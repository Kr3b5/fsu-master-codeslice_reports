Found 15/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof MMUnitAbstractNavigatorItem) {
        return;
    }
    MMUnitAbstractNavigatorItem abstractNavigatorItem = (MMUnitAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof MMUnitNavigatorItem) {
        navigatorView = ((MMUnitNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof MMUnitNavigatorGroup) {
        MMUnitNavigatorGroup navigatorGroup = (MMUnitNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof MMUnitNavigatorItem) {
            navigatorView = ((MMUnitNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public static void createLaunchConfigurations (IJavaProject javaProject, IFolder newFolder, String scenarioDirectory) {
    try {
        ILaunchManager launchManager = DebugPlugin.getDefault ().getLaunchManager ();
        ILaunchConfigurationType launchType = launchManager.getLaunchConfigurationType (IJavaLaunchConfigurationConstants.ID_JAVA_APPLICATION);
        ILaunchConfiguration [] launchConfigurations = launchManager.getLaunchConfigurations (launchType);
        DebugUIPlugin.getDefault ().getLaunchConfigurationManager ().getLaunchHistory ("org.eclipse.debug.ui.launchGroup.run");
        DebugUIPlugin.getDefault ().getLaunchConfigurationManager ().getLaunchHistory ("org.eclipse.debug.ui.launchGroup.debug");
        List classpath = new ArrayList ();
        for (int i = 0; i < launchConfigurations.length; i ++) {
            ILaunchConfiguration launchConfiguration = launchConfigurations [i];
            if (launchConfiguration.getName ().equals (javaProject.getElementName () + " Model")) {
                launchConfiguration.delete ();
                break;
            }
        }
        ILaunchConfigurationWorkingCopy launchConfigurationWorkingCopy = launchType.newInstance (newFolder, javaProject.getElementName () + " Model");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME, javaProject.getElementName ());
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME, "repast.simphony.runtime.RepastMain");
        Map < String, String > preferredLaunchers = new HashMap < String, String > ();
        preferredLaunchers.put (LAUNCH_DELEGATE_RUN, LOCAL_JAVA_LAUNCH_DELEGATE);
        preferredLaunchers.put (LAUNCH_DELEGATE_DEBUG, LOCAL_JAVA_LAUNCH_DELEGATE);
        launchConfigurationWorkingCopy.setAttribute (PREFERRED_LAUNCHERS, preferredLaunchers);
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, "\"${workspace_loc:" + javaProject.getElementName () + "}/" + scenarioDirectory + "\"");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_VM_ARGUMENTS, "-Xss10M -Xmx400M");
        List favoritesList = launchConfigurationWorkingCopy.getAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, (List) null);
        if (favoritesList == null) favoritesList = new ArrayList ();
        favoritesList.add (IDebugUIConstants.ID_DEBUG_LAUNCH_GROUP);
        favoritesList.add (IDebugUIConstants.ID_RUN_LAUNCH_GROUP);
        launchConfigurationWorkingCopy.setAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, favoritesList);
        IPath systemLibsPath = new Path (JavaRuntime.JRE_CONTAINER);
        IRuntimeClasspathEntry r = JavaRuntime.newRuntimeContainerClasspathEntry (systemLibsPath, IRuntimeClasspathEntry.STANDARD_CLASSES);
        r.setClasspathProperty (IRuntimeClasspathEntry.BOOTSTRAP_CLASSES);
        classpath.add (r.getMemento ());
        IPath jarPath = new Path (RepastLauncherClasspathContainer.JAR_CLASSPATH_DEFAULT);
        r = JavaRuntime.newRuntimeContainerClasspathEntry (jarPath, IRuntimeClasspathEntry.CONTAINER);
        r.setClasspathProperty (IRuntimeClasspathEntry.USER_CLASSES);
        classpath.add (r.getMemento ());
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_DEFAULT_CLASSPATH, false);
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_CLASSPATH, classpath);
        launchConfigurationWorkingCopy.doSave ();
        classpath.clear ();
        for (int i = 0; i < launchConfigurations.length; i ++) {
            ILaunchConfiguration launchConfiguration = launchConfigurations [i];
            if (launchConfiguration.getName ().equals ("Build Installer for " + javaProject.getElementName () + " Model")) {
                launchConfiguration.delete ();
                break;
            }
        }
        launchConfigurationWorkingCopy = launchType.newInstance (newFolder, "Build Installer for " + javaProject.getElementName () + " Model");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME, javaProject.getElementName ());
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME, "org.apache.tools.ant.launch.Launcher");
        launchConfigurationWorkingCopy.setAttribute (PREFERRED_LAUNCHERS, preferredLaunchers);
        if (SystemUtils.IS_OS_MAC) launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, "-buildfile \"${workspace_loc:" + javaProject.getElementName () + "}" + "/installer/installation_coordinator.xml\" -DoutputInstallationFile=\"" + "${folder_prompt:the Folder to output the installer (setup.jar) file}/setup.jar\" " + "-DEclipsePluginsDirectory=\"${eclipse_home}plugins\"" + "-DGroovyHomeDirectory=\"${groovy_home}\"" + " -DREPAST_VERSION=${REPAST_VERSION}");
        else if (SystemUtils.IS_OS_WINDOWS) launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, "-buildfile \"${workspace_loc:" + javaProject.getElementName () + "}" + "/installer/installation_coordinator.xml\" -DoutputInstallationFile=\"" + "${file_prompt:the Installer Output File Name:setup.jar}\" " + "-DEclipsePluginsDirectory=\"${eclipse_home}plugins\"" + "-DGroovyHomeDirectory=\"${groovy_home}\"" + " -DREPAST_VERSION=${REPAST_VERSION}");
        else launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, "-buildfile \"${workspace_loc:" + javaProject.getElementName () + "}" + "/installer/installation_coordinator.xml\" -DoutputInstallationFile=\"" + "${file_prompt:the Installer Output File Name:setup.jar}\" " + "-DEclipsePluginsDirectory=\"${eclipse_home}plugins\"" + "-DGroovyHomeDirectory=\"${groovy_home}\"" + " -DREPAST_VERSION=${REPAST_VERSION}");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_VM_ARGUMENTS, "-Xss10M -Xmx400M");
        favoritesList = launchConfigurationWorkingCopy.getAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, (List) null);
        if (favoritesList == null) favoritesList = new ArrayList ();
        favoritesList.add (IDebugUIConstants.ID_DEBUG_LAUNCH_GROUP);
        favoritesList.add (IDebugUIConstants.ID_RUN_LAUNCH_GROUP);
        launchConfigurationWorkingCopy.setAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, favoritesList);
        launchConfigurationWorkingCopy.doSave ();
        classpath.clear ();
        for (int i = 0; i < launchConfigurations.length; i ++) {
            ILaunchConfiguration launchConfiguration = launchConfigurations [i];
            if (launchConfiguration.getName ().equals ("Batch " + javaProject.getElementName () + " Model")) {
                launchConfiguration.delete ();
                break;
            }
        }
        launchConfigurationWorkingCopy = launchType.newInstance (newFolder, "Batch " + javaProject.getElementName () + " Model");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROJECT_NAME, javaProject.getElementName ());
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_MAIN_TYPE_NAME, "repast.simphony.runtime.RepastBatchMain");
        launchConfigurationWorkingCopy.setAttribute (PREFERRED_LAUNCHERS, preferredLaunchers);
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_PROGRAM_ARGUMENTS, "-params \"${file_prompt:the Batch Run Parameters File Name:params.xml}\"" + " \"${workspace_loc:" + javaProject.getElementName () + "}" + "/" + scenarioDirectory + "\"");
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_VM_ARGUMENTS, "-Xss10M -Xmx400M");
        favoritesList = launchConfigurationWorkingCopy.getAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, (List) null);
        if (favoritesList == null) favoritesList = new ArrayList ();
        favoritesList.add (IDebugUIConstants.ID_DEBUG_LAUNCH_GROUP);
        favoritesList.add (IDebugUIConstants.ID_RUN_LAUNCH_GROUP);
        launchConfigurationWorkingCopy.setAttribute (IDebugUIConstants.ATTR_FAVORITE_GROUPS, favoritesList);
        systemLibsPath = new Path (JavaRuntime.JRE_CONTAINER);
        r = JavaRuntime.newRuntimeContainerClasspathEntry (systemLibsPath, IRuntimeClasspathEntry.STANDARD_CLASSES);
        r.setClasspathProperty (IRuntimeClasspathEntry.BOOTSTRAP_CLASSES);
        classpath.add (r.getMemento ());
        jarPath = new Path (RepastLauncherClasspathContainer.JAR_CLASSPATH_DEFAULT);
        r = JavaRuntime.newRuntimeContainerClasspathEntry (jarPath, IRuntimeClasspathEntry.CONTAINER);
        r.setClasspathProperty (IRuntimeClasspathEntry.USER_CLASSES);
        classpath.add (r.getMemento ());
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_DEFAULT_CLASSPATH, false);
        launchConfigurationWorkingCopy.setAttribute (IJavaLaunchConfigurationConstants.ATTR_CLASSPATH, classpath);
        launchConfigurationWorkingCopy.doSave ();
        favoritesList = null;
    } catch (CoreException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=2=-----==

public void initPopupMenu () {
    pMenu = new JPopupMenu ("Data-Selection");
    JMenu subMenu = new JMenu ("Place new Extraction Form");
    JMenuItem eItem = new JMenuItem ("Polygon");
    eItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            setExtractionType (5);
            setExtractionMode (1);
        }
    }
    );
    subMenu.add (eItem);
    eItem = new JMenuItem ("Rectangle");
    eItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            setExtractionType (1);
            setExtractionMode (1);
        }
    }
    );
    subMenu.add (eItem);
    eItem = new JMenuItem ("Ellipse");
    eItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            setExtractionType (2);
            setExtractionMode (1);
        }
    }
    );
    subMenu.add (eItem);
    pMenu.add (subMenu);
    JMenuItem extrArrange = new JMenuItem ("Reshape");
    extrArrange.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            setExtractionMode (DataExtraction.SM_ARRANGE);
        }
    }
    );
    pMenu.add (extrArrange);
    extrVisibleMenu = new JMenuItem ("Show/Hide Shape");
    extrVisibleMenu.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            shapeVisible = ! shapeVisible;
        }
    }
    );
    pMenu.add (extrVisibleMenu);
    pMenu.addSeparator ();
    extrActionMenu = new JMenuItem ("Extract");
    extrActionMenu.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            extractionMode = EXTRACT;
            extractData ();
        }
    }
    );
    pMenu.add (extrActionMenu);
    excludeActionMenu = new JMenuItem ("Exclude");
    excludeActionMenu.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            extractionMode = EXCLUDE;
            extractData ();
        }
    }
    );
    pMenu.add (excludeActionMenu);
}


public static Resource openModel (Shell shell, String description, TransactionalEditingDomain editingDomain) {
    FileDialog fileDialog = new FileDialog (shell, SWT.OPEN);
    if (description != null) {
        fileDialog.setText (description);
    }
    fileDialog.open ();
    String fileName = fileDialog.getFileName ();
    if (fileName == null || fileName.length () == 0) {
        return null;
    }
    if (fileDialog.getFilterPath () != null) {
        fileName = fileDialog.getFilterPath () + File.separator + fileName;
    }
    URI uri = URI.createFileURI (fileName);
    Resource resource = null;
    try {
        resource = editingDomain.getResourceSet ().getResource (uri, true);
    } catch (WrappedException we) {
        SeaMonsterDiagramEditorPlugin.getInstance ().logError ("Unable to load resource: " + uri, we);
        MessageDialog.openError (shell, Messages.SeaMonsterDiagramEditorUtil_OpenModelResourceErrorDialogTitle, NLS.bind (Messages.SeaMonsterDiagramEditorUtil_OpenModelResourceErrorDialogMessage, fileName));
    }
    return resource;
}


-----Function Pair=3=-----==

public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=4=-----==

protected void setInput (IEditorInput input) {
    super.setInput (input);
    try {
        if (input instanceof NullEditorInput && StringUtil.isNotNull (((NullEditorInput) input).getToolTipText ())) {
            String path = ((NullEditorInput) input).getToolTipText ();
            URL url = FileLocator.find (ShapesPlugin.getDefault ().getBundle (), new Path (path), null);
            InputStream in = url.openStream ();
            diagram = (ShapesDiagram) xstream.fromXML (in);
            in.close ();
        }
        else {
            File file = ((IPathEditorInput) input).getPath ().toFile ();
            FileInputStream fis = new FileInputStream (file);
            diagram = (ShapesDiagram) xstream.fromXML (fis);
            fis.close ();
            setPartName (file.getName ());
        }
    } catch (Exception e) {
        handleLoadException (e);
    }
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    LinkedList < EditPart > editPartHolder = new LinkedList < EditPart > ();
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, editPartHolder) > 0) {
        EditPart editPart = editPartHolder.get (0);
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=5=-----==

protected void configureGraphicalViewer () {
    double [] zoomLevels;
    ArrayList < String > zoomContributions;
    super.configureGraphicalViewer ();
    GraphicalViewer viewer = getGraphicalViewer ();
    viewer.setEditPartFactory (new EditPartFactoryImpl ());
    ScalableFreeformRootEditPart rootEditPart = new ScalableFreeformRootEditPart ();
    viewer.setRootEditPart (rootEditPart);
    manager = rootEditPart.getZoomManager ();
    getActionRegistry ().registerAction (new ZoomInAction (manager));
    getActionRegistry ().registerAction (new ZoomOutAction (manager));
    zoomLevels = new double [] {0.1, 0.15, 0.25, 0.5, 0.75, 1.0, 1.5, 2.0};
    manager.setZoomLevels (zoomLevels);
    zoomContributions = new ArrayList < String > ();
    zoomContributions.add (ZoomManager.FIT_ALL);
    zoomContributions.add (ZoomManager.FIT_HEIGHT);
    zoomContributions.add (ZoomManager.FIT_WIDTH);
    manager.setZoomLevelContributions (zoomContributions);
    viewer.setProperty (MouseWheelHandler.KeyGenerator.getKey (SWT.CTRL), MouseWheelZoomHandler.SINGLETON);
    ContextMenuProvider provider = new GraphEditorContextMenuProvider (viewer, getActionRegistry ());
    viewer.setContextMenu (provider);
}


public void actionPerformed (ActionEvent arg0) {
    Vector < Integer > truev = new Vector < Integer > ();
    int plotno = 0;
    for (Boolean in : vp.getSelectionVector ()) {
        if (in.booleanValue () == true) {
            truev.add (plotno);
        }
        plotno ++;
    }
    plot.clearPlot ();
    for (Integer plno : truev) {
        plot.setDataGrid (plot.getDataGrid (), plno);
    }
    plot.repaint ();
}


-----Function Pair=6=-----==

protected void createMarker (int site, int type, Color color, String string) {
    if (markers [type] == null) return;
    int index = locationToIndex (site);
    markerApp = new Appearance ();
    markerApp.setColoringAttributes (new ColoringAttributes (new Color3f (color), ColoringAttributes.SHADE_FLAT));
    TransparencyAttributes ta = new TransparencyAttributes (TransparencyAttributes.FASTEST, 1f);
    ta.setCapability (TransparencyAttributes.ALLOW_VALUE_WRITE);
    markerApp.setTransparencyAttributes (ta);
    EventMarker marker = new EventMarker (0.03f, string);
    marker.setAppearance (markerApp);
    marker.setPickable (true);
    boolean internal = type != SUBSTITUTION;
    BranchGroup markerBranchGroup = segments [currentPos [index]].addMarker (site, marker, internal);
    transformGroups [currentPos [index]].addChild (markerBranchGroup);
    if (markers [type] [markerInds [type]] != null) markers [type] [markerInds [type]].detach ();
    markers [type] [markerInds [type]] = markerBranchGroup;
    markerInds [type] = (markerInds [type] + 1) % markers [type].length;
}


public void remove (int [] indices) {
    checkWidget ();
    if (indices == null) error (SWT.ERROR_NULL_ARGUMENT);
    if (indices.length == 0) return;
    int [] newIndices = new int [indices.length];
    System.arraycopy (indices, 0, newIndices, 0, indices.length);
    Element table = handle.childNodes [0];
    Element tbody = null;
    for (int i = 0; i < table.childNodes.length; i ++) {
        if ("TBODY".equals (table.childNodes [i].nodeName)) {
            tbody = table.childNodes [i];
            break;
        }
    }
    if (tbody == null) return;
    int start = newIndices [newIndices.length - 1], end = newIndices [0];
    int count = items.length;
    if (! (0 <= start && start <= end && end < count)) {
        return;
    }
    deselect (indices);
    TableItem [] newItems = new TableItem [count - 1];
    int last = - 1;
    for (int i = 0; i < newIndices.length; i ++) {
        int index = newIndices [i];
        if (index != last) {
            TableItem item = items [index];
            if (item != null) {
                item.releaseHandle ();
                System.arraycopy (items, 0, newItems, 0, index);
                System.arraycopy (items, index + 1, newItems, index, -- count - index);
                items = newItems;
                last = index;
            }
        }
    }
}


-----Function Pair=7=-----==

public static void main (String args []) throws Exception {
    PerfMonConfiguration config = new PerfMonConfiguration ();
    config.defineAppender ("Basic", TextAppender.class.getName (), "10 seconds");
    String monitorName = ExtremeExample.class.getName ();
    String stringClassMonitor = "java.lang.String";
    String objectClassMonitor = "java.lang.Object";
    config.defineMonitor (monitorName);
    config.defineMonitor (stringClassMonitor);
    config.defineMonitor (objectClassMonitor);
    config.attachAppenderToMonitor (monitorName, "Basic", PerfMon.APPENDER_PATTERN_PARENT_AND_ALL_DESCENDENTS);
    config.attachAppenderToMonitor (stringClassMonitor, "Basic", PerfMon.APPENDER_PATTERN_PARENT_ONLY);
    config.attachAppenderToMonitor (objectClassMonitor, "Basic", PerfMon.APPENDER_PATTERN_PARENT_ONLY);
    PerfMon.configure (config);
    launchSamplers (ExtremeExample.class);
}


private static int [] getVizinhos (int id) {
    int [] vizinhosTemp = new int [3];
    int j = 0;
    for (int i = 0; i < distancias.length; i += 3) {
        if (id == distancias [i]) {
            vizinhosTemp [j] = distancias [i + 1];
            j ++;
        }
        else if (id == distancias [i + 1]) {
            vizinhosTemp [j] = distancias [i];
            j ++;
        }
    }
    int [] vizinhos = new int [j];
    for (int i = 0; i < j; i ++) {
        vizinhos [i] = vizinhosTemp [i];
    }
    return vizinhos;
}


-----Function Pair=8=-----==

public String getResultText () {
    NumberFormat fmt = NumberFormat.getInstance ();
    fmt.setMaximumFractionDigits (3);
    StringBuffer stb = new StringBuffer ();
    stb.append ("Number of Values found " + String.valueOf (numberOfOutliers));
    stb.append ("\nMin :" + min);
    stb.append ("\nCut :" + fmt.format (heightCut) + " (" + fmt.format (heightPercentage) + " %)");
    stb.append ("\nMax :" + max);
    stb.append ("\n10 Values with lowest PMatrix Height:");
    for (int i = 0; i < Math.min (sortedArray.size (), 10); i ++) {
        Sortable s = (Sortable) sortedArray.elementAt (i);
        IBestMatch object_key = (IBestMatch) s.getObject ();
        Double integer_object = (Double) s.getKey ();
        stb.append ("\nIndex : " + object_key.getIndex () + " with " + integer_object);
    }
    return stb.toString ();
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=9=-----==

private static final void sort (Vec a, Vec b, CompareFunc c, int start, int end) {
    Object tmpa, tmpb = null;
    if (start >= end) return;
    if (end - start <= 6) {
        for (int i = start + 1; i <= end; i ++) {
            tmpa = a.store [i];
            if (b != null) tmpb = b.store [i];
            int j;
            for (j = i - 1; j >= start; j --) {
                if (c.compare (a.store [j], tmpa) <= 0) break;
                a.store [j + 1] = a.store [j];
                if (b != null) b.store [j + 1] = b.store [j];
            }
            a.store [j + 1] = tmpa;
            if (b != null) b.store [j + 1] = tmpb;
        }
        return;
    }
    Object pivot = a.store [end];
    int lo = start - 1;
    int hi = end;
    do {
        while (c.compare (a.store [++ lo], pivot) < 0) {
        }
        while ((hi > lo) && c.compare (a.store [-- hi], pivot) > 0) {
        }
        swap (a, lo, hi);
        if (b != null) swap (b, lo, hi);
    }
    while (lo < hi);
    swap (a, lo, end);
    if (b != null) swap (b, lo, end);
    sort (a, b, c, start, lo - 1);
    sort (a, b, c, lo + 1, end);
}


protected void renderNode (TreeView.Node node, PrintWriter writer, int level, int openNodeDepth, String formPrefix) {
    writer.print ("    <tr");
    if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
    writer.println (">");
    TreeView.Node [] taxonomy = new Node [level];
    taxonomy [level - 1] = node;
    for (int i = level - 2; i >= 0; i --) taxonomy [i] = taxonomy [i + 1].getParent ();
    int colSpans = 0;
    for (int i = 1; i < taxonomy.length; i ++) {
        if (i == level - 1) {
            if (colSpans > 0) {
                writer.print ("        <td");
                if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
                if (colSpans > 1) writer.print (" colspan='" + colSpans + "'");
                writer.println ("></td>");
                colSpans = 0;
            }
            if (node.getChildren ().size () > 0) {
                writer.print ("        <td");
                if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
                writer.print (" align=center>");
                writer.print ("<input type='image' src='");
                writer.print (getImagePath ());
                if (node.isOpened ()) writer.print ("open_arrow.png");
                else writer.print ("closed_arrow.png");
                writer.print ("' name='" + formPrefix + (node.isOpened () ? "close" : "open") + "." + node.resolvePath () + "'>");
                writer.println ("</td>");
            }
            else {
                colSpans ++;
            }
        }
        else colSpans ++;
    }
    if (colSpans > 0) {
        writer.print ("        <td");
        if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
        if (colSpans > 1) writer.print (" colspan='" + colSpans + "'");
        writer.println ("></td>");
        colSpans = 0;
    }
    writer.print ("        <td");
    if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
    writer.print (">");
    if (((Node) node).isSelectable ()) writer.print ("<input type='image' name='" + formPrefix + "select." + node.resolvePath () + "' src='");
    else writer.print ("<img src='");
    writer.print (node.getIconPath ());
    writer.println ("'></td>");
    writer.print ("        <td width=100%");
    if (getSelectedNode () == node) writer.print (getSelectedNodeBackgroundColor ());
    int spanToEnd = openNodeDepth - taxonomy.length + 2;
    if (spanToEnd > 0) writer.print (" colspan='" + String.valueOf (spanToEnd) + "'");
    writer.print ("><font size='-2'");
    if (getSelectedNode () == node) writer.print (" color='#ffffff'");
    writer.print (">&nbsp;");
    writer.print (node.getText ());
    writer.println ("&nbsp;</font></td>");
    writer.println ("    </tr>");
    if (node.isOpened ()) for (int i = 0; i < node.getChildren ().size (); i ++) renderNode (node.getChildren ().get (i), writer, level + 1, openNodeDepth, formPrefix);
}


-----Function Pair=10=-----==

public void renderHexDescriptor (String label, byte [] data, final JPanel destination) {
    String hex = ByteArrayHelper.toHexString (data);
    final JTextArea ta = new JTextArea (hex);
    ta.setOpaque (false);
    ta.setLineWrap (true);
    ta.setWrapStyleWord (false);
    ta.setEditable (false);
    ta.setBorder (BorderFactory.createTitledBorder (label));
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            destination.add (ta);
            destination.validate ();
            destination.repaint ();
        }
    }
    );
}


public boolean isGameComplete () {
    if (super.isGameComplete ()) {
        return true;
    }
    boolean closed [] = new boolean [getNumPlayers () + 1];
    boolean allClosed = true;
    for (int i = 1; i < getNumPlayers () + 1; i ++) {
        closed [i] = hasPlayerClosedAll (getPlayer (i));
    }
    closed : for (int i = 1; i < closed.length; i ++) {
        if (closed [i]) {
            int score = getTotalScore (i);
            checkScores : for (int j = 1; j < getNumPlayers () + 1; j ++) {
                if (i == j) {
                    continue checkScores;
                }
                if (score == getTotalScore (j)) {
                    if (closed [j] == true) {
                        continue closed;
                    }
                }
                else if (score < getTotalScore (j)) {
                    continue closed;
                }
            }
            setWinner (getPlayer (i));
            return true;
        }
    }
    return false;
}


-----Function Pair=11=-----==

public static double [] doubleFromCharacterTrait (Trait trait, String [] textdata) {
    TreeSet < String > dataset = new TreeSet < String > ();
    int n = textdata.length;
    double [] dbldata = new double [n];
    for (String str : textdata) {
        if (! missingPattern.matcher (str).matches () && ! str.contains ("?")) dataset.add (str);
    }
    String [] levelNames = new String [dataset.size ()];
    dataset.toArray (levelNames);
    for (int i = 0; i < n; i ++) {
        dbldata [i] = Arrays.binarySearch (levelNames, textdata [i]);
        if (dbldata [i] < - 0.1) dbldata [i] = Double.NaN;
    }
    trait.setProperty (Trait.PROP_LEVEL_LABELS, levelNames);
    return dbldata;
}


void process (List < Object [] > ret, List < Object [] > children, Object obj) {
    if (children == null) {
        Object [] da = new Object [1];
        da [0] = obj;
        ret.add (da);
    }
    else {
        for (Object [] cr : children) {
            Object [] rr = new Object [cr.length + 1];
            rr [0] = obj;
            for (int i = 0; i < cr.length; i ++) {
                rr [i + 1] = cr [i];
            }
            ret.add (rr);
        }
    }
}


-----Function Pair=12=-----==

public Decimal multiply (int x) {
    int r;
    int rh;
    int rl;
    int excp;
    int lostdigit;
    Decimal result = newInstance (this);
    if (nans != FINITE) {
        if (nans == QNAN || nans == SNAN) {
            return this;
        }
        if (nans == INFINITE && x != 0) {
            result = newInstance (this);
            return result;
        }
        if (nans == INFINITE && x == 0) {
            ieeeFlags |= FLAG_INVALID;
            result = newInstance (ZERO);
            result.nans = QNAN;
            result = dotrap (FLAG_INVALID, "multiply", newInstance (ZERO), result);
            return result;
        }
    }
    if (x < 0 || x >= radix) {
        ieeeFlags |= FLAG_INVALID;
        result = newInstance (ZERO);
        result.nans = QNAN;
        result = dotrap (FLAG_INVALID, "multiply", result, result);
        return result;
    }
    rh = 0;
    for (int i = 0; i < DIGITS; i ++) {
        r = mant [i] * x + rh;
        rl = r % radix;
        rh = r / radix;
        result.mant [i] = rl;
    }
    lostdigit = 0;
    if (rh != 0) {
        lostdigit = result.mant [0];
        result.shiftRight ();
        result.mant [DIGITS - 1] = rh;
    }
    if (result.mant [DIGITS - 1] == 0) {
        result.exp = 0;
    }
    excp = result.round (lostdigit);
    if (excp != 0) {
        result = dotrap (excp, "multiply", result, result);
    }
    return result;
}


public static void main (String [] arg) {
    int n = 10;
    double a = 0;
    double b = 1;
    double h = (b - a) / n;
    System.out.println ("Node amount: " + n);
    System.out.println ("a = " + a);
    System.out.println ("b = " + b);
    System.out.println ("h = " + h);
    System.out.println ();
    preciseApprCoeff (n, a, h);
    Vector apprSolution = driving (n);
    apprSolution.print ();
    System.out.println ();
    Vector solution = getPreciseSolution (n, a, h);
    solution.print ();
    System.out.println ();
    solution.add (apprSolution.multiply (- 1)).print ();
    System.out.println ();
    System.out.println (solution.add (apprSolution.multiply (- 1)).norm ());
}


-----Function Pair=13=-----==

private int nextNBits (int bitsToGet) {
    byte b, next, next2next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = data [bp + 1];
            next2next = 0x00;
        }
        else {
            next = data [bp + 1];
            next2next = data [bp + 2];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = flipTable [data [bp + 2] & 0xff];
        }
    }
    else {
        throw new Error (JaiI18N.getString ("TIFFFaxDecoder7"));
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int bitsFromNext2NextByte = 0;
    if (bitsFromNextByte > 8) {
        bitsFromNext2NextByte = bitsFromNextByte - 8;
        bitsFromNextByte = 8;
    }
    bytePointer ++;
    int i1 = (b & table1 [bitsLeft]) << (bitsToGet - bitsLeft);
    int i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
    int i3 = 0;
    if (bitsFromNext2NextByte != 0) {
        i2 <<= bitsFromNext2NextByte;
        i3 = (next2next & table2 [bitsFromNext2NextByte])>>> (8 - bitsFromNext2NextByte);
        i2 |= i3;
        bytePointer ++;
        bitPointer = bitsFromNext2NextByte;
    }
    else {
        if (bitsFromNextByte == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
        else {
            bitPointer = bitsFromNextByte;
        }
    }
    int i = i1 | i2;
    return i;
}


public void saveCurrent () {
    yvaluestemp = new double [currentyvalues.length];
    xvaluestemp = new double [xphase.length];
    x1temp = new double [x1.length];
    if (! linearplot) yvaluestemp = logdata;
    else yvaluestemp = currentyvalues;
    xvaluestemp = xphase;
    x1temp = x1;
    if (dataHasBeenFit) {
        xfittemp = new double [xfit.length];
        yfittemp = new double [yfit.length];
        xfittemp = xfit;
        if (! linearplot) yfittemp = ylogfit;
        else yfittemp = yfit;
    }
    rmstemp = rms;
    sigmatemp = sigma;
    centertemp = center;
    t1temp = t1;
    t2temp = t2;
    amptemp = amp;
}


-----Function Pair=14=-----==

private void processFontCache (RdpPacket_Localised data) throws RdesktopException {
    Glyph glyph = null;
    int font = 0, nglyphs = 0;
    int character = 0, offset = 0, baseline = 0, width = 0, height = 0;
    int datasize = 0;
    byte [] fontdata = null;
    font = data.get8 ();
    nglyphs = data.get8 ();
    for (int i = 0; i < nglyphs; i ++) {
        character = data.getLittleEndian16 ();
        offset = data.getLittleEndian16 ();
        baseline = data.getLittleEndian16 ();
        width = data.getLittleEndian16 ();
        height = data.getLittleEndian16 ();
        datasize = (height * ((width + 7) / 8) + 3) & ~ 3;
        fontdata = new byte [datasize];
        data.copyToByteArray (fontdata, 0, data.getPosition (), datasize);
        data.incrementPosition (datasize);
        glyph = new Glyph (font, character, offset, baseline, width, height, fontdata);
        cache.putFont (glyph);
    }
}


public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
    if (! value.equals ("remove")) {
        setIcon (null);
        setEnabled (false);
        return this;
    }
    setIcon (MainFrame.getIcon ("delete.gif"));
    setEnabled (true);
    if (isSelected && hasFocus) {
        setSelected (true);
        for (int row2 = row + 1; row2 < numShortcuts; row2 ++) {
            for (int col2 = 0; col2 < columnNames.length; col2 ++) {
                shortcuts [row2 - 1] [col2] = shortcuts [row2] [col2];
                if (row2 == numShortcuts - 1) {
                    shortcuts [row2] [col2] = null;
                }
            }
        }
        numShortcuts --;
        ((FeatureManagerTableModel) table.getModel ()).fireTableStructureChanged ();
    }
    return this;
}


-----Function Pair=15=-----==

public static String updateAntibody (AntibodyBean bean, UserBean userBean, DBUtil bioRoot) {
    if (bean.isNameChanged ()) {
        log.error ("Updating Antibody...Name has changed!");
        if (Misc.isEmpty (bean.getName ())) {
            return "You must provide a antibody text.";
        }
        if (bean.isAntibodyNameUnique (bioRoot) == false) {
            log.error ("Name is not unique!");
            return "That antibody text is in use, choose another.";
        }
    }
    if (Misc.isNotEmpty (bean.getFileName ()) && bean.getFileName ().startsWith ("temp")) {
        File tmp = new File (Util.filepath + "Upload/AntibodyFiles/" + bean.getFileName ());
        File real = new File ((Util.filepath + "Upload/AntibodyFiles/" + bean.getFileName ().substring (4)));
        tmp.renameTo (real);
        bean.setFileName (real.getName ());
    }
    if (Misc.isNotEmpty (bean.getOrganismName (bioRoot))) {
        bean.setOrganismId (bioRoot.getOrganismId (bean.getOrganismName (bioRoot)));
    }
    else bean.setOrganismId (0);
    if (Misc.isNotEmpty (bean.getGeneName (bioRoot))) {
        bean.setGeneId (bioRoot.getGeneId (bean.getGeneName (bioRoot), userBean.getLabGroupId ()));
    }
    else bean.setGeneId (0);
    if (bean.updateOld (bioRoot, userBean)) {
        bean.setMessages ("Saved");
        bean.setComplete (true);
        bean.setNameChanged (false);
        if (Misc.isNotEmpty (bean.getOldFileName ())) {
            File tmp = new File (Util.filepath + "Upload/AntibodyFiles/" + bean.getOldFileName ());
            tmp.delete ();
        }
        return "";
    }
    else {
        File tmp = new File (Util.filepath + "Upload/AntibodyFiles/" + bean.getFileName ());
        tmp.delete ();
        return "An error occured while attempting to update a antibody. Please " + "contact BioRoot ASAP! (TimeStamp: " + new java.util.Date () + ")<br>";
    }
}


void store () {
    int start = 0;
    int length = inLength;
    int blockLength;
    int BFINAL = 0x00;
    while (length > 0) {
        if (length < 65535) {
            blockLength = length;
            BFINAL = 0x01;
        }
        else {
            blockLength = 65535;
            BFINAL = 0x00;
        }
        bytes.write ((byte) BFINAL);
        writeShortLSB (bytes, blockLength);
        writeShortLSB (bytes, blockLength ^ 0xffff);
        bytes.write (in, start, blockLength);
        length = length - blockLength;
        start = start + blockLength;
    }
}


-----Function Pair=16=-----==

public void deselect (int start, int end) {
    checkWidget ();
    int count = items.length;
    if (start == 0 && end == count - 1) {
        deselectAll ();
    }
    else {
        start = Math.max (0, start);
        int [] indices = new int [end - start + 1];
        for (int i = start; i <= end; i ++) {
            items [i].showSelection (false);
            indices [i - start] = i;
        }
        removeFromSelection (indices);
    }
}


public static Object concatP (Class < ? > type, Object...arrays) {
    if (arrays.length == 0) return Array.newInstance (type, 0);
    if (arrays.length == 1) return arrays [0];
    int size = 0;
    int [] sizes = new int [arrays.length];
    for (int a = 0; a < arrays.length; a ++) {
        sizes [a] = Array.getLength (arrays [a]);
        size += sizes [a];
    }
    Object ret = Array.newInstance (type, size);
    int aLen = 0;
    for (int a = 0; a < arrays.length; a ++) {
        System.arraycopy (arrays [a], 0, ret, aLen, sizes [a]);
        aLen += sizes [a];
    }
    return ret;
}


-----Function Pair=17=-----==

private DatumRange getDatumRangeFor (String filename) {
    if (fieldHandlers.length == 0) {
        return DatumRange.newDatumRange (- 1e30, 1e30, Units.mj1958);
    }
    TimeUtil.TimeStruct ts1 = new TimeUtil.TimeStruct ();
    ts1.year = 0;
    ts1.day = 0;
    ts1.month = 1;
    ts1.doy = 0;
    ts1.hour = 0;
    ts1.minute = 0;
    ts1.seconds = 0;
    TimeUtil.TimeStruct ts2 = new TimeUtil.TimeStruct ();
    if (File.separatorChar == '\\') filename = filename.replaceAll ("\\\\", "/");
    Matcher m = pattern.matcher (filename);
    if (m.matches ()) {
        for (int i = 0; i < fieldHandlers.length; i ++) {
            String s = m.group (i + 1);
            fieldHandlers [i].handle (s, ts1, ts2);
        }
        if (ts1.doy == 0 && ts1.day == 0) ts1.day = 1;
        TimeUtil.normalize (ts1);
        if (copyToEndTime [1]) ts2.year = ts1.year;
        if (copyToEndTime [2]) ts2.month = ts1.month;
        if (copyToEndTime [3]) ts2.day = ts1.day;
        if (copyToEndTime [4]) ts2.doy = ts1.doy;
        if (copyToEndTime [5]) ts2.hour = ts1.hour;
        if (copyToEndTime [6]) ts2.minute = ts1.minute;
        if (copyToEndTime [7]) ts2.seconds = ts1.seconds;
        Datum s1 = TimeUtil.toDatum (ts1);
        Datum s2 = TimeUtil.next (timeWidth, TimeUtil.toDatum (ts2));
        for (int ii = 1; ii < timeWidthMultiplier; ii ++) {
            s2 = TimeUtil.next (timeWidth, s2);
        }
        DatumRange dr = new DatumRange (s1, s2);
        return dr;
    }
    else {
        throw new IllegalArgumentException ("file name (" + filename + ") doesn't match model specification (" + regex + ")");
    }
}


private int [] doAbsorbingRandowWalk (final Matrix mP, int highest) {
    final int size = mP.numRows ();
    final int [] ranking = new int [size];
    ranking [0] = highest;
    final int [] map = new int [size];
    for (int i = 0; i < highest; ++ i) map [i] = i;
    for (int i = highest; i < size - 1; ++ i) map [i] = i + 1;
    for (int absorbed = 1; absorbed < size; ++ absorbed) {
        System.out.println ("absorbed " + absorbed);
        final int sizeOfQ = size - absorbed;
        final Matrix mIminusQ = new DenseMatrix (sizeOfQ, sizeOfQ);
        for (int i = 0; i < sizeOfQ; ++ i) for (int j = 0; j < sizeOfQ; ++ j) mIminusQ.set (i, j, (i == j ? 1.0 : 0.0) - mP.get (map [i], map [j]));
        final Matrix mI = Matrices.identity (sizeOfQ);
        final Matrix mN = mI.copy ();
        mIminusQ.solve (mI, mN);
        final Vector v = new DenseVector (sizeOfQ);
        for (int i = 0; i < sizeOfQ; ++ i) {
            for (int j = 0; j < sizeOfQ; ++ j) v.add (i, mN.get (i, j));
            v.set (i, v.get (i) / sizeOfQ);
        }
        highest = findHighestRanked (v);
        ranking [absorbed] = map [highest];
        for (int i = highest; i < size - 1; ++ i) map [i] = map [i + 1];
    }
    return ranking;
}


-----Function Pair=18=-----==

private CardSet (JPanel mainPanel) {
    log = org.apache.log4j.Category.getInstance (CardSet.class);
    log.debug ("initializing");
    codeSet = new Card [9];
    programSet = new Card [5];
    EventController.getInstance ().addIssueCardsListener (this);
    mainPane = ((GameDialog) mainPanel).getMainPane ();
    if (mainPane == null) log.error ("mainPane is NULL");
    try {
        createPanes ();
        createBackgrounds ();
        mainPane.add (programSetPane, new Integer (51));
        mainPane.add (codeSetPane, new Integer (52));
        createButtons ();
    } catch (ResourceException e) {
        log.error (e, e);
    }
    log.debug ("initializing done");
}


public void showDialog (int x, int y) {
    JFrame dummyFrame = new JFrame ();
    JDialog dialog = new JDialog (dummyFrame, "Data Range Configuer", true);
    JButton actionButton;
    JButton resetButton;
    dialog.setLocation (x, y);
    dialog.setSize (300, 150);
    dialog.getContentPane ().setLayout (new GridLayout (5, 2));
    xAxisMinField.setText (Double.toString (xAxisExtents [0]));
    xAxisMaxField.setText (Double.toString (xAxisExtents [1]));
    yAxisMinField.setText (Double.toString (yAxisExtents [0]));
    yAxisMaxField.setText (Double.toString (yAxisExtents [1]));
    actionButton = new JButton ("OK");
    actionButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            try {
                actionButton_actionPerformed (e);
            } catch (Exception exception) {
            }
        }
    }
    );
    resetButton = new JButton ("Reset");
    resetButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            resetButton_actionPerformed (e);
        }
    }
    );
    dialog.getContentPane ().add (new JLabel ((attributeXName + " Min")));
    dialog.getContentPane ().add (xAxisMinField);
    dialog.getContentPane ().add (new JLabel ((attributeXName + " Max")));
    dialog.getContentPane ().add (xAxisMaxField);
    dialog.getContentPane ().add (new JLabel ((attributeYName + " Min")));
    dialog.getContentPane ().add (yAxisMinField);
    dialog.getContentPane ().add (new JLabel ((attributeYName + " Max")));
    dialog.getContentPane ().add (yAxisMaxField);
    dialog.getContentPane ().add (actionButton);
    dialog.getContentPane ().add (resetButton);
    dialog.setVisible (true);
}


-----Function Pair=19=-----==

public static String getSimpleTableHtmlStringForGraphs (String [] strs, String alignment, int numOfImagesInRow) {
    int number = 2;
    if (numOfImagesInRow > 0) {
        number = numOfImagesInRow;
    }
    String align = "center";
    if ((alignment != null) && (! "".equalsIgnoreCase (alignment))) {
        align = alignment;
    }
    boolean isClosed = true;
    int numToBeFilled = (strs.length) % number;
    if (strs.length <= numOfImagesInRow) {
        numToBeFilled = 0;
    }
    String table = "<table class=\"details\" border=\"0\" cellpadding=\"5\" cellspacing=\"2\" width=\"95%\">\n";
    if (strs != null) {
        for (int i = 0; i < strs.length; i ++) {
            if (i == 0) {
                table = table + "<tr valign=\"top\">\n";
                table = table + "<td> <" + align + "> <img src=\"" + strs [i] + "\"> </" + align + "> </td>\n";
                isClosed = false;
            }
            else {
                if ((i + 1) % number == 0) {
                    table = table + "<td> <" + align + "> <img src=\"" + strs [i] + "\"> </" + align + "> </td>\n";
                    table = table + "</tr>\n";
                    isClosed = true;
                }
                else {
                    table = table + "<td> <" + align + "> <img src=\"" + strs [i] + "\"> </" + align + "> </td>\n";
                    isClosed = false;
                }
            }
        }
        if (! isClosed) {
            for (int i = 0; i < numToBeFilled; i ++) {
                table = table + "<td> </td>\n";
            }
            table = table + "</tr>\n";
        }
    }
    table = table + "</table> \n";
    return table;
}


public void NotifyESR () {
    long ESRval = Memory.real_readd (Memory.RealSeg (ECBAddr), Memory.RealOff (ECBAddr) + 4);
    if (ESRval != 0 || databuffer != null) {
        if (prevECB == null) {
            ECBList = nextECB;
            if (ECBList != null) ECBList.prevECB = null;
        }
        else {
            prevECB.nextECB = nextECB;
            if (nextECB != null) nextECB.prevECB = prevECB;
        }
        nextECB = null;
        if (ESRList == null) {
            ESRList = this;
            prevECB = null;
        }
        else {
            ECBClass useECB = ESRList;
            while (useECB.nextECB != null) useECB = useECB.nextECB;
            useECB.nextECB = this;
            prevECB = useECB;
        }
        isInESRList = true;
        Pic.PIC_ActivateIRQ (11);
    }
    else close ();
}


-----Function Pair=20=-----==

private Tube subdivideTubeApprox (double tol) {
    Tube t = this;
    MeshVertex newvert [];
    float news [];
    int i, j, p1, p2, p3, p4, count;
    int numParam = (texParam == null ? 0 : texParam.length);
    double newt [], param [] [], newparam [] [], paramTemp [] = new double [numParam], tol2 = tol * tol;
    boolean refine [], newrefine [];
    param = new double [t.vertex.length] [numParam];
    for (i = 0; i < numParam; i ++) {
        if (paramValue [i] instanceof VertexParameterValue) {
            double val [] = ((VertexParameterValue) paramValue [i]).getValue ();
            for (j = 0; j < val.length; j ++) param [j] [i] = val [j];
        }
    }
    refine = new boolean [t.vertex.length];
    if (t.closed) {
        for (i = 0; i < refine.length; i ++) refine [i] = true;
        count = refine.length;
    }
    else {
        for (i = 1; i < refine.length - 1; i ++) refine [i] = true;
        count = refine.length - 1;
    }
    int iterations = 0;
    do {
        int len = t.vertex.length;
        newvert = new MeshVertex [len + count];
        news = new float [len + count];
        newt = new double [len + count];
        newparam = new double [len + count] [numParam];
        newrefine = new boolean [len + count];
        for (i = 0, j = 0; j < len; j ++) {
            p1 = j - 1;
            if (p1 < 0) p1 = (t.closed ? len - 1 : 0);
            p2 = j;
            p3 = j + 1;
            if (p3 >= len) p3 = (t.closed ? p3 - len : len - 1);
            if (! refine [j]) {
                newvert [i] = t.vertex [j];
                newt [i] = t.thickness [j];
                news [i] = t.smoothness [j];
                newparam [i] = param [j];
            }
            else {
                newvert [i] = SplineMesh.calcApproxPoint (t.vertex, t.smoothness, param, paramTemp, p1, p2, p3);
                newt [i] = calcApproxThickness (t.thickness, t.smoothness, p1, p2, p3);
                news [i] = t.smoothness [j] * 2.0f;
                if (news [i] > 1.0f) news [i] = 1.0f;
                for (int k = 0; k < numParam; k ++) newparam [i] [k] = paramTemp [k];
            }
            i ++;
            if (! refine [p2] && ! refine [p3]) continue;
            newvert [i] = MeshVertex.blend (t.vertex [p2], t.vertex [p3], 0.5, 0.5);
            newt [i] = 0.5 * (t.thickness [p2] + t.thickness [p3]);
            news [i] = 1.0f;
            for (int k = 0; k < numParam; k ++) newparam [i] [k] = 0.5 * (param [p2] [k] + param [p3] [k]);
            if (newvert [i - 1].r.distance2 (t.vertex [j].r) > tol2) {
                if (newvert [i].r.distance2 (newvert [i - 1].r) > tol2 && (i < 2 || newvert [i - 1].r.distance2 (newvert [i - 2].r) > tol2)) {
                    newrefine [i] = newrefine [i - 1] = true;
                    if (i > 1) newrefine [i - 2] = true;
                }
            }
            i ++;
        }
        count = 0;
        for (j = 0; j < newrefine.length - 1; j ++) if (newrefine [j] || newrefine [j + 1]) count ++;
        if (t.closed && (newrefine [newrefine.length - 1] || newrefine [0])) count ++;
        t = new Tube (newvert, news, newt, t.smoothingMethod, t.endsStyle);
        param = newparam;
        refine = newrefine;
        iterations ++;
    }
    while (count > 0 && iterations < MAX_SUBDIVISIONS);
    t.copyTextureAndMaterial (this);
    for (i = 0; i < numParam; i ++) {
        if (paramValue [i] instanceof VertexParameterValue) {
            double val [] = new double [t.vertex.length];
            for (j = 0; j < val.length; j ++) val [j] = param [j] [i];
            t.paramValue [i] = new VertexParameterValue (val);
        }
    }
    return t;
}


BufferedImage getImage (String file) {
    try {
        loadTGA (new File (file));
    } catch (Exception e) {
        e.printStackTrace ();
    }
    int pixel [] = new int [imageWidth * imageHeight];
    int z = 0;
    int red, green, blue, alpha;
    int startX = 0, maxX = 0, startY = 0, maxY = 0, xInc = 1, yInc = 1;
    switch (texFormat) {
        case BOTTOM_LEFT_ORIGIN :
            {
                startX = 0;
                startY = 0;
                maxX = imageWidth - 1;
                maxY = imageHeight - 1;
                break;
            }
        case BOTTOM_RIGHT_ORIGIN :
            {
                startX = imageWidth - 1;
                startY = 0;
                maxX = - 1;
                maxY = imageHeight - 1;
                xInc = - 1;
                break;
            }
        case TOP_LEFT_ORIGIN :
            {
                startX = 0;
                startY = imageHeight - 1;
                maxX = imageWidth - 1;
                maxY = - 1;
                yInc = - 1;
                break;
            }
        case TOP_RIGHT_ORIGIN :
            {
                startX = imageWidth - 1;
                startY = imageHeight - 1;
                maxX = - 1;
                maxY = - 1;
                xInc = - 1;
                yInc = - 1;
                break;
            }
    }
    if (iBits == 32) {
        for (int i = startX; i != maxX; i += xInc) {
            for (int j = startY; j != maxY; j += yInc) {
                red = imageData [(j * 4) + (i * (maxY * 4))] & 0xff;
                green = imageData [(j * 4) + (i * (maxY * 4)) + 1] & 0xff;
                blue = imageData [(j * 4) + (i * (maxY * 4)) + 2] & 0xff;
                alpha = imageData [(j * 4) + (i * (maxY * 4)) + 3] & 0xff;
                pixel [z ++] = (alpha << 24) | (red << 16) | (green << 8) | blue;
            }
        }
    }
    if (iBits == 24) {
        for (int i = startX; i != maxX; i += xInc) {
            for (int j = startY; j != maxY; j += yInc) {
                red = imageData [(j * 3) + (i * (maxY * 3))] & 0xff;
                green = imageData [(j * 3) + (i * (maxY * 3)) + 1] & 0xff;
                blue = imageData [(j * 3) + (i * (maxY * 3)) + 2] & 0xff;
                pixel [z ++] = (255 << 24) | (red << 16) | (green << 8) | blue;
            }
        }
    }
    if (iBits == 8) {
        for (int i = startX; i != maxX; i += xInc) {
            for (int j = startY; j != maxY; j += yInc) {
                red = imageData [(j * 3) + (i * (maxY * 3))] & 0xff;
                green = imageData [(j * 3) + (i * (maxY * 3)) + 1] & 0xff;
                blue = imageData [(j * 3) + (i * (maxY * 3)) + 2] & 0xff;
                pixel [z ++] = (255 << 24) | (red << 16) | (green << 8) | blue;
            }
        }
    }
    Toolkit tk = Toolkit.getDefaultToolkit ();
    Image im = tk.createImage (new MemoryImageSource (imageWidth, imageHeight, pixel, 0, imageWidth));
    BufferedImage ima = new BufferedImage (imageWidth, imageHeight, BufferedImage.TYPE_INT_RGB);
    Graphics g = ima.getGraphics ();
    g.drawImage (im, 0, 0, null);
    for (int x = 0; x < imageWidth; x ++) {
        for (int y = 0; y < imageHeight / 2; y ++) {
            Color c = new Color (ima.getRGB (x, y));
            Color d = new Color (ima.getRGB (x, imageHeight - 1 - y));
            g.setColor (d);
            g.drawLine (x, y, x, y);
            g.setColor (c);
            g.drawLine (x, imageHeight - y, x, imageHeight - y);
        }
    }
    return ima;
}


-----Function Pair=21=-----==

void filterRow (byte [] row, byte [] previousRow, int filterType) {
    int byteOffset = headerChunk.getFilterByteOffset ();
    switch (filterType) {
        case PngIhdrChunk.FILTER_NONE :
            break;
        case PngIhdrChunk.FILTER_SUB :
            for (int i = byteOffset; i < row.length; i ++) {
                int current = row [i] & 0xFF;
                int left = row [i - byteOffset] & 0xFF;
                row [i] = (byte) ((current + left) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_UP :
            for (int i = 0; i < row.length; i ++) {
                int current = row [i] & 0xFF;
                int above = previousRow [i] & 0xFF;
                row [i] = (byte) ((current + above) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_AVERAGE :
            for (int i = 0; i < row.length; i ++) {
                int left = (i < byteOffset) ? 0 : row [i - byteOffset] & 0xFF;
                int above = previousRow [i] & 0xFF;
                int current = row [i] & 0xFF;
                row [i] = (byte) ((current + ((left + above) / 2)) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_PAETH :
            for (int i = 0; i < row.length; i ++) {
                int left = (i < byteOffset) ? 0 : row [i - byteOffset] & 0xFF;
                int aboveLeft = (i < byteOffset) ? 0 : previousRow [i - byteOffset] & 0xFF;
                int above = previousRow [i] & 0xFF;
                int a = Math.abs (above - aboveLeft);
                int b = Math.abs (left - aboveLeft);
                int c = Math.abs (left - aboveLeft + above - aboveLeft);
                int preductor = 0;
                if (a <= b && a <= c) {
                    preductor = left;
                }
                else if (b <= c) {
                    preductor = above;
                }
                else {
                    preductor = aboveLeft;
                }
                int currentValue = row [i] & 0xFF;
                row [i] = (byte) ((currentValue + preductor) & 0xFF);
            }
            break;
    }
}


public void moveTo (Session session, int newPos) throws SQLException {
    PageStore store = index.getPageStore ();
    store.logUndo (this, data);
    PageDataLeaf p2 = PageDataLeaf.create (index, newPos, parentPageId);
    readAllRows ();
    p2.keys = keys;
    p2.overflowRowSize = overflowRowSize;
    p2.firstOverflowPageId = firstOverflowPageId;
    p2.rowRef = rowRef;
    p2.rows = rows;
    if (firstOverflowPageId != 0) {
        p2.rows [0] = getRowAt (0);
    }
    p2.entryCount = entryCount;
    p2.offsets = offsets;
    p2.start = start;
    p2.remapChildren (getPos ());
    p2.write ();
    p2.data.truncate (index.getPageStore ().getPageSize ());
    store.update (p2);
    store.free (getPos (), true);
    if (parentPageId == ROOT) {
        index.setRootPageId (session, newPos);
    }
    else {
        PageDataNode p = (PageDataNode) store.getPage (parentPageId);
        p.moveChild (getPos (), newPos);
    }
}


-----Function Pair=22=-----==

public void reComputeFunctionValueAndGradient (double [] weights) {
    double [] weights2 = weights;
    if (shouldComputeGradientForScalingFactor) {
        if (weights.length != numFeatures + 1) {
            System.out.println ("number of weights is not right");
            System.exit (1);
        }
        scalingFactor = weights [0];
        weights2 = new double [numFeatures];
        for (int i = 0; i < numFeatures; i ++) weights2 [i] = weights [i + 1];
    }
    for (int i = 0; i < numFeatures; i ++) gradientsForTheta [i] = 0;
    if (shouldComputeGradientForScalingFactor) gradientForScalingFactor = 0;
    functionValue = 0;
    sumGain = 0;
    sumEntropy = 0;
    hgFactory.startLoop ();
    reComputeFunctionValueAndGradientHelper (weights2);
    hgFactory.endLoop ();
    printLastestStatistics ();
    numCalls ++;
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=23=-----==

public static void concatenateOutput (File [] inputFiles, File outputFile) {
    int numberOfInputFiles = inputFiles.length;
    byte lf = (byte) '\n';
    try {
        FileOutputStream fos = new FileOutputStream (outputFile);
        FileChannel outfc = fos.getChannel ();
        System.out.println ("Processing " + inputFiles [0].getPath ());
        FileInputStream fis = new FileInputStream (inputFiles [0]);
        FileChannel infc = fis.getChannel ();
        int bufferCapacity = 100000;
        ByteBuffer bb = ByteBuffer.allocate (bufferCapacity);
        bb.clear ();
        while (infc.read (bb) > 0) {
            bb.flip ();
            outfc.write (bb);
            bb.clear ();
        }
        infc.close ();
        for (int f = 1; f < numberOfInputFiles; f ++) {
            System.out.println ("Processing " + inputFiles [f].getPath ());
            fis = new FileInputStream (inputFiles [f]);
            infc = fis.getChannel ();
            bb.clear ();
            int bytesread = infc.read (bb);
            bb.flip ();
            byte b = bb.get ();
            while (b != lf) {
                b = bb.get ();
            }
            outfc.write (bb);
            bb.clear ();
            while (infc.read (bb) > 0) {
                bb.flip ();
                outfc.write (bb);
                bb.clear ();
            }
            infc.close ();
        }
        outfc.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void plotData () {
    datapanel.removeAllGraphData ();
    datapanel.setColorSurfaceData (null);
    BasicGraphData rawgraphdata = new BasicGraphData ();
    BasicGraphData fitgraphdata = new BasicGraphData ();
    if (! linearplot) {
        double temp;
        logdata = new double [currentyvalues.length];
        for (int i = 0; i < logdata.length; i ++) {
            temp = currentyvalues [i];
            if (temp <= 0.0) temp = 0.00001;
            logdata [i] = Math.log (temp) / Math.log (10);
        }
        rawgraphdata.addPoint (xphase, logdata);
    }
    else rawgraphdata.addPoint (xphase, currentyvalues);
    rawgraphdata.setDrawPointsOn (true);
    rawgraphdata.setDrawLinesOn (false);
    rawgraphdata.setGraphProperty ("Legend", new String ("raw data"));
    rawgraphdata.setGraphColor (Color.RED);
    datapanel.addGraphData (rawgraphdata);
    datapanel.setAxisNameY (" ");
    datapanel.setLegendButtonVisible (true);
    datapanel.setChooseModeButtonVisible (true);
    datapanel.setGridLinesVisibleX (true);
    datapanel.setGridLinesVisibleY (true);
    datapanel.setName ("BSM " + bsmname);
    if (dataHasBeenFit) {
        center = center + phi0;
        double xmin = center - 5 * sigma;
        double xmax = center + 5 * sigma;
        double points = 100.0;
        double inc = (xmax - xmin) / points;
        int npoints = (new Double (points)).intValue ();
        xfit = new double [npoints];
        yfit = new double [npoints];
        int i = 0;
        double x = xmin;
        while (x <= xmax && i < npoints) {
            xfit [i] = x;
            yfit [i] = amp * Math.exp (- (x - center) * (x - center) / (2.0 * sigma * sigma * .7));
            x += inc;
            i ++;
        }
        if (! linearplot) {
            double temp;
            ylogfit = new double [yfit.length];
            for (int j = 0; j < ylogfit.length; j ++) {
                temp = yfit [j];
                if (temp <= 0.0) temp = 0.00001;
                ylogfit [j] = Math.log (temp) / Math.log (10);
            }
            fitgraphdata.addPoint (xfit, ylogfit);
        }
        else {
            fitgraphdata.addPoint (xfit, yfit);
        }
        fitgraphdata.setDrawPointsOn (false);
        fitgraphdata.setDrawLinesOn (true);
        fitgraphdata.setGraphProperty ("Legend", new String ("fit data"));
        fitgraphdata.setGraphColor (Color.black);
        datapanel.addGraphData (fitgraphdata);
    }
}


-----Function Pair=24=-----==

public void call (String a) {
    StringRef args = new StringRef (a);
    if (HELP (args, "VER")) return;
    if (args.value.length () > 0) {
        String word = StripWord (args);
        if (! word.equalsIgnoreCase ("set")) return;
        word = StripWord (args);
        try {
            Dos.dos.version.major = (byte) Integer.parseInt (word);
            Dos.dos.version.minor = (byte) Integer.parseInt (args.value);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    else WriteOut (Msg.get ("SHELL_CMD_VER_VER"), new Object [] {Config.VERSION, new Integer (Dos.dos.version.major), new Integer (Dos.dos.version.minor)});
}


public String countAritmetic (String line, String type) {
    boolean koniec = false;
    int kl = 0;
    while (! koniec) {
        String aa = makeLine ();
        podzielNaNawiasy (line);
        aa = makeLine ();
        oblicz (type);
        aa = makeLine ();
        line = makeLine ();
        koniec = checkEnd (line);
        if (koniec) {
            break;
        }
        aa = makeLine ();
        podzielNaAryt (line);
        aa = makeLine ();
        oblicz (type);
        aa = makeLine ();
        usunNawiasyLiczby ();
        line = makeLine ();
        koniec = checkEnd (line);
        if (koniec) {
            break;
        }
        aa = makeLine ();
        podzielNaMaleNawiasy (line);
        aa = makeLine ();
        oblicz (type);
        aa = makeLine ();
        usunNawiasyLiczby ();
        aa = makeLine ();
        oblicz (type);
        aa = makeLine ();
        line = makeLine ();
        podzielNaMaleNawiasy (line);
        aa = makeLine ();
        oblicz (type);
        aa = makeLine ();
        usunNawiasyLiczby ();
        line = makeLine ();
        koniec = checkEnd (line);
        if (koniec) {
            break;
        }
        if ((! szukaj ("*")) && (! szukaj ("/"))) {
            line = makeLine ();
            podzielNaAryt (line);
            while (usunElementZnak ("(")) {
            }
            while (usunElementZnak (")")) {
            }
            line = makeLine ();
            makeDzialania (line);
            aa = makeLine ();
            oblicz (type);
            line = makeLine ();
        }
        else {
            line = makeLine ();
            String internal = countInternal (line, type);
            if (internal.length () > 0) {
                makeDzialaniaM (internal);
            }
            makeDzialaniaM (makeLine ());
            aa = makeLine ();
            oblicz (type);
            line = makeLine ();
        }
        if (kl > 1000) {
            System.out.println ("$$$" + makeLine ());
            System.out.println ("Abnormal program terminated.");
            break;
        }
        kl ++;
    }
    kl = 0;
    String wynik = makeLine ();
    return wynik;
}


-----Function Pair=25=-----==

private int nextNBits (int bitsToGet) {
    byte b;
    byte next;
    byte next2next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = data [bp + 1];
            next2next = 0x00;
        }
        else {
            next = data [bp + 1];
            next2next = data [bp + 2];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = flipTable [data [bp + 2] & 0xff];
        }
    }
    else {
        throw new RuntimeException ("TIFF_FILL_ORDER tag must be either 1 or 2.");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int bitsFromNext2NextByte = 0;
    if (bitsFromNextByte > 8) {
        bitsFromNext2NextByte = bitsFromNextByte - 8;
        bitsFromNextByte = 8;
    }
    bytePointer ++;
    int i1 = (b & table1 [bitsLeft]) << (bitsToGet - bitsLeft);
    int i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
    int i3 = 0;
    if (bitsFromNext2NextByte != 0) {
        i2 <<= bitsFromNext2NextByte;
        i3 = (next2next & table2 [bitsFromNext2NextByte])>>> (8 - bitsFromNext2NextByte);
        i2 |= i3;
        bytePointer ++;
        bitPointer = bitsFromNext2NextByte;
    }
    else {
        if (bitsFromNextByte == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
        else {
            bitPointer = bitsFromNextByte;
        }
    }
    int i = i1 | i2;
    return i;
}


public static int guessFieldCount (String filename) throws FileNotFoundException, IOException {
    final int maxFieldCount = 10;
    int [] recCount = new int [maxFieldCount];
    StringBuilder regexBuf = new StringBuilder ();
    regexBuf.append ("\\s*(" + decimalRegex + ")");
    for (int i = 1; i < maxFieldCount; i ++) {
        regexBuf.append ("([\\s+,+]\\s*(" + decimalRegex + "))?");
    }
    regexBuf.append ("\\s*");
    Pattern pat = Pattern.compile (regexBuf.toString ());
    BufferedReader reader = null;
    try {
        reader = new LineNumberReader (new FileReader (filename));
        String line;
        while ((line = reader.readLine ()) != null) {
            Matcher m = pat.matcher (line);
            if (m.matches ()) {
                int j;
                for (j = 1; j < m.groupCount (); j += 2) {
                    if (m.group (j) == null) {
                        recCount [(j - 1) / 2] ++;
                        break;
                    }
                }
            }
        }
    } finally {
        if (reader != null) reader.close ();
    }
    int max = 0;
    int imax = 0;
    for (int j = 1; j < maxFieldCount; j ++) {
        if (recCount [j] > max) {
            imax = j;
            max = recCount [j];
        }
    }
    return imax;
}


-----Function Pair=26=-----==

public final Raster getRaster (int x, int y, int w, int h) {
    if (w == 0 || h == 0) {
        return null;
    }
    WritableRaster raster = saved;
    if (raster == null || raster.getWidth () < w || raster.getHeight () < h) {
        raster = getCachedRaster (dataModel, w, h);
        saved = raster;
    }
    DataBufferInt rasterDB = (DataBufferInt) raster.getDataBuffer ();
    int [] pixels = rasterDB.getBankData () [0];
    int off = rasterDB.getOffset ();
    int scanlineStride = ((SinglePixelPackedSampleModel) raster.getSampleModel ()).getScanlineStride ();
    int adjust = scanlineStride - w;
    fillRaster (pixels, off, adjust, x, y, w, h);
    GraphicsUtil.coerceData (raster, dataModel, model.isAlphaPremultiplied ());
    return raster;
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=27=-----==

private int nextLesserThan8Bits (int bitsToGet) {
    byte b;
    byte next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = data [bp + 1];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
        }
    }
    else {
        throw new RuntimeException ("tag must be either 1 or 2.");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int shift = bitsLeft - bitsToGet;
    int i1;
    int i2;
    if (shift >= 0) {
        i1 = (b & table1 [bitsLeft])>>> shift;
        bitPointer += bitsToGet;
        if (bitPointer == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
    }
    else {
        i1 = (b & table1 [bitsLeft]) << (- shift);
        i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
        i1 |= i2;
        bytePointer ++;
        bitPointer = bitsFromNextByte;
    }
    return i1;
}


private static Coordinate [] intersections (Coordinate p0, Coordinate p1, Coordinate [] coords) {
    Coordinate [] line = new Coordinate [4];
    int lineCount = 0;
    int n = coords.length - 1;
    for (int k = 0; k < n; k ++) {
        Coordinate p2 = coords [k];
        Coordinate p3 = coords [k + 1];
        Coordinate coord = intersectSegmentsExact (p0, p1, p2, p3);
        if (coord != null) {
            line [lineCount] = coord;
            lineCount ++;
        }
    }
    return line;
}


-----Function Pair=28=-----==

public void run () {
    try {
        final File file = new File (System.getProperty ("user.dir") + filepath);
        for (int i = 0; loopTimes == 0 || i < loopTimes; ++ i) {
            if (thePlayer != null) thePlayer.close ();
            final InputStream fileInputStream = new FileInputStream (file);
            final InputStream inputStream = new BufferedInputStream (fileInputStream);
            final Player player = new Player (inputStream);
            thePlayer = player;
            Thread.sleep (1000);
            player.play ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public RobotList < Float > sort_decr_Float (RobotList < Float > list, String field) {
    int length = list.size ();
    Index_value [] distri = new Index_value [length];
    for (int i = 0; i < length; i ++) {
        distri [i] = new Index_value (i, list.get (i));
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (distri [i].value < distri [i + 1].value) {
                Index_value a = distri [i];
                distri [i] = distri [i + 1];
                distri [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Float > sol = new RobotList < Float > (Float.class);
    for (int i = 0; i < length; i ++) {
        sol.addLast (new Float (distri [i].value));
    }
    return sol;
}


-----Function Pair=29=-----==

protected void decode_first_half () {
    int opcode;
    int optype, optypes;
    int optypes2 = 0;
    int optypebytes;
    int isextended = 0;
    opcode = zm.get_code_byte () & 0xFF;
    if (opcode == OP_EXTENDED) {
        isextended = 0xC0;
    }
    switch (isextended | opcode & 0xC0) {
        case 0xC0 :
            if (isextended != 0xC0) {
                opnum = opcode;
            }
            else {
                opnum = (0x100 | (zm.get_code_byte () & 0xFF));
            }
            if ((opcode & 0x20) == 0) {
                opnum = opcode & 0x1F;
            }
            count = 0;
            optypes = zm.get_code_byte ();
            if ((opnum == OP_CALL_VS2) || (opnum == OP_CALL_VN2)) {
                optypebytes = 2;
                optypes2 = zm.get_code_byte ();
            }
            else optypebytes = 1;
            while (optypebytes -- != 0) {
                optype = (optypes & 0xC0)>> 6;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x30)>> 4;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x0C)>> 2;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x03);
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optypes = optypes2;
            }
            break;
        case 0x80 :
            optype = (opcode & 0x30)>> 4;
            if (optype == zm.OP_OMITTED) {
                opnum = opcode;
                count = 0;
            }
            else {
                opnum = opcode & 0x8F;
                count = 1;
                operands [0] = zm.get_operand (optype);
            }
            break;
        default :
            opnum = opcode & 0x1F;
            count = 2;
            optype = ((opcode & 0x40)>> 6) + 1;
            operands [0] = zm.get_operand (optype);
            optype = ((opcode & 0x20)>> 5) + 1;
            operands [1] = zm.get_operand (optype);
    }
}


public Double2M max (Spolecne.D3 F, double x, double y, double uhel, double krok, double phodn) {
    double hodn, t;
    for (int k = 1; k <= 6; k ++) {
        do {
            hodn = F.f (x, y, uhel);
            t = phodn;
            if (hodn > phodn) {
                phodn = hodn;
                uhel = uhel + krok;
            }
        }
        while (hodn >= t);
        phodn = hodn;
        krok = - krok / 10;
        uhel = uhel + krok;
    }
    return new Double2M (phodn, uhel - krok);
}


-----Function Pair=30=-----==

protected void init (DistanceMatrix distanceMatrix) {
    numClusters = distanceMatrix.getTaxonCount ();
    clusters = new SimpleNode [numClusters];
    distance = new double [numClusters] [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        for (int j = 0; j < numClusters; j ++) {
            distance [i] [j] = distanceMatrix.getElement (i, j);
        }
    }
    for (int i = 0; i < numClusters; i ++) {
        clusters [i] = new SimpleNode ();
        clusters [i].setTaxon (distanceMatrix.getTaxon (i));
    }
    alias = new int [numClusters];
    tipCount = new int [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        alias [i] = i;
        tipCount [i] = 1;
    }
}


public static Object callMethod3 (Object object, String methodName, Object params [], Class [] types) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    Method method = null;
    Class < ? > myClass = object.getClass ();
    NoSuchMethodException ex = null;
    while (method == null && myClass != null) {
        try {
            method = myClass.getDeclaredMethod (methodName, types);
        } catch (NoSuchMethodException e) {
            ex = e;
            myClass = myClass.getSuperclass ();
        }
    }
    if (method == null) throw ex;
    Object returnVal = method.invoke (object, params);
    return returnVal;
}


-----Function Pair=31=-----==

protected void addSecondaryStructure (EnumStructure type, String structureID, int serialID, int strandCount, int indexStart, int indexEnd) {
    if (indexEnd < indexStart) {
        Logger.error ("AlphaPolymer:addSecondaryStructure error: " + " indexStart:" + indexStart + " indexEnd:" + indexEnd);
        return;
    }
    int structureCount = indexEnd - indexStart + 1;
    ProteinStructure proteinstructure = null;
    if (type == null) System.out.println ("alhapoly null type");
    switch (type) {
        case HELIX :
        case HELIX_ALPHA :
        case HELIX_310 :
        case HELIX_PI :
            proteinstructure = new Helix (this, indexStart, structureCount, 0, type);
            break;
        case SHEET :
            proteinstructure = new Sheet (this, indexStart, structureCount, 0, type);
            break;
        case TURN :
            proteinstructure = new Turn (this, indexStart, structureCount, 0);
            break;
        default :
            Logger.error ("unrecognized secondary structure type");
            return;
    }
    proteinstructure.structureID = structureID;
    proteinstructure.serialID = serialID;
    proteinstructure.strandCount = strandCount;
    for (int i = indexStart; i <= indexEnd; ++ i) monomers [i].setStructure (proteinstructure);
}


protected void analyzePixels () {
    int len = pixels.length;
    int nPix = len / 3;
    indexedPixels = new byte [nPix];
    NeuQuant nq = new NeuQuant (pixels, len, sample);
    colorTab = nq.process ();
    for (int i = 0; i < colorTab.length; i += 3) {
        byte temp = colorTab [i];
        colorTab [i] = colorTab [i + 2];
        colorTab [i + 2] = temp;
        usedEntry [i / 3] = false;
    }
    int k = 0;
    for (int i = 0; i < nPix; i ++) {
        int index = nq.map (pixels [k ++] & 0xff, pixels [k ++] & 0xff, pixels [k ++] & 0xff);
        usedEntry [index] = true;
        indexedPixels [i] = (byte) index;
    }
    pixels = null;
    colorDepth = 8;
    palSize = 7;
    if (transparent != null) {
        transIndex = findClosest (transparent);
    }
}


-----Function Pair=32=-----==

private RdpPacket_Localised receive (int [] type) throws IOException, RdesktopException, CryptoException, OrderException {
    int length = 0;
    if ((this.stream == null) || (this.next_packet >= this.stream.getEnd ())) {
        this.stream = SecureLayer.receive ();
        if (stream == null) return null;
        this.next_packet = this.stream.getPosition ();
    }
    else {
        this.stream.setPosition (this.next_packet);
    }
    length = this.stream.getLittleEndian16 ();
    if (length == 0x8000) {
        logger.warn ("32k packet keepalive fix");
        next_packet += 8;
        type [0] = 0;
        return stream;
    }
    type [0] = this.stream.getLittleEndian16 () & 0xf;
    if (stream.getPosition () != stream.getEnd ()) {
        stream.incrementPosition (2);
    }
    this.next_packet += length;
    return stream;
}


public static void BubbleSortInt2 (int [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                int temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=33=-----==

private boolean processData (RdpPacket_Localised data, int [] ext_disc_reason) throws RdesktopException, OrderException {
    @SuppressWarnings ("unused")
    int data_type, ctype, clen, len, roff, rlen;
    data_type = 0;
    data.incrementPosition (6);
    len = data.getLittleEndian16 ();
    data_type = data.get8 ();
    ctype = data.get8 ();
    clen = data.getLittleEndian16 ();
    clen -= 18;
    switch (data_type) {
        case (RdpJPanel.RDP_DATA_PDU_UPDATE) :
            this.processUpdate (data);
            break;
        case RDP_DATA_PDU_CONTROL :
            logger.debug (("Received Control PDU\n"));
            break;
        case RDP_DATA_PDU_SYNCHRONISE :
            logger.debug (("Received Sync PDU\n"));
            break;
        case (RdpJPanel.RDP_DATA_PDU_POINTER) :
            logger.debug ("Received pointer PDU");
            this.processPointer (data);
            break;
        case (RdpJPanel.RDP_DATA_PDU_BELL) :
            logger.debug ("Received bell PDU");
            Toolkit tx = Toolkit.getDefaultToolkit ();
            tx.beep ();
            break;
        case (RdpJPanel.RDP_DATA_PDU_LOGON) :
            logger.debug ("User logged on");
            RdesktopSwing.loggedon = true;
            break;
        case RDP_DATA_PDU_DISCONNECT :
            ext_disc_reason [0] = processDisconnectPdu (data);
            logger.info ("Received disconnect PDU");
            if (RdesktopSwing.loggedon || ext_disc_reason [0] > 0) {
                return true;
            }
            break;
        default :
            logger.warn ("Unimplemented Data PDU type " + data_type);
    }
    return false;
}


protected static void fixRoots (float coeffBuf [], int coeffNum) {
    int i, j, coeffNum2;
    float rootsRe, rootsIm, f1;
    coeffNum2 = coeffNum << 1;
    float [] a = new float [coeffNum2 + 2];
    float [] roots = new float [coeffNum2];
    float [] cmplxRes = new float [2];
    a [coeffNum2] = 1.0f;
    a [coeffNum2 + 1] = 0.0f;
    for (i = 0, j = coeffNum2; j > 0;) {
        a [-- j] = 0.0f;
        a [-- j] = - coeffBuf [i ++];
    }
    zRoots (a, coeffNum, roots, true);
    for (j = 0; j < coeffNum2; j += 2) {
        f1 = complexAbs (roots [j], roots [j + 1]);
        if (f1 > 1.0f) {
            complexDiv (1.0f, 0.0f, roots [j], - roots [j + 1], cmplxRes);
            roots [j] = cmplxRes [0];
            roots [j + 1] = cmplxRes [1];
        }
    }
    a [0] = - roots [0];
    a [1] = - roots [1];
    a [2] = 1.0f;
    a [3] = 0.0f;
    for (j = 2; j < coeffNum2; j += 2) {
        a [j + 2] = 1.0f;
        a [j + 3] = 0.0f;
        rootsRe = roots [j];
        rootsIm = roots [j + 1];
        for (i = j; i >= 2; i -= 2) {
            a [i] = a [i - 2] - (rootsRe * a [i] - rootsIm * a [i + 1]);
            a [i + 1] = a [i - 1] - (rootsIm * a [i] + rootsRe * a [i + 1]);
        }
        a [0] = - rootsRe * a [0] + rootsIm * a [1];
        a [1] = - rootsIm * a [0] - rootsRe * a [1];
    }
    for (i = coeffNum, j = 0; j < coeffNum2; j += 2) {
        coeffBuf [-- i] = - a [j];
    }
}


-----Function Pair=34=-----==

public Console (float resX, float resY, int maxlines, float fontHeight, float time) {
    resolutionX = resX;
    maxVisibleLines = maxlines;
    timeout = time;
    numberOfLinesEntered = 0;
    consoleState = State.HIDDEN;
    area = new TextArea (AppDefinition.getConsoleFontPath (), AppDefinition.getConsoleFontSize (), AppDefinition.getConsoleFontColor () [0], AppDefinition.getConsoleFontColor () [1], AppDefinition.getConsoleFontColor () [2], AppDefinition.getConsoleFontColor () [3], 1);
    area.setSize (resX, resY);
    area.setPosition (0.0f, 0.0f);
    background = ImageManager.loadUnindexedImage (AppDefinition.getDefaultDataPackagePath () + "/images/static/" + AppDefinition.getConsoleBackroundImagePath (), true, true);
    text = new String [maxlines];
    vertices [3] = resX;
    vertices [6] = resX;
    setVertexBuffer ();
    intiated = true;
    print ("Console initiated");
}


public void run (String arg) {
    String [] sequences = {"AcquisitionTime", "ImageNumber", "ImageTime"};
    String [] prefixlist = {"None", "LastFirstname", "Age", "Sex", "StudyDescription", "ProtocolName"};
    String [] prefixlist2 = {"None", "LastFirstname", "Age", "Sex", "StudyDescription", "ProtocolName"};
    String [] prefixlist3 = {"None", "LastFirstname", "Age", "Sex", "StudyDescription", "ProtocolName"};
    GenericDialog gd = new GenericDialog ("DICOM Sort");
    gd.addMessage ("This plugin explores DICOM files via selected tags below.");
    gd.addMessage ("          comments to: stammt@uni-muenster.de            ");
    gd.addMessage ("  ");
    gd.addChoice ("Image Sequence by: ", sequences, pick);
    gd.addChoice ("1st Prefix: ", prefixlist, prefix1);
    gd.addChoice ("2nd Prefix: ", prefixlist2, prefix2);
    gd.addChoice ("3rd Prefix: ", prefixlist3, prefix3);
    gd.addCheckbox ("Show sorted Image Sequence (asc)", statussorta);
    gd.addCheckbox ("Sort Image Sequence (desc)", statussortd);
    gd.addCheckbox ("Make Sorted Text File List (only path + file name)", statustext);
    gd.addCheckbox ("Open sorted Images", only_images);
    gd.addCheckbox ("Open sorted Images as a Stack", open_as_stack);
    gd.addCheckbox ("Convert to 8-bits", grayscale);
    gd.showDialog ();
    if (gd.wasCanceled ()) return;
    pick = gd.getNextChoice ();
    prefix1 = gd.getNextChoice ();
    prefix2 = gd.getNextChoice ();
    prefix3 = gd.getNextChoice ();
    statussorta = gd.getNextBoolean ();
    statussortd = gd.getNextBoolean ();
    statustext = gd.getNextBoolean ();
    only_images = gd.getNextBoolean ();
    open_as_stack = gd.getNextBoolean ();
    grayscale = gd.getNextBoolean ();
    OpenDialog od = new OpenDialog ("Select a file in source folder...", "");
    String dir = od.getDirectory ();
    if (od.getFileName () == null) return;
    process (od.getDirectory ());
}


-----Function Pair=35=-----==

public FrequencyNode (ProbabilityFunction func) {
    DiscreteVariable [] vars = func.get_variables ();
    id = vars [0].get_index ();
    int maxK = vars [0].number_values ();
    if (vars.length > 1) {
        parents = new int [vars.length - 1];
        int maxJ = 1;
        for (int p = 0; p < parents.length; ++ p) {
            parents [p] = vars [p + 1].get_index ();
            maxJ *= vars [p + 1].number_values ();
        }
        parentMult = new int [vars.length - 1];
        nJ = new int [maxJ];
        nJK = new int [maxJ] [maxK];
        for (int p = 0; p < parentMult.length; ++ p) {
            maxJ /= vars [p + 1].number_values ();
            parentMult [p] = maxJ;
        }
    }
    else {
        parents = null;
        parentMult = null;
        nJ = new int [1];
        nJK = new int [1] [maxK];
    }
}


private void mousePressed (MousePressedEvent ev) {
    fixRange = true;
    clickPoint = ev.getPoint ();
    canvas.requestFocus ();
    if (ev.isControlDown ()) {
        double h = (clickPoint.x - graphBounds.x) / (graphBounds.width - 1.0);
        double v = (graphBounds.height - clickPoint.y + graphBounds.y) / (graphBounds.height - 1.0);
        v = v * (maxy - miny) + miny;
        addHandle (0.001 * ((int) (1000.0 * h)), 0.001 * ((int) (1000.0 * v)));
        return;
    }
    for (int i = 0; i < handlePos.length; i ++) {
        int xh = handlePos [i].x, yh = handlePos [i].y;
        if (clickPoint.x >= xh - HANDLE_SIZE / 2 && clickPoint.x <= xh + HANDLE_SIZE / 2 && clickPoint.y >= yh - HANDLE_SIZE / 2 && clickPoint.y <= yh + HANDLE_SIZE / 2) {
            selected = i;
            adjustComponents ();
            canvas.repaint ();
            return;
        }
    }
    clickPoint = null;
}


-----Function Pair=36=-----==

public Object applyN (Object [] args) throws Throwable {
    int arity = args.length - 1;
    if (arity == 1 && args [0] instanceof Procedure) {
        Procedure proc = (Procedure) (args [0]);
        if (collect) return map1 (proc, args [1]);
        forEach1 (proc, args [1]);
        return Values.empty;
    }
    Object result;
    Pair last = null;
    if (collect) result = LList.Empty;
    else result = Values.empty;
    Object [] rest = new Object [arity];
    System.arraycopy (args, 1, rest, 0, arity);
    Procedure proc;
    int need_apply;
    Object [] each_args;
    if (args [0] instanceof Procedure) {
        need_apply = 0;
        each_args = new Object [arity];
        proc = (Procedure) args [0];
    }
    else {
        need_apply = 1;
        each_args = new Object [arity + 1];
        each_args [0] = args [0];
        proc = applyToArgs;
    }
    for (;;) {
        for (int i = 0; i < arity; i ++) {
            Object list = rest [i];
            if (list == LList.Empty) return result;
            Pair pair = (Pair) list;
            each_args [need_apply + i] = pair.getCar ();
            rest [i] = pair.getCdr ();
        }
        Object value = proc.applyN (each_args);
        if (collect) {
            Pair new_pair = new Pair (value, LList.Empty);
            if (last == null) result = new_pair;
            else last.setCdr (new_pair);
            last = new_pair;
        }
    }
}


public dfp multiply (int x) {
    int r, rh, rl;
    int excp;
    int lostdigit;
    dfp result = newInstance (this);
    if (nans != FINITE) {
        if (nans == QNAN || nans == SNAN) return this;
        if (nans == INFINITE && x != 0) {
            result = newInstance (this);
            return result;
        }
        if (nans == INFINITE && x == 0) {
            ieeeFlags |= FLAG_INVALID;
            result = newInstance (zero);
            result.nans = QNAN;
            result = dotrap (FLAG_INVALID, "multiply", newInstance (zero), result);
            return result;
        }
    }
    if (x < 0 || x >= radix) {
        ieeeFlags |= FLAG_INVALID;
        result = newInstance (zero);
        result.nans = QNAN;
        result = dotrap (FLAG_INVALID, "multiply", result, result);
        return result;
    }
    rh = 0;
    for (int i = 0; i < DIGITS; i ++) {
        r = mant [i] * x + rh;
        rl = r % radix;
        rh = r / radix;
        result.mant [i] = rl;
    }
    lostdigit = 0;
    if (rh != 0) {
        lostdigit = result.mant [0];
        result.shiftRight ();
        result.mant [DIGITS - 1] = rh;
    }
    if (result.mant [DIGITS - 1] == 0) result.exp = 0;
    excp = result.round (lostdigit);
    if (excp != 0) result = dotrap (excp, "multiply", result, result);
    return result;
}


-----Function Pair=37=-----==

public int prime (int m) {
    if (m > 1) {
        int maxSimple = 1;
        for (int i = 1; i <= m; i ++) {
            boolean simple = true;
            for (int j = 2; j < i; j ++) {
                if ((i % j) == 0) {
                    simple = false;
                    break;
                }
            }
            if (simple) {
                maxSimple = i;
            }
        }
        return maxSimple;
    }
    else {
        return 0;
    }
}


private void processSecondaryOrders (RdpPacket_Localised data) throws OrderException, RdesktopException {
    int length = 0;
    int type = 0;
    int flags = 0;
    int next_order = 0;
    length = data.getLittleEndian16 ();
    flags = data.getLittleEndian16 ();
    type = data.get8 ();
    next_order = data.getPosition () + length + 7;
    switch (type) {
        case RDP_ORDER_RAW_BMPCACHE :
            logger.debug ("Raw BitmapCache Order");
            this.processRawBitmapCache (data);
            break;
        case RDP_ORDER_COLCACHE :
            logger.debug ("Colorcache Order");
            this.processColorCache (data);
            break;
        case RDP_ORDER_BMPCACHE :
            logger.debug ("Bitmapcache Order");
            this.processBitmapCache (data);
            break;
        case RDP_ORDER_FONTCACHE :
            logger.debug ("Fontcache Order");
            this.processFontCache (data);
            break;
        case RDP_ORDER_RAW_BMPCACHE2 :
            try {
                this.process_bmpcache2 (data, flags, false);
            } catch (IOException e) {
                throw new RdesktopException (e.getMessage ());
            }
            break;
        case RDP_ORDER_BMPCACHE2 :
            try {
                this.process_bmpcache2 (data, flags, true);
            } catch (IOException e) {
                throw new RdesktopException (e.getMessage ());
            }
            break;
        default :
            logger.warn ("Unimplemented 2ry Order type " + type);
    }
    data.setPosition (next_order);
}


-----Function Pair=38=-----==

public static int [] sortAscending (int input []) {
    int [] order = new int [input.length];
    for (int i = 0; i < order.length; i ++) order [i] = i;
    for (int i = input.length; -- i >= 0;) {
        for (int j = 0; j < i; j ++) {
            if (input [j] > input [j + 1]) {
                int mem = input [j];
                input [j] = input [j + 1];
                input [j + 1] = mem;
                int id = order [j];
                order [j] = order [j + 1];
                order [j + 1] = id;
            }
        }
    }
    return order;
}


private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


-----Function Pair=39=-----==

public void colorTwist (int i, int i_24_) {
    int i_25_ = 0;
    int i_26_ = i_24_ * 2;
    for (int i_27_ = 0; i_27_ < 8; i_27_ ++) {
        this.buffer [i_26_] = (this.sideCols [i * 9 + this.circleOrder [i_27_]]);
        i_26_ = (i_26_ + 1) % 8;
    }
    for (int i_28_ = 0; i_28_ < 8; i_28_ ++) {
        this.sideCols [i * 9 + this.circleOrder [i_28_]] = this.buffer [i_28_];
    }
    i_26_ = i_24_ * 3;
    for (int i_29_ = 0; i_29_ < 4; i_29_ ++) {
        for (int i_30_ = 0; i_30_ < 4; i_30_ ++) {
            if ((this.nextSide [this.nextSide [i * 4 + i_29_] * 4 + i_30_]) == i) {
                i_25_ = i_30_;
            }
        }
        for (int i_31_ = 0; i_31_ < 3; i_31_ ++) {
            switch (i_25_) {
                case 0 :
                    this.buffer [i_26_] = (this.sideCols [(this.nextSide [i * 4 + i_29_] * 9 + i_31_)]);
                    break;
                case 1 :
                    this.buffer [i_26_] = (this.sideCols [(this.nextSide [i * 4 + i_29_] * 9 + 2 + 3 * i_31_)]);
                    break;
                case 2 :
                    this.buffer [i_26_] = (this.sideCols [(this.nextSide [i * 4 + i_29_] * 9 + 8 - i_31_)]);
                    break;
                case 3 :
                    this.buffer [i_26_] = (this.sideCols [(this.nextSide [i * 4 + i_29_] * 9 + 6 - 3 * i_31_)]);
                    break;
            }
            i_26_ = (i_26_ + 1) % 12;
        }
    }
    i_26_ = 0;
    for (int i_32_ = 0; i_32_ < 4; i_32_ ++) {
        for (int i_33_ = 0; i_33_ < 4; i_33_ ++) {
            if ((this.nextSide [this.nextSide [i * 4 + i_32_] * 4 + i_33_]) == i) {
                i_25_ = i_33_;
            }
        }
        for (int i_34_ = 0; i_34_ < 3; i_34_ ++) {
            switch (i_25_) {
                case 0 :
                    this.sideCols [this.nextSide [i * 4 + i_32_] * 9 + i_34_] = this.buffer [i_26_];
                    break;
                case 1 :
                    this.sideCols [(this.nextSide [i * 4 + i_32_] * 9 + 2 + 3 * i_34_)] = this.buffer [i_26_];
                    break;
                case 2 :
                    this.sideCols [(this.nextSide [i * 4 + i_32_]) * 9 + 8 - i_34_] = this.buffer [i_26_];
                    break;
                case 3 :
                    this.sideCols [(this.nextSide [i * 4 + i_32_] * 9 + 6 - 3 * i_34_)] = this.buffer [i_26_];
                    break;
            }
            i_26_ ++;
        }
    }
}


private void addToJarEncoded (JarOutputStream out, InputStreamReader isr, String entryName, long length) throws IOException {
    StringBuffer buffer = new StringBuffer ();
    Reader reader = new BufferedReader (isr);
    int ch;
    while ((ch = reader.read ()) > - 1) {
        buffer.append ((char) ch);
    }
    reader.close ();
    isr.close ();
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    OutputStreamWriter osw = new OutputStreamWriter (baos, "UTF8");
    osw.write (buffer.toString ());
    osw.flush ();
    ByteArrayInputStream bais = new ByteArrayInputStream (baos.toByteArray ());
    addToJar (out, bais, entryName, length);
}


-----Function Pair=40=-----==

public static double evaluate (double x [], double y [], double z) throws DuplicateSampleAbscissaException, IllegalArgumentException {
    int i, j, n, nearest = 0;
    double value, c [], d [], tc, td, divider, w, dist, min_dist;
    verifyInterpolationArray (x, y);
    n = x.length;
    c = new double [n];
    d = new double [n];
    min_dist = Double.POSITIVE_INFINITY;
    for (i = 0; i < n; i ++) {
        c [i] = y [i];
        d [i] = y [i];
        dist = Math.abs (z - x [i]);
        if (dist < min_dist) {
            nearest = i;
            min_dist = dist;
        }
    }
    value = y [nearest];
    for (i = 1; i < n; i ++) {
        for (j = 0; j < n - i; j ++) {
            tc = x [j] - z;
            td = x [i + j] - z;
            divider = x [j] - x [i + j];
            if (divider == 0.0) {
                throw new DuplicateSampleAbscissaException (x [i], i, i + j);
            }
            w = (c [j + 1] - d [j]) / divider;
            c [j] = tc * w;
            d [j] = td * w;
        }
        if (nearest < 0.5 * (n - i + 1)) {
            value += c [nearest];
        }
        else {
            nearest --;
            value += d [nearest];
        }
    }
    return value;
}


void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


-----Function Pair=41=-----==

FinishedMatchRegular getStatsMessage () {
    MauMauPlayerWrapper [] sort = new MauMauPlayerWrapper [indexOfNextSubscriberToAdd];
    System.arraycopy (players, 0, sort, 0, sort.length);
    MauMauPlayerWrapper s;
    for (int o = 0; o < sort.length; o ++) for (int i = 0; i < sort.length - o - 1; i ++) if (sort [i + 1].getMinusPoints () < sort [i].getMinusPoints ()) {
        s = sort [i];
        sort [i] = sort [i + 1];
        sort [i + 1] = s;
    }
    if (matchEndsWithGamesWon ()) {
        for (int o = 0; o < sort.length; o ++) for (int i = 0; i < sort.length - o - 1; i ++) if (sort [i].getGamesWon () < sort [i + 1].getGamesWon ()) {
            s = sort [i];
            sort [i] = sort [i + 1];
            sort [i + 1] = s;
        }
    }
    String [] playersNames = new String [sort.length];
    int [] playersMali = new int [sort.length];
    int [] playersGames = new int [sort.length];
    for (int i = 0; i < sort.length; i ++) {
        playersNames [i] = sort [i].getName ();
        playersMali [i] = sort [i].getMinusPoints ();
        playersGames [i] = sort [i].getGamesWon ();
    }
    return new FinishedMatchRegular (getName (), playersNames, playersMali, playersGames);
}


public Test findTest (String qualifiedName) {
    String currentQualify = getQualifiedName ();
    Test retVal = null;
    if (currentQualify.equals (qualifiedName)) retVal = this;
    else if (qualifiedName != null) {
        String name;
        if (qualifiedName.startsWith (currentQualify)) {
            name = qualifiedName.substring (currentQualify.length () + 1);
        }
        else {
            throw new IllegalArgumentException ("you must enter a fully qualified test name");
        }
        retVal = state.findTest (name);
        if (retVal == null) {
            if (name.indexOf ('/') != - 1) {
                TestSuite suite = findSuite (name.substring (0, (name.indexOf ('/'))));
                if (suite != null) retVal = suite.findTest (qualifiedName);
            }
        }
    }
    return retVal;
}


-----Function Pair=42=-----==

public static float PID (Sequence s1, Sequence s2) {
    int res = 0;
    int len;
    if (s1.getSequence ().length () > s2.getSequence ().length ()) {
        len = s1.getSequence ().length ();
    }
    else {
        len = s2.getSequence ().length ();
    }
    int bad = 0;
    for (int i = 0; i < len; i ++) {
        String str1 = "";
        String str2 = "";
        if (i < s1.getSequence ().length ()) {
            str1 = s1.getSequence ().substring (i, i + 1);
        }
        else {
            str1 = ".";
        }
        if (i < s2.getSequence ().length ()) {
            str2 = s2.getSequence ().substring (i, i + 1);
        }
        else {
            str2 = ".";
        }
        if (! (str1.equals (".") || str1.equals ("-") || str1.equals (" ")) && ! (str2.equals (".") || str2.equals ("-") || str2.equals (" "))) {
            if (! str1.equals (str2)) {
                bad ++;
            }
        }
    }
    return (float) 100 * (len - bad) / len;
}


public static String [] varParseFieldDimension (String name) {
    String remain;
    String thisfield = name;
    int dot1, dot2, bracket;
    int numfield = varCountField (name);
    String fields [] = new String [numfield];
    remain = name;
    if (numfield == 0) {
        return null;
    }
    for (int i = 0; i < numfield; i ++) {
        dot1 = remain.indexOf ('.');
        dot2 = remain.indexOf ('.', dot1 + 1);
        fields [i] = "";
        if (dot1 != - 1 && dot2 != - 1) {
            thisfield = remain.substring (dot1 + 1, dot2);
            remain = remain.substring (dot1 + 1);
        }
        else if (dot1 != - 1 && dot2 == - 1) {
            thisfield = remain.substring (dot1 + 1);
        }
        else {
            System.out.println ("ERROR: parsing " + name);
        }
        bracket = thisfield.indexOf ('[');
        if (bracket != - 1) {
            fields [i] = thisfield.substring (bracket);
        }
    }
    return fields;
}


-----Function Pair=43=-----==

public void normalizeByGaussian () {
    if (dataHasBeenFit) {
        double norm = vnorm.getValue ();
        int size = sdata.length;
        double max = 0.0;
        for (int i = 0; i < size; i ++) if (data [i] > max) max = data [i];
        for (int i = 0; i < size; i ++) {
            sdata [i] -= fitparams [2];
            sdata [i] /= fitparams [0];
            data [i] -= fitparams [3];
            data [i] /= fitparams [1];
        }
        dataHasBeenFit = false;
        plotData ();
    }
}


public final void mem16 (int addr, int v) {
    int addr1 = addr - 0x3FFF;
    if ((addr1 & 0x3FFF) != 0) {
        int n = cpu.time - ctime;
        if (n > 0) cont (n);
        ctime = NOCONT;
        if (addr1 < 0) return;
        if (addr1 >= 0x4000) {
            write_ram (addr1 - 1, v & 0xFF);
            write_ram (addr1, v>>> 8);
            return;
        }
    }
    mem (addr, v & 0xFF);
    cpu.time += 3;
    mem (addr + 1, v>>> 8);
    cpu.time -= 3;
}


-----Function Pair=44=-----==

public void sysCallAction (ActionEvent e) {
    Database localDb = this.getFatherPanel ().getLocalDb ();
    QueryDataSet queryMenuSQL = new QueryDataSet ();
    try {
        String query = "SELECT SYS_CALL_NAME FROM SYSCALL " + "WHERE DESCR = '" + e.getActionCommand () + "' AND " + "FK_SHAPE_ID=" + this.getElemId () + " AND " + "IMAGE_NAME='" + this.getImgName () + "'";
        queryMenuSQL.setQuery (new com.borland.dx.sql.dataset.QueryDescriptor (localDb, query, null, true, Load.ALL));
        queryMenuSQL.open ();
        String command = queryMenuSQL.getString ("SYS_CALL_NAME");
        if (! command.equals ("") && ! command.equals ("null") && command != null) parseCommand (command, "");
        queryMenuSQL.close ();
        queryMenuSQL = null;
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


public static byte [] setBit (final byte [] data, final int index, final boolean value) {
    if (data.length == 0) {
        return data;
    }
    final int max = data.length * 8;
    if (index >= max || index < 0) {
        throw new IndexOutOfBoundsException ("Index out of bounds: " + index);
    }
    final int pos = data.length - index / 8 - 1;
    final int bitPos = index % 8;
    int d = data [pos] & 0xFF;
    if (value) {
        d = d | (1 << bitPos);
    }
    else {
        d = d & ~ (1 << bitPos);
    }
    data [pos] = (byte) d;
    return data;
}


-----Function Pair=45=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


public void append (DataModel childNode) {
    if (values == null) values = new DataModel [1];
    String childName = childNode.getId ();
    int numChildren = numValidChildren;
    if (childName == null) {
        for (int i = 0; i < values.length; i ++) {
            if ((values [i] == null)) {
                values [i] = childNode;
                numValidChildren ++;
                return;
            }
        }
    }
    else {
        for (int i = 0; i < numChildren; i ++) {
            if ((values [i].getId () != null) && (values [i].getId ().compareTo (childName) == 0)) {
                values [i] = childNode;
                return;
            }
        }
    }
    setNumChildren (numChildren + 5);
    values [numValidChildren] = childNode;
    if (childNode instanceof BaseModel) childNode.setParent (this);
    numValidChildren = numChildren + 1;
}


-----Function Pair=46=-----==

private boolean jdpCommand (String command, String [] args) {
    runstat = true;
    int addr, count;
    if (user == null) {
        if (command.equals ("run")) {
            switch (args.length) {
                case 0 :
                    restart (saved_args);
                    break;
                default :
                    restart (args);
            }
        }
        else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
            if (args.length == 0) printHelp ("");
            else printHelp (args [0]);
        }
        else {
            jdp_console.writeOutput ("No program running, enter:  run ... ");
        }
        return false;
    }
    if (command.equals ("step") || command.equals ("s")) {
        boolean skip_prolog = false;
        printMode = PRINTASSEMBLY;
        runstat = user.pstep (0, printMode, skip_prolog);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        printMode = PRINTASSEMBLY;
        runstat = user.pstepOverBranch (0);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        printMode = PRINTASSEMBLY;
        runstat = user.pstepLine (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        printMode = PRINTSOURCE;
        runstat = user.pstepLineOverMethod (0);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("run")) {
        jdp_console.writeOutput ("Debuggee is running, kill before restarting");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        switch (debuggerEnvironment) {
            case EXTERNALCREATE :
                runstat = false;
                break;
            case EXTERNALATTACH :
                jdp_console.writeOutput ("Cannot kill attached process, type quit to detach debugger");
                break;
            case INTERNAL :
                jdp_console.writeOutput ("Debugger running inside JVM, type quit to exit debugger");
        }
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        if (debuggerEnvironment == EXTERNALATTACH && ! user.bpset.anyBreakpointExist ()) {
            jdp_console.writeOutput ("no breakpoint currently set, detaching process");
            return true;
        }
        else {
            runstat = user.pcontinue (0, printMode, true);
            if (runstat == true) refreshEnvironment ();
        }
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        runstat = user.pcontinue (0, printMode, false);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        runstat = user.pcontinueToReturn (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        doThread (command, args);
    }
    else if (command.equals ("reg") || command.equals ("r")) {
        doRegisterRead (command, args);
    }
    else if (command.equals ("wreg") || command.equals ("wr")) {
        doRegisterWrite (command, args);
    }
    else if (command.equals ("memraw") || command.equals ("mraw")) {
        doMemoryReadRaw (command, args);
    }
    else if (command.equals ("mem") || command.equals ("m")) {
        doMemoryRead (command, args);
    }
    else if (command.equals ("wmem") || command.equals ("wm")) {
        doMemoryWrite (command, args);
    }
    else if (command.equals ("print") || command.equals ("p")) {
        doPrintCommand (command, args);
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        doPrintClassCommand (command, args);
    }
    else if (command.equals ("getclass")) {
        doGetClassCommand (command, args);
    }
    else if (command.equals ("getinstance")) {
        doGetInstanceCommand (command, args);
    }
    else if (command.equals ("getarray")) {
        doGetArrayCommand (command, args);
    }
    else if (command.equals ("getcl")) {
        doGetClassAndLine (command, args);
    }
    else if (command.equals ("getcia")) {
        doGetCurrentInstrAddr (command, args);
    }
    else if (command.equals ("getframes")) {
        doGetFrames (command, args);
    }
    else if (command.equals ("getlocals")) {
        doGetLocals (command, args);
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        jdp_console.writeOutput ("(this command has been removed because the Opt compiler does not generate the bytecode map)");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        doListInstruction (command, args);
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        doListThread (command, args);
    }
    else if (command.equals ("break") || command.equals ("b")) {
        doSetBreakpoint (command, args);
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        doClearBreakpoint (command, args);
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        doCurrentFrame (command, args);
    }
    else if (command.equals ("where") || command.equals ("w")) {
        doShortFrame (command, args);
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        doFullFrame (command, args);
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        doSetPreference (command, args);
    }
    else if (command.equals ("preference") || command.equals ("x2d")) {
        doConvertHexToInt (command, args);
    }
    else if (command.equals ("preference") || command.equals ("d2x")) {
        doConvertIntToHex (command, args);
    }
    else if (command.equals ("test")) {
        doTest (args);
    }
    else if (command.equals ("test1")) {
        doTest1 (args);
    }
    else if (command.equals ("count")) {
        doThreadCount (0);
    }
    else if (command.equals ("zerocount")) {
        doThreadCount (1);
    }
    else if (command.equals ("readmem")) {
        if (args.length != 0) {
            try {
                addr = parseHex32 (args [0]);
                int mydata = user.mem.read (addr);
                jdp_console.writeOutput ("true memory = x" + Integer.toHexString (mydata));
            } catch (NumberFormatException e) {
                jdp_console.writeOutput ("bad address: " + args [0]);
            }
        }
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        if (user.verbose) {
            jdp_console.writeOutput ("Verbose now OFF");
            user.verbose = false;
        }
        else {
            jdp_console.writeOutput ("Verbose now ON");
            user.verbose = true;
        }
    }
    else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
        if (args.length == 0) printHelp ("");
        else printHelp (args [0]);
    }
    else if (macro.exists (command + ".jdp")) {
        macro.load (command + ".jdp");
    }
    else {
        jdp_console.writeOutput ("Command not implemented");
    }
    return false;
}


public Layer (Element e) {
    String typeOfFunction;
    NodeList nodeListOfNeurons = e.getElementsByTagName ("Neuron");
    int numberOfNeurons = nodeListOfNeurons.getLength ();
    number = inumber = numberOfNeurons;
    Neuron [] neurons = new Neuron [numberOfNeurons];
    for (int i = 0; i < numberOfNeurons; i ++) {
        typeOfFunction = ((org.w3c.dom.Element) nodeListOfNeurons.item (i)).getAttribute ("type");
        Neuron neuron = new Neuron ();
        if (typeOfFunction.equals ("Sigmoid")) {
            neuron = new SigmNeuron ();
        }
        else if (typeOfFunction.equals ("Linear")) {
            neuron = new LinearNeuron ();
        }
        else if (typeOfFunction.equals ("MultiGaussian")) {
            neuron = new MultiGaussianNeuron ();
        }
        else if (typeOfFunction.equals ("Rational")) {
            neuron = new PolyFractNeuron ();
        }
        else if (typeOfFunction.equals ("Polynomial")) {
            neuron = new PolySimpleNeuron ();
        }
        else if (typeOfFunction.equals ("Polynomial - NR")) {
            neuron = new PolySimpleNRNeuron ();
        }
        else if (typeOfFunction.equals ("Sine")) {
            neuron = new SinusNeuron ();
        }
        else if (typeOfFunction.equals ("Polynomial - combi")) {
            neuron = new CombiNeuron ();
        }
        else if (typeOfFunction.equals ("Exponential")) {
            neuron = new ExpNeuron ();
        }
        else if (typeOfFunction.equals ("Gaussian")) {
            neuron = new GaussianNeuron ();
        }
        else if (typeOfFunction.equals ("Gauss")) {
            neuron = new GaussNeuron ();
        }
        neurons [i] = neuron;
    }
    this.n = neurons;
}


-----Function Pair=47=-----==

public void doFullFrame (String command, String [] args) {
    int from, to;
    try {
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstackTraceFull (0, 20));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    int fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstackTraceFull (fp));
                }
                else {
                    from = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstackTraceFull (from, from));
                }
                break;
            case 2 :
                from = Integer.parseInt (args [0]);
                to = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstackTraceFull (from, to));
                break;
            default :
                printHelp (command);
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad stack frame numbers (decimal) or frame pointer value (hex)");
    }
}


public void setValueAt (Object value, int row, int column) {
    int i;
    switch (column) {
        case 1 :
            if (! (value instanceof String)) break;
            for (i = 0; i < BatchCellRenderer.CMD_NAMES.length; i ++) {
                if (value.equals (BatchCellRenderer.CMD_NAMES [i])) {
                    ((BatchObject) batchVector.get (row)).command = i;
                    break;
                }
            }
            break;
        case 2 :
            batchVector.set (row, value);
            break;
        case 3 :
            if (! (value instanceof String)) break;
            for (i = 0; i < BatchCellRenderer.ERR_NAMES.length; i ++) {
                if (value.equals (BatchCellRenderer.ERR_NAMES [i])) {
                    ((BatchObject) batchVector.get (row)).errorCmd = i;
                    break;
                }
            }
            break;
    }
    fireTableRowsUpdated (row, row);
}


-----Function Pair=48=-----==

public void visitSynchronized (JCSynchronized tree) {
    int limit = code.nextreg;
    final LocalItem lockVar = makeTemp (syms.objectType);
    genExpr (tree.lock, tree.lock.type).load ().duplicate ();
    lockVar.store ();
    code.emitop0 (monitorenter);
    code.state.lock (lockVar.reg);
    final Env < GenContext > syncEnv = env.dup (tree, new GenContext ());
    syncEnv.info.finalize = new GenFinalizer () {
        void gen () {
            genLast ();
            Assert.check (syncEnv.info.gaps.length () % 2 == 0);
            syncEnv.info.gaps.append (code.curPc ());
        } void genLast () {
            if (code.isAlive ()) {
                lockVar.load ();
                code.emitop0 (monitorexit);
                code.state.unlock (lockVar.reg);
            }
        }
    }
    ;
    syncEnv.info.gaps = new ListBuffer < Integer > ();
    genTry (tree.body, List.< JCCatch > nil (), syncEnv);
    code.endScopes (limit);
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=49=-----==

public void drop (DropTargetEvent event) {
    if (event.data == null) {
        event.detail = DND.DROP_NONE;
        return;
    }
    ColorItem selectedCanvas2 = getSelectedCanvas ();
    if (selectedCanvas2 == null || ! isDragging) {
        return;
    }
    isDragging = false;
    int oldPos = selectedCanvas2.getIndex ();
    final int newPos = item.index;
    if ((oldPos < colors.length) && (newPos < colors.length)) {
        final IProxyColor tmp = colors [oldPos];
        if (oldPos > newPos) {
            for (int i = oldPos; i > newPos; i --) {
                colors [i] = colors [i - 1];
            }
            colors [newPos] = tmp;
        }
        else {
            for (int i = oldPos; i < newPos; i ++) {
                colors [i] = colors [i + 1];
            }
            colors [newPos] = tmp;
        }
        updateColors ();
        isDirty = true;
    }
}


public void computeCorrection (double XCorr, double YCorr, double errAngle, float dZ []) {
    if (XCorr == VARIABLE) XCorr = 0;
    if (YCorr == VARIABLE) YCorr = 0;
    dZ [0] = 0;
    dZ [1] = 0;
    dZ [2] = + (float) (errAngle * Math.PI / (float) 1800);
    double cs = Math.cos (- dZ [2]);
    double ss = Math.sin (- dZ [2]);
    double rX = cs * cX + ss * cY;
    double rY = - ss * cX + cs * cY;
    if (debug) System.out.println ("  Rotating pos (" + cX + "," + cY + ") of " + dZ [2] + " rad : (" + rX + "," + rY + ")");
    if (debug) System.out.println ("  Computing correction for " + XCorr + ", " + YCorr + "," + errAngle);
    dZ [1] = (float) (rY - cY + YCorr) * (float) 0.00254;
    dZ [0] = (float) (rX - cX + XCorr) * (float) 0.00254;
    if (debug) System.out.println ("Delta Measure Z=[" + dZ [0] + "," + dZ [1] + "," + dZ [2]);
}


-----Function Pair=50=-----==

void removeBall (int index) {
    int npoints = all_x.length;
    int [] temp_all_x = new int [npoints - 1];
    int [] temp_all_y = new int [npoints - 1];
    double [] temp_all_radii = new double [npoints - 1];
    for (int i = 0; i < index; i ++) {
        temp_all_x [i] = all_x [i];
        temp_all_y [i] = all_y [i];
        temp_all_radii [i] = all_radii [i];
    }
    for (int j = index; j < npoints - 1; j ++) {
        temp_all_x [j] = all_x [j + 1];
        temp_all_y [j] = all_y [j + 1];
        temp_all_radii [j] = all_radii [j + 1];
    }
    all_x = temp_all_x;
    all_y = temp_all_y;
    all_radii = temp_all_radii;
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=51=-----==

public boolean podzielNaAryt (String line) {
    boolean answer = false;
    inArt = 0;
    int len = line.length ();
    String temp = "";
    boolean dod = false;
    for (int i = 0; i < len; i ++) {
        dod = false;
        boolean make = false;
        if (line.charAt (i) == 43) {
            temp = temp;
            dod = true;
            if (temp.length () > 0) {
                art [inArt] = temp;
                temp = "";
                inArt ++;
                answer = true;
            }
            art [inArt] = line.charAt (i) + "";
            inArt ++;
        }
        if (isAryt (line.charAt (i) + "")) {
            int k = i;
            if (k == 0) {
                if ((line.charAt (k) + "").equals ("-")) {
                    make = true;
                }
            }
            if (k == 0) {
                if ((line.charAt (k) + "").equals ("(")) {
                    make = true;
                }
            }
            if (k >= 1) {
                if (isAryt (line.charAt (k - 1) + "")) {
                    make = true;
                }
                if ((line.charAt (k - 1) + "").equals ("(")) {
                    make = true;
                }
            }
        }
        if (! make) {
            if (line.charAt (i) == 45) {
                temp = temp;
                dod = true;
                if (temp.length () > 0) {
                    art [inArt] = temp;
                    temp = "";
                    inArt ++;
                    answer = true;
                }
                art [inArt] = line.charAt (i) + "";
                inArt ++;
            }
        }
        if (line.charAt (i) == 40) {
            if (temp.length () > 0) {
                art [inArt] = temp;
                temp = "";
                inArt ++;
                answer = true;
            }
        }
        if (line.charAt (i) == 41) {
            if (temp.length () > 0) {
                art [inArt] = temp;
                temp = "";
                inArt ++;
                answer = true;
            }
        }
        if (! dod) {
            temp = temp + line.charAt (i);
        }
    }
    if (temp.length () > 0) {
        art [inArt] = temp;
        temp = "";
        inArt ++;
    }
    return answer;
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=52=-----==

int [] findClosestPoint (int clicked_x, int clicked_y) {
    int [] index_and_dist = new int [2];
    if (x.length != 0) {
        double distance = calcDist (x [0], y [0], clicked_x, clicked_y);
        double dist2 = 0;
        int position = 0;
        for (int i = 0; i < x.length; i ++) {
            dist2 = calcDist (x [i], y [i], clicked_x, clicked_y);
            if (dist2 < distance) {
                distance = dist2;
                position = i;
            }
        }
        int previous_point = position - 1;
        index_and_dist [0] = previous_point;
        index_and_dist [1] = (int) distance;
    }
    else {
        index_and_dist [0] = - 1;
        index_and_dist [1] = 10000;
    }
    return index_and_dist;
}


public static int [] varParseArrayDimension (String name) throws NumberFormatException {
    int bracketLeft, bracketRight;
    boolean gettingDimension = true;
    String dimString = name;
    int numDim = 0;
    int index = 0;
    int result [];
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        if (bracketRight == - 1) {
            gettingDimension = false;
        }
        else {
            numDim ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    result = new int [numDim];
    index = 0;
    dimString = name;
    gettingDimension = true;
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        bracketLeft = dimString.indexOf ('[');
        if (bracketRight == - 1 || bracketLeft == - 1) {
            gettingDimension = false;
        }
        else {
            result [index] = Integer.valueOf (dimString.substring (bracketLeft + 1, bracketRight)).intValue ();
            index ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    return result;
}


-----Function Pair=53=-----==

public static String [] getReferenceFileNames (String configFile) throws IOException {
    String [] referenceFiles = null;
    LineReader reader = new LineReader (configFile);
    try {
        for (String line : reader) {
            line = line.trim ();
            if (Regex.commentOrEmptyLine.matches (line)) continue;
            if (line.indexOf ("=") == - 1) {
                String [] fds = Regex.spaces.split (line);
                if ("oracle".equals (fds [0]) && fds.length >= 3) {
                    referenceFiles = new String [fds.length - 2];
                    for (int i = 0; i < referenceFiles.length; i ++) referenceFiles [i] = fds [i + 1].trim ();
                }
            }
        }
    } finally {
        reader.close ();
    }
    return referenceFiles;
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=54=-----==

Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


private int evalFactor (StreamTokenizer st) throws IOException {
    int tok = st.nextToken ();
    switch (tok) {
        case StreamTokenizer.TT_NUMBER :
            return (int) st.nval;
        case '-' :
            return - evalFactor (st);
        case '~' :
            return ~ evalFactor (st);
        case '(' :
            int val = evalExpr (st);
            if (st.nextToken () != ')') throw new IOException ("Mismatched parentheses");
            return val;
        case StreamTokenizer.TT_WORD :
            if (st.sval.equals ("@LENGTH")) return evalLength (st);
            else throw new IOException ("Invalid token");
        default :
            throw new IOException ("Invalid token");
    }
}


-----Function Pair=55=-----==

static void sort (int [] a) {
    int i = 0;
    while (i < a.length - 1) {
        int j = 0;
        while (j < (a.length - i) - 1) {
            if (a [j] > a [j + 1]) {
                int aux = a [j];
                a [j] = a [j + 1];
                a [j + 1] = aux;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=56=-----==

private Object [] fixContinuedLines (String [] code) {
    int arrayLen = code.length;
    int [] reallines = new int [code.length];
    for (int i = 0; i < reallines.length; i ++) reallines [i] = i;
    for (int i = 0; i < arrayLen; i ++) {
        if (code [i].endsWith ("..")) {
            if (code.length - 1 > i + 1) {
                code [i] = code [i].substring (0, code [i].length () - 2) + code [i + 1];
                arrayLen --;
                for (int l = i + 1; l < arrayLen; l ++) {
                    code [l] = code [l + 1];
                    reallines [l] ++;
                }
                i --;
            }
        }
    }
    return new Object [] {Arrays.copyOf (code, arrayLen), reallines};
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=57=-----==

public H2dRefluxValue getCommonValue (final int [] _idx, final H2dVariableType _t) {
    if ((_idx == null) || (_idx.length == 0)) {
        return null;
    }
    final H2dRefluxValue r = new H2dRefluxValue ();
    final H2dRefluxValue temp = new H2dRefluxValue ();
    bcArray_ [_idx [_idx.length - 1]].fillWithValue (_t, r);
    for (int i = _idx.length - 2; i >= 0; i --) {
        bcArray_ [_idx [i]].fillWithValue (_t, temp);
        if (H2dRefluxValue.compareTwoValueAndIsDiff (r, temp)) {
            if (r.getType () == H2dBcType.MIXTE) {
                return r;
            }
        }
    }
    return r;
}


private String acceptKeystroke () {
    historyCursor = history.size ();
    load ("");
    byte keystroke = readKeystroke ();
    for (;;) {
        switch (keystroke) {
            case K_NOP :
            case K_TAB :
                break;
            case K_BSP :
                if (bufferCursor > 0) {
                    -- bufferCursor;
                    delete ();
                }
                else beep ();
                break;
            case K_ESC :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        log.println ("completion not found for: " + toComplete);
                        beep ();
                    }
                    else load (completed);
                    break;
                }
            case K_SPACE :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        if (CommandCompletion.moreSpaceKeyExpected (toComplete)) {
                            insert (keystroke);
                            ++ bufferCursor;
                        }
                        else {
                            beep ();
                        }
                    }
                    else load (completed);
                    break;
                }
            case K_ENTER :
                {
                    String string = new String (buffer);
                    if (string.length () != 0) {
                        history.removeElement (string);
                        history.addElement (string);
                    }
                    historyCursor = history.size ();
                    load ("");
                    return string;
                }
            case K_UP :
                up ();
                break;
            case K_DN :
                down ();
                break;
            case K_RT :
                right ();
                break;
            case K_LT :
                left ();
                break;
            case K_HOME :
                home ();
                break;
            case K_END :
                end ();
                break;
            case K_DEL :
                delete ();
                break;
            default :
                insert (keystroke);
                ++ bufferCursor;
        }
        keystroke = readKeystroke ();
    }
}


-----Function Pair=58=-----==

public double getBestOutput (int vector) {
    double ret = 0, div = 0, num = getNumber ();
    iLayer.setActualVector (vector);
    mode = PASSIVE;
    prevLayer.computeOutputs ();
    if (GlobalConfig.getInstance ().getGc ().isCommonResponse ()) {
        for (int i = 0; i < num; i ++) {
            ret += (num - i) * (num - i) * n [i].getOutputValue ();
            div += (num - i) * (num - i);
        }
        mode = ACTIVE;
        return ret / div;
    }
    ret = n [0].getOutputValue ();
    mode = ACTIVE;
    return ret;
}


public void doMemoryReadRaw (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    ret.append ("Actual memory (breakpoints shown as is):\n");
    int addr, count;
    switch (args.length) {
        case 0 :
            jdp_console.writeOutput (ret.toString ());
            printHelp (command);
            break;
        case 1 :
            try {
                addr = parseHex32 (args [0]);
                ret.append (user.mem.printRaw (addr, 5));
            } catch (NumberFormatException e) {
                ret.append ("bad address: " + args [0] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
        default :
            try {
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                ret.append (user.mem.printRaw (addr, count));
            } catch (NumberFormatException e) {
                ret.append ("bad address or count: " + args [0] + ", " + args [1] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
    }
}


-----Function Pair=59=-----==

public static byte [] discryptionDES (byte [] source, byte [] keyByte) throws DESCryptionException {
    if (source.length % 8 != 0) throw new DESCryptionException ("source length is not multiple of 8 bytes");
    if (keyByte.length != 8) throw new DESCryptionException ("key length is not 8 bytes");
    int [] data = TypeConversion.byte2hexInt (source);
    data = changeIP (data);
    int [] left = new int [32];
    int [] right = new int [32];
    int [] tmp = new int [32];
    for (int j = 0; j < 32; j ++) {
        left [j] = data [j];
        right [j] = data [j + 32];
    }
    int [] key = TypeConversion.byte2hexInt (keyByte);
    int [] [] subKey = setKey (key);
    for (int i = 16; i > 0; i --) {
        int [] sKey = subKey [i - 1];
        tmp = left;
        left = right;
        int [] fTemp = f (right, sKey);
        right = diffOr (tmp, fTemp);
    }
    for (int i = 0; i < 32; i ++) {
        data [i] = right [i];
        data [32 + i] = left [i];
    }
    data = changeInverseIP (data);
    return TypeConversion.hexInt2byte (data);
}


private void gaussianblur () {
    D3Tensor blur, conv, pop;
    DMatrix speqblur, speqconv, speqpop;
    int i, j, p, q;
    blur = new D3Tensor (1, 1, 1, lx, 1, ly);
    conv = new D3Tensor (1, 1, 1, lx, 1, ly);
    pop = new D3Tensor (1, 1, 1, lx, 1, ly);
    speqblur = new DMatrix (1, 1, 1, 2 * lx);
    speqconv = new DMatrix (1, 1, 1, 2 * lx);
    speqpop = new DMatrix (1, 1, 1, 2 * lx);
    for (i = 1; i <= lx; i ++) {
        for (j = 1; j <= ly; j ++) {
            if (i > lx / 2) {
                p = i - 1 - lx;
            }
            else {
                p = i - 1;
            }
            if (j > ly / 2) {
                q = j - 1 - ly;
            }
            else {
                q = j - 1;
            }
            pop.setElement (1, i, j, rho_0 [i - 1].array [j - 1]);
            conv.setElement (1, i, j, (float) (0.5 * (erf ((p + 0.5) / (Math.sqrt (2.0) * (blurWidth * Math.pow (blurWidthFactor, nblurs)))) - erf ((p - 0.5) / (Math.sqrt (2.0) * (blurWidth * Math.pow (blurWidthFactor, nblurs))))) * (erf ((q + 0.5) / (Math.sqrt (2.0) * (blurWidth * Math.pow (blurWidthFactor, nblurs)))) - erf ((q - 0.5) / (Math.sqrt (2.0) * (blurWidth * Math.pow (blurWidthFactor, nblurs))))) / (lx * ly)));
        }
    }
    rlft3 (pop, speqpop, 1, lx, ly, 1);
    rlft3 (conv, speqconv, 1, lx, ly, 1);
    for (i = 1; i <= lx; i ++) {
        for (j = 1; j <= ly / 2; j ++) {
            blur.setElement (1, i, 2 * j - 1, pop.getElement (1, i, 2 * j - 1) * conv.getElement (1, i, 2 * j - 1) - pop.getElement (1, i, 2 * j) * conv.getElement (1, i, 2 * j));
            blur.setElement (1, i, 2 * j, pop.getElement (1, i, 2 * j) * conv.getElement (1, i, 2 * j - 1) + pop.getElement (1, i, 2 * j - 1) * conv.getElement (1, i, 2 * j));
        }
    }
    for (i = 1; i <= lx; i ++) {
        speqblur.setElement (1, 2 * i - 1, speqpop.getElement (1, 2 * i - 1) * speqconv.getElement (1, 2 * i - 1) - speqpop.getElement (1, 2 * i) * speqconv.getElement (1, 2 * i));
        speqblur.setElement (1, 2 * i, speqpop.getElement (1, 2 * i) * speqconv.getElement (1, 2 * i - 1) + speqpop.getElement (1, 2 * i - 1) * speqconv.getElement (1, 2 * i));
    }
    rlft3 (blur, speqblur, 1, lx, ly, - 1);
    for (i = 1; i <= lx; i ++) {
        for (j = 1; j <= ly; j ++) {
            rho_0 [i - 1].array [j - 1] = blur.getElement (1, i, j);
        }
    }
}


-----Function Pair=60=-----==

void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


public void actionPerformed (ActionEvent e) {
    int ID = gui.getItemID (e);
    int i, j, k;
    int [] rows;
    BatchObject [] dup;
    Transferable t;
    BatchObject bObj;
    switch (ID) {
        case GG_CMDOPEN :
            if (batchTable.getSelectedRowCount () != 1) break;
            bObj = (BatchObject) batchVector.get (batchTable.getSelectedRow ());
            if (bObj.command != BatchObject.CMD_MODULE) break;
            DocumentFrame procWin;
            try {
                procWin = getProcInstance (bObj, null);
                procWin.fillGUI ();
                procWin.setVisible (true);
            } catch (Exception e1) {
                GUIUtil.displayError (getComponent (), e1, getTitle ());
            }
            break;
        case GG_CMDADD :
            i = batchTable.getSelectedRow () + 1;
            i = i == 0 ? batchVector.size () : i;
            batchTable.clearSelection ();
            batchVector.add (i, new BatchObject ());
            batchTM.fireTableRowsInserted (i, i);
            batchTable.setRowSelectionInterval (i, i);
            break;
        case GG_CMDCUT :
        case GG_CMDCOPY :
            rows = batchTable.getSelectedRows ();
            if (rows.length > 0) {
                dup = new BatchObject [rows.length];
                for (i = 0; i < rows.length; i ++) {
                    dup [i] = new BatchObject ((BatchObject) batchVector.get (rows [i]));
                }
                AbstractApplication.getApplication ().getClipboard ().setContents (new BatchObjectArray (dup), cbo);
                if (ID == GG_CMDCUT) {
                    for (boolean finished = false; ! finished;) {
                        for (i = 0, j = - 1, k = - 1; i < rows.length; i ++) {
                            if (rows [i] > j) {
                                j = rows [i];
                                k = i;
                            }
                        }
                        if (j >= 0) {
                            batchVector.remove (j);
                            rows [k] = - 1;
                            batchTM.fireTableRowsDeleted (j, j);
                        }
                        else {
                            finished = true;
                        }
                    }
                }
            }
            break;
        case GG_CMDPASTE :
            i = batchTable.getSelectedRow () + 1;
            i = i == 0 ? batchVector.size () : i;
            try {
                t = AbstractApplication.getApplication ().getClipboard ().getContents (enc_this);
                if (t != null) {
                    if (t.isDataFlavorSupported (BatchObjectArray.flavor)) {
                        dup = (BatchObject []) t.getTransferData (BatchObjectArray.flavor);
                        if (dup.length > 0) {
                            batchTable.clearSelection ();
                            for (j = 0, k = i; j < dup.length; j ++, k ++) {
                                batchVector.add (k, dup [j]);
                            }
                            batchTM.fireTableRowsInserted (i, k - 1);
                            batchTable.setRowSelectionInterval (i, k - 1);
                        }
                    }
                }
            } catch (IllegalStateException e97) {
            } catch (IOException e98) {
            } catch (UnsupportedFlavorException e99) {
            }
            break;
    }
}


-----Function Pair=61=-----==

public boolean finish () {
    if (! started) return false;
    boolean ok = true;
    started = false;
    try {
        out.write (0x3b);
        out.flush ();
        if (closeStream) {
            out.close ();
        }
    } catch (IOException e) {
        ok = false;
    }
    transIndex = 0;
    out = null;
    image = null;
    pixels = null;
    indexedPixels = null;
    colorTab = null;
    closeStream = false;
    firstFrame = true;
    return ok;
}


void genCatch (JCCatch tree, Env < GenContext > env, int startpc, int endpc, List < Integer > gaps) {
    if (startpc != endpc) {
        int catchType = makeRef (tree.pos (), tree.param.type);
        while (gaps.nonEmpty ()) {
            int end = gaps.head.intValue ();
            registerCatch (tree.pos (), startpc, end, code.curPc (), catchType);
            gaps = gaps.tail;
            startpc = gaps.head.intValue ();
            gaps = gaps.tail;
        }
        if (startpc < endpc) registerCatch (tree.pos (), startpc, endpc, code.curPc (), catchType);
        VarSymbol exparam = tree.param.sym;
        code.statBegin (tree.pos);
        code.markStatBegin ();
        int limit = code.nextreg;
        int exlocal = code.newLocal (exparam);
        items.makeLocalItem (exparam).store ();
        code.statBegin (TreeInfo.firstStatPos (tree.body));
        genStat (tree.body, env, CRT_BLOCK);
        code.endScopes (limit);
        code.statBegin (TreeInfo.endPos (tree.body));
    }
}


-----Function Pair=62=-----==

void convertFromABGRToRGBA () {
    int i;
    if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_ARRAY) {
        byte [] srcBuffer, dstBuffer;
        srcBuffer = getAsByteArray ();
        if (dataIsByRef) {
            dstBuffer = new byte [length];
            for (i = 0; i < length; i += 4) {
                dstBuffer [i] = srcBuffer [i + 3];
                dstBuffer [i + 1] = srcBuffer [i + 2];
                dstBuffer [i + 2] = srcBuffer [i + 1];
                dstBuffer [i + 3] = srcBuffer [i];
            }
            data = dstBuffer;
            dataIsByRef = false;
        }
        else {
            byte a, b;
            for (i = 0; i < length; i += 4) {
                a = srcBuffer [i];
                b = srcBuffer [i + 1];
                srcBuffer [i] = srcBuffer [i + 3];
                srcBuffer [i + 1] = srcBuffer [i + 2];
                srcBuffer [i + 2] = b;
                srcBuffer [i + 3] = a;
            }
        }
    }
    else if (imageDataType == ImageComponentRetained.ImageDataType.TYPE_BYTE_BUFFER) {
        assert dataIsByRef;
        ByteBuffer srcBuffer, dstBuffer;
        srcBuffer = getAsByteBuffer ();
        srcBuffer.rewind ();
        ByteOrder order = ByteOrder.nativeOrder ();
        dstBuffer = ByteBuffer.allocateDirect (length).order (order);
        dstBuffer.rewind ();
        for (i = 0; i < length; i += 4) {
            dstBuffer.put (i, srcBuffer.get (i + 3));
            dstBuffer.put (i + 1, srcBuffer.get (i + 2));
            dstBuffer.put (i + 2, srcBuffer.get (i + 1));
            dstBuffer.put (i + 3, srcBuffer.get (i));
        }
        dataIsByRef = false;
    }
}


private String [] toArgs (String line) {
    String lineargs [];
    String str = new String (line);
    Vector vec = new Vector ();
    for (;;) {
        while (str.startsWith (" ")) str = str.substring (1);
        if (str.length () == 0) break;
        int end = str.indexOf (" ");
        if (end == - 1) {
            vec.addElement (str);
            str = "";
        }
        else {
            vec.addElement (str.substring (0, end));
            str = str.substring (end);
        }
    }
    if (vec.size () != 0) {
        lineargs = new String [vec.size ()];
        for (int i = 0; i < lineargs.length; ++ i) lineargs [i] = (String) vec.elementAt (i);
        return lineargs;
    }
    return null;
}


-----Function Pair=63=-----==

private int nextLesserThan8Bits (int bitsToGet) {
    byte b, next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = data [bp + 1];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
        }
    }
    else {
        throw new RuntimeException ("TIFF_FILL_ORDER tag must be either 1 or 2.");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int shift = bitsLeft - bitsToGet;
    int i1, i2;
    if (shift >= 0) {
        i1 = (b & table1 [bitsLeft])>>> shift;
        bitPointer += bitsToGet;
        if (bitPointer == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
    }
    else {
        i1 = (b & table1 [bitsLeft]) << (- shift);
        i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
        i1 |= i2;
        bytePointer ++;
        bitPointer = bitsFromNextByte;
    }
    return i1;
}


private static final void sort (MyVec a, MyVec b, CompareFunc c, int start, int end) {
    Object tmpa, tmpb = null;
    if (start >= end) return;
    if (end - start <= 6) {
        for (int i = start + 1; i <= end; i ++) {
            tmpa = a.store [i];
            if (b != null) tmpb = b.store [i];
            int j;
            for (j = i - 1; j >= start; j --) {
                if (c.compare (a.store [j], tmpa) <= 0) break;
                a.store [j + 1] = a.store [j];
                if (b != null) b.store [j + 1] = b.store [j];
            }
            a.store [j + 1] = tmpa;
            if (b != null) b.store [j + 1] = tmpb;
        }
        return;
    }
    Object pivot = a.store [end];
    int lo = start - 1;
    int hi = end;
    do {
        while (c.compare (a.store [++ lo], pivot) < 0) {
        }
        while ((hi > lo) && c.compare (a.store [-- hi], pivot) > 0) {
        }
        swap (a, lo, hi);
        if (b != null) swap (b, lo, hi);
    }
    while (lo < hi);
    swap (a, lo, end);
    if (b != null) swap (b, lo, end);
    sort (a, b, c, start, lo - 1);
    sort (a, b, c, lo + 1, end);
}


-----Function Pair=64=-----==

private boolean jdpCommand (String command, String [] args) {
    runstat = true;
    int addr, count;
    if (user == null) {
        if (command.equals ("run")) {
            switch (args.length) {
                case 0 :
                    restart (saved_args);
                    break;
                default :
                    restart (args);
            }
        }
        else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
            if (args.length == 0) printHelp ("");
            else printHelp (args [0]);
        }
        else {
            jdp_console.writeOutput ("No program running, enter:  run ... ");
        }
        return false;
    }
    if (command.equals ("step") || command.equals ("s")) {
        boolean skip_prolog = false;
        printMode = PRINTASSEMBLY;
        runstat = user.pstep (0, printMode, skip_prolog);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        jdp_console.writeOutput ("step instruction over call: not supported yet on Lintel");
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        printMode = PRINTASSEMBLY;
        runstat = user.pstepLine (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        printMode = PRINTSOURCE;
        runstat = user.pstepLineOverMethod (0);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("run")) {
        jdp_console.writeOutput ("Debuggee is running, kill before restarting");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        switch (debuggerEnvironment) {
            case EXTERNALCREATE :
                runstat = false;
                break;
            case EXTERNALATTACH :
                jdp_console.writeOutput ("Cannot kill attached process, type quit to detach debugger");
                break;
            case INTERNAL :
                jdp_console.writeOutput ("Debugger running inside JVM, type quit to exit debugger");
        }
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        if (debuggerEnvironment == EXTERNALATTACH && ! user.bpset.anyBreakpointExist ()) {
            jdp_console.writeOutput ("no breakpoint currently set, detaching process");
            return true;
        }
        else {
            runstat = user.pcontinue (0, printMode, true);
            if (runstat == true) refreshEnvironment ();
        }
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        jdp_console.writeOutput ("Continue thread not supported yet on Lintel");
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        runstat = user.pcontinueToReturn (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        doThread (command, args);
    }
    else if (command.equals ("reg") || command.equals ("r")) {
        doRegisterRead (command, args);
    }
    else if (command.equals ("wreg") || command.equals ("wr")) {
        doRegisterWrite (command, args);
    }
    else if (command.equals ("memraw") || command.equals ("mraw")) {
        doMemoryReadRaw (command, args);
    }
    else if (command.equals ("mem") || command.equals ("m")) {
        doMemoryRead (command, args);
    }
    else if (command.equals ("wmem") || command.equals ("wm")) {
        doMemoryWrite (command, args);
    }
    else if (command.equals ("print") || command.equals ("p")) {
        doPrintCommand (command, args);
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        doPrintClassCommand (command, args);
    }
    else if (command.equals ("getclass")) {
        doGetClassCommand (command, args);
    }
    else if (command.equals ("getinstance")) {
        doGetInstanceCommand (command, args);
    }
    else if (command.equals ("getarray")) {
        doGetArrayCommand (command, args);
    }
    else if (command.equals ("getcl")) {
        doGetClassAndLine (command, args);
    }
    else if (command.equals ("getcia")) {
        doGetCurrentInstrAddr (command, args);
    }
    else if (command.equals ("getframes")) {
        doGetFrames (command, args);
    }
    else if (command.equals ("getlocals")) {
        doGetLocals (command, args);
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        jdp_console.writeOutput ("(this command has been removed because the Opt compiler does not generate the bytecode map)");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        doListInstruction (command, args);
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        doListThread (command, args);
    }
    else if (command.equals ("break") || command.equals ("b")) {
        doSetBreakpoint (command, args);
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        doClearBreakpoint (command, args);
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        doCurrentFrame (command, args);
    }
    else if (command.equals ("where") || command.equals ("w")) {
        doShortFrame (command, args);
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        doFullFrame (command, args);
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        doSetPreference (command, args);
    }
    else if (command.equals ("preference") || command.equals ("x2d")) {
        doConvertHexToInt (command, args);
    }
    else if (command.equals ("preference") || command.equals ("d2x")) {
        doConvertIntToHex (command, args);
    }
    else if (command.equals ("test")) {
        doTest (args);
    }
    else if (command.equals ("test1")) {
        doTest1 (args);
    }
    else if (command.equals ("count")) {
        doThreadCount (0);
    }
    else if (command.equals ("zerocount")) {
        doThreadCount (1);
    }
    else if (command.equals ("readmem")) {
        if (args.length != 0) {
            try {
                addr = parseHex32 (args [0]);
                int mydata = user.mem.read (addr);
                jdp_console.writeOutput ("true memory = x" + Integer.toHexString (mydata));
            } catch (NumberFormatException e) {
                jdp_console.writeOutput ("bad address: " + args [0]);
            }
        }
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        if (user.verbose) {
            jdp_console.writeOutput ("Verbose now OFF");
            user.verbose = false;
        }
        else {
            jdp_console.writeOutput ("Verbose now ON");
            user.verbose = true;
        }
    }
    else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
        if (args.length == 0) printHelp ("");
        else printHelp (args [0]);
    }
    else if (macro.exists (command + ".jdp")) {
        macro.load (command + ".jdp");
    }
    else {
        jdp_console.writeOutput ("Command not implemented");
    }
    return false;
}


public static Object financialXnpv (Object [] args, XelContext ctx) {
    double rate = CommonFns.toNumber (args [0]).doubleValue ();
    double [] values = new double [UtilFns.toList (args [1], ctx).size ()];
    values = UtilFns.toDoubleArray (UtilFns.toList (args [1], ctx));
    List ls = UtilFns.toList (args [2], ctx);
    if (values.length != ls.size ()) {
        throw new SSErrorXelException (SSError.NUM);
    }
    else {
        Date [] dates = UtilFns.toDateArray (ls);
        double xnpv = 0.0;
        for (int i = 0; i < dates.length; i ++) {
            double di = UtilFns.dateToDouble (dates [i]).doubleValue ();
            double d1 = UtilFns.dateToDouble (dates [0]).doubleValue ();
            xnpv += values [i] / Math.pow (1 + rate, (di * d1) / 365);
        }
        return new Double (xnpv);
    }
}


-----Function Pair=65=-----==

public static void lineDiagrammErzeugen (Object [] [] auswertung, int startRunde, int endRunde, Typ cmd, File file, Dimension d) {
    if (auswertung != null) {
        Diagramm diagramm = new Diagramm (auswertung, cmd);
        startRunde --;
        if (endRunde > diagramm.m) {
            endRunde = diagramm.m;
        }
        if (startRunde < 0) {
            startRunde = 0;
        }
        if (startRunde >= endRunde) {
            startRunde = 0;
            endRunde = diagramm.m;
        }
        DefaultCategoryDataset dataset = new DefaultCategoryDataset ();
        for (int n = diagramm.n - 1; n >= 0; n --) {
            for (int m = startRunde; m < endRunde; m ++) {
                dataset.addValue ((Integer) diagramm.getAuswertung () [n] [m], diagramm.getDataLegends () [n], new Integer (m + 1));
            }
        }
        JFreeChart chart = ChartFactory.createLineChart ("Auswertung: " + auswertung [0] [0], diagramm.getXLegend (), diagramm.getYLegend (), dataset, PlotOrientation.VERTICAL, true, false, false);
        chart.setBackgroundPaint (new Color (255, 255, 255, 0));
        CategoryPlot plot = (CategoryPlot) chart.getPlot ();
        plot.setBackgroundPaint (Color.white);
        plot.setRangeGridlinePaint (Color.black);
        LineAndShapeRenderer renderer = (LineAndShapeRenderer) plot.getRenderer ();
        renderer.setShapesVisible (true);
        renderer.setDrawOutlines (true);
        NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis ();
        rangeAxis.setStandardTickUnits (NumberAxis.createIntegerTickUnits ());
        rangeAxis.setAutoRange (true);
        CategoryAxis timeAxis = plot.getDomainAxis ();
        timeAxis.setLowerMargin (0.00);
        timeAxis.setUpperMargin (0.00);
        timeAxis.setCategoryLabelPositions (CategoryLabelPositions.UP_45);
        if (file != null) {
            saveChart (file, chart, d);
        }
    }
}


public synchronized void dots () {
    for (int i = pixels.length - 1; i >= 0; i --) {
        pixels [i] = 0;
        pixelsZ [i] = 1000;
    }
    for (int row = 0; row < 255; row ++) {
        for (int col = 0; col < 255; col ++) {
            int i = row * 256 + col;
            PlotVal p0 = plotList [i];
            if (p0 != null) {
                tr.transform (p0);
                int x = tr.X, y = tr.Y, z = tr.Z;
                int c0 = (lutNr == ORIGINAL) ? p0.color : getLutColor (p0);
                if ((x & ~ 511) == 0 && (y & ~ 511) == 0) {
                    int pos = (y << 9) | x;
                    if (z < pixelsZ [pos]) {
                        pixelsZ [pos] = z;
                        if (light > 0) {
                            tr.x = p0.dx;
                            tr.y = p0.dy;
                            tr.z = p0.dz;
                            tr.xyzPos_ ();
                            float l = light * (- tr.X / (float) p0.len) + 1;
                            int r = (int) Math.min (255, l * ((c0>> 16) & 0xff));
                            int g = (int) Math.min (255, l * ((c0>> 8) & 0xff));
                            int b = (int) Math.min (255, l * (c0 & 0xff));
                            pixels [pos] = 0xff000000 | (r << 16) | (g << 8) | b;
                        }
                        else pixels [pos] = c0;
                    }
                }
            }
        }
    }
    image = Toolkit.getDefaultToolkit ().createImage (source);
    imageRegion.setImage (image);
}


-----Function Pair=66=-----==

protected double getDensity (int i, double [] x) {
    double [] v = new double [dim];
    for (int k = 0; k < dim; k ++) {
        v [k] = x [k] - obMean [i].get (k, 0);
    }
    Matrix V = new Matrix (v, dim);
    Matrix Vt = V.transpose ();
    double e = Vt.times (obInvSigma [i]).times (V).get (0, 0);
    double f = 1.0d;
    for (int k = 0; k < dim; k ++) {
        f *= factor;
    }
    double d = f * Math.sqrt (obDetInvSigma [i]) * Math.exp (- 0.5 * e);
    return d;
}


private breakpoint setBreakpointAtStringClass (JDP_Field stringField) {
    JDP_Class stringClass = new JDP_Class ();
    stringClass.name = stringField.type;
    stringClass.address = stringField.address;
    try {
        user.bmap.classToJDPClass (stringClass.name, stringClass.address, false, stringClass);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field valueField = (JDP_Field) stringClass.fields.elementAt (0);
    String charArrayString = valueField.value;
    charArrayString = charArrayString.substring (1, charArrayString.indexOf ('}'));
    StringTokenizer st = new StringTokenizer (charArrayString, ", ", false);
    StringBuffer ret = new StringBuffer ();
    while (st.hasMoreTokens ()) {
        ret.append (st.nextToken ());
    }
    String className = ret.toString ();
    breakpoint bp = null;
    try {
        bp = user.bmap.findBreakpoint (className + ".main", null, user.reg.hardwareIP ());
    } catch (BmapMultipleException e1) {
        jdp_console.writeOutput (e1.getMessage ());
    } catch (BmapNotFoundException e2) {
        jdp_console.writeOutput (e2.getMessage ());
    }
    user.bpset.setBreakpoint (bp);
    return bp;
}


-----Function Pair=67=-----==

String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


private byte readKeystroke () {
    if (kIndex < kCount) {
        return keystrokes [kIndex ++];
    }
    kIndex = 0;
    kCount = 0;
    sync ();
    for (;;) {
        int cnt = 0;
        try {
            cnt = in.read (keystrokes);
        } catch (IOException e) {
            return (byte) '?';
        }
        if (cnt < 1) System.exit (1);
        int ch = keystrokes [0];
        switch (ch) {
            default :
                if (ch < ' ') break;
                if (cnt > 1) {
                    kCount = cnt;
                    kIndex = 0;
                    return (byte) keystrokes [kIndex ++];
                }
                else {
                    return (byte) ch;
                }
            case '\r' :
                return K_ENTER;
            case '\t' :
                return K_TAB;
            case '\b' :
                return K_BSP;
            case 0x10 :
                return K_UP;
            case 0x0e :
                return K_DN;
            case 0x06 :
                return K_RT;
            case 0x02 :
                return K_LT;
            case 0x01 :
                return K_HOME;
            case 0x05 :
                return K_END;
            case '\033' :
                if (cnt == 1) {
                    try {
                        int cnt2 = in.available ();
                        if (cnt2 == 2) {
                            cnt2 = in.read (keystrokes);
                            if (cnt2 == 2) {
                                switch ((int) keystrokes [1]) {
                                    case 'A' :
                                        return K_UP;
                                    case 'B' :
                                        return K_DN;
                                    case 'C' :
                                        return K_RT;
                                    case 'D' :
                                        return K_LT;
                                    case 'H' :
                                        return K_HOME;
                                    case 'P' :
                                        return K_DEL;
                                    default :
                                        break;
                                }
                            }
                        }
                        else {
                            return K_ESC;
                        }
                    } catch (IOException e) {
                    }
                }
                if (cnt == 3) switch ((int) keystrokes [2]) {
                    case 'A' :
                        return K_UP;
                    case 'B' :
                        return K_DN;
                    case 'C' :
                        return K_RT;
                    case 'D' :
                        return K_LT;
                    case 'H' :
                        return K_HOME;
                    case 'P' :
                        return K_DEL;
                    default :
                        break;
                }
                if (cnt == 6) {
                    int n = ((int) keystrokes [2] - '0') * 100 + ((int) keystrokes [3] - '0') * 10 + ((int) keystrokes [4] - '0') * 1;
                    switch (n) {
                        case 146 :
                            return K_END;
                    }
                }
                break;
        }
        beep ();
    }
}


-----Function Pair=68=-----==

private void openDownloadFile (int row) {
    String title = "";
    String url = "";
    if (SetUp.getOpenPicFileProgram ().matches ("")) {
        String nowSkinName = UIManager.getLookAndFeel ().getName ();
        String colorString = "blue";
        if (nowSkinName.equals ("HiFi") || nowSkinName.equals ("Noire")) {
            colorString = "yellow";
        }
        JOptionPane.showMessageDialog (this, "<html>尚未設定開啟程式，請前往<font color=" + colorString + ">選項 -> 瀏覽</font>做設定</html>", "提醒訊息", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.MISSION) {
        row = downTable.convertRowIndexToModel (row);
        title = String.valueOf (downTableModel.getRealValueAt (row, DownTableEnum.TITLE));
        url = downTableModel.getRealValueAt (row, DownTableEnum.URL).toString ();
    }
    else if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.BOOKMARK) {
        row = bookmarkTable.convertRowIndexToModel (row);
        title = String.valueOf (bookmarkTableModel.getValueAt (row, BookmarkTableEnum.TITLE));
        url = String.valueOf (bookmarkTableModel.getValueAt (row, BookmarkTableEnum.URL));
    }
    else if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.RECORD) {
        row = recordTable.convertRowIndexToModel (row);
        title = String.valueOf (recordTableModel.getValueAt (row, RecordTableEnum.TITLE));
        url = String.valueOf (recordTableModel.getValueAt (row, RecordTableEnum.URL));
    }
    Common.debugPrintln ("以外部程式開啟" + title + "的下載資料夾或壓縮檔");
    if (url.matches ("(?s).*e-hentai(?s).*") || url.matches ("(?s).*exhentai(?s).*")) {
        String cmd = SetUp.getOpenZipFileProgram ();
        String path = "";
        if (new File (SetUp.getOriginalDownloadDirectory () + title + ".zip").exists ()) {
            path = SetUp.getOriginalDownloadDirectory () + title + ".zip";
            Common.debugPrintln ("開啟命令：" + cmd + " " + path);
            if (Common.isWindows ()) {
                Common.runUnansiCmd (cmd, path);
            }
            else {
                try {
                    String [] cmds = new String [] {cmd, path};
                    Runtime.getRuntime ().exec (cmds, null, new File (Common.getNowAbsolutePath ()));
                } catch (IOException ex) {
                    Logger.getLogger (ComicDownGUI.class.getName ()).log (Level.SEVERE, null, ex);
                }
            }
        }
        else {
            path = SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ();
            if (! new File (path).exists ()) {
                String nowSkinName = UIManager.getLookAndFeel ().getName ();
                String colorString = "blue";
                if (nowSkinName.equals ("HiFi") || nowSkinName.equals ("Noire")) {
                    colorString = "yellow";
                }
                JOptionPane.showMessageDialog (this, "<html><font color=" + colorString + ">" + path + "</font>" + "不存在，無法開啟</html>", "提醒訊息", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            if (Common.isWindows ()) {
                Common.debugPrintln ("開啟命令：" + cmd + " " + path);
                Common.runUnansiCmd (cmd, path);
            }
            else {
                String [] picList = new File (path).list ();
                String firstPicFileInFirstVolume = picList [0];
                path += firstPicFileInFirstVolume;
                Common.debugPrintln ("開啟命令：" + cmd + " " + path);
                try {
                    String [] cmds = new String [] {cmd, path};
                    Runtime.getRuntime ().exec (cmds, null, new File (Common.getNowAbsolutePath ()));
                } catch (IOException ex) {
                    Logger.getLogger (ComicDownGUI.class.getName ()).log (Level.SEVERE, null, ex);
                }
            }
        }
    }
    else {
        if (Common.isWindows ()) {
            Common.runUnansiCmd (SetUp.getOpenPicFileProgram (), SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ());
        }
        else {
            Common.runCmd (SetUp.getOpenPicFileProgram (), SetUp.getOriginalDownloadDirectory () + title);
        }
    }
}


public void appendToSession (String image, String date) {
    ResultSet rs;
    int count;
    String query = "SELECT COUNT(*) FROM images WHERE images.image_file=\"" + image + "\";";
    if (getCount (query) == 0) {
        query = "INSERT INTO images SET images.image_file=\"" + image + "\";";
        if (showQuery) out.println ("Add to images: " + query + "<BR>");
        count = executeUpdate (query);
    }
    query = "SELECT uid FROM images WHERE images.image_file=\"" + image + "\";";
    String image_uid = "";
    if (showQuery) out.println ("Get image uid: " + query + "<BR>");
    rs = executeQuery (query);
    try {
        rs.next ();
        image_uid = rs.getString ("uid");
    } catch (SQLException sqle) {
        out.println ("SQL Exception Error " + sqle.toString ());
    }
    query = "SELECT COUNT(*) FROM dates WHERE dates.date=\"" + date + "\";";
    if (getCount (query) == 0) {
        query = "INSERT INTO dates SET dates.date=\"" + date + "\";";
        if (showQuery) out.println ("Add to Dates: " + query + "<BR>");
        count = executeUpdate (query);
    }
    query = "SELECT uid FROM dates WHERE dates.date=\"" + date + "\";";
    String date_uid = "";
    if (showQuery) out.println ("Get date uid: " + query + "<BR>");
    rs = executeQuery (query);
    try {
        rs.next ();
        date_uid = rs.getString ("uid");
    } catch (SQLException sqle) {
        out.println ("SQL Exception Error " + sqle.toString ());
    }
    query = "SELECT COUNT(*) FROM image_date WHERE image_date.date_uid=\"" + date_uid + "\" AND image_date.image_uid = \"" + image_uid + "\";";
    if (getCount (query) == 0) {
        query = "INSERT INTO image_date SET image_date.image_uid = \"" + image_uid + "\", image_date.date_uid = \"" + date_uid + "\";";
        if (showQuery) out.println ("Add to Image_Date: " + query + "<BR>");
        count = executeUpdate (query);
    }
    String setSession = "INSERT INTO session_results " + "SET session_uid = \"" + sessionid + "\", " + "date=\"" + date + "\", image_uid=" + image_uid + ", image_file=\"" + image + "\" ";
    if (showQuery) out.println ("AppendToSession: " + setSession + "<BR>");
    count = executeUpdate (setSession);
}


-----Function Pair=69=-----==

private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandGrammarState (edu.cmu.sphinx.decoder.linguist.GrammarState grammarState) {
    edu.cmu.sphinx.decoder.linguist.GrammarWord [] [] alternatives = grammarState.getGrammarNode ().getAlternatives ();
    if (alternatives.length == 0) {
        return grammarState;
    }
    else {
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState endGrammarState = new CombineState (grammarState, 0);
        for (int i = 0; i < alternatives.length; i ++) {
            edu.cmu.sphinx.decoder.linguist.AlternativeState alternativeState = new edu.cmu.sphinx.decoder.linguist.AlternativeState (grammarState, i);
            attachState (grammarState, alternativeState, logMath.getLogOne (), logMath.getLogOne () - logMath.linearToLog (alternatives.length), logMath.getLogOne ());
            edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = expandAlternative (alternativeState);
            if (alternatives.length == 1) {
                endGrammarState = lastState;
            }
            else {
                attachState (lastState, endGrammarState, logMath.getLogOne (), logMath.getLogOne (), logMath.getLogOne ());
            }
        }
        return endGrammarState;
    }
}


private void processHits (int hits, int [] sb) {
    float minz = Float.MAX_VALUE;
    int chosen = - 1;
    for (int i = 0; i < hits * 4; i += 4) {
        if (sb [i] < MAX_NAMESTACK_SIZE) {
            float z = sb [i + 1];
            z /= Float.MAX_VALUE;
            if (z < minz) {
                minz = z;
                chosen = sb [i + 3];
            }
        }
    }
    if (selection) {
        selected = chosen;
    }
}


-----Function Pair=70=-----==

public void write (byte [] b, int off, int len) throws IOException {
    if (swapOrderBits == 2) {
        if (swapRemainingByte != null && swapRemainingByte.length == 1) {
            buffer.put (b [off]);
            buffer.put (swapRemainingByte [0]);
            off ++;
        }
        int modulo = Math.abs (len - off) % swapOrderBits;
        if (modulo != 0) {
            swapRemainingByte = new byte [1];
            len -= modulo;
            System.arraycopy (b, len, swapRemainingByte, 0, modulo);
        }
        for (int i = off; i < len; i += 2) {
            byte temp = b [i];
            b [i] = b [i + 1];
            b [i + 1] = temp;
        }
    }
    buffer.put (b, off, len);
    int remains = buffer.position () - internalMark;
    while (remains > streamableByteNumber || remains > neededByteNumber) {
        if (streamableByteNumber == 0) {
            if (remains > neededByteNumber) {
                count ++;
                analyzeBuffer (buffer.array (), internalMark, neededByteNumber);
                if (streamableByteNumber == 0) {
                    throw new IOException ("Packet size cannot be Null !");
                }
                if (! discard) {
                    beforeChunkSend ();
                }
            }
            else {
                buffer.position (internalMark);
                buffer.compact ();
                buffer.position (remains);
                internalMark = 0;
                return;
            }
        }
        if (streamableByteNumber > 0) {
            if (remains >= streamableByteNumber) {
                if (! discard) {
                    out.write (buffer.array (), internalMark, streamableByteNumber);
                }
                internalMark += streamableByteNumber;
                remains = remains - streamableByteNumber;
                streamableByteNumber = 0;
                if (! discard) {
                    afterChunkSend ();
                }
                if (remains == 0) {
                    buffer.position (0);
                    internalMark = 0;
                }
            }
            else {
                if (! discard) {
                    out.write (buffer.array (), internalMark, remains);
                }
                streamableByteNumber = streamableByteNumber - remains;
                buffer.position (0);
                internalMark = 0;
                remains = 0;
            }
        }
    }
}


private void processFontCache (RdpPacket_Localised data) throws RdesktopException {
    Glyph glyph = null;
    int font = 0, nglyphs = 0;
    int character = 0, offset = 0, baseline = 0, width = 0, height = 0;
    int datasize = 0;
    byte [] fontdata = null;
    font = data.get8 ();
    nglyphs = data.get8 ();
    for (int i = 0; i < nglyphs; i ++) {
        character = data.getLittleEndian16 ();
        offset = data.getLittleEndian16 ();
        baseline = data.getLittleEndian16 ();
        width = data.getLittleEndian16 ();
        height = data.getLittleEndian16 ();
        datasize = (height * ((width + 7) / 8) + 3) & ~ 3;
        fontdata = new byte [datasize];
        data.copyToByteArray (fontdata, 0, data.getPosition (), datasize);
        data.incrementPosition (datasize);
        glyph = new Glyph (font, character, offset, baseline, width, height, fontdata);
        cache.putFont (glyph);
    }
}


-----Function Pair=71=-----==

public void moveNode (GraphNodeModel node, Point2D pos) {
    Point2D oldPos = node.getPosition ();
    node.setPosition (pos);
    Rectangle2D bbox = node.getChangeBBox ();
    GraphPortModel ports [] = node.getPorts ();
    for (int i = 0; i < ports.length; i ++) {
        ports [i].markDirty ();
        bbox.add (ports [i].getChangeBBox ());
        GraphEdgeModel edges [] = ports [i].getEdges ();
        for (int j = 0; j < edges.length; j ++) {
            edges [j].markDirty ();
            bbox.add (edges [j].getChangeBBox ());
        }
    }
    getModel ().markDirty ();
    repaint (bbox);
}


void mkKeyRelease (int detail, int root, int ev, int child, int rootx, int rooty, int ex, int ey, int state, int sames) {
    int i;
    index = 0;
    event [index ++] = (byte) 3;
    event [index ++] = (byte) detail;
    index += 2;
    i = (int) System.currentTimeMillis ();
    event [index ++] = (byte) ((i>> 24) & 0xff);
    event [index ++] = (byte) ((i>> 16) & 0xff);
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = root;
    event [index ++] = (byte) ((i>> 24) & 0xff);
    event [index ++] = (byte) ((i>> 16) & 0xff);
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = ev;
    event [index ++] = (byte) ((i>> 24) & 0xff);
    event [index ++] = (byte) ((i>> 16) & 0xff);
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = child;
    event [index ++] = (byte) ((i>> 24) & 0xff);
    event [index ++] = (byte) ((i>> 16) & 0xff);
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = rootx;
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = rooty;
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = ex;
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = ey;
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    i = state;
    event [index ++] = (byte) ((i>> 8) & 0xff);
    event [index ++] = (byte) (i & 0xff);
    event [index ++] = (byte) sames;
}


-----Function Pair=72=-----==

public static void main (String [] args) {
    int [] a = new int [1000000];
    for (int i = 0; i < a.length; i ++) {
        a [i] = i;
    }
    long start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findBinary (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
    start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findLinear (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
}


private void rankPackagesAndMoveClassesBelow () {
    int currentColumnPosition = 0;
    int currentRow = 0;
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        BOTLObjectSourceDiagramNode node = getBOTLRuleDiagramNode (i);
        if (node.isPackage ()) {
            if (currentColumnPosition <= _vMax) {
                node.setRank (currentRow);
                currentColumnPosition ++;
            }
            else {
                node.setRank (++ currentRow);
                currentColumnPosition = 0;
            }
        }
    }
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        if (getBOTLRuleDiagramNode (i).isPackage () && (getBOTLRuleDiagramNode (i).getRank () > _maxPackageRank)) {
            _maxPackageRank = getBOTLRuleDiagramNode (i).getRank ();
        }
    }
    _maxPackageRank ++;
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        if (! getBOTLRuleDiagramNode (i).isPackage ()) getBOTLRuleDiagramNode (i).addRank (_maxPackageRank);
    }
}


-----Function Pair=73=-----==

public static float atomPropertyFloat (Viewer viewer, Atom atom, int tokWhat) {
    switch (tokWhat) {
        case Token.radius :
            return atom.getRadius ();
        case Token.selected :
            return (viewer.isAtomSelected (atom.index) ? 1 : 0);
        case Token.surfacedistance :
            atom.group.chain.model.modelSet.getSurfaceDistanceMax ();
            return atom.getSurfaceDistance100 () / 100f;
        case Token.temperature :
            return atom.getBfactor100 () / 100f;
        case Token.hydrophobic :
            return atom.getHydrophobicity ();
        case Token.volume :
            return atom.getVolume (viewer, EnumVdw.AUTO);
        case Token.adpmax :
            return atom.getADPMinMax (true);
        case Token.adpmin :
            return atom.getADPMinMax (false);
        case Token.atomx :
        case Token.x :
            return atom.x;
        case Token.atomy :
        case Token.y :
            return atom.y;
        case Token.atomz :
        case Token.z :
            return atom.z;
        case Token.covalent :
            return atom.getCovalentRadiusFloat ();
        case Token.fracx :
            return atom.getFractionalCoord ('X', true);
        case Token.fracy :
            return atom.getFractionalCoord ('Y', true);
        case Token.fracz :
            return atom.getFractionalCoord ('Z', true);
        case Token.fux :
            return atom.getFractionalCoord ('X', false);
        case Token.fuy :
            return atom.getFractionalCoord ('Y', false);
        case Token.fuz :
            return atom.getFractionalCoord ('Z', false);
        case Token.ionic :
            return atom.getBondingRadiusFloat ();
        case Token.mass :
            return atom.getMass ();
        case Token.occupancy :
            return atom.getOccupancy100 () / 100f;
        case Token.partialcharge :
            return atom.getPartialCharge ();
        case Token.phi :
        case Token.psi :
        case Token.omega :
            if (atom.group.chain.model.isJmolDataFrame && atom.group.chain.model.jmolFrameType.startsWith ("plot ramachandran")) {
                switch (tokWhat) {
                    case Token.phi :
                        return atom.getFractionalCoord ('X', false);
                    case Token.psi :
                        return atom.getFractionalCoord ('Y', false);
                    case Token.omega :
                        if (atom.group.chain.model.isJmolDataFrame && atom.group.chain.model.jmolFrameType.equals ("plot ramachandran")) {
                            float omega = atom.getFractionalCoord ('Z', false) - 180;
                            return (omega < - 180 ? 360 + omega : omega);
                        }
                }
            }
            return atom.getGroupParameter (tokWhat);
        case Token.eta :
        case Token.theta :
        case Token.straightness :
            return atom.getGroupParameter (tokWhat);
        case Token.spacefill :
            return atom.getRadius ();
        case Token.backbone :
        case Token.cartoon :
        case Token.dots :
        case Token.ellipsoid :
        case Token.geosurface :
        case Token.halo :
        case Token.meshRibbon :
        case Token.ribbon :
        case Token.rocket :
        case Token.star :
        case Token.strands :
        case Token.trace :
            return viewer.getAtomShapeValue (tokWhat, atom.group, atom.index);
        case Token.unitx :
            return atom.getFractionalUnitCoord ('X');
        case Token.unity :
            return atom.getFractionalUnitCoord ('Y');
        case Token.unitz :
            return atom.getFractionalUnitCoord ('Z');
        case Token.vanderwaals :
            return atom.getVanderwaalsRadiusFloat (viewer, EnumVdw.AUTO);
        case Token.vibx :
            return atom.getVibrationCoord ('X');
        case Token.viby :
            return atom.getVibrationCoord ('Y');
        case Token.vibz :
            return atom.getVibrationCoord ('Z');
        case Token.vectorscale :
            Vector3f v = atom.getVibrationVector ();
            return (v == null ? 0 : v.length () * viewer.getVectorScale ());
    }
    return atomPropertyInt (atom, tokWhat);
}


public void getValueGradient (int which, Vec3 grad, double blur) {
    if (! errorOk || blur != lastBlur) getValueError (which, blur);
    if (gradOk && blur == lastBlur) {
        grad.set (gradient);
        return;
    }
    if (linkFrom [0] == null) {
        gradient.set (0.0, 0.0, 0.0);
        grad.set (0.0, 0.0, 0.0);
        gradOk = true;
        return;
    }
    lastBlur = blur;
    gradOk = true;
    linkFrom [0].getValueGradient (linkFromIndex [0], gradient, blur);
    gradient.scale (deriv);
    grad.set (gradient);
}


-----Function Pair=74=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=75=-----==

public static void QuickSortDSC (Vector M, int inicio, int fim, int [] index) {
    int i, j;
    Vector aux;
    double [] pivo = new double [index.length];
    for (i = 0; i < index.length; i ++) {
        pivo [i] = ((double []) ((Vector) M.get (inicio)).get (0)) [index [i]];
    }
    i = inicio;
    j = fim;
    while (i < j) {
        while (((double []) ((Vector) M.get (i)).get (0)) [index [0]] <= pivo [0] && i < fim) {
            if (((double []) ((Vector) M.get (i)).get (0)) [index [0]] == pivo [0]) {
                if (((double []) ((Vector) M.get (i)).get (0)) [index [1]] >= pivo [1]) {
                    i ++;
                }
                else {
                    break;
                }
            }
            else {
                i ++;
            }
        }
        while (((double []) ((Vector) M.get (j)).get (0)) [index [0]] >= pivo [0] && j > inicio) {
            if (((double []) ((Vector) M.get (j)).get (0)) [index [0]] == pivo [0]) {
                if (((double []) ((Vector) M.get (j)).get (0)) [index [1]] <= pivo [1]) {
                    j --;
                }
                else {
                    break;
                }
            }
            else {
                j --;
            }
        }
        if (i < j) {
            aux = (Vector) M.get (i);
            M.set (i, M.get (j));
            M.set (j, aux);
        }
    }
    if (inicio != j) {
        aux = (Vector) M.get (inicio);
        M.set (inicio, M.get (j));
        M.set (j, aux);
    }
    if (inicio < j - 1) {
        QuickSortDSC (M, inicio, j - 1, index);
    }
    if (fim > j + 1) {
        QuickSortDSC (M, j + 1, fim, index);
    }
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=76=-----==

public static void alaw2pcm8 (byte [] inBuffer, int inByteOffset, byte [] outBuffer, int outByteOffset, int sampleCount, boolean signed) {
    int alawIndex = inByteOffset;
    int pcmIndex = outByteOffset;
    if (signed) {
        while (sampleCount > 0) {
            outBuffer [pcmIndex ++] = (byte) ((a2l [inBuffer [alawIndex ++] & 0xFF]>> 8) & 0xFF);
            sampleCount --;
        }
    }
    else {
        while (sampleCount > 0) {
            outBuffer [pcmIndex ++] = (byte) ((a2l [inBuffer [alawIndex ++] & 0xFF]>> 8) + 128);
            sampleCount --;
        }
    }
}


public void visitTry (final JCTry tree) {
    final Env < GenContext > tryEnv = env.dup (tree, new GenContext ());
    final Env < GenContext > oldEnv = env;
    if (! useJsrLocally) {
        useJsrLocally = (stackMap == StackMapFormat.NONE) && (jsrlimit <= 0 || jsrlimit < 100 && estimateCodeComplexity (tree.finalizer) > jsrlimit);
    }
    tryEnv.info.finalize = new GenFinalizer () {
        void gen () {
            if (useJsrLocally) {
                if (tree.finalizer != null) {
                    Code.State jsrState = code.state.dup ();
                    jsrState.push (code.jsrReturnValue);
                    tryEnv.info.cont = new Chain (code.emitJump (jsr), tryEnv.info.cont, jsrState);
                }
                assert tryEnv.info.gaps.length () % 2 == 0;
                tryEnv.info.gaps.append (code.curPc ());
            }
            else {
                assert tryEnv.info.gaps.length () % 2 == 0;
                tryEnv.info.gaps.append (code.curPc ());
                genLast ();
            }
        } void genLast () {
            if (tree.finalizer != null) genStat (tree.finalizer, oldEnv, CRT_BLOCK);
        } boolean hasFinalizer () {
            return tree.finalizer != null;
        }
    }
    ;
    tryEnv.info.gaps = new ListBuffer < Integer > ();
    genTry (tree.body, tree.catchers, tryEnv);
}


-----Function Pair=77=-----==

private boolean recursiveDirDeletion (String path) throws IOException {
    boolean erfolg = true;
    FTPFile [] ftpFiles = this.filterDotDirs (this.ftpClient.listFiles (path));
    for (int xx = 0; xx < ftpFiles.length; xx ++) {
        StringBuffer actEntry = new StringBuffer (path).append ('/');
        actEntry.append (ftpFiles [xx].getName ());
        if (! ftpFiles [xx].isDirectory ()) {
            erfolg = this.deleteFile (actEntry.toString ());
        }
        else {
            erfolg = this.recursiveDirDeletion (actEntry.toString ());
        }
        if (! erfolg) {
            break;
        }
    }
    erfolg = this.removeDirectory (path);
    return (erfolg);
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=78=-----==

public void configure (Map < String, Object > configuration) {
    serverName = getPart (configuration, "serverUrl");
    port = getOptPart (configuration, 5222, "port");
    user = getPart (configuration, "user");
    password = getPart (configuration, "password");
    roomId = getOptPart (configuration, null, "room");
    ignoreRoster = getOptPart (configuration, false, "ignoreRoster");
    autoRegister = getOptPart (configuration, false, "autoRegister");
    anonymous = getOptPart (configuration, false, "anonymous");
    fileTransferThreshold = getOptPart (configuration, 100 * 1024, "fileTransferThreshold");
    config = new ConnectionConfiguration (serverName, port.intValue ());
    config.setRosterLoadedAtLogin (true);
    config.setReconnectionAllowed (true);
    SmackConfiguration.setPacketReplyTimeout (30000);
}


private void configure () {
    LogManager manager = LogManager.getLogManager ();
    String cname = getClass ().getName ();
    debug = Boolean.parseBoolean (get (manager, cname + ".debug", "false"));
    host = manager.getProperty (cname + ".host");
    port = Integer.parseInt (get (manager, cname + ".port", "6667"));
    ssl = Boolean.parseBoolean (get (manager, cname + ".ssl", "false"));
    username = manager.getProperty (cname + ".username");
    password = manager.getProperty (cname + ".password");
    channel = manager.getProperty (cname + ".channel");
    buffertype = get (manager, cname + ".bufferType", get (manager, cname + ".buffertype", "autopop"));
    nickname = manager.getProperty (cname + ".nickname");
    messageDelay = Integer.parseInt (get (manager, cname + ".messageDelay", get (manager, cname + ".messagedelay", "1000")));
    buffersize = Integer.parseInt (get (manager, cname + ".bufferSize", get (manager, cname + ".buffersize", "1000")));
}


-----Function Pair=79=-----==

public static void main (String [] args) {
    FTPClient client = new FTPClient ();
    try {
        client.connect ("192.168.1.10");
        client.login ("a", "123456");
        String [] names = client.listNames ();
        for (String name : names) {
            System.out.println ("Name = " + name);
        }
        FTPFile [] ftpFiles = client.listFiles ();
        for (FTPFile ftpFile : ftpFiles) {
            if (ftpFile.getType () == FTPFile.FILE_TYPE) {
                System.out.println ("FTPFile: " + ftpFile.getName () + "; " + FileUtils.byteCountToDisplaySize (ftpFile.getSize ()));
            }
        }
        client.logout ();
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            client.disconnect ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public void startGetList () throws Exception {
    fileList = new ArrayList < String > ();
    dirQueue = getQueue (queFilePath);
    if (dirQueue.size () != 0) {
        cn.imgdpu.GSAGUI.setStatusAsyn ("载入上次缓存文件...");
        fileList = getFileToArr (bufFilePath);
        fileCount = fileList.size () / 4;
        dirPre = dirQueue.get (0);
    }
    else {
        dirQueue.add ("/");
    }
    String dirNext;
    while (dirQueue.size () != 0 && ! cancel) {
        if (dirPre != null) dirQueue.remove (0);
        if (dirQueue.size () > 0) {
            dirNext = dirQueue.get (0);
            listFile (dirNext);
            dirPre = dirNext;
        }
    }
    if (! cancel) {
        delFileList.add (queFilePath);
        delFileList.add (bufFilePath);
    }
    else {
        setArrToFile (dirQueue, queFilePath);
        setArrToFile (fileList, bufFilePath);
    }
}


-----Function Pair=80=-----==

public void testChannelJoinAndRelocateMultipleTimes () throws Exception {
    String channelName = "foo";
    createChannel (channelName);
    ClientGroup group = new ClientGroup (someUsers);
    Set < SgsTestNode > nodes = addNodes (3);
    try {
        joinUsers (channelName, someUsers);
        checkUsersJoined (channelName, someUsers);
        sendMessagesToChannel (channelName, 2);
        checkChannelMessagesReceived (group, channelName, 2);
        DummyClient relocatingClient = group.getClient (MOE);
        SgsTestNode oldNode = serverNode;
        for (SgsTestNode newNode : nodes) {
            moveClient (relocatingClient, oldNode, newNode);
            checkUsersJoined (channelName, someUsers);
            sendMessagesToChannel (channelName, 2);
            checkChannelMessagesReceived (group, channelName, 2);
            oldNode = newNode;
        }
        group.disconnect (true);
        checkUsersJoined (channelName, noUsers);
    } finally {
        group.disconnect (false);
    }
}


public void end () {
    m_zipFormatter.end ();
    IOUtils.closeQuietly (m_outputStream);
    final FTPClient ftp = new FTPClient ();
    FileInputStream fis = null;
    try {
        if (m_url.getPort () == - 1 || m_url.getPort () == 0 || m_url.getPort () == m_url.getDefaultPort ()) {
            ftp.connect (m_url.getHost ());
        }
        else {
            ftp.connect (m_url.getHost (), m_url.getPort ());
        }
        if (m_url.getUserInfo () != null && m_url.getUserInfo ().length () > 0) {
            final String [] userInfo = m_url.getUserInfo ().split (":", 2);
            ftp.login (userInfo [0], userInfo [1]);
        }
        else {
            ftp.login ("anonymous", "opennmsftp@");
        }
        int reply = ftp.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            ftp.disconnect ();
            LogUtils.errorf (this, "FTP server refused connection.");
            return;
        }
        String path = m_url.getPath ();
        if (path.endsWith ("/")) {
            LogUtils.errorf (this, "Your FTP URL must specify a filename.");
            return;
        }
        File f = new File (path);
        path = f.getParent ();
        if (! ftp.changeWorkingDirectory (path)) {
            LogUtils.infof (this, "unable to change working directory to %s", path);
            return;
        }
        LogUtils.infof (this, "uploading %s to %s", f.getName (), path);
        ftp.setFileType (FTP.BINARY_FILE_TYPE);
        fis = new FileInputStream (m_zipFile);
        if (! ftp.storeFile (f.getName (), fis)) {
            LogUtils.infof (this, "unable to store file");
            return;
        }
        LogUtils.infof (this, "finished uploading");
    } catch (final Exception e) {
        LogUtils.errorf (this, e, "Unable to FTP file to %s", m_url);
    } finally {
        IOUtils.closeQuietly (fis);
        if (ftp.isConnected ()) {
            try {
                ftp.disconnect ();
            } catch (IOException ioe) {
            }
        }
    }
}


-----Function Pair=81=-----==

public MyFTPFile getFileFromId (Entry parentEntry, String id, String baseDir) throws Exception {
    String path;
    if ((id == null) || (id.length () == 0)) {
        FTPFile file = new FTPFile ();
        file.setName (baseDir);
        file.setType (FTPFile.DIRECTORY_TYPE);
        return new MyFTPFile (file, baseDir);
    }
    else {
        path = new String (RepositoryUtil.decodeBase64 (id));
    }
    FTPFile ftpFile = getCache (parentEntry).get (path);
    if (ftpFile != null) {
        return new MyFTPFile (ftpFile, path);
    }
    FTPClient ftpClient = getFtpClient (parentEntry);
    if (ftpClient == null) {
        return null;
    }
    try {
        boolean isDir = isDir (ftpClient, path);
        if (isDir) {
            File tmp = new File (path);
            String parent = tmp.getParent ().replace ("\\", "/");
            String name = tmp.getName ();
            FTPFile [] files = ftpClient.listFiles (parent);
            MyFTPFile lookingForThisOne = null;
            for (int i = 0; i < files.length; i ++) {
                String childPath = parent + "/" + files [i].getName ();
                putCache (parentEntry, childPath, files [i]);
                if (files [i].getName ().equals (name)) {
                    lookingForThisOne = new MyFTPFile (files [i], childPath);
                }
            }
            if (lookingForThisOne != null) {
                return lookingForThisOne;
            }
            System.err.println ("Could not find directory:" + name + " path:" + path);
            return null;
        }
        else {
            FTPFile [] files = ftpClient.listFiles (path);
            if (files.length == 1) {
                putCache (parentEntry, path, files [0]);
                return new MyFTPFile (files [0], path);
            }
            else {
                System.err.println ("Got bad # of files when getting file:" + files.length + "  " + path);
            }
        }
        return null;
    } finally {
        closeConnection (ftpClient);
    }
}


private void testIcqGateway (EnumSet < ServerType > result) throws Exception {
    Thread.sleep (60 * 1000);
    presenceExists = false;
    log.info (gatewayJid);
    Roster roster = conn.getRoster ();
    if (roster.getEntry (gatewayJid) == null) {
        ServerType responseType = registerOnGateway ();
        if (responseType != null) {
            result.add (responseType);
        }
    }
    else {
        log.warn ("    Gateway already presents : " + gatewayJid);
        Presence gatewayPresence = roster.getPresence (gatewayJid);
        if (! gatewayPresence.isAvailable ()) {
            loginToGateway ();
        }
    }
    if (! result.isEmpty ()) return;
    String userJid = ICQ_USER + '@' + gatewayJid;
    addContact (userJid);
    Chat chat = conn.getChatManager ().createChat (userJid, simpleMessageListener);
    simpleMessageListener.setChat (chat);
    Thread.sleep (60 * 1000);
    if (presenceExists) {
        aliveServers.add (gatewayJid);
    }
    boolean wasOnline = true;
    if (simpleMessageListener.error != null) result.add (simpleMessageListener.error);
    if (simpleMessageListener.error == ServerType.sameMessage) {
        log.warn ("    Server message : " + simpleMessageListener.lastMessage);
    }
    simpleMessageListener.setChat (null);
    RosterEntry icqUser = roster.getEntry (userJid);
    boolean icqUserSubscribed = icqUser != null && icqUser.getType () == RosterPacket.ItemType.both;
    Presence icqUserOnlinePresence = presenceData.get (userJid);
    boolean icqUserOnline = icqUserOnlinePresence != null && icqUserOnlinePresence.isAvailable ();
    if (! icqUserOnline) result.add (ServerType.notsubscribed);
    if (! wasOnline) result.add (ServerType.notvisibleme);
    if (! icqUserSubscribed) result.add (ServerType.notvisiblehim);
    RosterEntry icqGatewayUser = roster.getEntry (gatewayJid);
    boolean gatewaySubscribed = icqGatewayUser != null && icqGatewayUser.getStatus () != RosterPacket.ItemStatus.SUBSCRIPTION_PENDING;
    unregisterOnGateway ();
    removeAllIcqUsers ();
}


-----Function Pair=82=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=83=-----==

public void unzip (ZipFile zip, File dir) {
    if (! dir.exists ()) {
        dir.mkdir ();
    }
    try {
        ZipEntry entry;
        Enumeration entries = zip.entries ();
        while (entries.hasMoreElements ()) {
            entry = (ZipEntry) entries.nextElement ();
            String name = dir.getPath () + FILE_SEPARATOR + entry.getName ();
            if (entry.isDirectory ()) {
                File f = new File (name);
                if (! f.exists ()) f.mkdir ();
            }
            else {
                copyInputStream (zip.getInputStream (entry), new BufferedOutputStream (new FileOutputStream (name)));
            }
        }
        zip.close ();
    } catch (FileNotFoundException ex) {
        org.softnetwork.log.Log4jConnector.getConsole ().error (ex.getMessage (), ex);
    } catch (IOException ex) {
        org.softnetwork.log.Log4jConnector.getConsole ().error (ex.getMessage (), ex);
    }
}


public ComposeMessageFrame (Storage storage, UserMessage message) {
    this.storage = storage;
    if (storage != null) this.message = message;
    initGUI ();
    if (storage != null) {
        boolean isOutbound = message.isOutbound ();
        boolean isDraft = message.isDraft ();
        addWindowListener (new WindowAdapter () {
            public void windowClosing (WindowEvent e) {
                int choice = JOptionPane.showOptionDialog (ComposeMessageFrame.this, "Would you like to save this message, or discard it?", null, JOptionPane.YES_NO_OPTION, JOptionPane.PLAIN_MESSAGE, null, new String [] {"Save", "Discard", "Cancel"}, "Save");
                if (choice == 0) ComposeMessageFrame.this.dispose ();
                else if (choice == 1) discardMessage ();
            } public void windowClosed (WindowEvent e) {
                saveMessage ();
                composeFrames.remove (ComposeMessageFrame.this.message);
            }
        }
        );
        composeFrames.put (ComposeMessageFrame.this.message, ComposeMessageFrame.this);
        attachmentsList.setEnabled (true);
        attachmentsList.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
        isEditable = isOutbound && isDraft;
        if (isEditable) {
            buttonPanel.remove (includeHistoryCheckbox);
            buttonPanel.remove (replyButton);
            buttonPanel.remove (replyToAllButton);
            buttonPanel.remove (forwardButton);
            buttonPanel.remove (closeButton);
        }
        else {
            subjectField.setEditable (false);
            messageArea.setEditable (false);
            addRecipientButton.setEnabled (false);
            removeRecipientButton.setEnabled (false);
            attachmentsToolbar.remove (addFileButton);
            attachmentsToolbar.remove (addFolderButton);
            attachmentsToolbar.remove (removeAttachmentButton);
            attachmentHelpPanel.remove (attachmentAreaHintLabel);
            buttonPanel.remove (sendButton);
            buttonPanel.remove (saveButton);
            buttonPanel.remove (cancelButton);
        }
        fromContents.setText (message.getSender ());
        subjectField.setText (message.getSubject ());
        messageArea.setText (message.getMessage ());
        addFileChooser.setMultiSelectionEnabled (true);
        addFolderChooser.setMultiSelectionEnabled (true);
        saveChooser.setMultiSelectionEnabled (false);
        saveAllChooser.setMultiSelectionEnabled (false);
        addFileChooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
        addFolderChooser.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
        saveChooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
        saveAllChooser.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
    }
}


-----Function Pair=84=-----==

public void makeChapters () {
    Vector chapters = moodle.getSections ();
    for (int i = 0; i < chapters.size (); i ++) {
        new File (path + courseName + "/Chapter_" + i).mkdirs ();
        Section sect = (Section) chapters.get (i);
        Vector mods = sect.getMods ();
        Lom chapterLom = new Lom (path + courseName + "/Chapter_" + i + ".xml");
        chapterLom.createEmptyDoc ();
        try {
            chapterLom.saveXML ();
        } catch (IOException ex) {
            System.out.println ("!!!" + ex.getLocalizedMessage ());
        }
        imsManifest.mainAsset.getFiles ().add (courseName + "/Chapter_" + i + ".xml");
        OrgItem chOrgItem = new OrgItem ();
        chOrgItem.setIdentifier ("S_" + i);
        chOrgItem.setTitle (sect.getSummary ());
        for (int j = 0; j < mods.size (); j ++) {
            Integer modId = (Integer) mods.get (j);
            Mod mod = moodle.getMod (modId);
            makeHtml (path + courseName + "/Chapter_" + i + "/sco_" + j + ".html", mod);
            makeLom (path + courseName + "/Chapter_" + i + "/sco_" + j + ".xml", mod);
            imsManifest.addRes (courseName + "/Chapter_" + i + "/sco_", i, j);
            OrgItem modOrgItem = new OrgItem ();
            modOrgItem.setIdentifier ("S_" + i + "_" + j);
            modOrgItem.setTitle (mod.getTitle ());
            modOrgItem.setIdentifierref ("RS_" + i + "_" + j);
            chOrgItem.addItem (modOrgItem);
        }
        imsManifest.orgItem.addItem (chOrgItem);
    }
}


private static DateRange recursiveFileSearch (String location, DateRange range) {
    File folder = new File (location);
    File [] listOfFiles = folder.listFiles (new FileFilter () {
        @Override
        public boolean accept (File file) {
            boolean isJPG = file.getName ().toLowerCase ().endsWith (".jpg");
            boolean isDir = file.isDirectory ();
            return isJPG || isDir;
        }
    }
    );
    for (int i = 0; i < listOfFiles.length; i ++) {
        File current = listOfFiles [i];
        if (! current.isDirectory ()) {
            Date d = null;
            try {
                d = DateFromExif (current.getAbsoluteFile ());
            } catch (IOException e) {
                Debug.print (e);
            }
            if (range.getStart () == null) {
                range.setStart (range.setEnd (d));
            }
            else if (d.before (range.getStart ())) {
                range.setStart (d);
            }
            else if (d.after (range.getEnd ())) {
                range.setEnd (d);
            }
        }
        else {
            range = recursiveFileSearch (current.getAbsolutePath (), range);
        }
    }
    return range;
}


-----Function Pair=85=-----==

public boolean deleteDebianPackages (Collection < Package > deleteList) {
    boolean ret = true;
    final int multiplier = maxProgress / deleteList.size ();
    int i = 1;
    lock.writeLock ().lock ();
    try {
        for (final Package pkg : deleteList) {
            if (! new File (archivesDir, pkg.getFilename ()).delete () || ! archivesDB.removePackage (pkg)) ret = false;
            setActprogress (i * multiplier);
            i ++;
        }
    } finally {
        lock.writeLock ().unlock ();
    }
    setActprogress (maxProgress);
    setIsDoneTrue ();
    return ret;
}


public static void runJava (Project pro, String classname, String...args) {
    org.apache.tools.ant.Project antProj = new org.apache.tools.ant.Project ();
    Java java = new Java ();
    java.setProject (antProj);
    java.setDir (new File (pro.getName ()));
    java.setClassname (classname);
    java.setFork (true);
    java.setFailonerror (true);
    Path classpath = new Path (antProj);
    addDepToPath (antProj, classpath, pro.getAllDependencies ());
    classpath.add (new Path (antProj, pro.getName () + "/bin"));
    java.setClasspath (classpath);
    for (String arg : args) java.createArg ().setValue (arg);
    java.execute ();
}


-----Function Pair=86=-----==

public static IProject CreateJavaProject (String name, IPath classpath) throws CoreException {
    IWorkspace workspace = ResourcesPlugin.getWorkspace ();
    IWorkspaceRoot root = workspace.getRoot ();
    IProject project = root.getProject (name);
    project.create (null);
    project.open (null);
    IProjectDescription desc = project.getDescription ();
    desc.setNatureIds (new String [] {JavaCore.NATURE_ID});
    project.setDescription (desc, null);
    IJavaProject javaProj = JavaCore.create (project);
    IFolder binDir = project.getFolder ("bin");
    IPath binPath = binDir.getFullPath ();
    javaProj.setOutputLocation (binPath, null);
    IClasspathEntry cpe = JavaCore.newLibraryEntry (classpath, null, null);
    javaProj.setRawClasspath (new IClasspathEntry [] {cpe}, null);
    return project;
}


public void copyFile (String oldPathFile, String newPathFile) {
    try {
        int bytesum = 0;
        int byteread = 0;
        File oldfile = new File (oldPathFile);
        if (oldfile.exists ()) {
            InputStream inStream = new FileInputStream (oldPathFile);
            FileOutputStream fs = new FileOutputStream (newPathFile);
            byte [] buffer = new byte [1444];
            while ((byteread = inStream.read (buffer)) != - 1) {
                bytesum += byteread;
                System.out.println (bytesum);
                fs.write (buffer, 0, byteread);
            }
            inStream.close ();
        }
    } catch (Exception e) {
        message = ("���Ƶ����ļ���������");
    }
}


-----Function Pair=87=-----==

private HSSFCellStyle createStyle (ReportSAXParser.Column c, HSSFWorkbook wb, short colIndex, short dataFormat) {
    Style st = new Style (c.iBorder, c.iFontSize, c.iWrap, c.sFont, colIndex, dataFormat);
    HSSFCellStyle newStyle = m_styles.get (st);
    if (newStyle != null) return newStyle;
    newStyle = wb.createCellStyle ();
    m_styles.put (st, newStyle);
    newStyle.setVerticalAlignment (HSSFCellStyle.VERTICAL_CENTER);
    newStyle.setDataFormat (dataFormat);
    switch (c.iBorder) {
        case 1 :
            newStyle.setBorderBottom (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderTop (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderLeft (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderRight (HSSFCellStyle.BORDER_NONE);
            break;
        case 2 :
            newStyle.setBorderBottom (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderTop (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderLeft (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderRight (HSSFCellStyle.BORDER_NONE);
            break;
        case 3 :
            newStyle.setBorderBottom (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderTop (HSSFCellStyle.BORDER_NONE);
            newStyle.setBorderLeft (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderRight (HSSFCellStyle.BORDER_THIN);
            break;
        case 4 :
            newStyle.setBorderBottom (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderTop (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderLeft (HSSFCellStyle.BORDER_THIN);
            newStyle.setBorderRight (HSSFCellStyle.BORDER_THIN);
            break;
    }
    if (colIndex == - 1) {
        newStyle.setFillPattern (HSSFCellStyle.NO_FILL);
    }
    else {
        newStyle.setFillForegroundColor (colIndex);
        newStyle.setFillPattern (HSSFCellStyle.SOLID_FOREGROUND);
    }
    HSSFFont fn = wb.findFont ((short) 400, (short) 32767, (short) (c.iFontSize * 20), c.sFont, false, false, (short) 0, (byte) 0);
    if (fn == null) {
        fn = wb.createFont ();
        fn.setFontName (c.sFont);
        fn.setFontHeight ((short) (c.iFontSize * 20));
    }
    newStyle.setFont (fn);
    if (c.iWrap > 0) newStyle.setWrapText (true);
    else newStyle.setWrapText (false);
    return newStyle;
}


public void valueChanged (ListSelectionEvent le) {
    if (jListWords.getSelectedValue () != null) {
        highlighter.removeAllHighlights ();
        WordsListElement listElement = (WordsListElement) jListWords.getSelectedValue ();
        txtWord.setText (listElement.getWord ());
        try {
            String def = getDefinition (listElement);
            txtDefinition.setText (def);
            highlightWord (def, listElement.getWord ());
            txtDefinition.setCaretPosition (0);
            txtWord.setText (listElement.getWord ());
            if (! listElement.getWord ().equals (currentSearch.getWord ())) {
                currentSearch = new SearchedWord (Searchs.WHOLE, listElement.getWord ());
                if (nbWordHistorique < SIZE_HISTORIQUE) {
                    historiqueWord.push (currentSearch);
                    nbWordHistorique ++;
                }
                else {
                    historiqueWord.removeLast ();
                    historiqueWord.push (currentSearch);
                }
            }
        } catch (BadLocationException ex) {
            ex.printStackTrace ();
        } catch (SAXException e) {
            e.printStackTrace ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=88=-----==

public static Any getReportList (Connection con, Any values, Any retValue) throws SQLException, IOException, ParserConfigurationException, SAXException {
    PreparedStatement ps = null;
    try {
        HashMap map = (HashMap) values.extract_Value ();
        String sParentID = (String) map.get ("PID");
        String sSql = ResourceBundle.getBundle (ExcelReports.class.getName ()).getString ("getReportList");
        ps = con.prepareStatement (sSql);
        ps.setString (1, sParentID);
        ResultSet rSet = ps.executeQuery ();
        HashMap [] ret = ObjUtil.getResultFromResultSet (rSet, "IOBJID", "COBJNAME", "DCREATE", "COBJNUM");
        retValue.insert_Value (ret);
    } finally {
        if (ps != null) ps.close ();
    }
    System.gc ();
    return retValue;
}


private String replaceQuotedStrings (String query) {
    StringBuffer buff = new StringBuffer (query);
    Pattern pattern = Pattern.compile (REGEX_QUOTED_STRING);
    Matcher matcher = pattern.matcher (buff);
    boolean found = false;
    int i = 0;
    while (matcher.find ()) {
        quotedStrings.add (matcher.group ());
        buff.replace (matcher.start (), matcher.end (), "{" + i + "}");
        matcher.reset ();
        found = true;
        i ++;
    }
    if (! found) {
    }
    String ret = buff.toString ();
    return ret;
}


-----Function Pair=89=-----==

public synchronized boolean exists (String file, long maximumWaitTime) {
    if (file == null) {
        return false;
    }
    long startTime = System.currentTimeMillis ();
    boolean hasAppeard = false;
    File f = new File (file);
    while (true) {
        boolean exists = f.exists ();
        if (exists) {
            hasAppeard = true;
            break;
        }
        if (maximumWaitTime <= 0) {
            break;
        }
        long currentTime = System.currentTimeMillis ();
        long lapTime = currentTime - startTime;
        if (lapTime > maximumWaitTime) {
            break;
        }
        try {
            this.wait (500);
        } catch (InterruptedException ie) {
            logger.log (Level.WARNING, ie.getMessage (), ie);
        }
    }
    return hasAppeard;
}


protected FBCompiler getFBCompiler (Element compilerElem) {
    if (compilerElem != null) {
        String Language = compilerElem.getAttributeValue ("Language");
        String Vendor = compilerElem.getAttributeValue ("Vendor");
        String Product = compilerElem.getAttributeValue ("Product");
        String Version = compilerElem.getAttributeValue ("Version");
        FBCompiler fbCompiler = new FBCompiler (Language, Vendor, Product, Version);
        return fbCompiler;
    }
    else {
        System.err.println ("Invalid element input in getFBCompiler()");
        if (this.console != null) {
            console.setText ("Invalid element input in getFBCompiler()");
        }
        return null;
    }
}


-----Function Pair=90=-----==

private void appendFilter (StringBuilder sb, boolean not, String field, String comparator, String param, boolean quoteParam) {
    if (not) {
        sb.append ("not ");
    }
    boolean quoteField = ! NamingHelper.NAME_FIELD_REF.equals (field);
    if (quoteField) {
        sb.append ("`");
    }
    sb.append (field);
    if (quoteField) {
        sb.append ("`");
    }
    sb.append (" ");
    sb.append (comparator);
    sb.append (" ");
    if (quoteParam) {
        sb.append ("'");
    }
    sb.append (param);
    if (quoteParam) {
        sb.append ("'");
    }
}


private String replaceQuotedStrings (String query) {
    StringBuffer buff = new StringBuffer (query);
    Pattern pattern = Pattern.compile (REGEX_QUOTED_STRING);
    Matcher matcher = pattern.matcher (buff);
    boolean found = false;
    int i = 0;
    while (matcher.find ()) {
        quotedStrings.add (matcher.group ());
        buff.replace (matcher.start (), matcher.end (), "{" + i + "}");
        matcher.reset ();
        found = true;
        i ++;
    }
    if (! found) {
    }
    String ret = buff.toString ();
    return ret;
}


-----Function Pair=91=-----==

public void replaceNamedVar (String sqlVar, String filterVarValue, String filterVarName, int max) {
    if (max <= 0) {
        max = Integer.MAX_VALUE;
    }
    List < Integer > bounds = nextUnbound (sqlVar);
    int count = 0;
    while (bounds != null && ! bounds.isEmpty ()) {
        sqlString.replace (bounds.get (0) - OFFSET, bounds.get (1) - OFFSET, filterVarValue + String.format (" /*%s%s*/", sqlVar, filterVarName == null ? "" : " (" + filterVarName + ")"));
        count ++;
        if (count > max) {
            break;
        }
        bounds = nextUnbound (sqlVar);
    }
}


public static void saveXsltFile (String file, Document document, ConfigData configData) throws SaveFileException {
    SaveFileHandler.saveStylesheet (document, configData);
    try {
        TransformerFactory tf = TransformerFactory.newInstance ();
        tf.setAttribute ("indent-number", INDENT);
        Transformer writer = tf.newTransformer ();
        writer.setOutputProperty (OutputKeys.INDENT, "yes");
        writer.setOutputProperty ("encoding", OptionItems.ENCODING);
        writer.setOutputProperty (OutputKeys.METHOD, "xml");
        OutputStreamWriter osw = new OutputStreamWriter (new FileStreamOutput (new FileOutputStream (new File (file))), Charset.forName (OptionItems.ENCODING));
        writer.transform (new DOMSource (document), new StreamResult (osw));
    } catch (Exception ex) {
        Log.error (ex);
        throw new SaveFileException (ex);
    }
}


-----Function Pair=92=-----==

static String formatExpression (String expression) throws JPLParseException {
    Pattern pattern = Pattern.compile ("([(!]*)\\s*([nNcC]?t(?:erm)?)?\\s*(!?=)" + "\\s*([abcxyzipP]+(?:\\s*,\\s*[abcxyzipP]{1,2})*)\\s*(\\)*)" + "\\s*([|&])?\\s*");
    Matcher match = pattern.matcher (expression);
    boolean found = false;
    StringBuffer sb = new StringBuffer ();
    String binOperator = null;
    int shift = 0;
    int openParenthesis = 0;
    int closedParenPos = 0;
    while (match.find ()) {
        found = true;
        if (logger.isDebugEnabled ()) {
            logger.debug (shift + ": '" + match.group (0) + "' found ! ");
        }
        if (match.group (1) != null) {
            openParenthesis += match.group (1).replace ("!", "").length ();
            sb.append (match.group (1));
        }
        if (match.group (2).equals ("term")) {
            String [] types = match.group (4).split (",");
            for (String type : types) {
                try {
                    sb.append (toTermString (type, match.group (3)));
                } catch (JPLParseException e) {
                    throw new JPLParseException ("'" + expression + "': parse exception", shift + match.start (4), e);
                }
                sb.append (" | ");
            }
            sb.delete (sb.length () - 2, sb.length ());
        }
        else {
            sb.append (match.group (2));
            sb.append (match.group (3));
            sb.append (match.group (4));
        }
        if (match.group (5) != null) {
            closedParenPos = match.end (5);
            openParenthesis -= match.group (5).length ();
            sb.append (match.group (5));
        }
        binOperator = match.group (6);
        if (binOperator != null) {
            sb.append (" " + binOperator + " ");
        }
        if (logger.isDebugEnabled ()) {
            for (int i = 1; i <= match.groupCount (); i ++) {
                logger.debug ("group " + i + ": " + match.group (i));
            }
        }
        shift = match.end ();
    }
    if (! found) {
        throw new JPLParseException ("bad peak type conditional expression: " + expression, 0);
    }
    else if (openParenthesis != 0) {
        boolean beg = (openParenthesis > 0) ? true : false;
        throw new JPLParseException (((beg) ? "missing" : "remove") + " token ')'" + " in conditional expression: '" + expression + "'", closedParenPos);
    }
    return sb.toString ();
}


public void startElement (String uri, String localName, String qName, Attributes attributes) throws SAXException {
    if (qName == null) {
        return;
    }
    if (_textBuffer != null && _textBuffer.toString ().length () > 0) {
        addTextNode (_currentNode, _textBuffer.toString ());
        _textBuffer = null;
    }
    if ("jjp:html".equals (qName)) {
        return;
    }
    else if ("jjp:title".equals (qName)) {
        _map.setString ("title", attributes.getValue ("value"));
        return;
    }
    else if ("jjp:list".equals (qName)) {
        String listName = attributes.getValue ("name");
        XmlViewNodeList node = new XmlViewNodeList ();
        node.setListName (listName);
        _currentNode.addNode (node);
        _currentNode = node;
        return;
    }
    else if ("jjp:value".equals (qName)) {
        String valueName = attributes.getValue ("name");
        XmlViewNodeValue node = new XmlViewNodeValue ();
        node.setValueName (valueName);
        _currentNode.addNode (node);
        return;
    }
    else if (ValueUtility.equalsString ("jjp:html", qName)) {
    }
    else if (qName.startsWith ("jjp:")) {
    }
    StringBuffer buffer = new StringBuffer ();
    buffer.append ("<");
    buffer.append (qName);
    for (int attrIndex = 0; attrIndex < attributes.getLength (); attrIndex ++) {
        String attrName = attributes.getQName (attrIndex);
        String attrValue = attributes.getValue (attrIndex);
        buffer.append (" ");
        buffer.append (attrName);
        buffer.append ("=\"");
        buffer.append (attrValue);
        buffer.append ("\"");
    }
    buffer.append (">");
    if (qName.equals ("br")) {
        buffer = new StringBuffer ("<br/>");
    }
    XmlViewNode node = new XmlViewNode (buffer.toString ());
    _currentNode.addNode (node);
}


-----Function Pair=93=-----==

protected void endPage (PDPage pdPage) throws IOException {
    textWriter.flush ();
    String page = new String (textOS.toByteArray (), "UTF-16");
    textOS.reset ();
    if (page.indexOf ("a") != - 1) {
        page = page.replaceAll ("a[0-9]{1,3}", ".");
    }
    for (int i = 0; i < searchedWords.length; i ++) {
        Pattern pattern = Pattern.compile (searchedWords [i], Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher (page);
        while (matcher.find ()) {
            int begin = matcher.start ();
            int end = matcher.end ();
            highlighterOutput.write ("    <loc " + "pg=" + (getCurrentPageNo () - 1) + " pos=" + begin + " len=" + (end - begin) + ">\n");
        }
    }
}


protected < T extends Pair < Integer, Integer > > Pair < int [], int [] > parseMassesAndIntensities (List < T > peaks) {
    if (peaks.size () == 0) {
        throw new IllegalArgumentException ("Peaklist was of length 0");
    }
    ArrayList < Pair < Integer, Integer > > tempPeaks = new ArrayList < Pair < Integer, Integer > > (peaks);
    java.util.Collections.sort (tempPeaks, reverseIntensityComp);
    int zeroIntensityCount = 0;
    for (Pair < Integer, Integer > pair : tempPeaks) {
        if (pair.getSecond () == 0) {
            zeroIntensityCount ++;
        }
        else {
            break;
        }
    }
    int [] intensities = new int [tempPeaks.size () - zeroIntensityCount];
    int [] masses = new int [tempPeaks.size () - zeroIntensityCount];
    for (int i = zeroIntensityCount, j = 0; i < tempPeaks.size (); i ++, j ++) {
        masses [j] = tempPeaks.get (i).getFirst ();
        intensities [j] = tempPeaks.get (i).getSecond ();
    }
    return new Pair < int [], int [] > (masses, intensities);
}


-----Function Pair=94=-----==

public JCompilationUnit createCompilationUnitForURI (String uri, String encoding) {
    try {
        URL url = null;
        try {
            url = new URL (uri);
        } catch (MalformedURLException exception) {
            url = new URL ("file:" + uri);
        }
        BufferedInputStream bufferedInputStream = new BufferedInputStream (url.openStream ());
        byte [] input = new byte [bufferedInputStream.available ()];
        bufferedInputStream.read (input);
        bufferedInputStream.close ();
        return getControlModel ().getFacadeHelper ().createCompilationUnit (url.toString (), encoding == null ? new String (input) : new String (input, encoding));
    } catch (IOException exception) {
    }
    return null;
}


public static void invokeStringMethod (Object object, String method, String [] arguments) throws ConfigEditorException {
    Class < String > [] argTypes = new Class [arguments.length];
    for (int i = 0; i < argTypes.length; i ++) {
        argTypes [i] = String.class;
    }
    try {
        Method methodProxy = object.getClass ().getMethod (method, argTypes);
        methodProxy.invoke (object, (Object []) arguments);
    } catch (NoSuchMethodException e) {
        throw new ConfigEditorException (ErrorID.CONFIG_EDITOR_SYNTAX_ERROR, new String [] {method});
    } catch (InvocationTargetException e) {
        throw new ConfigEditorException (ErrorID.CONFIG_EDITOR_EXECUTION_ERROR, new String [] {method}, e.getCause ());
    } catch (Exception e) {
        throw new ConfigEditorException (ErrorID.CONFIG_EDITOR_EXECUTION_ERROR, new String [] {method}, e);
    }
}


-----Function Pair=95=-----==

public void widgetSelected (final SelectionEvent e) {
    if (e.getSource () instanceof Button) {
        Button button = (Button) e.getSource ();
        String data = (String) button.getData (ACTION_COMMAND);
        int actionCommand = Integer.parseInt (data);
        switch (actionCommand) {
            case LIVE_EVAL_ACTION_COMMAND :
                fLiveEval = button.getSelection ();
                break;
            case EVALUATION_ACTION_COMMAND :
                evaluate ();
                break;
            default :
                break;
        }
    }
    else if (e.getSource () instanceof MenuItem) {
        MenuItem menuItem = (MenuItem) e.getSource ();
        String data = (String) menuItem.getData (ACTION_COMMAND);
        int actionCommand = Integer.parseInt (data);
        switch (actionCommand) {
            case POPUP_MENUITEM_ACTION_COMMAND :
                String regExCommand = (String) menuItem.getData (REG_EX_COMMAND);
                StringBuffer buffer = new StringBuffer (fRegEx.getText ());
                buffer.append (regExCommand);
                fRegEx.setText (buffer.toString ());
                break;
            default :
                break;
        }
    }
}


private void processHTMLElement (String parentName, Element elem) {
    String name = nextVariableName ();
    print (outputType.createElement (parentName, name, elem.getTagName ()));
    NamedNodeMap attrMap = elem.getAttributes ();
    for (int i = 0; i < attrMap.getLength (); i ++) {
        Attr attr = (Attr) attrMap.item (i);
        String attrName = attr.getName ();
        if (reservedAttributeMap.containsKey (attrName)) attrName = reservedAttributeMap.get (attrName);
        if (attrName.equals ("style")) {
            processHTMLStyleAttribute (name, attr);
        }
        else {
            String value = expandText (attr.getValue ());
            print (name + "." + attrName + "=" + value + ";");
        }
    }
    print (outputType.appendChild (parentName, name, elem.getTagName ()));
    NodeList nodeList = elem.getChildNodes ();
    processNodes (name, nodeList);
}


-----Function Pair=96=-----==

private void loadSymbolsTable () {
    String symbolsTableFile = Monet.getInstance ().getConfiguration ().getBusinessModelDir () + "/symbolsTable.txt";
    try {
        FileInputStream inputStream = new FileInputStream (symbolsTableFile);
        BufferedReader data = new BufferedReader (new InputStreamReader (inputStream));
        String line = "";
        String pattern = "#";
        while (null != ((line = data.readLine ()))) {
            String [] values = line.split (pattern);
            String code = values [0];
            String name = values [1];
            this.symbolsTable.put (name, code);
        }
    } catch (Exception e) {
        AgentLogger.getInstance ().error (e);
    }
}


private static void renderMacro (StringBuilder strb, String name, String [] args, String text, int start, int end) {
    if (name.equals ("noformat")) {
        if (start != end) {
            strb.append (text, start, end);
        }
    }
    else if (name.equals ("link")) {
        String href = (args.length == 1 ? args [0] : args [1]);
        String alias = args [0];
        strb.append ("<a href=\"").append (href).append ("\">").append (alias).append ("</a>");
    }
    else if (name.equals ("image")) {
        String src = args [0];
        strb.append ("<img src=\"").append (src).append ("\"/>");
    }
    else {
        throw new RuntimeException ("Unknown macro: " + name);
    }
}


-----Function Pair=97=-----==

public void doLayout () {
    Iterator nodes = lGraphManager.getNodeList ().iterator ();
    nodeList = new ArrayList ();
    while (nodes.hasNext ()) {
        LNode node = (LNode) nodes.next ();
        if (node.getChild () == null) {
            nodeList.add (node);
        }
    }
    nodeCount = nodeList.size ();
    int edgeCount = lGraphManager.getEdgeList ().size ();
    double euclidean_distance_threshold = 0.5D * (double) (nodeCount + edgeCount);
    int num_iterations = (int) (((double) nodeCount * averageIterationsPerNode) / (double) numLayoutPasses);
    List partials_list = new ArrayList ();
    SpringNode furthest_node_partials = null;
    for (layoutPass = 0; layoutPass < numLayoutPasses; layoutPass ++) {
        setupNodeDistanceSprings ();
        totalEnergy = 0.0D;
        partials_list.clear ();
        Iterator node_views_iterator = nodeList.iterator ();
        do {
            if (! node_views_iterator.hasNext ()) {
                break;
            }
            SpringNode partials = (SpringNode) node_views_iterator.next ();
            calculatePartials (partials, null, false);
            partials_list.add (partials);
            if (furthest_node_partials == null || partials.euclideanDistance > furthest_node_partials.euclideanDistance) {
                furthest_node_partials = partials;
            }
        }
        while (true);
        for (int iterations_i = 0; iterations_i < num_iterations && furthest_node_partials.euclideanDistance >= euclidean_distance_threshold; iterations_i ++) {
            furthest_node_partials = moveNode (furthest_node_partials, partials_list);
        }
    }
    List graphs = lGraphManager.getGraphs ();
    for (int i = 0; i < graphs.size () - 1; i ++) {
        LGraph graph = (LGraph) graphs.get (i);
        graph.getParent ().updateBounds ();
    }
}


private int CalculateTreeWidth (int myGraph [] [], int SolutionVector [], int zaehler) {
    int [] [] DecompositionedMatrix;
    int [] ConnectedNodes;
    int [] NextSolutionVector;
    int TreeWidth;
    int NumVerticesOfMyGraph;
    int DeeperTreeWidth;
    int LineIndex;
    NumVerticesOfMyGraph = myGraph.length;
    DecompositionedMatrix = new int [NumVerticesOfMyGraph - 1] [NumVerticesOfMyGraph - 1];
    ConnectedNodes = new int [NumVerticesOfMyGraph];
    TreeWidth = 0;
    DeeperTreeWidth = 0;
    LineIndex = 0;
    NextSolutionVector = new int [SolutionVector.length - 1];
    for (int i = 1; i < NumVerticesOfMyGraph; i ++) {
        if (SolutionVector [0] == myGraph [i] [0]) {
            LineIndex = i;
        }
    }
    for (int j = 1; j < NumVerticesOfMyGraph; j ++) {
        if (myGraph [LineIndex] [j] == 1) {
            ConnectedNodes [TreeWidth] = myGraph [0] [j];
            TreeWidth ++;
        }
    }
    for (int i = 0; i < NumVerticesOfMyGraph; i ++) {
        if (i < LineIndex) {
            for (int j = 0; j < NumVerticesOfMyGraph; j ++) {
                if (j < LineIndex) {
                    DecompositionedMatrix [i] [j] = myGraph [i] [j];
                }
                else if (j > LineIndex) {
                    DecompositionedMatrix [i] [j - 1] = myGraph [i] [j];
                }
            }
        }
        else if (i > LineIndex) {
            for (int j = 0; j < NumVerticesOfMyGraph; j ++) {
                if (j < LineIndex) {
                    DecompositionedMatrix [i - 1] [j] = myGraph [i] [j];
                }
                else if (j > LineIndex) {
                    DecompositionedMatrix [i - 1] [j - 1] = myGraph [i] [j];
                }
            }
        }
    }
    for (int k = 0; k < TreeWidth; k ++) {
        for (int i = 0; i < DecompositionedMatrix.length; i ++) {
            if (DecompositionedMatrix [i] [0] == ConnectedNodes [k]) {
                for (int l = 0; l < TreeWidth; l ++) {
                    for (int j = 0; j < DecompositionedMatrix.length; j ++) {
                        if (DecompositionedMatrix [0] [j] == ConnectedNodes [l]) {
                            DecompositionedMatrix [i] [j] = 1;
                        }
                    }
                }
            }
        }
    }
    for (int i = 1; i < DecompositionedMatrix.length; i ++) {
        DecompositionedMatrix [i] [i] = 0;
        for (int j = 1; j < DecompositionedMatrix.length; j ++) {
            DecompositionedMatrix [i] [j] = DecompositionedMatrix [j] [i];
        }
    }
    for (int l = 1; l < SolutionVector.length; l ++) {
        NextSolutionVector [l - 1] = SolutionVector [l];
    }
    if (NextSolutionVector.length > 1) {
        DeeperTreeWidth = CalculateTreeWidth (DecompositionedMatrix, NextSolutionVector, zaehler + 1);
        if (TreeWidth < DeeperTreeWidth) {
            TreeWidth = DeeperTreeWidth;
        }
    }
    return TreeWidth;
}


-----Function Pair=98=-----==

public static double [] [] derivateDoubles (String xDParam) {
    double [] [] resultDoubles;
    try {
        String tempStr = new String (xDParam);
        Vector tempVec = new Vector ();
        Vector resultVec = new Vector ();
        tempVec = split1 (xDParam);
        for (int i = 0; i < tempVec.size (); i ++) {
            resultVec.add (split2 ((String) tempVec.get (i), ','));
        }
        resultDoubles = new double [resultVec.size ()] [((Vector) resultVec.get (0)).size ()];
        for (int i = 0; i < resultVec.size (); i ++) {
            for (int j = 0; j < ((Vector) resultVec.get (0)).size (); j ++) {
                resultDoubles [i] [j] = Double.parseDouble (((String) ((Vector) (resultVec.get (i))).get (j)).trim ());
            }
        }
        return resultDoubles;
    } catch (Exception ex) {
        return resultDoubles = null;
    }
}


private String getGenotypeText () {
    String genotypeText = null;
    File genotypesFile = new File (filesDir, FILE_GENOTYPES);
    SAXReader reader = new SAXReader ();
    Document document = null;
    try {
        document = reader.read (genotypesFile);
    } catch (DocumentException ex) {
        throw new RuntimeException (ex);
    }
    Element root = document.getRootElement ();
    for (Object obj : root.elements ("ch")) {
        Element element = (Element) obj;
        Integer parsedLinkagGroup = Integer.valueOf (element.attribute ("id").getText ());
        if (parsedLinkagGroup.equals (Integer.valueOf (linkageGroup))) {
            genotypeText = element.getText ();
            break;
        }
    }
    return genotypeText;
}


-----Function Pair=99=-----==

static double [] [] decomposeCholesky (double [] [] m) {
    if (! isSquare (m)) throw new IllegalArgumentException ("Matrix is not square");
    double [] [] l = matrix (nbRows (m), nbColumns (m));
    for (int j = 0; j < nbRows (m); j ++) {
        double [] lj = l [j];
        double d = 0.;
        for (int k = 0; k < j; k ++) {
            double [] lk = l [k];
            double s = 0.;
            for (int i = 0; i < k; i ++) s += lk [i] * lj [i];
            lj [k] = s = (m [j] [k] - s) / l [k] [k];
            d = d + s * s;
        }
        if ((d = m [j] [j] - d) <= 0.) throw new IllegalArgumentException ("Matrix is not positive " + "defined");
        l [j] [j] = Math.sqrt (d);
        for (int k = j + 1; k < nbRows (m); k ++) l [j] [k] = 0.;
    }
    return l;
}


public double [] syntaxComparison (int [] order, int k) {
    double [] results = new double [n];
    double [] holder = new double [n];
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            int a = order [j];
            if (a != i) {
                double h = data [i] [a];
                if ((hasPrevious [i]) && (hasPrevious [j])) {
                    h += increment * data [i - 1] [order [j - 1]];
                }
                else if ((hasNext [i]) && (hasNext [j])) {
                    h += increment * data [i + 1] [order [j + 1]];
                }
                else {
                    h += increment * data [i] [a];
                }
                holder [j] = h;
            }
        }
        Arrays.sort (holder);
        results [i] = holder [k];
    }
    return results;
}


-----Function Pair=100=-----==

public static double [] [] invert (final double matrix [] []) {
    if (matrix.length != matrix [0].length) throw new IllegalArgumentException ("Only square matrices can be inverted.");
    final int n = matrix.length;
    double cc [] [] = BLA.copy (matrix);
    double DD [] [] = BLA.diagonal (BLA.same (n, 1.0));
    for (int i = 0; i < n; ++ i) {
        final double alpha = cc [i] [i];
        if (alpha == 0.0) {
            throw new RuntimeException ("Matrix is singular.");
        }
        cc [i] = BLA.scale (cc [i], 1 / alpha);
        DD [i] = BLA.scale (DD [i], 1 / alpha);
        for (int k = 0; k < n; ++ k) {
            if (k != i) {
                final double beta = - cc [k] [i];
                cc [k] = BLA.add (BLA.scale (cc [i], beta), cc [k]);
                DD [k] = BLA.add (BLA.scale (DD [i], beta), DD [k]);
            }
        }
    }
    return DD;
}


private double getMutualInfoWithClassAtt (int att) {
    double mutualInfo = 0;
    int attIndex = m_StartAttIndex [att];
    double [] PriorsClass = new double [m_NumClasses];
    double [] PriorsAttribute = new double [m_NumAttValues [att]];
    double [] [] PriorsClassAttribute = new double [m_NumClasses] [m_NumAttValues [att]];
    for (int i = 0; i < m_NumClasses; i ++) {
        PriorsClass [i] = (double) m_ClassCounts [i] / m_NumInstances;
    }
    for (int j = 0; j < m_NumAttValues [att]; j ++) {
        PriorsAttribute [j] = (double) m_AttCounts [attIndex + j] / m_NumInstances;
    }
    for (int i = 0; i < m_NumClasses; i ++) {
        for (int j = 0; j < m_NumAttValues [att]; j ++) {
            PriorsClassAttribute [i] [j] = (double) m_ClassAttAttCounts [i] [attIndex + j] [attIndex + j] / m_NumInstances;
        }
    }
    for (int i = 0; i < m_NumClasses; i ++) {
        for (int j = 0; j < m_NumAttValues [att]; j ++) {
            mutualInfo += PriorsClassAttribute [i] [j] * log2 (PriorsClassAttribute [i] [j], PriorsClass [i] * PriorsAttribute [j]);
        }
    }
    return mutualInfo;
}


-----Function Pair=101=-----==

public void setupRotMat (double phi, double theta, double psi) {
    double p = phi * DEG_TO_RAD;
    double h = theta * DEG_TO_RAD;
    double b = psi * DEG_TO_RAD;
    double cx = Math.cos (p);
    double sx = Math.sin (p);
    double cy = Math.cos (h);
    double sy = Math.sin (h);
    double cz = Math.cos (b);
    double sz = Math.sin (b);
    ele [0] [0] = cy * cz;
    ele [0] [1] = cy * sz;
    ele [0] [2] = - sy;
    ele [1] [0] = (sx * sy * cz) - (cx * sz);
    ele [1] [1] = (sx * sy * sz) + (cx * cz);
    ele [1] [2] = sx * cy;
    ele [2] [0] = (cx * sy * cz) + (sx * sz);
    ele [2] [1] = (cx * sy * sz) - (sx * cz);
    ele [2] [2] = cx * cy;
}


public static void colvraxpy_f77 (int nrow, double a, double y [], double x [] [], int begin, int j) {
    int i, m, mpbegin, end;
    if (nrow <= 0) return;
    if (a == 0.0) return;
    m = nrow % 4;
    mpbegin = m + begin;
    end = begin + nrow - 1;
    for (i = begin; i < mpbegin; i ++) {
        x [i] [j] += a * y [i];
    }
    for (i = mpbegin; i <= end; i += 4) {
        x [i] [j] += a * y [i];
        x [i + 1] [j] += a * y [i + 1];
        x [i + 2] [j] += a * y [i + 2];
        x [i + 3] [j] += a * y [i + 3];
    }
    return;
}


-----Function Pair=102=-----==

public static void main (String [] args) throws FailedGenerationException, IOException {
    Logger.getLogger ("").getHandlers () [0].setLevel (Level.FINE);
    final int x = Integer.valueOf (args [0]);
    final int y = Integer.valueOf (args [1]);
    final Problem problem = new Problem ("Crossword-" + x + "x" + y);
    final Variable [] [] variables = new Variable [x] [y];
    final Domain domain = new IntervalDomain ("letters", 0, 25);
    for (int i = x; -- i >= 0;) {
        for (int j = y; -- j >= 0;) {
            problem.addVariable (variables [i] [j] = new Variable (("x" + i) + j, domain));
        }
    }
    final List < Number [] > tuples = new ArrayList < Number [] > ();
    for (String s : getDict ("crossword/french", x)) {
        Number [] tuple = new Number [s.length ()];
        for (int i = s.length (); -- i >= 0;) {
            tuple [i] = s.charAt (i) - 65;
        }
        tuples.add (tuple);
    }
    final Extension relX = new Extension ("dict-" + x, x, tuples.size (), true, tuples.toArray (new Number [tuples.size ()] []));
    tuples.clear ();
    for (String s : getDict ("crossword/french", y)) {
        Number [] tuple = new Number [s.length ()];
        for (int i = s.length (); -- i >= 0;) {
            tuple [i] = s.charAt (i) - 65;
        }
        tuples.add (tuple);
    }
    final Extension relY = new Extension ("dict-" + y, y, tuples.size (), true, tuples.toArray (new Number [tuples.size ()] []));
    for (Variable [] v : variables) {
        problem.addConstraint (new ExtensionConstraint ("", Arrays.asList (v), relY));
    }
    for (Variable [] v : transpose (variables, new Variable [y] [x])) {
        problem.addConstraint (new ExtensionConstraint ("", Arrays.asList (v), relX));
    }
    final cspfj.problem.Problem cspfjProblem = cspfj.problem.Problem.load (new CspOM (problem, 0));
    final Solver solver = new MGACIter (cspfjProblem, new ResultDisplayer (x, y, cspfjProblem.getVariables ()));
    if (! solver.runSolver ()) {
        System.out.println ("No crossword found");
    }
}


public int [] [] fillAccMask_EPSG900913 (int startPolygon, int endPolygon, double longitude1, double latitude1, double longitude2, double latitude2, int width, int height, byte [] [] three_state_map, boolean noCellsReturned) {
    double divx = (longitude2 - longitude1) / width;
    double divy = (latitude2 - latitude1) / height;
    int i, j;
    int [] [] data = null;
    boolean cellsReturned = ! noCellsReturned;
    if (cellsReturned) {
        data = new int [width * height] [2];
    }
    int p = 0;
    for (j = 0; j < three_state_map [0].length; j ++) {
        for (i = 0; i < three_state_map.length; i ++) {
            if (three_state_map [i] [j] == GI_PARTIALLY_PRESENT) {
            }
            else if ((j == 0 || three_state_map [i] [j - 1] == GI_PARTIALLY_PRESENT)) {
                if (i > 0 && (three_state_map [i - 1] [j] == GI_FULLY_PRESENT || three_state_map [i - 1] [j] == GI_ABSENCE)) {
                    three_state_map [i] [j] = three_state_map [i - 1] [j];
                }
                else {
                    int count = 0;
                    for (int k = startPolygon; k <= endPolygon; k ++) {
                        count += isWithin_EPSG900913 (j * divx + divx / 2 + longitude1, i * divy + divy / 2 + latitude1) ? 1 : 0;
                    }
                    if (count % 2 == 1) {
                        three_state_map [i] [j] = GI_FULLY_PRESENT;
                    }
                }
            }
            else {
                three_state_map [i] [j] = three_state_map [i] [j - 1];
            }
            if (cellsReturned && three_state_map [i] [j] != GI_UNDEFINED) {
                data [p] [0] = j;
                data [p] [1] = i;
                p ++;
            }
        }
    }
    if (data != null) {
        data = java.util.Arrays.copyOf (data, p);
    }
    return data;
}


-----Function Pair=103=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


private static int eigtest (int order, double [] a, double [] eigval, double range) {
    int rank = 0;
    for (int i = order; i >= 1; -- i) {
        eigval [i] = a [(i * i + i) / 2];
        if (eigval [i] < ZERO) {
            break;
        }
        else if (eigval [i] < range) {
            RealSquareMatrix.logger.info ("SING");
            break;
        }
        else {
            ++ rank;
        }
    }
    return rank;
}


-----Function Pair=104=-----==

public void textureChanged (TextureParameter oldParams [], TextureParameter newParams []) {
    ParameterValue newval [] = new ParameterValue [newParams.length];
    for (int i = 0; i < newParams.length; i ++) {
        int j;
        for (j = 0; j < oldParams.length && ! oldParams [j].equals (newParams [i]); j ++);
        if (j == oldParams.length) {
            for (int k = 0; k < mesh.texParam.length; k ++) if (mesh.texParam [k].equals (newParams [i])) {
                newval [i] = mesh.paramValue [k].duplicate ();
                break;
            }
        }
        else {
            newval [i] = paramValue [j];
        }
    }
    paramValue = newval;
}


public Matrix mergeRows (Matrix B) {
    checkColumnDimension (B);
    Matrix X = new Matrix (m + B.m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    for (int i = 0; i < B.m; i ++) {
        for (int j = 0; j < n; j ++) {
            C [i + m] [j] = B.A [i] [j];
        }
    }
    return X;
}


-----Function Pair=105=-----==

public void orthogonalise () throws EuclidRuntimeException {
    if (cols == 3) {
        Vector3 v0 = new Vector3 (extractRowData (0));
        Vector3 v1 = new Vector3 (extractRowData (1));
        Vector3 v2 = new Vector3 (extractRowData (2));
        double l0 = v0.getLength ();
        double l1 = v1.getLength ();
        double l2 = v2.getLength ();
        double det = v0.getScalarTripleProduct (v1, v2);
        v0.normalize ();
        v2 = v0.cross (v1);
        v2.normalize ();
        v1 = v2.cross (v0);
        if (det < 0.0) {
            v2 = v2.negative ();
        }
        v0 = v0.multiplyBy (l0);
        v1 = v1.multiplyBy (l1);
        v2 = v2.multiplyBy (l2);
        replaceRowData (0, v0.getArray ());
        replaceRowData (1, v1.getArray ());
        replaceRowData (2, v2.getArray ());
    }
    else {
        throw new EuclidRuntimeException ("Sorry: orthogonalise only up to 3x3 matrices");
    }
}


public double [] calculateMeanKNearestNeighbour (float [] [] data, int k) {
    double sum = 0;
    int n = data.length;
    double [] holder = new double [n];
    double [] knearest = new double [n];
    double maxknearest = 0;
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            if (i > j) {
                holder [j] = data [i] [j];
            }
            else {
                holder [j] = data [j] [i];
            }
        }
        Arrays.sort (holder);
        knearest [i] = holder [k];
        if (knearest [i] > maxknearest) {
            maxknearest = knearest [i];
        }
    }
    for (int i = 0; i < n; i ++) {
        knearest [i] /= maxknearest;
    }
    return knearest;
}


-----Function Pair=106=-----==

public static void ZipFiles (File zipfile, File [] files) throws IOException {
    byte [] buffer = new byte [1024];
    FileOutputStream fos = new FileOutputStream (zipfile);
    ZipOutputStream zos = new ZipOutputStream (fos);
    for (int i = 0; i < files.length; i ++) {
        File src = files [i];
        FileInputStream fis = new FileInputStream (src);
        ZipEntry entry = new ZipEntry (src.getName ());
        zos.putNextEntry (entry);
        int length;
        while ((length = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, length);
        }
        zos.closeEntry ();
        fis.close ();
    }
    zos.close ();
}


public static final void eigenvalues (final float A [] [], float V [] [], float Y []) {
    int n = A.length;
    float AA [] [] = new float [n] [n];
    float norm;
    float c [] = new float [1];
    float s [] = new float [1];
    if (A [0].length != n || V.length != n || V [0].length != n || Y.length != n) {
        log.warning ("Error in Matrix.eigenvalues, inconsistent array sizes.");
    }
    c [0] = 1.0f;
    s [0] = 0.0f;
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) V [i] [j] = 0.0f;
        V [i] [i] = 1.0f;
    }
    copy (A, AA);
    for (int k = 0; k < n; k ++) {
        norm = norm4 (AA);
        for (int i = 0; i < n - 1; i ++) {
            for (int j = i + 1; j < n; j ++) {
                schur2 (AA, i, j, c, s);
                mat44 (i, j, c, s, AA, V);
            }
        }
    }
    norm = norm4 (AA);
    for (int i = 0; i < n; i ++) Y [i] = AA [i] [i];
}


-----Function Pair=107=-----==

public DataPoint [] Gamma (DataPoint P) {
    DataPoint [] Hood = UniteHoods (P);
    if (Hood != null) {
        double [] Pays = new double [Hood.length];
        for (int i = 0; i < Hood.length; i ++) {
            Pays [i] = Hood [i].Payoff ();
        }
        int [] Indices = this.MM.getIndMaxK (Pays, K);
        DataPoint [] RetHood = new DataPoint [K];
        for (int i = 0; i < K; i ++) {
            RetHood [i] = Hood [Indices [i]];
        }
        return RetHood;
    }
    else {
        return null;
    }
}


public static void transpose3 (double [] [] in, double [] [] out) {
    if (D.isIdentityMatrix (in)) {
        if (in != out) D.identityMatrix (out);
        return;
    }
    double [] [] copyIn;
    if (in == out) {
        D.copyMatrix (in, _dummyMatrix);
        copyIn = _dummyMatrix;
    }
    else {
        copyIn = in;
    }
    for (int rowI = 0; rowI < 3; rowI ++) {
        for (int colI = 0; colI < 3; colI ++) {
            out [colI] [rowI] = copyIn [rowI] [colI];
        }
    }
}


-----Function Pair=108=-----==

public String toString () {
    double maxval = 0;
    boolean fractional = false;
    for (int i = 0; i < getRowDimension (); i ++) {
        for (int j = 0; j < getColumnDimension (); j ++) {
            double current = get (i, j);
            if (current < 0) current *= - 11;
            if (current > maxval) maxval = current;
            double fract = Math.abs (current - Math.rint (current));
            if (! fractional && ((Math.log (fract) / Math.log (10)) >= - 2)) {
                fractional = true;
            }
        }
    }
    int width = (int) (Math.log (maxval) / Math.log (10) + (fractional ? 4 : 1));
    StringBuffer text = new StringBuffer ();
    for (int i = 0; i < getRowDimension (); i ++) {
        for (int j = 0; j < getColumnDimension (); j ++) text.append (" ").append (Utils.doubleToString (get (i, j), width, (fractional ? 2 : 0)));
        text.append ("\n");
    }
    return text.toString ();
}


public static double [] [] getSorted2DArray (IDataGrid grid, int var1, int var2) {
    double [] [] lrn = new double [grid.getNumRows ()] [2];
    double [] X = new double [grid.getNumRows ()];
    double [] Y = new double [grid.getNumRows ()];
    for (int i = 0; i < lrn.length; i ++) {
        try {
            X [i] = ((Double) grid.getPoint (i, var1)).doubleValue ();
        } catch (Exception e) {
            X [i] = ((Integer) grid.getPoint (i, var1)).doubleValue ();
        }
        try {
            Y [i] = ((Double) grid.getPoint (i, var2)).doubleValue ();
        } catch (Exception e) {
            System.out.println (grid.getPoint (i, var2).getClass ());
            Y [i] = ((Integer) grid.getPoint (i, var2)).doubleValue ();
        }
    }
    Arrays.sort (X);
    Arrays.sort (Y);
    for (int i = 0; i < lrn.length; i ++) {
        lrn [i] [0] = X [i];
        lrn [i] [1] = Y [i];
    }
    return lrn;
}


-----Function Pair=109=-----=1=

public float [] [] findDistances () {
    float [] [] distance = new float [noseqs] [noseqs];
    if (pwtype.equals ("PID")) {
        for (int i = 0; i < noseqs - 1; i ++) {
            for (int j = i; j < noseqs; j ++) {
                if (j == i) {
                    distance [i] [i] = 0;
                }
                else {
                    distance [i] [j] = 100 - Comparison.compare (sequence [i], sequence [j]);
                    distance [j] [i] = distance [i] [j];
                }
            }
        }
    }
    else {
        float max = - 1;
        for (int i = 0; i < noseqs - 1; i ++) {
            for (int j = i; j < noseqs; j ++) {
                AlignSeq as = new AlignSeq (sequence [i], sequence [j], "pep");
                as.calcScoreMatrix ();
                as.traceAlignment ();
                as.printAlignment ();
                distance [i] [j] = (float) as.maxscore;
                if (max < distance [i] [j]) {
                    max = distance [i] [j];
                }
            }
        }
        for (int i = 0; i < noseqs - 1; i ++) {
            for (int j = i; j < noseqs; j ++) {
                distance [i] [j] = max - distance [i] [j];
                distance [j] [i] = distance [i] [j];
            }
        }
    }
    return distance;
}


public static double [] [] Pearson (double [] [] X) {
    double [] [] output = new double [X.length] [X.length];
    try {
        for (int i = 0; i < X.length; i ++) {
            output [i] [i] = 1.0;
            for (int j = 0; j < i; j ++) {
                output [i] [j] = GeneUtils.pearson (X [i], X [j]);
                output [j] [i] = output [i] [j];
            }
        }
    } catch (Exception ex) {
        Logger.getLogger (Statistic.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return output;
}


-----Function Pair=110=-----==

public float [] [] UpperTriangle () {
    float [] [] m = this.matrix;
    if (INFO) {
        System.out.println ("Converting to Upper Triangle...");
    }
    float f1 = 0;
    float temp = 0;
    int tms = m.length;
    int v = 1;
    iDF = 1;
    for (int col = 0; col < tms - 1; col ++) {
        for (int row = col + 1; row < tms; row ++) {
            v = 1;
            outahere : while (m [col] [col] == 0) {
                if (col + v >= tms) {
                    iDF = 0;
                    break outahere;
                }
                else {
                    for (int c = 0; c < tms; c ++) {
                        temp = m [col] [c];
                        m [col] [c] = m [col + v] [c];
                        m [col + v] [c] = temp;
                    }
                    v ++;
                    iDF = iDF * - 1;
                }
            }
            if (m [col] [col] != 0) {
                if (DEBUG) {
                    System.out.println ("tms = " + tms + "   col = " + col + "   row = " + row);
                }
                try {
                    f1 = (- 1) * m [row] [col] / m [col] [col];
                    for (int i = col; i < tms; i ++) {
                        m [row] [i] = f1 * m [col] [i] + m [row] [i];
                    }
                } catch (Exception e) {
                    System.out.println ("Still Here!!!");
                }
            }
        }
    }
    return m;
}


public static int [] sort (final double [] items, boolean descending) {
    Integer [] itemIndices = new Integer [items.length];
    for (int i = 0; i < items.length; i ++) {
        itemIndices [i] = new Integer (i);
    }
    Arrays.sort (itemIndices, new Comparator () {
        @Override
        public int compare (Object index1, Object index2) {
            int intIndex1 = ((Integer) index1).intValue ();
            int intIndex2 = ((Integer) index2).intValue ();
            if (items [intIndex1] < items [intIndex2]) {
                return 1;
            }
            else if (items [intIndex1] > items [intIndex2]) {
                return - 1;
            }
            else {
                return 0;
            }
        }
    }
    );
    int [] sortedIndices = new int [items.length];
    for (int i = 0; i < items.length; i ++) {
        sortedIndices [i] = itemIndices [i].intValue ();
    }
    if (descending == false) {
        sortedIndices = reverse (sortedIndices);
    }
    return sortedIndices;
}


-----Function Pair=111=-----==

void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=112=-----==

void addRRset (Name name, Message response, RRset rrset, boolean sigonly) {
    Enumeration e;
    if (! sigonly) {
        e = rrset.rrs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
            response.addRecord (r, Section.ANSWER);
        }
    }
    e = rrset.sigs ();
    while (e.hasMoreElements ()) {
        Record r = (Record) e.nextElement ();
        if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
        response.addRecord (r, Section.ANSWER);
    }
}


public static void parseMimeTypes2 (String file, Map mimeTypes) {
    BufferedReader mimefile = null;
    try {
        if (new File (file).exists () == true) {
            mimefile = new BufferedReader (new FileReader (file));
            String aLine, Mime, value;
            while (mimefile.ready ()) {
                aLine = mimefile.readLine ();
                if (aLine != null && aLine.length () > 0) {
                    aLine = aLine.trim ().replace ('\t', ' ');
                    if (aLine.length () > 0 && aLine.charAt (0) != '#') {
                        int positionOfSpace = aLine.indexOf (' ');
                        if (positionOfSpace != - 1) {
                            Mime = aLine.substring (0, positionOfSpace).trim ();
                            value = aLine.substring (positionOfSpace + 1).trim ();
                            mimeTypes.put (Mime, value);
                        }
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
    } finally {
        try {
            if (mimefile != null) mimefile.close ();
        } catch (IOException e) {
        }
    }
}


-----Function Pair=113=-----==

public int getScore (String s, int cutoff) {
    double score = 0;
    int strokes = 0;
    int maxscore = 0;
    cutoff = cutoff * xstrokes.size ();
    StringTokenizer st = new StringTokenizer (s);
    Iterator xe = xstrokes.iterator ();
    Iterator ye = ystrokes.iterator ();
    while (st.hasMoreTokens ()) if (! xe.hasNext ()) return (99997);
    else {
        Vector vxe = (Vector) xe.next ();
        Vector vye = (Vector) ye.next ();
        int thisscore;
        thisscore = scoreStroke (vxe, vye, 0, vxe.size (), st.nextToken (), 0);
        score = score + thisscore * thisscore;
        maxscore = Math.max (maxscore, thisscore);
        strokes ++;
    }
    if (xe.hasNext ()) return (99998);
    else {
        if (strokes == 0) return (99997);
        else return ((int) Math.round (Math.sqrt (score)));
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


-----Function Pair=114=-----==

void addAuthority (Message response, Name name, Zone zone) {
    if (response.getHeader ().getCount (Section.ANSWER) > 0 || zone == null) {
        RRset nsRecords = findExactMatch (name, Type.NS, DClass.IN, false);
        if (nsRecords == null) {
            if (zone != null) nsRecords = zone.getNS ();
            else {
                RRset [] rrsets;
                rrsets = cache.findRecords (Name.root, Type.NS, DClass.IN);
                if (rrsets == null) nsRecords = null;
                else nsRecords = rrsets [0];
            }
        }
        if (nsRecords == null) return;
        Enumeration e = nsRecords.rrs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (response.findRecord (r, Section.ANSWER) == false) response.addRecord (r, Section.AUTHORITY);
        }
        e = nsRecords.sigs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (response.findRecord (r, Section.ANSWER) == false) response.addRecord (r, Section.AUTHORITY);
        }
    }
    else {
        SOARecord soa = (SOARecord) zone.getSOA ();
        response.addRecord (soa, Section.AUTHORITY);
    }
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=115=-----==

void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


public jnamed (String conffile) throws IOException, ZoneTransferException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    try {
        caches = new HashMap ();
        znames = new HashMap ();
        TSIGs = new HashMap ();
        InputStreamReader isr = new InputStreamReader (fs);
        BufferedReader br = new BufferedReader (isr);
        String line = null;
        while ((line = br.readLine ()) != null) {
            StringTokenizer st = new StringTokenizer (line);
            if (! st.hasMoreTokens ()) continue;
            String keyword = st.nextToken ();
            if (! st.hasMoreTokens ()) {
                System.out.println ("Invalid line: " + line);
                continue;
            }
            if (keyword.charAt (0) == '#') continue;
            if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("cache")) {
                Cache cache = new Cache (st.nextToken ());
                caches.put (new Integer (DClass.IN), cache);
            }
            else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("port")) ports.add (Integer.valueOf (st.nextToken ()));
            else if (keyword.equals ("address")) {
                String addr = st.nextToken ();
                addresses.add (InetAddress.getByName (addr));
            }
            else {
                System.out.println ("unknown keyword: " + keyword);
            }
        }
        if (ports.size () == 0) ports.add (new Integer (53));
        if (addresses.size () == 0) addresses.add (null);
        Iterator iaddr = addresses.iterator ();
        while (iaddr.hasNext ()) {
            InetAddress addr = (InetAddress) iaddr.next ();
            Iterator iport = ports.iterator ();
            while (iport.hasNext ()) {
                int port = ((Integer) iport.next ()).intValue ();
                String addrString;
                addUDP (addr, port);
                addTCP (addr, port);
                if (addr == null) addrString = "0.0.0.0";
                else addrString = addr.getHostAddress ();
                System.out.println ("jnamed: listening on " + addrString + "#" + port);
            }
        }
        System.out.println ("jnamed: running");
    } finally {
        fs.close ();
    }
}


-----Function Pair=116=-----==

private boolean evalCond (StreamTokenizer st) throws IOException {
    int val = evalExpr (st);
    int token = st.nextToken ();
    switch (token) {
        case '>' :
            if (st.nextToken () == '=') return val >= evalExpr (st);
            else {
                st.pushBack ();
                return val > evalExpr (st);
            }
        case '<' :
            if (st.nextToken () == '=') return val <= evalExpr (st);
            else {
                st.pushBack ();
                return val < evalExpr (st);
            }
        case '=' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val == evalExpr (st);
        case '!' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val != evalExpr (st);
        default :
            throw new IOException ("Invalid token");
    }
}


private void _cleanUp (Connection con, Statement s, ResultSet rs) {
    if (rs != null) {
        try {
            rs.close ();
        } catch (Exception e) {
        }
    }
    if (s != null) {
        try {
            s.close ();
        } catch (Exception e) {
        }
    }
    if (con != null) {
        try {
            con.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=117=-----==

public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


public static File createFile (File file, long size, boolean changeLastModified) throws IOException {
    if (! file.getParentFile ().exists ()) {
        throw new IOException ("Cannot create file " + file + " as the parent directory does not exist");
    }
    BufferedOutputStream output = new BufferedOutputStream (new java.io.FileOutputStream (file));
    try {
        generateTestData (output, size);
    } finally {
        closeQuietly (output);
    }
    if (changeLastModified) {
        file.setLastModified (file.lastModified () - 1000);
    }
    return file;
}


-----Function Pair=118=-----==

public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


private static void saveConfigFile () throws IOException {
    String in;
    while (true) {
        System.out.printf ("Would you like to save the options in a file, which later can be used for reinstalling and updating.\n<y/n>\n> ");
        in = stdIn.readLine ();
        if (in.compareToIgnoreCase ("n") == 0 || in.compareToIgnoreCase ("no") == 0) {
            System.out.printf ("Installation of MyKeyNote %s was successfull\n", version);
            System.exit (0);
        }
        if (in.compareToIgnoreCase ("y") == 0 || in.compareToIgnoreCase ("yes") == 0) {
            File file = new File (CONF_FOLDER + "/.installation");
            if (file.exists ()) {
                if (! file.delete ()) {
                    System.err.println ("Unable to delete the old configuration file " + file.getAbsolutePath ());
                    System.exit (1);
                }
            }
            String config = String.format ("JAVA_PATH = %s\nKN_PATH = %s\nPATH_TO_MKN = %s\nCONF_FOLDER = %s\nEXECUTABLE = %s\nINIT_SCRIPT = %s\nUSER = %s\nLOG = %s\nversion = %s", JAVA_PATH, KN_PATH, PATH_TO_MKN, CONF_FOLDER, EXECUTABLE, INIT_SCRIPT, USER, LOG, version);
            PrintWriter out;
            try {
                out = new PrintWriter (file);
                out.write (config);
                out.flush ();
                out.close ();
            } catch (FileNotFoundException e) {
                System.err.println ("Unable to create the installation file.\n" + "Please copy the following information to " + file.getAbsolutePath () + config);
                System.exit (1);
            }
            System.out.printf ("Installation of MyKeyNote %s was successfull\n", version);
        }
        return;
    }
}


-----Function Pair=119=-----==

public ArrayList zoekChunk (ArrayList chunk) {
    ArrayList resultaat = new ArrayList ();
    ArrayList bronnen = new ArrayList < String > ();
    ArrayList chunks_van_verdachte_bronnen = new ArrayList ();
    if (chunk == null) {
        System.out.println ("Meegegeven chunk is null.");
    }
    String chunkString = "";
    for (int i = 0; i < Settings.getCHUNKGROOTTE (); i ++) {
        chunkString += chunk.get (i) + " ";
    }
    chunkString = chunkString.trim ();
    try {
        IndexSearcher indexSearcher = new IndexSearcher (Settings.getIndexdir ());
        Analyzer analyzer = new StandardAnalyzer ();
        QueryParser qparser = new QueryParser ("chunk", analyzer);
        String chunkQuery = "chunk:\"" + chunkString + "\"";
        Query query = qparser.parse (chunkQuery);
        Hits hits = indexSearcher.search (query);
        String path;
        for (int i = 0; i < hits.length (); i ++) {
            path = hits.doc (i).get ("path");
            bronnen.add (path);
        }
        indexSearcher.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    resultaat.add (bronnen);
    resultaat.add (chunks_van_verdachte_bronnen);
    return resultaat;
}


private void load (DataInput in, ArrayList < ScriptItem > internalItems) {
    String workspaceDir = ti.plato.util.WorkspaceManagement.getDefault ().getCurrentWorkspaceDirectory ();
    String myDocumentsDir = Environment.getEnvironment ().getDocumentsDirectory ().getAbsolutePath ();
    String scriptPluginDir = new File (PluginUtil.getResource (ScriptsPlugin.getDefault (), "")).getAbsolutePath ();
    try {
        int internalItemsCount = in.readInt ();
        if (internalItemsCount != 0) {
            int internalItemsIndex;
            for (internalItemsIndex = 0; internalItemsIndex < internalItemsCount; internalItemsIndex ++) {
                String relativePath = in.readUTF ();
                String absolutePath = in.readUTF ();
                boolean doAdd = true;
                if (absolutePath.startsWith (preWorkspace)) absolutePath = workspaceDir + absolutePath.substring (preWorkspace.length ());
                else if (absolutePath.startsWith (preDocuments)) absolutePath = myDocumentsDir + absolutePath.substring (preDocuments.length ());
                else if (absolutePath.startsWith (prePlugIn)) absolutePath = scriptPluginDir + absolutePath.substring (prePlugIn.length ());
                else if (absolutePath.startsWith (preOther)) absolutePath = absolutePath.replaceFirst (preOther, "");
                else doAdd = false;
                boolean hasItems = in.readBoolean ();
                if (! hasItems) {
                    ScriptItem item = new ScriptItem (absolutePath, relativePath, null, internalItems);
                    if (doAdd) internalItems.add (item);
                }
                else {
                    ArrayList < ScriptItem > internalItemsTmp = new ArrayList < ScriptItem > ();
                    ScriptItem item = new ScriptItem (absolutePath, relativePath, internalItemsTmp, internalItems);
                    if (doAdd) internalItems.add (item);
                    load (in, internalItemsTmp);
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=120=-----==

public boolean addUpload (DownloadInfo di, boolean verified) {
    byte type = di.getResource ().getType ();
    Resources resToUp = di.getResource ();
    Resources resExported;
    if (type == Resources.PROJECT) {
        resExported = this.getProjectInfo (resToUp.getID (), verified);
    }
    else if (type == Resources.FEATURE_LAYER) {
        resExported = this.getFeatureLayerInfo (resToUp.getID (), verified);
    }
    else if (type == Resources.RASTER_LAYER) {
        resExported = this.getRasterLayerInfo (resToUp.getID (), verified);
    }
    else if (type == Resources.DATASET) {
        resExported = this.getDatasetInfo (resToUp.getID (), verified);
    }
    else {
        return false;
    }
    if (resExported == null) return false;
    if (! Resources.matchingDigest (di.getResource ().getDigest (), resExported.getDigest ())) {
        return false;
    }
    di.setResource (resExported);
    if (this.poolUp.addUpload (di)) {
        debug.println ("Provider: add upload " + di.getResource ().getName () + "/" + di.getResource ().getIDString () + " in queue");
    }
    else return false;
    return true;
}


public void testAllGroups () throws LDAPException {
    LDAPConnection con = new LDAPConnection ();
    con.connect ("localhost", 50983);
    Util util = new Util ();
    LDAPSearchResults res = con.search ("ou=groups,dc=compinternal,dc=com", 2, "(objectClass=*)", new String [0], false);
    LDAPAttributeSet attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("objectClass", "organizationalUnit"));
    attribs.add (new LDAPAttribute ("ou", "groups"));
    LDAPEntry entry = new LDAPEntry ("ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("base entry failed");
    }
    attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("uniqueMember", "uid=jjeffords,dc=nam,dc=compinternal,dc=com"));
    attribs.add (new LDAPAttribute ("objectClass", "groupOfUniquenames"));
    attribs.add (new LDAPAttribute ("cn", "Admins"));
    entry = new LDAPEntry ("cn=Admins,ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    LDAPEntry entry2 = res.next ();
    if (! util.compareEntry (entry, entry2)) {
        fail ("1st entry failed " + entry2.toString ());
    }
    attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("uniqueMember", "uid=jjackson,dc=nam,dc=compinternal,dc=com"));
    attribs.getAttribute ("uniqueMember").addValue ("uid=aalberts,dc=nam,dc=compinternal,dc=com");
    attribs.add (new LDAPAttribute ("objectClass", "groupOfUniqueNames"));
    attribs.add (new LDAPAttribute ("cn", "Users"));
    entry = new LDAPEntry ("cn=Users,ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("2st entry failed");
    }
    if (res.hasMore ()) {
        fail ("too many entries");
    }
    con.disconnect ();
}


-----Function Pair=121=-----==

private static boolean hardCopy (File sourceFile, File destinationFile, StringBuffer errorLog) {
    boolean result = true;
    try {
        notifyCopyStart (destinationFile);
        destinationFile.getParentFile ().mkdirs ();
        byte [] buffer = new byte [4096];
        int len = 0;
        FileInputStream in = new FileInputStream (sourceFile);
        FileOutputStream out = new FileOutputStream (destinationFile);
        while ((len = in.read (buffer)) != - 1) out.write (buffer, 0, len);
        in.close ();
        out.close ();
    } catch (Exception e) {
        result = false;
        handleException ("\n Error in method: copy!\n", e, errorLog);
    } finally {
        notifyCopyEnd (destinationFile);
    }
    return result;
}


public static synchronized File downloadFile (URL url, String data, String name, ICancellable cancel) throws IOException, ConnectException, UnknownHostException {
    File f = null;
    if ((f = getPreviousDownloadedURL (url, data)) == null) {
        File tempDirectory = new File (tempDirectoryPath);
        if (! tempDirectory.exists ()) tempDirectory.mkdir ();
        f = new File (calculateFileName (name));
        if (cancel == null) {
            cancel = new ICancellable () {
                public boolean isCanceled () {
                    return false;
                } public Object getID () {
                    return Utilities.class.getName ();
                }
            }
            ;
        }
        Monitor monitorObj = new Monitor (cancel);
        Thread downloader = new Thread (new Downloader (url, data, f, cancel.getID ()));
        Thread monitor = new Thread (monitorObj);
        monitor.start ();
        downloader.start ();
        while (! getCanceled (cancel.getID ()) && downloader.isAlive ()) {
            try {
                Thread.sleep (latency);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            monitorObj.setFinish (true);
            monitor.join ();
            downloader.join ();
        } catch (InterruptedException e1) {
            logger.warning (e1.getMessage ());
        }
        downloader = null;
        monitor = null;
        if (getCanceled (cancel.getID ())) return null;
        if (Utilities.downloadException != null) {
            Exception e = Utilities.downloadException;
            if (e instanceof FileNotFoundException) throw (IOException) e;
            else if (e instanceof IOException) throw (IOException) e;
            else if (e instanceof ConnectException) throw (ConnectException) e;
            else if (e instanceof UnknownHostException) throw (UnknownHostException) e;
        }
    }
    else {
        logger.info (url.toString () + " cached at '" + f.getAbsolutePath () + "'");
    }
    return f;
}


-----Function Pair=122=-----==

public static synchronized void setupLogger (boolean guiVisible, Level level) {
    if (! alreadySetup) {
        try {
            alreadySetup = true;
            Logger root = Logger.getRootLogger ();
            root.setLevel (level);
            if (guiVisible) {
                SocketAppender eventViewer = new SocketAppender ("localhost", 4445);
                root.addAppender (eventViewer);
                eventViewer.setName ("EventViewerAppender");
            }
            RollingFileAppender fileAppender = new RollingFileAppender (new PatternLayout (LOG_LAYOUT), LOG_FILE, true);
            fileAppender.setName ("FileAppender");
            fileAppender.setMaxBackupIndex (1);
            fileAppender.setMaxFileSize ("1MB");
            ConsoleAppender consoleAppender = new ConsoleAppender (new PatternLayout (PatternLayout.DEFAULT_CONVERSION_PATTERN));
            consoleAppender.setName ("ConsoleAppender");
            root.addAppender (fileAppender);
            root.addAppender (consoleAppender);
        } catch (Exception e) {
            System.err.println ("Error configuring logger.");
            e.printStackTrace ();
        }
    }
}


private void cmdRefresh (HttpServletRequest req, HttpServletResponse res, String userName) throws ServletException, IOException {
    res.setContentType ("text/html");
    PrintWriter out = res.getWriter ();
    String s = req.getParameter ("jobParams");
    String workflowName = req.getParameter ("workflow");
    String actualUserDir = this.getActualUserDir (userName);
    String returnStr = getWorkflowStatus (userName, workflowName);
    if (returnStr.equals ("RUNNING")) {
        returnStr = "Status;RUNNING\n";
        returnStr += getJobStatus (actualUserDir, workflowName, s);
    }
    else if (returnStr.equals ("RESCUE")) {
        returnStr = "Status;RESCUE\n";
        returnStr += getJobStatus (actualUserDir, workflowName, s);
    }
    else if (returnStr.equals ("NOT_RUNNING")) {
        returnStr = "Status;NOT_RUNNING";
    }
    else {
        returnStr = "Error;" + returnStr;
        this.printlnLog (this.getClass ().getName () + ".cmdRefresh()", "Cannot get status information about '" + workflowName + "'. Reason: " + returnStr);
    }
    this.printlnLog (this.getClass ().getName () + ".cmdRefresh()", "'" + workflowName + "' : " + returnStr);
    out.println (returnStr);
    out.close ();
}


-----Function Pair=123=-----==

void verifyRootOfAllServersMatch (String hostPort) throws InterruptedException, KeeperException, IOException {
    String parts [] = hostPort.split (",");
    int [] counts = new int [parts.length];
    int failed = 0;
    for (int j = 0; j < 100; j ++) {
        int newcounts [] = new int [parts.length];
        int i = 0;
        for (String hp : parts) {
            try {
                ZooKeeper zk = createClient (hp);
                try {
                    newcounts [i ++] = zk.getChildren ("/", false).size ();
                } finally {
                    zk.close ();
                }
            } catch (Throwable t) {
                failed ++;
                logAllStackTraces ();
            }
        }
        if (Arrays.equals (newcounts, counts)) {
            LOG.info ("Found match with array:" + Arrays.toString (newcounts));
            counts = newcounts;
            break;
        }
        else {
            counts = newcounts;
            Thread.sleep (10000);
        }
        if (failed > 10) {
            break;
        }
    }
    String logmsg = "node count not consistent{} {}";
    for (int i = 1; i < parts.length; i ++) {
        if (counts [i - 1] != counts [i]) {
            LOG.error (logmsg, Integer.valueOf (counts [i - 1]), Integer.valueOf (counts [i]));
        }
        else {
            LOG.info (logmsg, Integer.valueOf (counts [i - 1]), Integer.valueOf (counts [i]));
        }
    }
}


public static void assertRenamedFiles (boolean preserveFileDate, File srcFile, File dstFile, String appendStr, String sep, int renameCt) throws IOException {
    File [] dstFiles = new File [renameCt + 1];
    dstFiles [0] = dstFile;
    for (int i = 1; i <= renameCt; i ++) {
        if (i == 1) {
            File [] dFiles = dstFile.getParentFile ().listFiles ((FilenameFilter) new RegexFileFilter ("^" + dstFile.getName () + appendStr + "$"));
            assertEquals (1, dFiles.length);
            dstFiles [i] = dFiles [0];
        }
        else {
            File [] dFiles = dstFile.getParentFile ().listFiles ((FilenameFilter) new RegexFileFilter ("^" + dstFile.getName () + appendStr + sep + (i - 1) + "$"));
            assertEquals (1, dFiles.length);
            dstFiles [i] = dFiles [0];
        }
    }
    assertFiles (preserveFileDate, srcFile, dstFiles);
}


-----Function Pair=124=-----==

public static void deleteFilesWithFilenameFilter (File source, FilenameFilter includeFilenameFilter, FilenameFilter excludeFilenameFilter) throws FileIsNotADirectoryException, IOException, FileIsSecurityRestrictedException {
    if (! source.isDirectory ()) {
        throw new FileIsNotADirectoryException ("Source file '" + source.getAbsolutePath () + "' is not a directory.");
    }
    File [] includeFilesArray;
    if (null != includeFilenameFilter) {
        includeFilesArray = source.listFiles (includeFilenameFilter);
    }
    else {
        includeFilesArray = source.listFiles ();
    }
    if (null != includeFilesArray) {
        File [] excludeFilesArray = null;
        List < File > excludeFilesList = null;
        if (null != excludeFilenameFilter) {
            excludeFilesArray = source.listFiles (excludeFilenameFilter);
            excludeFilesList = Arrays.asList (excludeFilesArray);
        }
        if (null != excludeFilesList && (! excludeFilesList.isEmpty ())) {
            for (int i = 0; i < includeFilesArray.length; i ++) {
                File currentFile = includeFilesArray [i];
                if (! excludeFilesList.contains (currentFile)) {
                    if (currentFile.isDirectory ()) {
                        deleteFilesWithFilenameFilter (currentFile, includeFilenameFilter, excludeFilenameFilter);
                    }
                    else {
                        deleteFile (currentFile);
                    }
                }
            }
        }
        else {
            for (int i = 0; i < includeFilesArray.length; i ++) {
                File currentFile = includeFilesArray [i];
                if (currentFile.isDirectory ()) {
                    deleteFilesWithFilenameFilter (currentFile, includeFilenameFilter, excludeFilenameFilter);
                }
                else {
                    deleteFile (currentFile);
                }
            }
        }
    }
    else {
        throw new FileIsSecurityRestrictedException ("File '" + source.getAbsolutePath () + "' is security restricted.");
    }
}


private byte [] showAvailablePaths (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CapturePathsAvailable.html");
    StringBuffer buff = new StringBuffer ();
    template.replaceAll ("$title", "Available capture paths");
    String path = urlData.getParameter ("path");
    File [] files = null;
    String parent = "";
    if (path == null || path.length () == 0) {
        files = File.listRoots ();
        template.replaceAll ("$currentPath", "none");
    }
    else {
        File thisPath = new File (path);
        files = thisPath.listFiles ();
        if (thisPath.getParentFile () != null) parent = thisPath.getParentFile ().getAbsolutePath ();
        String addLink = "";
        if (thisPath.exists ()) {
            addLink = " <a href='#' class='noUnder' onClick=\"addPath('/servlet/SystemDataRes?action=32&path=" + URLEncoder.encode (thisPath.getAbsolutePath (), "UTF-8") + "');\">" + "<img alt='Add Path' border=0 src='/images/add.png' align='absmiddle' width='24' height='24'> " + thisPath.getAbsolutePath () + "</a>";
        }
        template.replaceAll ("$currentPath", addLink);
        if (thisPath.getParentFile () != null && thisPath.getParentFile ().exists () == true) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (parent, "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(parent)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
        else {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(root)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
    }
    if (files == null) {
        files = new File [0];
    }
    int numberItems = 0;
    for (int x = 0; x < files.length; x ++) {
        if (files [x].isDirectory ()) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (files [x].getCanonicalPath (), "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='path' border=0 src='/images/showchildren.png' align='absmiddle' width='24' height='24'> ");
            buff.append (files [x].getCanonicalPath ());
            buff.append ("</a>");
            buff.append ("</td></tr>");
            numberItems ++;
        }
    }
    if (numberItems == 0) {
        buff.append ("<tr><td nowrap>No items to show</td></tr>");
    }
    template.replaceAll ("$availablePaths", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=125=-----==

private void readSymbol (InputStream f, Hashtable sbTable, long size, int wordsize) throws IOException {
    byte [] buf = new byte [wordsize];
    char [] stringBuf = new char [1024];
    Long address;
    int stringSize;
    for (int i = 0; i < size; i ++) {
        f.read (buf);
        address = new Long (convert (buf));
        f.read (buf);
        stringSize = (int) convert (buf);
        if (stringSize > 1024) {
            JOptionPane.showMessageDialog (null, "Symbol too big", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        for (int j = 0; j < stringSize; j ++) {
            f.read (buf);
            stringBuf [j] = (char) convert (buf);
        }
        sbTable.put (address, new String (stringBuf, 0, stringSize));
    }
}


public static void ZipFiles (File zipfile, File [] files) throws IOException {
    byte [] buffer = new byte [1024];
    FileOutputStream fos = new FileOutputStream (zipfile);
    ZipOutputStream zos = new ZipOutputStream (fos);
    for (int i = 0; i < files.length; i ++) {
        File src = files [i];
        FileInputStream fis = new FileInputStream (src);
        ZipEntry entry = new ZipEntry (src.getName ());
        zos.putNextEntry (entry);
        int length;
        while ((length = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, length);
        }
        zos.closeEntry ();
        fis.close ();
    }
    zos.close ();
}


-----Function Pair=126=-----==

private Map < String, String > readIFO (File ifoFile) throws Exception {
    BufferedReader rd = new BufferedReader (new InputStreamReader (new FileInputStream (ifoFile), UTF8));
    try {
        String line = null;
        String first = rd.readLine ();
        if (! "StarDict's dict ifo file".equals (first)) {
            throw new Exception ("Invalid header of .ifo file: " + first);
        }
        Map < String, String > result = new TreeMap < String, String > ();
        while ((line = rd.readLine ()) != null) {
            if (line.trim ().length () == 0) {
                continue;
            }
            int pos = line.indexOf ('=');
            if (pos < 0) {
                throw new Exception ("Invalid format of .ifo file: " + line);
            }
            result.put (line.substring (0, pos), line.substring (pos + 1));
        }
        return result;
    } finally {
        rd.close ();
    }
}


private PluginManager () {
    try {
        ClassLoader cl = ClassLoader.getSystemClassLoader ();
        InputStream in = cl.getResourceAsStream ("res/builtinspec.properties");
        parseProperties (in, cl);
        in.close ();
    } catch (IOException ex) {
        l.log (Level.SEVERE, "Cannot load internal plugin spec", ex);
        return;
    }
    File f = new File ("plugins");
    if (! f.exists ()) {
        l.warning ("No plugin folder found.");
        return;
    }
    File [] ps = f.listFiles ();
    URL [] urls = new URL [ps.length];
    for (int i = 0; i < ps.length; i ++) {
        try {
            urls [i] = ps [i].toURI ().toURL ();
        } catch (MalformedURLException ex) {
            l.log (Level.SEVERE, "Cannot add file to classloader", ex);
            return;
        }
    }
    URLClassLoader ucl = new URLClassLoader (urls);
    try {
        for (int i = 0; i < ps.length; i ++) {
            URLClassLoader resl = new URLClassLoader (new URL [] {urls [i]});
            InputStream in = resl.getResourceAsStream ("res/pluginspec.properties");
            if (in == null) continue;
            l.finer ("Loading plugin: " + urls [i]);
            parseProperties (in, ucl);
            in.close ();
        }
    } catch (NumberFormatException ex) {
        l.log (Level.SEVERE, "Cannot parse plugin spec", ex);
        return;
    } catch (IOException ex) {
        l.log (Level.SEVERE, "Cannot load plugin spec", ex);
        return;
    }
}


-----Function Pair=127=-----==

public void actionPerformed (ActionEvent e) {
    JFileChooser fc = new JFileChooser ("");
    fc.setMultiSelectionEnabled (false);
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    int option = 0;
    boolean save = m_data != null;
    if (save) option = fc.showSaveDialog (this);
    else option = fc.showOpenDialog (this);
    if (option != JFileChooser.APPROVE_OPTION) return;
    File file = fc.getSelectedFile ();
    if (file == null) return;
    log.info (file.toString ());
    try {
        if (save) {
            FileOutputStream os = new FileOutputStream (file);
            byte [] buffer = (byte []) m_data;
            os.write (buffer);
            os.flush ();
            os.close ();
            log.config ("Save to " + file + " #" + buffer.length);
        }
        else {
            FileInputStream is = new FileInputStream (file);
            ByteArrayOutputStream os = new ByteArrayOutputStream ();
            byte [] buffer = new byte [1024 * 8];
            int length = - 1;
            while ((length = is.read (buffer)) != - 1) os.write (buffer, 0, length);
            is.close ();
            byte [] data = os.toByteArray ();
            m_data = data;
            log.config ("Load from " + file + " #" + data.length);
            os.close ();
        }
    } catch (Exception ex) {
        log.log (Level.WARNING, "Save=" + save, ex);
    }
    try {
        fireVetoableChange (m_columnName, null, m_data);
    } catch (PropertyVetoException pve) {
    }
}


public void traversePath (String strPath, XMLReader xmlReader, FileWriter fw) throws SAXException, IOException {
    File path = new File (strPath);
    File [] files = path.listFiles ();
    if (files == null) {
        System.out.println ("The path " + strPath + " has no files");
        System.exit (1);
    }
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            traversePath (files [i].getAbsolutePath (), xmlReader, fw);
        }
        else {
            String strFileName = files [i].getAbsolutePath ();
            try {
                if (strFileName.contains ("zip")) {
                    traverseZipFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.contains ("tar.gz")) {
                    traverseTarGzFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.endsWith ("xml")) {
                    xmlReader.parse (strFileName);
                }
            } catch (SAXParseException e) {
                System.out.println ("Wrong Xml format file" + strFileName);
            }
        }
    }
    System.out.println ("Iteration start: " + this.tagMap.size ());
    Iterator it = this.tagMap.entrySet ().iterator ();
    double totalNum = 0;
    double rate = 0;
    int count = 0;
    while (it.hasNext ()) {
        Map.Entry entry = (Map.Entry) it.next ();
        totalNum += (Integer) entry.getValue ();
        System.out.println (totalNum);
    }
    System.out.println ("Start Writing File");
    it = this.tagMap.entrySet ().iterator ();
    while (it.hasNext ()) {
        Map.Entry entry = (Map.Entry) it.next ();
        exchFile.write ((String) entry.getKey ());
        exchFile.write ('\t');
        count = (Integer) entry.getValue ();
        exchFile.write (Integer.toString (count));
        exchFile.write ('\t');
        rate = count / totalNum;
        exchFile.write (Double.toString (rate));
        exchFile.write ('\n');
        exchFile.flush ();
    }
    System.out.println ("Writing file finished");
}


-----Function Pair=128=-----==

public void testReadWriteRdf () throws Exception {
    File jpeg = new File (System.getProperty ("project.root"), "build/test/exif-rdf.jpg");
    Model model = getPhotoModel ();
    ByteArrayOutputStream rdf = new ByteArrayOutputStream ();
    model.write (rdf);
    log.debug ("RDF to write to jpeg:\n" + rdf);
    ByteArrayOutputStream jpegOS = new ByteArrayOutputStream ();
    JpegCommentWriter jcw = new JpegCommentWriter (jpegOS, new FileInputStream (jpeg));
    jcw.write (rdf.toString ());
    jcw.close ();
    FileOutputStream fos = new FileOutputStream (jpeg);
    fos.write (jpegOS.toByteArray ());
    fos.close ();
    FileInputStream jpegIn = new FileInputStream (jpeg);
    JpegHeaders jh = new JpegHeaders (jpegIn, new org.w3c.tools.jpeg.Exif ());
    String comments = StringUtils.join (jh.getComments (), "");
    jpegIn.close ();
    assertNotNull (comments);
    log.info ("EXIF comments from jpeg:\n" + comments);
    Model fromJpeg = ModelFactory.createDefaultModel ();
    fromJpeg.read (new StringReader (comments), "");
    fromJpeg.write (System.out);
    log.info ("RDF from EXIF comments:\n" + comments);
}


public static ID3v2Tag readTag (File file) throws FileNotFoundException, ID3v2NotFoundException, ID3v2UnsupportedVersionException, ID3v2ParseException, IOException {
    InputStream in = new BufferedInputStream (new FileInputStream (file));
    RandomAccessFile raFile = new RandomAccessFile (file, "r");
    raFile.seek (file.length () - 10);
    byte [] code = new byte [3];
    raFile.read (code);
    if (new String (code, "ISO-8859-1").equals ("3DI")) {
        byte [] sizeDescriptor = new byte [4];
        raFile.skipBytes (2);
        raFile.read (sizeDescriptor);
        int tagSize = (int) Bytes.convertLong (sizeDescriptor, 7, 0, 4);
        long bytesToSkip = file.length () - 10 - tagSize;
        in.skip (bytesToSkip);
    }
    ID3v2Tag tag = readTag (in);
    in.close ();
    return tag;
}


-----Function Pair=129=-----==

public synchronized void disconnect () {
    System.out.println ("Disconnecting");
    if (vc != null) {
        double sec = (System.currentTimeMillis () - vc.statStartTime) / 1000.0;
        double rate = Math.round (vc.statNumUpdates / sec * 100) / 100.0;
        long nRealRects = vc.statNumPixelRects;
        long nPseudoRects = vc.statNumTotalRects - vc.statNumPixelRects;
        System.out.println ("Updates received: " + vc.statNumUpdates + " (" + nRealRects + " rectangles + " + nPseudoRects + " pseudo), " + rate + " updates/sec");
        long numRectsOther = nRealRects - vc.statNumRectsTight - vc.statNumRectsZRLE - vc.statNumRectsHextile - vc.statNumRectsRaw - vc.statNumRectsCopy;
        System.out.println ("Rectangles:" + " Tight=" + vc.statNumRectsTight + "(JPEG=" + vc.statNumRectsTightJPEG + ") ZRLE=" + vc.statNumRectsZRLE + " Hextile=" + vc.statNumRectsHextile + " Raw=" + vc.statNumRectsRaw + " CopyRect=" + vc.statNumRectsCopy + " other=" + numRectsOther);
        long raw = vc.statNumBytesDecoded;
        long compressed = vc.statNumBytesEncoded;
        if (compressed > 0) {
            double ratio = Math.round ((double) raw / compressed * 1000) / 1000.0;
            System.out.println ("Pixel data: " + vc.statNumBytesDecoded + " bytes, " + vc.statNumBytesEncoded + " compressed, ratio " + ratio);
        }
    }
    if (rfb != null && ! rfb.closed ()) rfb.close ();
    options.dispose ();
    clipboard.dispose ();
    if (rec != null) rec.dispose ();
    if (inAnApplet) {
        showMessage ("Disconnected");
    }
    else {
        System.exit (0);
    }
}


private SearchEngine makeEngine (NavigatorView view) {
    Hashtable params = view.getParameters ();
    if (params == null || (params != null && ! params.containsKey ("data"))) {
        return null;
    }
    String engineName = (String) params.get ("engine");
    HelpSet hs = view.getHelpSet ();
    URL base = hs.getHelpSetURL ();
    ClassLoader loader = hs.getLoader ();
    if (engineName == null) {
        engineName = HelpUtilities.getDefaultQueryEngine ();
        params.put ("engine", engineName);
    }
    SearchEngine back = null;
    Constructor konstructor;
    Class types [] = {URL.class, Hashtable.class};
    Object args [] = {base, params};
    Class klass;
    debug ("makeEngine");
    debug ("  base: " + base);
    debug ("  params: " + params);
    try {
        if (loader == null) {
            klass = Class.forName (engineName);
        }
        else {
            klass = loader.loadClass (engineName);
        }
    } catch (Throwable t) {
        throw new Error ("Could not load engine named " + engineName + " for view: " + view);
    }
    try {
        konstructor = klass.getConstructor (types);
    } catch (Throwable t) {
        throw new Error ("Could not find constructor for " + engineName + ". For view: " + view);
    }
    try {
        back = (SearchEngine) konstructor.newInstance (args);
    } catch (InvocationTargetException e) {
        System.err.println ("Exception while creating engine named " + engineName + " for view: " + view);
        e.printStackTrace ();
    } catch (Throwable t) {
        throw new Error ("Could not create engine named " + engineName + " for view: " + view);
    }
    return back;
}


-----Function Pair=130=-----=1=

private static Iterable < Pair < Path, String > > create (URL configLoc, Class < ? extends Iterable < Pair < Path, String > > > clazz) throws IOException, ParseException {
    try {
        Constructor < ? extends Iterable < Pair < Path, String > > > constructor = clazz.getConstructor (URL.class);
        return constructor.newInstance (configLoc);
    } catch (SecurityException ex) {
        throw new Error (ex);
    } catch (NoSuchMethodException ex) {
        throw new Error (ex);
    } catch (IllegalArgumentException ex) {
        throw new Error (ex);
    } catch (InstantiationException ex) {
        throw new Error (ex);
    } catch (IllegalAccessException ex) {
        throw new Error (ex);
    } catch (InvocationTargetException ex) {
        IOUtils.checkCause (IOException.class, ex);
        IOUtils.checkCause (ParseException.class, ex);
        throw new RuntimeException (ex.getCause ());
    }
}


public void run (String [] args) {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    new ZLOwnXMLProcessorFactory ();
    new ZLOwnHtmlProcessorFactory ();
    loadProperties ();
    new ZLXMLConfigManager (System.getProperty ("user.home") + "/." + getInstance ().getApplicationName ());
    new ZLSwingImageManager ();
    new ZLSwingDialogManager ();
    ZLApplication application = null;
    try {
        application = (ZLApplication) getApplicationClass ().getConstructor (String [].class).newInstance (new Object [] {args});
    } catch (Exception e) {
        e.printStackTrace ();
        shutdown ();
    }
    ZLSwingApplicationWindow mainWindow = ((ZLSwingDialogManager) ZLSwingDialogManager.getInstance ()).createApplicationWindow (application);
    application.initWindow ();
    mainWindow.run ();
}


-----Function Pair=131=-----==

public void run () {
    int count = 0;
    for (int z = 0; z < activeVolume.getDepth (); z ++) {
        if (isStopped) return;
        setProgress (z);
        short [] slice = activeVolume.getSlice (z);
        for (int i = 0; i < slice.length; i ++) {
            if (slice [i] == 255) {
                count ++;
                slice [i] = 0;
            }
        }
    }
    activeVolume.flush ();
    StringBuffer output = new StringBuffer ();
    output.append ("Removed " + count + " voxels \n");
    showResults (output, "Voxelcount");
    enableMenus ();
    updateImage ();
}


private void saveNewObject (Object o, DirContext ctx, String baseDN, Transaction tx) throws InvalidNameException, DirectoryException, NamingException {
    final Name targetName = fillEmptyDN (o, ctx, baseDN);
    for (final AttributeMapping attributeMapping : attributes) attributeMapping.cascadePreSave (o, tx);
    final BasicAttributes a = new BasicAttributes ();
    rdnAttribute.dehydrate (o, a);
    fillAttributes (o, a);
    DiropLogger.LOG.logAdd (getDN (o), a, "save new object");
    ctx.bind (targetName, null, a);
    tx.putCacheEntry (this, getDirectoryFacade ().makeAbsoluteName (targetName), o, a);
    try {
        for (final AttributeMapping attributeMapping : attributes) attributeMapping.cascadePostSave (o, tx, ctx);
    } catch (final DirectoryException t) {
        try {
            DiropLogger.LOG.logDelete (targetName, "delete due to rollback");
            ctx.destroySubcontext (targetName);
        } catch (final Throwable u) {
        }
        throw t;
    }
}


-----Function Pair=132=-----==

public static List postprocess (String [] argv, Map aliases) throws BadArgsException {
    ArrayList pipe;
    String [] next;
    String [] tmp;
    boolean eating;
    int n;
    int m;
    if (argv == null || argv.length == 0) {
        return new ArrayList (0);
    }
    eating = false;
    pipe = new ArrayList (4);
    tmp = new String [argv.length];
    for (m = 0, n = 0; n < argv.length; n ++) {
        if (argv [n].equals ("|")) {
            if (! eating) {
                throw new BadArgsException ("Isolated pipe symbol at index " + n);
            }
            if (m == 0) {
                throw new BadArgsException ("Empty pipe at index " + n);
            }
            next = new String [m];
            System.arraycopy (tmp, 0, next, 0, m);
            pipe.add (resolveAlias (next, aliases));
            m = 0;
            eating = false;
        }
        else {
            tmp [m ++] = argv [n];
            eating = true;
        }
    }
    if (! eating) {
        throw new BadArgsException ("Terminal argument is a pipe symbol!");
    }
    next = new String [m];
    System.arraycopy (tmp, 0, next, 0, m);
    pipe.add (resolveAlias (next, aliases));
    return pipe;
}


public void updateProperties (Element elem) {
    beginUpdate ();
    Element e = elem.getChild (ELEMENT_MINIATURES);
    if (e == null) {
        return;
    }
    Iterator iter = e.getAttributes ().iterator ();
    while (iter.hasNext ()) {
        try {
            Attribute attrib = (Attribute) iter.next ();
            if (attrib.getName ().equals (ATTRIBUTE_SERIAL_NUMBER)) {
                setSerial (attrib.getIntValue ());
            }
        } catch (Exception ex) {
        }
    }
    logger.debug (xout.outputString (e));
    iter = e.getChildren (ELEMENT_MINIATURE).iterator ();
    while (iter.hasNext ()) {
        Element mini = (Element) iter.next ();
        if (mini.getAttributeValue (ATTRIBUTE_ACTION).equals (ACTION_NEW)) {
            Miniature miniature = null;
            try {
                Class k = getClass ().getClassLoader ().loadClass (mini.getAttributeValue (MapConstants.MINIATURE_TYPE, Miniature.class.getName ()));
                Constructor cons = k.getConstructor (new Class [] {});
                miniature = (Miniature) cons.newInstance (new Object [] {});
            } catch (ClassNotFoundException e1) {
                e1.printStackTrace ();
            } catch (SecurityException se) {
                miniature = new Miniature ();
                se.printStackTrace ();
            } catch (NoSuchMethodException nsme) {
                miniature = new Miniature ();
                nsme.printStackTrace ();
            } catch (IllegalArgumentException iae) {
                miniature = new Miniature ();
                iae.printStackTrace ();
            } catch (InstantiationException ie) {
                miniature = new Miniature ();
                ie.printStackTrace ();
            } catch (IllegalAccessException iarge) {
                miniature = new Miniature ();
                iarge.printStackTrace ();
            } catch (InvocationTargetException ite) {
                miniature = new Miniature ();
                ite.printStackTrace ();
            }
            miniature.fromXML (mini);
            add (miniature);
        }
        else if (mini.getAttributeValue (ATTRIBUTE_ACTION).equals (ACTION_UPDATE)) {
            for (int loop = 0; loop < getMiniatures ().size (); loop ++) {
                Miniature m = (Miniature) getMiniatures ().get (loop);
                if (m.getId ().equals (mini.getAttributeValue (Miniature.ATTRIBUTE_ID))) {
                    m.fromXML (mini);
                    break;
                }
            }
        }
        else if (mini.getAttributeValue (ATTRIBUTE_ACTION).equals (ACTION_DELETE)) {
            for (int loop = 0; loop < getMiniatures ().size (); loop ++) {
                Miniature m = (Miniature) getMiniatures ().get (loop);
                if (m.getId ().equals (mini.getAttributeValue (Miniature.ATTRIBUTE_ID))) {
                    getMiniatures ().remove (m);
                    break;
                }
            }
        }
    }
    endUpdate ();
}


-----Function Pair=133=-----==

public MarshalledObject newInstance (ActivationID id, ActivationDesc desc) throws ActivationException, RemoteException {
    try {
        if (ActivationSystemTransient.debug) System.out.println ("Instantiating " + desc.getClassName ());
        Remote object;
        Class objectClass;
        ClassLoader loader = Thread.currentThread ().getContextClassLoader ();
        objectClass = loader.loadClass (desc.getClassName ());
        Constructor constructor = objectClass.getConstructor (cConstructorTypes);
        object = (Remote) constructor.newInstance (new Object [] {id, desc.getData ()});
        ActivatableServerRef ref = UnicastServer.getActivatableRef (id);
        Remote stub = ref.exportObject (object);
        MarshalledObject marsh = new MarshalledObject (stub);
        activeObject (id, marsh);
        activeObject (id, stub);
        return marsh;
    } catch (Exception e) {
        ActivationException acex = new ActivationException ("Unable to activate " + desc.getClassName () + " from " + desc.getLocation (), e);
        throw acex;
    }
}


public static void playSound2 (File file) throws UnsupportedAudioFileException, IOException, LineUnavailableException {
    AudioInputStream inputStream = AudioSystem.getAudioInputStream (file);
    AudioFormat audioFormat = inputStream.getFormat ();
    DataLine.Info info = new DataLine.Info (SourceDataLine.class, audioFormat);
    SourceDataLine sourceLine = (SourceDataLine) AudioSystem.getLine (info);
    sourceLine.open (audioFormat);
    sourceLine.start ();
    int nbytes = 0;
    byte [] data = new byte [1024];
    while (nbytes != - 1) {
        nbytes = inputStream.read (data, 0, data.length);
        sourceLine.write (data, 0, data.length);
    }
    sourceLine.drain ();
    sourceLine.close ();
}


-----Function Pair=134=-----=1=

public MarshalledObject newInstance (ActivationID id, ActivationDesc desc) throws ActivationException, RemoteException {
    try {
        if (ActivationSystemTransient.debug) System.out.println ("Instantiating " + desc.getClassName ());
        Remote object;
        Class objectClass;
        ClassLoader loader = Thread.currentThread ().getContextClassLoader ();
        objectClass = loader.loadClass (desc.getClassName ());
        Constructor constructor = objectClass.getConstructor (cConstructorTypes);
        object = (Remote) constructor.newInstance (new Object [] {id, desc.getData ()});
        ActivatableServerRef ref = UnicastServer.getActivatableRef (id);
        Remote stub = ref.exportObject (object);
        MarshalledObject marsh = new MarshalledObject (stub);
        activeObject (id, marsh);
        activeObject (id, stub);
        return marsh;
    } catch (Exception e) {
        ActivationException acex = new ActivationException ("Unable to activate " + desc.getClassName () + " from " + desc.getLocation (), e);
        throw acex;
    }
}


private void showURLWithMethod (String url, String clazz, String method) {
    Class c = null;
    Object obj = null;
    try {
        c = Class.forName (clazz);
    } catch (Throwable e) {
        GUIUtilities.error (null, "infoviewer.error.classnotfound", new Object [] {clazz});
        return;
    }
    if (method == null || (method != null && method.length () == 0)) {
        Constructor constr = null;
        try {
            constr = c.getConstructor (new Class [] {URL.class});
            if (constr != null) obj = constr.newInstance (new Object [] {new URL (url)});
        } catch (Exception ex) {
            Log.log (Log.DEBUG, this, ex);
        }
        if (obj == null) {
            try {
                constr = c.getConstructor (new Class [] {String.class});
                if (constr != null) obj = constr.newInstance (new Object [] {url});
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (obj == null) {
            try {
                constr = c.getConstructor (new Class [0]);
                if (constr != null) obj = constr.newInstance (new Object [0]);
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (obj == null) {
            GUIUtilities.error (null, "infoviewer.error.classnotfound", new Object [] {clazz});
            return;
        }
    }
    else {
        Method meth = null;
        boolean ok = false;
        try {
            meth = c.getDeclaredMethod (method, new Class [] {URL.class});
            if (meth != null) {
                obj = meth.invoke (null, new Object [] {new URL (url)});
                ok = true;
            }
        } catch (Exception ex) {
            Log.log (Log.DEBUG, this, ex);
        }
        if (! ok) {
            try {
                meth = c.getDeclaredMethod (method, new Class [] {String.class});
                if (meth != null) {
                    obj = meth.invoke (null, new Object [] {url});
                    ok = true;
                }
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (! ok) {
            try {
                meth = c.getDeclaredMethod (method, new Class [0]);
                if (meth != null) {
                    obj = meth.invoke (null, new Object [0]);
                    ok = true;
                }
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (! ok) {
            GUIUtilities.error (null, "infoviewer.error.methodnotfound", new Object [] {clazz, method});
            return;
        }
    }
    if (obj != null) {
        if (obj instanceof Window) {
            ((Window) obj).show ();
        }
        else if (obj instanceof JComponent) {
            JFrame f = new JFrame ("Infoviewer JWrapper");
            f.getContentPane ().add ((JComponent) obj);
            f.pack ();
            f.setVisible (true);
        }
        else if (obj instanceof Component) {
            Frame f = new Frame ("Infoviewer Wrapper");
            f.add ((Component) obj);
            f.pack ();
            f.setVisible (true);
        }
    }
}


-----Function Pair=135=-----==

public int compareTo (Version v) {
    for (int i = 0; i < parts.length; i ++) {
        Integer left = parts [i];
        Integer right = v.parts [i];
        if (left == null) {
            if (right == null) {
                break;
            }
            else {
                return - 1;
            }
        }
        else {
            if (right == null) {
                return 1;
            }
            else if (left < right) {
                return - 1;
            }
            else if (left > right) {
                return 1;
            }
        }
    }
    if (snapshot) {
        return v.snapshot ? 0 : - 1;
    }
    else {
        return v.snapshot ? 1 : 0;
    }
}


public void actionPerformed (ActionEvent ev) {
    Object [] vars = variableGrabber.getSelectedValues ();
    if (vars.length <= 0) {
        return;
    }
    String currText = modelRightHandSide.getText ();
    currText = currText.trim ();
    if (currText.length () == 0) {
        currText = (String) vars [0];
    }
    else {
        currText = currText + vars [0];
    }
    for (int j = 1; j < vars.length; j ++) {
        currText = currText + vars [j];
    }
    modelRightHandSide.setText (currText);
}


-----Function Pair=136=-----==

public void run () {
    long total = 0;
    int cnt = 0;
    for (int i = 0; i < idList.length; i ++) {
        if (! idList [i]) cnt ++;
    }
    System.out.println ("Estimated was " + cnt);
    long [] histo = new long [MAX_FIBERS + 256];
    for (int z = 0; z < volume.getDepth (); z ++) {
        setProgress (z);
        short [] slice = volume.getSlice (z);
        for (int i = 0; i < slice.length; i ++) {
            histo [slice [i]] ++;
            total ++;
        }
    }
    StringBuffer output = new StringBuffer ();
    int diffcnt = 0;
    for (int i = 0; i < histo.length; i ++) {
        if (histo [i] > 0) output.append (i + " : " + histo [i] + "\n");
        if (histo [i] != 0) diffcnt ++;
    }
    output.append ("Total = " + total + "\n");
    output.append (diffcnt + " unique labels");
    showResults (output, "Histogram");
    enableMenus ();
}


public Connection connect (final String url, final Properties info) throws SQLException {
    String access = info.getProperty ("user");
    String secret = info.getProperty ("password");
    String endpoint = info.getProperty ("endpoint");
    if (access == null || access.trim ().length () == 0 || secret == null || secret.trim ().length () == 0) {
        throw new SQLException ("AWS access credentials are missing", "08001", 8001);
    }
    if (endpoint == null || endpoint.trim ().length () == 0) {
        throw new SQLException ("Endpoint is missing", "08001", 8001);
    }
    try {
        AmazonSimpleDB service = getClient (access, secret, endpoint);
        ListDomainsRequest req = new ListDomainsRequest ();
        req.setMaxNumberOfDomains (10);
        service.listDomains (req);
        JdbcConnection conn = new JdbcConnection (this, access, secret, endpoint);
        return conn;
    } catch (AmazonServiceException e) {
        SQLException se = new SQLException (e.getLocalizedMessage (), "08001", e.getStatusCode ());
        se.initCause (e);
        throw se;
    } catch (SQLException e) {
        throw e;
    } catch (Exception e) {
        SQLException se = new SQLException (e.getLocalizedMessage (), "08001", 8001);
        se.initCause (e);
        throw se;
    }
}


-----Function Pair=137=-----==

public String toString () {
    StringWriter str = new StringWriter ();
    PrintWriter out = new PrintWriter (str);
    out.println ("struct {");
    out.print ("  types = ");
    for (int i = 0; i < types.length; i ++) {
        out.print (types [i]);
        if (i != types.length - 1) out.print (", ");
    }
    out.println (";");
    out.println ("  authorities =");
    for (int i = 0; i < authorities.length; i ++) {
        out.print ("    ");
        out.print (authorities [i].getName ());
        if (i != types.length - 1) out.println (",");
    }
    out.println (";");
    out.println ("} CertificateRequest;");
    return str.toString ();
}


private static void testDexClassLoader () {
    ClassLoader dexClassLoader = getDexClassLoader ();
    Class anotherClass;
    try {
        anotherClass = dexClassLoader.loadClass ("Another");
    } catch (ClassNotFoundException cnfe) {
        throw new RuntimeException ("Another?");
    }
    Object another;
    try {
        another = anotherClass.newInstance ();
    } catch (IllegalAccessException ie) {
        throw new RuntimeException ("new another", ie);
    } catch (InstantiationException ie) {
        throw new RuntimeException ("new another", ie);
    }
    dexClassLoader.getResource ("nonexistent");
}


-----Function Pair=138=-----==

public DataImpl open (String id) throws BadFormException, IOException, VisADException {
    String header = getClass ().getName () + ".open(String): ";
    DataImpl data;
    try {
        Class sourceClass = Class.forName (getClass ().getPackage ().getName () + ".DODSSource");
        DataInputStream source = (DataInputStream) sourceClass.getConstructor (new Class [0]).newInstance (new Object [0]);
        sourceClass.getMethod ("open", new Class [] {String.class}).invoke (source, new Object [] {id});
        data = new Consolidator (new TimeFactorer (source)).readData ();
    } catch (ClassNotFoundException e) {
        throw new VisADException (header + e + ".  " + sourceMessage);
    } catch (NoSuchMethodException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (SecurityException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (InstantiationException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (IllegalAccessException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (IllegalArgumentException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (InvocationTargetException e) {
        throw new VisADException (e.getTargetException ().getMessage ());
    }
    return data;
}


public void showSwingSet2 () {
    if (! isApplet () && getFrame () != null) {
        JFrame f = getFrame ();
        f.setTitle (getString ("Frame.title"));
        f.getContentPane ().add (this, BorderLayout.CENTER);
        f.pack ();
        Rectangle screenRect = f.getGraphicsConfiguration ().getBounds ();
        Insets screenInsets = Toolkit.getDefaultToolkit ().getScreenInsets (f.getGraphicsConfiguration ());
        int centerWidth = screenRect.width < f.getSize ().width ? screenRect.x : screenRect.x + screenRect.width / 2 - f.getSize ().width / 2;
        int centerHeight = screenRect.height < f.getSize ().height ? screenRect.y : screenRect.y + screenRect.height / 2 - f.getSize ().height / 2;
        centerHeight = centerHeight < screenInsets.top ? screenInsets.top : centerHeight;
        f.setLocation (centerWidth, centerHeight);
        f.show ();
        numSSs ++;
        swingSets.add (this);
    }
}


-----Function Pair=139=-----==

public void startProcesses (JobProcess [] procs) throws PpException, IntegrityException, MalformedURLException {
    synchronized (this) {
        JobMetaData j = jobs.get (procs [0].getJob ().getId ());
        if (j == null) {
            throw new IntegrityException ("no such job");
        }
        j.started = true;
    }
    try {
        Supernode2Consumer consumer = (Supernode2Consumer) getDefaultServer ().getProxyFactory ().createProxy (new URL (getConsumerUrl (procs [0].getJob ().getConsumerPeer ()) + "/" + Supernode2Consumer.class.getSimpleName ()), Supernode2Consumer.class);
        consumer.jobStarted (procs);
    } catch (Exception e) {
        synchronized (this) {
            jobs.remove (procs [0].getJob ().getId ());
        }
        if (e instanceof PpException) {
            throw (PpException) e;
        }
        else if (e instanceof IntegrityException) {
            throw (IntegrityException) e;
        }
        else if (e instanceof MalformedURLException) {
            throw (MalformedURLException) e;
        }
        else {
            throw new RuntimeException ("unexpected exception informing user that job is started", e);
        }
    }
}


void invokeReadObject (Object me, Method readObjectMethod) throws ClassNotFoundException, IOException {
    if (NOV_DEBUG) System.err.println ("using correct class frame now (I believe)");
    if (NESTEDREADOBJECT_DEBUG) System.err.print ("\t--JSX deserialize--");
    try {
        readObjectMethod.invoke (me, readObjectArglist);
        if (NESTEDREADOBJECT_DEBUG) System.err.println ("\tinvoke " + readObjectMethod + " on " + me + " of " + me.getClass ());
    } catch (InvocationTargetException e) {
        if (DEBUG) {
            System.err.println ("JSX InvocationTargetException:");
            System.err.println ("Object which is a: " + me.getClass ());
            e.printStackTrace ();
        }
        Throwable t = e.getTargetException ();
        if (t instanceof ClassNotFoundException) throw (ClassNotFoundException) t;
        else if (t instanceof IOException) throw (IOException) t;
        else if (t instanceof RuntimeException) throw (RuntimeException) t;
        else if (t instanceof Error) throw (Error) t;
        else throw new Error ("internal error");
    } catch (IllegalAccessException e) {
        System.err.println ("IllegalAccessExcetion - please report this error");
        e.printStackTrace ();
    }
}


-----Function Pair=140=-----==

public void setCheckBox (boolean condition, String windowName, int checkBoxName) throws Exception {
    int i = 0;
    JFrameOperator mainFrame = new JFrameOperator (windowName);
    JCheckBoxOperator jc = new JCheckBoxOperator (mainFrame, checkBoxName);
    if (condition == true && ! jc.isSelected ()) {
        while (! jc.isSelected () && i < 5) {
            this.report ("Setting checkox " + checkBoxName + " to on attempt-" + i);
            jc.clickMouse ();
            Thread.sleep (1000);
            i ++;
        }
    }
    else if (condition == false && jc.isSelected ()) {
        while (jc.isSelected () && i < retryNumber) {
            this.report ("Setting checkox " + checkBoxName + " to off attempt-" + i);
            jc.clickMouse ();
            Thread.sleep (1000);
            i ++;
        }
    }
    if (i == retryNumber) this.report ("setting the checkbox " + checkBoxName + "to " + condition + " has failed");
}


public synchronized ArrayList < Tracker > getTrackers () {
    ArrayList < Tracker > trackers = new ArrayList < Tracker > ();
    File f = new File ("trackers/");
    if (! f.exists ()) {
        JOptionPane.showMessageDialog (mainWindow, "Tracker-directory not found at " + f.getAbsolutePath ());
        return null;
    }
    String [] descriptorNames = f.list ();
    try {
        for (int i = 0; i < descriptorNames.length; i ++) {
            if (descriptorNames [i].endsWith (".class")) {
                String name = "trackers." + (descriptorNames [i].substring (0, descriptorNames [i].length () - 6));
                if (! name.contains ("$")) {
                    ClassLoader loader = getClass ().getClassLoader ().getSystemClassLoader ();
                    Constructor c = loader.loadClass (name).getConstructors () [0];
                    Object [] args = new Object [1];
                    args [0] = this;
                    trackers.add ((Tracker) c.newInstance (args));
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return trackers;
}


-----Function Pair=141=-----==

public Level execute (String [] args) throws Exception {
    Level nextLevel = MoteMessageProfilingLevel.this;
    Variables.set ("status", "0");
    if (args.length != 2) {
        System.out.printf ("usage: %s <messageSymbol>\n", args [0]);
        Variables.set ("status", "1");
        return nextLevel;
    }
    String name = args [1];
    Entry entry = getEntryWithName (name);
    if (entry instanceof ProgramProfilingMessageSymbolEntry) {
        ProgramProfilingMessageSymbolEntry ppmse;
        ppmse = (ProgramProfilingMessageSymbolEntry) entry;
        ppmse.clearProfiling ();
    }
    else {
        System.out.printf ("No entry found for %s\n", name);
        Variables.set ("status", "2");
    }
    return nextLevel;
}


private void boardSaveAs () {
    JFileChooser fc = new JFileChooser ("data" + File.separator + "boards");
    fc.setLocation (frame.getLocation ().x + 150, frame.getLocation ().y + 100);
    fc.setDialogTitle (Messages.getString ("BoardEditor.saveBoardAs"));
    fc.setFileFilter (new FileFilter () {
        @Override
        public boolean accept (File dir) {
            return (null != dir.getName ()) && dir.getName ().endsWith (".board");
        }@Override
        public String getDescription () {
            return ".board";
        }
    }
    );
    int returnVal = fc.showSaveDialog (frame);
    if ((returnVal != JFileChooser.APPROVE_OPTION) || (fc.getSelectedFile () == null)) {
        return;
    }
    curfileBoard = fc.getSelectedFile ();
    if (! curfileBoard.getName ().toLowerCase ().endsWith (".board")) {
        try {
            curfileBoard = new File (curfileBoard.getCanonicalPath () + ".board");
        } catch (IOException ie) {
            return;
        }
    }
    boardSave ();
}


-----Function Pair=142=-----==

public MetaDatabase (OrmHandler ormHandler, OrmUjo database, MetaDatabase param) {
    this.ormHandler = ormHandler;
    ROOT.setValue (this, database);
    if (param != null) {
        changeDefault (this, SCHEMA, SCHEMA.of (param));
        changeDefault (this, DIALECT, DIALECT.of (param));
        changeDefault (this, JDBC_URL, JDBC_URL.of (param));
        changeDefault (this, JDBC_DRIVER, JDBC_DRIVER.of (param));
        changeDefault (this, USER, USER.of (param));
        changeDefault (this, PASSWORD, PASSWORD.of (param));
        changeDefault (this, JNDI, JNDI.of (param));
        changeDefault (this, SEQUENCER, SEQUENCER.of (param));
    }
    Db annotDB = database.getClass ().getAnnotation (Db.class);
    if (annotDB != null) {
        changeDefault (this, SCHEMA, annotDB.schema ());
        changeDefault (this, DIALECT, annotDB.dialect ());
        changeDefault (this, JDBC_URL, annotDB.jdbcUrl ());
        changeDefault (this, JDBC_DRIVER, annotDB.jdbcDriver ());
        changeDefault (this, USER, annotDB.user ());
        changeDefault (this, PASSWORD, annotDB.password ());
        changeDefault (this, JNDI, Arrays.asList (annotDB.jndi ()));
        changeDefault (this, SEQUENCER, annotDB.sequencer ());
    }
    changeDefault (this, ID, database.getClass ().getSimpleName ());
    changeDefault (this, JDBC_URL, getDialect ().getJdbcUrl ());
    changeDefault (this, JDBC_DRIVER, getDialect ().getJdbcDriver ());
    for (UjoProperty tableProperty : database.readProperties ()) {
        if (tableProperty instanceof RelationToMany) {
            RelationToMany tProperty = (RelationToMany) tableProperty;
            MetaTable par = param != null ? param.findTable (tProperty.getName ()) : null;
            MetaTable table = new MetaTable (this, tProperty, par);
            TABLES.addItem (this, table);
            ormHandler.addTableModel (table);
        }
        else if (tableProperty.isTypeOf (DbProcedure.class)) {
            UjoProperty tProcedure = tableProperty;
            MetaProcedure par = param != null ? param.findProcedure (tProcedure.getName ()) : null;
            MetaProcedure procedure = new MetaProcedure (this, tProcedure, par);
            PROCEDURES.addItem (this, procedure);
            ormHandler.addProcedureModel (procedure);
        }
    }
    if (ADD_DB_MODEL) {
        @SuppressWarnings ("unchecked")
        RelationToMany relation = new RelationToMany (SCHEMA.of (this), database.getClass ());
        MetaTable table = new MetaTable (this, relation, null);
        table.setNotPersistent ();
        TABLES.addItem (this, table);
        ormHandler.addTableModel (table);
    }
}


static String findR (boolean findAllSettings) {
    String ip = null;
    try {
        if (hasreg ()) {
            isWin32 = true;
            int rroot = HKLM;
            System.out.println ("has registry, trying to find R");
            ip = regvalue (HKLM, "SOFTWARE\\R-core\\R", "InstallPath");
            if (ip == null) ip = regvalue (rroot = HKCU, "SOFTWARE\\R-core\\R", "InstallPath");
            if (ip == null) {
                System.out.println (" - InstallPath not present (possibly uninstalled R)");
                String [] vers = regsubkeys (rroot = HKLM, "SOFTWARE\\R-core\\R");
                if (vers == null) vers = regsubkeys (rroot = HKCU, "SOFTWARE\\R-core\\R");
                if (vers != null) {
                    String lvn = "";
                    int i = 0;
                    while (i < vers.length) {
                        if (vers [i] != null && lvn.compareTo (vers [i]) < 0) lvn = vers [i];
                        i ++;
                    }
                    if (! lvn.equals ("")) ip = regvalue (rroot, "SOFTWARE\\R-core\\R\\" + lvn, "InstallPath");
                }
            }
            if (ip == null) {
                ip = getenv ("R_HOME");
                if (ip == null || ip.length () < 1) ip = getenv ("RHOME");
                if (ip == null || ip.length () < 1) ip = null;
            }
            if (ip != null) rs_home = ip;
            return ip;
        }
        isMac = System.getProperty ("os.name").startsWith ("Mac");
        File f = null;
        ip = getenv ("R_HOME");
        if (ip == null || ip.length () < 1) ip = getenv ("RHOME");
        if (ip == null || ip.length () < 1) {
            if (isMac) {
                f = new File ("/Library/Frameworks/R.framework/Resources/bin/R");
                if (! f.exists ()) f = new File (getenv ("HOME") + "/Library/Frameworks/R.framework/Resources/bin/R");
                if (! f.exists ()) f = null;
            }
            if (f == null) {
                String fn = findInPath (getenv ("PATH"), "R", true);
                if (fn == null) fn = findInPath ("/usr/bin:/usr/local/bin:/sw/bin:/opt/bin:/usr/lib/R/bin:/usr/local/lib/R/bin", "R", true);
                if (fn != null) f = new File (fn);
            }
            if (! findAllSettings) {
                String s = f.getAbsolutePath ();
                if (s.length () > 6) ip = s.substring (0, s.length () - 6);
            }
        }
        if (findAllSettings) {
            if (f == null && ip != null) f = new File (u2w (ip + "/bin/R"));
            if (f != null) ip = getRSettings (f.getAbsolutePath ());
        }
    } catch (Exception e) {
    }
    return ip;
}


-----Function Pair=143=-----==

String fileNameForContext (NSDictionary context) {
    String kind = (String) context.objectForKey (MD.Kind);
    String extension;
    if ("com.macromedia.flash.swf".equals (kind)) {
        extension = "swf";
    }
    else {
        extension = UTType.preferredTagWithClass (kind, UTType.FilenameExtensionTagClass);
        if (extension == null) {
            extension = NSPathUtilities.pathExtension (_object.url ().getPath ());
        }
    }
    String _width = (String) context.valueForKey (MD.PixelWidth);
    String _height = (String) context.valueForKey (MD.PixelHeight);
    String dimensions = "";
    if ((_width != null) && (_height != null)) {
        dimensions = "-" + _width + "x" + _height;
    }
    String objectFileName = baseFileName () + dimensions;
    objectFileName = NSPathUtilities.stringByAppendingPathExtension (objectFileName, extension);
    return objectFileName;
}


private static void setProperty (PropertyDescriptor pd, Object value, Object source) throws IllegalAccessException, InvocationTargetException, MouldException {
    if (pd != null && pd.getWriteMethod () != null) {
        Method m = pd.getWriteMethod ();
        if (! m.isAccessible ()) m.setAccessible (true);
        Class tClass = m.getParameterTypes () [0];
        if (value == null || tClass.isAssignableFrom (value.getClass ())) {
            m.invoke (source, new Object [] {value});
            log.debug ("Set property '" + pd.getName () + "=" + value + "' on object '" + source.getClass ().getName () + "'");
        }
        else if (DataTypeMapper.instance ().isMappable (value.getClass (), tClass)) {
            value = DataTypeMapper.instance ().map (value, tClass);
            m.invoke (source, new Object [] {value});
            log.debug ("Translate+Set property '" + pd.getName () + "=" + value + "' on object '" + source.getClass ().getName () + "'");
        }
        else {
            throw new MouldException (MouldException.DATATYPE_MISMATCH, source.getClass ().getName () + "." + m.getName (), tClass.getName (), value.getClass ().getName ());
        }
    }
    else {
        MouldException me = new MouldException (MouldException.NO_SETTER, null, pd == null ? "???" : pd.getName (), source.getClass ().getName ());
        log.error (me.getLocalizedMessage ());
        throw me;
    }
}


-----Function Pair=144=-----==

protected void recoverySave () {
    if (Config.get ("save.recovery.active", "yes").equalsIgnoreCase ("no")) return;
    String filePath = Config.get ("save.recovery.filepath", "18xx_autosave.rails");
    File tempFile = null;
    tempFile = new File (filePath + ".tmp");
    if (! save (tempFile, recoverySaveWarning, "RecoverySaveFailed")) {
        recoverySaveWarning = false;
        return;
    }
    File recoveryFile = null;
    boolean result = false;
    try {
        log.debug ("Created temporary recovery file, path = " + tempFile.getPath ());
        recoveryFile = new File (filePath);
        log.debug ("Potential recovery filePath = " + recoveryFile.getPath ());
        if (recoveryFile.exists ()) {
            log.debug ("Potential recovery filePath = " + recoveryFile.getPath ());
            File backupFile = new File (filePath + ".bak");
            if (backupFile.exists ()) backupFile.delete ();
            recoveryFile.renameTo (backupFile);
            result = tempFile.renameTo (recoveryFile);
        }
        else {
            log.debug ("Tries to rename temporary file");
            result = tempFile.renameTo (recoveryFile);
        }
    } catch (Exception e) {
        DisplayBuffer.add (LocalText.getText ("RecoverySaveFailed", e.getMessage ()));
        recoverySaveWarning = false;
        return;
    }
    if (result) {
        log.debug ("Renamed to recovery file, path = " + recoveryFile.getPath ());
        if (! recoverySaveWarning) {
            DisplayBuffer.add (LocalText.getText ("RecoverySaveSuccessAgain"));
            recoverySaveWarning = true;
        }
    }
    else {
        if (recoverySaveWarning) {
            DisplayBuffer.add (LocalText.getText ("RecoverySaveFailed", "file renaming not possible"));
            recoverySaveWarning = false;
        }
    }
}


public static void shuffle2 (int [] a) {
    Random random = new Random ();
    random.nextInt ();
    for (int i = a.length - 1; i >= 1; i --) {
        int j = random.nextInt (i + 1);
        int tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


-----Function Pair=145=-----==

private AbsoluteDirection absoluteMovementDirection (int from, MovingDirection direction) {
    AbsoluteDirection result = AbsoluteDirection.right;
    if (direction == MovingDirection.CLOCKWISE) {
        if (from > 3) result = AbsoluteDirection.down;
        if (from > 7) result = AbsoluteDirection.left;
        if (from > 11) result = AbsoluteDirection.up;
    }
    else {
        if (from == 0) return AbsoluteDirection.down;
        result = AbsoluteDirection.left;
        if (from > 4) result = AbsoluteDirection.up;
        if (from > 8) result = AbsoluteDirection.right;
        if (from > 12) result = AbsoluteDirection.down;
    }
    return result;
}


private static void getcompletionname () throws TestException {
    Field f;
    Method m;
    String name;
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.x)");
        f = RJavaTools_Test.class.getField ("x");
        if (! "x".equals (RJavaTools.getCompletionName (f))) {
            throw new TestException ("getCompletionName(RJavaTools_Test.x) != 'x' ");
        }
        System.out.println (" == 'x' : ok ");
    } catch (NoSuchFieldException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.static_x)");
        f = RJavaTools_Test.class.getField ("static_x");
        if (! "static_x".equals (RJavaTools.getCompletionName (f))) {
            throw new TestException ("getCompletionName(RJavaTools_Test.static_x) != 'static_x' ");
        }
        System.out.println (" == 'static_x' : ok ");
    } catch (NoSuchFieldException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.getX() )");
        m = RJavaTools_Test.class.getMethod ("getX", (Class []) null);
        if (! "getX()".equals (RJavaTools.getCompletionName (m))) {
            System.err.println (RJavaTools.getCompletionName (m));
            throw new TestException ("getCompletionName(RJavaTools_Test.getX() ) != ''getX()' ");
        }
        System.out.println (" == 'getX()' : ok ");
    } catch (NoSuchMethodException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.setX( Integer ) )");
        m = RJavaTools_Test.class.getMethod ("setX", new Class [] {Integer.class});
        if (! "setX(".equals (RJavaTools.getCompletionName (m))) {
            System.err.println (RJavaTools.getCompletionName (m));
            throw new TestException ("getCompletionName(RJavaTools_Test.setX(Integer) ) != 'setX(' ");
        }
        System.out.println (" == 'setX(' : ok ");
    } catch (NoSuchMethodException e) {
        throw new TestException (e.getMessage ());
    }
}


-----Function Pair=146=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


private void subscribe () {
    MetricListener ml = this;
    try {
        this.initFile (jobId);
        MonitorConsumer mc = new MonitorConsumer (this.monitorURL);
        mc.addMetricListener (ml);
        mc.auth ();
        MonitorArg args [] = new MonitorArg [1];
        args [0] = new MonitorArg ("jobid", jobId);
        MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect ("application.message", args);
        cr.waitResult ();
        MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance ();
        int mid = suscribeMetric.getMetricId ();
        this.metricId = mid;
        int channel = mc.getChannelId ();
        System.out.println ("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
        MonitorConsumer.CommandResult sr = mc.subscribe (mid, channel);
        sr.waitResult ();
        int status = sr.getStatus ();
        if (status != 0) {
            System.out.println ("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr ());
            System.exit (1);
        }
        System.out.println ("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
        while (true) {
            try {
                java.lang.Thread.sleep (1000);
            } catch (Exception e) {
            }
        }
    } catch (MonitorException mex) {
        System.out.println ("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
        mex.printStackTrace ();
    }
}


-----Function Pair=147=-----==

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


private byte [] showAvailablePaths (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CapturePathsAvailable.html");
    StringBuffer buff = new StringBuffer ();
    template.replaceAll ("$title", "Available capture paths");
    String path = urlData.getParameter ("path");
    File [] files = null;
    String parent = "";
    if (path == null || path.length () == 0) {
        files = File.listRoots ();
        template.replaceAll ("$currentPath", "");
    }
    else {
        File thisPath = new File (path);
        files = thisPath.listFiles ();
        if (thisPath.getParentFile () != null) parent = thisPath.getParentFile ().getAbsolutePath ();
        String addLink = "";
        if (thisPath.exists ()) {
            addLink = " <a href='#' onClick=\"addPath('/servlet/SystemDataRes?action=32&path=" + URLEncoder.encode (thisPath.getAbsolutePath (), "UTF-8") + "');\">" + "<img alt='Add Path' border=0 src='/images/add.png' align='absmiddle' width='24' height='24'></a> " + thisPath.getAbsolutePath ();
        }
        template.replaceAll ("$currentPath", addLink);
        if (thisPath.getParentFile () != null && thisPath.getParentFile ().exists () == true) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (parent, "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(parent)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
        else {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(root)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
    }
    if (files == null) {
        files = new File [0];
    }
    int numberItems = 0;
    for (int x = 0; x < files.length; x ++) {
        if (files [x].isDirectory ()) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (files [x].getCanonicalPath (), "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='path' border=0 src='/images/showchildren.png' align='absmiddle' width='24' height='24'> ");
            buff.append (files [x].getCanonicalPath ());
            buff.append ("</a>");
            buff.append ("</td></tr>");
            numberItems ++;
        }
    }
    if (numberItems == 0) {
        buff.append ("<tr><td nowrap>No items to show</td></tr>");
    }
    template.replaceAll ("$availablePaths", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=148=-----==

private static int executeCommand (final String commandName, final List < String > arguments) {
    System.out.println ("executing [" + commandName.toString () + "] with arguments: " + Arrays.toString (arguments.toArray ()));
    try {
        final List < String > pbArgs = new LinkedList < String > (arguments);
        pbArgs.add (0, commandName);
        final ProcessBuilder pb = new ProcessBuilder (pbArgs);
        System.out.println ("starting ...");
        final Process process = pb.start ();
        InputStream inputStream = process.getInputStream ();
        InputStream errorStream = process.getErrorStream ();
        ThreadedStreamHandler outputStreamHandler = ThreadedStreamHandler.newSimple ("OUT", inputStream);
        ThreadedStreamHandler errorStreamHandler = ThreadedStreamHandler.newSimple ("ERR", errorStream);
        outputStreamHandler.start ();
        errorStreamHandler.start ();
        System.out.println ("command running");
        final int exitValue = process.waitFor ();
        outputStreamHandler.interrupt ();
        errorStreamHandler.interrupt ();
        outputStreamHandler.join ();
        errorStreamHandler.join ();
        System.out.println ("finished. exitValue: " + exitValue);
        return exitValue;
    } catch (final Exception e) {
        throw new RuntimeException ("executing command failed", e);
    }
}


private String generateDirectoryListing (String httpURIPath) {
    String dirListing = "";
    File path = new File (pws.getSetting ("documentroot") + httpURIPath);
    File [] Listing = path.listFiles ();
    if (Listing != null) {
        dirListing = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">";
        dirListing += "<HTML><HEAD><TITLE>Index of " + httpURIPath + "</TITLE></HEAD><BODY><H1>Index of " + httpURIPath + "</H1><P><TABLE BORDER=\"0\" CELLPADDING=\"4\" WIDTH=\"100%\">";
        dirListing += "<TR><TD>Type</TD><TD>File Name</TD><TD>File Size</TD><TD>Last Modified</TD><TD></TD></TR>";
        dirListing += "<TR><TD COLSPAN=\"5\"><HR></TD>";
        if (path.getPath ().replace ('\\', '/').equals (pws.getSetting ("documentroot")) == false) {
            String filePath = path.getPath ().substring (pws.getSetting ("documentroot").length (), path.getPath ().length () - path.getName ().length ()).replace ('\\', '/');
            StringTokenizer filePart = new StringTokenizer (filePath, "/");
            String piece = "";
            String EncodedfilePath = "";
            while (filePart.hasMoreTokens () == true) {
                EncodedfilePath += "/";
                piece = filePart.nextToken ();
                try {
                    EncodedfilePath += URLEncoder.encode (piece, pws.getEncoding ());
                } catch (UnsupportedEncodingException e) {
                    Misc.putSysMessage (1, "Unsupported encoding detected: " + e);
                }
            }
            dirListing += "<TR><TD COLSPAN=\"4\"><a href=\"http://" + pws.getSetting ("servername") + ":" + pws.getSetting ("port");
            dirListing += EncodedfilePath + "\">Parent Directory</a></TD></TR>" + pws.crlf ();
        }
        for (int i = 0; i < Listing.length; i ++) {
            dirListing += "<TR><TD>";
            if (Listing [i].isDirectory () == true) dirListing += "[DIR]";
            else dirListing += "[FILE]";
            SimpleDateFormat temp = new SimpleDateFormat ("dd-MM-yyyy HH:mm:ss zzz");
            temp.setTimeZone (new SimpleTimeZone (0, "GMT"));
            String S_lastModified = temp.format (new Date (Listing [i].lastModified ()));
            String filePath = Listing [i].getPath ().substring (pws.getSetting ("documentroot").length () + 1).replace ('\\', '/');
            StringTokenizer filePart = new StringTokenizer (filePath, "/");
            String piece = "";
            String EncodedfilePath = "";
            while (filePart.hasMoreTokens () == true) {
                EncodedfilePath += "/";
                piece = filePart.nextToken ();
                try {
                    EncodedfilePath += URLEncoder.encode (piece, pws.getEncoding ());
                } catch (UnsupportedEncodingException e) {
                    Misc.putSysMessage (1, "Unsupported encoding detected: " + e);
                }
            }
            dirListing += "</TD><TD><a href=\"http://" + pws.getSetting ("servername") + ":" + pws.getSetting ("port");
            dirListing += EncodedfilePath + "\">" + Listing [i].getName () + "</a></TD><TD>" + Listing [i].length () + " Bytes</TD><TD>" + S_lastModified + "</TD></TR>" + pws.crlf ();
        }
        dirListing += "</TABLE>" + this.giveOutputFooter () + "</BODY></HTML>";
    }
    return dirListing;
}


-----Function Pair=149=-----==

static MemoryUsage forClass (String className) {
    MeasureWithTimeout measurer = new MeasureWithTimeout (className);
    new Thread (measurer).start ();
    synchronized (measurer) {
        if (measurer.memoryUsage == null) {
            try {
                measurer.wait (30000);
            } catch (InterruptedException e) {
                System.err.println ("Interrupted waiting for measurement.");
                e.printStackTrace ();
                return NOT_AVAILABLE;
            }
            if (measurer.memoryUsage == null) {
                System.err.println ("Timed out while measuring " + className + ".");
                return NOT_AVAILABLE;
            }
        }
        System.err.println ("Got memory usage for " + className + ".");
        return measurer.memoryUsage;
    }
}


private synchronized void writeToFile (String line) {
    try {
        PrintWriter out = new PrintWriter (new FileOutputStream (this.tf, true));
        out.println (line);
        out.close ();
    } catch (IOException ex) {
        System.out.println ("\tTestClient.writeToFile(" + line + ") ~ FAILED, IOException: " + ex.getMessage ());
        ex.printStackTrace (System.out);
        return;
    }
    System.out.print (".");
    if (this.currentMessageNumber ++ == this.maxMessageNumber + 1) {
        this.cbInterface.finished (this.jobId);
    }
}


-----Function Pair=150=-----=1=

private void readHeader () throws IOException {
    CRC32 headCRC = new CRC32 ();
    int magic = in.read ();
    if (magic < 0) {
        eos = true;
        return;
    }
    int magic2 = in.read ();
    if ((magic + (magic2 << 8)) != GZIP_MAGIC) throw new IOException ("Error in GZIP header, bad magic code");
    headCRC.update (magic);
    headCRC.update (magic2);
    int CM = in.read ();
    if (CM != Deflater.DEFLATED) throw new IOException ("Error in GZIP header, data not in deflate format");
    headCRC.update (CM);
    int flags = in.read ();
    if (flags < 0) throw new EOFException ("Early EOF in GZIP header");
    headCRC.update (flags);
    if ((flags & 0xd0) != 0) throw new IOException ("Reserved flag bits in GZIP header != 0");
    for (int i = 0; i < 6; i ++) {
        int readByte = in.read ();
        if (readByte < 0) throw new EOFException ("Early EOF in GZIP header");
        headCRC.update (readByte);
    }
    if ((flags & FEXTRA) != 0) {
        for (int i = 0; i < 2; i ++) {
            int readByte = in.read ();
            if (readByte < 0) throw new EOFException ("Early EOF in GZIP header");
            headCRC.update (readByte);
        }
        if (in.read () < 0 || in.read () < 0) throw new EOFException ("Early EOF in GZIP header");
        int len1, len2, extraLen;
        len1 = in.read ();
        len2 = in.read ();
        if ((len1 < 0) || (len2 < 0)) throw new EOFException ("Early EOF in GZIP header");
        headCRC.update (len1);
        headCRC.update (len2);
        extraLen = (len1 << 8) | len2;
        for (int i = 0; i < extraLen; i ++) {
            int readByte = in.read ();
            if (readByte < 0) throw new EOFException ("Early EOF in GZIP header");
            headCRC.update (readByte);
        }
    }
    if ((flags & FNAME) != 0) {
        int readByte;
        while ((readByte = in.read ()) > 0) headCRC.update (readByte);
        if (readByte < 0) throw new EOFException ("Early EOF in GZIP file name");
        headCRC.update (readByte);
    }
    if ((flags & FCOMMENT) != 0) {
        int readByte;
        while ((readByte = in.read ()) > 0) headCRC.update (readByte);
        if (readByte < 0) throw new EOFException ("Early EOF in GZIP comment");
        headCRC.update (readByte);
    }
    if ((flags & FHCRC) != 0) {
        int tempByte;
        int crcval = in.read ();
        if (crcval < 0) throw new EOFException ("Early EOF in GZIP header");
        tempByte = in.read ();
        if (tempByte < 0) throw new EOFException ("Early EOF in GZIP header");
        crcval = (crcval << 8) | tempByte;
        if (crcval != ((int) headCRC.getValue () & 0xffff)) throw new IOException ("Header CRC value mismatch");
    }
    readGZIPHeader = true;
}


public static long sampledCRC (File file) throws FileNotFoundException {
    long fileSize = file.length ();
    RandomAccessFile fs = new RandomAccessFile (file, "r");
    long startTime = System.currentTimeMillis ();
    CRC32 crc = new CRC32 ();
    for (int i = 7; i >= 0; i --) {
        crc.update ((int) (fileSize>> (8 * i)));
    }
    final int CHUNK_SIZE = 4096;
    final int MINIMUM_CHUNK_SKIP = 1;
    final int MAXIMUM_CHUNK_SKIP = 1000;
    final double CHUNK_SKIP_MULTIPLIER = 1.2;
    int totalRead = 0;
    byte [] data = new byte [CHUNK_SIZE];
    for (int position = 0, chunkSkip = 0;;) {
        try {
            fs.seek (position);
            int read = fs.read (data, 0, data.length);
            if (read == - 1) {
                break;
            }
            position += read + chunkSkip * CHUNK_SIZE;
            if (position > 64 << 10) {
                if (chunkSkip == 0) {
                    chunkSkip = MINIMUM_CHUNK_SKIP;
                }
                else {
                    chunkSkip = Math.min ((int) Math.ceil (chunkSkip * CHUNK_SKIP_MULTIPLIER), MAXIMUM_CHUNK_SKIP);
                }
            }
            totalRead += read;
            crc.update (data, 0, read);
        } catch (IOException ioe) {
        }
        if ((totalRead % (100 * CHUNK_SIZE)) == 0) {
            Logging.verboseln (1, "Processed " + (totalRead / 1024) + "KBytes.  CRC32 = " + crc.getValue ());
        }
    }
    long endTime = System.currentTimeMillis ();
    Logging.msgln ("Sampled " + (totalRead / 1024) + " of " + (fileSize / 1024) + " KBytes. CRC took " + (endTime - startTime) + "ms.  CRC32 = " + crc.getValue ());
    return crc.getValue ();
}


-----Function Pair=151=-----==

private void downloadFile (String filename, long remoteFileCRC) throws IOException {
    URL updateList = new URL (basedir + filename.replace ('\\', '/'));
    HttpURLConnection conn = (HttpURLConnection) updateList.openConnection ();
    BufferedInputStream bis = new BufferedInputStream (conn.getInputStream ());
    File localFile = new File (filename + ".new");
    File parent = localFile.getParentFile ();
    if (parent != null) {
        parent.mkdirs ();
    }
    FileOutputStream fos = new FileOutputStream (localFile);
    System.out.print ("Receiving " + filename);
    int b = bis.read ();
    while (b != - 1) {
        fos.write (b);
        b = bis.read ();
    }
    fos.close ();
    bis.close ();
    long downloadedFileCRC = getFileCRC32 (localFile);
    String blank = new String (new char [50 - filename.length ()]);
    if (downloadedFileCRC != remoteFileCRC) {
        System.out.println (blank + "  [FAILED]");
        downloadFailed = true;
        localFile.delete ();
    }
    else {
        System.out.println (blank + "  [  OK  ]");
        localFile.renameTo (new File (filename));
    }
}


public byte [] decrypt (byte [] cryptedData, byte [] keySignature) throws CryptographicException {
    KeyBL key = KeyCache.searchKey (keySignature);
    if (key == null) {
        return null;
    }
    BlockCipherBL blockCipher = CSPManager.getBlockCipher (key.getKeyCSP ());
    int blockSize = blockCipher.getBlockSize ();
    int cryptedDataSize = cryptedData.length;
    if (cryptedDataSize == 0 || cryptedDataSize % blockSize != 0) {
        throw new CryptographicException ("Incompatible crypted data size (" + cryptedDataSize + ") or block cipher block size (" + blockSize + ")");
    }
    if (blockSize <= 8) {
        throw new CryptographicException ("Unsupported block type: " + blockSize + " <= 8");
    }
    byte [] lastBlocks;
    if (cryptedData.length == blockSize) {
        lastBlocks = new byte [blockSize];
    }
    else {
        lastBlocks = new byte [2 * blockSize];
    }
    System.arraycopy (cryptedData, cryptedData.length - lastBlocks.length, lastBlocks, 0, lastBlocks.length);
    blockCipher.getBlockCipher ().decrypt (lastBlocks, 0, blockSize, lastBlocks.length / blockSize, key.getKey ());
    int dataSize = bytesToInt (lastBlocks, lastBlocks.length - 8);
    int crcValue = bytesToInt (lastBlocks, lastBlocks.length - 4);
    if (log.isTraceEnabled ()) {
        log.trace ("Decrypting " + dataSize + " bytes with CSP " + key.getKeyCSP ());
    }
    if (dataSize > cryptedDataSize) {
        log.error ("Decryption error");
        throw new RuntimeException ("Decryption error");
    }
    byte [] data = new byte [dataSize];
    int fullDataBlockCount = data.length / blockSize;
    int dataInLastBlock = data.length % blockSize;
    if (cryptedData.length != blockSize && fullDataBlockCount == cryptedDataSize / blockSize - 1) {
        fullDataBlockCount --;
        dataInLastBlock += blockSize;
    }
    System.arraycopy (cryptedData, 0, data, 0, fullDataBlockCount * blockSize);
    blockCipher.getBlockCipher ().decrypt (data, 0, blockSize, fullDataBlockCount, key.getKey ());
    System.arraycopy (lastBlocks, 0, data, fullDataBlockCount * blockSize, dataInLastBlock);
    CRC32 crc32 = new CRC32 ();
    crc32.update (data);
    if ((int) crc32.getValue () != crcValue) {
        throw new CryptographicException ("CRC error after decryption. (should: " + crcValue + ", is: " + (int) crc32.getValue () + ")");
    }
    return data;
}


-----Function Pair=152=-----==

public static long sampledCRC (File file) throws FileNotFoundException {
    long fileSize = file.length ();
    RandomAccessFile fs = new RandomAccessFile (file, "r");
    long startTime = System.currentTimeMillis ();
    CRC32 crc = new CRC32 ();
    for (int i = 7; i >= 0; i --) {
        crc.update ((int) (fileSize>> (8 * i)));
    }
    final int CHUNK_SIZE = 4096;
    final int MINIMUM_CHUNK_SKIP = 1;
    final int MAXIMUM_CHUNK_SKIP = 1000;
    final double CHUNK_SKIP_MULTIPLIER = 1.2;
    int totalRead = 0;
    byte [] data = new byte [CHUNK_SIZE];
    for (int position = 0, chunkSkip = 0;;) {
        try {
            fs.seek (position);
            int read = fs.read (data, 0, data.length);
            if (read == - 1) {
                break;
            }
            position += read + chunkSkip * CHUNK_SIZE;
            if (position > 64 << 10) {
                if (chunkSkip == 0) {
                    chunkSkip = MINIMUM_CHUNK_SKIP;
                }
                else {
                    chunkSkip = Math.min ((int) Math.ceil (chunkSkip * CHUNK_SKIP_MULTIPLIER), MAXIMUM_CHUNK_SKIP);
                }
            }
            totalRead += read;
            crc.update (data, 0, read);
        } catch (IOException ioe) {
        }
        if ((totalRead % (100 * CHUNK_SIZE)) == 0) {
            Logging.verboseln (1, "Processed " + (totalRead / 1024) + "KBytes.  CRC32 = " + crc.getValue ());
        }
    }
    long endTime = System.currentTimeMillis ();
    Logging.msgln ("Sampled " + (totalRead / 1024) + " of " + (fileSize / 1024) + " KBytes. CRC took " + (endTime - startTime) + "ms.  CRC32 = " + crc.getValue ());
    return crc.getValue ();
}


public List < RARFileEntry > listFiles (File f) throws IOException, RARException {
    StreamDataSource sds = new StreamDataSource ("test", f);
    InputStream is = sds.getInputStream (0);
    StreamDataSource.RAFInputStream ris = null;
    if (is instanceof StreamDataSource.RAFInputStream) {
        ris = (StreamDataSource.RAFInputStream) is;
    }
    long pos = 0L;
    List < RARFileEntry > files = new LinkedList < RARFileEntry > ();
    RH_MARK mh = new RH_MARK (is);
    pos += mh.getSize ();
    boolean b = true;
    while (b) {
        try {
            RH rh = new RH (is);
            if (! rh.validate ()) {
                long brokenPosStart = pos;
                long brokenPosEnd = pos;
                if (ris != null) {
                    while (! ris.eof () && ! rh.validate ()) {
                        ris.seek (++ pos);
                        rh = new RH (ris);
                    }
                }
                else {
                    throw new RARException ("Invalid RAR header. Can't scan for next valid header - exiting.");
                }
                if (rh != null) {
                }
                brokenPosEnd = pos;
                if (brokenPosStart != brokenPosEnd) {
                    files.add (new RARBrokenFileEntry (f, brokenPosStart, brokenPosEnd));
                }
            }
            if (code2head.get (rh.getType ()) == HEAD_TYPE.FILE) {
                RH_FILE fh = new RH_FILE (rh);
                if (fh != null) {
                    files.add (new RARFileEntry (f, pos, fh));
                    pos += is.skip (fh.getPackedSize ());
                }
            }
            pos += rh.getSize ();
            b = rh.validate ();
        } catch (IOException ioex) {
            b = false;
        }
    }
    is.close ();
    return files;
}


-----Function Pair=153=-----==

public static void unzip2 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    ZipFile zip = new ZipFile (zipfile);
    Enumeration < ZipArchiveEntry > files = zip.getEntries ();
    while (files.hasMoreElements ()) {
        ZipArchiveEntry ze = files.nextElement ();
        File newFile = new File (outputdir + File.separator + ze.getName ());
        newFile.getParentFile ().mkdirs ();
        if (ze.isDirectory ()) {
            newFile.mkdir ();
        }
        else {
            InputStream is = zip.getInputStream (ze);
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = is.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
            is.close ();
        }
    }
    zip.close ();
}


public ActionForward deleteMultipleCorpora (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    if (log.isDebugEnabled ()) {
        log.debug ("Entering 'delete multiple corpora' method");
    }
    ActionMessages messages = new ActionMessages ();
    DocServiceManager mgr = (DocServiceManager) getBean ("docServiceManager");
    String toDelete = request.getParameter ("toDelete");
    String [] corporaIds = request.getParameterValues ("rowId");
    if (corporaIds == null) {
        ActionMessages errors = new ActionMessages ();
        errors.add ("errors.detail", new ActionMessage ("corpus.noCorpusSelected"));
        saveErrors (request, errors);
        return dispatchMethod (mapping, form, request, response, "search");
    }
    if (toDelete != null) {
        for (String corpusId : corporaIds) {
            mgr.deleteCorpus (corpusId);
        }
        messages.add (ActionMessages.GLOBAL_MESSAGE, new ActionMessage ("corpora.deleted"));
    }
    saveMessages (request.getSession (), messages);
    return dispatchMethod (mapping, form, request, response, "search");
}


-----Function Pair=154=-----=1=

public static boolean sendMail (String server, String toAddress, String fromName, String fromAddress, String ccAddress, String bccAddress, String subject, String message) {
    Properties properties = System.getProperties ();
    properties.put ("mail.smtp.host", server);
    Session session = Session.getDefaultInstance (properties, null);
    Address ccInternetAddress = null, bccInternetAddress = null;
    try {
        MimeMessage msg = new MimeMessage (session);
        int ii;
        Address toInternetAddress = new InternetAddress (toAddress);
        msg.setRecipients (Message.RecipientType.TO, new Address [] {toInternetAddress});
        if (ccAddress != null && ! ccAddress.equals ("")) {
            ccInternetAddress = new InternetAddress (ccAddress);
            msg.setRecipients (Message.RecipientType.CC, new Address [] {ccInternetAddress});
        }
        if (bccAddress != null && ! bccAddress.equals ("")) {
            bccInternetAddress = new InternetAddress (bccAddress);
            msg.setRecipients (Message.RecipientType.BCC, new Address [] {bccInternetAddress});
        }
        MimeBodyPart textPart = new MimeBodyPart ();
        msg.setFrom (new InternetAddress (fromAddress, fromName));
        msg.setSubject (subject);
        msg.setText (message);
        Transport.send (msg);
        return true;
    } catch (UnsupportedEncodingException uee) {
        System.err.println ("U:" + uee);
        return false;
    } catch (AddressException ae) {
        System.err.println ("A:" + ae);
        return false;
    } catch (MessagingException me) {
        System.err.println ("M:" + me);
        return false;
    }
}


public static void main (String [] args) {
    if (args.length != 4) {
        usage ();
        System.exit (1);
    }
    System.out.println ();
    String to = args [0];
    String from = args [1];
    String host = args [2];
    boolean debug = Boolean.valueOf (args [3]).booleanValue ();
    Properties props = new Properties ();
    props.put ("mail.smtp.host", host);
    if (debug) props.put ("mail.debug", args [3]);
    Session session = Session.getInstance (props, null);
    session.setDebug (debug);
    try {
        Message msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (from));
        InternetAddress [] address = {new InternetAddress (args [0])};
        msg.setRecipients (Message.RecipientType.TO, address);
        msg.setSubject ("JavaMail APIs Test");
        msg.setSentDate (new Date ());
        msg.setText (msgText);
        Transport.send (msg);
    } catch (MessagingException mex) {
        System.out.println ("\n--Exception handling in msgsendsample.java");
        mex.printStackTrace ();
        System.out.println ();
        Exception ex = mex;
        do {
            if (ex instanceof SendFailedException) {
                SendFailedException sfex = (SendFailedException) ex;
                Address [] invalid = sfex.getInvalidAddresses ();
                if (invalid != null) {
                    System.out.println ("    ** Invalid Addresses");
                    if (invalid != null) {
                        for (int i = 0; i < invalid.length; i ++) System.out.println ("         " + invalid [i]);
                    }
                }
                Address [] validUnsent = sfex.getValidUnsentAddresses ();
                if (validUnsent != null) {
                    System.out.println ("    ** ValidUnsent Addresses");
                    if (validUnsent != null) {
                        for (int i = 0; i < validUnsent.length; i ++) System.out.println ("         " + validUnsent [i]);
                    }
                }
                Address [] validSent = sfex.getValidSentAddresses ();
                if (validSent != null) {
                    System.out.println ("    ** ValidSent Addresses");
                    if (validSent != null) {
                        for (int i = 0; i < validSent.length; i ++) System.out.println ("         " + validSent [i]);
                    }
                }
            }
            System.out.println ();
            if (ex instanceof MessagingException) ex = ((MessagingException) ex).getNextException ();
            else ex = null;
        }
        while (ex != null);
    }
}


-----Function Pair=155=-----==

public static void BubbleSortLong1 (long [] num) {
    boolean flag = true;
    long temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


public boolean moveNext () {
    classText.setText (classText.getText ().trim ());
    dirText.setText (dirText.getText ().trim ());
    if (classText.getText ().equals ("") || dirText.getText ().equals ("")) {
        JOptionPane.showMessageDialog (this, ResourceBundle.getBundle ("jarwizard_res").getString ("IDS_BOTH_ERROR"), "Error", JOptionPane.ERROR_MESSAGE);
        return false;
    }
    if (! classText.getText ().startsWith (dirText.getText ())) {
        JOptionPane.showMessageDialog (this, ResourceBundle.getBundle ("jarwizard_res").getString ("IDS_SUBDIR_ERROR"), "Error", JOptionPane.ERROR_MESSAGE);
        return false;
    }
    setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
    new JarringThread (jarringDialog, dirText.getText (), m_fc3.getSelectedFile ().getAbsolutePath (), classText.getText (), (jList1.getSelectedIndex () == 1)).start ();
    jarringDialog.pack ();
    Dimension screenDim = getSize ();
    int dx = (screenDim.width - jarringDialog.getSize ().width) / 2, dy = (screenDim.height - jarringDialog.getSize ().height) / 2;
    jarringDialog.setLocation (getLocationOnScreen ().x + dx, getLocationOnScreen ().y + dy);
    jarringDialog.show ();
    boolean b;
    if (m_errorDescription == null) {
        jLabel111.setText (ResourceBundle.getBundle ("jarwizard_res").getString ("IDS_CONGRATS_1") + m_fc3.getSelectedFile ().getAbsolutePath () + ResourceBundle.getBundle ("jarwizard_res").getString ("IDS_CONGRATS_2"));
        Toolkit.getDefaultToolkit ().beep ();
        b = true;
    }
    else {
        JOptionPane.showMessageDialog (this, "Jar Creation error\n\n" + m_errorDescription + "\n\n", "Error", JOptionPane.ERROR_MESSAGE);
        b = false;
    }
    setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));
    return b;
}


-----Function Pair=156=-----==

private void runInstall (File dir, String webappFolder, String user) {
    try {
        info ("OK, starting the installation now.");
        info ("- Creating the folder: " + dir.getAbsolutePath ());
        dir.mkdirs ();
        info ("- Copying VERSION.txt to: " + dir.getAbsolutePath ());
        copyFile (new File (dir, "VERSION.txt"), new File ("VERSION.txt"));
        info ("- Copying LICENCE.txt to: " + dir.getAbsolutePath ());
        copyFile (new File (dir, "VERSION.txt"), new File ("LICENCE.txt"));
        info ("- Copying INSTALL.txt to: " + dir.getAbsolutePath ());
        copyFile (new File (dir, "VERSION.txt"), new File ("INSTALL.txt"));
        info ("- Copying the standard templates to: " + dir.getAbsolutePath ());
        File srcDir = new File ("templates");
        File destDir = new File (dir, "templates");
        destDir.mkdirs ();
        copyFolderContent (destDir, srcDir, true);
        info ("- Creating runsetup.txt in: " + dir.getAbsolutePath () + " since it's a new install.");
        new File (dir, "runsetup.txt").createNewFile ();
        if (user != null) {
            if (user.equals ("")) {
                user = "UNSET";
            }
            info ("- Updating ownership/permissions of: " + dir);
            String [] args1 = {"chmod", "-R", "750", dir.getAbsolutePath ()};
            String [] args2 = {"chown", "-R", user, dir.getAbsolutePath ()};
            if (! exec (args1, true, true)) {
                error ("Failed to execute: " + "chmod -R 750 " + dir.getAbsolutePath ());
            }
            if (error) {
                return;
            }
            if (! exec (args2, true, true)) {
                error ("Failed to execute: " + "chown -R " + user + " " + dir.getAbsolutePath ());
            }
            if (error) {
                return;
            }
        }
        info ("- Copying the web application(jotwiki.war) to the webapp folder: " + webappFolder);
        File deployedWar = new File (webappFolder, "jotwiki.war");
        copyFile (deployedWar, new File ("jotwiki.war"));
        if (user != null) {
            String [] args3 = {"chown", user, deployedWar.getAbsolutePath ()};
            if (user.equals ("")) {
                user = "UNSET";
            }
            if (! exec (args3, true, true)) {
                error ("Failed to execute: " + "chown " + user + deployedWar.getAbsolutePath ());
            }
            if (error) {
                return;
            }
        }
        warn ("Installation has completed, you should now go to\nhttp://yourserver:8080/jotwiki/ to do the initial configuration.\nNote: you might need to restart your app server first.");
        info ("Installation completed successfuly.");
    } catch (Exception e) {
        e.printStackTrace ();
        error ("Error: " + e.getMessage ());
    }
}


private void saveMenuItemActionPerformed (java.awt.event.ActionEvent evt) {
    JFileChooser fileChooser = new JFileChooser ();
    ExampleFileFilter filter = new ExampleFileFilter (new String [] {"qc"}, "quantum circuits");
    fileChooser.addChoosableFileFilter (filter);
    int returnVal = fileChooser.showSaveDialog (this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fileChooser.getSelectedFile ();
        ObjectOutputStream output = null;
        try {
            output = new ObjectOutputStream (new FileOutputStream (file));
            try {
                int [] size = {xRegister.size, yRegister.size};
                output.writeObject (size);
                output.writeObject (circuitPanel.gates);
                output.flush ();
            } catch (EOFException eof) {
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
        } catch (IOException ioe) {
            ioe.printStackTrace ();
        } finally {
            try {
                if (output != null) output.close ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
        }
    }
}


-----Function Pair=157=-----==

public void actionPerformed (ActionEvent e) {
    try {
        BufferedWriter out = new BufferedWriter (new FileWriter (confFile));
        Set < Map.Entry < String, Parameter > > sParam = parameterMap.entrySet ();
        Iterator itParam = sParam.iterator ();
        System.out.println (sParam.getClass ());
        Set < Map.Entry < String, JComponent > > sGui = parameterGuiMap.entrySet ();
        Iterator itGui = sGui.iterator ();
        System.out.println (sGui.getClass ());
        while (itParam.hasNext ()) {
            Map.Entry mParam = (Map.Entry) itParam.next ();
            System.out.println ("mParam -> " + mParam.getKey ());
            while (itGui.hasNext ()) {
                Map.Entry mGui = (Map.Entry) itGui.next ();
                System.out.println ("paramKey " + mParam.getKey () + ", GuiKey " + mGui.getKey ());
                if (mParam.getKey ().equals (mGui.getKey ())) {
                    System.out.println ("entrou");
                    Parameter param = ((Entry < String, Parameter >) mParam).getValue ();
                    if (mGui.getValue ().getClass ().equals (textField.getClass ())) {
                        JTextField value = ((Entry < String, JTextField >) mGui).getValue ();
                        out.write (param.getAttribute () + " = " + value.getText () + "\n");
                    }
                    else if (mGui.getValue ().getClass ().equals (checkBox.getClass ())) {
                        JCheckBox value = ((Entry < String, JCheckBox >) mGui).getValue ();
                        out.write (param.getAttribute () + " = " + value.isSelected () + "\n");
                    }
                    else System.out.println (mGui.getValue ().getClass ());
                    System.out.println ("passou");
                }
            }
            itGui = sGui.iterator ();
        }
        out.close ();
    } catch (IOException ex) {
    }
}


public void open () {
    JFileChooser fileChooser = new JFileChooser ();
    fileChooser.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    fileChooser.addChoosableFileFilter (new VESTChartFilter ());
    fileChooser.setCurrentDirectory (new File ("."));
    int result = fileChooser.showOpenDialog (this);
    if (result == JFileChooser.CANCEL_OPTION) return;
    File fileName = fileChooser.getSelectedFile ();
    if (fileName == null || fileName.getName ().equals ("")) {
        JOptionPane.showMessageDialog (this, "Invalid File Name", "Invalid File Name", JOptionPane.ERROR_MESSAGE);
    }
    else {
        try {
            clearGraph ();
            input = new ObjectInputStream (new FileInputStream (fileName));
            int length = input.readInt ();
            Object [] cells = new Object [length];
            Hashtable < DefaultGraphCell, AttributeMap > attrib = new Hashtable < DefaultGraphCell, AttributeMap > ();
            for (int i = 0; i < length; i ++) {
                DefaultGraphCell tmp = (DefaultGraphCell) input.readObject ();
                if (tmp instanceof DefaultEdge) {
                }
                else if (tmp instanceof basicCell) {
                    attrib.put (tmp, tmp.getAttributes ());
                    cells [i] = tmp;
                }
                else if (tmp instanceof SwimLaneCell) {
                    attrib.put (tmp, tmp.getAttributes ());
                    cells [i] = tmp;
                }
                else if (tmp instanceof AndStateCell) {
                    attrib.put (tmp, tmp.getAttributes ());
                    cells [i] = tmp;
                }
                else if (tmp instanceof orthogonalCell) {
                    attrib.put (tmp, tmp.getAttributes ());
                    cells [i] = tmp;
                }
                else if (tmp instanceof circle) {
                    attrib.put (tmp, tmp.getAttributes ());
                    cells [i] = tmp;
                }
            }
            graph.getGraphLayoutCache ().insert (cells, attrib, null, null, null);
            int counter = input.readInt ();
            for (int j = 0; j < counter; j ++) {
                String name, source, target;
                name = (String) input.readObject ();
                source = (String) input.readObject ();
                target = (String) input.readObject ();
                remakeConnection (name, source, target);
            }
            input.close ();
        } catch (IOException e) {
            JOptionPane.showMessageDialog (this, "Error Opening File", "Error", JOptionPane.ERROR_MESSAGE);
            System.out.println (e);
        } catch (ClassNotFoundException e) {
            JOptionPane.showMessageDialog (this, "File is not an Evaluation!", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }
}


-----Function Pair=158=-----==

private void layoutView () {
    this.setBorder (BorderFactory.createEmptyBorder (30, 30, 30, 30));
    this.setLayout (new BoxLayout (this, BoxLayout.Y_AXIS));
    data.setLayout (new BoxLayout (data, BoxLayout.Y_AXIS));
    data.setBorder (BorderFactory.createTitledBorder ("Save Data"));
    data.add (exportCsvButton);
    image.setLayout (new BoxLayout (image, BoxLayout.Y_AXIS));
    image.setBorder (BorderFactory.createTitledBorder ("Save Image"));
    data.setAlignmentX (Component.LEFT_ALIGNMENT);
    image.setAlignmentX (Component.LEFT_ALIGNMENT);
    doneButton.setAlignmentX (Component.LEFT_ALIGNMENT);
    this.add (titleLabel);
    this.add (Box.createVerticalStrut (12));
    this.add (data);
    this.add (Box.createVerticalStrut (12));
    this.add (doneButton);
    Dimension minsize = new Dimension (1, 1);
    Dimension maxsize = new Dimension (Short.MAX_VALUE, Short.MAX_VALUE);
    this.add (new Box.Filler (minsize, maxsize, maxsize));
}


private void runAllActionPerformed (java.awt.event.ActionEvent evt) {
    if (evt.getSource () == runAll) {
        int returnVal = fc.showOpenDialog (PMCopy.this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            inputFile = fc.getSelectedFile ();
            if (! BinningFasta.verifyInputFile (inputFile)) {
                log.append ("That is not a valid fasta file, please choose" + " a properly formatted fasta file.\n");
                return;
            }
            (new Thread () {
                public void run () {
                    log.append ("Opening: " + inputFile.getName () + "\n");
                    narr.println ("Opening: " + inputFile.getName () + "\n");
                    File startingFile = removeOutgroup (inputFile);
                    int userChoice = userSortPercentage ();
                    values = new BinningAndFred (startingFile, log, narr, userChoice);
                    values.run ();
                    hClimbResult = null;
                    try {
                        hClimbResult = hillClimbing (values.getValue ());
                    } catch (IOException e) {
                        e.printStackTrace ();
                    }
                    runNpopConfidenceInterval ();
                    runSigmaConfidenceInterval ();
                    runOmegaConfidenceInterval ();
                    runDriftConfidenceInterval ();
                    readyForCI = true;
                    printResults ();
                }
            }
            ).start ();
        }
        else {
            log.append ("Dialog Cancelled by User.\n");
        }
    }
}


-----Function Pair=159=-----==

public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {
    this.applet = applet;
    if (applet == null) {
        frame = new JFrame (gc);
        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    }
    setLayout (new BorderLayout ());
    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));
    Action openAction = new AbstractAction ("Open File", new ImageIcon (getClass ().getResource ("/open.gif"))) {
        public void actionPerformed (ActionEvent e) {
            if (filechooser == null) {
                filechooser = new JFileChooser ();
                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
            }
            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                open (filechooser.getSelectedFile ());
            }
        }
    }
    ;
    JToolBar bar = new JToolBar ();
    bar.add (new ToolBarButton (openAction));
    add (bar, BorderLayout.NORTH);
    if (applet == null) {
        frame.setTitle ("Image Display - Control Panel");
        frame.getContentPane ().add (this, BorderLayout.CENTER);
        frame.pack ();
        frame.show ();
    }
}


void ReadInClasses () {
    file = new File (System.getProperty ("user.dir"));
    foundcomps = new DefaultListModel ();
    StringTokenizer token;
    String filename = "";
    String filetype = "";
    String classes [] = file.list ();
    for (int i = 0; i < compsInJar.length; i ++) {
        try {
            Class comp = Class.forName (compsInJar [i]);
            Object temp = comp.newInstance ();
            if (temp instanceof Component) {
                Component addthis = (Component) temp;
                foundcomps.addElement (new Comp (compsInJar [i], addthis.getName (), addthis.getPinNames ()));
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace ();
        } catch (InstantiationException e) {
            e.printStackTrace ();
        } catch (IllegalAccessException e) {
            e.printStackTrace ();
        }
    }
    for (int i = 0; i < classes.length; i ++) {
        token = new StringTokenizer (classes [i], ".\0", false);
        int nr = token.countTokens ();
        filename = token.nextToken ();
        if (nr == 2) {
            filetype = token.nextToken ();
            if (filetype.equals ("class")) {
                Object temp = new Object ();
                try {
                    if (! (filename.equals ("Workbench") | filename.equals ("DebugWindow") | filename.equals ("RamDebugWindow") | filename.equals ("CpuDebugWindow") | filename.equals ("BreakpointDebugWindow") | filename.equals ("EEPROMDebugWindow") | filename.equals ("HelpBrowser") | filename.equals ("Logic") | filename.equals ("Splash"))) {
                        Class comp = Class.forName (filename);
                        temp = comp.newInstance ();
                        if (temp instanceof Component) {
                            Component addthis = (Component) temp;
                            System.out.println ("found custom component: " + classes [i]);
                            foundcomps.addElement (new Comp (filename, addthis.getName (), addthis.getPinNames ()));
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace ();
                    JOptionPane.showMessageDialog (Workbench.mainframe, "An error occured while loading component: " + classes [i], "Error loading component", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }
}


-----Function Pair=160=-----==

public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {
    this.applet = applet;
    if (applet == null) {
        frame = new JFrame (gc);
        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    }
    setLayout (new BorderLayout ());
    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));
    Action openAction = new AbstractAction ("Open File", new ImageIcon (getClass ().getResource ("/open.gif"))) {
        public void actionPerformed (ActionEvent e) {
            if (filechooser == null) {
                filechooser = new JFileChooser ();
                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
            }
            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                open (filechooser.getSelectedFile ());
            }
        }
    }
    ;
    JToolBar bar = new JToolBar ();
    bar.add (new ToolBarButton (openAction));
    add (bar, BorderLayout.NORTH);
    if (applet == null) {
        frame.setTitle ("Image Display - Control Panel");
        frame.getContentPane ().add (this, BorderLayout.CENTER);
        frame.pack ();
        frame.show ();
    }
}


private boolean saveFile (File output) {
    if (values == null) {
        return false;
    }
    try {
        BufferedWriter saveOut = new BufferedWriter (new FileWriter (output));
        saveOut.write ("CohanLabProg save file\n");
        String allText = log.getText ();
        saveOut.write (allText + "\n");
        saveOut.write ("narr\n");
        String allNarrText = narr.getText ();
        saveOut.write (allNarrText + "\n");
        saveOut.write ("bins\n");
        ArrayList < String > bins = values.getBins ();
        for (int i = 0; i < bins.size (); i ++) {
            saveOut.write (bins.get (i) + "\n");
        }
        saveOut.write ("sequenceVals\n");
        int [] sequenceVals = values.getSeqVals ();
        saveOut.write (sequenceVals [0] + " " + sequenceVals [1] + "\n");
        int sortPer = MasterVariables.getSortPercentage ();
        saveOut.write ("sortPer\n");
        saveOut.write (sortPer + "\n");
        saveOut.write ("hClimbResult\n");
        double [] percentages = hClimbResult.getPercentages ();
        String save = "";
        save += hClimbResult.getOmega () + " " + hClimbResult.getSigma () + " " + hClimbResult.getNpop ();
        save += " " + hClimbResult.getDrift () + " " + percentages [0] + " " + percentages [1] + " ";
        save += percentages [2] + " " + percentages [3] + " " + percentages [4] + " " + percentages [5] + "\n";
        saveOut.write (save);
        if (omegaConfidenceInterval != null) {
            saveOut.write ("omega ci\n");
            saveOut.write (omegaConfidenceInterval [0] + " " + omegaConfidenceInterval [1] + "\n");
        }
        if (sigmaConfidenceInterval != null) {
            saveOut.write ("sigma ci\n");
            saveOut.write (sigmaConfidenceInterval [0] + " " + sigmaConfidenceInterval [1] + "\n");
        }
        if (npopConfidenceInterval != null) {
            saveOut.write ("npop ci\n");
            saveOut.write (npopConfidenceInterval [0] + " " + npopConfidenceInterval [1] + "\n");
        }
        if (driftConfidenceInterval != 0) {
            saveOut.write ("drift ci\n");
            saveOut.write (driftConfidenceInterval + "\n");
        }
        saveOut.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return true;
}


-----Function Pair=161=-----==

public static void main (String [] args) {
    if (args.length < 2) {
        System.err.println ("Usage: Differ [-verbose] new_vers_dir old_vers_dir");
        System.exit (255);
    }
    Differ differ = new Differ ();
    boolean verbose = false;
    int aidx = 0;
    if (args [0].equals ("-verbose")) {
        verbose = true;
        aidx ++;
    }
    try {
        differ.createDiff (new File (args [aidx ++]), new File (args [aidx ++]), verbose);
    } catch (IOException ioe) {
        System.err.println ("Error: " + ioe.getMessage ());
        System.exit (255);
    }
}


public static Integer [] evaluatePresetsForPackage (Integer [] presets, boolean deep, PresetContext pc, ProgressCallback prog) throws PackageGenerationException {
    try {
        Set preset_set;
        if (deep) {
            try {
                preset_set = pc.getPresetsDeepSet (presets);
                return (Integer []) preset_set.toArray (new Integer [preset_set.size ()]);
            } catch (Exception e) {
                throw new PackageGenerationException (e.getMessage ());
            } finally {
            }
        }
        else return presets;
    } finally {
        prog.updateProgress (1);
    }
}


-----Function Pair=162=-----==

public static void unzipStream (InputStream in, File outputDir) throws FileNotFoundException, IOException {
    String directoryName = outputDir.getAbsolutePath ();
    int BUFFER = 2048;
    BufferedOutputStream dest;
    if (! outputDir.isDirectory ()) outputDir.mkdirs ();
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (in));
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        if (entry.isDirectory ()) {
            File dir = new File (directoryName + File.separator + entry.getName ());
            if (! dir.exists ()) dir.mkdirs ();
            continue;
        }
        new File (new File (directoryName + File.separator + entry.getName ()).getParent ()).mkdirs ();
        int count;
        byte data [] = new byte [BUFFER];
        FileOutputStream fos = new FileOutputStream (directoryName + File.separator + entry.getName ());
        dest = new BufferedOutputStream (fos, BUFFER);
        while ((count = zis.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
}


public void readTaskList (TaskList taskList, File inFile, TaskDataManager taskDataManager) {
    hasCaughtException = false;
    Map < AbstractTask, NodeList > tasksWithSubtasks = new HashMap < AbstractTask, NodeList > ();
    orphanedTaskNodes.clear ();
    orphanedQueryNodes.clear ();
    try {
        if (! inFile.exists ()) return;
        Document doc = openAsDOM (inFile);
        if (doc == null) {
            handleException (inFile, null, new TaskExternalizationException ("TaskList was not well formed XML"));
            return;
        }
        Element root = doc.getDocumentElement ();
        readVersion = root.getAttribute (ATTRIBUTE_VERSION);
        if (readVersion.equals (VALUE_VERSION_1_0_0)) {
            StatusHandler.log ("version: " + readVersion + " not supported", this);
        }
        else {
            NodeList list = root.getChildNodes ();
            for (int i = 0; i < list.getLength (); i ++) {
                Node child = list.item (i);
                try {
                    if (child.getNodeName ().endsWith (DelegatingTaskExternalizer.KEY_CATEGORY)) {
                        delagatingExternalizer.readCategory (child, taskList);
                    }
                } catch (Exception e) {
                    handleException (inFile, child, e);
                }
            }
            for (int i = 0; i < list.getLength (); i ++) {
                Node child = list.item (i);
                try {
                    if (! child.getNodeName ().endsWith (DelegatingTaskExternalizer.KEY_CATEGORY) && ! child.getNodeName ().endsWith (AbstractTaskListFactory.KEY_QUERY)) {
                        AbstractTask task = delagatingExternalizer.readTask (child, taskList, null, null);
                        if (task == null) {
                            orphanedTaskNodes.add (child);
                        }
                        else {
                            if (child.getChildNodes () != null && child.getChildNodes ().getLength () > 0) {
                                tasksWithSubtasks.put (task, child.getChildNodes ());
                            }
                        }
                    }
                } catch (Exception e) {
                    handleException (inFile, child, e);
                }
            }
            for (AbstractTask task : tasksWithSubtasks.keySet ()) {
                NodeList nodes = tasksWithSubtasks.get (task);
                delagatingExternalizer.readSubTasks (task, nodes, taskList);
            }
            for (int i = 0; i < list.getLength (); i ++) {
                Node child = list.item (i);
                try {
                    if (child.getNodeName ().endsWith (AbstractTaskListFactory.KEY_QUERY)) {
                        readQuery (taskList, child);
                    }
                } catch (Exception e) {
                    handleException (inFile, child, e);
                }
            }
            int largest = taskList.findLargestTaskId ();
            taskList.setLastLocalTaskId (largest);
        }
    } catch (Exception e) {
        handleException (inFile, null, e);
    }
    if (hasCaughtException) {
        writeTaskList (taskList, inFile);
    }
}


-----Function Pair=163=-----==

public boolean hasNextFileEntry (Molecule mol) throws IOException, MoleculeIOException {
    if (isCMLFile) {
        String value = BasicPropertyHolder.instance ().getProperties ().getProperty ("joelib2.io.types.ChemicalMarkupLanguage.useSlowerMemorySavingPreparser");
        if (((value != null) && ! value.equalsIgnoreCase ("true"))) {
            logger.warn ("Only one CML file in a compressed ZIP file can be loaded.");
            logger.warn ("Other CML files are skipped, because SAX parser forces close.");
            logger.warn ("Please activate: joelib2.io.types.ChemicalMarkupLanguage.useSlowerMemorySavingPreparser");
        }
        return false;
    }
    ZipEntry actualZipEntry;
    while ((actualZipEntry = zipInputFileSream.getNextEntry ()) != null) {
        if (actualZipEntry.isDirectory ()) {
            continue;
        }
        else {
            String inputFile = actualZipEntry.getName ();
            BasicIOType inType;
            inType = BasicReader.checkGetInputType (inputFile);
            if (inType.equals (BasicIOTypeHolder.instance ().getIOType ("CML"))) {
                isCMLFile = true;
            }
            logger.info (inputFile + " (" + actualZipEntry.getSize () + " bytes) forces setting input type to " + inType.toString () + ".");
            reader = new BasicReader (zipInputFileSream, inType);
            mol.setInputType (inType);
            return reader.readNext (mol);
        }
    }
    return false;
}


private static void processSchedule () {
    Date date = new Date ();
    for (Holiday holiday : Holiday.getHolidays ()) if (holiday.contains (date)) return;
    int pause = 0;
    try {
        pause = Integer.parseInt (OGSserver.getProperty ("Server.Schedule.Pause", "30"));
    } catch (NumberFormatException err) {
        Galaxy.getLogger ().severe ("Bad value for schedule pause");
    }
    List < String > needArchive = new ArrayList < String > ();
    for (String gameName : getGameNames ()) {
        Schedule sch = Schedule.getSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName));
        if (sch.isTimeToArchive (date)) needArchive.add (gameName);
        else if (sch.isTimeToGenerate (date) && ! sch.isDateInsideStopPeriod (date)) {
            if (sch.isTooLateToGenerate (date, pause)) {
                Galaxy.getLogger ().severe ("Game " + gameName + " generation skipped");
                sch.updateNextScheduleDate (sch.getTurn ());
                Schedule.commitSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName), sch);
            }
            else {
                Galaxy galaxy = Galaxy.load (gameName);
                if (galaxy == null) continue;
                if (galaxy.getState () == Galaxy.State.GAME || galaxy.getState () == Galaxy.State.RECRUITING) {
                    sch.updateNextScheduleDate (galaxy.getTurn () + 2);
                    Schedule.commitSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName), sch);
                    Galaxy.getLogger ().info ("Generate " + galaxy.getName () + " turn " + (galaxy.getTurn () + 1) + " by schedule");
                    generateGame (galaxy);
                }
            }
        }
    }
    for (String gameName : needArchive) {
        Galaxy galaxy = Galaxy.load (gameName);
        if (galaxy == null) continue;
        if (galaxy.getState () != Galaxy.State.FINAL && galaxy.getState () != Galaxy.State.ARCHIVE) {
            Galaxy.getLogger ().severe ("Game " + galaxy.getName () + " : time to archive, but game state != FINAL, break archiving");
            continue;
        }
        if (! archiveGame (galaxy)) break;
    }
}


-----Function Pair=164=-----==

public void rotate (File file, int angel) {
    BufferedImage i = null;
    IIOMetadata imeta = null;
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (file);
        ImageReader reader = ImageIO.getImageReadersByFormatName ("jpg").next ();
        reader.setInput (iis, true);
        ImageReadParam params = reader.getDefaultReadParam ();
        i = reader.read (0, params);
        imeta = reader.getImageMetadata (0);
    } catch (IOException e) {
        System.err.println ("Error while reading File: " + file.getAbsolutePath ());
        e.printStackTrace ();
        return;
    }
    try {
        int w = i.getWidth (null);
        int h = i.getHeight (null);
        rotateImage (i, 90);
        System.out.println ("Width: " + w + " Height :" + h);
        System.out.println ("Drehe Bild:" + file.getAbsolutePath ());
        i = rotateImage (i, angel);
        FileOutputStream fos = new FileOutputStream (file);
        ImageWriter writer = ImageIO.getImageWritersByFormatName ("jpg").next ();
        ImageOutputStream ios = ImageIO.createImageOutputStream (fos);
        writer.setOutput (ios);
        ImageWriteParam iwparam = new JPEGImageWriteParam (Locale.getDefault ());
        iwparam.setCompressionMode (ImageWriteParam.MODE_COPY_FROM_METADATA);
        iwparam.setCompressionQuality (0.92f);
        writer.write (imeta, new IIOImage (i, null, null), iwparam);
        ios.flush ();
        writer.dispose ();
        ios.close ();
        fos.close ();
        System.out.println ("Bild gespeichert!");
    } catch (Exception l) {
        m.error = true;
    }
}


public Builder (Properties properties) {
    this.properties = properties;
    final String [] jnipath = new String [2];
    FilenameFilter filter = new FilenameFilter () {
        public boolean accept (File dir, String name) {
            if (new File (dir, "jni.h").exists ()) {
                jnipath [0] = dir.getAbsolutePath ();
            }
            if (new File (dir, "jni_md.h").exists ()) {
                jnipath [1] = dir.getAbsolutePath ();
            }
            return new File (dir, name).isDirectory ();
        }
    }
    ;
    File javaHome = new File (System.getProperty ("java.home"));
    for (File f : javaHome.getParentFile ().listFiles (filter)) {
        for (File f2 : f.listFiles (filter)) {
            for (File f3 : f2.listFiles (filter)) {
                for (File f4 : f3.listFiles (filter)) {
                }
            }
        }
    }
    if (jnipath [0] != null && jnipath [0].equals (jnipath [1])) {
        jnipath [1] = null;
    }
    else if (jnipath [0] == null) {
        String macpath = "/System/Library/Frameworks/JavaVM.framework/Headers/";
        if (new File (macpath).isDirectory ()) {
            jnipath [0] = macpath;
        }
    }
    Loader.appendProperty (properties, "compiler.includepath", properties.getProperty ("path.separator"), jnipath);
}


-----Function Pair=165=-----==

private void addCell (Element rowElement, Object cellObject) {
    Element cellElement = rowElement.addElement ("c");
    if (cellObject == null) {
        return;
    }
    String text;
    if (cellObject instanceof String) {
        cellElement.addAttribute ("t", "str");
        text = (String) cellObject;
    }
    else if (cellObject instanceof Number) {
        cellElement.addAttribute ("t", "n");
        text = String.valueOf (((Number) cellObject).doubleValue ());
    }
    else if (cellObject instanceof Boolean) {
        cellElement.addAttribute ("t", "b");
        if (((Boolean) cellObject).booleanValue ()) {
            text = "1";
        }
        else {
            text = "0";
        }
    }
    else {
        Double excelDate = OpenXmlUtil.toExcelDate (cellObject);
        if (excelDate != null) {
            cellElement.addAttribute ("t", "n");
            text = excelDate.toString ();
        }
        else {
            log.warn ("Unknown data type found, add as String: " + cellObject.getClass ().getName ());
            cellElement.addAttribute ("t", "str");
            text = cellObject.toString ();
        }
    }
    Element valueElement = cellElement.addElement ("v");
    valueElement.setText (text);
}


public synchronized boolean writeFile (String filename, InputStream stream) throws IOException {
    if (fileSent) return false;
    BufferedInputStream origin = new BufferedInputStream (stream, BUFFER);
    try {
        byte data [] = new byte [BUFFER];
        ZipEntry entry = new ZipEntry (filename);
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        fileWritten = true;
        interrupt ();
        return true;
    } catch (IOException e) {
        LOG.error ("Error writing to zip file '" + zipFile + "'", e);
        interrupt ();
        throw e;
    } finally {
        CloseUtils.safeClose (origin);
    }
}


-----Function Pair=166=-----==

private static String [] getRegisteredScreens (Statement stm, Integer function_id) throws SQLException {
    String [] scrs = new String [0];
    String sql = "select (select s.service_name from sys_service s" + " where s.service_id = f.service_id) service_name from sys_function_service f" + " where f.function_id = " + function_id;
    ResultSet rs = stm.executeQuery (sql);
    if (rs.last ()) {
        int length = rs.getRow ();
        scrs = new String [length];
        rs.first ();
        for (int i = 0; i < length; i ++) {
            scrs [i] = rs.getString ("service_name");
            rs.next ();
        }
    }
    return scrs;
}


public void addAgent (String role, String type, String aname) {
    Agent agent = new Agent ();
    try {
        agent.setROLE (Role.parse (role.toUpperCase ()));
    } catch (MetsException e) {
        agent.setROLE (Role.OTHER);
        agent.setOTHERROLE (role);
    }
    try {
        agent.setTYPE (Type.parse (type.toUpperCase ()));
    } catch (MetsException e) {
        agent.setTYPE (Type.OTHER);
        agent.setOTHERTYPE (type);
    }
    Name name = new Name ();
    name.getContent ().add (new PCData (aname));
    agent.getContent ().add (name);
    for (Object o : manifest.getContent ()) {
        if (o instanceof MetsHdr) {
            ((MetsHdr) o).getContent ().add (agent);
            break;
        }
    }
}


-----Function Pair=167=-----==

public static void zipFilesRecursively (ZipOutputStream out, File zipOutputFile, File [] files, File entryRoot) throws IOException {
    if (entryRoot == null && files == null) throw new IllegalArgumentException ("entryRoot and files must not both be null!");
    if (entryRoot != null && ! entryRoot.isDirectory ()) throw new IllegalArgumentException ("entryRoot is not a directory: " + entryRoot.getAbsolutePath ());
    if (files == null) {
        files = new File [] {entryRoot};
    }
    byte [] buf = new byte [1024 * 5];
    for (int i = 0; i < files.length; i ++) {
        File file = files [i];
        if (zipOutputFile != null) if (file.equals (zipOutputFile)) continue;
        if (file.isDirectory ()) {
            File [] dirFiles = file.listFiles ();
            zipFilesRecursively (out, zipOutputFile, dirFiles, entryRoot);
        }
        else {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (file));
            String relativePath = entryRoot == null ? file.getName () : getRelativePath (entryRoot, file.getAbsoluteFile ());
            ZipEntry entry = new ZipEntry (relativePath);
            entry.setTime (file.lastModified ());
            out.putNextEntry (entry);
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
    }
}


public static ReqResBean getReqResArchive (File zipFile) throws FileNotFoundException, IOException, XMLException {
    ReqResBean encpBean = new ReqResBean ();
    FileInputStream fis = new FileInputStream (zipFile);
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    ZipEntry entry;
    try {
        boolean isReqRead = false;
        boolean isResRead = false;
        while ((entry = zis.getNextEntry ()) != null) {
            int count;
            byte data [] = new byte [BUFF_SIZE];
            File tmpFile = File.createTempFile (entry.getName (), "");
            try {
                FileOutputStream fos = new FileOutputStream (tmpFile);
                BufferedOutputStream dest = new BufferedOutputStream (fos, BUFF_SIZE);
                while ((count = zis.read (data, 0, BUFF_SIZE)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
                if (entry.getName ().equals ("request.rcq")) {
                    Request reqBean = XMLUtil.getRequestFromXMLFile (tmpFile);
                    encpBean.setRequestBean (reqBean);
                    isReqRead = true;
                }
                else if (entry.getName ().equals ("response.rcs")) {
                    Response resBean = XMLUtil.getResponseFromXMLFile (tmpFile);
                    encpBean.setResponseBean (resBean);
                    isResRead = true;
                }
            } finally {
                tmpFile.delete ();
            }
        }
        if ((! isReqRead) || (! isResRead)) {
            throw new IOException ("Archive does not have request.rcq/response.rcs!");
        }
    } finally {
        zis.close ();
    }
    return encpBean;
}


-----Function Pair=168=-----==

public void read (DataInputStream dis) {
    try {
        header = dis.readUTF ();
        int numberRegionScoreTexts = sliceInfo.getNumberRecords ();
        sortedRegionScoreTexts = new RegionScoreText [numberRegionScoreTexts];
        String fileType = sliceInfo.getBinaryType ();
        if (USeqUtilities.REGION_SCORE_TEXT_INT_INT_FLOAT_TEXT.matcher (fileType).matches ()) {
            int start = dis.readInt ();
            sortedRegionScoreTexts [0] = new RegionScoreText (start, start + dis.readInt (), dis.readFloat (), dis.readUTF ());
            for (int i = 1; i < numberRegionScoreTexts; i ++) {
                start = sortedRegionScoreTexts [i - 1].start + dis.readInt ();
                sortedRegionScoreTexts [i] = new RegionScoreText (start, start + dis.readInt (), dis.readFloat (), dis.readUTF ());
            }
        }
        else if (USeqUtilities.REGION_SCORE_TEXT_INT_SHORT_FLOAT_TEXT.matcher (fileType).matches ()) {
            int start = dis.readInt ();
            sortedRegionScoreTexts [0] = new RegionScoreText (start, start + dis.readShort () + 32768, dis.readFloat (), dis.readUTF ());
            for (int i = 1; i < numberRegionScoreTexts; i ++) {
                start = sortedRegionScoreTexts [i - 1].start + dis.readInt ();
                sortedRegionScoreTexts [i] = new RegionScoreText (start, start + dis.readShort () + 32768, dis.readFloat (), dis.readUTF ());
            }
        }
        else if (USeqUtilities.REGION_SCORE_TEXT_SHORT_SHORT_FLOAT_TEXT.matcher (fileType).matches ()) {
            int start = dis.readInt ();
            sortedRegionScoreTexts [0] = new RegionScoreText (start, start + dis.readShort () + 32768, dis.readFloat (), dis.readUTF ());
            for (int i = 1; i < numberRegionScoreTexts; i ++) {
                start = sortedRegionScoreTexts [i - 1].start + dis.readShort () + 32768;
                sortedRegionScoreTexts [i] = new RegionScoreText (start, start + dis.readShort () + 32768, dis.readFloat (), dis.readUTF ());
            }
        }
        else if (USeqUtilities.REGION_SCORE_TEXT_SHORT_INT_FLOAT_TEXT.matcher (fileType).matches ()) {
            int start = dis.readInt ();
            sortedRegionScoreTexts [0] = new RegionScoreText (start, start + dis.readInt (), dis.readFloat (), dis.readUTF ());
            for (int i = 1; i < numberRegionScoreTexts; i ++) {
                start = sortedRegionScoreTexts [i - 1].start + dis.readShort () + 32768;
                sortedRegionScoreTexts [i] = new RegionScoreText (start, start + dis.readInt (), dis.readFloat (), dis.readUTF ());
            }
        }
        else {
            throw new IOException ("Incorrect file type for creating a RegionScoreText[] -> '" + fileType + "' in " + binaryFile + "\n");
        }
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (dis);
    }
}


private byte [] moveTunerUp (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex > 0 && tunerIndex < devList.getDeviceCount ()) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex - 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=169=-----==

protected static void scaleLayout (InputStream in, String name, ZipOutputStream out, double scaleX, double scaleY) throws Exception {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    int i;
    while ((i = in.read ()) != - 1) baos.write (i);
    String str = new String (baos.toByteArray ());
    out.putNextEntry (new ZipEntry (name));
    i = 0;
    int oldI = i;
    String buf = "";
    while ((i = str.indexOf ("x=\"", i)) != - 1) {
        i += 3;
        buf += str.substring (oldI, i);
        int j = str.indexOf ("\"", i);
        double newX = Integer.parseInt (str.substring (i, j));
        System.out.print ("X: " + newX + " -> ");
        newX *= scaleX;
        System.out.println ("" + newX);
        buf += ("" + (int) newX);
        oldI = j;
    }
    buf += str.substring (oldI);
    i = 0;
    oldI = i;
    str = buf;
    buf = "";
    while ((i = str.indexOf ("y=\"", i)) != - 1) {
        i += 3;
        buf += str.substring (oldI, i);
        int j = str.indexOf ("\"", i);
        double newY = Integer.parseInt (str.substring (i, j));
        System.out.print ("Y: " + newY + " -> ");
        newY *= scaleY;
        System.out.println (newY);
        buf += ("" + (int) newY);
        oldI = j;
    }
    buf += str.substring (oldI);
    out.write (buf.getBytes ());
}


protected void createOutput () throws IOException {
    if (eclipseOutputPluginsDir.exists ()) deleteDirectoryRecursively (eclipseOutputPluginsDir);
    for (Plugin plugin : plugins) {
        File eclipseInputPluginsDir = new File (plugin.getEclipseInputDir (), PLUGINS_SUBDIR);
        if (! eclipseOutputPluginsDir.exists ()) eclipseOutputPluginsDir.mkdirs ();
        File pluginInFile = new File (eclipseInputPluginsDir, plugin.getFile ().getName ().replace ('\\', '/'));
        if (pluginInFile.isDirectory ()) {
            File pluginOutFile = new File (eclipseOutputPluginsDir, plugin.getFile ().getName ().replace ('\\', '/') + ARCHIVE_FORMAT);
            System.out.println ("directory \"" + pluginInFile.getAbsolutePath () + "\" => zip into \"" + pluginOutFile.getAbsolutePath () + "\"");
            pluginOutFile.getParentFile ().mkdirs ();
            FileOutputStream fo = new FileOutputStream (pluginOutFile);
            ZipOutputStream zipStream = new ZipOutputStream (fo);
            zipStream.setLevel (9);
            zipDir (zipStream, eclipseInputPluginsDir, plugin.getFile ().getName ().replace ('\\', '/'));
            zipStream.finish ();
            zipStream.close ();
            IncludeEntry ie = includeEntries.get (plugin.getId ());
            if (ie != null) {
                if (ie.isExtractOutput ()) {
                    extract (pluginOutFile, pluginOutFile.getParentFile ());
                }
            }
        }
        else if (pluginInFile.isFile ()) {
            File pluginOutFile = new File (eclipseOutputPluginsDir, plugin.getFile ().getName ().replace ('\\', '/'));
            System.out.println ("file \"" + pluginInFile.getAbsolutePath () + "\" => copy to \"" + pluginOutFile.getAbsolutePath () + "\"");
            FileInputStream in = new FileInputStream (pluginInFile);
            FileOutputStream out = new FileOutputStream (pluginOutFile);
            copy (in, out);
            out.close ();
            in.close ();
            pluginOutFile.setLastModified (pluginInFile.lastModified ());
        }
    }
}


-----Function Pair=170=-----==

public FileCacheableInformations getInformations (File file) {
    File [] f = resolveFiles (file);
    boolean bool = true;
    FileCacheableInformations fi = null;
    long length = - 1;
    for (int i = 0; i < f.length; i ++) {
        fi = predecessor.getInformations (f [i]);
        if (fi.isLengthSet ()) {
            length += fi.getLength ();
        }
    }
    if (fi != null && length != - 1) {
        fi.enforceLength (length);
    }
    return fi;
}


public List < AbstractRepositoryQuery > readQueryDocument (Document doc) {
    List < AbstractRepositoryQuery > queries = new ArrayList < AbstractRepositoryQuery > ();
    Element root = doc.getDocumentElement ();
    readVersion = root.getAttribute (ATTRIBUTE_VERSION);
    if (! readVersion.equals (VALUE_VERSION_1_0_0)) {
        NodeList list = root.getChildNodes ();
        for (int i = 0; i < list.getLength (); i ++) {
            Node child = list.item (i);
            try {
                if (child.getNodeName ().endsWith (AbstractTaskListFactory.KEY_QUERY)) {
                    AbstractRepositoryQuery query = readQuery (null, child);
                    if (query != null) {
                        queries.add (query);
                    }
                }
            } catch (Exception e) {
                StatusHandler.log (e, "Tasks may have been lost from " + child.getNodeName ());
            }
        }
    }
    else {
        StatusHandler.log ("version: " + readVersion + " not supported", this);
    }
    return queries;
}


-----Function Pair=171=-----==

public static DownloadTableModel inputDownTableFile () {
    String dataString = getFileString (SetUp.getRecordFileDirectory (), "downloadList.dat");
    if (! dataString.matches ("\\s*_OVER_\\s*")) {
        String [] rowStrings = dataString.split ("%%%%%%");
        Common.debugPrint ("將讀入下載任務數量: " + (rowStrings.length - 1));
        DownloadTableModel downTableModel = new DownloadTableModel (ComicDownGUI.getDownloadColumns (), rowStrings.length - 1);
        try {
            for (int row = 0; row < rowStrings.length - 1; row ++) {
                String [] colStrings = rowStrings [row].split ("@@@@@@");
                for (int col = 0; col < ComicDownGUI.getDownloadColumns ().size (); col ++) {
                    if (col == DownTableEnum.YES_OR_NO) {
                        downTableModel.setValueAt (Boolean.valueOf (colStrings [col]), row, col);
                    }
                    else if (col == DownTableEnum.ORDER) {
                        downTableModel.setValueAt (new Integer (row + 1), row, col);
                    }
                    else {
                        downTableModel.setValueAt (colStrings [col], row, col);
                    }
                }
                ComicDownGUI.downTableUrlStrings [row] = colStrings [ComicDownGUI.getDownloadColumns ().size ()];
                Common.missionCount ++;
            }
            Common.debugPrintln ("   ... 讀入完畢!!");
        } catch (Exception ex) {
            Common.debugPrintln ("   ... 讀入失敗!!");
            cleanDownTable ();
            new File ("downloadList.dat").delete ();
        }
        return downTableModel;
    }
    else {
        return new DownloadTableModel (ComicDownGUI.getDownloadColumns (), 0);
    }
}


private void dirCommandProcessor (String in_dir, String out_dir) {
    String list [] = new File (in_dir).list ();
    new File (out_dir).mkdirs ();
    for (int i = 0; i < list.length; i ++) {
        String in = new String (in_dir + "/" + list [i]);
        String out = new String (out_dir + "/" + list [i]);
        if (new File (in).isDirectory ()) {
            dirCommandProcessor (in, out);
        }
        else if (in.endsWith (".class")) {
            addElement (new ClassFileEntry (in, out));
        }
        else if (in.endsWith (".jar")) {
            addElement (new JarFileEntry (in, out));
        }
    }
}


-----Function Pair=172=-----==

private XMLContent cloneDocument (XMLContent officeDoc, Element dataRootElement) {
    XMLContent officeText = officeDoc.findContentCalled (OFFICE_TEXT);
    int numberOfRecords = XMLUtil.getChildren (dataRootElement).size ();
    int nextRecordCount = officeText.count (NEXT_RECORD_FIELD);
    int loopCount = numberOfRecords - 1;
    if (nextRecordCount > 0) loopCount = numberOfRecords / nextRecordCount;
    List < XMLContent > cloned = new ArrayList < XMLContent > ();
    for (int i = 0; i < loopCount; i ++) {
        XMLContent pageBreak = new XMLContent ();
        pageBreak.setHeader (MAIL_MERGE_PAGE);
        XMLContent officeDocContent = officeText.clone ();
        int start = 1;
        int end = officeDocContent.getSubContents ().size ();
        XMLContent ignoreTo = officeDocContent.findContentCalled (IGNORE_TO);
        if (ignoreTo != null) start = officeDocContent.getIndexOf (ignoreTo) + 1;
        cloned.add (pageBreak);
        cloned.addAll (officeDocContent.getSubContents ().subList (start, end));
    }
    officeText.addSubContent (cloned);
    return officeText;
}


private TriangleMesh getRenderable (File surface_file, JxSegmentation segmentation, JxView view) throws FileNotFoundException, IOException {
    LineNumberReader surface_reader = new LineNumberReader (new FileReader (surface_file));
    String [] tokens;
    ArrayList < Triplet [] > vertices = new ArrayList < Triplet [] > ();
    ArrayList < int [] > indices = new ArrayList < int [] > ();
    String s;
    JxOrientation orientation = super.getOrientation (view);
    while ((s = surface_reader.readLine ()) != null) {
        tokens = s.trim ().split (" +");
        if (tokens [0].equals ("V")) {
            int n_vertices = Integer.parseInt (tokens [1]);
            double z = Double.parseDouble (tokens [3]);
            for (int v = 0; v < n_vertices; v ++) {
                tokens = surface_reader.readLine ().trim ().split (" +");
                Triplet vertex = orientation.transform (Double.parseDouble (tokens [0]), Double.parseDouble (tokens [1]), z);
                Triplet normal = view.rotate (Double.parseDouble (tokens [2]), Double.parseDouble (tokens [3]), Double.parseDouble (tokens [4]));
                vertices.add (new Triplet [] {vertex, normal});
            }
        }
        else if (tokens [0].equals ("T")) {
            int triangles = Integer.parseInt (tokens [1]);
            for (int t = 0; t < triangles; t ++) {
                tokens = surface_reader.readLine ().trim ().split (" +");
                indices.add (new int [] {Integer.parseInt (tokens [0]), Integer.parseInt (tokens [1]), Integer.parseInt (tokens [2])});
            }
        }
    }
    return new TriangleMesh (vertices, indices);
}


-----Function Pair=173=-----==

private void saveBMT (Element btmn) {
    try {
        String uniqueID;
        String dictionaryEntryName;
        String definition;
        String objectClassTermQualifier;
        String objectClassTerm;
        ArrayList ABIES = new ArrayList ();
        String businessProcessContextValue;
        String productContextValue;
        String industryContextValue;
        String geopoliticalContextValue;
        String officialConstraintsContextValue;
        String businessProcessRoleContextValue;
        String supportingRoleContextValue;
        String systemCapabilitiesContextValue;
        NodeList nl;
        uniqueID = btmn.getElementsByTagName (TAG_UNIQUE_ID).item (0).getTextContent ();
        dictionaryEntryName = btmn.getElementsByTagName (TAG_DEN).item (0).getTextContent ();
        definition = btmn.getElementsByTagName (TAG_DEFINITION).item (0).getTextContent ();
        objectClassTermQualifier = btmn.getElementsByTagName (TAG_OBJECT_CLASS_TERM_QUALIFIER).item (0).getTextContent ();
        objectClassTerm = btmn.getElementsByTagName (TAG_OBJECT_CLASS_TERM).item (0).getTextContent ();
        nl = ((Element) (btmn.getElementsByTagName ("ABIES").item (0))).getElementsByTagName ("ABIE");
        for (int i = 0; i < nl.getLength (); i ++) {
            ABIES.add (nl.item (i).getTextContent ());
        }
        businessProcessContextValue = btmn.getElementsByTagName (TAG_BUSINESS_PROCESS).item (0).getTextContent ();
        productContextValue = btmn.getElementsByTagName (TAG_PRODUCT).item (0).getTextContent ();
        industryContextValue = btmn.getElementsByTagName (TAG_INDUSTRY).item (0).getTextContent ();
        geopoliticalContextValue = btmn.getElementsByTagName (TAG_GEOPOLITICAL).item (0).getTextContent ();
        officialConstraintsContextValue = btmn.getElementsByTagName (TAG_OFFICIAL_CONSTRAINTS).item (0).getTextContent ();
        businessProcessRoleContextValue = btmn.getElementsByTagName (TAG_BUSINESS_PROCESS_ROLE).item (0).getTextContent ();
        supportingRoleContextValue = btmn.getElementsByTagName (TAG_SUPPORTING_ROLE).item (0).getTextContent ();
        systemCapabilitiesContextValue = btmn.getElementsByTagName (TAG_SYSTEM_CAPABILITIES).item (0).getTextContent ();
        ExtrinsicObject eo = generateExtrinsicObject (dictionaryEntryName, definition, uniqueID);
        for (int i = 0; i < ABIES.size (); i ++) {
            eo.addAssociation (generateAssociation (eo, "Contains", getEObyName ((String) ABIES.get (i))));
        }
        eo.addSlot (generateSlot (SLOT_ENTRY_TYPE, "BMT"));
        eo.addSlot (generateSlot (SLOT_OBJECT_CLASS_TERM_QUALIFIER, objectClassTermQualifier));
        eo.addSlot (generateSlot (SLOT_OBJECT_CLASS_TERM, objectClassTerm));
        eo.addSlot (generateSlot (SLOT_BUSINESS_PROCESS, businessProcessContextValue));
        eo.addSlot (generateSlot (SLOT_BUSINESS_PROCESS_ROLE, businessProcessRoleContextValue));
        eo.addSlot (generateSlot (SLOT_GEOPOLITICAL, geopoliticalContextValue));
        eo.addSlot (generateSlot (SLOT_INDUSTRY, industryContextValue));
        eo.addSlot (generateSlot (SLOT_OFFICIAL_CONSTRAINTS, officialConstraintsContextValue));
        eo.addSlot (generateSlot (SLOT_PRODUCT, productContextValue));
        eo.addSlot (generateSlot (SLOT_SUPPORTING_ROLE, supportingRoleContextValue));
        eo.addSlot (generateSlot (SLOT_SYSTEM_CAPABILITIES, systemCapabilitiesContextValue));
        ((ExtrinsicObjectImpl) eo).setLid (uniqueID);
        String fileString = xmlString;
        String fileName = dictionaryEntryName.concat (".xml");
        File file = new File (fileName);
        try {
            (new DataOutputStream (new FileOutputStream (file))).writeBytes (fileString);
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        addRepositoryItem (eo, fileName);
        addExtrinsicObject (eo);
    } catch (JAXRException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


private byte [] showAvailableThemes (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer out = new StringBuffer ();
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "ShowThemes.html");
    String httpDir = store.getProperty ("path.httproot");
    String themeDir = store.getProperty ("path.theme");
    File themeDirs = new File (httpDir + File.separator + "themes");
    int count = 0;
    if (themeDirs.exists ()) {
        File [] dirs = themeDirs.listFiles ();
        for (int x = 0; x < dirs.length; x ++) {
            if (dirs [x].isDirectory () && dirs [x].isHidden () == false) {
                count ++;
                out.append ("<option value=\"" + dirs [x].getName () + "\"");
                if (dirs [x].getName ().equalsIgnoreCase (themeDir)) out.append (" SELECTED ");
                out.append (">" + dirs [x].getName () + "</option>\n");
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$themeList", out.toString ());
    String currentEPGTheme = store.getProperty ("path.theme.epg");
    out = new StringBuffer ();
    String xslDir = store.getProperty ("path.xsl");
    count = 0;
    File xslDirs = new File (xslDir);
    if (xslDirs.exists ()) {
        File [] xslFiles = xslDirs.listFiles ();
        for (int x = 0; x < xslFiles.length; x ++) {
            if (xslFiles [x].isDirectory () == false) {
                if (xslFiles [x].getName ().matches ("epg-.*.xsl")) {
                    count ++;
                    out.append ("<option value=\"" + xslFiles [x].getName () + "\"");
                    if (xslFiles [x].getName ().equalsIgnoreCase (currentEPGTheme)) out.append (" SELECTED ");
                    String name = xslFiles [x].getName ().substring (4, xslFiles [x].getName ().length () - 4);
                    out.append (">" + name + "</option>\n");
                }
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$epg_themeList", out.toString ());
    out = new StringBuffer ();
    String [] agentList = store.getAgentMappingList ();
    for (int x = 0; x < agentList.length; x ++) {
        String themeForAgent = store.getThemeForAgent (agentList [x]);
        out.append ("<tr>");
        out.append ("<td>" + agentList [x] + "</td>");
        out.append ("<td>" + themeForAgent + "</td>");
        out.append ("<td><a href='/servlet/SystemDataRes?action=37&agent=" + URLEncoder.encode (agentList [x], "UTF-8") + "'><img src='/images/delete.png' alt='Delete Mapping' align='absmiddle' border='0' height='24' width='24'></a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$themeMappings", out.toString ());
    template.replaceAll ("$agentString", headers.get ("User-Agent"));
    return template.getPageBytes ();
}


-----Function Pair=174=-----==

public static boolean deleteFiles (File directory, String extension) {
    boolean deleted = true;
    if (directory.isDirectory ()) {
        String [] files = directory.list ();
        int num = files.length;
        try {
            String path = directory.getCanonicalPath ();
            for (int i = 0; i < num; i ++) {
                if (files [i].endsWith (extension)) {
                    deleted = new File (path, files [i]).delete ();
                    if (deleted == false) return false;
                }
            }
        } catch (IOException e) {
            System.out.println ("Prob deleteFiles, dir ->" + directory + " " + extension);
            e.printStackTrace ();
        }
    }
    else deleted = false;
    return deleted;
}


private void unzipAssembly (File tempDir, File assembly) throws IOException {
    ZipInputStream zis = null;
    String tempDirPath = tempDir.getAbsolutePath ();
    byte [] buf = new byte [4096];
    try {
        zis = new ZipInputStream (new FileInputStream (assembly));
        ZipEntry ze = null;
        while ((ze = zis.getNextEntry ()) != null) {
            if (ze.isDirectory ()) {
                this.processDirectory (tempDirPath, ze);
            }
            else {
                this.processFile (tempDirPath, ze, new ZipInputStreamWrapper (zis), buf);
            }
        }
    } finally {
        if (zis != null) {
            zis.close ();
        }
    }
}


-----Function Pair=175=-----==

public void write (Resource resource, OutputStream stream) throws ExportException {
    if (resource == null) {
        throw new IllegalArgumentException ("Can't export 'null' resource.");
    }
    if (stream == null) {
        throw new IllegalArgumentException ("Can't export to 'null' stream.");
    }
    ZipOutputStream zip = new ZipOutputStream (stream);
    try {
        ZipEntry mimeType = new ZipEntry (MIME_TYPE_NAME);
        mimeType.setMethod (ZipEntry.STORED);
        zip.putNextEntry (mimeType);
        zip.write (MIME_TYPE_VALUE.getBytes (charset));
        zip.closeEntry ();
        ZipEntry container = new ZipEntry (CONTAINER_NAME);
        zip.putNextEntry (container);
        writeContainer (resource, zip);
        zip.closeEntry ();
        ZipEntry packageInfo = new ZipEntry (PACKAGE_INFO_NAME);
        zip.putNextEntry (packageInfo);
        writePackageInfo (resource, zip);
        zip.closeEntry ();
        zip.finish ();
    } catch (IOException io) {
        throw new ExportException (io);
    } catch (TransformerException t) {
        throw new ExportException (t);
    } catch (FormatException f) {
        throw new ExportException (f);
    }
}


private byte [] setEpgTask (HTTPurl urlData) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String taskDef = urlData.getParameter ("Tasks.DefTask");
    if (taskDef == null || "none".equals (taskDef)) taskDef = "";
    store.setServerProperty ("Tasks.DefTask", taskDef);
    String taskPre = urlData.getParameter ("Tasks.PreTask");
    if (taskPre == null || "none".equals (taskPre)) taskPre = "";
    store.setServerProperty ("Tasks.PreTask", taskPre);
    String taskStartError = urlData.getParameter ("Tasks.StartErrorTask");
    if (taskStartError == null || "none".equals (taskStartError)) taskStartError = "";
    store.setServerProperty ("Tasks.StartErrorTask", taskStartError);
    String taskNoDataError = urlData.getParameter ("Tasks.NoDataErrorTask");
    if (taskNoDataError == null || "none".equals (taskNoDataError)) taskNoDataError = "";
    store.setServerProperty ("Tasks.NoDataErrorTask", taskNoDataError);
    return out.getBytes ();
}


-----Function Pair=176=-----==

public static String replaceSubstring (String str, String regex, String replacement) {
    int found = 0;
    int start = 0;
    int len = regex.length ();
    if (str == "") return "";
    while ((found = str.indexOf (regex, found)) != - 1) {
        if (found + len >= str.length ()) {
            return str.substring (0, found) + replacement;
        }
        else {
            str = str.substring (0, found) + replacement + str.substring (found + len);
        }
        found += len;
    }
    return str;
}


public static UserZipFile makeNewUser (String name, int flags) throws Exception {
    MakeUserZipFileTool make = new MakeUserZipFileTool ();
    File temp = TempFileUtil.createTemporaryFile ();
    try {
        make.setName (name);
        make.setPassphrase ("");
        make.setValidDays (2);
        make.setSaveFile (temp);
        UserZipFile user = make.makeCertificate ();
        user.setFlags (flags);
        return user;
    } finally {
        IOUtil.safeDelete (temp);
    }
}


-----Function Pair=177=-----==

public void writeTaskList (TaskList taskList, File outFile) {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db;
    Document doc = null;
    try {
        db = dbf.newDocumentBuilder ();
        doc = db.newDocument ();
    } catch (ParserConfigurationException e) {
        StatusHandler.log (e, "could not create document");
        return;
    }
    Element root = doc.createElement (ELEMENT_TASK_LIST);
    root.setAttribute (ATTRIBUTE_VERSION, VALUE_VERSION);
    for (AbstractTaskContainer category : taskList.getCategories ()) {
        delagatingExternalizer.createCategoryElement (category, doc, root);
    }
    for (AbstractRepositoryQuery query : taskList.getQueries ()) {
        try {
            delagatingExternalizer.createQueryElement (query, doc, root);
        } catch (Throwable t) {
            StatusHandler.fail (t, "Did not externalize: " + query.getSummary (), true);
        }
    }
    for (AbstractTask task : taskList.getAllTasks ()) {
        delagatingExternalizer.createTaskElement (task, doc, root);
    }
    for (Node orphanedTaskNode : orphanedTaskNodes) {
        Node tempNode = doc.importNode (orphanedTaskNode, true);
        if (tempNode != null) {
            root.appendChild (tempNode);
        }
    }
    for (Node orphanedQueryNode : orphanedQueryNodes) {
        Node tempNode = doc.importNode (orphanedQueryNode, true);
        if (tempNode != null) {
            root.appendChild (tempNode);
        }
    }
    doc.appendChild (root);
    writeDOMtoFile (doc, outFile);
    return;
}


public static void writeFeatureDigest (PrintWriter digest, FeatureModel featureModel, Properties featureProperties) {
    String label = null;
    String provider = null;
    String description = null;
    String license = null;
    String copyright = null;
    if ((featureProperties != null) && featureModel.getLabel ().startsWith ("%")) {
        label = featureProperties.getProperty (featureModel.getLabel ().substring (1));
    }
    else {
        label = featureModel.getLabel ();
    }
    if ((featureProperties != null) && (featureModel.getDescriptionModel () != null) && featureModel.getDescriptionModel ().getAnnotation ().startsWith ("%")) {
        description = featureProperties.getProperty (featureModel.getDescriptionModel ().getAnnotation ().substring (1));
    }
    else {
        URLEntryModel descriptionModel = featureModel.getDescriptionModel ();
        if (descriptionModel == null) description = "";
        else description = descriptionModel.getAnnotation ();
    }
    String pvalue = featureModel.getProvider ();
    if ((featureProperties != null) && pvalue != null && pvalue.startsWith ("%")) {
        provider = featureProperties.getProperty (featureModel.getProvider ().substring (1));
    }
    else {
        provider = pvalue;
    }
    if (provider == null) provider = "";
    if (((featureProperties != null) && featureModel.getCopyrightModel () != null) && featureModel.getCopyrightModel ().getAnnotation ().startsWith ("%")) {
        copyright = featureProperties.getProperty (featureModel.getCopyrightModel ().getAnnotation ().substring (1));
    }
    else {
        if (featureModel.getCopyrightModel () != null) {
            copyright = featureModel.getCopyrightModel ().getAnnotation ();
        }
        else {
            copyright = null;
        }
    }
    if ((featureProperties != null) && (featureModel.getLicenseModel () != null) && featureModel.getLicenseModel ().getAnnotation ().startsWith ("%")) {
        license = featureProperties.getProperty (featureModel.getLicenseModel ().getAnnotation ().substring (1));
    }
    else {
        license = featureModel.getLicenseModel ().getAnnotation ();
    }
    digest.print ("<feature ");
    digest.print ("label=\"" + getUTF8String (label) + "\" ");
    digest.print ("provider-name=\"" + provider + "\" ");
    digest.print ("id=\"" + featureModel.getFeatureIdentifier () + "\" ");
    digest.print ("version=\"" + featureModel.getFeatureVersion () + "\" ");
    if (featureModel.getOS () != null) digest.print ("os=\"" + featureModel.getOS () + "\" ");
    if (featureModel.getNL () != null) digest.print ("nl=\"" + featureModel.getNL () + "\" ");
    if (featureModel.getWS () != null) digest.print ("ws=\"" + featureModel.getWS () + "\" ");
    if (featureModel.getOSArch () != null) digest.print ("arch=\"" + featureModel.getOSArch () + "\" ");
    if (featureModel.isExclusive ()) digest.print ("exclusive=\"" + featureModel.isExclusive () + "\" ");
    if (((featureModel.getImportModels () == null) || (featureModel.getImportModels ().length == 0)) && ((featureModel.getDescriptionModel () == null) || (featureModel.getDescriptionModel ().getAnnotation () == null) || (featureModel.getDescriptionModel ().getAnnotation ().trim ().length () == 0)) && ((featureModel.getCopyrightModel () == null) || (featureModel.getCopyrightModel ().getAnnotation () == null) || (featureModel.getCopyrightModel ().getAnnotation ().trim ().length () == 0)) && ((featureModel.getLicenseModel () == null) || (featureModel.getLicenseModel ().getAnnotation () == null) || (featureModel.getLicenseModel ().getAnnotation ().trim ().length () == 0)) && ((featureModel.getFeatureIncluded () == null) || (featureModel.getFeatureIncluded ().length == 0))) {
        digest.println ("/> ");
    }
    else {
        digest.println ("> ");
        if (featureModel.getImportModels ().length > 0) {
            digest.println ("\t<requires> ");
            ImportModel [] imports = featureModel.getImportModels ();
            for (int j = 0; j < imports.length; j ++) {
                digest.print ("\t\t<import ");
                if (imports [j].isFeatureImport ()) {
                    digest.print ("feature=\"");
                }
                else {
                    digest.print ("plugin=\"");
                }
                digest.print (imports [j].getIdentifier () + "\" ");
                digest.print ("version=\"");
                digest.print (imports [j].getVersion () + "\" ");
                digest.print ("match=\"");
                digest.print (imports [j].getMatchingRuleName () + "\" ");
                if (imports [j].isPatch ()) {
                    digest.print ("patch=\"true\" ");
                }
                digest.println (" />");
            }
            digest.println ("\t</requires>");
        }
        if ((featureModel.getDescriptionModel () != null) && (featureModel.getDescriptionModel ().getAnnotation () != null) && (featureModel.getDescriptionModel ().getAnnotation ().trim ().length () != 0)) {
            digest.println ("\t<description>");
            digest.println ("\t\t" + UpdateManagerUtils.getWritableXMLString (description));
            digest.println ("\t</description>");
        }
        if (featureModel.getCopyrightModel () != null) {
            if (featureModel.getCopyrightModel ().getAnnotation () != null) {
                digest.println ("\t<copyright>");
                digest.println ("\t\t" + UpdateManagerUtils.getWritableXMLString (copyright));
                digest.println ("\t</copyright>");
            }
        }
        if ((featureModel.getLicenseModel () != null) && (featureModel.getLicenseModel ().getAnnotation () != null) && (featureModel.getLicenseModel ().getAnnotation ().trim ().length () != 0)) {
            digest.println ("\t<license>");
            digest.println ("\t\t" + UpdateManagerUtils.getWritableXMLString (license));
            digest.println ("\t</license>");
        }
        PluginEntryModel [] plugins = featureModel.getPluginEntryModels ();
        if ((plugins != null) && (plugins.length != 0)) {
            for (int i = 0; i < plugins.length; i ++) {
                digest.print ("\t<plugin ");
                digest.print ("id=\"" + plugins [i].getPluginIdentifier () + "\" ");
                digest.print ("version=\"" + plugins [i].getPluginVersion () + "\" ");
                if (plugins [i].getOS () != null) digest.print ("os=\"" + plugins [i].getOS () + "\" ");
                if (plugins [i].getNL () != null) digest.print ("nl=\"" + plugins [i].getNL () + "\" ");
                if (plugins [i].getWS () != null) digest.print ("ws=\"" + plugins [i].getWS () + "\" ");
                if (plugins [i].getOSArch () != null) digest.print ("arch=\"" + plugins [i].getOSArch () + "\" ");
                if (plugins [i].getDownloadSize () > 0) digest.print ("download-size=\"" + plugins [i].getDownloadSize () + "\" ");
                if (plugins [i].getInstallSize () > 0) digest.print ("install-size=\"" + plugins [i].getInstallSize () + "\" ");
                if (! plugins [i].isUnpack ()) digest.print ("unpack=\"" + plugins [i].isUnpack () + "\" ");
                digest.println ("/> ");
            }
        }
        IIncludedFeatureReference [] includedFeatures = featureModel.getFeatureIncluded ();
        if ((includedFeatures != null) && (includedFeatures.length != 0)) {
            for (int i = 0; i < includedFeatures.length; i ++) {
                try {
                    digest.print ("\t<includes ");
                    digest.print ("id=\"" + includedFeatures [i].getVersionedIdentifier ().getIdentifier () + "\" ");
                    digest.print ("version=\"" + includedFeatures [i].getVersionedIdentifier ().getVersion () + "\" ");
                    if (includedFeatures [i].getOS () != null) digest.print ("os=\"" + includedFeatures [i].getOS () + "\" ");
                    if (includedFeatures [i].getNL () != null) digest.print ("nl=\"" + includedFeatures [i].getNL () + "\" ");
                    if (includedFeatures [i].getWS () != null) digest.print ("ws=\"" + includedFeatures [i].getWS () + "\" ");
                    if (includedFeatures [i].getOSArch () != null) digest.print ("arch=\"" + includedFeatures [i].getOSArch () + "\" ");
                    if ((includedFeatures [i] instanceof IncludedFeatureReference) && (((IncludedFeatureReference) includedFeatures [i]).getLabel () != null)) digest.print ("name=\"" + includedFeatures [i].getName () + "\" ");
                    if (includedFeatures [i].isOptional ()) digest.print ("optional=\"true\" ");
                    digest.print ("search-location=\"" + includedFeatures [i].getSearchLocation () + "\" ");
                    digest.println ("/> ");
                } catch (CoreException e) {
                    e.printStackTrace ();
                }
            }
        }
        digest.println ("</feature>");
    }
}


-----Function Pair=178=-----==

private void zip (File destinationZipFile, String basePath, File [] files) throws IOException {
    FileOutputStream dest = null;
    ZipOutputStream out = null;
    try {
        totalSpace = getTotalSpace (files);
        finishSpace = 0;
        dest = new FileOutputStream (destinationZipFile);
        out = new ZipOutputStream (new BufferedOutputStream (dest));
        for (int i = 0; i < files.length; i ++) {
            if (files [i].isDirectory ()) {
                addFolder (out, basePath, files [i]);
            }
            else {
                addFile (out, basePath, files [i]);
            }
        }
    } finally {
        if (out != null) {
            out.close ();
        }
        if (dest != null) {
            dest.close ();
        }
    }
}


private void importAsOrganization (GroupwareUser groupwareUser, Community importedCommunity, ImportCommunityResult importCommunityResult) throws SystemException, PortalException {
    String type = importCommunityResult.getCommunityType ();
    boolean isOrganizationTypeRootable = getLiferayHelper ().getIsOrganizationTypeRootable (type);
    log.info ("Creating organization for imported community");
    Organization createdOrganizationFromCommunityData;
    if (! isOrganizationTypeRootable) {
        createdOrganizationFromCommunityData = createSubOrganization (groupwareUser, importedCommunity, importCommunityResult);
    }
    else createdOrganizationFromCommunityData = getLiferayHelper ().createOrganizationFromCommunityData (importedCommunity, groupwareUser, importCommunityResult.getWebName (), importedCommunity.getType ());
    setCustomAttributes (importedCommunity, importCommunityResult, createdOrganizationFromCommunityData);
    String groupId = String.valueOf (createdOrganizationFromCommunityData.getGroup ().getGroupId ());
    String name = createdOrganizationFromCommunityData.getName ();
    String description = createdOrganizationFromCommunityData.getComments ();
    log.info ("Assigning imported community to organization with groupId " + groupId);
    updateCommunityAndWeb (groupId, importedCommunity, name, description, Boolean.TRUE);
}


-----Function Pair=179=-----==

private static void zipFolder (File folder, ZipOutputStream zipOutputStream, String relativePath) throws IOException {
    File [] children = folder.listFiles ();
    for (int i = 0; i < children.length; i ++) {
        File child = children [i];
        if (child.isFile ()) {
            String zipEntryName = children [i].getCanonicalPath ().replace (relativePath + File.separator, "");
            ZipEntry entry = new ZipEntry (zipEntryName);
            zipOutputStream.putNextEntry (entry);
            InputStream inputStream = new FileInputStream (child);
            IOUtils.copy (inputStream, zipOutputStream);
            inputStream.close ();
        }
        else {
            ZipUtil.zipFolder (child, zipOutputStream, relativePath);
        }
    }
}


private File getFilenameFromUser (JFileChooser fileChooser, String fileSuffix) {
    if (fileSuffix.indexOf ('.') == - 1) {
        fileSuffix = "." + fileSuffix;
    }
    File aFile = null;
    int userChoice = 0;
    String aFileName = null;
    outer : do {
        aFileName = null;
        userChoice = fileChooser.showSaveDialog (this);
        if (userChoice == JFileChooser.CANCEL_OPTION) {
            break;
        }
        File selectedFile = fileChooser.getSelectedFile ();
        aFileName = selectedFile.getAbsolutePath ();
        if (userChoice == JFileChooser.APPROVE_OPTION) {
            boolean notUniquelyNamed = true;
            while (notUniquelyNamed) {
                if (aFileName.indexOf ('.') == - 1) {
                    aFileName = aFileName + "." + this.phylipFileSuffix;
                }
                aFile = new File (aFileName);
                if (aFile.exists ()) {
                    int returnVal = JOptionPane.showOptionDialog (this, "This file already exists.  " + "Do you wish to overwrite it?", "Overwrite File Confirmation", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE, null, null, null);
                    if (returnVal == JOptionPane.CANCEL_OPTION) {
                        return null;
                    }
                    if (returnVal == JOptionPane.NO_OPTION) {
                        aFileName = null;
                        continue outer;
                    }
                    if (returnVal == JOptionPane.YES_OPTION) {
                        notUniquelyNamed = false;
                    }
                }
                else {
                    notUniquelyNamed = false;
                }
            }
        }
    }
    while (aFileName == null);
    return aFile;
}


-----Function Pair=180=-----==

public static LinkedHashMap loadKeyValueFile (File file) {
    LinkedHashMap map = new LinkedHashMap ();
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line;
        Pattern comment = Pattern.compile ("^[/|#].*");
        Pattern whiteSpace = Pattern.compile ("\\s+");
        Pattern equal = Pattern.compile ("=");
        while ((line = in.readLine ()) != null) {
            line = line.trim ();
            if (line.length () == 0 || comment.matcher (line).matches ()) continue;
            line = whiteSpace.matcher (line).replaceAll ("");
            String [] keyValue = equal.split (line);
            if (keyValue.length != 2) continue;
            map.put (keyValue [0], keyValue [1]);
        }
    } catch (Exception e) {
        System.out.println ("Prob with loadKeyValueFile()");
        e.printStackTrace ();
    }
    return map;
}


public static File [] extractFiles (File dirOrFile, String extension) {
    if (dirOrFile == null) return null;
    File [] files = null;
    Pattern p = Pattern.compile (".*" + extension + "$", Pattern.CASE_INSENSITIVE);
    Matcher m;
    if (dirOrFile.isDirectory ()) {
        files = dirOrFile.listFiles ();
        int num = files.length;
        ArrayList < File > chromFiles = new ArrayList < File > ();
        for (int i = 0; i < num; i ++) {
            m = p.matcher (files [i].getName ());
            if (m.matches ()) chromFiles.add (files [i]);
        }
        files = new File [chromFiles.size ()];
        chromFiles.toArray (files);
    }
    else {
        m = p.matcher (dirOrFile.getName ());
        if (m.matches ()) {
            files = new File [1];
            files [0] = dirOrFile;
        }
    }
    if (files != null) Arrays.sort (files);
    return files;
}


-----Function Pair=181=-----==

public static int [] [] loadTableOfInts (File file) {
    int [] [] columnsRows = null;
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line = in.readLine ();
        if (line == null) return null;
        String [] tokens = line.split ("\\t");
        int numColumns = tokens.length;
        int numRows = (int) IO.countNumberOfLines (file);
        columnsRows = new int [numColumns] [numRows];
        int y = 0;
        for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        y ++;
        for (; y < numRows; y ++) {
            line = in.readLine ();
            tokens = line.split ("\\t");
            for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        }
        in.close ();
    } catch (Exception e) {
        System.out.println ("Problem loading table");
        e.printStackTrace ();
    }
    return columnsRows;
}


private void update (double loaded, String text) {
    Graphics g2 = getGraphics ();
    String s = text;
    if (backbuffer == null || backbuffer.getWidth (null) != getSize ().width || backbuffer.getHeight (null) != getSize ().height) backbuffer = createImage (getSize ().width, getSize ().height);
    if (backbuffer == null) return;
    Graphics g = backbuffer.getGraphics ();
    g.setColor (loaded < 0 ? Color.red : Color.blue);
    loaded = Math.abs (loaded);
    int w = (int) ((double) getSize ().width * loaded);
    g.fillRect (0, 0, w, getSize ().height);
    g.setColor (Color.darkGray);
    g.fillRect (w, 0, getSize ().width - w, getSize ().height);
    Font f = new Font ("Sans-serif", Font.BOLD, 12);
    FontRenderContext frc = new FontRenderContext (null, true, true);
    LineMetrics lm = f.getLineMetrics (s, frc);
    g.setFont (f);
    int x = (int) ((getSize ().width - f.getStringBounds (s, frc).getWidth ()) / 2);
    int y = (int) (((getSize ().height - lm.getAscent () - lm.getDescent ()) / 2) + lm.getAscent ());
    g.setColor (Color.white);
    g.drawString (s, x, y);
    if (g2 != null) {
        g2.setClip (0, 0, getSize ().width, getSize ().height);
        g2.drawImage (backbuffer, 0, 0, null);
    }
}


-----Function Pair=182=-----==

public byte [] zip (byte [] content, String fileName) {
    if (content == null) {
        throw new RuntimeException ("contentO Not Set");
    }
    try {
        File tempFile = new File (FilenameUtils.concat (tempDir.getAbsolutePath (), fileName));
        logger.debug ("tempFile: " + tempFile);
        FileUtils.writeByteArrayToFile (tempFile, content);
        if (! tempFile.exists ()) {
            throw new RuntimeException ("No errors and no file after FileUtils.writeByteArrayToFile");
        }
        String compressedFilePath = zip (tempFile.getAbsolutePath ());
        logger.debug ("compressedFilePath: " + compressedFilePath);
        return FileUtils.readFileToByteArray (new File (compressedFilePath));
    } catch (IOException ioe) {
        logger.error (UNHANDLED_EXCEPTION + ioe.getMessage ());
        ioe.printStackTrace ();
        throw new RuntimeException ("Error while zipping file", ioe);
    }
}


protected void subAppend (LoggingEvent event) {
    long n = System.currentTimeMillis ();
    if (fileName != null && qw != null) {
        long size = ((CountingQuietWriter) qw).getCount ();
        if (size >= maxFileSize && size >= nextRollover) {
            try {
                rollOver (ROLL);
            } catch (IOException ioe) {
                if (ioe instanceof InterruptedIOException) {
                    Thread.currentThread ().interrupt ();
                }
                LogLog.error ("rollOver() failed.", ioe);
            }
        }
    }
    if (n >= nextCheck) {
        now.setTime (n);
        nextCheck = rc.getNextCheckMillis (now);
        try {
            rollOver (DAILY);
        } catch (IOException ioe) {
            if (ioe instanceof InterruptedIOException) {
                Thread.currentThread ().interrupt ();
            }
            LogLog.error ("rollOver() failed.", ioe);
        }
    }
    super.subAppend (event);
}


-----Function Pair=183=-----==

public void unCompressOnlyFile (String fileZip, String fileFrom, String fileTo) {
    Enumeration entries;
    ZipFile zipFile;
    if (! new File (fileZip).exists ()) {
        System.err.println ("File not exits: " + fileZip);
        return;
    }
    try {
        zipFile = new ZipFile (fileZip);
        entries = zipFile.entries ();
        String fileDest;
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            if (entry.getName ().length () >= fileFrom.length ()) {
                if (entry.getName ().substring (0, fileFrom.length ()).equals (fileFrom)) {
                    if (entry.getName ().length () == fileFrom.length ()) fileDest = fileTo;
                    else {
                        File fileToReal = new File (fileTo);
                        if (! fileToReal.isDirectory ()) continue;
                        fileDest = fileTo + "/" + entry.getName ().substring (fileFrom.length () + 1);
                    }
                    if (entry.isDirectory ()) {
                        (new File (fileDest)).mkdirs ();
                    }
                    else {
                        copyInputStream (zipFile.getInputStream (entry), new BufferedOutputStream (new FileOutputStream (fileDest)));
                    }
                }
            }
        }
        zipFile.close ();
    } catch (IOException ioe) {
        System.err.println ("Unhandled exception:");
        ioe.printStackTrace ();
        return;
    }
}


private byte [] getBytesFromFile (File file) throws IOException {
    InputStream is = new FileInputStream (file);
    long length = file.length ();
    if (length > Integer.MAX_VALUE) {
        return null;
    }
    byte [] bytes = new byte [(int) length];
    int offset = 0;
    int numRead = 0;
    while (offset < bytes.length && (numRead = is.read (bytes, offset, bytes.length - offset)) >= 0) {
        offset += numRead;
    }
    if (offset < bytes.length) {
        throw new IOException ("Could not completely read file " + file.getName ());
    }
    is.close ();
    return bytes;
}


-----Function Pair=184=-----==

public static boolean fileExists (File zip, String fileName) throws ZipException, IOException {
    String filename = fileName;
    if (! zip.exists ()) {
        return false;
    }
    while (filename.charAt (0) == '/') {
        filename = filename.substring (1);
    }
    if (filename.contains ("\\")) {
        filename = filename.replace ("\\", "/");
    }
    ZipFile zipFile = new ZipFile (zip);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.getName ().equalsIgnoreCase (filename)) {
            return true;
        }
    }
    return false;
}


private static void pack (final URL url, final String comment, final File destFile) throws IOException {
    ZipOutputStream zipStrm = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (destFile, false)));
    try {
        zipStrm.setComment (comment);
        File file = IoUtil.url2file (url);
        if (file == null) {
            throw new IOException ("resolved URL " + url + " is not local file system location pointer");
        }
        File [] files = file.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            packEntry (zipStrm, null, files [i]);
        }
    } finally {
        zipStrm.close ();
    }
}


-----Function Pair=185=-----==

private long writeFileToZip (String filename, String uspaceName, String uplDirectory, boolean isAscii, org.unicore.utility.ZipOutputStream zos) throws FileNotFoundException, IOException {
    String zipName = uplDirectory + "/" + uspaceName;
    logger.info ("Writing ZIP entry: " + zipName);
    zos.putNextEntry (new ZipEntry (zipName));
    FileInputStream fis = new FileInputStream (filename);
    long length = new File (filename).length ();
    if (! isAscii) {
        byte [] buffer = new byte [4096];
        int read;
        while ((read = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, read);
            logger.fine ("next chunk: " + read);
        }
    }
    else {
        byte read;
        while ((read = (byte) fis.read ()) > 0) {
            if (read != 13 && read != 26) {
                zos.write ((int) read);
            }
        }
    }
    zos.closeEntry ();
    fis.close ();
    return length;
}


public boolean setImportMapContext (String importsource) {
    progress = new Progress ("Reading Projects", 100);
    progress.addProgressLine ("reading source " + importsource);
    importmapcontext = null;
    if (importsource == null || importsource.trim ().equals ("")) {
        progress.addMessageLine ("invalid source");
        this.getError ().setErrorString ("Error reading Projects : source is invalid");
        return false;
    }
    boolean import_from_zip;
    if (importsource.toLowerCase ().endsWith ("projects.xml")) {
        importsource = new File (importsource).getParent ();
    }
    if (importsource.toLowerCase ().endsWith (".jar") || importsource.toLowerCase ().endsWith (".zip")) {
        import_from_zip = true;
        progress.addProgressLine ("reading zip");
    }
    else {
        import_from_zip = false;
    }
    MapContext sourcemapcontext = null;
    ZipFile zip_file = null;
    try {
        progress.addProgressLine ("validating source");
        if (import_from_zip) {
            String temp_map_context = System.getProperty ("java.io.tmpdir") + File.separatorChar + "mc" + new Random (System.currentTimeMillis ()).nextLong ();
            zip_file = new ZipFile (importsource);
            ZipEntry prj_entry = zip_file.getEntry ("projects.xml");
            if (prj_entry != null) {
                new File (temp_map_context).mkdir ();
                FileSystem.copyStreamToFile (zip_file.getInputStream (prj_entry), new File (temp_map_context + File.separatorChar + "projects.xml"));
            }
            else {
                this.getError ().setErrorString ("Error reading Projects : Invalid zip file");
                System.out.println ("Error reading Projects : Invalid zip file " + importsource);
                return false;
            }
            progress.addProgressLine ("valid source");
            progress.addProgressLine ("reading source");
            sourcemapcontext = new MapContext (temp_map_context);
            new File (temp_map_context + File.separatorChar + "projects.xml").delete ();
            new File (temp_map_context + File.separatorChar).delete ();
        }
        else {
            if (new File (getHome ()).getCanonicalFile ().equals (new File (importsource).getCanonicalFile ())) {
                progress.addProgressLine ("cannot import from current working directory");
                this.getError ().setErrorString ("Error reading Projects : cannot import from current working directory");
                System.out.println ("Error reading Projects : cannot import from current working directory");
                return false;
            }
            progress.addProgressLine ("valid source");
            progress.addMessageLine ("reading source");
            sourcemapcontext = new MapContext (importsource);
        }
        sourcemapcontext.isZip = import_from_zip;
        sourcemapcontext.importSource = importsource;
    } catch (Exception e) {
        this.getError ().setErrorString ("Error reading Projects");
        this.getError ().addErrorString (" : " + e.getMessage ());
        return false;
    }
    if (sourcemapcontext.getMapFiles ().size () <= 0) {
        this.getError ().setErrorString ("Error reading Projects : no projects to import");
        return false;
    }
    progress.addProgressLine ("done", 20);
    progress.stop ();
    importmapcontext = sourcemapcontext;
    return true;
}


-----Function Pair=186=-----==

private long writeFileToZip (String filename, String uspaceName, String uplDirectory, boolean isAscii, org.unicore.utility.ZipOutputStream zos) throws FileNotFoundException, IOException {
    String zipName = uplDirectory + "/" + uspaceName;
    logger.info ("Writing ZIP entry: " + zipName);
    zos.putNextEntry (new ZipEntry (zipName));
    FileInputStream fis = new FileInputStream (filename);
    long length = new File (filename).length ();
    if (! isAscii) {
        byte [] buffer = new byte [4096];
        int read;
        while ((read = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, read);
            logger.fine ("next chunk: " + read);
        }
    }
    else {
        byte read;
        while ((read = (byte) fis.read ()) > 0) {
            if (read != 13 && read != 26) {
                zos.write ((int) read);
            }
        }
    }
    zos.closeEntry ();
    fis.close ();
    return length;
}


private static String toEscape (String s) {
    StringBuffer res = new StringBuffer ();
    for (int i = 0; i < s.length (); i ++) {
        char ch = s.charAt (i);
        int val = (int) ch;
        if (ch == '\r') continue;
        if (val >= 0 && val < 128 && ch != '\n' && ch != '\\') res.append (ch);
        else {
            res.append ("\\u");
            String hex = Integer.toHexString (val);
            for (int j = 0; j < 4 - hex.length (); j ++) res.append ("0");
            res.append (hex);
        }
    }
    return res.toString ();
}


-----Function Pair=187=-----==

public void endElement (XMLStreamReader xmlReader) throws Exception {
    String qName = xmlReader.getLocalName ().toLowerCase ();
    CXMLCorrente = CXML_INDEFINDO;
    if (qName.equals ("col")) {
        if (cont >= registroInicial && ! valorCorrenteENulo) {
            linha [indiceColuna] = converteDados (dadoLido.toString (), tipos [indiceColuna]);
        }
        indiceColuna ++;
    }
    else if (qName.equals ("linha")) {
        if (cont >= registroInicial) {
            dadosSeriais.getDados ().add (linha);
        }
        cont ++;
    }
    else if (qName.equals ("quantidade")) {
        dadosSeriais.setQuantidade ((Long) converteDados (dadoLido.toString (), INTEIRO));
    }
    else if (qName.equals ("cabecalho")) {
        if (dadosSeriais.getTipos ().size () > 0) {
            tipos = new int [dadosSeriais.getTipos ().size ()];
            for (int c = 0; c < dadosSeriais.getTipos ().size (); c ++) {
                String tipo = dadosSeriais.getTipos ().get (c);
                if (tipo.equals (LIT_INTEIRO)) {
                    tipos [c] = INTEIRO;
                }
                else if (tipo.equals (LIT_DECIMAL)) {
                    tipos [c] = DECIMAL;
                }
                else if (tipo.equals (LIT_DATA)) {
                    tipos [c] = DATA;
                }
                else {
                    tipos [c] = TEXTO;
                }
            }
        }
    }
    else if (qName.equals ("nome")) {
        dadosSeriais.getCabecalho ().add (dadoLido.toString ());
    }
    else if (qName.equals ("sql")) {
        dadosSeriais.setSql (dadoLido.toString ());
    }
    else if (qName.equals ("data")) {
        dadosSeriais.setDataColeta ((Date) converteDados (dadoLido.toString (), DATA));
    }
}


private String findJvmBinary () throws IOException {
    String jvmBinary = null;
    String os_name = System.getProperty ("os.name", "").toLowerCase ();
    String javaHome = null;
    System.out.println ("has PATH NPE fix");
    if (new File ("/System/Library/Frameworks/JavaVM.framework/Versions/1.3.1/Commands/java").exists ()) jvmBinary = "/System/Library/Frameworks/JavaVM.framework/Versions/1.3.1/Commands/java";
    if (os_name.indexOf ("windows 9") != - 1 || os_name.indexOf ("windows me") != - 1) {
        javaHome = System.getProperty ("java.home");
        if (jvmBinary == null && javaHome != null && ! javaHome.equals ("")) {
            jvmBinary = javaHome + File.separatorChar + "bin" + File.separatorChar + "java.exe";
            if (! new File (jvmBinary).exists ()) jvmBinary = null;
        }
    }
    if (jvmBinary == null) {
        javaHome = getEnv ("JAVA_HOME");
        if (javaHome != null && ! javaHome.equals ("")) {
            jvmBinary = javaHome + File.separatorChar + "bin" + File.separatorChar + "java";
            if (os_name.indexOf ("windows") != - 1) {
                jvmBinary += ".exe";
            }
            if (! new File (jvmBinary).exists ()) jvmBinary = null;
        }
    }
    if (jvmBinary == null) for (int i = 0; i < commonJavaLocations.length; i ++) if (new File (commonJavaLocations [i]).exists ()) {
        jvmBinary = commonJavaLocations [i];
        break;
    }
    if (jvmBinary == null) {
        String path = getEnv ("PATH");
        if (path == null) {
            path = getEnv ("Path");
        }
        if (path != null) {
            StringTokenizer st = new StringTokenizer (path, File.pathSeparatorChar + "");
            while (st.hasMoreTokens ()) {
                String s = st.nextToken ();
                if (new File (s + File.separatorChar + "java").exists () || new File (s + File.separatorChar + "java.exe").exists ()) {
                    jvmBinary = s + File.separatorChar + "java";
                    if (os_name.indexOf ("windows") != - 1) {
                        jvmBinary += ".exe";
                    }
                    break;
                }
            }
        }
    }
    if (jvmBinary == null) {
        javaHome = System.getProperty ("java.home");
        if (javaHome != null && ! javaHome.equals ("")) {
            jvmBinary = javaHome + File.separatorChar + "bin" + File.separatorChar + "java";
            if (os_name.indexOf ("windows") != - 1) {
                jvmBinary += ".exe";
            }
            if (! new File (jvmBinary).exists ()) jvmBinary = null;
        }
    }
    if (jvmBinary == null) throw new Error ("couldn't find JVM binary! JAVA_HOME=" + getEnv ("JAVA_HOME") + " PATH=" + getEnv ("PATH"));
    else return jvmBinary;
}


-----Function Pair=188=-----==

protected static Object [] loadFlash (E4Device device) throws ExternalizationException {
    File file = new File (device.remote.getDeviceLocalDir (), LAST_FLASH_SESSION_FILENAME + "." + SESSION_EXT);
    ZipInputStream zis;
    ZipEntry ze;
    ObjectInputStream ois;
    try {
        zis = new ZipInputStream (new FileInputStream (file));
        ze = zis.getNextEntry ();
        if (ze == null) throw new ExternalizationException ("Invalid flash session file");
        ois = new ObjectInputStream (zis);
        Object o = ois.readObject ();
        ois.close ();
        if (! (o instanceof Object [])) throw new ExternalizationException ("Invalid flash session file");
        return (Object []) o;
    } catch (FileNotFoundException e) {
        throw new ExternalizationException (e.getMessage ());
    } catch (IOException e) {
        throw new ExternalizationException (e.getMessage ());
    } catch (ClassNotFoundException e) {
        throw new ExternalizationException (e.getMessage ());
    }
}


public void putNextEntry (ZipEntry entry) throws IOException {
    if (entries == null) throw new ZipException ("ZipOutputStream was finished");
    int method = entry.getMethod ();
    int flags = 0;
    if (method == - 1) method = defaultMethod;
    if (method == STORED) {
        if (entry.getCompressedSize () >= 0) {
            if (entry.getSize () < 0) entry.setSize (entry.getCompressedSize ());
            else if (entry.getSize () != entry.getCompressedSize ()) throw new ZipException ("Method STORED, but compressed size != size");
        }
        else entry.setCompressedSize (entry.getSize ());
        if (entry.getSize () < 0) throw new ZipException ("Method STORED, but size not set");
        if (entry.getCrc () < 0) throw new ZipException ("Method STORED, but crc not set");
    }
    else if (method == DEFLATED) {
        if (entry.getCompressedSize () < 0 || entry.getSize () < 0 || entry.getCrc () < 0) flags |= 8;
    }
    if (curEntry != null) closeEntry ();
    if (entry.getTime () < 0) entry.setTime (System.currentTimeMillis ());
    entry.flags = flags;
    entry.offset = offset;
    entry.setMethod (method);
    curMethod = method;
    writeLeInt (LOCSIG);
    writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
    writeLeShort (flags);
    writeLeShort (method);
    writeLeInt (entry.getDOSTime ());
    if ((flags & 8) == 0) {
        writeLeInt ((int) entry.getCrc ());
        writeLeInt ((int) entry.getCompressedSize ());
        writeLeInt ((int) entry.getSize ());
    }
    else {
        writeLeInt (0);
        writeLeInt (0);
        writeLeInt (0);
    }
    byte [] name;
    try {
        name = entry.getName ().getBytes ("UTF-8");
    } catch (UnsupportedEncodingException uee) {
        throw new AssertionError (uee);
    }
    if (name.length > 0xffff) throw new ZipException ("Name too long.");
    byte [] extra = entry.getExtra ();
    if (extra == null) extra = new byte [0];
    writeLeShort (name.length);
    writeLeShort (extra.length);
    out.write (name);
    out.write (extra);
    offset += LOCHDR + name.length + extra.length;
    curEntry = entry;
    crc.reset ();
    if (method == DEFLATED) def.reset ();
    size = 0;
}


-----Function Pair=189=-----==

private String getTaskList (ScheduleItem item) {
    StringBuffer buff = new StringBuffer (1024);
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String selectedTask = store.getProperty ("tasks.deftask");
    if (item != null) {
        selectedTask = item.getPostTask ();
    }
    String [] keys = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    if (selectedTask.length () == 0) buff.append ("<label><input type='radio' name='task' value='none' checked>none</label><br>\n");
    else buff.append ("<label><input type='radio' name='task' value='none'>none</label><br>\n");
    for (int x = 0; x < keys.length; x ++) {
        if (keys [x].equals (selectedTask)) buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "' checked>" + keys [x] + "</label><br>\n");
        else buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "'>" + keys [x] + "</label><br>\n");
    }
    return buff.toString ();
}


public static String removeSpacesAndCapitalise (String string) {
    char [] result = new char [string.length ()];
    char [] chars = string.toCharArray ();
    int pos = - 1;
    boolean nextCapitalized = false;
    for (int i = 0; i < result.length; i ++) {
        if (Character.isWhitespace (chars [i])) {
            nextCapitalized = true;
            continue;
        }
        pos ++;
        if (nextCapitalized) {
            nextCapitalized = false;
            result [pos] = Character.toUpperCase (chars [i]);
        }
        else {
            result [pos] = chars [i];
        }
    }
    result [0] = Character.toLowerCase (result [0]);
    return new String (result, 0, pos + 1);
}


-----Function Pair=190=-----==

private void doUpload (HttpServletRequest request, HttpServletResponse response) throws IOException {
    deleteTempFiles ();
    String tempdir = Config.CONTEXT.getRealPath (backupTempFilePath);
    MultipartRequest mpr;
    try {
        mpr = new MultipartRequest (request, tempdir, 1000000000);
        File importFile = mpr.getFile ("fileUpload");
        if (importFile != null && importFile.getName ().toLowerCase ().endsWith (".zip")) {
            InputStream in = new BufferedInputStream (new FileInputStream (importFile));
            ZipInputStream zin = new ZipInputStream (in);
            ZipEntry e;
            while ((e = zin.getNextEntry ()) != null) {
                unzip (zin, e.getName ());
            }
            zin.close ();
            importFile.delete ();
        }
    } catch (IOException e) {
        Logger.error (this, e.getMessage (), e);
    }
    File f = new File (Config.CONTEXT.getRealPath (backupTempFilePath));
    String [] _tempFiles = f.list (new XMLFileNameFilter ());
    PrintWriter out = response.getWriter ();
    out.println ("<pre>Found " + _tempFiles.length + " files to import");
    for (int i = 0; i < _tempFiles.length; i ++) {
        File _importFile = new File (Config.CONTEXT.getRealPath (backupTempFilePath + "/" + _tempFiles [i]));
        System.gc ();
        doXMLFileImport (_importFile, out);
        out.flush ();
    }
    out.println ("Done Importing");
}


private static File recursiveFileSearch (String location, String name) {
    File found = null;
    File folder = new File (location);
    File [] listOfFiles = folder.listFiles (new FileFilter () {
        @Override
        public boolean accept (File file) {
            boolean isJPG = file.getName ().toLowerCase ().endsWith (".jpg");
            boolean isDir = file.isDirectory ();
            return isJPG || isDir;
        }
    }
    );
    for (int i = 0; i < listOfFiles.length && found == null; i ++) {
        File current = listOfFiles [i];
        if (! current.isDirectory () && current.getName ().contains (name)) {
            found = current;
            break;
        }
        else {
            found = recursiveFileSearch (current.getAbsolutePath (), name);
        }
    }
    return found;
}


-----Function Pair=191=-----==

private Map loadProperties (JarFile featureJar, String featureJarFileName, Map perFeatureLocales) {
    Iterator it = ((List) perFeatureLocales.get (featureJarFileName)).iterator ();
    Map result = new HashMap ();
    while (it.hasNext ()) {
        String propertyFileName = (String) it.next ();
        ZipEntry featurePropertiesEntry = featureJar.getEntry (propertyFileName);
        Properties featureProperties = new Properties ();
        if (featurePropertiesEntry != null) {
            try {
                featureProperties.load (featureJar.getInputStream (featurePropertiesEntry));
                String localeString = null;
                if (propertyFileName.endsWith ("feature.properties")) {
                    localeString = "";
                }
                else {
                    localeString = propertyFileName.substring (8, propertyFileName.indexOf ('.'));
                }
                result.put (localeString, featureProperties);
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
    return result;
}


public static final void zip (String fileName, final String zipName) throws Exception {
    try {
        final File file = new File (fileName);
        final FileInputStream fileInputStream = new FileInputStream (file);
        final ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (zipName));
        if (fileName.indexOf (File.separator) != - 1) fileName = fileName.substring (fileName.lastIndexOf (File.separator) + 1);
        zipOutputStream.putNextEntry (new ZipEntry (fileName));
        final byte [] buf = new byte [1024];
        int len;
        while ((len = fileInputStream.read (buf)) > 0) {
            zipOutputStream.write (buf, 0, len);
        }
        zipOutputStream.closeEntry ();
        fileInputStream.close ();
        zipOutputStream.close ();
    } catch (final IOException e) {
        System.out.println ("zip: Error: " + e.getMessage ());
        throw (e);
    }
}


-----Function Pair=192=-----==

public static PositionTextData merge (ArrayList < PositionTextData > pdAL) {
    PositionTextData [] pdArray = new PositionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionTexts.length;
    PositionText [] concatinate = new PositionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionText [] slice = pdArray [i].sortedPositionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionTextData (concatinate, sliceInfo);
}


private static void compress (String path, String parent, ZipOutputStream zip) throws IOException {
    File [] f = new File (path).listFiles ();
    byte [] buffer = new byte [4096];
    int bytes_read;
    for (int i = 0; i < f.length; i ++) {
        if (f [i].isFile ()) {
            FileInputStream in = new FileInputStream (f [i]);
            ZipEntry entry = new ZipEntry (parent + f [i].getName ());
            zip.putNextEntry (entry);
            while ((bytes_read = in.read (buffer)) != - 1) zip.write (buffer, 0, bytes_read);
            in.close ();
        }
        else if (f [i].isDirectory ()) {
            compress (f [i].getAbsolutePath (), parent + f [i].getName () + File.separator, zip);
        }
    }
}


-----Function Pair=193=-----==

private void zipTempDirectoryToStream (OutputStream out) throws IOException {
    byte b [] = new byte [512];
    ZipOutputStream zout = new ZipOutputStream (out);
    File f = new File (Config.CONTEXT.getRealPath (backupTempFilePath));
    String [] s = f.list ();
    for (int i = 0; i < s.length; i ++) {
        InputStream in = new BufferedInputStream (new FileInputStream (f = new File (Config.CONTEXT.getRealPath (backupTempFilePath + "/" + s [i]))));
        ZipEntry e = new ZipEntry (s [i].replace (File.separatorChar, '/'));
        zout.putNextEntry (e);
        int len = 0;
        while ((len = in.read (b)) != - 1) {
            zout.write (b, 0, len);
        }
        zout.closeEntry ();
        in.close ();
    }
    zout.close ();
    out.close ();
}


public void saveAttributes (Attributes a) throws IOException {
    String extension = fileresource.getUpperCaseExtension ();
    if ("XML".equals (extension)) {
    }
    else {
        File file = new File (getBinaryFilename ());
        if (! file.exists ()) {
            File parent = new File (file.getParent ());
            if (! parent.exists ()) {
                parent.mkdir ();
            }
        }
        FileOutputStream fos = new FileOutputStream (file);
        ZipOutputStream zout = new ZipOutputStream (fos);
        zout.putNextEntry (new ZipEntry ("Attributes"));
        DataOutputStream out = new DataOutputStream (zout);
        saveAttributesBinary (out, a);
        out.close ();
        fos.close ();
    }
}


-----Function Pair=194=-----==

private static void setUpLoadFiles (boObject object, String userBoui, File upLoadFile, String bridge) throws boRuntimeException, IOException, iFilePermissionDenied {
    boolean compressed = false;
    FileInputStream fi = new FileInputStream (upLoadFile);
    CheckedInputStream csumi = new CheckedInputStream (fi, new Adler32 ());
    ZipInputStream in = new ZipInputStream (csumi);
    BufferedInputStream bis = new BufferedInputStream (in);
    ZipEntry zfile;
    long tInicial = System.currentTimeMillis ();
    long tFinal = 0;
    while ((zfile = in.getNextEntry ()) != null) {
        compressed = true;
        String [] docTree = zfile.getName ().split ("/");
        if (! zfile.isDirectory ()) {
            if (docTree.length > 1) {
                iFileUpdate (true, bis, object, userBoui, docTree [docTree.length - 1], null, zfile, docTree, bridge);
            }
            else {
                iFileUpdate (true, bis, object, userBoui, zfile.getName (), null, zfile, docTree, bridge);
            }
        }
        else {
            boObject fatherObject = getDocument (object, docTree, bridge);
            if ("Ebo_Folder".equals (fatherObject.getBoDefinition ().getName ())) {
                if (! fatherObject.getAttribute ("description").getValueString ().equals (docTree [docTree.length - 1])) {
                    documentCreate (fatherObject, docTree [docTree.length - 1], bridge);
                }
            }
            else {
                documentCreate (fatherObject, docTree [docTree.length - 1], bridge);
            }
        }
    }
    bis.close ();
    fi.close ();
    if (! compressed) {
        setUpLoadFile (object, userBoui, upLoadFile, bridge);
    }
    tFinal = System.currentTimeMillis ();
    logger.finer (LoggerMessageLocalizer.getMessage ("TOTAL_CHECKIN_TIME") + ": " + (tFinal - tInicial) / 1000 + "s");
}


public ManifestType createRootManifest (AssessmentContentPackage cp, int testType) {
    ManifestType manifest = new ManifestType ();
    ResourcesType resource = new ResourcesType ();
    try {
        manifest.setOrganizations (new OrganizationsType ());
    } catch (Exception e) {
    }
    try {
        manifest.setMetadata (cp.getManifest ().getMetadata ());
    } catch (Exception e) {
    }
    String testID = cp.getTestResId ();
    testID = testID.replace ("__QTIE__", "");
    ResourceType testResReal = new ResourceType ();
    testResReal.setIdentifier (testID);
    if (testType == PURE) {
        testResReal.setType ("imsqti_test_xmlv2p1");
    }
    if ((testType == QTIENGINE) || (testType == HYBRID)) {
        testResReal.setType ("imsqti_assessment_xmlv2p1");
    }
    testResReal.setHref (cp.getTestXMLlocationHref ());
    FileType testResFile = new FileType ();
    testResFile.setHref (cp.getTestXMLlocationHref ());
    testResReal.getFile ().add (testResFile);
    ArrayList < DependencyType > dependencies = new ArrayList < DependencyType > ();
    ArrayList < ResourceType > questionResources = new ArrayList < ResourceType > ();
    for (Section s : cp.getSections ()) {
        for (Question q : s.getQuestions ()) {
            ResourceType qRes = new ResourceType ();
            qRes.setIdentifier (q.getRefId ());
            qRes.setType ("imsqti_item_xmlv2p1");
            qRes.setHref (q.getBaseHref ());
            if (q.getMetadata () != null) qRes.setMetadata (q.getMetadata ());
            qRes.getFile ().addAll (q.getFiles ());
            questionResources.add (qRes);
            DependencyType qdep = new DependencyType ();
            qdep.setIdentifierref (q.getRefId ());
            dependencies.add (qdep);
        }
    }
    testResReal.getDependency ().addAll (dependencies);
    resource.getResource ().add (testResReal);
    if (testType == HYBRID) {
        JAXBElement < ResourceType > je2 = null;
        ResourceType testResQTIEngine = new ResourceType ();
        StringWriter sw = new StringWriter ();
        try {
            JAXBElement je = new JAXBElement < ResourceType > (new QName ("http://www.imsglobal.org/xsd/imscp_v1p1", "resource"), ResourceType.class, testResReal);
            imsmanifestMarshaller.marshal (je, sw);
            je2 = (JAXBElement < ResourceType >) imsmanifestUnmarshaller.unmarshal (new ByteArrayInputStream (sw.toString ().getBytes ()));
            testResQTIEngine = je2.getValue ();
        } catch (JAXBException e) {
        }
        testResQTIEngine.setType ("imsqti_test_xmlv2p1");
        resource.getResource ().add (testResQTIEngine);
    }
    resource.getResource ().addAll (questionResources);
    manifest.setResources (resource);
    cp.setManifest (manifest);
    return manifest;
}


-----Function Pair=195=-----==

public static long getFolderSize (boObject object, String bridge) throws boRuntimeException {
    long size = 0;
    iFile file = null;
    bridgeHandler bHandler = object.getBridge (bridge);
    bHandler.beforeFirst ();
    while (bHandler.next ()) {
        boObject objHandler = bHandler.getObject ();
        if (objHandler.exists ()) {
            if (isDocument (objHandler.getBoDefinition ().getName ())) {
                file = objHandler.getAttribute ("file").getValueiFile ();
                size += file.length ();
            }
            else {
                size += getFolderSize (objHandler, "details");
            }
        }
    }
    return size;
}


public synchronized boolean writeFile (String filename, InputStream stream) throws IOException {
    if (fileSent) return false;
    BufferedInputStream origin = new BufferedInputStream (stream, BUFFER);
    try {
        byte data [] = new byte [BUFFER];
        ZipEntry entry = new ZipEntry (filename);
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        fileWritten = true;
        interrupt ();
        return true;
    } catch (IOException e) {
        LOG.error ("Error writing to zip file '" + zipFile + "'", e);
        interrupt ();
        throw e;
    } finally {
        CloseUtils.safeClose (origin);
    }
}


-----Function Pair=196=-----==

private void createShortcuts (File sharedDir) {
    LogInfo logInfo;
    PrintWriter log;
    Set shortcuts;
    Iterator scIt;
    String tempString;
    try {
        Vector oldlog = loadLogFile (new File (sharedDir.getAbsolutePath () + File.separator + "vai_" + VAGlobals.APP_NAME + "_" + VAGlobals.APP_VERSION + File.separator + "shortcuts.vai"));
        log = new PrintWriter (new FileWriter (sharedDir.getAbsolutePath () + File.separator + "vai_" + VAGlobals.APP_NAME + "_" + VAGlobals.APP_VERSION + File.separator + "shortcuts.vai"));
        logInfo = new LogInfo ();
        logInfo.log = log;
        logInfo.oldlog = oldlog;
        scIt = oldlog.iterator ();
        shortcuts = new java.util.LinkedHashSet ();
        while (scIt.hasNext ()) {
            shortcuts.add (scIt.next ());
        }
        if (VAGlobals.CREATE_UNINSTALL_SHORTCUT) {
            if (VAGlobals.DEBUG) VAGlobals.printDebug ("create uninstall shortcut");
            List entry = new ArrayList ();
            if (launchparms != null) entry.addAll (Arrays.asList (launchparms));
            String exe = VAGlobals.DEST_PATH + System.getProperty ("file.separator") + "uninstall_" + VAGlobals.APP_NAME + "_" + VAGlobals.APP_VERSION;
            if (IS_WIN) exe += ".bat";
            else if (IS_UNIX) exe += ".sh";
            VAShortcutEntry e = new VAShortcutEntry ("Uninstall " + VAGlobals.APP_NAME, exe);
            e.setUninstall (true);
            e.setCreateOnDesktop (false);
            entry.add (e);
            launchparms = new VAShortcutEntry [entry.size ()];
            entry.toArray (launchparms);
        }
        if (launchparms != null) {
            if (IS_UNIX) {
                VALinkLinux.createAll (this.launchparms, shortcuts);
            }
            else if (IS_WIN) {
                VALinkWindows.create (launchparms, sharedDir, installClassName_, shortcuts);
            }
            else {
                ui_.showError (new Exception (VAGlobals.i18n ("Setup_SorryFeatureNotImplemented")));
            }
        }
        scIt = shortcuts.iterator ();
        while (scIt.hasNext ()) {
            tempString = (String) scIt.next ();
            log.println (tempString);
        }
        logInfo.close ();
    } catch (IOException e) {
        ui_.showError (e);
    }
}


public static void zipFilesTo (Vector < File > fileVector, String baseDir, File destFile) {
    FileOutputStream ops = null;
    ZipOutputStream zos = null;
    int basedirlen = baseDir.length ();
    if (! baseDir.endsWith (File.separator)) basedirlen ++;
    try {
        ops = new FileOutputStream (destFile);
        zos = new ZipOutputStream (ops);
        Iterator < File > iter = fileVector.iterator ();
        while (iter.hasNext ()) {
            File file = iter.next ();
            FileInputStream fis = null;
            try {
                fis = new FileInputStream (file);
                String name = file.getPath ().substring (basedirlen);
                name = name.replace ('\\', '/');
                ZipEntry zi = new ZipEntry (name);
                zos.putNextEntry (zi);
                copystream (fis, zos);
                zos.closeEntry ();
            } catch (FileNotFoundException e) {
                e.printStackTrace ();
            } catch (IOException e) {
                e.printStackTrace ();
            } finally {
                try {
                    if (fis != null) fis.close ();
                } catch (Exception e) {
                }
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (zos != null) zos.close ();
            else if (ops != null) ops.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=197=-----==

protected ModelAndView handleRequestInternal (HttpServletRequest request, HttpServletResponse response) throws Exception {
    NodeVisit visit = VisitUtils.getVisit (request);
    if (visit == null) {
        logger.debug (AdminConstants.UNAUTHED + " transaction " + AdminConstants.ACCESS_REQUEST);
        return VisitUtils.getUnauthedView (request);
    }
    String transactionId = ServletRequestUtils.getRequiredStringParameter (request, "transactionId");
    NodeTransaction trans = getTransactionService ().get (transactionId, visit);
    NodeTransaction downloadTrans = null;
    File zipFile = null;
    if (trans != null) {
        PartnerIdentity oldPartner = new PartnerIdentity ();
        oldPartner.setUrl (trans.getNetworkEndpointUrl ());
        oldPartner.setVersion (trans.getNetworkEndpointVersion ());
        NodeClientService ncl = getNodeClientFactory ().makeAndConfigure (oldPartner);
        trans.setDocuments (new ArrayList < Document > ());
        downloadTrans = ncl.download (trans);
        if (downloadTrans.getDocuments () != null) {
            zipFile = File.createTempFile ("transdownload", ".zip");
            if (zipFile.exists ()) {
                zipFile.delete ();
            }
            ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
            for (int i = 0; i < downloadTrans.getDocuments ().size (); i ++) {
                Document currentDoc = downloadTrans.getDocuments ().get (i);
                writeFileToZip (zipOut, currentDoc.getContent (), currentDoc.getDocumentName ());
            }
            zipOut.flush ();
            zipOut.close ();
        }
    }
    if (zipFile != null) {
        response.setHeader ("Cache-Control", "must-revalidate");
        response.setContentType ("application/zip");
        response.setHeader ("Content-Disposition", "attachment; filename=\"" + trans.getNetworkId () + ".zip\"");
        FileCopyUtils.copy (new FileInputStream (zipFile), response.getOutputStream ());
        return null;
    }
    return new ModelAndView ("redirect:tran.htm?id=" + transactionId);
}


public boolean saveAsZip (String path) {
    if (! path.endsWith (".zip")) path = path + ".zip";
    if (name == null) name = imp.getTitle ();
    if (name.endsWith (".zip")) name = name.substring (0, name.length () - 4);
    if (! name.endsWith (".tif")) name = name + ".tif";
    fi.description = getDescriptionString ();
    Object info = imp.getProperty ("Info");
    if (info != null && (info instanceof String)) fi.info = (String) info;
    fi.roi = RoiEncoder.saveAsByteArray (imp.getRoi ());
    fi.overlay = getOverlay (imp);
    fi.sliceLabels = imp.getStack ().getSliceLabels ();
    if (imp.isComposite ()) saveDisplayRangesAndLuts (imp, fi);
    if (fi.nImages > 1 && imp.getStack ().isVirtual ()) fi.virtualStack = (VirtualStack) imp.getStack ();
    try {
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (path));
        DataOutputStream out = new DataOutputStream (new BufferedOutputStream (zos));
        zos.putNextEntry (new ZipEntry (name));
        TiffEncoder te = new TiffEncoder (fi);
        te.write (out);
        out.close ();
    } catch (IOException e) {
        showErrorMessage (e);
        return false;
    }
    updateImp (fi, FileInfo.TIFF);
    return true;
}


-----Function Pair=198=-----==

public boolean saveAsRawStack (String path) {
    if (fi.nImages == 1) {
        IJ.write ("This is not a stack");
        return false;
    }
    fi.intelByteOrder = Prefs.intelByteOrder;
    boolean signed16Bit = false;
    Object [] stack = null;
    int n = 0;
    boolean virtualStack = imp.getStackSize () > 1 && imp.getStack ().isVirtual ();
    if (virtualStack) {
        fi.virtualStack = (VirtualStack) imp.getStack ();
        if (imp.getProperty ("AnalyzeFormat") != null) fi.fileName = "FlipTheseImages";
    }
    try {
        signed16Bit = imp.getCalibration ().isSigned16Bit ();
        if (signed16Bit && ! virtualStack) {
            stack = (Object []) fi.pixels;
            n = imp.getWidth () * imp.getHeight ();
            for (int slice = 0; slice < fi.nImages; slice ++) {
                short [] pixels = (short []) stack [slice];
                for (int i = 0; i < n; i ++) pixels [i] = (short) (pixels [i] - 32768);
            }
        }
        ImageWriter file = new ImageWriter (fi);
        OutputStream out = new BufferedOutputStream (new FileOutputStream (path));
        file.write (out);
        out.close ();
    } catch (IOException e) {
        showErrorMessage (e);
        return false;
    }
    if (signed16Bit) {
        for (int slice = 0; slice < fi.nImages; slice ++) {
            short [] pixels = (short []) stack [slice];
            for (int i = 0; i < n; i ++) pixels [i] = (short) (pixels [i] + 32768);
        }
    }
    updateImp (fi, fi.RAW);
    return true;
}


public static byte [] zipEntriesAndFiles (Map < ZipEntry, byte [] > files) throws IOException {
    ByteArrayOutputStream dest = new ByteArrayOutputStream ();
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    byte [] data = new byte [2048];
    Iterator < Entry < ZipEntry, byte [] > > itr = files.entrySet ().iterator ();
    while (itr.hasNext ()) {
        Entry < ZipEntry, byte [] > entry = itr.next ();
        ByteArrayInputStream bytesIn = new ByteArrayInputStream (entry.getValue ());
        BufferedInputStream origin = new BufferedInputStream (bytesIn, 2048);
        out.putNextEntry (entry.getKey ());
        int count;
        while ((count = origin.read (data, 0, 2048)) != - 1) {
            out.write (data, 0, count);
        }
        bytesIn.close ();
        origin.close ();
    }
    out.close ();
    byte [] outBytes = dest.toByteArray ();
    dest.close ();
    return outBytes;
}


-----Function Pair=199=-----==

public void Add2Ftp (Article art, File page) {
    if (article_ftp_hosts == null || article_ftp_hosts.isEmpty ()) return;
    if (art == null) return;
    for (Object obj : article_ftp_hosts) {
        FtpHost ftphost = (FtpHost) obj;
        FtpQueue ftp_queue = new FtpQueue (ftphost);
        ftp_queue = FtpScheduler.GetScheduler ().Add (ftp_queue);
        File local_file = page;
        String str_art_publish_dir = art_publish_dir.getAbsolutePath ();
        str_art_publish_dir = Utils.FixPath (str_art_publish_dir);
        String remote_file = local_file.getAbsolutePath ();
        remote_file = Utils.FixPath (remote_file);
        remote_file = remote_file.replaceFirst (str_art_publish_dir, ftphost.remotedir);
        remote_file = Utils.FixPath (remote_file);
        try {
            ftp_queue.AddTask (local_file, remote_file);
        } catch (NpsException e) {
            com.microfly.util.DefaultLog.error_noexception (e);
            continue;
        }
    }
}


public void findValidStations (int minDays) {
    String s, t = "";
    int count = 0;
    int valid = 0;
    int n = vector.size ();
    Collections.sort (vector);
    for (int i = 0; i < n; i ++) {
        s = vector.elementAt (i).toString ().substring (0, 6);
        if (i < (n - 1)) {
            t = vector.elementAt (i + 1).toString ().substring (0, 6);
            if (s.equals (t)) {
                count ++;
            }
            else {
                if (count > minDays) {
                    valid ++;
                }
                else {
                }
                count = 0;
            }
        }
    }
    System.out.println ("Valid:\t" + valid + "\tfinal size: " + vector.size ());
}


-----Function Pair=200=-----=1=

public static void zipDirectory (String directory, String zipName) {
    try {
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream (zipName);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        int endpos = directory.lastIndexOf ('/');
        byte data [] = new byte [ZIP_BUFFER];
        File f = new File (directory);
        String files [] = getRecursiveFileList (f);
        for (int i = 0; i < files.length; i ++) {
            logger.debug ("Adding: " + files [i]);
            FileInputStream fi = new FileInputStream (files [i]);
            origin = new BufferedInputStream (fi, ZIP_BUFFER);
            String fileName = files [i];
            String relativeName = fileName.substring (endpos + 1, fileName.length ());
            relativeName = relativeName.replace ('\\', '/');
            ZipEntry entry = new ZipEntry (relativeName);
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, ZIP_BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (Exception e) {
        logger.error ("zipDirectory: " + e, e);
    }
}


protected void zipFile (InputStream in, ZipOutputStream zOut, String vPath, long lastModified, File fromArchive, int mode, ZipExtraField [] extra) throws IOException {
    if (entries.contains (vPath)) {
        if (duplicate.equals ("preserve")) {
            logWhenWriting (vPath + " already added, skipping", Project.MSG_INFO);
            return;
        }
        else if (duplicate.equals ("fail")) {
            throw new BuildException ("Duplicate file " + vPath + " was found and the duplicate " + "attribute is 'fail'.");
        }
        else {
            logWhenWriting ("duplicate file " + vPath + " found, adding.", Project.MSG_VERBOSE);
        }
    }
    else {
        logWhenWriting ("adding entry " + vPath, Project.MSG_VERBOSE);
    }
    entries.put (vPath, vPath);
    if (! skipWriting) {
        ZipEntry ze = new ZipEntry (vPath);
        ze.setTime (lastModified);
        ze.setMethod (doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
        if (! zOut.isSeekable () && ! doCompress) {
            long size = 0;
            CRC32 cal = new CRC32 ();
            if (! in.markSupported ()) {
                ByteArrayOutputStream bos = new ByteArrayOutputStream ();
                byte [] buffer = new byte [BUFFER_SIZE];
                int count = 0;
                do {
                    size += count;
                    cal.update (buffer, 0, count);
                    bos.write (buffer, 0, count);
                    count = in.read (buffer, 0, buffer.length);
                }
                while (count != - 1);
                in = new ByteArrayInputStream (bos.toByteArray ());
            }
            else {
                in.mark (Integer.MAX_VALUE);
                byte [] buffer = new byte [BUFFER_SIZE];
                int count = 0;
                do {
                    size += count;
                    cal.update (buffer, 0, count);
                    count = in.read (buffer, 0, buffer.length);
                }
                while (count != - 1);
                in.reset ();
            }
            ze.setSize (size);
            ze.setCrc (cal.getValue ());
        }
        ze.setUnixMode (mode);
        zOut.putNextEntry (ze);
        if (extra != null) {
            ze.setExtraFields (extra);
        }
        byte [] buffer = new byte [BUFFER_SIZE];
        int count = 0;
        do {
            if (count != 0) {
                zOut.write (buffer, 0, count);
            }
            count = in.read (buffer, 0, buffer.length);
        }
        while (count != - 1);
    }
    addedFiles.addElement (vPath);
}


-----Function Pair=201=-----=1=

private void addRecursivly (ZipOutputStream out, File path, String removePath) throws Exception {
    String [] children = path.list ();
    byte [] buf = new byte [1024];
    for (int i = 0; i < children.length; i ++) {
        File f = new File (path, children [i]);
        if (f.isDirectory ()) {
            addRecursivly (out, f, removePath);
            continue;
        }
        String filename = f.getAbsolutePath ().replace (removePath, "");
        if (filename.indexOf ("/") == 0) filename = filename.substring (1);
        if (filename.indexOf (File.separatorChar) == 0) filename = filename.substring (1);
        out.putNextEntry (new java.util.zip.ZipEntry (filename.replace ("\\", "/")));
        int len;
        FileInputStream zin = new FileInputStream (f);
        while ((len = zin.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        zin.close ();
    }
}


public void addContents (ZipOutputStream pZipFile, File pDirectory, String pDirName) throws IOException {
    File [] files = pDirectory.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        File f = files [i];
        String name = pDirName.length () == 0 ? f.getName () : pDirName + "/" + f.getName ();
        if (f.isDirectory ()) {
            addContents (pZipFile, f, name);
        }
        else if (f.isFile ()) {
            FileInputStream istream = new FileInputStream (f);
            try {
                ZipEntry zipEntry = new ZipEntry (name);
                pZipFile.putNextEntry (zipEntry);
                byte [] buffer = new byte [1024];
                for (;;) {
                    int res = istream.read (buffer);
                    if (res == - 1) {
                        break;
                    }
                    else if (res > 0) {
                        pZipFile.write (buffer, 0, res);
                    }
                }
                pZipFile.closeEntry ();
                istream.close ();
                istream = null;
            } finally {
                if (istream != null) {
                    try {
                        istream.close ();
                    } catch (Throwable ignore) {
                    }
                }
            }
        }
    }
}


-----Function Pair=202=-----==

void addJarEntry (JarOutputStream jar, File jarFile, java.io.FileFilter filter, String dir) throws IOException {
    String name = "";
    if (dir != null) name += dir;
    name += jarFile.getName ();
    if (jarFile.isDirectory ()) {
        name += "/";
    }
    addJarEntry (jar, name, jarFile);
    if (jarFile.isDirectory ()) {
        File [] jarFiles = listFiles (jarFile, false, filter);
        for (int i = 0; i < jarFiles.length; i ++) {
            addJarEntry (jar, jarFiles [i], filter, name);
        }
        File [] dirs = listDirectories (jarFile, false);
        for (int i = 0; i < dirs.length; i ++) {
            addJarEntry (jar, dirs [i], filter, name);
        }
    }
}


public static < T > String join (String delimiter, UnaryFunction < String, T > formatter, Collection < T > array) {
    if (array.isEmpty ()) {
        return "<empty>";
    }
    int i = 0;
    StringBuffer res = new StringBuffer ();
    for (T item : array) {
        if (formatter != null) {
            res.append (formatter.eval (item));
        }
        else {
            res.append (item);
        }
        i ++;
        if (i < array.size ()) {
            res.append (delimiter);
        }
    }
    return res.toString ();
}


-----Function Pair=203=-----==

private boolean archiveDirectoryTo (String destination, String pathPrefix) {
    File destinationFile = prepareDestinationArchive (destination);
    if (destinationFile == null) {
        return false;
    }
    JarOutputStream outputStream;
    try {
        outputStream = new JarOutputStream (new FileOutputStream (destinationFile));
    } catch (FileNotFoundException e) {
        Log.error (TAG, "Could not create JarOutputStream: " + e.getMessage ());
        return false;
    } catch (IOException e) {
        Log.error (TAG, "Could not create JarOutputStream: " + e.getMessage ());
        return false;
    }
    String basePath = getAbsolutePath ();
    UniversalFile [] filesToArchive = listFilesRecursively ();
    try {
        for (UniversalFile fileToArchive : filesToArchive) {
            String path = fileToArchive.getAbsolutePath ();
            if (! path.startsWith (basePath)) {
                Log.error (TAG, "Internal error: File in directory has wrong path:");
                Log.error (TAG, "Base path: " + basePath);
                Log.error (TAG, "File path: " + path);
                return false;
            }
            path = path.substring (basePath.length () + 1);
            String entryPath = (pathPrefix + path).replace ('\\', '/');
            outputStream.putNextEntry (new ZipEntry (entryPath));
            outputStream.write (fileToArchive.getFileAsBytes ());
        }
        outputStream.close ();
        return true;
    } catch (IOException e) {
        Log.error (TAG, "Could not write to archive: " + e.getMessage ());
    }
    return false;
}


private static OutputStream transferStream (InputStream input, int length, ExportController controller, OutputStream output, String targetName, int mode) throws IOException, CoreException {
    output = controller.getOutputStream (output, targetName, mode);
    int remaining = length;
    byte [] buffer;
    if (remaining > BUFFER_THRESHHOLD) {
        buffer = new byte [BUFFER_THRESHHOLD];
    }
    else {
        buffer = new byte [remaining];
    }
    while (remaining > 0) {
        int toRead = remaining > buffer.length ? buffer.length : remaining;
        int amount = input.read (buffer, 0, toRead);
        output.write (buffer, 0, amount);
        remaining -= amount;
    }
    input.close ();
    return output;
}


-----Function Pair=204=-----==

public void actionPerformed (ActionEvent ae) {
    try {
        TreeNode lastElement = getSelectedNode ();
        if (! (lastElement instanceof MetadataNode)) return;
        Metadata metadata = ((MetadataNode) lastElement).getMetadata ();
        SelectableEntry entry = metadata.getEntry ();
        metadata.setEntry (null);
        entry.removeMetadata (metadata);
        int index = getIndexByToolTip (metadata.getDescriptiveName ());
        if (index != - 1) {
            metadataView.removeTabAt (index);
        }
    } catch (Exception e) {
        Utility.showExceptionDialog (creator, e);
    }
}


public static void removeEmptyParagraphs (Node root) {
    NodeList pNodes = ((Element) root).getElementsByTagName ("text:p");
    for (int i = 0; i < pNodes.getLength (); i ++) {
        Node node = pNodes.item (i);
        if (node.getTextContent ().trim ().equals ("")) {
            if (! node.hasChildNodes ()) {
                node.getParentNode ().removeChild (node);
                i --;
            }
            else {
                boolean empty = true;
                for (int j = 0; j < node.getChildNodes ().getLength (); j ++) {
                    if (node.getChildNodes ().item (j).getNodeType () == node.ELEMENT_NODE) {
                        empty = false;
                    }
                }
                if (empty) {
                    node.getParentNode ().removeChild (node);
                    i --;
                }
            }
        }
    }
}


-----Function Pair=205=-----==

private void writeFileToZipFile (File file, String zipFilePath, ZipOutputStream zipOutput) throws IOException {
    ZipEntry zipEntry = new ZipEntry (zipFilePath);
    zipOutput.putNextEntry (zipEntry);
    BufferedInputStream bufferedInput = new BufferedInputStream (new FileInputStream (file));
    try {
        byte [] buffer = new byte [1024];
        while (bufferedInput.available () > 0) {
            int read = bufferedInput.read (buffer);
            zipOutput.write (buffer, 0, read);
        }
    } finally {
        try {
            bufferedInput.close ();
        } catch (Exception e) {
        }
    }
    zipOutput.closeEntry ();
}


public void run () {
    try {
        byte [] buf = new byte [1024];
        URLConnection uc = updatePath.openConnection ();
        BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (updaterFile));
        InputStream in = uc.getInputStream ();
        int byteRead, byteWritten = 0;
        while ((byteRead = in.read (buf)) != - 1) {
            out.write (buf, 0, byteRead);
            byteWritten += byteRead;
        }
        in.close ();
        out.close ();
        extractUpdate (path2);
    } catch (IOException e) {
        JOptionPane.showMessageDialog (null, "Update error! Could not download update data. Check your internet connection.", "Error", JOptionPane.ERROR_MESSAGE);
        e.printStackTrace ();
    }
}


-----Function Pair=206=-----==

public ExtentManager loadExtentManager (Connection con) throws SQLException {
    Debug.println ("GIEWSAttributesExternalizer.loadExtentManager START");
    ExtentManager extents = null;
    String SQL = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        extents = new ExtentManager ();
        SQL = "select b.KidsDimension_Label, count(a.DimensionValue_Order), " + "a.KidsDimension_Index " + "from kidsdatasetextent a, kidsdimension b " + "where b.Dataset_ID =? and a.Dataset_ID = b.Dataset_ID and " + "a.KidsDimension_Index = b.KidsDimension_Index " + "group by a.KidsDimension_Index, b.KidsDimension_Label " + "order by a.KidsDimension_Index";
        pstmt = con.prepareStatement (SQL);
        pstmt.setInt (1, getID ());
        rs = pstmt.executeQuery ();
        while (rs.next ()) {
            String label = rs.getString (1);
            Extent extent = new Extent (label);
            extent.ensureCapacity (rs.getInt (2));
            extents.add (extent);
        }
        try {
            rs.close ();
            pstmt.close ();
        } catch (Exception e) {
        }
        SQL = "select KidsDimension_Index, DimensionValue_Code , " + "DimensionValue_Name, DimensionValue_Order  " + "from kidsdatasetextent where Dataset_ID = ? " + "order by KidsDimension_Index, DimensionValue_Order";
        pstmt = con.prepareStatement (SQL);
        pstmt.setInt (1, getID ());
        rs = pstmt.executeQuery ();
        Extent extent = null;
        while (rs.next ()) {
            extents.addExtentEntry (rs.getInt (1), rs.getString (2), rs.getString (3));
            extent = extents.at (rs.getInt (1));
        }
    } finally {
        try {
            rs.close ();
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    Debug.println ("GIEWSAttributesExternalizer.loadExtentManager END");
    return extents;
}


public static File zipFile (String pathToBeZipped, String pathZippedFile) throws IOException {
    if (pathZippedFile.indexOf (".zip") < 0) {
        pathZippedFile += ".zip";
    }
    File fileASerZipado = new File (pathToBeZipped);
    byte [] buf = new byte [BUFFER_SIZE];
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (pathZippedFile));
    FileInputStream in = new FileInputStream (pathToBeZipped);
    out.putNextEntry (new ZipEntry (fileASerZipado.getName ()));
    int len;
    while ((len = in.read (buf)) > 0) {
        out.write (buf, 0, len);
    }
    out.closeEntry ();
    in.close ();
    out.close ();
    return new File (pathZippedFile);
}


-----Function Pair=207=-----==

public void openFile (String filename) throws ApplicationException {
    int returnVal;
    JFileChooser fc = getOpenFileChooser ();
    if (filename == null) {
        returnVal = fc.showOpenDialog (this);
    }
    else {
        fc.setSelectedFile (new File (filename));
        returnVal = JFileChooser.APPROVE_OPTION;
    }
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        if (! closeFile ()) return;
        freeze (true);
        final File file = fc.getSelectedFile ();
        if (file.canRead ()) {
            int ii = 0;
            boolean pushit = true;
            for (File recentFile : recentFiles) {
                if (ii ++ >= 4) {
                    break;
                }
                if (file.equals (recentFile)) {
                    pushit = false;
                    break;
                }
            }
            if (pushit) {
                try {
                    String desc = abbreviateFileName (file.getCanonicalPath ());
                    recentFileMenuItems.addFirst (new JMenuItem (desc));
                    recentFiles.addFirst (file);
                    constructFileMenu ();
                } catch (IOException ioe) {
                }
            }
        }
        try {
            Document doc = openDoc (file);
            String reason = "Unknown reason";
            if (doc != null) {
                final Document finaldoc = doc;
                Thread doModelPopulation = new Thread () {
                    public void run () {
                        try {
                            desktopPane.removeAll ();
                            Element component = finaldoc.getRootElement ();
                            Attribute component_name = component.getAttribute ("name");
                            if (component == null || component_name == null) throw new Exception ("Bad Component tag");
                            HierarchyNode rootHierarchyNode = XmlEngine.createCluster (InfoSec.this, component_name.getValue ());
                            hierarchy = new Hierarchy (rootHierarchyNode);
                            hierarchy.setRoot (rootHierarchyNode);
                            rootHierarchyNode.setModel (hierarchy);
                            rootHierarchyNode.getComponentModel ().setNameChangeEventListener (InfoSec.this);
                            tree.setModel (hierarchy);
                            Element schematicElement = component.getChild ("Schematic");
                            if (schematicElement == null) throw new Exception ("No schematic tag inside component");
                            XmlEngine.doChildComponents (InfoSec.this, rootHierarchyNode, schematicElement.getChildren ("ChildComponent"), schematicElement.getChildren ("Connection"), schematicElement.getChildren ("Instantiation"), false);
                            if (component.getChild ("LocalFaultData") == null) throw new Exception ("No local fault data for component");
                            XmlEngine.doLocalFaultData (rootHierarchyNode, component.getChild ("LocalFaultData"));
                            setDirty (false);
                            hierarchyNodeHashToInternalFrame.clear ();
                            hierarchyNodeHashToHierarchyNode.clear ();
                            freeze (false);
                            setStatus ("Finished loading " + file.getName ());
                        } catch (Exception e2) {
                            freeze (false);
                            new ApplicationException ("Open failed - XML not valid\n" + e2.getMessage ()).handler ();
                        }
                    }
                }
                ;
                doModelPopulation.start ();
                currentlyOpenFile = file;
            }
            else {
                setStatus ("Open failed - " + reason);
                freeze (false);
                throw new ApplicationException ("Open failed - " + reason);
            }
        } catch (ApplicationException e) {
            freeze (false);
            throw e;
        }
    }
}


private void jButton1ActionPerformed (ActionEvent evt) {
    System.out.println ("jButton1.actionPerformed, event=" + evt);
    int fila = table.getSelectedRow ();
    int columna = table.getSelectedColumn ();
    String dd = table.getValueAt (fila, columna).toString ();
    String [] f = mes.getText ().split (" ");
    String mm = mesLetraNumero (f [0]);
    String aaa = f [1];
    int dia = - 1;
    try {
        dia = Integer.parseInt (dd);
    } catch (Exception e) {
        Calendar calendario = new GregorianCalendar ();
        dia = calendario.get (Calendar.DAY_OF_MONTH);
    }
    String fecha = Utilidades.ceros (String.valueOf (dia)) + "/" + Utilidades.ceros (String.valueOf (mm)) + "/" + aaa;
    System.out.println ("Fecha Calendario: " + fecha);
    padre.setEnabled (true);
    jTextFieldPadre.setText (fecha);
    this.dispose ();
}


-----Function Pair=208=-----==

public static void createJar (File jarFile, String [] classpath, LinkedList < File > files) throws IOException {
    System.out.println ("Creating jar file: " + jarFile);
    JarOutputStream jos = new JarOutputStream (new FileOutputStream (jarFile));
    for (File f : files) {
        String name = f.getPath ();
        if (classpath != null) {
            String [] names = new String [classpath.length];
            for (int i = 0; i < classpath.length; i ++) {
                String path = new File (classpath [i]).getCanonicalPath ();
                if (name.startsWith (path)) {
                    names [i] = name.substring (path.length () + 1);
                }
            }
            for (int i = 0; i < names.length; i ++) {
                if (names [i] != null && names [i].length () < name.length ()) {
                    name = names [i];
                }
            }
        }
        ZipEntry e = new ZipEntry (name.replace (File.separatorChar, '/'));
        e.setTime (f.lastModified ());
        jos.putNextEntry (e);
        FileInputStream fis = new FileInputStream (f);
        byte [] data = new byte [fis.available ()];
        int n;
        while ((n = fis.read (data)) > 0) {
            jos.write (data, 0, n);
        }
        fis.close ();
        jos.closeEntry ();
    }
    jos.close ();
}


protected ModelAndView handleRequestInternal (HttpServletRequest request, HttpServletResponse response) throws Exception {
    String projectId = request.getParameter ("projectId");
    Project project = projectService.getById (projectId);
    String curriculumBaseDir = portalProperties.getProperty ("curriculum_base_dir");
    String sep = System.getProperty ("file.separator");
    String rawProjectUrl = (String) project.getCurnit ().accept (new CurnitGetCurnitUrlVisitor ());
    String projectJSONFullPath = curriculumBaseDir + sep + rawProjectUrl;
    String foldername = rawProjectUrl.substring (1, rawProjectUrl.lastIndexOf (sep));
    String projectJSONDir = projectJSONFullPath.substring (0, projectJSONFullPath.lastIndexOf (sep));
    response.setContentType ("application/zip");
    response.addHeader ("Content-Disposition", "attachment;filename=\"" + foldername + ".zip" + "\"");
    ServletOutputStream outputStream = response.getOutputStream ();
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (outputStream));
    File zipFolder = new File (projectJSONDir);
    int len = zipFolder.getAbsolutePath ().lastIndexOf (File.separator);
    String baseName = zipFolder.getAbsolutePath ().substring (0, len + 1);
    addFolderToZip (zipFolder, out, baseName);
    out.close ();
    return null;
}


-----Function Pair=209=-----==

public static void zip (String path, String source, String target, ZipOutputContainer outc, LongNum lm, long ml, StringBuffer msg) throws IOException {
    File f = new File (source);
    String [] flist = f.list ();
    String zfn = null;
    if (flist == null || flist.length < 1) return;
    File ft = new File (target);
    ZipEntry ze = null;
    String p = null;
    File nf = null;
    InputStream b = null;
    ZipOutputStream out = null;
    try {
        for (int i = 0; i < flist.length; i ++) {
            p = f.getAbsolutePath ();
            if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
            nf = new File (p + flist [i]);
            if (nf.isDirectory ()) {
                out = outc.getOut ();
                zfn = nf.toString ();
                zfn = zfn.substring (path.length (), zfn.length ());
                if (zfn.startsWith ("/") || zfn.startsWith ("\\")) zfn = zfn.substring (1, zfn.length ());
                if (! zfn.endsWith ("/")) zfn = zfn + "/";
                ze = new ZipEntry (zfn);
                ze.setTime (nf.lastModified ());
                out.putNextEntry (ze);
                out.closeEntry ();
                zip (path, p + flist [i], target, outc, lm, ml, msg);
            }
            else {
                if (flist [i].equals ("core") && nf.length () > 1000000) {
                    nf.delete ();
                    tools.util.LogMgr.debug ("******* Deleted existing core from context dir: " + nf);
                    msg.append ("******* Deleted existing core from context dir: " + nf + "\r\n");
                }
                else {
                    if (! ft.getParent ().equals (nf.getParent ())) {
                        zfn = nf.toString ();
                        zfn = zfn.substring (path.length (), zfn.length ());
                        if (zfn.startsWith ("/") || zfn.startsWith ("\\")) zfn = zfn.substring (1, zfn.length ());
                        ze = new ZipEntry (zfn.replace ('\\', '/'));
                        ze.setTime (nf.lastModified ());
                        try {
                            try {
                                b = new FileInputStream (nf);
                            } catch (FileNotFoundException fe) {
                                tools.util.LogMgr.err (nf + " FileUtil.zip " + fe.toString ());
                                b = null;
                                msg.append ("Unable to Archive the Following File " + nf + "\r\n");
                            }
                            out = outc.getOut ();
                            if (ml > 0 && lm.value > ml) {
                                out.close ();
                                File ffd = new File (ft.getParent ());
                                int ct = ffd.list ().length + 1;
                                target = target.substring (0, target.length () - 4);
                                target = target + ct + ".zip";
                                out = new ZipOutputStream (new FileOutputStream (new File (target)));
                                outc.setOut (out);
                                lm.value = 0;
                            }
                            if (b != null) {
                                lm.increment (nf.length ());
                                out.putNextEntry (ze);
                                StreamUtil.write (b, out);
                            }
                        } finally {
                            if (b != null) b.close ();
                        }
                        out.closeEntry ();
                    }
                }
            }
        }
    } catch (Throwable e) {
        if (out != null) try {
            out.close ();
        } catch (Exception io) {
        }
    }
}


private byte [] showAvailableThemes (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer out = new StringBuffer ();
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "ShowThemes.html");
    String httpDir = store.getProperty ("path.httproot");
    String themeDir = store.getProperty ("path.theme");
    File themeDirs = new File (httpDir + File.separator + "themes");
    int count = 0;
    if (themeDirs.exists ()) {
        File [] dirs = themeDirs.listFiles ();
        for (int x = 0; x < dirs.length; x ++) {
            if (dirs [x].isDirectory () && dirs [x].isHidden () == false) {
                count ++;
                out.append ("<option value=\"" + dirs [x].getName () + "\"");
                if (dirs [x].getName ().equalsIgnoreCase (themeDir)) out.append (" SELECTED ");
                out.append (">" + dirs [x].getName () + "</option>\n");
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$themeList", out.toString ());
    String currentEPGTheme = store.getProperty ("path.theme.epg");
    out = new StringBuffer ();
    String xslDir = store.getProperty ("path.xsl");
    count = 0;
    File xslDirs = new File (xslDir);
    if (xslDirs.exists ()) {
        File [] xslFiles = xslDirs.listFiles ();
        for (int x = 0; x < xslFiles.length; x ++) {
            if (xslFiles [x].isDirectory () == false) {
                if (xslFiles [x].getName ().matches ("epg-.*.xsl")) {
                    count ++;
                    out.append ("<option value=\"" + xslFiles [x].getName () + "\"");
                    if (xslFiles [x].getName ().equalsIgnoreCase (currentEPGTheme)) out.append (" SELECTED ");
                    String name = xslFiles [x].getName ().substring (4, xslFiles [x].getName ().length () - 4);
                    out.append (">" + name + "</option>\n");
                }
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$epg_themeList", out.toString ());
    out = new StringBuffer ();
    String [] agentList = store.getAgentMappingList ();
    for (int x = 0; x < agentList.length; x ++) {
        String themeForAgent = store.getThemeForAgent (agentList [x]);
        out.append ("<tr>");
        out.append ("<td>" + agentList [x] + "</td>");
        out.append ("<td>" + themeForAgent + "</td>");
        out.append ("<td><a href='/servlet/SystemDataRes?action=37&agent=" + URLEncoder.encode (agentList [x], "UTF-8") + "'><img src='/images/delete.png' alt='Delete Mapping' align='absmiddle' border='0' height='24' width='24'></a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$themeMappings", out.toString ());
    template.replaceAll ("$agentString", headers.get ("User-Agent"));
    return template.getPageBytes ();
}


-----Function Pair=210=-----==

private boolean writeEntry (File f, JarOutputStream out, String RelativePath) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            fPath = f.getPath ().substring (f.getPath ().lastIndexOf (FILESEPARATOR));
            en = RelativePath + fPath;
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, RelativePath);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


private void writeInstanceFile () {
    try {
        Map selModules = clientSession.getClientSelection ().getSelectedModules ();
        OutputStreamWriter fos = new OutputStreamWriter (new FileOutputStream (instanceFile), "UTF-8");
        String schemaLocation = ((ModuleLocation) taxonomy.getModuleByID ("coreSchemas").getSubModules ().get (0).getModuleLocations ().get (0)).getTargetNamespace () + " ";
        if (clientSession.getTaxonomyRefTyp ().equals ("relative")) {
            schemaLocation += taxonomy.getModuleByID ("coreSchemas").getSubModules ().get (0).getModuleLocations ().get (0).getLocalFile () + "\" ";
        }
        else if (clientSession.getTaxonomyRefTyp ().equals ("absolute")) {
            schemaLocation += taxonomy.getModuleByID ("coreSchemas").getSubModules ().get (0).getModuleLocations ().get (0).getAbsoluteURL () + "\" ";
        }
        fos.write ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\r" + "<xbrl " + "xsi:schemaLocation=\"" + schemaLocation + "xmlns:link=\"http://www.xbrl.org/2003/linkbase\" " + "xmlns:xlink=\"http://www.w3.org/1999/xlink\" " + "xmlns=\"http://www.xbrl.org/2003/instance\" " + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " + "xmlns:xbrli=\"http://www.xbrl.org/2003/instance\" " + "xmlns:iso4217=\"http://www.xbrl.org/2003/iso4217\" >\n\r");
        boolean dimensionsSelected = false;
        Iterator keys = selModules.keySet ().iterator ();
        while (keys.hasNext ()) {
            String moduleKey = (String) keys.next ();
            IModule m = (IModule) taxonomy.getModuleByID (moduleKey);
            if (m.getType ().equals (AIdentifiableComponent.MODULE_TYPE_DIMENSIONS_MODULE)) {
                dimensionsSelected = true;
            }
            String modulePath = "";
            modulePath = m.getPath ();
            createInstanceEntry (m.getModuleLocations (), m.getDescription (), modulePath);
            List ssm = clientSession.getClientSelection ().getSelectedSubModules (moduleKey);
            ISubModule sm;
            for (int i = 0; i < ssm.size (); i ++) {
                sm = (ISubModule) taxonomy.getSubModuleByID (moduleKey, ssm.get (i).toString ());
                String subModulePath = sm.getPath ();
                createInstanceEntry (sm.getModuleLocations (), sm.getDescription (), modulePath + subModulePath);
            }
        }
        List < ExternalModule > externalModules = taxonomy.getExternalModules ();
        for (int i = 0; i < externalModules.size (); i ++) {
            fos.write ("        <link:schemaRef xlink:type=\"simple\" xlink:href=\"" + externalModules.get (i).getFileLocation () + "\"/>\n\r");
        }
        for (int i = 0; i < schemaRef.size (); i ++) {
            fos.write ((String) schemaRef.get (i));
        }
        for (int i = 0; i < linkbaseRefLL.size (); i ++) {
            fos.write ((String) linkbaseRefLL.get (i));
        }
        for (int i = 0; i < linkbaseRefRL.size (); i ++) {
            fos.write ((String) linkbaseRefRL.get (i));
        }
        for (int i = 0; i < linkbaseRefPL.size (); i ++) {
            fos.write ((String) linkbaseRefPL.get (i));
        }
        for (int i = 0; i < linkbaseRefCL.size (); i ++) {
            fos.write ((String) linkbaseRefCL.get (i));
        }
        for (int i = 0; dimensionsSelected && i < linkbaseRefDL.size (); i ++) {
            fos.write ((String) linkbaseRefDL.get (i));
        }
        fos.write ("</xbrl>");
        fos.close ();
    } catch (IOException e) {
        log.error ("instancefile could not be written.\n\r" + e.getMessage ());
        throw new RuntimeException ("instancefile could not be written.\n\r" + e.getMessage ());
    }
}


-----Function Pair=211=-----=1=

public static Boolean compress (String sSourceDir, ArrayList < String > aFiles, String sDestinationFilename) {
    log.info ("PentahoReport() sourceDir: " + sSourceDir + " destination:" + sDestinationFilename);
    BufferedInputStream oOrigin = null;
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    Iterator < String > oIterator;
    byte [] aData;
    try {
        oDestination = new FileOutputStream (sDestinationFilename);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        aData = new byte [BUFFER_SIZE];
        oIterator = aFiles.iterator ();
        while (oIterator.hasNext ()) {
            String sFilename = (String) oIterator.next ();
            FileInputStream fisInput = new FileInputStream (sSourceDir + File.separator + sFilename);
            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);
            ZipEntry oEntry = new ZipEntry (sFilename.replace ('\\', '/'));
            oOutput.putNextEntry (oEntry);
            int iCount;
            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {
                oOutput.write (aData, 0, iCount);
            }
            oOrigin.close ();
        }
        oOutput.close ();
    } catch (Exception oException) {
        log.error (oException.getMessage ());
        oException.printStackTrace ();
        return false;
    }
    return true;
}


public boolean marshallRelationshipPart (PackageRelationshipCollection rels, URI relPartURI, ZipOutputStream zos) {
    if (logger.isDebugEnabled ()) {
        logger.debug ("writing relation:" + relPartURI);
    }
    Document xmlOutDoc = DocumentFactory.getInstance ().createDocument ();
    Namespace dfNs = Namespace.get ("", PackageRelationship.RELATIONSHIPS_NAMESPACE);
    Element root = xmlOutDoc.addElement (new QName (PackageRelationship.RELATIONSHIPS_TAG_NAME, dfNs));
    for (PackageRelationship rel : rels) {
        Element relElem = root.addElement (PackageRelationship.RELATIONSHIP_TAG_NAME);
        relElem.addAttribute (PackageRelationship.ID_ATTRIBUTE_NAME, rel.getId ());
        relElem.addAttribute (PackageRelationship.TYPE_ATTRIBUTE_NAME, rel.getRelationshipType ());
        String targetValue;
        URI uri = rel.getTargetUri ();
        if (rel.getTargetMode () == TargetMode.EXTERNAL) {
            targetValue = uri.getScheme () + "://" + uri.getPath ();
            relElem.addAttribute (PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME, "External");
        }
        else {
            targetValue = uri.getPath ();
        }
        relElem.addAttribute (PackageRelationship.TARGET_ATTRIBUTE_NAME, targetValue);
    }
    xmlOutDoc.normalize ();
    ZipEntry ctEntry = new ZipEntry (relPartURI.getPath ());
    try {
        zos.putNextEntry (ctEntry);
        if (! Package.saveAsXmlInZip (xmlOutDoc, relPartURI.getPath (), zos)) {
            return false;
        }
        zos.closeEntry ();
    } catch (IOException e1) {
        logger.error ("cannot create file " + relPartURI, e1);
        return false;
    }
    return true;
}


-----Function Pair=212=-----=1=

public void sendHashAllFilesToStream (String baseDirStr, OutputStream httpout, Hashtable newNamesTable) throws Exception {
    if (baseDirStr.endsWith (sep)) {
        baseDirStr = baseDirStr.substring (0, baseDirStr.length () - 1);
    }
    FileUtils.getInstance ().createDirectory (baseDirStr);
    if (null == newNamesTable) {
        newNamesTable = new Hashtable ();
    }
    BufferedInputStream in = null;
    byte dataBuff [] = new byte [bufferSize];
    File baseDir = new File (baseDirStr);
    if ((baseDir.exists ()) && (baseDir.isDirectory ())) {
        if (! newNamesTable.isEmpty ()) {
            ZipOutputStream outStream = new ZipOutputStream (httpout);
            Enumeration enumFiles = newNamesTable.keys ();
            while (enumFiles.hasMoreElements ()) {
                String newName = (String) enumFiles.nextElement ();
                String oldPathName = (String) newNamesTable.get (newName);
                if ((newName != null) && (! "".equals (newName)) && (oldPathName != null) && (! "".equals (oldPathName))) {
                    String oldPathFileName = baseDirStr + sep + oldPathName;
                    if (oldPathName.startsWith (sep)) {
                        oldPathFileName = baseDirStr + oldPathName;
                    }
                    File f = new File (oldPathFileName);
                    if ((f.exists ()) && (f.isFile ())) {
                        System.out.println ("download:" + f.getAbsolutePath ());
                        in = new BufferedInputStream (new FileInputStream (oldPathFileName), bufferSize);
                        ZipEntry entry = new ZipEntry (newName);
                        outStream.putNextEntry (entry);
                        int writeLen;
                        while ((writeLen = in.read (dataBuff)) > 0) {
                            outStream.write (dataBuff, 0, writeLen);
                        }
                        outStream.flush ();
                        outStream.closeEntry ();
                        in.close ();
                    }
                }
                else {
                    throw new Exception ("newNamesTable parameters wrong (null or empty) !");
                }
            }
            outStream.finish ();
            httpout.flush ();
        }
        else {
            throw new Exception ("newNamesTable is empty !");
        }
    }
    else {
        throw new Exception ("Base (baseDirStr) dir not exist !");
    }
}


public static void zipDir (File zipDir, ZipOutputStream zos, String path, ProgressMonitor pm, Map filter) {
    try {
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                if (filter != null && filter.get (f.getAbsolutePath ()) == null) zipDir (f, zos, path + f.getName () + "/", pm, filter);
            }
            else {
                FileInputStream fis = new FileInputStream (f);
                ZipEntry anEntry = new ZipEntry (path + f.getName ());
                zos.putNextEntry (anEntry);
                while ((bytesIn = fis.read (readBuffer)) != - 1) {
                    zos.write (readBuffer, 0, bytesIn);
                    if (pm != null) pm.addToProgress (bytesIn);
                }
                fis.close ();
            }
        }
    } catch (Exception e) {
        Installer.getInstance ().getLogger ().log (StringUtils.getStackTrace (e));
    }
}


-----Function Pair=213=-----==

public static File unzip (byte [] zipData, File directory) throws IOException {
    ByteArrayInputStream bais = new ByteArrayInputStream (zipData);
    ZipInputStream zis = new ZipInputStream (bais);
    ZipEntry entry = zis.getNextEntry ();
    File root = null;
    while (entry != null) {
        if (entry.isDirectory ()) {
            File f = new File (directory, entry.getName ());
            f.mkdir ();
            if (root == null) {
                root = f;
            }
        }
        else {
            BufferedOutputStream out;
            out = new BufferedOutputStream (new FileOutputStream (new File (directory, entry.toString ())), BUFFER_SIZE);
            for (int data = zis.read (); data != - 1; data = zis.read ()) {
                out.write (data);
            }
            out.close ();
        }
        zis.closeEntry ();
        entry = zis.getNextEntry ();
    }
    zis.close ();
    return root;
}


public boolean removeBaseForWord (String word, String remove) {
    boolean got_it = false;
    String upperWord = word.toUpperCase ();
    remove = remove.toUpperCase ();
    List l = (List) apelonAdditions.get (upperWord);
    if (l == null || l.size () == 0) return got_it;
    Iterator iter = l.iterator ();
    while (iter.hasNext ()) {
        WordEntry we = (WordEntry) iter.next ();
        if (we.getBase ().equals (remove)) {
            iter.remove ();
            got_it = true;
            break;
        }
    }
    apelonAdditions.put (upperWord, l);
    return got_it;
}


-----Function Pair=214=-----==

public boolean storeTransactionToZippedStream (OutputStream outputStream, boolean updateResourceFiles) {
    System.out.println ("Writing as a zipped transaction: " + this.uuid);
    ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);
    try {
        zipOutputStream.setLevel (Deflater.DEFAULT_COMPRESSION);
        String relativeFileName = ArchiveFileSupport.fileNameInSubdirectoryForTransactionIdentifier (this.uuid);
        ZipEntry zipEntry = new ZipEntry (relativeFileName);
        try {
            zipOutputStream.putNextEntry (zipEntry);
            if (! this.writeTransactionMetadataAndTriplesToUTF8Stream (zipOutputStream)) {
                return false;
            }
            zipOutputStream.closeEntry ();
        } catch (IOException e) {
            e.printStackTrace ();
            return false;
        }
        for (String transactionResourceFileReference : this.resourceFiles.keySet ()) {
            ResourceFileSpecification resourceFileSpecification = this.resourceFiles.get (transactionResourceFileReference);
            zipEntry = new ZipEntry (transactionResourceFileReference);
            zipOutputStream.putNextEntry (zipEntry);
            if (! resourceFileSpecification.copyTo (zipOutputStream, updateResourceFiles)) {
                return false;
            }
            zipOutputStream.closeEntry ();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
        this.resetResourceFiles ();
        return false;
    } catch (IOException e) {
        e.printStackTrace ();
        this.resetResourceFiles ();
        return false;
    } finally {
        try {
            zipOutputStream.close ();
        } catch (IOException e) {
            e.printStackTrace ();
            return false;
        }
    }
    return true;
}


private static void writeFile (File file, ZipOutputStream out) throws IOException {
    InputStream in = null;
    try {
        in = new FileInputStream (file);
        out.putNextEntry (new ZipEntry (file.getName ()));
        byte [] buffer = new byte [BUFFER_SIZE];
        int read = - 1;
        do {
            read = in.read (buffer);
            if (read > - 1) {
                out.write (buffer, 0, read);
            }
        }
        while (read > - 1);
        out.closeEntry ();
    } catch (IOException e) {
        throw e;
    } finally {
        if (in != null) in.close ();
    }
}


-----Function Pair=215=-----==

private void compressDirectory (String directoryPath) {
    byte [] buffer = new byte [4096];
    byte [] extra = new byte [0];
    File dir = new File (directoryPath);
    int bytes_read;
    try {
        if (dir.isDirectory ()) {
            String [] entries = dir.list ();
            if (entries.length == 0) {
                ZipEntry entry = new ZipEntry (dir.getPath () + "/");
                out.putNextEntry (entry);
            }
            for (int i = 0; i < entries.length; i ++) {
                File f = new File (dir, entries [i]);
                compressDirectory (f.getAbsolutePath ());
            }
        }
        else {
            in = new FileInputStream (dir);
            ZipEntry entry = new ZipEntry (dir.getPath ());
            out.putNextEntry (entry);
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
            }
            in.close ();
        }
    } catch (Exception c) {
        c.printStackTrace ();
    }
}


private final void saveStatistics (File dictFile) throws Exception {
    String statistics = "";
    statistics += "Total Wiktionary Title count: " + book.getTitleCount () + "\r\n";
    statistics += "Language Title count: " + book.getLanguageTitleCount () + "\r\n";
    statistics += "Word count in dictionary: " + book.getWordCount () + "\r\n";
    statistics += "Char count in dictionary: " + book.getCharCount () + "\r\n";
    statistics += "Dictionary size on disk (bytes): " + dictFile.length () + "\r\n";
    Class clazz = Class.forName ("com.inet.jortho.DictionaryFactory");
    Constructor constructor = clazz.getConstructor ();
    constructor.setAccessible (true);
    Object factory = constructor.newInstance ();
    Method loadWordList = clazz.getDeclaredMethod ("loadWordList", URL.class);
    loadWordList.setAccessible (true);
    loadWordList.invoke (factory, dictFile.toURL ());
    Method create = clazz.getDeclaredMethod ("create");
    create.setAccessible (true);
    Object dictionary = create.invoke (factory);
    Method getDataSize = dictionary.getClass ().getDeclaredMethod ("getDataSize");
    getDataSize.setAccessible (true);
    Integer size = (Integer) getDataSize.invoke (dictionary);
    statistics += "Dictionary size in memory (bytes): " + size + "\r\n";
    System.out.println (statistics);
    FileOutputStream out = new FileOutputStream ("statistics.txt");
    out.write (statistics.getBytes ());
    out.close ();
}


-----Function Pair=216=-----==

public static String file2String (String fn) {
    File f = new File (fn);
    if (f.exists () && f.length () == 0) {
        return " ";
    }
    Reader theReader = null;
    if (fn == null) return null;
    try {
        theReader = new FileReader (fn);
        StringWriter sw = new StringWriter ();
        char [] text = new char [128];
        int n;
        while ((n = theReader.read (text, 0, 128)) > 0) {
            sw.write (text, 0, n);
        }
        String tmp = sw.toString ();
        String tmp1 = tmp.replace ('\r', '\n');
        String tmp2 = tmp1.replaceAll ("\n\n", "\n");
        return tmp2;
    } catch (IOException e) {
        log.error ("file2String   " + fn + ":" + e.toString ());
        return null;
    } finally {
        if (theReader != null) {
            try {
                theReader.close ();
            } catch (IOException ie) {
            }
            theReader = null;
        }
    }
}


public void test_getInputStream_DeleteJarFileUsingURLConnection () throws Exception {
    String jarFileName = "";
    String entry = "text.txt";
    String cts = System.getProperty ("java.io.tmpdir");
    File tmpDir = new File (cts);
    File jarFile = tmpDir.createTempFile ("file", ".jar", tmpDir);
    jarFileName = jarFile.getPath ();
    FileOutputStream jarFileOutputStream = new FileOutputStream (jarFileName);
    JarOutputStream out = new JarOutputStream (new BufferedOutputStream (jarFileOutputStream));
    JarEntry jarEntry = new JarEntry (entry);
    out.putNextEntry (jarEntry);
    out.write (new byte [] {'a', 'b', 'c'});
    out.close ();
    URL url = new URL ("jar:file:" + jarFileName + "!/" + entry);
    URLConnection conn = url.openConnection ();
    conn.setUseCaches (false);
    InputStream is = conn.getInputStream ();
    is.close ();
    assertTrue (jarFile.delete ());
}


-----Function Pair=217=-----==

private void gzipFiles (Set < File > files, File gzipFile) throws IOException {
    if (files.isEmpty ()) {
        log.warn ("No files to gzip.");
    }
    else {
        try {
            BufferedInputStream origin = null;
            FileOutputStream dest = new FileOutputStream (gzipFile);
            TarArchiveOutputStream out = new TarArchiveOutputStream (new GzipCompressorOutputStream (dest));
            byte data [] = new byte [BUFFER];
            for (File f : files) {
                log.debug ("Adding file " + f + " to archive");
                FileInputStream fi = new FileInputStream (f);
                origin = new BufferedInputStream (fi, BUFFER);
                TarArchiveEntry entry = new TarArchiveEntry (f.getName ());
                out.putArchiveEntry (entry);
                int count;
                while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                    out.write (data, 0, count);
                }
                origin.close ();
            }
            out.finish ();
            out.close ();
        } catch (IOException e) {
            log.error ("IOException while gzipping files: " + files);
            throw e;
        }
    }
}


private static void getWatcherOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT watcherOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("watcherOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


-----Function Pair=218=-----=1=

private void write (File file, ZipOutputStream out, int pos, ZipFile zip) throws IOException {
    if (file.isDirectory ()) {
        File [] entries = file.listFiles ();
        for (File f : entries) write (f, out, pos, zip);
    }
    else {
        byte [] buffer = new byte [4096];
        int bytesRead;
        FileInputStream in = null;
        try {
            in = new FileInputStream (file);
            ZipEntry entry = new ZipEntry (file.getPath ().substring (pos));
            out.putNextEntry (entry);
            while ((bytesRead = in.read (buffer)) != - 1) out.write (buffer, 0, bytesRead);
            out.closeEntry ();
        } finally {
            Util.close (in);
        }
    }
}


public void zipDocsetFiles (SaxHandler theXmlHandler, int theEventId, Attributes theAtts) throws BpsProcessException {
    ZipOutputStream myZipOut = null;
    BufferedInputStream myDocumentInputStream = null;
    String myFinalFile = null;
    String myTargetPath = null;
    String myTargetFileName = null;
    String myInputFileName = null;
    byte [] myBytesBuffer = null;
    int myLength = 0;
    try {
        myZipOut = new ZipOutputStream (new FileOutputStream (myFinalFile));
        myZipOut.putNextEntry (new ZipEntry (myTargetPath + myTargetFileName));
        myDocumentInputStream = new BufferedInputStream (new FileInputStream (myInputFileName));
        while ((myLength = myDocumentInputStream.read (myBytesBuffer, 0, 4096)) != - 1) myZipOut.write (myBytesBuffer, 0, myLength);
        myZipOut.closeEntry ();
        myZipOut.close ();
    } catch (FileNotFoundException e) {
        throw (new BpsProcessException (BpsProcessException.ERR_OPEN_FILE, "FileNotFoundException while building zip dest file"));
    } catch (IOException e) {
        throw (new BpsProcessException (BpsProcessException.ERR_OPEN_FILE, "IOException while building zip dest file"));
    }
}


-----Function Pair=219=-----==

public static void archieveFiles (List < FileSystemNode > files, ZipOutputStream out, String pathFromRoot) throws Exception {
    byte [] buffer = new byte [4096];
    for (FileSystemNode file : files) {
        if (file.isFolder ()) {
            archieveFiles (file.getFileNodes (), out, pathFromRoot + file.getName () + "/");
            continue;
        }
        out.putNextEntry (new ZipEntry (pathFromRoot + file.getName ()));
        InputStream in = new BufferedInputStream (file.getContent ());
        for (int length = 0; (length = in.read (buffer)) > 0;) {
            out.write (buffer, 0, length);
        }
        out.closeEntry ();
        in.close ();
    }
}


private static String toEscape (String s) {
    StringBuffer res = new StringBuffer ();
    for (int i = 0; i < s.length (); i ++) {
        char ch = s.charAt (i);
        int val = (int) ch;
        if (ch == '\r') continue;
        if (val >= 0 && val < 128 && ch != '\n' && ch != '\\') res.append (ch);
        else {
            res.append ("\\u");
            String hex = Integer.toHexString (val);
            for (int j = 0; j < 4 - hex.length (); j ++) res.append ("0");
            res.append (hex);
        }
    }
    return res.toString ();
}


-----Function Pair=220=-----==

private void backupDiskFile (ZipOutputStream out, String fileName, DiskFile file) throws SQLException, IOException {
    Database db = session.getDatabase ();
    fileName = FileUtils.getFileName (fileName);
    out.putNextEntry (new ZipEntry (fileName));
    int pos = - 1;
    int max = file.getReadCount ();
    while (true) {
        pos = file.copyDirect (pos, out);
        if (pos < 0) {
            break;
        }
        db.setProgress (DatabaseEventListener.STATE_BACKUP_FILE, fileName, pos, max);
    }
    out.closeEntry ();
}


private byte [] setEpgTask (HTTPurl urlData) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String taskDef = urlData.getParameter ("tasks.deftask");
    if (taskDef == null || "none".equals (taskDef)) taskDef = "";
    store.setServerProperty ("tasks.defTask", taskDef);
    String taskPre = urlData.getParameter ("tasks.pretask");
    if (taskPre == null || "none".equals (taskPre)) taskPre = "";
    store.setServerProperty ("tasks.pretask", taskPre);
    String taskStartError = urlData.getParameter ("tasks.starterrortask");
    if (taskStartError == null || "none".equals (taskStartError)) taskStartError = "";
    store.setServerProperty ("tasks.starterrortask", taskStartError);
    String taskNoDataError = urlData.getParameter ("tasks.nodataerrortask");
    if (taskNoDataError == null || "none".equals (taskNoDataError)) taskNoDataError = "";
    store.setServerProperty ("tasks.nodataerrortask", taskNoDataError);
    return out.getBytes ();
}


-----Function Pair=221=-----==

public boolean appendAllParagraph (Element paragraphToAppend, TreeMap < String, String > mapOldIdToNewId) {
    List listParagraphToInsert = getListOfNodeToInsert (paragraphToAppend, mapOldIdToNewId);
    if (listParagraphToInsert == null) {
        return false;
    }
    Element body = getDocumentBody ();
    for (Iterator i = body.elementIterator (); i.hasNext ();) {
        Element curNode = (Element) i.next ();
        if (! isNodeParagraphOrTable (curNode) && ! isNodeIndentText (curNode)) {
            for (Iterator iter = listParagraphToInsert.iterator (); iter.hasNext ();) {
                Node elementtoInsert = (Node) iter.next ();
                body.elements ().add (body.elements ().indexOf (curNode), elementtoInsert);
            }
            return true;
        }
    }
    Iterator iter = listParagraphToInsert.iterator ();
    while (iter.hasNext ()) {
        logger.debug ("appending to body");
        Node curNodeToInsert = (Node) iter.next ();
        body.elements ().add (curNodeToInsert);
    }
    return true;
}


public static byte [] hs2b (String hex) {
    java.util.Vector < Object > res = new java.util.Vector < Object > ();
    String part;
    int pos = 0;
    final int len = 2;
    while (pos < hex.length ()) {
        part = hex.substring (pos, pos + len);
        pos += len;
        int byteVal = Integer.parseInt (part, 16);
        res.add (new Byte ((byte) byteVal));
    }
    if (res.size () > 0) {
        byte [] b = new byte [res.size ()];
        for (int i = 0; i < res.size (); i ++) {
            Byte a = (Byte) res.elementAt (i);
            b [i] = a.byteValue ();
        }
        return b;
    }
    else {
        return null;
    }
}


-----Function Pair=222=-----==

private void jList2MouseClicked (java.awt.event.MouseEvent evt) {
    flag = 2;
    selectedEntry = (FileEntry) jList2.getSelectedValue ();
    if (evt.getClickCount () == 2) {
        if (selectedEntry.isDir () || selectedEntry.isBackEntry ()) {
            if (selectedEntry.getName ().equals ("..")) {
                String [] temp = rightPath.split ("\\\\");
                rightPath = "";
                for (int i = 0; i < temp.length - 1; i ++) {
                    rightPath += temp [i] + "\\";
                }
            }
            else {
                rightPath = rightPath + selectedEntry.getName () + "\\";
            }
            jListDisplay (rightPath, jList2);
            RightPath.setText (rightPath + "*.*");
        }
    }
}


public FileNameGroup (String line) {
    executable_ = false;
    recursive_ = true;
    if (line.startsWith ("(E)")) {
        line = line.substring (3);
        executable_ = true;
    }
    if (line.startsWith ("(N)")) {
        line = line.substring (3);
        recursive_ = false;
    }
    StringTokenizer tok = new StringTokenizer (new String (line), "|", true);
    originBase_ = tok.nextToken ();
    if (originBase_.endsWith ("/")) originBase_ = originBase_.substring (0, originBase_.length () - 1);
    tok.nextToken ();
    destBase_ = tok.nextToken ();
    if (destBase_.equals ("|")) destBase_ = null;
    else {
        if (destBase_.endsWith ("/")) destBase_ = destBase_.substring (0, destBase_.length () - 1);
        tok.nextToken ();
    }
    extensions_ = null;
    commonPath_ = null;
    if (tok.hasMoreTokens ()) {
        commonPath_ = tok.nextToken ();
        if (commonPath_.equals ("|")) commonPath_ = null;
        if (tok.hasMoreTokens ()) {
            if (commonPath_ != null) tok.nextToken ();
            if (tok.hasMoreTokens ()) extensions_ = tok.nextToken ();
        }
    }
}


-----Function Pair=223=-----==

protected static Bitstream findOriginalBitstream (Item item, Bitstream derived) throws SQLException {
    Bundle [] bundles = item.getBundles ();
    String originalFilename = derived.getName ().substring (0, derived.getName ().length () - 4);
    for (int i = 0; i < bundles.length; i ++) {
        if ((bundles [i].getName () != null) && bundles [i].getName ().equals ("ORIGINAL")) {
            Bitstream [] bitstreams = bundles [i].getBitstreams ();
            for (int bsnum = 0; bsnum < bitstreams.length; bsnum ++) {
                if (bitstreams [bsnum].getName ().equals (originalFilename)) {
                    return bitstreams [bsnum];
                }
            }
        }
    }
    return null;
}


public static final byte [] unZipBuffer (byte [] buffer) {
    if (buffer == null) {
        throw new RuntimeException ("buffer is null, unZipBuffer");
    }
    ByteArrayInputStream is = new ByteArrayInputStream (buffer);
    ByteArrayOutputStream os = new ByteArrayOutputStream (1000);
    try {
        MLUtil.d ("unZipBuffer: " + buffer.length);
        ZipInputStream zip = new ZipInputStream (is);
        ZipEntry zipentry = zip.getNextEntry ();
        if (zipentry == null) {
            MLUtil.runtimeError (null, "unZipBuffer failure");
            return (null);
        }
        int n;
        byte [] temp = new byte [TEMP_FILE_BUFFER_SIZE];
        while ((n = zip.read (temp)) > - 1) os.write (temp, 0, n);
        zip.closeEntry ();
        zip.close ();
        is.close ();
        os.close ();
        byte [] bb = os.toByteArray ();
        MLUtil.d ("uncompressed=" + bb.length);
        return (bb);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "unzipBuffer");
    }
    return (null);
}


-----Function Pair=224=-----==

private static void addDir (String root, File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (root, files [i], out);
            continue;
        }
        if (root.equals (dirObj.getAbsolutePath ()) && files [i].getName ().equals ("JavaSnoop.jar")) {
            continue;
        }
        FileInputStream in = new FileInputStream (files [i].getAbsolutePath ());
        String fileWithoutRootDir = files [i].getAbsolutePath ();
        fileWithoutRootDir = fileWithoutRootDir.substring (root.length () + 1);
        fileWithoutRootDir = fileWithoutRootDir.replaceAll ("\\\\", "/");
        ZipEntry entry = new ZipEntry (fileWithoutRootDir);
        out.putNextEntry (entry);
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


private byte [] showRunningActions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer buff = new StringBuffer (2048);
    buff.append ("HTTP/1.0 200 OK\n");
    buff.append ("Content-Type: text/html\n");
    buff.append ("Pragma: no-cache\n");
    buff.append ("Cache-Control: no-cache\n\n");
    buff.append ("<html>\n");
    buff.append ("<table align='center' border='1'>\n");
    buff.append ("<tr>\n");
    buff.append ("<td nowrap>Device Index</td>\n");
    buff.append ("<td nowrap>Device Name</td>\n");
    buff.append ("<td nowrap>HashKey</td>\n");
    buff.append ("<td nowrap>Share Name</td>\n");
    buff.append ("<td nowrap>Usage Count</td>\n");
    buff.append ("<td nowrap>Is Running</td>\n");
    buff.append ("<td nowrap>Exit Code</td>\n");
    buff.append ("<td nowrap>Needs Reastart</td>\n");
    buff.append ("</tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    StreamProducerProcess [] producers = devList.getProducers ();
    for (int index = 0; index < producers.length; index ++) {
        StreamProducerProcess producer = producers [index];
        buff.append ("<tr>\n");
        buff.append ("<td nowrap>" + producer.getDeviceIndex () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getCaptureDevice ().getName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getKey () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getMemoryShareName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getUsageCount () + "</td>\n");
        buff.append ("<td nowrap>" + producer.isProducerRunning () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getExitCode () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getNeedsRestart () + "</td>\n");
        buff.append ("</tr>\n");
    }
    buff.append ("</table>\n");
    buff.append ("<br><br><br>\n");
    buff.append ("</html>");
    buff.append ("\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=225=-----==

public void newFile (ActionFormEvent event) throws PortletException {
    String userName = (String) ((Map) event.getActionRequest ().getAttribute (PortletRequest.USER_INFO)).get ("user.name");
    String sideParam = event.getActionRequest ().getParameter ("side");
    TextFieldBean textFieldBean = event.getTextFieldBean ("resourceName" + sideParam);
    String resourceName = textFieldBean.getValue ();
    UserData userData = (UserData) event.getActionRequest ().getPortletSession ().getAttribute ("userData");
    if (resourceName != null && ! resourceName.equals ("")) {
        try {
            String path = userData.getPath (sideParam);
            File f = new File (userData.getChrootDir () + path);
            if (! f.isDirectory ()) {
                f.mkdirs ();
            }
            File newFile = new File (userData.getChrootDir () + path + resourceName);
            newFile.createNewFile ();
            textFieldBean.setValue ("");
            readDirectories (userName, userData);
        } catch (IOException e) {
            log.error ("Unable to create new file", e);
            event.getActionResponse ().setRenderParameter ("errorMessage", "Unable to create newfile");
        }
    }
}


public static boolean copy (File source, File target) {
    try {
        if (! source.exists ()) return false;
        target.getParentFile ().mkdirs ();
        InputStream input = new FileInputStream (source);
        OutputStream output = new FileOutputStream (target);
        byte [] buf = new byte [1024];
        int len;
        while ((len = input.read (buf)) > 0) output.write (buf, 0, len);
        input.close ();
        output.close ();
        return true;
    } catch (Exception exc) {
        exc.printStackTrace ();
        return false;
    }
}


-----Function Pair=226=-----==

public void visitJavaClass (JavaClass clazz) throws Exception {
    if (dest.contains (clazz)) return;
    dest.add (clazz);
    ConstantPoolGen cpg = new ConstantPoolGen (clazz.getConstantPool ());
    level += 2;
    for (int i = 0; i < level; i ++) System.out.print (" ");
    System.out.println (clazz.getClassName () + ".class");
    JavaClass superclass = clazz.getSuperClass ();
    for (JavaClass sup = superclass; sup != null; sup = sup.getSuperClass ()) {
        if (subclasses.get (sup) == null) subclasses.put (sup, new HashSet ());
        ((HashSet) subclasses.get (sup)).add (clazz);
    }
    JavaClass [] interfaces = clazz.getAllInterfaces ();
    for (int i = 0; i < interfaces.length; i ++) {
        if (subclasses.get (interfaces [i]) == null) subclasses.put (interfaces [i], new HashSet ());
        ((HashSet) subclasses.get (interfaces [i])).add (clazz);
    }
    for (JavaClass sup = superclass; sup != null; sup = sup.getSuperClass ()) {
        visitJavaClass (sup);
        remarkMethods (sup, clazz, cpg);
    }
    for (int i = 0; i < interfaces.length; i ++) {
        visitJavaClass (interfaces [i]);
        remarkMethods (interfaces [i], clazz, cpg);
    }
    Field [] fields = clazz.getFields ();
    for (int i = 0; i < fields.length; i ++) {
        if (! fields [i].isStatic ()) visitJavaField (fields [i], clazz);
        else {
            Type t = fields [i].getType ();
            if (t instanceof ObjectType) load (t);
        }
    }
    level -= 2;
}


public boolean isDiff (File srcFile, File targetFile) {
    int buff_size = 1024;
    byte srcBuf [] = new byte [1024], targetBuf [] = new byte [1024];
    if (srcFile.length () != targetFile.length ()) return true;
    try {
        BufferedInputStream targetStream = new BufferedInputStream (new FileInputStream (targetFile));
        BufferedInputStream srcStream = new BufferedInputStream (new FileInputStream (srcFile));
        while (srcStream.read (srcBuf, 0, buff_size) != - 1 && targetStream.read (targetBuf, 0, buff_size) != - 1) {
            for (int i = 0; i < buff_size; i ++) {
                if (srcBuf [i] != targetBuf [i]) return true;
            }
        }
    } catch (FileNotFoundException e) {
        throw new RuntimeException (e);
    } catch (IOException e1) {
        throw new RuntimeException (e1);
    }
    return false;
}


-----Function Pair=227=-----=1=

public static void zip (Collection files, File zipFile) throws IOException {
    FileOutputStream fos = new FileOutputStream (zipFile);
    try {
        BufferedOutputStream bos = new BufferedOutputStream (fos);
        try {
            ZipOutputStream zos = new ZipOutputStream (bos);
            try {
                for (Iterator i = files.iterator (); i.hasNext ();) {
                    File file = (File) i.next ();
                    zos.putNextEntry (new ZipEntry (file.getName ()));
                    FileInputStream fis = new FileInputStream (file);
                    try {
                        BufferedInputStream bis = new BufferedInputStream (fis);
                        try {
                            while (true) {
                                int j = bis.read ();
                                if (j == - 1) {
                                    break;
                                }
                                zos.write (j);
                            }
                        } finally {
                            bis.close ();
                        }
                    } finally {
                        fis.close ();
                        zos.closeEntry ();
                    }
                }
            } finally {
                zos.close ();
            }
        } finally {
            bos.close ();
        }
    } finally {
        fos.close ();
    }
}


public void update (BackUpInfoFileGroup backedUpFiles, BackUpInfoFileGroup updateFiles, String filePath) {
    if (update == null) {
        update = new Update ();
    }
    try {
        File zipFile = new File (filePath);
        File tempFile = File.createTempFile (zipFile.getName (), null);
        tempFile.delete ();
        zipFile.renameTo (tempFile);
        ZipInputStream zis = new ZipInputStream (new FileInputStream (tempFile));
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipFile));
        ZipEntry entry = zis.getNextEntry ();
        while (entry != null) {
            if (entry.getName ().equals (FILE_INFO)) {
                entry = zis.getNextEntry ();
                continue;
            }
            else if (! update.isToUpdate (updateFiles, entry.getName ())) {
                zos.putNextEntry (new ZipEntry (entry.getName ()));
                int len;
                while ((len = zis.read (BUFFER)) > 0) {
                    zos.write (BUFFER, 0, len);
                }
            }
            entry = zis.getNextEntry ();
        }
        zis.close ();
        update.execute (updateFiles, zos);
        if (exportData == null) {
            exportData = new ExportData ();
        }
        exportData.execute (update.updateInformationFile (backedUpFiles, updateFiles), zos, FILE_INFO);
        zos.close ();
    } catch (IOException e) {
        throw new BackupException (e.getMessage ());
    }
}


-----Function Pair=228=-----==

private static boolean proguard (String caption, File normalJarFile, File progrdJarFile) {
    System.out.println ("proguard");
    try {
        String [] cmds = new String [9];
        cmds [0] = PATH_TO_JDK + "java";
        cmds [1] = "-jar";
        cmds [2] = BASE_DIR + "tools/proguard.jar";
        cmds [3] = "-include";
        cmds [4] = BASE_DIR + "tools/proguard.conf";
        cmds [5] = "-injars";
        cmds [6] = normalJarFile.getAbsolutePath ();
        cmds [7] = "-outjars";
        cmds [8] = progrdJarFile.getAbsolutePath ();
        Process proc = Runtime.getRuntime ().exec (cmds);
        ByteArrayOutputStream stdout = new ByteArrayOutputStream ();
        ByteArrayOutputStream stderr = new ByteArrayOutputStream ();
        Streams.asynchronousTransfer (proc.getInputStream (), stdout);
        Streams.asynchronousTransfer (proc.getErrorStream (), stderr);
        int exit = proc.waitFor ();
        System.out.println ("" + caption + "");
        if (stderr.size () != 0) {
            System.out.println ("" + Text.utf8 (stdout.toByteArray ()) + "");
            System.out.println ("" + Text.utf8 (stderr.toByteArray ()) + "");
        }
        if (exit != 0) {
            System.out.println ("Exit value: " + exit + "");
        }
        if (exit != 0) {
            return false;
        }
        return true;
    } catch (Exception exc) {
        System.out.println ("EXCEPTION: " + exc.getClass ().getName () + "");
        exc.printStackTrace ();
        return false;
    }
}


private byte [] showServerProperties (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (1024);
    String value = "";
    HashMap < String, String > options = null;
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Capture Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.deftype");
    options = new HashMap < String, String > ();
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int index = 0; index < capabilities.size (); index ++) {
        CaptureCapability capability = capabilities.get (index);
        options.put (new Integer (capability.getTypeID ()).toString (), capability.getName ());
    }
    out.append ("<tr><td align='left'>Default Capture Type</td><td>");
    out.append (htmlDropMenu (options, "Capture.deftype", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.deftype');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.path.details");
    out.append ("<tr><td align='left'>Capture Details Path</td><td>\n");
    out.append ("<input type='text' name='Capture.path.details' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.path.details');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.CaptureFailedTimeout");
    options = new HashMap < String, String > ();
    options.put ("003", "15 Seconds");
    options.put ("006", "30 Seconds");
    options.put ("012", "60 Seconds");
    options.put ("024", "128 Seconds");
    out.append ("<tr><td align='left'>Failed Capture Timeout</td><td>");
    out.append (htmlDropMenu (options, "Capture.CaptureFailedTimeout", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.CaptureFailedTimeout');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Schedule Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.end");
    out.append ("<tr><td align='left'>End Buffer Time</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.end' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.start");
    out.append ("<tr><td align='left'>Start Buffer Time</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.start' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.start');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.end.epg");
    out.append ("<tr><td align='left'>End Buffer EPG Addition</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.end.epg' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end.epg');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Email Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.server");
    out.append ("<tr><td align='left'>Email Server</td><td>\n");
    out.append ("<input type='text' name='email.server' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.server');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.from");
    out.append ("<tr><td align='left'>Email From Address</td><td>\n");
    out.append ("<input type='text' name='email.from' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.from.name");
    out.append ("<tr><td align='left'>Email From Name</td><td>\n");
    out.append ("<input type='text' name='email.from.name' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from.name');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.to");
    out.append ("<tr><td align='left'>Email To</td><td>\n");
    out.append ("<input type='text' name='email.to' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.to');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>File Browser Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("filebrowser.DirsAtTop");
    options = new HashMap < String, String > ();
    options.put ("0", "Bottom");
    options.put ("1", "Top");
    out.append ("<tr><td align='left'>Directories Shown At</td><td>");
    out.append (htmlDropMenu (options, "filebrowser.DirsAtTop", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.DirsAtTop');\" width='24' height='24'></td></tr>\n");
    value = store.getProperty ("filebrowser.masks");
    out.append ("<tr><td align='left'>Show Extensions</td><td>\n");
    out.append ("<input type='text' name='filebrowser.masks' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.masks');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("filebrowser.ShowWsPlay");
    options = new HashMap < String, String > ();
    options.put ("0", "False");
    options.put ("1", "True");
    out.append ("<tr><td align='left'>Show Play Now Link</td><td>");
    out.append (htmlDropMenu (options, "filebrowser.ShowWsPlay", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.ShowWsPlay');\" width='24' height='24'></td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Server Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("server.kbLED");
    options = new HashMap < String, String > ();
    options.put ("0", "Disabled");
    options.put ("1", "Enabled");
    out.append ("<tr><td align='left'>Keyboard LED Control</td><td>");
    out.append (htmlDropMenu (options, "server.kbLED", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('server.kbLED');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.wake.system");
    out.append ("<tr><td align='left'>Seconds for system wake up</td><td>\n");
    out.append ("<input type='text' name='Schedule.wake.system' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.wake.system');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("AutoDel.KeepFor");
    out.append ("<tr><td align='left'>Default keep for</td><td>\n");
    out.append ("<input type='text' name='AutoDel.KeepFor' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('AutoDel.KeepFor');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("EPG.ShowUnlinked");
    options = new HashMap < String, String > ();
    options.put ("0", "False");
    options.put ("1", "True");
    out.append ("<tr><td align='left'>Show Unlinked Schedules</td><td>");
    out.append (htmlDropMenu (options, "EPG.ShowUnlinked", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('EPG.ShowUnlinked');\" width='24' height='24'></tr>\n");
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "serverpropertie.html");
    template.replaceAll ("$properties", out.toString ());
    return template.getPageBytes ();
}


-----Function Pair=229=-----==

public File create (ArrayList sources, File parent, File target, Manifest manifest) {
    OverwriteValue policy = new OverwriteValue (overwritePolicy);
    overwritePolicy = NO;
    if (sources.size () <= 0) return null;
    try {
        boolean warnBeforeOverwritting = true;
        if (target != null) {
            chooser.setCurrentDirectory (target.getParentFile ());
            chooser.setSelectedFile (target);
        }
        else chooser.setSelectedFile (new File ("default.jar"));
        String targetName = OSPRuntime.chooseFilename (chooser);
        if (targetName == null) return null;
        if (! (targetName.toLowerCase ().endsWith (".jar") || targetName.toLowerCase ().endsWith (".zip"))) targetName = targetName + ".jar";
        else warnBeforeOverwritting = false;
        target = new File (targetName);
        if (org.opensourcephysics.controls.XML.forwardSlash (target.getAbsolutePath ()).equals (OSPRuntime.getLaunchJarPath ())) {
            String [] message = new String [] {res.getString ("JarTool.JarNotCreated"), res.getString ("JarTool.FileIsForbidden") + " " + target};
            JOptionPane.showMessageDialog ((JFrame) null, message, res.getString ("JarTool.Error"), JOptionPane.WARNING_MESSAGE);
            return create (sources, parent, target, manifest);
        }
        if (warnBeforeOverwritting && target.exists ()) {
            int selected = JOptionPane.showConfirmDialog (null, DisplayRes.getString ("DrawingFrame.ReplaceExisting_message") + " " + target.getName () + DisplayRes.getString ("DrawingFrame.QuestionMark"), DisplayRes.getString ("DrawingFrame.ReplaceFile_option_title"), JOptionPane.YES_NO_CANCEL_OPTION);
            if (selected != JOptionPane.YES_OPTION) return null;
        }
        JarTool builder = new JarTool (sources, parent, target, manifest, policy, ownerFrame);
        java.lang.Thread thread = new Thread (builder);
        thread.setPriority (Thread.NORM_PRIORITY);
        thread.start ();
        return target;
    } catch (Exception exception) {
        exception.printStackTrace ();
        return null;
    }
}


public IncludeEntry (XDOMParser parser, Node n) throws TransformerException {
    extractOutput = Boolean.parseBoolean (XDOMParser.getAttributeValue (n, "extractOutput", "false"));
    NodeIterator niP = parser.getXPathAPI ().selectNodeIterator (n, "provides");
    Node nP = niP.nextNode ();
    while (nP != null) {
        String pathTemplate = XDOMParser.getAttributeValue (nP, "path-template");
        String locationTemplate = XDOMParser.getAttributeValue (nP, "location-template");
        providesEntries.add (new ProvidesEntry (pathTemplate, locationTemplate));
        nP = niP.nextNode ();
    }
    niP.detach ();
    NodeIterator niPA = parser.getXPathAPI ().selectNodeIterator (n, "provides-all");
    Node nPA = niPA.nextNode ();
    while (nPA != null) {
        String pathTemplate = XDOMParser.getAttributeValue (nPA, "path-template");
        providesAllEntries.add (new ProvidesAllEntry (pathTemplate));
        nPA = niPA.nextNode ();
    }
    niPA.detach ();
    niPA = parser.getXPathAPI ().selectNodeIterator (n, "deploy");
    nPA = niPA.nextNode ();
    while (nPA != null) {
        String platform = XDOMParser.getAttributeValue (nPA, "platform", DeployEntry.PLATFORM_ALLPLATFORMS);
        deployEntries.add (new DeployEntry (platform));
        nPA = niPA.nextNode ();
    }
    niPA.detach ();
    niPA = parser.getXPathAPI ().selectNodeIterator (n, "product");
    nPA = niPA.nextNode ();
    while (nPA != null) {
        String productName = XDOMParser.getAttributeValue (nPA, "name", DeployEntry.PLATFORM_ALLPLATFORMS);
        productNames.add (productName);
        nPA = niPA.nextNode ();
    }
    niPA.detach ();
}


-----Function Pair=230=-----==

public static boolean copy (File source, File target) {
    try {
        if (! source.exists ()) return false;
        target.getParentFile ().mkdirs ();
        InputStream input = new FileInputStream (source);
        OutputStream output = new FileOutputStream (target);
        byte [] buf = new byte [1024];
        int len;
        while ((len = input.read (buf)) > 0) output.write (buf, 0, len);
        input.close ();
        output.close ();
        return true;
    } catch (Exception exc) {
        exc.printStackTrace ();
        return false;
    }
}


public void saveAttributes (Attributes a) throws IOException {
    String extension = fileresource.getUpperCaseExtension ();
    if ("XML".equals (extension)) {
    }
    else {
        File file = new File (getBinaryFilename ());
        if (! file.exists ()) {
            File parent = new File (file.getParent ());
            if (! parent.exists ()) {
                parent.mkdir ();
            }
        }
        FileOutputStream fos = new FileOutputStream (file);
        ZipOutputStream zout = new ZipOutputStream (fos);
        zout.putNextEntry (new ZipEntry ("Attributes"));
        DataOutputStream out = new DataOutputStream (zout);
        saveAttributesBinary (out, a);
        out.close ();
        fos.close ();
    }
}


-----Function Pair=231=-----==

private void updateRapidMiner (InputStream openStream, String version) throws IOException {
    File updateDir = new File (FileSystemService.getRapidMinerHome (), "update");
    if (! updateDir.exists ()) {
        if (! updateDir.mkdir ()) {
            throw new IOException ("Cannot create update directory. Please ensure you have administrator permissions.");
        }
    }
    if (! updateDir.canWrite ()) {
        throw new IOException ("Cannot write to update directory. Please ensure you have administrator permissions.");
    }
    File updateFile = new File (updateDir, "rmupdate-" + version + ".jar");
    Tools.copyStreamSynchronously (openStream, new FileOutputStream (updateFile), true);
    File ruInstall = new File (FileSystemService.getRapidMinerHome (), "RUinstall");
    ZipFile zip = new ZipFile (updateFile);
    Enumeration < ? extends ZipEntry > en = zip.entries ();
    while (en.hasMoreElements ()) {
        ZipEntry entry = en.nextElement ();
        if (entry.isDirectory ()) {
            continue;
        }
        String name = entry.getName ();
        if ("META-INF/UPDATE".equals (name)) {
            Tools.copyStreamSynchronously (zip.getInputStream (entry), new FileOutputStream (new File (updateDir, "UPDATE")), true);
            continue;
        }
        if (name.startsWith ("rapidminer/")) {
            name = name.substring ("rapidminer/".length ());
        }
        File dest = new File (ruInstall, name);
        File parent = dest.getParentFile ();
        if (parent != null && ! parent.exists ()) {
            parent.mkdirs ();
        }
        Tools.copyStreamSynchronously (zip.getInputStream (entry), new FileOutputStream (dest), true);
    }
    zip.close ();
    updateFile.delete ();
    LogService.getRoot ().info ("Prepared RapidMiner for update. Restart required.");
}


public void run () {
    Object [] container = containerList.getSelectedValues ();
    if (container.length == 0) {
        JOptionPane.showMessageDialog (parent, "no containers are selected", "error", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    try {
        JFileChooser chooser = new JFileChooser ();
        chooser.setMultiSelectionEnabled (false);
        chooser.setDialogTitle ("Export to zip");
        int returnVal = chooser.showOpenDialog (parent);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File file = chooser.getSelectedFile ();
            if (file.exists ()) {
                if (JOptionPane.showConfirmDialog (parent, "File exists - overwrite?", "confirm", JOptionPane.OK_CANCEL_OPTION) != JOptionPane.OK_OPTION) {
                    return;
                }
            }
            ProgressMonitor progressMonitor = new ProgressMonitor (parent, "Exporting selected containers", "Preparing " + chooser.getSelectedFile ().getCanonicalPath (), 0, container.length);
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));
            String containerName;
            for (int i = 0; i < container.length; i ++) {
                containerName = ((JLabel) container [i]).getText ();
                progressMonitor.setNote ("Exporting " + containerName);
                progressMonitor.setProgress (i);
                zipContainer (containerName, out);
            }
            out.close ();
            progressMonitor.close ();
        }
    } catch (Throwable t) {
        t.printStackTrace ();
        JOptionPane.showMessageDialog (parent, "Error adding document (" + t.getMessage () + ")");
        logger.severe (t.getMessage ());
    }
}


-----Function Pair=232=-----==

private String GetClob (CLOB clob) throws Exception {
    if (clob == null) return null;
    Reader is = null;
    StringWriter so = null;
    try {
        is = clob.getCharacterStream ();
        so = new StringWriter ();
        int b;
        while ((b = is.read ()) != - 1) {
            so.write (b);
        }
        return so.toString ();
    } finally {
        if (so != null) try {
            so.close ();
        } catch (Exception e) {
        }
        if (is != null) try {
            is.close ();
        } catch (Exception e) {
        }
    }
}


private static void handleException (final Shell shell, Throwable exception) {
    if (exception instanceof InvocationTargetException) {
        exception = ((InvocationTargetException) exception).getTargetException ();
    }
    IStatus status = null;
    if (exception instanceof CoreException) {
        status = ((CoreException) exception).getStatus ();
    }
    if (status == null) {
        status = new Status (Status.ERROR, EEditPlugin.ID, exception.getMessage (), exception);
    }
    ResourcesPlugin.getPlugin ().getLog ().log (status);
    final IStatus istatus = status;
    PlatformUI.getWorkbench ().getDisplay ().syncExec (new Runnable () {
        public void run () {
            ErrorDialog.openError (shell, "Error during export", istatus.getMessage (), istatus);
        }
    }
    );
}


-----Function Pair=233=-----==

private InputStream openStream (URL url, ProgressListener listener, int minProgress, int maxProgress) throws IOException {
    HttpURLConnection con = (HttpURLConnection) url.openConnection ();
    con.setDoInput (true);
    con.setDoOutput (false);
    String lengthStr = con.getHeaderField ("Content-Length");
    InputStream urlIn;
    try {
        urlIn = con.getInputStream ();
    } catch (IOException e) {
        throw new IOException (con.getResponseCode () + ": " + con.getResponseMessage (), e);
    }
    if (lengthStr == null || lengthStr.isEmpty ()) {
        LogService.getRoot ().warning ("Server did not send content length.");
        return urlIn;
    }
    else {
        try {
            long length = Long.parseLong (lengthStr);
            return new ProgressReportingInputStream (urlIn, listener, minProgress, maxProgress, length);
        } catch (NumberFormatException e) {
            LogService.getRoot ().log (Level.WARNING, "Server sent illegal content length: " + lengthStr, e);
            return urlIn;
        }
    }
}


private void addTask () {
    if (ui.tabs_tasks.currentIndex () == 0) {
        Boolean customflag = false;
        Algorithm algorithm = null;
        if (ui.tab_algorithm.currentIndex () == 0) {
            String alg = ui.select_algorithm.currentText ();
            algorithm = new SortingAlgorithm (alg, alg);
        }
        else {
            customflag = true;
            String alg = ui.txt_classname.toPlainText ();
            String customtype = text2CustomType (ui.custom_type.currentText ()) + "";
            System.out.println ("Customtype: " + customtype);
            algorithm = new CustomAlgorithm (alg, alg, customtype);
        }
        int arrayType = text2ArrayType (ui.select_arraytype.currentText ());
        int startsize = ui.spin_startsize.value ();
        int maxsize = ui.spin_maxsize.value ();
        int stepsize = ui.spin_stepsize.value ();
        System.out.println (startsize);
        AlgorithmTask task = new AlgorithmTask (algorithm, startsize, maxsize, stepsize, arrayType);
        ceo.getTaskHolder ().addTask (task);
        ui.tasklist.addRow (new String [] {task.getAlgorithm ().getClassName (), task.getArrayType () + "", "" + startsize, "" + maxsize, "" + stepsize});
        if (! customflag) {
            ui.tasklist.setDefaultAlgorithm (ui.tasklist.rowCount () - 1);
        }
    }
    else if (ui.tabs_tasks.currentIndex () == 1) {
        int startsize = ui.spin_startsize_function.value ();
        int maxsize = ui.spin_maxsize_function.value ();
        int stepsize = ui.spin_stepsize_function.value ();
        Function task = new Function (ui.txt_function.text (), startsize, stepsize, maxsize);
        ceo.getTaskHolder ().addTask (task);
        ui.tasklist.addRow (new String [] {task.getExpression (), "", startsize + "", "" + maxsize, "" + stepsize});
        ui.tasklist.setFunction (ui.tasklist.rowCount () - 1);
    }
}


-----Function Pair=234=-----==

public void unpack (InputStream in0, JarOutputStream out) throws IOException {
    assert (Utils.currentInstance.get () == null);
    TimeZone tz = (_props.getBoolean (Utils.PACK_DEFAULT_TIMEZONE)) ? null : TimeZone.getDefault ();
    try {
        Utils.currentInstance.set (this);
        if (tz != null) TimeZone.setDefault (TimeZone.getTimeZone ("UTC"));
        final int verbose = _props.getInteger (Utils.DEBUG_VERBOSE);
        BufferedInputStream in = new BufferedInputStream (in0);
        if (Utils.isJarMagic (Utils.readMagic (in))) {
            if (verbose > 0) Utils.log.info ("Copying unpacked JAR file...");
            Utils.copyJarFile (new JarInputStream (in), out);
        }
        else if (_props.getBoolean (Utils.DEBUG_DISABLE_NATIVE)) {
            (new DoUnpack ()).run (in, out);
            in.close ();
            Utils.markJarFile (out);
        }
        else {
            (new NativeUnpack (this)).run (in, out);
            in.close ();
            Utils.markJarFile (out);
        }
    } finally {
        _nunp = null;
        Utils.currentInstance.set (null);
        if (tz != null) TimeZone.setDefault (tz);
    }
}


protected void fromStream (File file, InputStream in, IItemProgressMonitor monitor) throws CancelParsingException, ClassNotFoundException {
    FileStorageUtil.getSAXParser ().setContentHandler (new CollectionFileContentHandler (this, file, monitor));
    try {
        FileStorageUtil.getSAXParser ().parse (new InputSource (in));
    } catch (CancelParsingException e) {
        throw e;
    } catch (IOException e) {
    } catch (SAXException e) {
    }
    m_categoryRoot.reset ();
    for (IItem item : this) for (String strCategoryRef : item.getCategoryRefs ()) {
        Category category = getCategoryByRef (strCategoryRef);
        if (category != null) category.addItem (item);
    }
    fireCollectionLoaded ();
}


-----Function Pair=235=-----==

public void zipDir (String dir2zip, ZipOutputStream zos, String callDir) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        if (manifest == false) {
            File f = new File (zipDir, "META-INF/manifest.xml");
            FileInputStream fis = new FileInputStream (f);
            String n = "META-INF/manifest.xml";
            ZipEntry anEntry = new ZipEntry (n);
            System.out.println ("Archiving:" + n);
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            manifest = true;
        }
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (filePath, zos, callDir);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String relativePath = f.getPath ();
            relativePath = relativePath.replace (callDir + File.separator, "");
            relativePath = relativePath.replace ("\\", "/");
            if (relativePath.contains ("manifest") == true) {
                continue;
            }
            ZipEntry anEntry = new ZipEntry (relativePath);
            zos.putNextEntry (anEntry);
            System.out.println ("Archiving:" + relativePath);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
        System.err.println ("Error during archiving.");
    }
}


public void convertAction (File dirOut, File d) throws Exception {
    String [] files = d.list ();
    for (int i = 0; i < files.length; i ++) {
        File file = new File (d, files [i]);
        if (file.isDirectory ()) {
            convertAction (dirOut, file);
        }
        else if (files [i].toLowerCase ().endsWith (".lrf")) {
            String fi = files [i];
            String oname = d.getAbsolutePath () + File.separator + fi.substring (0, fi.length () - 4);
            String ff = oname.substring (root.getAbsolutePath ().length () + 1);
            String aux = d.getAbsolutePath () + File.separator + fi;
            File auxFile = new File (aux);
            boolean genPDF = pdf, genHTML = html, genRTF = rtf, genXML = xml, genEPUB = epub;
            if (noo) {
                if (dirOut == null) {
                    if (genPDF && new File (oname + ".pdf").exists ()) genPDF = false;
                    if (genRTF && new File (oname + ".rtf").exists ()) genRTF = false;
                    if (genXML && new File (oname + ".xml").exists ()) genXML = false;
                    if (genEPUB && new File (oname + ".epub").exists ()) genEPUB = false;
                    if (genHTML && new File (oname + ".html").exists ()) genHTML = false;
                }
                else {
                    if (genPDF && new File (dirOut, ff + ".pdf").exists ()) genPDF = false;
                    if (genRTF && new File (dirOut, ff + ".rtf").exists ()) genRTF = false;
                    if (genXML && new File (dirOut, ff + ".xml").exists ()) genXML = false;
                    if (genEPUB && new File (dirOut, ff + ".epub").exists ()) genEPUB = false;
                    if (genHTML && new File (dirOut, ff + ".html").exists ()) genHTML = false;
                }
            }
            Book book = null;
            if (genPDF || genHTML || genRTF || genXML || genEPUB) book = new Book (auxFile);
            if (genPDF) {
                dumpToPDF (dirOut, oname, ff, book, repl);
            }
            if (genHTML) {
                dumpToHTML (dirOut, oname, ff, book, repl);
            }
            if (genRTF) {
                dumpToRTF (dirOut, oname, ff, book, repl);
            }
            if (genXML) {
                dumpToXML (dirOut, oname, ff, book, repl);
            }
            if (genEPUB) {
                dumpToEpub (dirOut, oname, ff, book, repl);
            }
            if ((pdf && ! genPDF)) System.out.println ("Skipping " + ff + ".pdf...");
            if ((html && ! genHTML)) System.out.println ("Skipping " + ff + ".html...");
            if ((xml && ! genXML)) System.out.println ("Skipping " + ff + ".xml...");
            if ((rtf && ! genRTF)) System.out.println ("Skipping " + ff + ".rtf...");
            if ((epub && ! genEPUB)) System.out.println ("Skipping " + ff + ".epub...");
        }
    }
}


-----Function Pair=236=-----=1=

public void ajouterAuZip (String nomFile, Vector nomFilms, int nbFilm) throws FileNotFoundException {
    FileOutputStream fichierZip = new FileOutputStream (nomFile);
    ZipOutputStream zin = new ZipOutputStream (fichierZip);
    try {
        ZipEntry base = new ZipEntry ("Base.xml");
        zin.putNextEntry (base);
        ZipEntry [] photo = new ZipEntry [nbFilm];
        zin.setLevel (9);
        byte [] buffer = new byte [512 * 1024];
        int nbLecture;
        java.io.FileInputStream sourceFile = new java.io.FileInputStream (new File ("Base.xml"));
        while ((nbLecture = sourceFile.read (buffer)) != - 1) {
            zin.write (buffer, 0, nbLecture);
        }
        zin.closeEntry ();
        base = new ZipEntry ("film.xsl");
        zin.putNextEntry (base);
        nbLecture = 0;
        sourceFile = new java.io.FileInputStream (new File ("film.xsl"));
        while ((nbLecture = sourceFile.read (buffer)) != - 1) {
            zin.write (buffer, 0, nbLecture);
        }
        zin.closeEntry ();
        int i = 0;
        while (i < nbFilm) {
            File image = new File ("image/" + nomFilms.get (i).toString () + ".jpg");
            if (image.exists ()) {
                java.io.FileInputStream photoFile = new java.io.FileInputStream (image);
                photo [i] = new ZipEntry ("image/" + nomFilms.get (i).toString () + ".jpg");
                zin.putNextEntry (photo [i]);
                while ((nbLecture = photoFile.read (buffer)) != - 1) {
                    zin.write (buffer, 0, nbLecture);
                }
                zin.closeEntry ();
                photoFile.close ();
            }
            i ++;
        }
    } catch (java.io.FileNotFoundException fe) {
    } catch (java.io.IOException e) {
    } finally {
        try {
            zin.close ();
        } catch (Exception e) {
        }
    }
}


private static void zipRecursively (ZipOutputStream out, File dir, String zippath, String [] filenames) {
    byte [] buf = new byte [1024];
    try {
        for (int i = 0; i < filenames.length; i ++) {
            File f = new File (dir, filenames [i]);
            if (f.isDirectory ()) {
                String [] subfiles = f.list ();
                zipRecursively (out, f, zippath + f.getName () + "/", subfiles);
            }
            else {
                FileInputStream in = new FileInputStream (new File (dir, filenames [i]));
                String entrypath = zippath + filenames [i];
                out.putNextEntry (new ZipEntry (entrypath));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=237=-----==

public static void setValueInObject (Object object, List < Field > path, Object value) {
    Iterator < Field > fit = path.iterator ();
    Object target = object;
    while (fit.hasNext () && target != null) {
        Field f = fit.next ();
        if (! fit.hasNext ()) {
            try {
                f.set (target, value);
            } catch (IllegalArgumentException e) {
                logger.error ("Could not restore property value for " + f.getName () + " in class " + target.getClass ().getName (), e);
            } catch (IllegalAccessException e) {
                logger.error ("Could not restore property value for " + f.getName () + " in class " + target.getClass ().getName (), e);
            }
        }
        else {
            target = OpPrototype.getFieldValue (target, f);
        }
    }
}


private void geocodeMissingStop (String stopname, String [] coordinates) throws MalformedURLException, UnsupportedEncodingException, XPathExpressionException, IOException, ParserConfigurationException, SAXException {
    float [] coordFloat = {- 999999, - 999999};
    String broadenedStopname;
    String token;
    StringTokenizer st;
    geocodeStop (stopname, coordFloat);
    if ((coordFloat [0] == - 999999 || coordFloat [1] == - 999999) && stopname.contains ("/")) {
        broadenedStopname = "";
        st = new StringTokenizer (stopname, ",");
        while (st.hasMoreTokens ()) {
            token = st.nextToken ();
            if (token.contains ("/")) token = token.substring (0, token.indexOf ("/"));
            if (broadenedStopname.length () > 0) broadenedStopname += ", ";
            broadenedStopname += token;
        }
        if (! broadenedStopname.equals (stopname)) {
            stopname = broadenedStopname;
            geocodeStop (stopname, coordFloat);
        }
    }
    if ((coordFloat [0] == - 999999 || coordFloat [1] == - 999999) && stopname.contains ("(")) {
        broadenedStopname = "";
        st = new StringTokenizer (stopname, ",");
        while (st.hasMoreTokens ()) {
            token = st.nextToken ();
            if (token.contains ("(")) token = token.substring (0, token.indexOf ("("));
            if (broadenedStopname.length () > 0) broadenedStopname += ", ";
            broadenedStopname += token;
        }
        if (! broadenedStopname.equals (stopname)) {
            stopname = broadenedStopname;
            geocodeStop (stopname, coordFloat);
        }
    }
    while ((coordFloat [0] == - 999999 || coordFloat [1] == - 999999) && stopname.lastIndexOf (",") >= 0) {
        stopname = stopname.substring (0, stopname.lastIndexOf (","));
        geocodeStop (stopname, coordFloat);
    }
    if (coordFloat [0] == - 999999) coordinates [0] = "OpenRequired";
    else coordinates [0] = "" + coordFloat [0];
    if (coordFloat [1] == - 999999) coordinates [1] = "OpenRequired";
    else coordinates [1] = "" + coordFloat [1];
}


-----Function Pair=238=-----==

public ActionForward execute (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    ActionErrors errors = new ActionErrors ();
    HttpSession session = request.getSession ();
    User voUser = (User) session.getAttribute ("voUser");
    VO virtObs = (VO) session.getAttribute ("vobean");
    if (null == virtObs) {
        session.removeAttribute ("currentPage");
        return (mapping.findForward ("logon"));
    }
    if (voUser == null) {
        session.removeAttribute ("currentPage");
        log.error ("Session is missing or has expired for client from " + request.getRemoteAddr ());
        errors.add (ActionErrors.GLOBAL_ERROR, new ActionError ("error.session.nouser"));
        saveErrors (request, errors);
        return (mapping.findForward ("logon"));
    }
    if (! voUser.isAnonymous ()) {
        String objectId = request.getParameter ("objId");
        String action = request.getParameter ("action");
        String taskValue = request.getParameter ("task");
        if (null != objectId && objectId.length () > 0 && null != action) {
            if (action.equalsIgnoreCase ("remove")) {
                removeBasketObject (voUser.getProfileName (), objectId);
            }
            if (action.equalsIgnoreCase ("saveNote") && null != request.getParameter ("noteText")) {
                noteBasketObject (voUser.getProfileName (), objectId, request.getParameter ("noteText"));
            }
        }
        if (null != action && action.equalsIgnoreCase ("archive")) {
            archiveBasketObjects (voUser.getProfileName (), request, false);
        }
        if (null != action && action.equalsIgnoreCase ("taskSel")) {
            if (null != taskValue && taskValue.equalsIgnoreCase ("archive")) {
                archiveBasketObjects (voUser.getProfileName (), request, true);
            }
            if (null != taskValue && taskValue.equalsIgnoreCase ("delete")) {
                String [] items = request.getParameterValues ("selectedItem");
                for (int i = 0; i < items.length; i ++) {
                    removeBasketObject (voUser.getProfileName (), items [i].toString ());
                }
            }
        }
        return (mapping.findForward ("success"));
    }
    else {
        session.removeAttribute ("currentPage");
        log.error ("User from " + request.getRemoteAddr () + " is not authorize to use this page.");
        errors.add (ActionErrors.GLOBAL_ERROR, new ActionError ("error.voUser.authorize"));
        saveErrors (request, errors);
        return (mapping.findForward ("logon"));
    }
}


public void validatorXSL (Workbook workbook) throws ApplicationException {
    int numOfSheets = workbook.getNumberOfSheets ();
    for (int i = 0; i < numOfSheets; i ++) {
        Sheet sheet = workbook.getSheet (i);
        for (int j = 1; j < sheet.getRows (); j ++) {
            Cell [] cellAry = sheet.getRow (j);
            try {
                for (int k = 0; k < cellAry.length; k ++) {
                    if (k == 1 && ! Utility.isEmpty (cellAry [1].getContents ())) {
                        if (Utility.isEmpty (cellAry [k - 1].getContents ()) || cellAry [k - 1].getContents () == null) {
                            throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
                        }
                    }
                    else if (k == 2 && ! Utility.isEmpty (cellAry [2].getContents ())) {
                        if (Utility.isEmpty (cellAry [k - 1].getContents ()) || cellAry [k - 1].getContents () == null) {
                            throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
                        }
                    }
                    if (k == 2) {
                        String [] splitAry = TextUtility.splitString (TextUtility.noNull (cellAry [2].getContents ()).trim (), "//");
                        for (int loop = 0; loop < splitAry.length; loop ++) {
                            TextUtility.stringValidation (splitAry [loop]);
                        }
                    }
                    else {
                        TextUtility.stringValidation (cellAry [k].getContents ());
                    }
                }
            } catch (ApplicationException ex) {
                throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
            }
        }
    }
}


-----Function Pair=239=-----==

public static void createBPR (File destinationFile, String processName, String bpel, String wsdl, String pdd, String cat, Vector < String > extWSDLs) {
    try {
        ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (destinationFile));
        zout.setMethod (ZipOutputStream.DEFLATED);
        String mani = "Manifest-Version: 1.0\n Ant-Version: Apache Ant 1.6.5\n Created-By: 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-14ubuntu7) (Free/nSoftware Foundation, Inc.)";
        addToZip (zout, processName + ".bpel", bpel, "bpel/");
        addToZip (zout, "MANIFEST.MF", mani, "META-INF/");
        addToZip (zout, "wsdlCatalog.xml", cat, "META-INF/");
        addToZip (zout, processName + "Defs.wsdl", wsdl, "wsdl/");
        addToZip (zout, processName + ".pdd", pdd, "");
        Iterator < String > it = extWSDLs.iterator ();
        int wsdlNumber = 1;
        while (it.hasNext ()) {
            addToZip (zout, wsdlNumber + ".wsdl", it.next (), "");
            wsdlNumber ++;
        }
        zout.close ();
    } catch (FileNotFoundException f) {
        f.printStackTrace ();
    } catch (IOException i) {
        i.printStackTrace ();
    }
}


private void createJAR (String currentPath, String fullName, ArrayList < File > files) {
    try {
        FileOutputStream fos = new FileOutputStream (fullName);
        JarOutputStream jos = new JarOutputStream (fos);
        for (int i = 0; i < files.size (); i ++) {
            myProcess.currentFile = currentPath + files.get (i);
            myProcess.currentProgress = 0;
            myProcess.totalProgress = ((i * 100) / files.size ());
            final long length = new File (myProcess.currentFile).length ();
            FileInputStream fis = new FileInputStream (myProcess.currentFile);
            jos.putNextEntry (new ZipEntry (myProcess.currentFile));
            byte [] buf = new byte [1024];
            int len = 0;
            int total = 0;
            while ((len = fis.read (buf)) > 0) {
                total += len;
                jos.write (buf, 0, len);
                myProcess.currentProgress = (int) (total * 100 / length);
                if (myProcess.cancel) {
                    logger.info ("Cancel packing.");
                    fis.close ();
                    jos.close ();
                    fos.close ();
                    return;
                }
            }
            jos.closeEntry ();
            fis.close ();
        }
        jos.close ();
        fos.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    myProcess.totalProgress = 100;
    MainGUI.app.getSource ().refreshFiles ();
}


-----Function Pair=240=-----==

public void zip_compressFiles () throws Exception {
    FileInputStream in = null;
    File f1 = new File ("C:\\WINDOWS\\regedit.exe");
    File f2 = new File ("C:\\WINDOWS\\win.ini");
    File file = new File ("C:\\" + NTUtil.class.getName () + ".zip");
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));
    out.putNextEntry (new ZipEntry ("regedit.exe"));
    in = new FileInputStream (f1);
    while (in.available () > 0) {
        out.write (in.read ());
    }
    in.close ();
    out.closeEntry ();
    out.putNextEntry (new ZipEntry ("win.ini"));
    in = new FileInputStream (f2);
    while (in.available () > 0) {
        out.write (in.read ());
    }
    in.close ();
    out.closeEntry ();
    out.close ();
}


private ImageIcon loadIcon (String resPrefix, int PanelNo, boolean tryBaseIcon) throws ResourceNotFoundException, IOException {
    ResourceManager rm = ResourceManager.getInstance ();
    ImageIcon icon = null;
    String iconext = this.getIconResourceNameExtension ();
    if (tryBaseIcon) {
        try {
            icon = rm.getImageIconResource (resPrefix);
        } catch (Exception e) {
            icon = rm.getImageIconResource (resPrefix + "." + PanelNo + iconext);
        }
    }
    else {
        icon = rm.getImageIconResource (resPrefix + "." + PanelNo + iconext);
    }
    return (icon);
}


-----Function Pair=241=-----==

private Collection < EdgeMappingDescriptor > loadMapping (InputStream in) throws IOException, ParseException, MalformedPathException {
    TreeSet < EdgeMappingDescriptor > ds = new TreeSet < EdgeMappingDescriptor > ();
    BufferedReader br = new BufferedReader (new InputStreamReader (in));
    String line = null;
    int lineCount = 0;
    while ((line = br.readLine ()) != null) {
        lineCount ++;
        String [] cols = line.split ("\t");
        if (cols.length == 2) {
            String name = cols [0].trim ();
            String path = cols [1].trim ();
            EdgeMappingDescriptor d = new EdgeMappingDescriptor (name, path);
            d.validate ();
            ds.add (d);
        }
        else if (line.trim ().equals ("")) {
        }
        else {
            throw new ParseException ("Invalid number of columns", lineCount);
        }
    }
    br.close ();
    return ds;
}


public static Boolean compress (ArrayList < String > aFiles, String sDestinationFilename) {
    BufferedInputStream oOrigin = null;
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    Iterator < String > oIterator;
    byte [] aData;
    try {
        oDestination = new FileOutputStream (sDestinationFilename);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        aData = new byte [BUFFER_SIZE];
        oIterator = aFiles.iterator ();
        while (oIterator.hasNext ()) {
            String sFilename = (String) oIterator.next ();
            FileInputStream fisInput = new FileInputStream (sFilename);
            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);
            ZipEntry oEntry = new ZipEntry (sFilename);
            oOutput.putNextEntry (oEntry);
            int iCount;
            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {
                oOutput.write (aData, 0, iCount);
            }
            oOrigin.close ();
        }
        oOutput.close ();
    } catch (Exception e) {
        AgentLogger.getInstance ().error (e);
        return false;
    }
    return true;
}


-----Function Pair=242=-----=1=

private void addDir (File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (files [i], out);
            continue;
        }
        String dir = dirObj.toString ();
        dir = dir.substring (dir.indexOf (File.separator) + 1);
        FileInputStream in = new FileInputStream (dirObj + File.separator + files [i].getName ());
        out.putNextEntry (new ZipEntry (dir + File.separator + files [i].getName ()));
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


private void buildExportZipFile (String parentDirectory, ZipOutputStream zipOutputStream, File [] files, int step) {
    try {
        for (int i = 0; i < files.length; i ++) {
            exportProgressDialog.setBarValue (step ++);
            if (files [i].isDirectory ()) {
                if (parentDirectory.equals ("")) {
                    ZipEntry newZipEntry = new ZipEntry (files [i].getName () + "/");
                    zipOutputStream.putNextEntry (newZipEntry);
                    zipOutputStream.closeEntry ();
                    zipOutputStream.flush ();
                    File [] subFiles = files [i].listFiles ();
                    buildExportZipFile (files [i].getName (), zipOutputStream, subFiles, step);
                }
                else {
                    ZipEntry newZipEntry = new ZipEntry (parentDirectory + System.getProperty ("file.separator") + files [i].getName () + "/");
                    zipOutputStream.putNextEntry (newZipEntry);
                    zipOutputStream.closeEntry ();
                    zipOutputStream.flush ();
                    File [] subFiles = files [i].listFiles ();
                    buildExportZipFile (parentDirectory + System.getProperty ("file.separator") + files [i].getName (), zipOutputStream, subFiles, step);
                }
            }
            else {
                ZipEntry newZipEntry;
                if (parentDirectory.equals ("")) {
                    newZipEntry = new ZipEntry (files [i].getName ());
                }
                else {
                    newZipEntry = new ZipEntry (parentDirectory + System.getProperty ("file.separator") + files [i].getName ());
                }
                zipOutputStream.putNextEntry (newZipEntry);
                InputStream is = new FileInputStream (files [i]);
                byte [] buf = new byte [4096];
                int len;
                while ((len = is.read (buf)) > 0) {
                    zipOutputStream.write (buf, 0, len);
                }
                is.close ();
                zipOutputStream.closeEntry ();
                zipOutputStream.flush ();
            }
        }
    } catch (Exception exp) {
        exp.printStackTrace ();
    }
}


-----Function Pair=243=-----==

private void readObject (ObjectInputStream in) throws ClassNotFoundException, IOException {
    defaultInit ();
    sequencer = new FrinikaSequencer ();
    try {
        sequencer.open ();
        attachTootNotifications ();
        midiResource = new MidiResource (sequencer);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    renderer = new FrinikaRenderer (this);
    in.defaultReadObject ();
    createSequence ();
    if (synthSettings != null || externalMidiDevices != null) {
        if (midiDeviceDescriptors != null) {
            this.midiDeviceDescriptors.clear ();
        }
        else {
            this.midiDeviceDescriptors = new ArrayList < MidiDeviceDescriptor > ();
        }
        this.midiDeviceDescriptorMap = new HashMap < MidiDevice, MidiDeviceDescriptor > ();
        for (SynthSettings synthSetup : synthSettings) {
            SynthRack synthRack = new SynthRack (null);
            try {
                MidiDevice midiDevice = new SynthWrapper (this, synthRack);
                synthRack.loadSynthSetup (synthSetup);
                addMidiOutDevice (midiDevice);
                if (! synthSetup.hasProgramChangeEvent ()) {
                    FrinikaSynthRackDescriptor.fixLaneProgramChange (this, midiDevice);
                }
            } catch (MidiUnavailableException e) {
                e.printStackTrace ();
            }
        }
        if (externalMidiDevices != null) {
            for (String name : externalMidiDevices) {
                MidiDevice dev = MidiHub.getMidiOutDeviceByName (name);
                if (dev == null) {
                    System.out.println (" Failed to find MidiDevice " + name);
                }
                else {
                    SynthWrapper externMidi = new SynthWrapper (this, dev);
                    try {
                        externMidi.open ();
                    } catch (MidiUnavailableException e) {
                        System.out.println (" Failed to open MidiDevice " + name);
                        e.printStackTrace ();
                    }
                    try {
                        addMidiOutDevice (externMidi);
                    } catch (MidiUnavailableException e) {
                        System.out.println (" Failed to add MidiDevice " + name);
                        e.printStackTrace ();
                    }
                }
            }
        }
    }
    else {
        installMidiDevices ();
    }
    validate ();
    projectLane.onLoad ();
    if (tempoList == null) {
        tempoList = new TempoList (sequence.getResolution (), this);
        tempoList.add (0, tempo);
    }
    tempoList.reco ();
    sequencer.setTempoList (tempoList);
    sequencer.setLoopStartPoint (loopStartPoint);
    sequencer.setLoopEndPoint (loopEndPoint);
    sequencer.setLoopCount (loopCount);
    postInit ();
    rebuildGUI ();
}


public void decompressWorkflow (String file, String prefix) {
    System.out.println ("******************-" + file);
    try {
        BufferedOutputStream dest = null;
        BufferedInputStream is = null;
        ZipEntry entry;
        ZipFile zipfile = new ZipFile (file);
        Enumeration e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            System.out.println ("Extracting: " + entry.getName ());
            is = new BufferedInputStream (zipfile.getInputStream (entry));
            int count;
            byte data [] = new byte [BUFFER];
            String [] path_element = null;
            path_element = entry.getName ().replaceAll ("\\\\", "/").split ("/");
            String path_part_dir = new String (prefix);
            for (int i = 0; i < path_element.length - 1; i ++) {
                path_part_dir += path_element [i] + "/";
                File fpath_test = new File (path_part_dir);
                if (! fpath_test.exists ()) fpath_test.mkdirs ();
            }
            FileOutputStream fos = new FileOutputStream (prefix + entry.getName ().replaceAll ("\\\\", "/"));
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = is.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
            is.close ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=244=-----==

private Collection < EdgeMappingDescriptor > loadInternal (File file, TaskMonitor monitor) throws IOException, ParseException, MalformedPathException {
    InputStream graphStream = null, mappingStream = null;
    long oxlSize = 0L;
    boolean gzip = false;
    if (file.getName ().endsWith (".ov1")) {
        ZipFile zipfile = new ZipFile (file);
        Enumeration < ? extends ZipEntry > entries = zipfile.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = entries.nextElement ();
            if (entry.getName ().endsWith (".tsv")) {
                mappingStream = zipfile.getInputStream (entry);
            }
            else if (entry.getName ().contains (".xml")) {
                monitor.setStatus ("decompressing...");
                File copy = extractTempCopy (zipfile.getInputStream (entry));
                OndexPlugin.getInstance ().setOndexGraphFile (copy);
                oxlSize = entry.getSize ();
                graphStream = zipfile.getInputStream (entry);
                gzip = entry.getName ().endsWith (".gz");
            }
        }
    }
    else {
        gzip = file.getName ().endsWith (".gz");
        graphStream = new FileInputStream (file);
        oxlSize = file.length ();
    }
    monitor.setStatus ("loading graph data set...");
    boolean ok = loadGraph (new ByteCounterInputStream (graphStream), oxlSize, monitor, gzip);
    if (ok && mappingStream != null) {
        monitor.setStatus ("loading mapping descriptors...");
        return loadMapping (mappingStream);
    }
    else {
        return null;
    }
}


public ASMWorkflow getASMWorkflow (String userId, String workflowname) {
    Hashtable hsh = new Hashtable ();
    ServiceType st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
    WFS = st.getServiceUrl ();
    st = InformationBase.getI ().getService ("storage", "portal", hsh, new Vector ());
    STORAGE = st.getServiceUrl ();
    PORTAL = getPortalID ();
    if (workflows.get (userId) == null) {
        workflows.put (userId, new ArrayList < ASMWorkflow > ());
        loadASMWorkflows (userId);
    }
    for (int i = 0; i < workflows.get (userId).size (); ++ i) {
        if (workflows.get (userId).get (i).getWorkflowName ().equals (new String (workflowname))) return workflows.get (userId).get (i);
    }
    return null;
}


-----Function Pair=245=-----==

public static int count (String str, File file) throws IOException {
    BufferedReader in = new BufferedReader (new FileReader (file), BUFFER_SIZE);
    File fout = new File (StringOperations.replace (file.toString (), ".txt", ".csv"));
    PrintStream out = new PrintStream (new BufferedOutputStream (new FileOutputStream (fout), BUFFER_SIZE));
    String linha;
    int result = 0;
    while ((linha = in.readLine ()) != null) {
        String linhaOriginal = linha;
        int soma = StringOperations.count (linha, str);
        if (soma != SHORT_COUNTER) {
            System.out.println (linhaOriginal);
        }
        result += soma;
    }
    in.close ();
    out.close ();
    return result;
}


public Object getContainedShape (double _x, double _y) {
    boolean found = false;
    ESRIPolygon containedShape = null;
    if (geometrySetConfig.getShapeType () == ShapeTypes.POLYGON || geometrySetConfig.getShapeType () == ShapeTypes.MULTIPOLYGON) {
        int i = 0;
        while (! found && i < geometrySetConfig.getGridSize ()) {
            int j = 0;
            while (! found && j < geometrySetConfig.getGridSize ()) {
                int k = 0;
                while (! found && k < matrix [i] [j].size ()) {
                    ESRIPolygon _polygon = (ESRIPolygon) matrix [i] [j].elementAt (k);
                    if (_polygon.contains (_x, _y)) {
                        containedShape = _polygon;
                        found = true;
                    }
                    k ++;
                }
                j ++;
            }
            i ++;
        }
    }
    else {
    }
    return containedShape;
}


-----Function Pair=246=-----==

public void deleteRecursiveExcludePattern (File file, String [] excludePattern) throws IOException {
    if (file.exists ()) {
        if (file.isDirectory ()) {
            File [] files = file.listFiles ();
            for (int i = 0, l = files.length; i < l; ++ i) deleteRecursiveExcludePattern (files [i], excludePattern);
        }
        boolean delete = true;
        for (int x = 0; x < excludePattern.length; x ++) {
            if (Pattern.matches (excludePattern [x], file.getName ())) {
                delete = false;
                break;
            }
        }
        if (delete) file.delete ();
    }
}


public void mouseClicked (final MouseEvent e) {
    if (e.getClickCount () == 2) {
        final JTable target = (JTable) e.getSource ();
        final int row = target.getSelectedRow ();
        final SubjectiveScoreDifference diff = model.getDiffForRow (row);
        final String category = diff.getCategory ();
        final JTable scoreTable = getTableForTitle (category);
        final int tabIndex = getTabIndexForCategory (category);
        getTabbedPane ().setSelectedIndex (tabIndex);
        final SubjectiveTableModel model = (SubjectiveTableModel) scoreTable.getModel ();
        final int scoreRow = model.getRowForTeamAndJudge (diff.getTeamNumber (), diff.getJudge ());
        final int scoreCol = model.getColForSubcategory (diff.getSubcategory ());
        if (scoreRow == - 1 || scoreCol == - 1) {
            throw new FLLRuntimeException ("Internal error: Cannot find correct row and column for score difference: " + diff);
        }
        scoreTable.changeSelection (scoreRow, scoreCol, false, false);
    }
}


-----Function Pair=247=-----==

public void DeleteWorkflow (String userID, String workflowID) {
    ASMWorkflow inst = getASMWorkflow (userID, workflowID);
    removeWorkflow (userID, inst);
    WorkflowData wData = PortalCacheService.getInstance ().getUser (userID).getWorkflow (workflowID);
    Hashtable hsh = new Hashtable ();
    ServiceType st;
    PortalWfsClient pc = null;
    try {
        hsh = new Hashtable ();
        hsh.put ("url", wData.getStorageID ());
        st = InformationBase.getI ().getService ("storage", "portal", hsh, new Vector ());
        PortalStorageClient ps = (PortalStorageClient) Class.forName (st.getClientObject ()).newInstance ();
        ps.setServiceURL (st.getServiceUrl ());
        ps.setServiceID (st.getServiceID ());
        ComDataBean tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        tmp.setPortalID (PORTAL);
        tmp.setUserID (userID);
        tmp.setWorkflowID (wData.getWorkflowID ());
        ps.deleteWorkflow (tmp);
        Enumeration wfenm = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().keys ();
        while (wfenm.hasMoreElements ()) {
            String wfkey = "" + wfenm.nextElement ();
            if (PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (wfkey).getGraf ().equals (wData.getGraf ())) {
                ComDataBean template_tmp = new ComDataBean ();
                PORTAL = this.getPortalID ();
                template_tmp.setPortalID (PORTAL);
                template_tmp.setUserID (userID);
                template_tmp.setWorkflowID (wfkey);
                ps.deleteWorkflow (template_tmp);
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    hsh = new Hashtable ();
    hsh.put ("url", wData.getWfsID ());
    st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
    try {
        pc = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
        pc.setServiceURL (st.getServiceUrl ());
        pc.setServiceID (st.getServiceID ());
        ComDataBean tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        tmp.setPortalID (PORTAL);
        tmp.setUserID (userID);
        tmp.setWorkflowID (wData.getWorkflowID ());
        pc.deleteWorkflow (tmp);
        PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    WorkflowData temp_data = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (wData.getTemplate ());
    try {
        ComDataBean template_tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        template_tmp.setPortalID (PORTAL);
        template_tmp.setUserID (userID);
        template_tmp.setWorkflowID (wData.getTemplate ());
        pc.deleteWorkflow (template_tmp);
        PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    Enumeration wfenm = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().keys ();
    String key = "";
    while (wfenm.hasMoreElements ()) {
        key = "" + wfenm.nextElement ();
        if (PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (key).getGraf ().equals (workflowID)) {
            hsh = new Hashtable ();
            st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
            try {
                pc = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
                pc.setServiceURL (st.getServiceUrl ());
                pc.setServiceID (st.getServiceID ());
                ComDataBean tmp = new ComDataBean ();
                PORTAL = this.getPortalID ();
                tmp.setPortalID (PORTAL);
                tmp.setUserID (userID);
                tmp.setWorkflowID (key);
                pc.deleteWorkflow (tmp);
                PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (key);
            } catch (Exception e) {
                e.printStackTrace ();
            }
            PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().remove (key);
            ComDataBean cmd = new ComDataBean ();
            cmd.setWorkflowID (workflowID);
            cmd.setUserID (userID);
            PORTAL = this.getPortalID ();
            cmd.setPortalID (PORTAL);
            pc.deleteWorkflowGraf (cmd);
        }
    }
    PortalCacheService.getInstance ().getUser (userID).getAbstactWorkflows ().remove (workflowID);
    PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
}


void loadKeyStore (String keyStoreName, boolean prompt) {
    if (! nullStream && keyStoreName == null) {
        keyStoreName = System.getProperty ("user.home") + File.separator + ".keystore";
    }
    try {
        if (providerName == null) {
            store = KeyStore.getInstance (storetype);
        }
        else {
            store = KeyStore.getInstance (storetype, providerName);
        }
        if (token && storepass == null && ! protectedPath && ! KeyStoreUtil.isWindowsKeyStore (storetype)) {
            storepass = getPass (rb.getString ("Enter Passphrase for keystore: "));
        }
        else if (! token && storepass == null && prompt) {
            storepass = getPass (rb.getString ("Enter Passphrase for keystore: "));
        }
        if (nullStream) {
            store.load (null, storepass);
        }
        else {
            keyStoreName = keyStoreName.replace (File.separatorChar, '/');
            URL url = null;
            try {
                url = new URL (keyStoreName);
            } catch (java.net.MalformedURLException e) {
                url = new File (keyStoreName).toURI ().toURL ();
            }
            InputStream is = null;
            try {
                is = url.openStream ();
                store.load (is, storepass);
            } finally {
                if (is != null) {
                    is.close ();
                }
            }
        }
        Set < TrustAnchor > tas = new HashSet < TrustAnchor > ();
        try {
            KeyStore caks = KeyTool.getCacertsKeyStore ();
            if (caks != null) {
                Enumeration < String > aliases = caks.aliases ();
                while (aliases.hasMoreElements ()) {
                    String a = aliases.nextElement ();
                    try {
                        tas.add (new TrustAnchor ((X509Certificate) caks.getCertificate (a), null));
                    } catch (Exception e2) {
                    }
                }
            }
        } catch (Exception e) {
        }
        if (store != null) {
            Enumeration < String > aliases = store.aliases ();
            while (aliases.hasMoreElements ()) {
                String a = aliases.nextElement ();
                try {
                    X509Certificate c = (X509Certificate) store.getCertificate (a);
                    if (store.isCertificateEntry (a) || c.getSubjectDN ().equals (c.getIssuerDN ())) {
                        tas.add (new TrustAnchor (c, null));
                    }
                } catch (Exception e2) {
                }
            }
        }
        certificateFactory = CertificateFactory.getInstance ("X.509");
        validator = CertPathValidator.getInstance ("PKIX");
        try {
            pkixParameters = new PKIXParameters (tas);
            pkixParameters.setRevocationEnabled (false);
        } catch (InvalidAlgorithmParameterException ex) {
        }
    } catch (IOException ioe) {
        throw new RuntimeException (rb.getString ("keystore load: ") + ioe.getMessage ());
    } catch (java.security.cert.CertificateException ce) {
        throw new RuntimeException (rb.getString ("certificate exception: ") + ce.getMessage ());
    } catch (NoSuchProviderException pe) {
        throw new RuntimeException (rb.getString ("keystore load: ") + pe.getMessage ());
    } catch (NoSuchAlgorithmException nsae) {
        throw new RuntimeException (rb.getString ("keystore load: ") + nsae.getMessage ());
    } catch (KeyStoreException kse) {
        throw new RuntimeException (rb.getString ("unable to instantiate keystore class: ") + kse.getMessage ());
    }
}


-----Function Pair=248=-----==

public static byte [] zipBytes (byte [] bytes, String aName) throws IOException {
    ByteArrayOutputStream tempOStream = null;
    BufferedOutputStream tempBOStream = null;
    ZipOutputStream tempZStream = null;
    ZipEntry tempEntry = null;
    byte [] tempBytes = null;
    CRC32 tempCRC = null;
    tempOStream = new ByteArrayOutputStream (bytes.length);
    tempBOStream = new BufferedOutputStream (tempOStream);
    tempZStream = new ZipOutputStream (tempBOStream);
    tempCRC = new CRC32 ();
    tempCRC.update (bytes, 0, bytes.length);
    tempEntry = new ZipEntry (aName);
    tempEntry.setMethod (ZipEntry.STORED);
    tempEntry.setSize (bytes.length);
    tempEntry.setCrc (tempCRC.getValue ());
    tempZStream.putNextEntry (tempEntry);
    tempZStream.write (bytes, 0, bytes.length);
    tempZStream.flush ();
    tempBytes = tempOStream.toByteArray ();
    tempZStream.close ();
    return tempBytes;
}


public File uploadFiletoPortalServer (FileItem file, String userID, String filename) throws Exception {
    File serverSideFile = null;
    try {
        String tempDir = System.getProperty ("java.io.tmpdir") + "/uploads/" + userID;
        File f = new File (tempDir);
        if (! f.exists ()) f.mkdirs ();
        serverSideFile = new File (tempDir, filename);
        file.write (serverSideFile);
        file.delete ();
    } catch (FileUploadException fue) {
        throw new Upload_ErrorDuringUploadException (fue.getCause (), userID);
    } catch (Exception e) {
        throw new Upload_GeneralException (e.getCause (), userID);
    }
    return serverSideFile;
}


-----Function Pair=249=-----==

public static void writeEntry (File file, File input) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ARGOUML_EXT);
        temporaryFile.deleteOnExit ();
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        FileInputStream inputStream = new FileInputStream (input);
        ZipEntry entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT);
        output.putNextEntry (new ZipEntry (entry));
        IOUtils.copy (inputStream, output);
        output.closeEntry ();
        inputStream.close ();
        entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + ".argo");
        output.putNextEntry (new ZipEntry (entry));
        output.write (ArgoWriter.getArgoContent (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT).getBytes ());
        output.closeEntry ();
        output.close ();
        temporaryFile.renameTo (file);
    } catch (IOException ioe) {
        throw new PersistenceException (ioe);
    }
}


public byte [] retrieve (User user, String doc, String id, Hashtable parameters) throws EXistException, PermissionDeniedException {
    RpcConnection con = pool.get ();
    String xml = null;
    try {
        xml = con.retrieve (user, doc, id, parameters);
        try {
            String encoding = (String) parameters.get (OutputKeys.ENCODING);
            if (encoding == null) encoding = "UTF-8";
            return xml.getBytes (encoding);
        } catch (UnsupportedEncodingException uee) {
            return xml.getBytes ();
        }
    } catch (Exception e) {
        handleException (e);
        return null;
    } finally {
        pool.release (con);
    }
}


-----Function Pair=250=-----=1=

public void actionPerformed (ActionEvent e) {
    String cmd = e.getActionCommand ();
    if (cmd.equals (LOAD)) {
        if (fc == null) {
            fc = new JFileChooser (System.getProperty ("user.dir"));
            fc.addChoosableFileFilter (new ExtFileFilter ("jar", Messages.getString ("XCsiripJAVA_ARCHIVES")));
            fc.addChoosableFileFilter (new ExtFileFilter ("zip", Messages.getString ("XCsiripZIP_ARCHIVES")));
        }
        if (JFileChooser.APPROVE_OPTION == fc.showOpenDialog (this)) {
            File file = fc.getSelectedFile ();
            loadedTheme = file.getAbsolutePath ();
            se.load (loadedTheme);
        }
    }
    else if (cmd.equals (RESTORE)) {
        if (loadedTheme != null) {
            se.load (loadedTheme);
        }
        else {
            this.remove (se);
            se = null;
            se = new SkinEditor ();
            getContentPane ().add (se);
        }
    }
    else if (cmd.equals (SAVE)) {
        if (fc == null) {
            fc = new JFileChooser (System.getProperty ("user.dir"));
            fc.addChoosableFileFilter (new ExtFileFilter ("jar", Messages.getString ("XCsiripJAVA_ARCHIVES")));
            fc.addChoosableFileFilter (new ExtFileFilter ("zip", Messages.getString ("XCsiripZIP_ARCHIVES")));
        }
        String css = se.getCSS ();
        String theme = se.getTheme ();
        String saveZip = null;
        String themeName = null;
        if (JFileChooser.APPROVE_OPTION == fc.showSaveDialog (this)) {
            File file = fc.getSelectedFile ();
            saveZip = file.getAbsolutePath ();
            themeName = file.getName ();
        }
        if (saveZip != null) {
            String [] filenames = new String [] {themeName + ".css", themeName + ".theme"};
            try {
                BufferedWriter out = new BufferedWriter (new FileWriter (filenames [0]));
                out.write (css);
                out.close ();
                out = new BufferedWriter (new FileWriter (filenames [1]));
                out.write (theme);
                out.close ();
            } catch (IOException ex) {
            }
            byte [] buf = new byte [1024];
            try {
                ZipOutputStream out = new ZipOutputStream (new FileOutputStream (saveZip));
                for (int i = 0; i < filenames.length; i ++) {
                    FileInputStream in = new FileInputStream (filenames [i]);
                    out.putNextEntry (new ZipEntry (filenames [i]));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    in.close ();
                }
                out.close ();
            } catch (IOException ex) {
                ex.printStackTrace ();
            }
            new File (filenames [0]).delete ();
            new File (filenames [1]).delete ();
        }
    }
    else if (cmd.equals (CANCEL)) {
        dispose ();
    }
}


private void zipGeneratedFiles (String path, String nomeArquivo) {
    try {
        int BUFFER = 2048;
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream (path + File.separatorChar + "mapas" + File.separatorChar + nomeArquivo + ".zip");
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        out.setLevel (ZipOutputStream.DEFLATED);
        byte data [] = new byte [BUFFER];
        String rootPath = File.listRoots () [0].getAbsolutePath ();
        String files [] = new String [3];
        files [0] = rootPath + "tmp" + File.separatorChar + nomeArquivo + ".shp";
        files [1] = rootPath + "tmp" + File.separatorChar + nomeArquivo + ".shx";
        files [2] = rootPath + "tmp" + File.separatorChar + nomeArquivo + ".dbf";
        for (int i = 0; i < files.length; i ++) {
            System.out.println ("Adding: " + files [i]);
            FileInputStream fi = new FileInputStream (files [i]);
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (files [i]);
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
            File file = new File (files [i]);
            file.delete ();
        }
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=251=-----==

void addDirectoryFileToZip (DirectoryFile file, ZipOutputStream zipOutStream, String previousPath, String filePathtoConverTags, ExportContentData exportContentData) {
    log.debug ("File " + file.getName () + " previousPath: " + previousPath);
    try {
        BufferedInputStream in = new BufferedInputStream (getInputStreamFromPath (file));
        ZipEntry zipEntry = new ZipEntry (previousPath + file.getName ());
        try {
            try {
                zipOutStream.putNextEntry (zipEntry);
            } catch (ZipException e) {
                log.warn ("File " + file.getName () + " is already at the zip. Ignored");
                zipOutStream.closeEntry ();
                return;
            }
            if (filePathtoConverTags != null) {
                String chapterHTMLContent = writeInputStreamIntoString (in);
                String contentResourcesFolderId = filePathtoConverTags.substring (0, 36);
                String relativeChapterPath = filePathtoConverTags.substring (37, filePathtoConverTags.length ());
                String convertedChapterContent = convertToLocalUrls (chapterHTMLContent, zipOutStream, contentResourcesFolderId, relativeChapterPath, file.getWorkspace (), exportContentData);
                in = new BufferedInputStream (new ByteArrayInputStream (convertedChapterContent.getBytes ()));
            }
            writeInputStreamIntoOutputStream (in, zipOutStream);
            zipOutStream.closeEntry ();
        } catch (IOException e) {
            String errorMessage = "Error adding file " + previousPath + file.getName ();
            log.error (errorMessage, e);
            throw new CMSRuntimeException (errorMessage, e);
        }
    } catch (MalformedDirectoryItemException e) {
        log.error ("Cannot add file to zip. Item " + file.getId () + " is malformed");
    }
}


protected void setObjectReferences (ParticleSystem ps) {
    List < Modifier > modifiers = ps.getModifiers ();
    PointMass mass = null;
    PositionAnimator panimator = null;
    int index = - 1;
    for (Modifier modifier : modifiers) {
        if (modifier instanceof PointMass) {
            mass = (PointMass) modifier;
            index = mass.getPositionAnimatorIndex ();
            if (index > - 1) {
                panimator = ps.getPanimators ().get (index);
                mass.setPositionAnimator (panimator);
            }
        }
    }
    List < Generator > gens = ps.getGenerators ();
    panimator = null;
    ParticleBehaviour behaviour = null;
    GeneratorBehaviour genBehhaviour = null;
    SpaceAnimator animator = null;
    ParticleRender render = null;
    Modifier modifier = null;
    GeneratorSpace space = null;
    index = - 1;
    for (Generator generator : gens) {
        index = generator.getParticleBehaviourIndex ();
        if (index > - 1) {
            behaviour = ps.getBehaviours ().get (index);
            generator.setPb (behaviour);
        }
        else generator.setPb (null);
        index = generator.getGeneratorBehaviourIndex ();
        if (index > - 1) {
            genBehhaviour = ps.getGenBehaviours ().get (index);
            generator.setGb (genBehhaviour);
        }
        else generator.setGb (null);
        index = generator.getRenderIndex ();
        if (index > - 1) {
            render = ps.getRenders ().get (index);
            generator.setRender (render);
        }
        else generator.setRender (null);
        index = generator.getSpaceIndex ();
        if (index > - 1) {
            space = ps.getSpaces ().get (index);
            generator.setSpace (space);
        }
        else generator.setSpace (null);
        index = generator.getSpaceAnimatorIndex ();
        if (index > - 1) {
            animator = ps.getAnimators ().get (index);
            generator.setAnimator (animator);
        }
        else generator.setAnimator (null);
        index = generator.getPositionAnimatorIndex ();
        System.out.println ("PositionAnimator Index ->" + index);
        if (index > - 1) {
            panimator = ps.getPanimators ().get (index);
            System.out.println ("Setting a PositionAnimator ->" + panimator);
            generator.setPositionAnimator (panimator);
        }
        else generator.setPositionAnimator (null);
        List < Integer > indexes = generator.getModifierIndexes ();
        if (indexes != null) {
            for (Integer integer : indexes) {
                modifier = ps.getModifiers ().get (integer);
                generator.getModifiers ().add (modifier);
            }
            generator.setModifierIndexes (null);
        }
    }
}


-----Function Pair=252=-----==

protected void exportUsers (Element parent, CmsOrganizationalUnit orgunit) throws CmsImportExportException, SAXException {
    try {
        I_CmsReport report = getReport ();
        List allUsers = OpenCms.getOrgUnitManager ().getUsers (getCms (), orgunit.getName (), false);
        for (int i = 0, l = allUsers.size (); i < l; i ++) {
            CmsUser user = (CmsUser) allUsers.get (i);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_SUCCESSION_2, String.valueOf (i + 1), String.valueOf (l)), I_CmsReport.FORMAT_NOTE);
            report.print (Messages.get ().container (Messages.RPT_EXPORT_USER_0), I_CmsReport.FORMAT_NOTE);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_ARGUMENT_1, user.getName ()));
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
            exportUser (parent, user);
            report.println (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_OK_0), I_CmsReport.FORMAT_OK);
        }
    } catch (CmsImportExportException e) {
        throw e;
    } catch (CmsException e) {
        if (LOG.isDebugEnabled ()) {
            LOG.debug (e.getLocalizedMessage (), e);
        }
        throw new CmsImportExportException (e.getMessageContainer (), e);
    }
}


private void extractUpdate (String path) {
    try {
        files = new ArrayList < File > ();
        updater.setProgress (25);
        ZipFile zf = new ZipFile (updaterFile);
        ZipFile jf = new ZipFile (file);
        updater.setLabelText ("Extracting Updates...");
        Enumeration < ? extends ZipEntry > en = jf.entries ();
        while (en.hasMoreElements ()) {
            extractEntry (jf, en.nextElement (), path);
        }
        updater.setProgress (50);
        en = zf.entries ();
        while (en.hasMoreElements ()) {
            extractEntry (zf, en.nextElement (), path);
        }
        updater.setProgress (75);
        updater.setLabelText ("Implementing Updates...");
        updaterFile.delete ();
        file.delete ();
        for (File f : files) {
            if (! f.isDirectory ()) {
                compressEntry (f, file.getCanonicalPath (), file.getCanonicalPath ().substring (0, file.getCanonicalPath ().length () - file.getName ().length ()));
            }
        }
        updater.setProgress (100);
        if (Runtime.getRuntime ().exec (System.getProperty ("java.home") + "/bin/" + "java -jar " + file.getCanonicalPath () + " -startAfterUpdate " + file.getCanonicalPath ().substring (0, (file.getCanonicalPath ().length () - 4)) + "Updater.jar") == null) {
            JOptionPane.showMessageDialog (null, "Could not start Updater!\n (java -jar " + updaterFile.getCanonicalPath () + " -update " + file.getCanonicalPath ());
        }
        Thread.sleep (500);
        updater.dispose ();
        for (File f : files) {
            f.delete ();
        }
        System.exit (2);
    } catch (ZipException e) {
        e.printStackTrace ();
        JOptionPane.showMessageDialog (null, "Update error! Could not extract files to patch. Check folder permission.", "Error", JOptionPane.ERROR_MESSAGE);
    } catch (IOException e) {
        e.printStackTrace ();
        JOptionPane.showMessageDialog (null, "Update error! Could not read files. Maybe the update file is corrupt.\nTry to update again.", "Error", JOptionPane.ERROR_MESSAGE);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=253=-----==

private static void copyMoveFolderRecursive (File src, File dest, boolean move) throws IOException {
    File [] fs = Utils.listFilesForFolder (src);
    File f;
    for (int i = 0; i < fs.length; i ++) {
        f = fs [i];
        if (! f.canRead ()) {
            throw new IOException ("no read access to " + f.getAbsolutePath ());
        }
        if (f.isFile ()) {
            copyFile (f, new File (dest, f.getName ()));
        }
        else if (f.isDirectory ()) {
            File destFolder = new File (dest, f.getName ());
            if (! destFolder.exists ()) {
                destFolder.mkdir ();
            }
            copyMoveFolderRecursive (f, destFolder, move);
        }
        if (move && f.canWrite ()) {
            f.delete ();
        }
    }
}


private static void zipFile (File resFile, ZipOutputStream zipout, String rootpath) throws FileNotFoundException, IOException {
    rootpath = rootpath + (rootpath.trim ().length () == 0 ? "" : File.separator) + resFile.getName ();
    rootpath = new String (rootpath.getBytes ("8859_1"), "GB2312");
    if (resFile.isDirectory ()) {
        File [] fileList = resFile.listFiles ();
        for (File file : fileList) {
            zipFile (file, zipout, rootpath);
        }
    }
    else {
        byte buffer [] = new byte [BUFF_SIZE];
        BufferedInputStream in = new BufferedInputStream (new FileInputStream (resFile), BUFF_SIZE);
        zipout.putNextEntry (new ZipEntry (rootpath));
        int realLength;
        while ((realLength = in.read (buffer)) != - 1) {
            zipout.write (buffer, 0, realLength);
        }
        in.close ();
        zipout.flush ();
        zipout.closeEntry ();
    }
}


-----Function Pair=254=-----==

void writeJad (String jarLocation, long jarSize) throws IOException {
    DataOutputStream os = new DataOutputStream (this.jadFile);
    for (int i = 0; i < this.manifestLines.size (); ++ i) {
        for (int j = 0; j < MANIFEST_ONLY_LINES.length; ++ j) {
            if (this.manifestLines.elementAt (i).startsWith (MANIFEST_ONLY_LINES [j])) {
                continue;
            }
        }
        os.writeBytes (this.manifestLines.elementAt (i));
        os.writeByte ('\n');
    }
    os.writeBytes (JAD_FILESIZE + JAD_SEPARATOR + jarSize + "\n");
    os.writeBytes (JAD_FILENAME + JAD_SEPARATOR + jarLocation + "\n");
    os.flush ();
    this.jadFile.close ();
    this.jadFile = null;
}


public void openCard () {
    if (current_card == - 1) return;
    Card card = (Card) cards.elementAt (current_card);
    boolean soundPlayed = true;
    learned.setSelected (card.learned);
    if (edit_mode) if (cards.size () == 0) {
        card.left_side.setVisible (false);
        card.right_side.setVisible (false);
        updatePosition ();
        delete_card.setEnabled (false);
        properties.setEnabled (false);
        return;
    }
    else {
        card_panel.setVisible (true);
        card.left_side.setVisible (true);
        card.right_side.setVisible (true);
        delete_card.setEnabled (true);
        properties.setEnabled (true);
    }
    if (mode == QUIZ_LEFT_SOUND || mode == QUIZ_RIGHT_SOUND) {
        card.left_side.setVisible (false);
        card.right_side.setVisible (false);
    }
    else if (mode == QUIZ_LEFT) {
        card.left_side.setVisible (true);
        card.right_side.setVisible (false);
    }
    else if (mode == QUIZ_RIGHT) {
        card.left_side.setVisible (false);
        card.right_side.setVisible (true);
    }
    else {
        card.left_side.setVisible (true);
        card.right_side.setVisible (true);
    }
    if (edit_mode) {
        card.left_side.setFocusable (true);
        card.right_side.setFocusable (true);
    }
    else {
        card.left_side.setFocusable (false);
        card.right_side.setFocusable (false);
    }
    add_edits = false;
    JComponent left = card.left_side.get ();
    JComponent right = card.right_side.get ();
    add_edits = true;
    card.left_side.setSoundFlag (lSoundFlag);
    card.right_side.setSoundFlag (rSoundFlag);
    card.left_side.setEditMode (edit_mode);
    card.right_side.setEditMode (edit_mode);
    card_panel.removeAll ();
    card_panel.add (left);
    card_panel.add (right);
    card_panel.repaint ();
    if (mode != BROWSE) show.requestFocus ();
    else {
        updatePosition ();
        if (edit_mode) {
            updateEditMenu ();
            if (card.left_side.getType () != Side.IMAGE) left.requestFocus ();
            else if (card.right_side.getType () != Side.IMAGE) right.requestFocus ();
        }
    }
    if (mode == QUIZ_LEFT_SOUND) {
        if (! card.left_side.playSound ()) {
            JOptionPane.showMessageDialog (null, "There is no sound set for " + lName + " on this card.", "No Sound", JOptionPane.WARNING_MESSAGE);
            show.doClick ();
        }
    }
    else if (mode == QUIZ_RIGHT_SOUND) {
        if (! card.right_side.playSound ()) {
            JOptionPane.showMessageDialog (null, "There is no sound set for " + rName + " on this card.", "No Sound", JOptionPane.WARNING_MESSAGE);
            show.doClick ();
        }
    }
}


-----Function Pair=255=-----==

private void init () {
    try {
        ZipFile zf = new ZipFile (jarFileName);
        Enumeration e = zf.entries ();
        while (e.hasMoreElements ()) {
            ZipEntry ze = (ZipEntry) e.nextElement ();
            htSizes.put (ze.getName (), new Integer ((int) ze.getSize ()));
        }
        zf.close ();
        FileInputStream fis = new FileInputStream (jarFileName);
        BufferedInputStream bis = new BufferedInputStream (fis);
        ZipInputStream zis = new ZipInputStream (bis);
        ZipEntry ze = null;
        while ((ze = zis.getNextEntry ()) != null) {
            if (ze.isDirectory ()) {
                continue;
            }
            int size = (int) ze.getSize ();
            if (size == - 1) {
                size = ((Integer) htSizes.get (ze.getName ())).intValue ();
            }
            byte [] b = new byte [(int) size];
            int rb = 0;
            int chunk = 0;
            while (((int) size - rb) > 0) {
                chunk = zis.read (b, rb, (int) size - rb);
                if (chunk == - 1) {
                    break;
                }
                rb += chunk;
            }
            htJarContents.put (ze.getName (), b);
        }
    } catch (NullPointerException e) {
        return;
    } catch (FileNotFoundException e) {
        return;
    } catch (IOException e) {
        return;
    }
}


private byte [] showAddForm (HTTPurl urlData) throws Exception {
    int day = - 1;
    int month = - 1;
    int year = - 1;
    try {
        day = Integer.parseInt (urlData.getParameter ("day"));
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    ScheduleItem item = null;
    String id = urlData.getParameter ("id");
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
    }
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "itemdetails.html");
    if (item != null) template.replaceAll ("$duration", new Integer (item.getDuration ()).toString ());
    else template.replaceAll ("$duration", "1");
    if (item != null) template.replaceAll ("$name", item.getName ());
    else template.replaceAll ("$name", "");
    Calendar cal = Calendar.getInstance ();
    if (item != null) cal.setTime (item.getStart ());
    template.replaceAll ("$hour", store.intToStr (cal.get (Calendar.HOUR_OF_DAY)));
    template.replaceAll ("$min", store.intToStr (cal.get (Calendar.MINUTE)));
    template.replaceAll ("$channels", getChannelList (item));
    template.replaceAll ("$item_type", getTypeList (item));
    template.replaceAll ("$item_captype", getCapTypeList (item));
    String fields = "";
    fields += "<input type='hidden' name='day' value='" + day + "'>\n";
    fields += "<input type='hidden' name='month' value='" + month + "'>\n";
    fields += "<input type='hidden' name='year' value='" + year + "'>\n";
    if (item != null) {
        fields += "<input name='id' type='hidden' id='id' value='" + id + "'>\n";
    }
    template.replaceAll ("$fields", fields);
    if (item != null && item.isAutoDeletable ()) template.replaceAll ("$adtrue", "checked");
    else template.replaceAll ("$adtrue", "");
    template.replaceAll ("$pattern", getNamePatternList (item));
    if (item == null) {
        String defKeepFor = store.getProperty ("AutoDel.KeepFor");
        if (defKeepFor == null) defKeepFor = "30";
        template.replaceAll ("$keepfor", defKeepFor);
    }
    else {
        template.replaceAll ("$keepfor", new Integer (item.getKeepFor ()).toString ());
    }
    template.replaceAll ("$tasks", getTaskList (item));
    template.replaceAll ("$CapturePaths", getCapturePathList (item));
    return template.getPageBytes ();
}


-----Function Pair=256=-----==

public static void upZipFile (File zipFile, String folderPath) throws ZipException, IOException {
    File desDir = new File (folderPath);
    if (! desDir.exists ()) {
        desDir.mkdirs ();
    }
    ZipFile zf = new ZipFile (zipFile);
    for (Enumeration < ? > entries = zf.entries (); entries.hasMoreElements ();) {
        ZipEntry entry = ((ZipEntry) entries.nextElement ());
        InputStream in = zf.getInputStream (entry);
        String str = folderPath + File.separator + entry.getName ();
        str = new String (str.getBytes ("8859_1"), "GB2312");
        File desFile = new File (str);
        if (! desFile.isDirectory ()) {
            if (! desFile.exists ()) {
                File fileParentDir = desFile.getParentFile ();
                if (! fileParentDir.exists ()) {
                    fileParentDir.mkdirs ();
                }
                desFile.createNewFile ();
            }
            OutputStream out = new FileOutputStream (desFile);
            byte buffer [] = new byte [BUFF_SIZE];
            int realLength;
            while ((realLength = in.read (buffer)) > 0) {
                out.write (buffer, 0, realLength);
            }
            in.close ();
            out.close ();
        }
    }
}


public static void zipDir (String dir2zip, ZipOutputStream zos, String inFolder) throws IOException {
    File zipDir = new File (dir2zip);
    String [] dirList = zipDir.list ();
    byte [] readBuffer = new byte [BUFFER];
    int bytesIn = 0;
    for (String dir : dirList) {
        File f = new File (zipDir, dir);
        if (f.isDirectory ()) {
            String filePath = f.getPath ();
            zipDir (filePath, zos, inFolder);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        String fileZipPath = f.getPath ().replace (inFolder, "");
        ZipEntry anEntry = new ZipEntry (fileZipPath);
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            zos.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


-----Function Pair=257=-----==

private void SaveTopic (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    Topic try_topic_by_code = GetTopicByCode (t.GetCode ());
    if (try_topic_by_code != null && ! try_topic_by_code.GetId ().equalsIgnoreCase (t.GetId ())) throw new NpsException ("alias for topic exists:" + t.GetAlias (), ErrorHelper.SYS_INVALIDTOPICALIAS);
    try {
        String sql = "insert into topic(id,name,siteid,alias,code,parentid,idx,tname,art_template,default_article_state,default_article_score,layer,visible) values(?,?,?,?,?,?,?,?,?,?,?,?,?)";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.setString (2, t.GetName ());
        pstmt.setString (3, site.GetId ());
        pstmt.setString (4, t.GetAlias ());
        pstmt.setString (5, t.GetCode ());
        pstmt.setString (6, "-1".equalsIgnoreCase (t.GetParentId ()) ? null : t.GetParentId ());
        pstmt.setInt (7, t.GetIndex ());
        pstmt.setString (8, t.GetTable ());
        if (t.GetArticleTemplate () != null) pstmt.setString (9, t.GetArticleTemplate ().GetId ());
        else pstmt.setNull (9, java.sql.Types.VARCHAR);
        pstmt.setInt (10, t.GetDefaultArticleState ());
        pstmt.setFloat (11, t.GetScore ());
        pstmt.setInt (12, GetLayer (t));
        pstmt.setInt (13, t.IsVisible () ? 1 : 0);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


private String getTemplateParam (DicomObject blobAttrs, String param, HashSet < Integer > sopHash) {
    boolean useHash = param.charAt (0) == '#';
    String value;
    if (param.endsWith ("patID")) {
        value = blobAttrs.getString (Tag.PatientID);
    }
    else if (param.endsWith ("patName")) {
        value = blobAttrs.getString (Tag.PatientName);
    }
    else if (param.endsWith ("studyIuid")) {
        value = blobAttrs.getString (Tag.StudyInstanceUID);
    }
    else if (param.endsWith ("seriesIuid")) {
        value = blobAttrs.getString (Tag.SeriesInstanceUID);
    }
    else if (param.endsWith ("sopIuid")) {
        value = blobAttrs.getString (Tag.SOPInstanceUID);
        if (useHash) {
            int hash;
            for (hash = value.hashCode (); ! sopHash.add (hash); hash ++);
            return FileUtils.toHex (hash);
        }
    }
    else {
        throw new IllegalArgumentException ("Unknown zip entry template parameter:" + param);
    }
    return useHash ? FileUtils.toHex (value == null ? - 1 : value.hashCode ()) : value;
}


-----Function Pair=258=-----==

public void pkgResources (Set < String > res, String fileName) throws IOException {
    File f = new File (fileName);
    if (! f.exists ()) {
        f.createNewFile ();
    }
    byte [] buf = new byte [1024];
    JarOutputStream out = new JarOutputStream (new FileOutputStream (fileName));
    for (String s : res) {
        s = s.replace ('.', '/') + ".class";
        if (debugEnabled) {
            System.out.println ("adding: " + s);
        }
        InputStream in = this.getClass ().getClassLoader ().getResourceAsStream (s);
        if (in == null) continue;
        out.putNextEntry (new ZipEntry (s));
        int w = in.read (buf);
        while (w >= 0) {
            out.write (buf, 0, w);
            w = in.read (buf);
        }
        in.close ();
    }
    out.finish ();
    out.close ();
}


public static void unzip1 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    if (! outputdir.exists ()) {
        outputdir.mkdirs ();
    }
    ArchiveInputStream zis = new ZipArchiveInputStream (new FileInputStream (zipfile));
    ArchiveEntry ae = zis.getNextEntry ();
    while (ae != null) {
        File newFile = new File (outputdir + File.separator + ae.getName ());
        if (! newFile.getParentFile ().exists ()) newFile.getParentFile ().mkdirs ();
        if (ae.isDirectory ()) {
            if (! newFile.exists ()) newFile.mkdir ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = zis.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
        }
        ae = zis.getNextEntry ();
    }
    zis.close ();
}


-----Function Pair=259=-----==

private static void save (Instance instance, String formula, InstanceClass instanceClass) {
    if (instance.isNew ()) {
        try {
            PreparedStatement ps;
            final String insertQuery = "INSERT INTO " + table + " (name, md5, instance) " + "VALUES (?, ?, ?)";
            ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (insertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
            ps.setString (1, instance.getName ());
            ps.setString (2, instance.getMd5 ());
            if (! formula.isEmpty ()) {
                ByteArrayInputStream input = new ByteArrayInputStream (formula.getBytes ());
                ps.setBinaryStream (3, input);
            }
            else {
                ps.setNull (3, Types.BLOB);
            }
            ps.executeUpdate ();
            ResultSet rs = ps.getGeneratedKeys ();
            if (rs.next ()) {
                instance.setId (rs.getInt (1));
            }
            cache.cache (instance);
            ps.close ();
            instance.setSaved ();
            InstanceHasInstanceClassDAO.createInstanceHasInstance (instance, instanceClass);
        } catch (Exception ex) {
            Logger.getLogger (InstanceDAO.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
}


private byte [] remTask (HTTPurl urlData, HashMap headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    tasks.remove (name);
    store.saveTaskList (null);
    return out.getBytes ();
}


-----Function Pair=260=-----==

public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


protected static void createArguement (ONDEXPlugin plugin, ONDEXPluginArguments arguments, String arguementName, Object arguementValue) throws IllegalArguementsException {
    checkArguementName (plugin, arguementName);
    if (arguementValue == null) {
        logger.info ("Ignoring null value for arguement " + arguementName);
        return;
    }
    if (arguementValue instanceof String) {
        String asString = (String) arguementValue;
        if (asString.length () == 0) {
            logger.info ("Ignoring empty string for arguement " + arguementName);
            return;
        }
    }
    try {
        arguments.addOption (arguementName, arguementValue);
    } catch (Exception e) {
        throw new IllegalArguementsException ("Unable to add value " + arguementValue + " for arguement with the name: " + arguementName + " in the plugin " + plugin.getClass () + " exception thrown was ", e, plugin, logger);
    }
}


-----Function Pair=261=-----==

public synchronized void write (byte [] b, int off, int len) throws IOException {
    ensureOpen ();
    if (off < 0 || len < 0 || off > b.length - len) {
        throw new IndexOutOfBoundsException ();
    }
    else if (len == 0) {
        return;
    }
    if (entry == null) {
        throw new ZipException ("no current ZIP entry");
    }
    switch (entry.method) {
        case DEFLATED :
            super.write (b, off, len);
            break;
        case STORED :
            written += len;
            if (written - locoff > entry.size) {
                throw new ZipException ("attempt to write past end of STORED entry");
            }
            out.write (b, off, len);
            break;
        default :
            throw new InternalError ("invalid compression method");
    }
    crc.update (b, off, len);
}


public void putNextEntry (ZipEntry ze) throws IOException {
    if (firstEntry) {
        byte [] edata = ze.getExtra ();
        if (edata != null && ! hasMagic (edata)) {
            byte [] tmp = new byte [edata.length + 4];
            System.arraycopy (tmp, 4, edata, 0, edata.length);
            edata = tmp;
        }
        else {
            edata = new byte [4];
        }
        set16 (edata, 0, JAR_MAGIC);
        set16 (edata, 2, 0);
        ze.setExtra (edata);
        firstEntry = false;
    }
    super.putNextEntry (ze);
}


-----Function Pair=262=-----==

public void sequence (String file_id, String id, String entry) {
    String input = entry.replaceAll ("\\s", "").replaceAll ("\\p{Blank}", "").trim ();
    String head = ">" + id + "|" + input.length () + LINE_SEPARATOR;
    String fasta = new String ();
    int j = 0;
    for (int i = 0; i < input.length (); i ++) {
        if (j == 80) {
            fasta = fasta + LINE_SEPARATOR;
            j = - 1;
        }
        else {
            fasta = fasta + input.charAt (i);
        }
        j ++;
    }
    fasta = head + fasta;
    create (Config.getTmpPath () + file_id + FileFormat.FASTA.getFileType (), fasta);
    FILE = Config.getWebTmpPath () + file_id + FileFormat.FASTA.getFileType ();
}


protected Collection < Community > getExplicitUserCommunities (GroupwareUser user, String role) {
    Collection < Community > communities = new ArrayList < Community > ();
    CommunityPrivilege prototype = new CommunityPrivilege ();
    prototype.setUserId (user.getId ());
    prototype.setRole (role);
    Collection < CommunityPrivilege > privileges = privilegePersister.searchByPrototype (prototype);
    for (CommunityPrivilege privilege : privileges) {
        try {
            Community community = communityPersister.getCommunityById (privilege.getCommunityId ());
            communities.add (community);
        } catch (CommunityNotFoundException e) {
            String message = "Privilege found for user " + privilege.getUserId () + " with role " + privilege.getRole () + " in community " + privilege.getCommunityId () + " but community was not found";
            log.debug (message);
        }
    }
    return communities;
}


-----Function Pair=263=-----==

public void Delete (NpsContext ctxt) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        List topics = null;
        if (Config.CACHE) {
            topics = GetTopics (ctxt);
        }
        String sql = "delete from topic_pts where templateid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update topic set art_template=null where art_template=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from template where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        for (int i = 0; topics != null && i < topics.size (); i ++) {
            TopicProfile profile = (TopicProfile) topics.get (i);
            Site site = ctxt.GetSite (profile.GetSiteId ());
            if (site == null) continue;
            TopicTree topic_tree = site.GetTopicTree ();
            if (topic_tree == null) continue;
            Topic topic = topic_tree.GetTopic (profile.GetId ());
            if (topic == null) continue;
            if (this instanceof ArticleTemplate) topic.SetArticleTemplate (null);
            else topic.RemovePageTemplate (id);
        }
        DeleteJavaFiles ();
        TemplatePool.GetPool ().remove (this);
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


private String getCapTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = - 1;
    if (item != null) type = item.getCapType ();
    if (type == - 1) {
        typeList.append ("<label><input name='captype' type='radio' value='-1' checked>AutoSelect</label><br>\n");
    }
    else {
        typeList.append ("<label><input name='captype' type='radio' value='-1'>AutoSelect</label><br>\n");
    }
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int x = 0; x < capabilities.size (); x ++) {
        CaptureCapability capability = capabilities.get (x);
        typeList.append ("<label><input name='captype' type='radio' value='" + capability.getTypeID () + "' ");
        if (type == capability.getTypeID ()) typeList.append ("checked");
        typeList.append (">" + capability.getName () + "</label><br>\n");
    }
    return typeList.toString ();
}


-----Function Pair=264=-----==

private static void getAllFiles (File file, String extension, ArrayList < File > filesLst) {
    if (file != null) {
        if (file.isDirectory ()) {
            File [] dirfiles = file.listFiles ();
            if (dirfiles != null) {
                for (int i = 0; i < dirfiles.length; i ++) {
                    getAllFiles (dirfiles [i], extension, filesLst);
                }
            }
        }
        if (extension.length () == 0 || file.getName ().endsWith (extension)) {
            filesLst.add (file);
        }
    }
}


private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Run\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=44&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/RunTaskSmall.png' border='0' alt='Delete' title='Run' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("tasks.deftask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("tasks.pretask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("tasks.starterrortask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("tasks.nodataerrortask"));
    return template.getPageBytes ();
}


-----Function Pair=265=-----==

public static void waitForFile (String filePath) throws Exception {
    int maxRetries = 20;
    int retry = 0;
    boolean success = false;
    File file = new File (filePath);
    while (! success && retry < maxRetries) {
        if (retry > 0) {
            Thread.sleep (1000);
        }
        if (file.exists ()) {
            success = true;
        }
        retry ++;
        if (! success) {
            logger.info ("Could not locate file=" + filePath + ", starting retry " + retry);
        }
    }
    if (! success) {
        throw new Exception ("Could not locate file=" + filePath);
    }
}


private void writeEND (long off, long cenSize) throws IOException {
    byte [] commentBytes = null;
    if (comment != null) {
        commentBytes = ZipStringEncoder.encode (comment, charset);
    }
    int size = SIZE_END + (commentBytes == null ? 0 : commentBytes.length) + (useZip64 ? SIZE_Z64_END : 0);
    long mark = ensureCapacity (size);
    if (useZip64) {
        this.Z64EODRStart = volumeStrategy == null ? 0 : volumeStrategy.getCurrentVolumeNumber ();
        writeZip64END (off, cenSize);
        cenSize += SIZE_Z64_END;
    }
    writeInt (ENDSIG);
    writeShort (volumeStrategy == null ? 0 : this.volumeStrategy.getCurrentVolumeNumber ());
    writeShort (this.CENStart);
    if (useZip64) {
        writeShort (- 1);
        writeShort (- 1);
        writeInt (- 1);
        writeInt (- 1);
    }
    else {
        writeShort ((short) this.getEntryCount ());
        writeShort (entries.size ());
        writeInt (cenSize);
        writeInt (off);
    }
    if (commentBytes != null) {
        writeShort (commentBytes.length);
        writeBytes (commentBytes, 0, commentBytes.length);
    }
    else {
        writeShort (0);
    }
    checkWritten (mark, size);
}


-----Function Pair=266=-----==

public final void handleArchiveEnd (final File parentDir, final File archive) {
    final Logger log = m_log;
    if (log.atTRACE2 ()) log.trace2 ("handleArchiveEnd", "[" + parentDir + "] [" + archive + "]");
    m_currentArchiveTS = Long.MAX_VALUE;
    if ((m_outMode == OutMode.OUT_MODE_FULLCOPY) || (m_outMode == OutMode.OUT_MODE_OVERWRITE)) {
        try {
            drainJobQueue ();
            m_archiveOut.flush ();
            m_archiveOut.close ();
            m_archiveOut = null;
        } catch (IOException ioe) {
            throw new EMMARuntimeException (ioe);
        }
        if (m_outMode == OutMode.OUT_MODE_OVERWRITE) {
            if (! Files.renameFile (m_tempArchiveFile, m_origArchiveFile, true)) {
                throw new EMMARuntimeException ("could not rename temporary file [" + m_tempArchiveFile + "] to [" + m_origArchiveFile + "]: make sure the original file is not locked and can be deleted");
            }
            else {
                if (log.atTRACE2 ()) log.trace2 ("handleArchiveEnd", "renamed temp archive [" + m_tempArchiveFile.getAbsolutePath () + "] to [" + m_origArchiveFile + "]");
                m_origArchiveFile = m_tempArchiveFile = null;
            }
        }
    }
}


protected Collection < Community > getExplicitUserCommunities (GroupwareUser user, String role) {
    Collection < Community > communities = new ArrayList < Community > ();
    CommunityPrivilege prototype = new CommunityPrivilege ();
    prototype.setUserId (user.getId ());
    prototype.setRole (role);
    Collection < CommunityPrivilege > privileges = privilegePersister.searchByPrototype (prototype);
    for (CommunityPrivilege privilege : privileges) {
        try {
            Community community = communityPersister.getCommunityById (privilege.getCommunityId ());
            communities.add (community);
        } catch (CommunityNotFoundException e) {
            String message = "Privilege found for user " + privilege.getUserId () + " with role " + privilege.getRole () + " in community " + privilege.getCommunityId () + " but community was not found";
            log.debug (message);
        }
    }
    return communities;
}


-----Function Pair=267=-----==

private void addFiles (final File work, final ZipOutputStream zipStream) throws IOException {
    File [] files = work.listFiles ();
    int cut = runnerDir.getAbsolutePath ().length () - runnerDir.getName ().length ();
    for (int i = 0; i < files.length; i ++) {
        File f = files [i];
        if (f.isDirectory ()) {
            addFiles (f, zipStream);
        }
        else if (! f.isHidden ()) {
            String fileName = f.getAbsolutePath ().substring (cut);
            zipStream.putNextEntry (new ZipEntry (fileName));
            InputStream input = new FileInputStream (f);
            byte [] buffer = new byte [1024];
            int b;
            while ((b = input.read (buffer)) != - 1) zipStream.write (buffer, 0, b);
            input.close ();
        }
    }
}


private byte [] showRunningActions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer buff = new StringBuffer (2048);
    buff.append ("HTTP/1.0 200 OK\n");
    buff.append ("Content-Type: text/html\n");
    buff.append ("Pragma: no-cache\n");
    buff.append ("Cache-Control: no-cache\n\n");
    buff.append ("<html>\n");
    buff.append ("<table align='center' border='1'>\n");
    buff.append ("<tr>\n");
    buff.append ("<td nowrap>Device Index</td>\n");
    buff.append ("<td nowrap>Device Name</td>\n");
    buff.append ("<td nowrap>HashKey</td>\n");
    buff.append ("<td nowrap>Share Name</td>\n");
    buff.append ("<td nowrap>Usage Count</td>\n");
    buff.append ("<td nowrap>Is Running</td>\n");
    buff.append ("<td nowrap>Exit Code</td>\n");
    buff.append ("<td nowrap>Needs Reastart</td>\n");
    buff.append ("</tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    StreamProducerProcess [] producers = devList.getProducers ();
    for (int index = 0; index < producers.length; index ++) {
        StreamProducerProcess producer = producers [index];
        buff.append ("<tr>\n");
        buff.append ("<td nowrap>" + producer.getDeviceIndex () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getCaptureDevice ().getName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getKey () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getMemoryShareName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getUsageCount () + "</td>\n");
        buff.append ("<td nowrap>" + producer.isProducerRunning () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getExitCode () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getNeedsRestart () + "</td>\n");
        buff.append ("</tr>\n");
    }
    buff.append ("</table>\n");
    buff.append ("<br><br><br>\n");
    buff.append ("</html>");
    buff.append ("\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=268=-----==

private static int readUtf8 (int c0, InputStream in) throws IOException {
    int c1, c2, c3;
    switch (c0>> 4) {
        case 12 :
        case 13 :
            c1 = in.read ();
            if ((c1 & 0xC0) != 0x80) throw new UTFDataFormatException (Integer.toHexString (c0));
            return ((c0 & 0x1F) << 6) | ((c1 & 0x3F) << 0);
        case 14 :
            c1 = in.read ();
            c2 = in.read ();
            if (((c1 & 0xC0) != 0x80) || ((c2 & 0xC0) != 0x80)) throw new UTFDataFormatException ();
            return ((c0 & 0x0F) << 12) | ((c1 & 0x3F) << 6) | ((c2 & 0x3F) << 0);
        case 15 :
            throw new UTFDataFormatException (Integer.toHexString (c0));
        default :
            throw new UTFDataFormatException (Integer.toHexString (c0));
    }
}


private byte [] deleteSchedule (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    StringBuffer out = new StringBuffer (4096);
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null && (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR)) {
        store.removeScheduleItem (id);
        store.saveSchedule (null);
    }
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=269=-----==

private Map preloadIdValueTable (PreparedStatement cntStm, PreparedStatement stm) throws SQLException {
    Map m = null;
    ResultSet rs = cntStm.executeQuery ();
    rs.next ();
    long recordCount = rs.getLong (1);
    closeResultSet (rs);
    if (recordCount < MAX_PRELOAD_CNT) {
        rs = stm.executeQuery ();
        if (true) {
            m = new HashMap ();
            String currentId = null;
            List l = null;
            while (rs.next ()) {
                String id = rs.getString (1);
                if (! id.equals (currentId)) {
                    l = new ArrayList ();
                    m.put (id, l);
                    currentId = id;
                }
                l.add (rs.getString (2));
            }
            closeResultSet (rs);
        }
    }
    return m;
}


public ProgramWindow () {
    barMenu = new JMenuBar ();
    menuFile = new JMenu ("Files");
    itemSplit = new JMenuItem ("Split file");
    itemJoin = new JMenuItem ("Join files");
    menuHash = new JMenu ("Compute file signature");
    itemMD5 = new JMenuItem ("MD5 hash");
    itemSHA1 = new JMenuItem ("SHA1 hash");
    itemExit = new JMenuItem ("Quit");
    itemSplit.addActionListener (this);
    itemJoin.addActionListener (this);
    itemMD5.addActionListener (this);
    itemSHA1.addActionListener (this);
    itemExit.addActionListener (this);
    menuFile.add (itemJoin);
    menuFile.add (itemSplit);
    menuFile.add (menuHash);
    menuHash.add (itemMD5);
    menuHash.add (itemSHA1);
    menuFile.add (itemExit);
    barMenu.add (menuFile);
    setJMenuBar (barMenu);
    progress = new JProgressBar (0, 100);
    progress.setStringPainted (true);
    progress.setVisible (false);
    getContentPane ().add (progress);
    setTitle ("Join Split");
    setSize (500, 150);
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            System.exit (0);
        }
    }
    );
}


-----Function Pair=270=-----==

private void loadHublists (Node fromNode) throws ConfigurationException {
    NodeList nodes = fromNode.getChildNodes ();
    Node n = nodes.item (0);
    while (n != null) {
        if ("item".equals (n.getNodeName ())) {
            Node urlAttr = n.getAttributes ().getNamedItem ("url");
            if (urlAttr == null) {
                throw new ConfigurationException ("Missing url attribute for hublists item.");
            }
            String urlText = urlAttr.getNodeValue ();
            URI uri = null;
            try {
                uri = new URI (urlText);
                hublists.add (uri);
            } catch (URISyntaxException e) {
            }
        }
        n = n.getNextSibling ();
    }
}


public Signature getSignature (Symbol key) throws Exception {
    if (false == this.allowKeyOverride) {
        return this.getSignature ();
    }
    String _spec = null;
    String _alg = ((Key) key.getValue ()).getAlgorithm ();
    if (key.existProperty (SymbolProperties.SignatureDigest)) {
        _spec = key.getProperty (SymbolProperties.SignatureDigest) + "with" + _alg;
        if (key.existProperty (SymbolProperties.SignatureMask)) {
            _spec = _spec + "and" + key.getProperty (SymbolProperties.SignatureMask);
        }
    }
    if (null == _spec) {
        String _defaultDigest = this.signatureSpec.substring (0, this.signatureSpec.indexOf ("with"));
        if (null == _defaultDigest) {
            _defaultDigest = "SHA1";
        }
        String _defaultAnd = "";
        int _andIndex = this.signatureSpec.indexOf ("and");
        if (- 1 != _andIndex) {
            _defaultAnd = this.signatureSpec.substring (_andIndex);
        }
        _spec = _defaultDigest + "with" + _alg + _defaultAnd;
    }
    return Signature.getInstance (_spec);
}


-----Function Pair=271=-----==

public void testCcndRetrieve () throws Exception {
    ContentName dataPrefix = testHelper.getTestNamespace ("TestCcndRetrieve");
    Flosser floss = new Flosser (dataPrefix);
    CCNStringObject so = new CCNStringObject (dataPrefix, "This is the value", SaveType.RAW, handle);
    so.save ();
    ContentName name = so.getVersionedName ();
    so.close ();
    floss.stop ();
    Operation < Interest, Object > getcontent = new Operation < Interest, Object > () {
        Object execute (Interest interest, Object ignored) throws Exception {
            ContentObject result = handle.get (interest, CCNNetworkManager.PERIOD);
            if (null == result) {
                throw new NoMatchingContentFoundException ("timeout on get for " + interest.name ());
            }
            return null;
        } int size (Interest interest) {
            return - 1;
        }
    }
    ;
    Interest interest = new Interest (name);
    System.out.println ("==== Single data retrieval from ccnd: " + name);
    runBenchmark ("retrieve data", getcontent, interest, null);
}


public static String loadFromFile (String fname) throws FileNotFoundException, IOException {
    FileInputStream fis = null;
    String ret = null;
    try {
        fis = new FileInputStream (fname);
        byte mybuffer [] = new byte [4096];
        int totalnum = fis.read (mybuffer);
        while (totalnum > 0) {
            String buf = new String (mybuffer, 0, totalnum);
            if (ret == null) ret = buf;
            else ret += buf;
            totalnum = fis.read (mybuffer);
        }
        return ret;
    } finally {
        try {
            fis.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=272=-----==

private Vector convertColDataMYSQL_ORACLE (String olddttype, String newdttype, Vector olddataVec) {
    Vector newdataVec = new Vector ();
    Enumeration enm = olddataVec.elements ();
    while (enm.hasMoreElements ()) {
        olddata = enm.nextElement ().toString ();
        String newdata = "'" + olddata + "'";
        if ((olddttype.equalsIgnoreCase ("Float") || olddttype.equalsIgnoreCase ("Integer") || olddttype.equalsIgnoreCase ("bigint") || olddttype.equalsIgnoreCase ("tinyint") || olddttype.equalsIgnoreCase ("Double") || olddttype.equalsIgnoreCase ("Varchar")) && newdttype.equalsIgnoreCase ("Date")) {
            newdata = "''";
        }
        if ((olddttype.equalsIgnoreCase ("Char") && newdttype.equalsIgnoreCase ("Number"))) {
            newdata = "'0'";
        }
        if (olddttype.equalsIgnoreCase ("Char") && (newdttype.equalsIgnoreCase ("Timestamp") || newdttype.equalsIgnoreCase ("DateTime") || newdttype.equalsIgnoreCase ("Date"))) {
            newdata = "''";
        }
        if ((olddttype.equalsIgnoreCase ("DateTime") || olddttype.equalsIgnoreCase ("Timestamp") || olddttype.equalsIgnoreCase ("Date")) && newdttype.equalsIgnoreCase ("Number")) {
            newdata = "'0'";
        }
        if (olddttype.equalsIgnoreCase ("DateTime") && newdttype.equalsIgnoreCase ("Timestamp")) {
            SimpleDateFormat sf = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss");
            try {
                Date d = sf.parse (olddata);
                sf = new SimpleDateFormat ("dd-MM-yyyy");
                String finalDate = sf.format (d);
                newdata = "to_date('" + finalDate + "','dd-MM-yyyy')";
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        if ((olddttype.equalsIgnoreCase ("Varchar") && newdttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "''";
        }
        if ((olddttype.equalsIgnoreCase ("Varchar") && newdttype.equalsIgnoreCase ("Number"))) {
            newdata = "'0'";
        }
        if (olddttype.equalsIgnoreCase ("Date")) {
            if (olddata.equals ("0")) {
                newdata = "";
            }
            else {
                if (newdttype.equalsIgnoreCase ("date")) {
                    olddata = olddata.replaceAll ("'", "''");
                    SimpleDateFormat sf = new SimpleDateFormat ("yyyy-MM-dd");
                    try {
                        Date d = sf.parse (olddata);
                        sf = new SimpleDateFormat ("dd-MM-yyyy");
                        String finalDate = sf.format (d);
                        if (olddata.contains ("0000-00-00")) newdata = "''";
                        else newdata = "to_date('" + finalDate + "','dd-MM-yyyy')";
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                }
            }
        }
        if (olddttype.equalsIgnoreCase (newdttype) && (! olddttype.equalsIgnoreCase ("Date"))) {
            newdata = "'" + olddata + "'";
        }
        if (olddttype.equalsIgnoreCase ("DateTime") && newdttype.equalsIgnoreCase ("Date")) {
            SimpleDateFormat formatter = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss");
            try {
                Date d = formatter.parse (olddata);
                formatter = new SimpleDateFormat ("dd-MM-yyyy");
                String finalDate = formatter.format (d);
                if (olddata.contains ("0000-00-00")) newdata = "''";
                else newdata = "to_date('" + finalDate + "','dd-MM-yyyy')";
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        if (olddttype.equalsIgnoreCase ("Time") && newdttype.equalsIgnoreCase ("Date")) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Year") && newdttype.equalsIgnoreCase ("Date")) {
            newdata = "''";
        }
        newdataVec.addElement (newdata);
    }
    return newdataVec;
}


private JPanel creePanelType (Date date) {
    JPanel paneltype = new JPanel ();
    JLabel lblTitre = new JLabel ("Par Type");
    paneltype.setLayout (new GridBagLayout ());
    List < Categorie > listCategorie = new ArrayList < Categorie > ();
    listCategorie = getListCategorie ("Type");
    paneltype.add (lblTitre, new GBC (0, 0, 3, 1).setAnchor (GBC.CENTER).setInsets (0, 0, 20, 0));
    int i = 1;
    for (final Categorie uneCategorie : listCategorie) {
        JLabel lblcat = new JLabel (uneCategorie.getLibelle ());
        final ChampMonetaire chmMontantType = new ChampMonetaire (0, 7, Formatter.getInstance ().getDecimalFormat ());
        chmMontantType.getDocument ().addDocumentListener (new CalculType ());
        paneltype.add (lblcat, new GBC (0, i).setAnchor (GBC.EAST).setInsets (0, 0, 10, 10));
        paneltype.add (chmMontantType, new GBC (1, i).setAnchor (GBC.WEST).setInsets (0, 0, 10, 0));
        chmMontantType.addFocusListener (new FocusListener () {
            public void focusGained (FocusEvent arg0) {
                if (chmMontantType.getText ().equals ("0,00")) {
                    chmMontantType.setText ("");
                }
            } public void focusLost (FocusEvent arg0) {
                if (chmMontantType.getText ().equals ("")) {
                    chmMontantType.setText ("0,00");
                }
            }
        }
        );
        if (uneCategorie.getOptions () != null && uneCategorie.getOptions ().equals ("Remise de ch�ques")) {
            JButton btnOption = new JButton ("Remise");
            btnOption.setPreferredSize (new Dimension (80, 20));
            btnOption.addActionListener (new ActionListener () {
                public void actionPerformed (ActionEvent arg0) {
                    lanceRemiseDeCheques (lblDate.getText (), chmMontantType.getText (), uneCategorie.getidCat ());
                }
            }
            );
            paneltype.add (btnOption, new GBC (2, i).setAnchor (GBC.WEST).setInsets (0, 0, 10, 0));
        }
        i ++;
    }
    return paneltype;
}


-----Function Pair=273=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=274=-----==

public void doSetPreference (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    if (args.length == 0) {
        ret.append ("Current preferences: \n");
        ret.append ("  integer = " + integerPreference + "\n");
        ret.append ("  stack = " + stackPreference + "\n");
        ret.append ("  fpr = " + fprPreference + "\n");
        jdp_console.writeOutput (ret.toString ());
    }
    else if (args [0].equals ("int")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) integerPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) integerPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("stack")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) stackPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) stackPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("fpr")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) fprPreference = 'x';
        else if (args [1].equals ("float") || args [1].equals ("f")) fprPreference = 'f';
        else printHelp (command);
        return;
    }
    else {
        printHelp (command);
    }
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=275=-----==

public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


private void transform (OPT_RegisterOperand rop) {
    OPT_Instruction inst = rop.instruction;
    switch (inst.getOpcode ()) {
        case CALL_opcode :
            OPT_RegisterOperand invokee = Call.getParam (inst, 0).asRegister ();
            if (invokee == rop) {
                OPT_MethodOperand mop = Call.getMethod (inst);
                if (mop.method.isSynchronized ()) {
                    mop.spMethod = context.findOrCreateSpecializedVersion (mop.method);
                    if (DEBUG) VM.sysWrite ("Identified call " + inst + " for unsynchronization\n");
                }
            }
            break;
        case MONITORENTER_opcode :
            if (DEBUG) {
                VM.sysWrite ("Removing " + inst);
            }
            if (! options.NO_CACHE_FLUSH) {
                inst.insertBefore (Empty.create (READ_CEILING));
            }
            OPT_DefUse.removeInstructionAndUpdateDU (inst);
            break;
        case MONITOREXIT_opcode :
            if (DEBUG) {
                VM.sysWrite ("Removing " + inst);
            }
            if (! options.NO_CACHE_FLUSH) {
                inst.insertAfter (Empty.create (WRITE_FLOOR));
            }
            OPT_DefUse.removeInstructionAndUpdateDU (inst);
            break;
        default :
            break;
    }
}


-----Function Pair=276=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=277=-----==

private breakpoint setMainBreakpoint () {
    JDP_Class mainThread = null;
    mainThread = user.bmap.currentThreadToJDPClass ();
    JDP_Field field = null;
    for (int i = 0; i < mainThread.fields.size (); i ++) {
        field = (JDP_Field) mainThread.fields.elementAt (i);
        if (field.name.equals ("args")) break;
    }
    JDP_Class argsArray = null;
    try {
        argsArray = user.bmap.arrayTypeToJDPClass (field.name, field.type, field.address, false);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field classNameField = (JDP_Field) argsArray.fields.elementAt (0);
    return setBreakpointAtStringClass (classNameField);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=278=-----==

private static Set getOpcodes (Method [] emitters) {
    Set s = new HashSet ();
    for (int i = 0; i < emitters.length; i ++) {
        String name = emitters [i].getName ();
        if (DEBUG) System.out.println (name);
        if (name.startsWith ("emit")) {
            int posOf_ = name.indexOf ('_');
            if (posOf_ != - 1) {
                String opcode = name.substring (4, posOf_);
                if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
            else {
                String opcode = name.substring (4);
                if (opcode.equals (opcode.toUpperCase (Locale.getDefault ()))) if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
        }
    }
    return s;
}


private static File getJarFile () {
    if (jarFile == null) {
        try {
            URL classURL = getClassURL ();
            if (classURL == null) return null;
            String url = classURL.toString ();
            if (url.startsWith ("jar:")) {
                int exclamationIndex = url.lastIndexOf ('!');
                if (exclamationIndex >= 0) {
                    if (url.charAt (9) != '/') {
                        url = url.substring (0, 9) + "/" + url.substring (9);
                        exclamationIndex ++;
                    }
                    URL jarURL = new URL (url.substring (4, exclamationIndex));
                    jarFile = new File (jarURL.toURI ());
                    if (! jarFile.exists ()) jarFile = null;
                }
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    isWebstart = jarFile != null && jarFile.exists () && jarFile.getName ().startsWith ("RM") && new File (jarFile.getParentFile (), "RT" + jarFile.getName ().substring (2)).exists ();
    return jarFile;
}


-----Function Pair=279=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=280=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=281=-----==

public void test31 () throws Exception {
    CsvWriter writer = new CsvWriter (new PrintWriter (new OutputStreamWriter (new FileOutputStream ("temp.csv"), Charset.forName ("UTF-8"))), ',');
    writer.write (" \t \t");
    writer.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new FileInputStream ("temp.csv"), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
    new File ("temp.csv").delete ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=282=-----==

public static void unzip1 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    if (! outputdir.exists ()) {
        outputdir.mkdirs ();
    }
    ArchiveInputStream zis = new ZipArchiveInputStream (new FileInputStream (zipfile));
    ArchiveEntry ae = zis.getNextEntry ();
    while (ae != null) {
        File newFile = new File (outputdir + File.separator + ae.getName ());
        if (! newFile.getParentFile ().exists ()) newFile.getParentFile ().mkdirs ();
        if (ae.isDirectory ()) {
            if (! newFile.exists ()) newFile.mkdir ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = zis.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
        }
        ae = zis.getNextEntry ();
    }
    zis.close ();
}


public void makeChromSet (File [] [] setRep, boolean treatmentSet) {
    File pCels = new File (parameters.getResultsDirectory (), "PCels");
    if (pCels.exists () == false) pCels.mkdir ();
    for (int r = 0; r < setRep [0].length; r ++) {
        File saveDir;
        if (treatmentSet) {
            saveDir = new File (pCels, "TreatmentReplica" + (r + 1));
            replicas [replicaIndex].setTreatmentReplica (true);
        }
        else {
            saveDir = new File (pCels, "ControlReplica" + (r + 1));
            replicas [replicaIndex].setTreatmentReplica (false);
        }
        replicas [replicaIndex].setSaveDirectory (saveDir);
        File [] set = new File [setRep.length];
        for (int j = 0; j < set.length; j ++) {
            String name = Misc.removeExtension (setRep [j] [r].getName ());
            File test = new File (setRep [j] [r].getParentFile (), name);
            if (test.exists () == false) Misc.printExit ("Missing normalized file! " + test);
            set [j] = test;
        }
        replicas [replicaIndex].setChipSetDirectories (set);
        replicaIndex ++;
    }
}


-----Function Pair=283=-----==

public void actionPerformed (ActionEvent arg0) {
    if (owner_ == null || owner_.getKey () == - 1) {
        Errmsg.notice (Resource.getPlainResourceString ("att_owner_null"));
        return;
    }
    File file;
    while (true) {
        JFileChooser chooser = new JFileChooser ();
        chooser.setCurrentDirectory (new File ("."));
        chooser.setDialogTitle (Resource.getResourceString ("choose_file"));
        chooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
        int returnVal = chooser.showOpenDialog (null);
        if (returnVal != JFileChooser.APPROVE_OPTION) return;
        String s = chooser.getSelectedFile ().getAbsolutePath ();
        file = new File (s);
        break;
    }
    try {
        LinkModel.getReference ().addLink (owner_, file.getAbsolutePath (), LinkModel.ATTACHMENT);
    } catch (Exception e) {
        Errmsg.errmsg (e);
    }
}


private void setDefaultsAndActions () {
    fileBrowser.getSelectionModel ().addTreeSelectionListener (new TreeSelectionListener () {
        @Override
        public void valueChanged (TreeSelectionEvent e) {
            if (fileBrowser.getSelectionCount () != 1) {
                return;
            }
            final File file = (File) fileBrowser.getSelectionPath ().getLastPathComponent ();
            if (file instanceof ZipFileProxy || file.isDirectory ()) {
                return;
            }
            showPhoto (file);
            imgPreview.propertyChange (new PropertyChangeEvent (this, JFileChooser.SELECTED_FILE_CHANGED_PROPERTY, null, file));
        }
    }
    );
    fileBrowser.addKeyListener (new KeyAdapter () {
        @Override
        public void keyTyped (final KeyEvent e) {
            if (e.getKeyChar () != '\n') {
                return;
            }
            final TreePath path = fileBrowser.getSelectionPath ();
            if (path == null) {
                return;
            }
            final File file = (File) path.getLastPathComponent ();
            if (file.isFile ()) {
                attachAndRunDemo ((File) fileBrowser.getSelectionPath ().getLastPathComponent (), null);
            }
        }
    }
    );
    fileBrowser.addMouseListener (new MouseAdapter () {
        @Override
        public void mouseClicked (final MouseEvent mouseEvent) {
            final TreePath selectionPath = fileBrowser.getSelectionPath ();
            if (selectionPath == null || ! (selectionPath.getLastPathComponent () instanceof File)) {
                return;
            }
            final File tuneFile = (File) selectionPath.getLastPathComponent ();
            if (! tuneFile.isFile ()) {
                return;
            }
            if (mouseEvent.getButton () == MouseEvent.BUTTON1 && mouseEvent.getClickCount () > 1) {
                attachAndRunDemo ((File) fileBrowser.getSelectionPath ().getLastPathComponent (), null);
            }
        }
    }
    );
}


-----Function Pair=284=-----==

public boolean fixExtension (File file, String prefExt) {
    String fileName = file.getName ();
    String dir = file.getParentFile ().getAbsolutePath ();
    String ext = null;
    try {
        ext = fileName.substring (fileName.lastIndexOf ("."), fileName.length ());
        System.out.println ("Original File Extension: " + ext);
    } catch (StringIndexOutOfBoundsException e) {
        ext = null;
    }
    if (ext != null && ! ext.equalsIgnoreCase ("." + prefExt)) {
        return false;
    }
    String csvName = null;
    if (ext == null || ext.length () == 0) {
        csvName = fileName + "." + prefExt;
    }
    else {
        csvName = fileName.substring (0, fileName.lastIndexOf (".") + 1) + prefExt;
    }
    System.out.println ("Corrected File Name: " + csvName);
    File csvCert = new File (dir, csvName);
    if (csvCert.exists ()) {
        int val = JOptionPane.showConfirmDialog (null, "Replace Existing File?", "File Exists", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE);
        if (val == JOptionPane.NO_OPTION) {
            obtainFileName ();
            cancelOp = true;
            return false;
        }
        else if (val == JOptionPane.CANCEL_OPTION) {
            cancelOp = true;
            return false;
        }
    }
    if (! file.renameTo (csvCert)) {
        file = new File (dir, csvName);
        try {
            file.createNewFile ();
        } catch (IOException ioe) {
        }
    }
    System.out.println ("Exporting as: " + file.getAbsolutePath ());
    return true;
}


public static final List < File > list (final File root, final int minDepth, final int maxDepth, final FileFilter ff, final boolean sort) {
    if (minDepth > maxDepth) throw new IllegalArgumentException (minDepth + " > " + maxDepth);
    if (maxDepth < 0) throw new IllegalArgumentException (maxDepth + " < 0");
    if (! root.exists ()) return Collections.< File > emptyList ();
    final File currentFile = accept (ff, minDepth, maxDepth, root, 0) ? root : null;
    if (maxDepth == 0) {
        return currentFile == null ? Collections.< File > emptyList () : Collections.singletonList (currentFile);
    }
    else {
        final List < File > res = new ArrayList < File > ();
        final File [] children = root.listFiles ();
        if (children == null) throw new IllegalStateException ("cannot list " + root);
        if (sort) Arrays.sort (children);
        for (final File child : children) {
            if (maxDepth > 1 && child.isDirectory ()) {
                res.addAll (list (child, minDepth - 1, maxDepth - 1, ff, sort));
            }
            else if (accept (ff, minDepth, maxDepth, child, 1)) {
                res.add (child);
            }
        }
        if (currentFile != null) res.add (currentFile);
        return res;
    }
}


-----Function Pair=285=-----==

public void actionPerformed (ActionEvent e) {
    final TimeSlotTracker tst = layoutManager.getTimeSlotTracker ();
    if (chooseFileResult.getFile () == null) {
        String msgTitle = layoutManager.getCoreString ("reports.configuration-window.noResultFile.title");
        String msg = layoutManager.getCoreString ("reports.configuration-window.noResultFile.msg");
        JOptionPane.showMessageDialog (ReportConfiguration.this, msg, msgTitle, JOptionPane.ERROR_MESSAGE);
        return;
    }
    try {
        tst.setCursorWait ();
        Runnable runnable = new Runnable () {
            public void run () {
                Thread.yield ();
                runReport ();
            }
        }
        ;
        Thread runThread = new Thread (runnable);
        runThread.start ();
        runThread.join ();
        if (reportCompleted) {
            ReportConfiguration.this.dispose ();
        }
        else {
            String title = layoutManager.getCoreString ("reprots.configuration-window.run.errorTitle");
            JOptionPane.showMessageDialog (ReportConfiguration.this, reportErrorMessage, title, JOptionPane.ERROR_MESSAGE);
        }
    } catch (InterruptedException ex) {
    } finally {
        tst.setCursorDefault ();
    }
}


private void redirectTo (URL url) {
    if (UILocation.isInterfaceLocation (url.toString ())) {
        String interfaceLocation = UILocation.extractLocation (url.getQuery ());
        String interfaceInitialization = UILocation.extractInitialization (url.getQuery ());
        String objectParameter = UILocation.extractParameter (url.getQuery ());
        UILocation target = targets.get (interfaceLocation);
        UIInitialization [] initialization = UIInitializations.MAP.get (interfaceInitialization);
        if (target != null) if (object instanceof RedirectionObject) UIResources.getDefaultNavigator ().navigate (target, ((RedirectionObject) object).getObject (objectParameter), initialization);
        else UIResources.getDefaultNavigator ().navigate (target, object, initialization);
    }
    else {
        try {
            if (url.toString ().equals (DefaultServerSettings.signOutURL)) Effectopedia.EFFECTOPEDIA.getAutentication ().signOut (new URL (DefaultServerSettings.signOutURL));
            else if (DefaultServerSettings.isInternallyLoadedURL (url)) pane.setPage (url);
            else openTheDefaultBrowser (url.toString ());
        } catch (IOException e1) {
            e1.printStackTrace ();
        }
    }
}


-----Function Pair=286=-----==

public void valueChanged (TreeSelectionEvent e) {
    Object o = e.getPath ().getLastPathComponent ();
    if (o.toString ().equals ("About")) {
        try {
            jHelpEditorPane.setPage (this.getClass ().getResource ("sample1.html"));
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        jHelpEditorPane.addHyperlinkListener (new javax.swing.event.HyperlinkListener () {
            public void hyperlinkUpdate (javax.swing.event.HyperlinkEvent evt) {
                jHelpEditorPaneHyperlinkUpdate (evt);
            }
        }
        );
    }
    else if (o.toString ().equals ("Basics")) {
        try {
            jHelpEditorPane.setPage (this.getClass ().getResource ("sample2.html"));
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        jHelpEditorPane.addHyperlinkListener (new javax.swing.event.HyperlinkListener () {
            public void hyperlinkUpdate (javax.swing.event.HyperlinkEvent evt) {
                jHelpEditorPaneHyperlinkUpdate (evt);
            }
        }
        );
    }
    else if (o.toString ().equals ("Preset Slide Types")) {
        try {
            jHelpEditorPane.setPage (this.getClass ().getResource ("sample3.html"));
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        jHelpEditorPane.addHyperlinkListener (new javax.swing.event.HyperlinkListener () {
            public void hyperlinkUpdate (javax.swing.event.HyperlinkEvent evt) {
                jHelpEditorPaneHyperlinkUpdate (evt);
            }
        }
        );
    }
    else if (o.toString ().equals ("Keyboard Shortcuts")) {
        try {
            jHelpEditorPane.setPage (this.getClass ().getResource ("sample4.html"));
        } catch (IOException ex) {
            ex.printStackTrace ();
        }
        jHelpEditorPane.addHyperlinkListener (new javax.swing.event.HyperlinkListener () {
            public void hyperlinkUpdate (javax.swing.event.HyperlinkEvent evt) {
                jHelpEditorPaneHyperlinkUpdate (evt);
            }
        }
        );
    }
}


public void hyperlinkUpdate (HyperlinkEvent e) {
    if (e.getEventType () == HyperlinkEvent.EventType.ACTIVATED) {
        if (Desktop.isDesktopSupported ()) {
            Desktop desktop = Desktop.getDesktop ();
            if (desktop.isSupported (Desktop.Action.BROWSE)) {
                try {
                    URI uri = e.getURL ().toURI ();
                    desktop.browse (uri);
                } catch (URISyntaxException ex) {
                    System.err.println ("A link in the description.html is not correct: " + e.getURL ());
                } catch (IOException ex) {
                    System.err.println ("Cannot navigate to link since a default program is not set or does not exist.");
                }
            }
        }
    }
}


-----Function Pair=287=-----==

public void displayFeed (Rssfeed feed) {
    if (feed != null) {
        listRssModel.removeAllElements ();
        List < RssItem > oldEntries = juicyNews.getOldEntries (feed);
        List < RssItem > newEntries = juicyNews.getNewEntries (feed);
        if (newEntries != null) {
            Iterator < RssItem > newsIterator = newEntries.iterator ();
            while (newsIterator.hasNext ()) {
                RssItem news = newsIterator.next ();
                listRssModel.addElement (news);
            }
        }
        else {
            listRssModel.removeAllElements ();
        }
    }
}


public static void setLocation (Window window) {
    Integer x = ConfigurationHelper.getInteger (window, "x", null);
    Integer y = ConfigurationHelper.getInteger (window, "y", null);
    Dimension screenSize = getScreenSize ();
    if ((x != null && y != null) && (x >= screenSize.getWidth () - 50 || y >= screenSize.getHeight () - 50)) {
        x = null;
        y = null;
    }
    if (x != null && y != null) {
        window.setLocation (x.intValue (), y.intValue ());
    }
    else {
        Component parent = null;
        if (window instanceof JFrame) {
            parent = ((JFrame) window).getRootPane ();
        }
        else if (window instanceof JDialog) {
            parent = ((JDialog) window).getRootPane ();
        }
        window.setLocationRelativeTo (parent);
    }
}


-----Function Pair=288=-----==

public void set (final Object bean, final Integer index, final Object value) {
    try {
        if (index == null) {
            this.set.invoke (bean, convert (this.type, this.componentType, value));
        }
        else {
            Object array = get (bean, index, true, false);
            if (array instanceof List) {
                ((List < Object >) array).set (index, convert (this.componentType, null, value));
            }
            else {
                Array.set (array, index, value);
            }
        }
    } catch (IllegalArgumentException e) {
        throw new BexlException (e);
    } catch (IllegalAccessException e) {
        throw new BexlException (e);
    } catch (InvocationTargetException e) {
        throw new BexlException (e);
    } catch (SecurityException e) {
        throw new BexlException (e);
    }
}


private PropertyEditor getCustomEditor (Class requiredType) {
    if (requiredType != null) {
        PropertyEditor editor = (PropertyEditor) this.customEditors.get (requiredType);
        if (editor == null) {
            for (Iterator it = this.customEditors.keySet ().iterator (); it.hasNext ();) {
                Object key = it.next ();
                if (key instanceof Class && ((Class) key).isAssignableFrom (requiredType)) {
                    editor = (PropertyEditor) this.customEditors.get (key);
                }
            }
        }
        return editor;
    }
    return null;
}


-----Function Pair=289=-----==

private void buildReferenceList (HashMap < Class, HashSet < Long > > list, long id, Class c, Class subtype) throws SQLException {
    Object object;
    if (c != StoredList.class) object = getById (id, c);
    else object = new StoredList (ProxyStorage.this, subtype, id);
    HashSet < Long > set = list.get (c);
    if (set == null) {
        set = new HashSet ();
        list.put (c, set);
    }
    if (set.contains (id)) return;
    set.add (id);
    if (c == StoredList.class) {
        StoredList storedList = (StoredList) object;
        int size = storedList.size ();
        for (int i = 0; i < size; i ++) {
            ProxyObject result = (ProxyObject) storedList.get (i);
            buildReferenceList (list, result.getProxyStorageId (), subtype, null);
        }
    }
    else {
        for (Method method : getGetterMethods (c)) {
            if (method.getReturnType ().isAnnotationPresent (ProxyBean.class)) {
                try {
                    ProxyObject result = (ProxyObject) method.invoke (object, new Object [0]);
                    if (result != null) buildReferenceList (list, result.getProxyStorageId (), method.getReturnType (), null);
                } catch (Exception e) {
                    throw new RuntimeException (e);
                }
            }
            else if (method.getReturnType () == StoredList.class) {
                try {
                    StoredList result = (StoredList) method.invoke (object, new Object [0]);
                    buildReferenceList (list, result.getProxyStorageId (), StoredList.class, method.getAnnotation (ListType.class).value ());
                } catch (Exception e) {
                    throw new RuntimeException (e);
                }
            }
        }
    }
}


private JMethod generateCopyConstructor (final ClassOutline clazz) {
    final JMethod ctor = clazz.implClass.constructor (JMod.PUBLIC);
    final JClass paramClass = this.hierarchical ? this.getSupertype (clazz.implClass) : clazz.implClass;
    final JVar o = ctor.param (JMod.FINAL, paramClass, "o");
    final boolean superTypeParam = ! clazz.implClass.equals (paramClass);
    ctor.javadoc ().add ("Creates a new {@code " + clazz.implClass.name () + "} instance by deeply copying a given {@code " + paramClass.name () + "} instance.\n");
    if (! this.nullable) {
        ctor.javadoc ().addParam (o).add ("The instance to copy.");
        ctor.javadoc ().addThrows (NullPointerException.class).append ("if {@code o} is {@code null}.");
    }
    else {
        ctor.javadoc ().addParam (o).add ("The instance to copy or {@code null}.");
    }
    ctor.body ().directStatement ("// " + getMessage ("title"));
    if (this.needsWarningOnReferencedSupertypes (clazz)) {
        ctor.body ().directStatement ("// " + WARNING_PREFIX + ": A super-class of this class was not part of the compilation unit.");
        ctor.body ().directStatement ("// " + WARNING_PREFIX + ": The plugin assumes this super-class to directly extend class " + "'java.lang.Object'.");
        ctor.body ().directStatement ("// " + WARNING_PREFIX + ": The type of the constructor arguments (type of o) in the hierarchy " + "this constructor is part");
        ctor.body ().directStatement ("// " + WARNING_PREFIX + ": of may be wrong and must be verified.");
    }
    if (clazz.getSuperClass () != null || (clazz.implClass._extends () != null && ! clazz.implClass._extends ().binaryName ().equals ("java.lang.Object"))) {
        ctor.body ().invoke ("super").arg (o);
    }
    else {
        ctor.body ().invoke ("super");
    }
    if (! this.nullable) {
        ctor.body ()._if (o.eq (JExpr._null ()))._then ()._throw (JExpr._new (clazz.parent ().getCodeModel ().ref (NullPointerException.class)).arg ("Cannot create a copy of '" + clazz.implClass.name () + "' from 'null'."));
    }
    this.contextExceptions.clear ();
    boolean hasFields = false;
    if (! clazz.implClass.fields ().isEmpty ()) {
        final JBlock copyBlock = new JBlock (false, false);
        final JExpression source = superTypeParam ? JExpr.cast (clazz.implClass, o) : o;
        for (FieldOutline field : clazz.getDeclaredFields ()) {
            hasFields = true;
            this.generateCopyOfProperty (field, JExpr._this (), source, copyBlock, false);
        }
        for (JFieldVar field : clazz.implClass.fields ().values ()) {
            if ((field.mods ().getValue () & JMod.STATIC) == JMod.STATIC) {
                continue;
            }
            hasFields = true;
            final FieldOutline fieldOutline = this.getFieldOutline (clazz, field.name ());
            if (fieldOutline == null) {
                if (field.type ().isPrimitive ()) {
                    copyBlock.directStatement ("// Unknown primitive field '" + field.name () + "'.");
                    copyBlock.assign (JExpr.refthis (field.name ()), source.ref (field));
                    this.log (Level.WARNING, "fieldWithoutProperties", field.name (), clazz.implClass.name ());
                }
                else {
                    if (field.name ().equals ("otherAttributes") && clazz.target.declaresAttributeWildcard ()) {
                        copyBlock.directStatement ("// Other attributes.");
                        copyBlock.add (JExpr.refthis (field.name ()).invoke ("putAll").arg (source.ref (field)));
                    }
                    else {
                        copyBlock.directStatement ("// Unknown reference field '" + field.name () + "'.");
                        copyBlock.assign (JExpr.refthis (field.name ()), JExpr.cast (field.type (), this.getCopyOfObjectInvocation (clazz).arg (source.ref (field))));
                        this.log (Level.WARNING, "fieldWithoutProperties", field.name (), clazz.implClass.name ());
                    }
                }
            }
        }
        if (hasFields) {
            JBlock effective = ctor.body ();
            if (! this.contextExceptions.isEmpty ()) {
                final JTryBlock tryCopy = ctor.body ()._try ();
                effective = tryCopy.body ();
                if (this.contextExceptions.contains (Exception.class)) {
                    this.contextExceptions.retainAll (Arrays.asList (new Class < ? > [] {Exception.class}));
                }
                for (Class < ? > e : this.contextExceptions) {
                    final JCatchBlock catchBlock = tryCopy._catch (clazz.parent ().getCodeModel ().ref (e));
                    catchBlock.body ().directStatement ("// Please report this at " + getMessage ("bugtrackerUrl"));
                    catchBlock.body ()._throw (JExpr._new (clazz.parent ().getCodeModel ().ref (AssertionError.class)).arg (catchBlock.param ("e")));
                }
            }
            if (superTypeParam) {
                effective._if (o._instanceof (clazz.implClass))._then ().add (copyBlock);
            }
            else if (this.nullable) {
                effective._if (o.ne (JExpr._null ()))._then ().add (copyBlock);
            }
            else {
                effective.add (copyBlock);
            }
        }
    }
    this.constructorCount = this.constructorCount.add (BigInteger.ONE);
    return ctor;
}


-----Function Pair=290=-----==

public void channel_process (RdpPacket_Localised data, int mcsChannel) throws RdesktopException, IOException, CryptoException {
    int length, flags;
    int thislength = 0;
    VChannel channel = null;
    int i;
    for (i = 0; i < num_channels; i ++) {
        if (mcs_id (i) == mcsChannel) {
            channel = channels [i];
            break;
        }
    }
    if (i >= num_channels) return;
    length = data.getLittleEndian32 ();
    flags = data.getLittleEndian32 ();
    if (((flags & CHANNEL_FLAG_FIRST) != 0) && ((flags & CHANNEL_FLAG_LAST) != 0)) {
        channel.process (data);
    }
    else {
        byte [] content = new byte [data.getEnd () - data.getPosition ()];
        data.copyToByteArray (content, 0, data.getPosition (), content.length);
        fragment_buffer = append (fragment_buffer, content);
        if ((flags & CHANNEL_FLAG_LAST) != 0) {
            RdpPacket_Localised fullpacket = new RdpPacket_Localised (fragment_buffer.length);
            fullpacket.copyFromByteArray (fragment_buffer, 0, 0, fragment_buffer.length);
            channel.process (fullpacket);
            fragment_buffer = null;
        }
    }
}


public final List < T > toContentList (final ListDirection direction, final Filter < ? super T, ? >...filters) {
    final List < T > flattenedTree = toContentList (direction);
    final List < T > out = new ArrayList (this.getSize ());
    for (T node : flattenedTree) {
        if (node != null) {
            final T [] eArray = (T []) Array.newInstance (getContentClass (), 1);
            eArray [0] = node;
            boolean allAccept = true;
            for (Filter filter : filters) {
                allAccept = allAccept && filter.accept (eArray);
            }
            if (allAccept) {
                out.add (node);
            }
        }
    }
    return out;
}


-----Function Pair=291=-----==

public static Object [] remove (Object [] array, Object value) {
    if (array != null) {
        for (int index = 0, n = array.length; index < n; index ++) {
            if (value.equals (array [index])) {
                if (n == 1) {
                    return null;
                }
                Object [] tmp = (Object []) java.lang.reflect.Array.newInstance (array.getClass ().getComponentType (), array.length - 1);
                if (index > 0) {
                    System.arraycopy (array, 0, tmp, 0, index);
                }
                if (index < tmp.length) {
                    System.arraycopy (array, index + 1, tmp, index, tmp.length - index);
                }
                return tmp;
            }
        }
    }
    return array;
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=292=-----==

private Object getPropertyForSpecification (final PropertySpecification name) throws BeanException {
    final PropertyDescriptor pd = (PropertyDescriptor) properties.get (name.getName ());
    if (pd == null) {
        throw new BeanException ("No such property:" + name);
    }
    if (pd instanceof IndexedPropertyDescriptor && name.getIndex () != null) {
        final IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) pd;
        final Method readMethod = ipd.getIndexedReadMethod ();
        if (readMethod == null) {
            throw new BeanException ("Property is not readable: " + name);
        }
        try {
            return readMethod.invoke (bean, new Object [] {new Integer (name.getIndex ())});
        } catch (Exception e) {
            throw new BeanException ("InvokationError", e);
        }
    }
    else {
        final Method readMethod = pd.getReadMethod ();
        if (readMethod == null) {
            throw new BeanException ("Property is not readable: " + name);
        }
        if (name.getIndex () != null) {
            try {
                final Object value = readMethod.invoke (bean, null);
                if (value == null) {
                    throw new IndexOutOfBoundsException ("No such index, property is null");
                }
                if (value.getClass ().isArray () == false) {
                    throw new BeanException ("The property contains no array.");
                }
                final int index = Integer.parseInt (name.getIndex ());
                return Array.get (value, index);
            } catch (BeanException be) {
                throw be;
            } catch (IndexOutOfBoundsException iob) {
                throw iob;
            } catch (Exception e) {
                throw new BeanException ("Failed to read indexed property.");
            }
        }
        try {
            return readMethod.invoke (bean, null);
        } catch (Exception e) {
            throw new BeanException ("InvokationError", e);
        }
    }
}


public void grow (int minimumCapacity) {
    ++ modCount;
    int oldCapacity = data == null ? 0 : data.length;
    if (minimumCapacity > oldCapacity) {
        Object oldData [] = data;
        int newCapacity = oldCapacity + oldCapacity / 2 + 4;
        if (newCapacity < minimumCapacity) {
            newCapacity = minimumCapacity;
        }
        data = newData (newCapacity);
        if (oldData != null) {
            System.arraycopy (oldData, 0, data, 0, size);
        }
    }
}


-----Function Pair=293=-----==

public int read () {
    File fileTemp = new File (trustedLocationLocal);
    int fileLength = (int) fileTemp.length ();
    byte [] fileBytes = new byte [fileLength];
    byte [] decryptedBytes = null;
    byte [] block = null;
    int result = 0;
    if (fileTemp.exists ()) {
        try {
            RandomAccessFile raf = new RandomAccessFile (fileTemp, "rw");
            int length = raf.read (fileBytes);
            try {
                Cipher cipher = Cipher.getInstance ("PBEWithMD5AndDES");
                cipher.init (Cipher.DECRYPT_MODE, secretKey, paramSpec);
                block = cipher.doFinal (fileBytes);
            } catch (Exception e) {
                this.showMessage ("Using secretKey to read TCB failed", SAWSTextOutputCallback.ERROR);
                if (debugLevel >= SAWSConstant.ErrorInfo) sawsDebugLog.write (e + "\nUsing secretKey to read TCB failed");
                result = - 1;
            }
            raf.close ();
        } catch (Exception e) {
            if (debugLevel >= SAWSConstant.ErrorInfo) sawsDebugLog.write (e);
            result = - 1;
        }
        if (result != - 1) {
            result = extractASN1Block (block);
        }
    }
    return result;
}


public static String downloadWebpage2 (String address) throws MalformedURLException, IOException {
    URL url = new URL (address);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
    HttpURLConnection.setFollowRedirects (true);
    String encoding = conn.getContentEncoding ();
    InputStream is = null;
    if (encoding != null && encoding.equalsIgnoreCase ("gzip")) {
        is = new GZIPInputStream (conn.getInputStream ());
    }
    else if (encoding != null && encoding.equalsIgnoreCase ("deflate")) {
        is = new InflaterInputStream (conn.getInputStream ());
    }
    else {
        is = conn.getInputStream ();
    }
    BufferedReader br = new BufferedReader (new InputStreamReader (is));
    String line;
    String page = "";
    while ((line = br.readLine ()) != null) {
        page += line + "\n";
    }
    br.close ();
    return page;
}


-----Function Pair=294=-----==

public void addTrustedCertificate (Certificate cert, boolean rehashKeystoreEntries) throws Exception {
    String alias = CertificateUtility.getCommonName ((X509Certificate) cert);
    Certificate original = keyStore.getCertificate (alias);
    if (original != null && ! original.equals (cert)) {
        alias = checkDuplicateAlias (alias);
    }
    keyStore.setCertificateEntry (alias, cert);
    alias = keyStore.getCertificateAlias (cert);
    logger.info ("Added new trusted certificate for: " + alias + " to the keystore");
    if (rehashKeystoreEntries) {
        rehashKeystoreEntries ();
    }
    else {
        this.addEntryToKeystoreManager (alias);
    }
}


public void loadTrustedCertificate (File certFile) throws Exception {
    X509Certificate cert = (X509Certificate) CertificateUtility.importTrustedCertifcate (certFile);
    logger.fine ("Importing cert for: " + ((X509Certificate) cert).getSubjectDN ().getName ());
    X509Certificate oriCert = getCertificateByKey (cert.getPublicKey ());
    if (oriCert == null) {
        logger.info ("Adding new trusted certificate: " + cert);
        addTrustedCertificate (cert, true);
    }
    else {
        String alias = getAliasFromCertifcate (oriCert);
        if (isKeyEntry (alias)) {
            logger.info ("Replacing key certificate: " + alias);
            replaceKeyCertificate (alias, cert, true);
        }
        else {
            logger.info ("Replacing trusted certifcate: " + alias);
            addTrustedCertificate (cert, true);
        }
    }
}


-----Function Pair=295=-----==

private int compareImage (BufferedImage image1, BufferedImage image2) {
    int x = 0;
    int startx = - 1;
    int stopx = - 1;
    for (int i = 0; i < image1.getHeight () - 1; i ++) {
        for (int j = 0; j < image1.getWidth () - 1; j ++) {
            int rgb1 = image1.getRGB (j, i);
            int rgb2 = image2.getRGB (j, i);
            if (rgb1 == rgb2) {
                if (startx != - 1) {
                    stopx = j;
                    break;
                }
                continue;
            }
            else {
                startx = j;
            }
        }
    }
    return startx + (stopx - startx) / 2;
}


public Capture (String title) {
    super (title);
    setDefaultCloseOperation (EXIT_ON_CLOSE);
    dimScreenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    rectScreenSize = new Rectangle (dimScreenSize);
    final JFileChooser fcSave = new JFileChooser ();
    fcSave.setCurrentDirectory (new File (System.getProperty ("user.dir")));
    fcSave.setAcceptAllFileFilterUsed (false);
    fcSave.setFileFilter (new ImageFileFilter ());
    JMenuBar mb = new JMenuBar ();
    JMenu menu = new JMenu ("File");
    ActionListener al;
    JMenuItem mi = new JMenuItem ("Save As...");
    mi.setAccelerator (KeyStroke.getKeyStroke (KeyEvent.VK_S, InputEvent.ALT_MASK));
    al = new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (ia.getImage () == null) {
                showError ("No captured image.");
                return;
            }
            fcSave.setSelectedFile (null);
            if (fcSave.showSaveDialog (Capture.this) != JFileChooser.APPROVE_OPTION) return;
            File file = fcSave.getSelectedFile ();
            String path = file.getAbsolutePath ().toLowerCase ();
            if (! path.endsWith (".jpg") && ! path.endsWith (".jpeg")) file = new File (path += ".jpg");
            if (file.exists ()) {
                int choice = JOptionPane.showConfirmDialog (null, "Overwrite file?", "Capture", JOptionPane.YES_NO_OPTION);
                if (choice == JOptionPane.NO_OPTION) return;
            }
            ImageWriter writer = null;
            ImageOutputStream ios = null;
            try {
                Iterator iter;
                iter = ImageIO.getImageWritersByFormatName ("jpeg");
                if (! iter.hasNext ()) {
                    showError ("Unable to save image to jpeg file type.");
                    return;
                }
                writer = (ImageWriter) iter.next ();
                ios = ImageIO.createImageOutputStream (file);
                writer.setOutput (ios);
                ImageWriteParam iwp = writer.getDefaultWriteParam ();
                iwp.setCompressionMode (ImageWriteParam.MODE_EXPLICIT);
                iwp.setCompressionQuality (0.95f);
                writer.write (null, new IIOImage ((BufferedImage) ia.getImage (), null, null), iwp);
            } catch (IOException e2) {
                showError (e2.getMessage ());
            } finally {
                try {
                    if (ios != null) {
                        ios.flush ();
                        ios.close ();
                    }
                    if (writer != null) writer.dispose ();
                } catch (IOException e2) {
                }
            }
        }
    }
    ;
    mi.addActionListener (al);
    menu.add (mi);
    menu.addSeparator ();
    mi = new JMenuItem ("Exit");
    mi.setAccelerator (KeyStroke.getKeyStroke (KeyEvent.VK_X, InputEvent.ALT_MASK));
    mi.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            System.exit (0);
        }
    }
    );
    menu.add (mi);
    mb.add (menu);
    menu = new JMenu ("Capture");
    mi = new JMenuItem ("Capture");
    mi.setAccelerator (KeyStroke.getKeyStroke (KeyEvent.VK_C, InputEvent.ALT_MASK));
    al = new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            setVisible (false);
            BufferedImage biScreen;
            biScreen = robot.createScreenCapture (rectScreenSize);
            setVisible (true);
            ia.setImage (biScreen);
            jsp.getHorizontalScrollBar ().setValue (0);
            jsp.getVerticalScrollBar ().setValue (0);
        }
    }
    ;
    mi.addActionListener (al);
    menu.add (mi);
    mb.add (menu);
    mi = new JMenuItem ("Crop");
    mi.setAccelerator (KeyStroke.getKeyStroke (KeyEvent.VK_K, InputEvent.ALT_MASK));
    al = new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (ia.crop ()) {
                jsp.getHorizontalScrollBar ().setValue (0);
                jsp.getVerticalScrollBar ().setValue (0);
            }
            else showError ("Out of bounds.");
        }
    }
    ;
    mi.addActionListener (al);
    menu.add (mi);
    mb.add (menu);
    setJMenuBar (mb);
    getContentPane ().add (jsp = new JScrollPane (ia));
    setSize (dimScreenSize.width / 2, dimScreenSize.height / 2);
    setLocation ((dimScreenSize.width - dimScreenSize.width / 2) / 2, (dimScreenSize.height - dimScreenSize.height / 2) / 2);
    setVisible (true);
}


-----Function Pair=296=-----==

public void run () {
    df.resetImage ();
    boolean lastCaptureWasDifferences = usingDifferences;
    while (sharerState == ACTIVE_SHARER) {
        if (sendingImages) {
            try {
                AppSharePacket packet = null;
                BufferedImage buff = robot.createScreenCapture (sharingRegion);
                if (usingDifferences) {
                    if (! lastCaptureWasDifferences) {
                        df.resetImage ();
                        lastCaptureWasDifferences = true;
                    }
                    Vector differences = df.createDifference (buff);
                    if (differences.size () > 0) packet = new AppSharePacket (differences, myClientKey);
                }
                else {
                    lastCaptureWasDifferences = false;
                    if (! isDifferent (buff)) {
                        buff = null;
                    }
                    packet = new AppSharePacket (buff, myClientKey, quality);
                }
                if (packet != null) {
                    sendDataToOthers (packet);
                    if (previewing) {
                        if (appSharePanel != null) {
                            appSharePanel.setDisplayImageTitle ("Previewing... sent " + packet.length + " bytes in image");
                            appSharePanel.displayImage (packet);
                            appSharePanel.imageLabel.setText (null);
                        }
                    }
                    else {
                        if (appSharePanel != null) {
                            appSharePanel.setDisplayImageTitle ("not Previewing...");
                            appSharePanel.displayImage (null);
                            appSharePanel.imageLabel.setText ("sent " + packet.length + " bytes in image");
                        }
                    }
                    if (! controllingClient.equals ("")) {
                        if (SessionUtilities.getVerbose ()) System.out.println ("Waiting for ACK from controller...");
                        waitForControllerToAck ();
                        if (SessionUtilities.getVerbose ()) System.out.println ("Received ACK");
                    }
                }
            } catch (java.awt.image.RasterFormatException rfe) {
            }
        }
        try {
            Thread.sleep (delayTime);
        } catch (Exception e) {
        }
    }
}


public void getFlop () {
    char couleur = 'o';
    int [] pix = new int [54];
    BufferedImage image1 = this.bot.createScreenCapture (new Rectangle (i + 165, j + 97, 3, 18));
    PixelGrabber pg = new PixelGrabber (image1, 0, 0, 3, 18, pix, 0, 3);
    try {
        ImageIO.write (image1, "png", new File ("coincoin.png"));
    } catch (IOException e1) {
        e1.printStackTrace ();
    }
    try {
        pg.grabPixels ();
    } catch (InterruptedException d) {
        System.err.println ("en attente des pixels");
    }
    if ((pix [53]>> 8 & 0xFF) == (pix [53]>> 16 & 0xFF) && (pix [53]>> 8 & 0xFF) == (pix [53]>> 0 & 0xFF)) {
        couleur = 's';
    }
    else if ((pix [53]>> 16 & 0xFF) > (pix [53]>> 8 & 0xFF) && (pix [53]>> 16 & 0xFF) > (pix [53]>> 0 & 0xFF)) {
        couleur = 'h';
    }
    else if ((pix [53]>> 0 & 0xFF) > (pix [53]>> 16 & 0xFF) && (pix [53]>> 0 & 0xFF) > (pix [53]>> 8 & 0xFF)) {
        couleur = 'd';
    }
    else {
        couleur = 'c';
    }
    if (pix [7] == - 1 && pix [18] == pix [19] && pix [5] == pix [8] && pix [11] == pix [14]) {
        if (pix [20] != - 1) {
            this.flop [0] = new Card ('K', couleur);
        }
        else {
            this.flop [0] = new Card ('J', couleur);
        }
    }
    else if (pix [15] == pix [18] && pix [3] == - 1 && pix [20] != - 1 & pix [35] != - 1) {
        if (pix [20] == pix [19] && pix [19] == pix [16] && pix [0] != pix [1]) {
            this.flop [0] = new Card ('T', couleur);
        }
        else if (pix [22] == - 1) {
            if (pix [25] == - 1) {
                this.flop [0] = new Card ('9', couleur);
            }
            else {
                this.flop [0] = new Card ('5', couleur);
            }
        }
        else if (pix [7] == - 1) {
            if (pix [5] != - 1) {
                this.flop [0] = new Card ('8', couleur);
            }
            else {
                this.flop [0] = new Card ('A', couleur);
            }
        }
        else {
            this.flop [0] = new Card ('6', couleur);
        }
    }
    else if (pix [1] == pix [2] && pix [4] == pix [5] && pix [7] == pix [8] && pix [7] != pix [10]) {
        this.flop [0] = new Card ('7', couleur);
    }
    else if (pix [2] == - 1 && pix [15] != pix [16] && pix [4] == - 1 && pix [4] == pix [5]) {
        this.flop [0] = new Card ('4', couleur);
    }
    else {
        if (pix [15] == - 1 && pix [18] == - 1 && pix [14] == - 1) {
            if (pix [7] != - 1) {
                this.flop [0] = new Card ('2', couleur);
            }
            else {
                this.flop [0] = new Card ('3', couleur);
            }
        }
        else if (pix [2] == pix [4] && pix [7] != - 1) {
            this.flop [0] = new Card ('Q', couleur);
        }
    }
    image1 = this.bot.createScreenCapture (new Rectangle (i + 197, j + 97, 3, 18));
    pg = new PixelGrabber (image1, 0, 0, 3, 18, pix, 0, 3);
    try {
        pg.grabPixels ();
    } catch (InterruptedException d) {
        System.err.println ("en attente des pixels");
    }
    if ((pix [53]>> 8 & 0xFF) == (pix [53]>> 16 & 0xFF) && (pix [53]>> 8 & 0xFF) == (pix [53]>> 0 & 0xFF)) {
        couleur = 's';
    }
    else if ((pix [53]>> 16 & 0xFF) > (pix [53]>> 8 & 0xFF) && (pix [53]>> 16 & 0xFF) > (pix [53]>> 0 & 0xFF)) {
        couleur = 'h';
    }
    else if ((pix [53]>> 0 & 0xFF) > (pix [53]>> 16 & 0xFF) && (pix [53]>> 0 & 0xFF) > (pix [53]>> 8 & 0xFF)) {
        couleur = 'd';
    }
    else {
        couleur = 'c';
    }
    if (pix [7] == - 1 && pix [18] == pix [19] && pix [5] == pix [8] && pix [11] == pix [14]) {
        if (pix [20] != - 1) {
            this.flop [1] = new Card ('K', couleur);
        }
        else {
            this.flop [1] = new Card ('J', couleur);
        }
    }
    else if (pix [15] == pix [18] && pix [3] == - 1 && pix [20] != - 1 & pix [35] != - 1) {
        if (pix [20] == pix [19] && pix [19] == pix [16] && pix [0] != pix [1]) {
            this.flop [1] = new Card ('T', couleur);
        }
        else if (pix [22] == - 1) {
            if (pix [25] == - 1) {
                this.flop [1] = new Card ('9', couleur);
            }
            else {
                this.flop [1] = new Card ('5', couleur);
            }
        }
        else if (pix [7] == - 1) {
            if (pix [5] != - 1) {
                this.flop [1] = new Card ('8', couleur);
            }
            else {
                this.flop [1] = new Card ('A', couleur);
            }
        }
        else {
            this.flop [1] = new Card ('6', couleur);
        }
    }
    else if (pix [1] == pix [2] && pix [4] == pix [5] && pix [7] == pix [8] && pix [7] != pix [10]) {
        this.flop [1] = new Card ('7', couleur);
    }
    else if (pix [2] == - 1 && pix [15] != pix [16] && pix [4] == - 1 && pix [4] == pix [5]) {
        this.flop [1] = new Card ('4', couleur);
    }
    else {
        if (pix [15] == - 1 && pix [18] == - 1 && pix [14] == - 1) {
            if (pix [7] != - 1) {
                this.flop [1] = new Card ('2', couleur);
            }
            else {
                this.flop [1] = new Card ('3', couleur);
            }
        }
        else if (pix [2] == pix [4] && pix [7] != - 1) {
            this.flop [1] = new Card ('Q', couleur);
        }
    }
    image1 = this.bot.createScreenCapture (new Rectangle (i + 229, j + 97, 3, 18));
    pg = new PixelGrabber (image1, 0, 0, 3, 18, pix, 0, 3);
    try {
        pg.grabPixels ();
    } catch (InterruptedException d) {
        System.err.println ("en attente des pixels");
    }
    if ((pix [53]>> 8 & 0xFF) == (pix [53]>> 16 & 0xFF) && (pix [53]>> 8 & 0xFF) == (pix [53]>> 0 & 0xFF)) {
        couleur = 's';
    }
    else if ((pix [53]>> 16 & 0xFF) > (pix [53]>> 8 & 0xFF) && (pix [53]>> 16 & 0xFF) > (pix [53]>> 0 & 0xFF)) {
        couleur = 'h';
    }
    else if ((pix [53]>> 0 & 0xFF) > (pix [53]>> 16 & 0xFF) && (pix [53]>> 0 & 0xFF) > (pix [53]>> 8 & 0xFF)) {
        couleur = 'd';
    }
    else {
        couleur = 'c';
    }
    if (pix [7] == - 1 && pix [18] == pix [19] && pix [5] == pix [8] && pix [11] == pix [14]) {
        if (pix [20] != - 1) {
            this.flop [2] = new Card ('K', couleur);
        }
        else {
            this.flop [2] = new Card ('J', couleur);
        }
    }
    else if (pix [15] == pix [18] && pix [3] == - 1 && pix [20] != - 1 & pix [35] != - 1) {
        if (pix [20] == pix [19] && pix [19] == pix [16] && pix [0] != pix [1]) {
            this.flop [2] = new Card ('T', couleur);
        }
        else if (pix [22] == - 1) {
            if (pix [25] == - 1) {
                this.flop [2] = new Card ('9', couleur);
            }
            else {
                this.flop [2] = new Card ('5', couleur);
            }
        }
        else if (pix [7] == - 1) {
            if (pix [5] != - 1) {
                this.flop [2] = new Card ('8', couleur);
            }
            else {
                this.flop [2] = new Card ('A', couleur);
            }
        }
        else {
            this.flop [2] = new Card ('6', couleur);
        }
    }
    else if (pix [1] == pix [2] && pix [4] == pix [5] && pix [7] == pix [8] && pix [7] != pix [10]) {
        this.flop [2] = new Card ('7', couleur);
    }
    else if (pix [2] == - 1 && pix [15] != pix [16] && pix [4] == - 1 && pix [4] == pix [5]) {
        this.flop [2] = new Card ('4', couleur);
    }
    else {
        if (pix [15] == - 1 && pix [18] == - 1 && pix [14] == - 1) {
            if (pix [7] != - 1) {
                this.flop [2] = new Card ('2', couleur);
            }
            else {
                this.flop [2] = new Card ('3', couleur);
            }
        }
        else if (pix [2] == pix [4] && pix [7] != - 1) {
            this.flop [2] = new Card ('Q', couleur);
        }
    }
}


-----Function Pair=297=-----==

public void sendSlave (String msg) {
    int i;
    int l;
    String s;
    try {
        for (i = 0; i < 256; i ++) bufPGUI [i] = ' ';
        l = msg.length ();
        if (l > 255) l = 255;
        System.arraycopy (msg.getBytes (), 0, bufPGUI, 0, l);
        dpcktPGUI.setData (bufPGUI);
        dsPGUI.send (dpcktPGUI);
        s = new String ("Sent Slave " + msg);
        logPrint (s);
    } catch (Exception e) {
        s = new String ("Failed to send Message " + msg + " Exception " + e);
        System.out.println (s);
        logPrint (s);
    }
    return;
}


public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


-----Function Pair=298=-----==

public static void main (String [] args) {
    final JFrame frame = new JFrame ("Dissolve Hack");
    JButton quit = new JButton ("Quit");
    quit.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            new Dissolver ().dissolveExit (frame);
        }
    }
    );
    frame.getContentPane ().add (quit);
    frame.pack ();
    frame.setLocation (300, 300);
    frame.setSize (400, 400);
    frame.setVisible (true);
}


public static void main (final String [] args) throws Throwable {
    try {
        initializeSettings (args);
    } catch (final Throwable t) {
        printParameterError (args, t);
        throw t;
    }
    try {
        System.out.print ("Connecting to " + HOST + ":" + PORT + " ... ");
        singleton = connect (HOST, PORT, NetScreen3.class.getSimpleName ());
        System.out.println ("successful.");
    } catch (final Exception e) {
        System.out.println ("Host not reachable");
    }
    initializeGUI ();
    if (singleton != null) {
        client ();
    }
    else {
        server ();
    }
}


-----Function Pair=299=-----==

public static ViterbiElement [] getLogViterbi (ViterbiElement [] logV, double [] [] logA) {
    YeriDebug.ASSERT (logV.length != 0, "Null Vector");
    YeriDebug.ASSERT (logA.length != 0, "Null Matrix");
    YeriDebug.ASSERT (CollectionsToolkit.isRectangular (logA), "Matrix is not rectangular!");
    YeriDebug.ASSERT_compareInteger (logV.length, logA.length);
    ViterbiElement [] logResult = new ViterbiElement [logV.length];
    for (int j = 0; j < logA [0].length; j ++) {
        double [] pathScoreArray = new double [logV.length];
        for (int i = 0; i < logV.length; i ++) {
            pathScoreArray [i] = StatisticsToolkit.logMultiply (logV [i].getScore (), logA [i] [j]);
        }
        ViterbiElement viterbiElement = StatisticsToolkit.getViterbiMax (pathScoreArray);
        logResult [j] = viterbiElement;
    }
    return logResult;
}


public void paint (Graphics g) {
    g.setColor (fg1);
    Rectangle r = getBounds ();
    g.draw3DRect (0, 0, r.width, r.height, true);
    Enumeration xe = paps.xstrokes.elements ();
    Enumeration ye = paps.ystrokes.elements ();
    while (xe.hasMoreElements ()) {
        Vector xvec, yvec;
        xvec = (Vector) xe.nextElement ();
        yvec = (Vector) ye.nextElement ();
        Enumeration xe2 = xvec.elements ();
        Enumeration ye2 = yvec.elements ();
        if (xvec != paps.curxvec) g.setColor (fg2);
        else g.setColor (fg1);
        drawVec (g, xe2, ye2);
    }
}


-----Function Pair=300=-----==

public Collection listGroupInstructions (int id) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Rank, GroupInstruction from InstructionGroups " + "where InstructionId = " + id + " order by Rank";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                CollectionInstruction instr = new CollectionInstruction (rs.getInt (1), rs.getInt (2));
                list.add (instr);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public void addGames (List < Game > games) throws StadiumException, SQLException {
    Connection conn = ConnectionManager.getManager ().getConnection ();
    conn.setAutoCommit (false);
    PreparedStatement stm = null;
    ResultSet rs = null;
    try {
        for (Game game : games) {
            stm = conn.prepareStatement (Statements.SELECT_STADIUM);
            stm.setString (1, game.getStadiumName ());
            stm.setString (2, game.getStadiumCity ());
            rs = stm.executeQuery ();
            int stadiumId = - 1;
            while (rs.next ()) {
                stadiumId = rs.getInt ("stadiumID");
            }
            if (stadiumId == - 1) throw new StadiumException ("No such stadium");
            stm = conn.prepareStatement (Statements.INSERT_GAME);
            stm.setInt (1, stadiumId);
            stm.setDate (2, game.getGameDate ());
            stm.setTime (3, game.getGameTime ());
            stm.setString (4, game.getTeamA ());
            stm.setString (5, game.getTeamB ());
            stm.executeUpdate ();
            int gameId = getMaxId ();
            List < SectorPrice > sectorPrices = game.getSectorPrices ();
            for (SectorPrice price : sectorPrices) {
                stm = conn.prepareStatement (Statements.INSERT_TICKET_PRICE);
                stm.setInt (1, gameId);
                stm.setInt (2, price.getSectorId ());
                stm.setInt (3, price.getPrice ());
                stm.executeUpdate ();
            }
        }
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } finally {
        rs.close ();
        stm.close ();
    }
    conn.commit ();
    conn.setAutoCommit (true);
}


-----Function Pair=301=-----==

public void testTimestamps0004 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0004 " + "  (mytime  datetime not null, " + "   mytime2 datetime null,     " + "   mytime3 datetime null     )");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0004 values ('1964-02-14 10:00:00.0', ?, ?)");
    Timestamp t0 = Timestamp.valueOf ("1964-02-14 10:00:00.0");
    pstmt.setTimestamp (1, t0);
    pstmt.setTimestamp (2, t0);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.setNull (2, java.sql.Types.TIMESTAMP);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.close ();
    pstmt = con.prepareStatement ("select mytime, mytime2, mytime3 from #t0004");
    ResultSet rs = pstmt.executeQuery ();
    assertNotNull (rs);
    Timestamp t1, t2, t3;
    assertTrue ("Expected a result set", rs.next ());
    t1 = rs.getTimestamp (1);
    t2 = rs.getTimestamp (2);
    t3 = rs.getTimestamp (3);
    assertEquals (t0, t1);
    assertEquals (t0, t2);
    assertEquals (t0, t3);
    assertTrue ("Expected a result set", rs.next ());
    t1 = rs.getTimestamp (1);
    t2 = rs.getTimestamp (2);
    t3 = rs.getTimestamp (3);
    assertEquals (t0, t1);
    assertEquals (t0, t2);
    assertEquals (null, t3);
    pstmt.close ();
}


public Question loadQuestion (TopicArea topicArea, String id) throws SQLException {
    String query = "select * from fs.question where topic = ? and qid = ?";
    ensureConnection ();
    PreparedStatement statement = m_connection.prepareStatement (query);
    ResultSet result = null;
    try {
        statement.setLong (1, topicArea.getDatabaseID ());
        statement.setString (2, id);
        result = statement.executeQuery ();
        if (! result.next ()) return null;
        Question question = topicArea.getConfig ().createQuestion (id, topicArea, result.getString ("title"), result.getString ("asker"));
        question.setDatabaseID (result.getLong ("id"));
        question.setPoints (result.getLong ("points"));
        return question;
    } finally {
        if (null != result) {
            try {
                result.close ();
            } catch (SQLException _) {
            }
        }
        try {
            statement.close ();
        } catch (SQLException _) {
        }
    }
}


-----Function Pair=302=-----==

public void testStatements0020 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0020a ( " + "  i1   int not null,     " + "  s1   char(10) not null " + ")                        " + "");
    stmt.executeUpdate ("create table #t0020b ( " + "  i2a   int not null,     " + "  i2b   int not null,     " + "  s2   char(10) not null " + ")                        " + "");
    stmt.executeUpdate ("create table #t0020c ( " + "  i3   int not null,     " + "  s3   char(10) not null " + ")                        " + "");
    int nextB = 1;
    int nextC = 1;
    for (int i = 1; i < 50; i ++) {
        stmt.executeUpdate ("insert into #t0020a " + "  values(" + i + ", " + "         'row" + i + "') " + "");
        for (int j = nextB; (nextB % 5) != 0; j ++, nextB ++) {
            stmt.executeUpdate ("insert into #t0020b " + " values(" + i + ", " + "        " + j + ", " + "        'row" + i + "." + j + "' " + "        )" + "");
            for (int k = nextC; (nextC % 3) != 0; k ++, nextC ++) {
                stmt.executeUpdate ("insert into #t0020c " + " values(" + j + ", " + "        'row" + i + "." + j + "." + k + "' " + "        )" + "");
            }
        }
    }
    Statement stmtA = con.createStatement ();
    PreparedStatement stmtB = con.prepareStatement ("select i2b, s2 from #t0020b where i2a=?");
    PreparedStatement stmtC = con.prepareStatement ("select s3 from #t0020c where i3=?");
    ResultSet rs1 = stmtA.executeQuery ("select i1 from #t0020a");
    assertNotNull (rs1);
    while (rs1.next ()) {
        stmtB.setInt (1, rs1.getInt ("i1"));
        ResultSet rs2 = stmtB.executeQuery ();
        assertNotNull (rs2);
        while (rs2.next ()) {
            stmtC.setInt (1, rs2.getInt (1));
            ResultSet rs3 = stmtC.executeQuery ();
            assertNotNull (rs3);
            rs3.next ();
        }
    }
    stmt.close ();
    stmtA.close ();
    stmtB.close ();
    stmtC.close ();
}


public boolean classDelete_Child (Row row) {
    boolean flag = true;
    dao.setAutoCommit (false);
    String childTableName = getChildTableName ();
    if (childTableName != null) {
        StringBuffer sb = new StringBuffer ("DELETE FROM ");
        sb.append (childTableName + " WHERE ");
        Vector whereColumns = new Vector ();
        Iterator pkColumnIter = pkColumns.iterator ();
        while (pkColumnIter.hasNext ()) {
            Column pkColumn = (Column) pkColumnIter.next ();
            if (pkColumn.getTableName ().equals (childTableName)) {
                whereColumns.add (pkColumn);
                sb.append (pkColumn.getColumnName () + "=? AND ");
            }
        }
        sb.delete (sb.lastIndexOf ("AND"), sb.lastIndexOf ("AND") + 3);
        String sql = sb.toString ();
        DAO dao = DAO.getInstance ();
        dao.update (sql);
        for (int i = 0; i < whereColumns.size (); i ++) {
            Column column = (Column) whereColumns.get (i);
            Cell cell = ObjectUtil.findNewCell (row, column.getTableName (), column.getColumnName ());
            dao.setObject (i + 1, cell.getColumnValue ());
        }
        dao.executeUpdate ();
        dao.commit ();
        dao.setAutoCommit (true);
    }
    return true;
}


-----Function Pair=303=-----==

protected final void dropIndex (String name, String tableName, boolean ifExists) throws RecordException {
    String sql = "drop index " + name + " on " + TableNameResolver.getTableName (tableName, isItalian ());
    if (ifExists) {
        throw new RecordException ("Mysql does not support drop index _if exists_");
    }
    LoggableStatement st = null;
    Connection conn = null;
    if (autoCommit) {
        conn = ConnectionManager.getConnection ();
    }
    else {
        conn = this.conn;
    }
    try {
        st = new LoggableStatement (conn, sql);
        log.log (st.getQueryString ());
        st.execute ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback ", e1);
        }
        throw new RecordException ("Error dropping index " + name + ". A rollback was done.", e);
    } finally {
        try {
            if (st != null) {
                st.close ();
            }
            if (autoCommit) {
                conn.close ();
            }
        } catch (SQLException e) {
            throw new RecordException ("Error closing the connection", e);
        }
    }
}


protected long getLastRowIdInResultTable (long startId, int rows) throws SQLException {
    if (queryContext.getRunCount () % 50 != 0) {
        return startId < 0 ? rows : (startId + rows);
    }
    long lastRowId = Constants.DEFAULT_MONOTONIC_ID_VALUE;
    if (lastRowIdStmt == null) {
        lastRowIdStmt = connection.createStatement ();
    }
    ResultSet resultSet = null;
    try {
        resultSet = lastRowIdStmt.executeQuery (lastRowIdInResultTableSQL);
        while (resultSet.next ()) {
            lastRowId = resultSet.getLong (Constants.ID_COLUMN_POS + 1);
        }
    } finally {
        Helper.closeResultSet (resultSet);
    }
    return lastRowId;
}


-----Function Pair=304=-----==

protected final void renameTable (String tableName, String newName) throws RecordException {
    Connection conn = null;
    if (autoCommit) {
        conn = ConnectionManager.getConnection ();
    }
    else {
        conn = this.conn;
    }
    String sql = "rename table " + TableNameResolver.getTableName (tableName, isItalian ()) + " to " + newName;
    LoggableStatement st = null;
    try {
        st = new LoggableStatement (conn, sql);
        log.log (st.getQueryString ());
        st.execute ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback ", e1);
        }
        throw new RecordException ("Error renaming table " + TableNameResolver.getTableName (tableName, isItalian ()) + ". A rollback was done.", e);
    } finally {
        try {
            if (st != null) {
                st.close ();
            }
            if (autoCommit) {
                conn.close ();
            }
        } catch (SQLException e) {
            throw new RecordException ("Error closing the connection", e);
        }
    }
}


private String getNewId () {
    idFlag.getBusyFlag ();
    if (id == null) {
        id = new char [NetTransferObject.MAX_LEN];
        for (int i = 0; i < NetTransferObject.MAX_LEN; i ++) id [i] = (char) 1;
    }
    String newId = new String (id);
    id [NetTransferObject.MAX_LEN - 1] ++;
    for (int i = (NetTransferObject.MAX_LEN - 1); i >= 0; i --) {
        if (id [i] == Character.MAX_VALUE) {
            id [i] = 1;
            if (i != 1) id [i - 1] ++;
            for (int j = i; j < NetTransferObject.MAX_LEN; j ++) id [j] = 1;
        }
        else break;
    }
    idFlag.freeBusyFlag ();
    return newId;
}


-----Function Pair=305=-----==

public void testBlob0021 () throws Exception {
    byte smallarray [] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};
    byte array1 [] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
    String bigtext1 = "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "abcdefghijklmnop" + "";
    Statement stmt = con.createStatement ();
    dropTable ("#t0021");
    stmt.executeUpdate ("create table #t0021 ( " + " mybinary         binary(16) not null, " + " myimage          image not null, " + " mynullimage      image null, " + " mytext           text not null, " + " mynulltext       text null) ");
    PreparedStatement insert = con.prepareStatement ("insert into #t0021(     " + " mybinary,             " + " myimage,              " + " mynullimage,          " + " mytext,               " + " mynulltext            " + ")                      " + "values(?, ?, ?, ?, ?)  ");
    insert.setBytes (1, smallarray);
    insert.setBytes (2, array1);
    insert.setBytes (3, array1);
    insert.setString (4, bigtext1);
    insert.setString (5, bigtext1);
    int count = insert.executeUpdate ();
    assertEquals (count, 1);
    insert.close ();
    ResultSet rs = stmt.executeQuery ("select * from #t0021");
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    byte [] a1 = rs.getBytes ("myimage");
    byte [] a2 = rs.getBytes ("mynullimage");
    String s1 = rs.getString ("mytext");
    String s2 = rs.getString ("mynulltext");
    assertEquals (0, compareBytes (a1, array1));
    assertEquals (0, compareBytes (a2, array1));
    assertEquals (bigtext1, s1);
    assertEquals (bigtext1, s2);
    stmt.close ();
}


private static void updateandquerywithcriteria (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    entityManager.getTransaction ().begin ();
    Session session = JpaHelper.getEntityManager (entityManager).getActiveSession ();
    try {
        ReadAllQuery query = new ReadAllQuery ();
        query.setReferenceClass (Person.class);
        Collection < Person > collection = (Collection < Person >) session.executeQuery (query);
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-2");
        }
        ReadAllQuery inMemoryQuery = new ReadAllQuery ();
        inMemoryQuery.setReferenceClass (Person.class);
        ExpressionBuilder personE = inMemoryQuery.getExpressionBuilder ();
        Expression expression = personE.get ("firstName").like ("%-2");
        inMemoryQuery.setSelectionCriteria (expression);
        inMemoryQuery.conformResultsInUnitOfWork ();
        Collection < Person > imqCollection = (Collection < Person >) session.executeQuery (inMemoryQuery);
        for (Person person : imqCollection) {
            System.out.println ("found: " + person);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=306=-----==

public RestServiceResult update (RestServiceResult serviceResult, List listWordsComleteE2, Long nCompleteId) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_COMPLETE2_WORD);
        query.setParameter (1, new Long (nCompleteId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        if (listWordsComleteE2 != null) {
            for (int i = 0; i < listWordsComleteE2.size (); i ++) {
                CoWordsCompleteE2 coWordsCompleteE2 = (CoWordsCompleteE2) listWordsComleteE2.get (i);
                serviceResult = this.create (serviceResult, coWordsCompleteE2);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar las palabras: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public int hashCode (String name, String row) throws FidoDatabaseException, ProperNounNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select ObjectId from ProperNouns " + "where Noun = '" + name + "' and SenseNumber = " + row;
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new ProperNounNotFoundException (name);
            Vector list = new Vector ();
            list.add (name);
            list.add (row);
            list.add (rs.getString (1));
            return list.hashCode ();
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=307=-----==

public ArrayList getEvaluationsByProposal (String proposalId) throws Exception {
    Evaluation a;
    ArrayList as = new ArrayList ();
    String sql = "select event.*,usr.first_name from event,usr where (event.ACTION_ID='evaluated' OR event.ACTION_ID='decided') AND event.PROPOSAL_ID='" + proposalId + "'";
    sql += " AND usr.USR_ID=event.USR_ID";
    PreparedStatement prepStmt = null;
    try {
        con = database.getConnection ();
        prepStmt = con.prepareStatement (sql);
        ResultSet es = prepStmt.executeQuery ();
        while (es.next ()) {
            a = new Evaluation (es.getString ("EVENT_ID"), es.getString ("eventDate"), proposalId, es.getString ("USR_ID"), es.getString ("first_name"), es.getString ("reviewText"), es.getString ("summary"));
            as.add (a);
        }
        prepStmt.close ();
        con.close ();
        return as;
    } catch (Exception e) {
        if (! con.isClosed ()) {
            prepStmt.close ();
            con.close ();
        }
        throw e;
    }
}


public void testPreparedStatement0040 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0040 (" + " c255 char(255)     not null, " + " v255 varchar(255)  not null) ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0040 values (?, ?)");
    String along = getLongString ('a');
    String blong = getLongString ('b');
    pstmt.setString (1, along);
    pstmt.setString (2, along);
    int count = pstmt.executeUpdate ();
    assertEquals (count, 1);
    pstmt.close ();
    count = stmt.executeUpdate ("" + "insert into #t0040 values ( " + "'" + blong + "', " + "'" + blong + "')");
    assertEquals (count, 1);
    pstmt = con.prepareStatement ("select c255, v255 from #t0040 order by c255");
    ResultSet rs = pstmt.executeQuery ();
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), along);
    assertEquals (rs.getString ("v255"), along);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), blong);
    assertEquals (rs.getString ("v255"), blong);
    assertTrue ("Expected no result set", ! rs.next ());
    pstmt.close ();
    rs = stmt.executeQuery ("select c255, v255 from #t0040 order by c255");
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), along);
    assertEquals (rs.getString ("v255"), along);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), blong);
    assertEquals (rs.getString ("v255"), blong);
    assertTrue ("Expected no result set", ! rs.next ());
    stmt.close ();
}


-----Function Pair=308=-----==

public int getCount (String className, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "select count(*) from " + className + getWhereStatement (filters);
        Query queryObject = getSession ().createQuery (queryString);
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public RestServiceResult listDailyForUserCourse (RestServiceResult serviceResult, Long nUserId, Long nCourseId) {
    Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_TO_DAILY_USER_COURSE, ToDaily.class);
    query.setParameter (1, nUserId);
    query.setParameter (2, nCourseId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    List < ToDaily > list = query.getResultList ();
    if (list.size () == 0) {
        serviceResult.setMessage (bundle.getString ("daily.list.notFound"));
        serviceResult.setObjResult (0);
    }
    else {
        Object [] array = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("daily.list.success"), array));
        serviceResult.setObjResult (list.size ());
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


-----Function Pair=309=-----==

public TimmonId doMove (TimmonId source_id, TimmonId new_parent_id) throws SecurityException, RemoteException, IllegalArgumentException, TimmonBackEndException {
    SQLTimmonId sql_source_id = (SQLTimmonId) source_id;
    if (isTypeOf (TYPE_TASK_MASK, sql_source_id.getTimmonIdType ())) {
        long new_parent_id_value = ((SQLTimmonId) new_parent_id).getTimmonId ();
        try {
            sql_change_task_parent_stmt_.setInt (1, (int) new_parent_id_value);
            sql_change_task_parent_stmt_.setInt (2, (int) sql_source_id.getTimmonId ());
            sql_change_task_parent_stmt_.executeUpdate ();
            return (sql_source_id);
        } catch (SQLException e) {
            throw (new TimmonBackEndException (e));
        }
    }
    else if (isTypeOf (TYPE_ACTIVITY_MASK, sql_source_id.getTimmonIdType ())) {
        long new_parent_id_value = ((SQLTimmonId) new_parent_id).getTimmonId ();
        try {
            sql_change_activity_parent_stmt_.setInt (1, (int) new_parent_id_value);
            sql_change_activity_parent_stmt_.setInt (2, (int) sql_source_id.getTimmonId ());
            sql_change_activity_parent_stmt_.executeUpdate ();
            return (sql_source_id);
        } catch (SQLException e) {
            throw (new TimmonBackEndException (e));
        }
    }
    throw (new TimmonBackEndException ("unknown or usupported type for move: " + sql_source_id.getTimmonIdType ()));
}


public void updateAnchor (Anchor anchor) {
    Session session = this.hibernateManager.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Anchor currentAnchor = (Anchor) session.createQuery ("from Anchor anchor where anchor.target=? AND anchor.app=?").setString (0, anchor.getTarget ()).setString (1, anchor.getApp ()).uniqueResult ();
        if (currentAnchor != null) {
            currentAnchor.setLastSync (anchor.getLastSync ());
            currentAnchor.setNextSync (anchor.getNextSync ());
            session.update (currentAnchor);
        }
        else {
            session.save (anchor);
        }
        tx.commit ();
    } catch (Exception e) {
        logger.error (this, e);
        if (tx != null) {
            tx.rollback ();
        }
        throw new SyncException (e);
    }
}


-----Function Pair=310=-----==

private void upgradeSchema () {
    Statement stmt = null;
    boolean updatedSchema = false;
    try {
        int i = getSchema ();
        if (i < SCHEMA_VERSION) {
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            updatedSchema = true;
        }
        while (i < SCHEMA_VERSION) {
            String qry;
            switch (i) {
                case 0 :
                    qry = "CREATE TABLE settings (var VARCHAR(32) NOT NULL, val LONG VARCHAR)";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO settings (var, val) VALUES ('schema', '1')";
                    stmt.executeUpdate (qry);
                    qry = "ALTER TABLE recordings ADD COLUMN exe LONG VARCHAR NOT NULL DEFAULT '%UNKNOWN%'";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE files (id INT NOT NULL, file LONG VARCHAR NOT NULL, finished INT NOT NULL)";
                    stmt.executeUpdate (qry);
                    updateFilesTable ();
                    break;
                case 1 :
                    qry = "ALTER TABLE files ADD COLUMN type VARCHAR(32) NOT NULL DEFAULT '%UNKNOWN%'";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '2' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 2 :
                    qry = "CREATE UNIQUE INDEX IF NOT EXISTS recordings_history ON recordings(id,type)";
                    stmt.executeUpdate (qry);
                    qry = "CREATE INDEX IF NOT EXISTS files_history ON files(id,type)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '3' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 3 :
                    qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, context VARCHAR(16) NOT NULL, level VARCHAR(16) NOT NULL, time LONG INT NOT NULL, msg LONG VARCHAR NOT NULL, parent INT)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '4' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 4 :
                    qry = "CREATE UNIQUE INDEX IF NOT EXISTS log_id ON log(id)";
                    stmt.executeUpdate (qry);
                    qry = "CREATE INDEX IF NOT EXISTS log_parent ON log(parent)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '5' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 5 :
                    qry = "CREATE TABLE tmp_settings (var varchar(32) NOT NULL PRIMARY KEY, val varchar(128) NOT NULL)";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO tmp_settings SELECT var,val FROM settings";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE settings";
                    stmt.executeUpdate (qry);
                    qry = "ALTER TABLE tmp_settings RENAME TO settings";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '6' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 6 :
                    qry = "DROP TABLE log";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, mediaid varchar(32) NOT NULL, taskid varchar(32) NOT NULL, msg LONG VARCHAR NOT NULL)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '7' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 7 :
                    qry = "CREATE TABLE client (host varchar(255) PRIMARY KEY, conf LONG VARCHAR)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '8' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 8 :
                    qry = "DROP INDEX files_history";
                    stmt.executeUpdate (qry);
                    qry = "DROP INDEX recordings_history";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE files";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE new_rec (id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, PRIMARY KEY(id, type))";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO new_rec SELECT id, type, 0, 0, 1 FROM recordings";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE recordings";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE recordings (id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, PRIMARY KEY(id, type))";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO recordings SELECT * FROM new_rec";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE new_rec";
                    stmt.executeUpdate (qry);
                    qry = "CREATE UNIQUE INDEX recordings_history on recordings(id,type)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '9' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 9 :
                    qry = "ALTER TABLE recordings ADD COLUMN host VARCHAR(255) NOT NULL DEFAULT ''";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '10' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 10 :
                    qry = "ALTER TABLE recordings ADD COLUMN airing VARCHAR(64) NOT NULL DEFAULT '0'";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '11' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 11 :
                    PreparedStatement pstmt = null;
                    try {
                        MessageDigest msg = MessageDigest.getInstance ("MD5");
                        msg.update ("sjqadmin".getBytes ());
                        String pwd = new String (msg.digest ());
                        pstmt = conn.prepareStatement ("REPLACE INTO settings (var, val) VALUES ('password', ?)");
                        pstmt.setString (1, pwd);
                        pstmt.executeUpdate ();
                    } catch (NoSuchAlgorithmException e) {
                        throw new SQLException (e);
                    } finally {
                        if (pstmt != null) pstmt.close ();
                    }
                    stmt.executeUpdate ("UPDATE settings SET val = '12' WHERE var = 'schema'");
                    break;
                case 12 :
                    qry = "CREATE INDEX logs_for_tasks ON log(mediaid, taskid)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '13' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 13 :
                    qry = "DELETE FROM log";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '14' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 14 :
                    qry = "DROP TABLE log";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE log (id INTEGER PRIMARY KEY, mediaid varchar(32) NOT NULL, taskid varchar(32) NOT NULL, msg LONG VARCHAR NOT NULL, ts INTEGER NOT NULL DEFAULT 0)";
                    stmt.executeUpdate (qry);
                    qry = "CREATE INDEX logs_by_date ON log(ts)";
                    stmt.executeUpdate (qry);
                    qry = "CREATE INDEX IF NOT EXISTS logs_for_tasks ON log(mediaid, taskid)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '15' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 15 :
                    qry = "DELETE FROM log WHERE mediaid = 0 AND taskid = '0'";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '16' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 16 :
                    qry = "CREATE TEMPORARY TABLE rec_tmp (objtype varchar(64) NOT NULL DEFAULT 'media', id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, host VARCHAR(255) NOT NULL DEFAULT '', airing VARCHAR(64) NOT NULL DEFAULT '0', PRIMARY KEY (objtype, id, type))";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO rec_tmp SELECT 'media', id, type, start, finish, state, host, airing FROM recordings";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE recordings";
                    stmt.executeUpdate (qry);
                    qry = "CREATE TABLE recordings (objtype varchar(64) NOT NULL DEFAULT 'media', id INT NOT NULL, type VARCHAR(32) NOT NULL, start INT NOT NULL DEFAULT 0, finish INT NOT NULL DEFAULT 0, state INT NOT NULL DEFAULT 1, host VARCHAR(255) NOT NULL DEFAULT '', airing VARCHAR(64) NOT NULL DEFAULT '0', PRIMARY KEY (objtype, id, type))";
                    stmt.executeUpdate (qry);
                    qry = "INSERT INTO recordings SELECT * FROM rec_tmp";
                    stmt.executeUpdate (qry);
                    qry = "DROP TABLE rec_tmp";
                    stmt.executeUpdate (qry);
                    qry = "ALTER TABLE log ADD COLUMN objtype varchar(64) NOT NULL DEFAULT 'media'";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '17' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
                case 17 :
                    qry = "DROP INDEX logs_for_tasks";
                    stmt.executeUpdate (qry);
                    qry = "CREATE INDEX logs_for_tasks ON log(mediaid, taskid, objtype)";
                    stmt.executeUpdate (qry);
                    qry = "UPDATE settings SET val = '18' WHERE var = 'schema'";
                    stmt.executeUpdate (qry);
                    break;
            }
            i ++;
        }
        if (updatedSchema) conn.commit ();
    } catch (SQLException e) {
        try {
            if (updatedSchema) conn.rollback ();
        } catch (SQLException x) {
            LOG.fatal ("SQL error", x);
        }
        LOG.fatal ("SQL error", e);
        throw new RuntimeException (e);
    } finally {
        try {
            if (stmt != null) stmt.close ();
            if (updatedSchema) conn.setAutoCommit (true);
        } catch (SQLException e) {
            LOG.fatal ("SQL error", e);
            throw new RuntimeException (e);
        }
    }
}


private void prepareList (Vector examList, Vector gradeList) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        {
            r.add ("adm_exam_id");
            r.add ("adm_exam_name");
            sql = r.getSQLSelect ("adm_exam");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("adm_exam_id"));
                h.put ("name", rs.getString ("adm_exam_name"));
                examList.addElement (h);
            }
        }
        {
            r.clear ();
            r.add ("adm_grade_display_id");
            r.add ("adm_grade_display_name");
            sql = r.getSQLSelect ("adm_display_grade_main");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("adm_grade_display_id"));
                h.put ("name", rs.getString ("adm_grade_display_name"));
                gradeList.addElement (h);
            }
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=311=-----==

public DTSTransferObject [] previewDifferences (String user, String subsetExpr, int subsetId, PreviewOptions options) throws SQLException, DTSValidationException, PermissionException {
    long newSubsetId = getSubsetIdFromSeq ();
    int previewId = (int) newSubsetId * - 1;
    long time = System.currentTimeMillis ();
    Subset item = new Subset ();
    item.setId (previewId);
    item.setExpression (subsetExpr);
    item.setName ("Preview" + previewId);
    item.setDataCreatedTime (time);
    item.setModifiedTime (time);
    DTSTransferObject [] cons = new DTSTransferObject [0];
    this.addSubset (user, item, previewId, true);
    this.getPreviewResults (item, true);
    String connType = SQL.getConnType (this.conn);
    if (connType.equals (SQL.ORACLE)) {
        cons = this.previewSubsetDiffORA (previewId, subsetId, options);
    }
    else if (connType.equals (SQL.SQL2K) || connType.equals (SQL.CACHE)) {
        cons = this.previewSubsetDiffSQL2K (previewId, subsetId, options);
    }
    Categories.dataDb ().debug ("Got [" + cons.length + "] differences [" + previewId + "]");
    this.deleteSubset (previewId, null);
    return cons;
}


public int update (String strUpdate, Object...objs) throws RuntimeException {
    int rtnVal = 0;
    EntityManager em = getEntityManager ();
    if (em != null) {
        EntityTransaction et = em.getTransaction ();
        try {
            Query query = em.createQuery (strUpdate);
            if (objs != null) {
                int index = 1;
                for (Object obj : objs) {
                    query.setParameter (index ++, obj);
                }
            }
            if (query != null) {
                if (et.isActive () == false) {
                    et.begin ();
                }
                rtnVal = query.executeUpdate ();
                if (et.isActive ()) {
                    et.commit ();
                }
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            em.close ();
            throw new RuntimeException (exception);
        }
        em.close ();
    }
    return rtnVal;
}


-----Function Pair=312=-----==

public void testUnionColumnTypes () {
    try {
        Connection conn = newConnection ();
        Statement stmt = conn.createStatement ();
        stmt.execute ("DROP TABLE test1 IF EXISTS");
        stmt.execute ("DROP TABLE test2 IF EXISTS");
        stmt.execute ("CREATE TABLE test1 (id int, b1 boolean)");
        stmt.execute ("CREATE TABLE test2 (id int)");
        stmt.execute ("INSERT INTO test1 VALUES(1,true)");
        stmt.execute ("INSERT INTO test2 VALUES(2)");
        ResultSet rs = stmt.executeQuery ("select id,null as b1 from test2 union select id, b1 from test1");
        Boolean [] array = new Boolean [2];
        for (int i = 0; rs.next (); i ++) {
            boolean boole = rs.getBoolean (2);
            array [i] = Boolean.valueOf (boole);
            if (rs.wasNull ()) {
                array [i] = null;
            }
        }
        boolean result = (array [0] == null && array [1] == Boolean.TRUE) || (array [0] == Boolean.TRUE && array [1] == null);
        assertTrue (result);
    } catch (SQLException e) {
        e.printStackTrace ();
        System.out.println ("TestSql.testUnionColumnType() error: " + e.getMessage ());
    }
}


public boolean execSql (String sql) {
    boolean bool = false;
    this.result = null;
    Connection conn = null;
    try {
        conn = ConnectUtil.getConnect ();
        PreparedStatement ps = conn.prepareStatement (sql);
        ps.executeUpdate ();
        ps.close ();
        bool = true;
    } catch (Exception e) {
        this.result = e.getMessage ();
    } finally {
        ConnectUtil.closeConn (conn);
    }
    return bool;
}


-----Function Pair=313=-----==

void clearCompletedTaskLogs (long age, long lastRun) {
    String delQry = "DELETE FROM log WHERE mediaid <> '0' AND mediaid <> '-1' AND ts < " + (System.currentTimeMillis () - age);
    Statement delStmt = null;
    try {
        delStmt = conn.createStatement ();
        delStmt.executeUpdate (delQry);
    } catch (SQLException e) {
        LOG.error ("SQL error", e);
        throw new RuntimeException (e);
    } finally {
        try {
            if (delStmt != null) delStmt.close ();
        } catch (SQLException e) {
            LOG.error ("SQL error", e);
            throw new RuntimeException (e);
        }
    }
}


protected void removeMessage (ReplicationMessage message) {
    logger.info (String.format ("remove replication message: %d", message.getId ()));
    ConnectionProvider cp = null;
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        SessionFactoryImplementor impl = (SessionFactoryImplementor) portalDao.getSessionFactory ();
        cp = impl.getConnectionProvider ();
        conn = cp.getConnection ();
        conn.setAutoCommit (false);
        ps = conn.prepareStatement ("delete from light_replication_message where id=?");
        ps.setLong (1, message.getId ());
        ps.executeUpdate ();
        conn.commit ();
        ps.close ();
        conn.close ();
    } catch (Exception e) {
        try {
            conn.rollback ();
            ps.close ();
            conn.close ();
        } catch (Exception se) {
        }
    }
}


-----Function Pair=314=-----==

private long [] getSubsetConceptGids (int subsetId) throws SQLException {
    PreparedStatement getSubConsStmt = null;
    try {
        String getSubConQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_SUBSET_CONCEPTS_GID);
        getSubConsStmt = this.conn.prepareStatement (getSubConQuery);
        getSubConsStmt.setInt (1, subsetId);
        ResultSet rs = getSubConsStmt.executeQuery ();
        ArrayList al = new ArrayList ();
        while (rs.next ()) {
            long conceptGid = rs.getLong (1);
            al.add (new Long (conceptGid));
        }
        rs.close ();
        long [] gids = new long [al.size ()];
        for (int i = 0; i < al.size (); i ++) {
            gids [i] = ((Long) al.get (i)).longValue ();
        }
        return gids;
    } finally {
        if (getSubConsStmt != null) {
            getSubConsStmt.close ();
        }
    }
}


public RestServiceResult listCommentForDictionary (RestServiceResult serviceResult, Long nDictionaryId) {
    ToDictionary toDictionary = new ToDictionaryDAO ().findById (nDictionaryId);
    EntityManagerHelper.refresh (toDictionary);
    Set < ToComment > set = toDictionary.getToComments ();
    List < ToComment > list = new ArrayList < ToComment > (set);
    if (list.size () == 0) {
        serviceResult.setNumResult (0);
        serviceResult.setMessage (bundle.getString ("comment.list.notFound"));
        log.info ("Resultado es cero");
    }
    else {
        Object [] array = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.list.success"), array));
        serviceResult.setNumResult (list.size ());
        log.info ("Resultado es diferente de cero " + list.size ());
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


-----Function Pair=315=-----==

public void link (TimmonId id, TimmonId parent_id) throws SecurityException, RemoteException, IllegalArgumentException, TimmonBackEndException {
    SQLTimmonId sql_id = (SQLTimmonId) id;
    SQLTimmonId sql_parent_id = (SQLTimmonId) parent_id;
    int type = sql_id.getTimmonIdType ();
    if (isTypeOf (TYPE_USER_MASK, type)) {
        if (! isTypeOf (TYPE_GROUP_MASK, sql_parent_id.getTimmonIdType ())) throw (new TimmonBackEndException ("cannot link user to non 'group' parent (" + sql_parent_id.getTimmonIdType () + ")"));
        SQLTimmonId root_group_id = (SQLTimmonId) doGetGlobalProperty (GPROP_KEY_ROOT_GROUP_ID);
        if (root_group_id.equals (parent_id)) throw (new TimmonBackEndException ("cannot link user to 'all' group"));
        try {
            sql_add_user_to_group_stmt_.setInt (1, (int) sql_parent_id.getTimmonId ());
            sql_add_user_to_group_stmt_.setInt (2, (int) sql_id.getTimmonId ());
            sql_add_user_to_group_stmt_.executeUpdate ();
        } catch (SQLException exc) {
            if (Debug.DEBUG) Debug.println ("exc", exc + Debug.getStackTrace (exc));
            throw (new TimmonBackEndException (exc));
        }
    }
    else throw (new TimmonBackEndException ("can only link users to groups"));
}


private void doTestNewsItemPortletById () throws Exception {
    for (int i = 0; i < newsBlock.getNewsGroupCount (); i ++) {
        NewsGroupType group = newsBlock.getNewsGroup (i);
        for (int j = 0; j < group.getNewsItemCount (); j ++) {
            NewsItemType item = group.getNewsItem (j);
            testAbstract.initRequestSession ();
            PortletDefinition desc;
            PortletResultObject obj;
            NewsItemSimpleType originItem = new NewsItemSimpleType ();
            originItem.setNewsAnons (item.getNewsAnons ());
            originItem.setNewsDate (DateUtils.getStringDate (item.getNewsDateTime (), "dd.MMM.yyyy", StringTools.getLocale (TestSite.TEST_LANGUAGE)));
            originItem.setNewsHeader (item.getNewsHeader ());
            originItem.setNewsText (item.getNewsText ());
            originItem.setNewsTime (DateUtils.getStringDate (item.getNewsDateTime (), "HH:mm", StringTools.getLocale (TestSite.TEST_LANGUAGE)));
            byte [] originByte = XmlTools.getXml (originItem, "NewsItemSimple");
            MainTools.writeToFile (SiteUtils.getTempDir () + "news-by-id-bytes-from-test-object.xml", originByte);
            System.out.println ("news id - " + item.getNewsItemId ());
            System.out.println ("result #1 " + new String (originByte, "utf-8"));
        }
    }
}


-----Function Pair=316=-----==

public String updateNamespace (Element root) throws SQLException, XMLException {
    NodeList children = root.getChildNodes ();
    int len = children.getLength ();
    Node node = children.item (0);
    String oldId = root.getAttribute (ID);
    String name = getAttribute (node, NAME);
    String code = getAttribute (node, CODE);
    String type = getAttribute (node, TYPE);
    String authority_id = getAttribute (node, AUTHORITY_ID);
    String referenced_by = getAttribute (node, REFERENCED_BY);
    String local = getAttribute (node, "local");
    String writable = getAttribute (node, "writable");
    String semanticType = getAttribute (node, "semanticType");
    name = DTSUtil.checkValue ("Namespace Name", name, DTSDataLimits.LEN_NAME);
    code = DTSUtil.checkValue ("Namespace Code", code, DTSDataLimits.LEN_CODE);
    updateSt.setString (1, name);
    updateSt.setString (2, code);
    updateSt.setString (3, referenced_by);
    updateSt.setString (4, authority_id);
    updateSt.setString (5, local);
    updateSt.setString (6, writable);
    updateSt.setString (7, semanticType);
    updateSt.setString (8, type);
    updateSt.setString (9, oldId);
    int result = updateSt.executeUpdate ();
    String response = null;
    if (result != 0) {
        addCache (new Integer (oldId), name, local, writable, type);
        response = getTrueResult ();
    }
    else {
        response = getFalseResult ();
    }
    return response;
}


public static void savechoice (Hashtable h) throws Exception {
    String applicant_id = (String) h.get ("applicant_id");
    String choice1 = (String) h.get ("choice1");
    String choice2 = (String) h.get ("choice2");
    String choice3 = (String) h.get ("choice3");
    if ("".equals (applicant_id)) return;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("applicant_id");
            r.add ("applicant_id", applicant_id);
            sql = r.getSQLSelect ("adm_applicant_choice");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        {
            r.clear ();
            r.add ("choice1", choice1);
            r.add ("choice2", choice2);
            r.add ("choice3", choice3);
            if (! found) {
                r.add ("applicant_id", applicant_id);
                sql = r.getSQLInsert ("adm_applicant_choice");
            }
            else {
                r.update ("applicant_id", applicant_id);
                sql = r.getSQLUpdate ("adm_applicant_choice");
            }
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=317=-----==

protected void setUp () {
    try {
        Connection setupConn = DriverManager.getConnection ("jdbc:hsqldb:mem:test", "SA", "");
        setupConn.setAutoCommit (false);
        Statement st = setupConn.createStatement ();
        st.executeUpdate ("SET PASSWORD 'sapwd'");
        populate (st);
        st.close ();
        setupConn.commit ();
        setupConn.close ();
    } catch (SQLException se) {
        throw new RuntimeException ("Failed to set up in-memory database", se);
    }
    try {
        server = new Server ();
        HsqlProperties properties = new HsqlProperties ();
        if (System.getProperty ("VERBOSE") == null) {
            server.setLogWriter (null);
            server.setErrWriter (null);
        }
        else {
            properties.setProperty ("server.silent", "false");
            properties.setProperty ("server.trace", "true");
        }
        properties.setProperty ("server.database.0", "mem:test");
        properties.setProperty ("server.dbname.0", "");
        properties.setProperty ("server.port", AbstractTestOdbc.portString);
        server.setProperties (properties);
        server.start ();
        try {
            Thread.sleep (1000);
        } catch (InterruptedException ie) {
        }
    } catch (Exception e) {
        throw new RuntimeException ("Failed to set up in-memory database", e);
    }
    if (server.getState () != ServerConstants.SERVER_STATE_ONLINE) {
        throw new RuntimeException ("Server failed to start up");
    }
    try {
        netConn = DriverManager.getConnection ("jdbc:odbc:" + dsnName, "SA", "sapwd");
    } catch (SQLException se) {
        if (se.getMessage ().indexOf ("No suitable driver") > - 1) {
            throw new RuntimeException ("You must install the native library for Sun's jdbc:odbc " + "JDBC driver");
        }
        if (se.getMessage ().indexOf ("Data source name not found") > - 1) {
            throw new RuntimeException ("You must configure ODBC DSN '" + dsnName + "' (you may change the name and/or port by setting Java " + "system properties 'test.hsqlodbc.port' or " + "'test.hsqlodbc.dsnname'");
        }
        throw new RuntimeException ("Failed to set up JDBC/ODBC network connection", se);
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("P�rez");
            c.setApellido2 ("G�mez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=318=-----==

public Object executeProcessReturnObject () throws SQLException {
    psImpl = connImpl.prepareStatement (sqlCommands.getProperty ("realm.removeUser"));
    Iterator < NewUser > iter = users.iterator ();
    NewUser user;
    int realmId;
    Iterator < Integer > iter2;
    List < Integer > removeFromNullRealm = new ArrayList < Integer > ();
    while (iter.hasNext ()) {
        user = iter.next ();
        psImpl.setInt (1, user.userId);
        iter2 = user.realmIds.iterator ();
        while (iter2.hasNext ()) {
            realmId = iter2.next ();
            if (realmId == 0) {
                removeFromNullRealm.add (user.userId);
                continue;
            }
            psImpl.setInt (2, realmId);
            psImpl.executeUpdate ();
        }
        cmDB.removeUser (user.userId);
    }
    return removeFromNullRealm;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=319=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
            person.getAddresses ().add ("Camino De Las Cabras 212 - San Jose");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=320=-----==

public List < Website > loadAll () {
    List < Website > websites = new ArrayList < Website > ();
    Connection conn = null;
    try {
        conn = db.getConnection ();
        String sql1 = "SELECT id, url, name, description FROM websites";
        PreparedStatement ps1 = conn.prepareStatement (sql1);
        ResultSet rs1 = ps1.executeQuery ();
        while (rs1.next ()) {
            int id = rs1.getInt ("id");
            String url = rs1.getString ("url");
            String name = rs1.getString ("name");
            String description = rs1.getString ("description");
            String sql2 = "SELECT id, keyphrase FROM keyphrases WHERE website_id=? ORDER BY id";
            PreparedStatement ps2 = conn.prepareStatement (sql2);
            ps2.setInt (1, id);
            ResultSet rs2 = ps2.executeQuery ();
            List < Keyphrase > keyphrases = new ArrayList < Keyphrase > ();
            while (rs2.next ()) {
                keyphrases.add (new Keyphrase (rs2.getInt ("id"), id, rs2.getString ("keyphrase")));
            }
            Website website = new Website (id, url, name, description, keyphrases);
            websites.add (website);
            rs2.close ();
            ps2.close ();
        }
        rs1.close ();
        ps1.close ();
    } catch (SQLException ex) {
        throw new OsseoFailure ("SQL error: cannot read website list. ", ex);
    } finally {
        db.putConnection (conn);
    }
    return websites;
}


protected synchronized Long putModel (String table, String linkTable, String type, TupleBinding binding, LocatableModel model) {
    try {
        if (model.getId () != null && ! "".equals (model.getId ())) {
            ps7.setInt (1, Integer.parseInt (model.getId ()));
            ps7.execute ();
            ps6.setInt (1, Integer.parseInt (model.getId ()));
            ps6.execute ();
        }
        if (persistenceMethod == PostgreSQLStore.BYTEA) {
            ps1.setString (1, model.getContig ());
            ps1.setInt (2, model.getStartPosition ());
            ps1.setInt (3, model.getStopPosition ());
            ps1.setString (4, type);
            DatabaseEntry objData = new DatabaseEntry ();
            binding.objectToEntry (model, objData);
            ps1.setBytes (5, objData.getData ());
            ps1.executeUpdate ();
        }
        else if (persistenceMethod == PostgreSQLStore.OID || persistenceMethod == PostgreSQLStore.FIELDS) {
            ps1b.setString (1, model.getContig ());
            ps1b.setInt (2, model.getStartPosition ());
            ps1b.setInt (3, model.getStopPosition ());
            ps1b.setString (4, type);
            DatabaseEntry objData = new DatabaseEntry ();
            binding.objectToEntry (model, objData);
            int oid = lobj.create (LargeObjectManager.READ | LargeObjectManager.WRITE);
            LargeObject obj = lobj.open (oid, LargeObjectManager.WRITE);
            obj.write (objData.getData ());
            obj.close ();
            ps1b.setInt (5, oid);
            ps1b.executeUpdate ();
        }
        ResultSet rs = null;
        PreparedStatement ps = conn.prepareStatement ("select currval('" + table + "_" + table + "_id_seq')");
        rs = ps.executeQuery ();
        int modelId = - 1;
        if (rs != null) {
            if (rs.next ()) {
                modelId = rs.getInt (1);
            }
        }
        rs.close ();
        ps.close ();
        for (String key : model.getTags ().keySet ()) {
            int tagId = - 1;
            if (tags.get (key) != null) {
                tagId = tags.get (key);
            }
            else {
                ps2.setString (1, key);
                rs = ps2.executeQuery ();
                if (rs != null) {
                    while (rs.next ()) {
                        tagId = rs.getInt (1);
                    }
                }
                rs.close ();
            }
            if (tagId < 0) {
                ps3.setString (1, key);
                ps3.setString (2, model.getTags ().get (key));
                ps3.executeUpdate ();
                rs = ps4.executeQuery ();
                if (rs != null) {
                    if (rs.next ()) {
                        tagId = rs.getInt (1);
                        tags.put (key, tagId);
                    }
                }
                rs.close ();
            }
            ps5.setInt (1, tagId);
            ps5.executeUpdate ();
        }
        conn.commit ();
        return (new Long (modelId));
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e2) {
            e2.printStackTrace ();
        }
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e2) {
            e2.printStackTrace ();
        }
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    }
    return (null);
}


-----Function Pair=321=-----==

public List findMaxResults (int max) throws TechnicalException {
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        Criteria criteria = session.createCriteria (TimeSlot.class).setResultTransformer (Criteria.DISTINCT_ROOT_ENTITY).setMaxResults (max);
        List result = criteria.list ();
        transaction.commit ();
        return result;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    }
}


private static void shuffle (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        Person person1 = list.iterator ().next ();
        Person person2 = new Person ();
        person2.setFirstName ("William");
        person2.setLastName ("Bush");
        Address address = person1.getAddresses ().iterator ().next ();
        person1.getAddresses ().remove (address);
        person2.getAddresses ().add (address);
        session.save (person2);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


-----Function Pair=322=-----==

public boolean executeRepositoryUpdateTransaction (DatabaseRepositoryQuery [] queries) {
    Connection connection = null;
    int pos = 0;
    NamedParameterStatement [] queriesArray;
    boolean autoCommit = true;
    if (queries.length == 0) {
        return true;
    }
    try {
        connection = this.dataSource.getConnection ();
        queriesArray = this.getRepositoryPreparedStatements (connection, queries);
        autoCommit = connection.getAutoCommit ();
        connection.setAutoCommit (false);
        for (pos = 0; pos < queriesArray.length; pos ++) {
            try {
                queriesArray [pos].executeUpdate ();
            } finally {
                queriesArray [pos].close ();
            }
        }
        if (autoCommit) {
            connection.commit ();
            connection.setAutoCommit (true);
        }
    } catch (SQLException oException) {
        try {
            if (connection != null) connection.rollback ();
        } catch (SQLException oRollbackException) {
            throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, Strings.ROLLBACK, oRollbackException);
        }
    } finally {
        close (connection);
    }
    return true;
}


public SessionType findByAcronym (String acronym) throws DBConnectionException, SelectException {
    SessionType sessType = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("SESSION_TYPE_ACRONYM", acronym);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                sessType = new SessionType ();
                sessType.setId (result.getInt ("SESSION_TYPE_ID"));
                sessType.setName (result.getString ("SESSION_TYPE_NAME"));
                sessType.setAcronym (result.getString ("SESSION_TYPE_ACRONYM"));
                sessType.setEquivTuto (result.getFloat ("SESSION_TYPE_EQV_TD"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return sessType;
}


-----Function Pair=323=-----==

public static IReferenceLocal getReference () throws ClassCastException, NamingException {
    if (localReference != null) {
        return localReference;
    }
    else {
        IReferenceLocal local = null;
        try {
            local = (IReferenceLocal) getBean (getReferenceBean (), IReferenceLocal.class);
        } catch (ClassCastException cce) {
            Log.exception (cce);
            System.exit (1);
        }
        if (local == null) {
            throw new NamingException ("getReference() is null");
        }
        localReference = local;
        return localReference;
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=324=-----==

public < T > void remove (EntityManager em, Collection < T > objs) throws RuntimeException {
    EntityManager emTemp = em;
    boolean doCloseEntityManager = false;
    if (emTemp == null) {
        emTemp = getEntityManager ();
        doCloseEntityManager = true;
    }
    if (emTemp != null) {
        EntityTransaction et = emTemp.getTransaction ();
        try {
            if (et.isActive () == false) {
                et.begin ();
            }
            for (T t : objs) {
                emTemp.remove (t);
            }
            if (et.isActive ()) {
                et.commit ();
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            if (doCloseEntityManager) {
                emTemp.close ();
            }
            throw new RuntimeException (exception);
        }
        if (doCloseEntityManager) {
            emTemp.close ();
        }
    }
}


public String addUserIdentity (OpenIDItem identity, long userId) throws DatabaseException {
    if (identity == null) throw new NullPointerException ("identity");
    if (identity.getIdentity () == null || "".equals (identity.getIdentity ())) throw new NullPointerException ("identity.getIdentity()");
    try {
        getConnection ().setAutoCommit (false);
    } catch (SQLException e) {
        LOGGER.warn ("Unable to set autocommit off", e);
    }
    String retID = "exist";
    PreparedStatement insSt = null, seqSt = null;
    try {
        int modified = 0;
        insSt = getConnection ().prepareStatement (INSERT_IDENTITY_STATEMENT);
        insSt.setLong (1, userId);
        insSt.setString (2, identity.getIdentity ());
        modified = insSt.executeUpdate ();
        seqSt = getConnection ().prepareStatement (USER_IDENTITY_VALUE);
        ResultSet rs = seqSt.executeQuery ();
        while (rs.next ()) {
            retID = rs.getString (1);
        }
        if (modified == 1) {
            getConnection ().commit ();
            LOGGER.debug ("DB has been updated. Queries: \"" + seqSt + "\" and \"" + insSt + "\"");
        }
        else {
            getConnection ().rollback ();
            LOGGER.debug ("DB has not been updated -> rollback! Queries: \"" + seqSt + "\" and \"" + insSt + "\"");
            retID = "error";
        }
    } catch (SQLException e) {
        LOGGER.error (e);
        retID = "error";
    } finally {
        closeConnection ();
    }
    return retID;
}


-----Function Pair=325=-----==

public void test32_blockedAccount () throws Exception {
    Logs.logMethodName ();
    Db db = DbConnection.defaultCieDbRW ();
    try {
        db.begin ();
        Config.setProperty (db, "com.entelience.esis.security.numberOfFailedLoginLimit", "3", PeopleFactory.anonymousId);
        Config.setProperty (db, "com.entelience.esis.security.failedLoginTimeLimit", "5", PeopleFactory.anonymousId);
        db.commit ();
        p_logout ();
        LoginResult lr = null;
        for (int i = 0; i < 2; i ++) {
            lr = login ("esis", "bad password");
            assertTrue (lr.isLoginFail ());
            assertFalse (lr.isAccountLocked ());
            assertFalse (lr.isAccountNewlyLocked ());
            assertFalse (lr.isSuccess ());
            assertEquals (3, lr.getNumberOfFailedLoginLimit ());
            assertEquals (5, lr.getFailedLoginTimeLimit ());
            assertEquals (i + 1, lr.getConsecutiveFailedLogin ());
        }
        lr = login ("esis", "esis");
        assertFalse (lr.isLoginFail ());
        assertFalse (lr.isAccountLocked ());
        assertFalse (lr.isAccountNewlyLocked ());
        assertTrue (lr.isSuccess ());
        assertEquals (3, lr.getNumberOfFailedLoginLimit ());
        assertEquals (5, lr.getFailedLoginTimeLimit ());
        assertEquals (0, lr.getConsecutiveFailedLogin ());
        for (int i = 0; i < 2; i ++) {
            lr = login ("esis", "bad password");
            assertTrue (lr.isLoginFail ());
            assertFalse (lr.isAccountLocked ());
            assertFalse (lr.isAccountNewlyLocked ());
            assertFalse (lr.isSuccess ());
            assertEquals (3, lr.getNumberOfFailedLoginLimit ());
            assertEquals (5, lr.getFailedLoginTimeLimit ());
            assertEquals (i + 1, lr.getConsecutiveFailedLogin ());
        }
        lr = login ("esis", "bad password");
        assertTrue (lr.isLoginFail ());
        assertTrue (lr.isAccountLocked ());
        assertTrue (lr.isAccountNewlyLocked ());
        assertFalse (lr.isSuccess ());
        assertEquals (3, lr.getNumberOfFailedLoginLimit ());
        assertEquals (5, lr.getFailedLoginTimeLimit ());
        assertEquals (3, lr.getConsecutiveFailedLogin ());
        lr = login ("esis", "esis");
        assertTrue (lr.isLoginFail ());
        assertTrue (lr.isAccountLocked ());
        assertFalse (lr.isAccountNewlyLocked ());
        assertFalse (lr.isSuccess ());
        assertEquals (3, lr.getNumberOfFailedLoginLimit ());
        assertEquals (5, lr.getFailedLoginTimeLimit ());
        assertEquals (4, lr.getConsecutiveFailedLogin ());
        db.begin ();
        assertTrue (PeopleFactory.unlockAccount (db, esisId, PeopleFactory.anonymousId));
        db.commit ();
        PeopleHistory [] ph = getUserHistory (esisId);
        assertNotNull (ph);
        assertTrue (ph.length > 0);
        lr = login ("esis", "bad password");
        assertEquals (lr.isLoginFail (), true);
        assertEquals (lr.isAccountLocked (), false);
        assertEquals (lr.isAccountNewlyLocked (), false);
        assertEquals (lr.isSuccess (), false);
        assertSame (3, lr.getNumberOfFailedLoginLimit ());
        assertSame (5, lr.getFailedLoginTimeLimit ());
        assertSame (1, lr.getConsecutiveFailedLogin ());
        lr = login ("esis", "esis");
        assertEquals (lr.isLoginFail (), false);
        assertEquals (lr.isAccountLocked (), false);
        assertEquals (lr.isAccountNewlyLocked (), false);
        assertEquals (lr.isSuccess (), true);
        assertSame (3, lr.getNumberOfFailedLoginLimit ());
        assertSame (5, lr.getFailedLoginTimeLimit ());
        assertSame (0, lr.getConsecutiveFailedLogin ());
    } catch (Exception e) {
        e.printStackTrace ();
        db.rollback ();
    } finally {
        db.safeClose ();
    }
}


public void insert () {
    DbRs rs = null;
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        conn.setAutoCommit (false);
        String sql = "select * from sevgrade where sgid = ?";
        conn.prepare (sql);
        conn.setInt (1, getSgid ());
        rs = conn.executeQuery ();
        if (rs != null && rs.size () > 0) {
            setErr ("等级编号已经存在请重新输入");
            return;
        }
        sql = "insert into sevgrade(sgid,sgname)values(?,?)";
        conn.prepare (sql);
        conn.setInt (1, getSgid ());
        conn.setString (2, getSgname ());
        conn.executeUpdate ();
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=326=-----==

public SessionType findBySubjectModel (Integer idSubjectModel) throws SelectException, DBConnectionException {
    SessionType sessType = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (SessionTypeDAO.TABLE_NAME + " sess"));
    tablesFrom.add (new SQLWord (SubjectModelDAO.TABLE_NAME + " subj"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("subj.SUBJECT_MODEL_ID", idSubjectModel);
    critWhere.addCriterion ("sess.SESSION_TYPE_ID", new SQLWord ("subj.SESSION_TYPE_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                sessType = new SessionType ();
                sessType.setId (result.getInt ("SESSION_TYPE_ID"));
                sessType.setName (result.getString ("SESSION_TYPE_NAME"));
                sessType.setAcronym (result.getString ("SESSION_TYPE_ACRONYM"));
                sessType.setEquivTuto (result.getFloat ("SESSION_TYPE_EQV_TD"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return sessType;
}


public static PhotoOutlineBean getNextPhoto (SiteBean site, SessionUserObject user, int album_id, int photo_id) {
    if (site == null) return null;
    StringBuffer hql = new StringBuffer ("FROM PhotoOutlineBean AS p WHERE p.status=:photo_status AND p.site.id=:site AND p.id>:photo");
    if (user == null || ! site.isOwner (user)) {
        hql.append (" AND p.album.type=:album_type");
    }
    if (album_id > 0) {
        hql.append (" AND p.album.id=:album");
    }
    hql.append (" ORDER BY p.id ASC");
    Session ssn = getSession ();
    try {
        Query q = ssn.createQuery (hql.toString ());
        q.setInteger ("photo_status", PhotoBean.STATUS_NORMAL);
        q.setInteger ("site", site.getId ());
        q.setInteger ("photo", photo_id);
        if (album_id > 0) q.setInteger ("album", album_id);
        if (! site.isOwner (user)) q.setInteger ("album_type", AlbumBean.TYPE_PUBLIC);
        q.setMaxResults (1);
        return (PhotoOutlineBean) q.uniqueResult ();
    } finally {
        hql = null;
    }
}


-----Function Pair=327=-----==

public Instruction get (int id) throws FidoDatabaseException, InstructionNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Type, ExecuteString, FrameSlot, Operator, LinkName, " + "       ObjectId, AttributeName " + "from Instructions " + "where InstructionId = " + id;
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new InstructionNotFoundException (id);
            else {
                Instruction instruction = new Instruction (id, rs.getInt (1), rs.getString (2), rs.getString (3), rs.getInt (4), rs.getString (5), rs.getInt (6), rs.getString (7));
                return instruction;
            }
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public Integer getAcDataCustomerCount (Integer customerId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (AcDataCustomer.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" data.id = '" + customerId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=328=-----==

public Collection listTypes () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Type, Description from InstructionTypes order by Type";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                InstructionType type = new InstructionType (rs.getInt (1), rs.getString (2));
                list.add (type);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public static final boolean hasAlert (long accountId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select count(*) from Alert R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, accountId);
        Integer count = (Integer) q.uniqueResult ();
        return count > 0;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=329=-----==

protected List < List < Object > > retrieveAsList (String sql) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("querying " + sql + "...");
    }
    List < List < Object > > list = new ArrayList < List < Object > > ();
    Connection connection = null;
    try {
        connection = dataSource.getConnection ();
        connection.clearWarnings ();
        Statement statement = connection.createStatement ();
        ResultSet rs = statement.executeQuery (sql);
        ResultSetMetaData metadata = rs.getMetaData ();
        while (rs.next ()) {
            List < Object > oneRow = new ArrayList < Object > ();
            for (int i = 0; i < metadata.getColumnCount (); i ++) {
                oneRow.add (rs.getObject (i + 1));
            }
            list.add (oneRow);
        }
        return list;
    } catch (SQLException e) {
        LOG.error ("Unable to retrive data via: " + sql, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


private List < FieldStatusVO > findTableFieldStatus (String tableName) {
    List < FieldStatusVO > fieldStatusVOs = new ArrayList < FieldStatusVO > ();
    String sql = "SHOW FULL COLUMNS FROM " + tableName;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        conn = session.connection ();
        pstmt = conn.prepareStatement (sql);
        rs = pstmt.executeQuery ();
        FieldStatusVO fieldStatusVO = null;
        while (rs.next ()) {
            fieldStatusVO = new FieldStatusVO ();
            fieldStatusVO.setField (rs.getString ("Field"));
            fieldStatusVO.setType (rs.getString ("Type"));
            fieldStatusVO.setCollation (rs.getString ("Collation"));
            fieldStatusVO.setAllowNull (rs.getString ("Null"));
            fieldStatusVO.setKey (rs.getString ("Key"));
            fieldStatusVO.setDefaultValue (rs.getString ("Default"));
            fieldStatusVO.setExtra (rs.getString ("Extra"));
            fieldStatusVO.setPrivileges (rs.getString ("Privileges"));
            fieldStatusVO.setComment (rs.getString ("Comment"));
            fieldStatusVOs.add (fieldStatusVO);
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    } finally {
        try {
            if (transaction != null) {
                transaction = null;
            }
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return fieldStatusVOs;
}


-----Function Pair=330=-----==

public static long getAssociationType (Statement stmt, String column, String value, String namespaceId, StringBuffer response, GeneralDAO dao) throws SQLException {
    String statement = dao.getStatement (TABLE_KEY, "GET_TYPE_BY_" + column.toUpperCase ());
    statement = dao.getStatement (statement, 1, "'" + value + "'");
    ResultSet res = stmt.executeQuery (statement + namespaceId);
    long gid = - 1;
    while (res.next ()) {
        gid = res.getLong (1);
        int id = res.getInt (2);
        String code = res.getString (3);
        String name = res.getString (4);
        String connectType = res.getString (5);
        String purpose = res.getString (6);
        String inverseName = res.getString (7);
        response.append (DTSXMLFactory.createAssociationTypeXML (name, id, code, Integer.parseInt (namespaceId), connectType.charAt (0), purpose.charAt (0), inverseName));
    }
    res.close ();
    return gid;
}


public void testFilterEntity () {
    ScriptParser.registerScriplet ("methodResult", new FilterObjProperty ());
    ScriptParser.registerScriplet ("filterPar", new FilterProp ());
    ScriptParser.registerScriplet ("equal", new Equal ());
    FilterManager.instance ().clearFilter ();
    FilterManager.instance ().registerClassFilter (BookDTO.class, "#equal(#methodResult(#filterPar(entity),getTitle),bogus)");
    DTOSession dtoSession = DTOSessionFactory.getSession (DTOSessionFactory.createSession ("admin", dtoAccessService));
    AuthorDTO aAuthorDto = (AuthorDTO) dtoService.doLoad (aid, AuthorDTO.class, dtoSession);
    assertTrue (aAuthorDto.getBooksReadOnly ().size () == 0);
    assertTrue (aAuthorDto.getCommentBooksReadOnly ().size () == 0);
    dtoService.doSave (aAuthorDto, dtoSession);
    Session session = sf.getCurrentSession ();
    Transaction t = session.beginTransaction ();
    t.begin ();
    String fn = null, ln = null, title = null, text = null;
    boolean hasPerson = false, hasBook = false, hasComment = false;
    try {
        Author a = (Author) session.load (Author.class, aid);
        Person p = (Person) session.load (Person.class, pid);
        Book b = (Book) session.load (Book.class, bid);
        Comment c = (Comment) session.load (Comment.class, cid);
        fn = p.getFirstName ();
        ln = p.getLastName ();
        title = b.getTitle ();
        text = c.getText ();
        hasBook = a.getBooksReadOnly ().size () == 1;
        hasPerson = a.getPerson () != null;
        hasComment = a.getCommentBooksReadOnly ().size () == 1;
        t.commit ();
    } catch (HibernateException e) {
        e.printStackTrace ();
        t.rollback ();
    }
    assertTrue ("test".equals (fn));
    assertTrue ("test".equals (ln));
    assertTrue ("test".equals (title));
    assertTrue ("test".equals (text));
    assertTrue (hasPerson && hasBook && hasComment);
}


-----Function Pair=331=-----==

public static Cargo selectByID (String id_cargo) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Cargo objCargo = null;
    if (c == null) {
        return null;
    }
    try {
        String sql = "Select id_cargo, nome from cargo where id_cargo = ?";
        pst = c.prepareStatement (sql);
        pst.setString (1, id_cargo);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objCargo = new Cargo ();
            objCargo.setCodigo (rs.getInt ("id_cargo"));
            objCargo.setNome (rs.getString ("nome"));
        }
    } catch (SQLException e) {
        System.out.println ("[CargoDAO.selectByID] Erro ao atualizar -> " + e.getMessage ());
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objCargo;
}


public Subject store (Subject obj) throws InsertException, DBConnectionException {
    if (obj.getTeachingUnit ().getId () == null) {
        throw new InsertException ("Missing Teaching Unit FK");
    }
    else {
        Statement stmt;
        try {
            stmt = OracleJDBConnector.getInstance ().getStatement ();
        } catch (XmlIOException e2) {
            e2.printStackTrace ();
            throw new DBConnectionException ("Unable to get statement", e2);
        }
        List < Object > values = new ArrayList < Object > ();
        values.add (0);
        values.add (obj.getTeachingUnit ().getId ());
        values.add (obj.getDescription ());
        values.add (obj.getName ());
        values.add (obj.getDescription ());
        values.add (obj.getCoeff ());
        values.add (obj.getAlias ());
        try {
            stmt.executeUpdate (new InsertQuery (TABLE_NAME, values).toString ());
            Criteria critWhere = new Criteria ();
            critWhere.addCriterion ("TEACHING_UNIT_ID", obj.getTeachingUnit ().getId ());
            critWhere.addCriterion ("SUBJECT_NAME", obj.getName ());
            List < SQLWord > listSelect = new ArrayList < SQLWord > ();
            listSelect.add (new SQLWord ("SUBJECT_ID"));
            ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, listSelect, critWhere).toString ());
            if (result != null) {
                while (result.next ()) obj.setId (result.getInt ("SUBJECT_ID"));
            }
            else {
                throw new SelectException (TABLE_NAME + " Can't retieve record");
            }
            stmt.getConnection ().commit ();
            stmt.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
            try {
                stmt.getConnection ().rollback ();
            } catch (SQLException e1) {
                throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
            }
            throw new InsertException (TABLE_NAME + " Insert Exception :", e);
        }
    }
    return obj;
}


-----Function Pair=332=-----==

public Integer getMembersaddtoday () {
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        String hql = "SELECT COUNT(*) FROM Members WHERE regdate>=?";
        Query query = session.createQuery (hql);
        Integer nowTime = Integer.valueOf ((Calendar.getInstance ().getTimeInMillis () + "").substring (0, 10));
        query.setInteger (0, nowTime - 86400);
        List list = query.list ();
        if (list.size () <= 0) {
            throw new Exception ();
        }
        transaction.commit ();
        return (Integer) list.get (0);
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
        return null;
    }
}


private NotificationServerSettings reflectReporter (String clsName, String key, String data) {
    NotificationServerSettings obj = null;
    try {
        Class < ? > cls = Class.forName (clsName);
        Constructor < ? > ctor = cls.getConstructor ((Class < ? > []) null);
        ctor.setAccessible (true);
        obj = (NotificationServerSettings) ctor.newInstance ((Object []) null);
        Method method = cls.getDeclaredMethod ("unserialize", new Class < ? > [] {String.class, String.class});
        method.setAccessible (true);
        method.invoke (obj, Password.deobfuscate (key), Password.deobfuscate (data));
    } catch (ClassNotFoundException e) {
        LOG.error ("Class not found", e);
    } catch (NoSuchMethodException e) {
        LOG.error ("No such method", e);
    } catch (InvocationTargetException e) {
        LOG.error ("Invocation target exception", e);
    } catch (InstantiationException e) {
        LOG.error ("Instantiation exception", e);
    } catch (IllegalAccessException e) {
        LOG.error ("Illegal access", e);
    }
    return obj;
}


-----Function Pair=333=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoParagraphBaseKnowledge coParagraphBaseKnowledge) {
    CoParagraphBaseKnowledgeDAO coParagraphBaseKnowledgeDAO = new CoParagraphBaseKnowledgeDAO ();
    try {
        coParagraphBaseKnowledge.setKnowledgeId (getSequence ("sq_co_paragraph_base_knowledge"));
        EntityManagerHelper.beginTransaction ();
        coParagraphBaseKnowledgeDAO.save (coParagraphBaseKnowledge);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coParagraphBaseKnowledge);
        log.info ("Knowledge creado con �xito: " + coParagraphBaseKnowledge.getKnowledgeId ());
        Object [] arrayParam = {coParagraphBaseKnowledge.getKnowledgeId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el knowledge: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public boolean executeUpdate (String strSql, HashMap < Integer, Object > prams) throws SQLException, ClassNotFoundException {
    getConnection ();
    boolean flag = false;
    try {
        pstmt = con.prepareStatement (strSql);
        setParamet (pstmt, prams);
        logger.info ("###############::执行SQL语句操作(更新数据 有参数):" + strSql);
        if (0 < pstmt.executeUpdate ()) {
            close_DB_Object ();
            flag = true;
            con.commit ();
        }
    } catch (SQLException ex) {
        logger.info ("###############Error DBManager Line121::执行SQL语句操作(更新数据 无参数):" + strSql + "失败!");
        flag = false;
        con.rollback ();
        throw ex;
    } catch (ClassNotFoundException ex) {
        logger.info ("###############Error DBManager Line152::执行SQL语句操作(更新数据 无参数):" + strSql + "失败! 参数设置类型错误!");
        con.rollback ();
        throw ex;
    }
    return flag;
}


-----Function Pair=334=-----==

private void insert (Connection c) throws SQLException {
    if (m_fromDb) throw new IllegalStateException ("The record already exists in the database");
    StringBuffer names = new StringBuffer ("INSERT INTO ifServices (nodeID,ipAddr,serviceID");
    StringBuffer values = new StringBuffer ("?,?,?");
    if ((m_changed & CHANGED_IFINDEX) == CHANGED_IFINDEX) {
        values.append (",?");
        names.append (",ifIndex");
    }
    if ((m_changed & CHANGED_STATUS) == CHANGED_STATUS) {
        values.append (",?");
        names.append (",status");
    }
    if ((m_changed & CHANGED_LASTGOOD) == CHANGED_LASTGOOD) {
        values.append (",?");
        names.append (",lastGood");
    }
    if ((m_changed & CHANGED_LASTFAIL) == CHANGED_LASTFAIL) {
        values.append (",?");
        names.append (",lastFail");
    }
    if ((m_changed & CHANGED_SOURCE) == CHANGED_SOURCE) {
        values.append (",?");
        names.append (",source");
    }
    if ((m_changed & CHANGED_NOTIFY) == CHANGED_NOTIFY) {
        values.append (",?");
        names.append (",notify");
    }
    if ((m_changed & CHANGED_QUALIFIER) == CHANGED_QUALIFIER) {
        values.append (",?");
        names.append (",qualifier");
    }
    names.append (") VALUES (").append (values).append (')');
    if (log ().isDebugEnabled ()) log ().debug ("DbIfServiceEntry.insert: SQL insert statment = " + names.toString ());
    PreparedStatement stmt = null;
    PreparedStatement delStmt = null;
    final DBUtils d = new DBUtils (getClass ());
    try {
        stmt = c.prepareStatement (names.toString ());
        d.watch (stmt);
        names = null;
        int ndx = 1;
        stmt.setInt (ndx ++, m_nodeId);
        stmt.setString (ndx ++, m_ipAddr.getHostAddress ());
        stmt.setInt (ndx ++, m_serviceId);
        if ((m_changed & CHANGED_IFINDEX) == CHANGED_IFINDEX) stmt.setInt (ndx ++, m_ifIndex);
        if ((m_changed & CHANGED_STATUS) == CHANGED_STATUS) stmt.setString (ndx ++, new String (new char [] {m_status}));
        if ((m_changed & CHANGED_LASTGOOD) == CHANGED_LASTGOOD) {
            stmt.setTimestamp (ndx ++, m_lastGood);
        }
        if ((m_changed & CHANGED_LASTFAIL) == CHANGED_LASTFAIL) {
            stmt.setTimestamp (ndx ++, m_lastFail);
        }
        if ((m_changed & CHANGED_SOURCE) == CHANGED_SOURCE) stmt.setString (ndx ++, new String (new char [] {m_source}));
        if ((m_changed & CHANGED_NOTIFY) == CHANGED_NOTIFY) stmt.setString (ndx ++, new String (new char [] {m_notify}));
        if ((m_changed & CHANGED_QUALIFIER) == CHANGED_QUALIFIER) stmt.setString (ndx ++, m_qualifier);
        int rc;
        try {
            rc = stmt.executeUpdate ();
        } catch (SQLException e) {
            log ().warn ("ifServices DB insert got exception; will retry after " + "deletion of any existing records for this ifService " + "that are marked for deletion.", e);
            c.rollback ();
            String delCmd = "DELETE FROM ifServices WHERE status = 'D' " + "AND nodeid = ? AND ipAddr = ? AND serviceID = ?";
            delStmt = c.prepareStatement (delCmd);
            d.watch (delStmt);
            delStmt.setInt (1, m_nodeId);
            delStmt.setString (2, m_ipAddr.getHostAddress ());
            delStmt.setInt (3, m_serviceId);
            rc = delStmt.executeUpdate ();
            rc = stmt.executeUpdate ();
        }
        log ().debug ("insert(): SQL update result = " + rc);
    } finally {
        d.cleanUp ();
    }
    m_fromDb = true;
    m_changed = 0;
}


public void testSocketConcurrency1 () {
    final Connection con = this.con;
    final int threadCount = 10, loopCount = 10;
    final Vector errors = new Vector ();
    StringBuffer queryBuffer = new StringBuffer (4100);
    queryBuffer.append ("SELECT '");
    while (queryBuffer.length () < 2000) {
        queryBuffer.append ("0123456789");
    }
    queryBuffer.append ("' AS value1, '");
    while (queryBuffer.length () < 4000) {
        queryBuffer.append ("9876543210");
    }
    queryBuffer.append ("' AS value2");
    final String query = queryBuffer.toString ();
    Thread heavyThreads [] = new Thread [threadCount], lightThreads [] = new Thread [threadCount];
    for (int i = 0; i < threadCount; i ++) {
        heavyThreads [i] = new Thread () {
            public void run () {
                try {
                    Statement stmt = con.createStatement ();
                    for (int i = 0; i < loopCount; i ++) {
                        stmt.execute (query);
                    }
                    stmt.close ();
                } catch (SQLException ex) {
                    ex.printStackTrace ();
                    errors.add (ex);
                }
            }
        }
        ;
    }
    for (int i = 0; i < threadCount; i ++) {
        lightThreads [i] = new Thread () {
            public void run () {
                try {
                    sleep (100);
                } catch (InterruptedException ex) {
                }
                try {
                    Statement stmt = con.createStatement ();
                    for (int i = 0; i < loopCount; i ++) {
                        stmt.execute ("SELECT 1");
                    }
                    stmt.close ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                    errors.add (ex);
                }
            }
        }
        ;
    }
    for (int i = 0; i < threadCount; i ++) {
        heavyThreads [i].start ();
        lightThreads [i].start ();
    }
    for (int i = 0; i < threadCount; i ++) {
        try {
            heavyThreads [i].join ();
        } catch (InterruptedException ex) {
        }
        try {
            lightThreads [i].join ();
        } catch (InterruptedException ex) {
        }
    }
    assertEquals (0, errors.size ());
}


-----Function Pair=335=-----==

boolean addOverride (int airingId, String title, String subtitle, boolean active) {
    boolean autoCommit = false;
    try {
        autoCommit = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        overrideRmQry.setInt (1, airingId);
        overrideRmQry.executeUpdate ();
        overrideInsQry.setInt (1, airingId);
        overrideInsQry.setString (2, title);
        overrideInsQry.setString (3, subtitle);
        overrideInsQry.setBoolean (4, active);
        overrideInsQry.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            LOG.error (SQL_ERROR, e1);
        }
        LOG.error (SQL_ERROR, e);
        return false;
    } finally {
        try {
            conn.setAutoCommit (autoCommit);
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
    return true;
}


public Enumeration getSubscriptions () {
    Vector subscriptions = new Vector ();
    StringACLCodec codec = new StringACLCodec ();
    ResultSet rs = null;
    try {
        rs = getPreparedStatements ().stm_selSubscriptions.executeQuery ();
        while (rs.next ()) {
            String base64Str = rs.getString ("aclm");
            String aclmStr = new String (Base64.decodeBase64 (base64Str.getBytes ("US-ASCII")), "US-ASCII");
            ACLMessage aclm = codec.decode (aclmStr.getBytes (), ACLCodec.DEFAULT_CHARSET);
            subscriptions.add (sr.createSubscription (aclm));
        }
    } catch (Exception e) {
        if (logger.isLoggable (Logger.SEVERE)) logger.log (Logger.SEVERE, "Error retrieving subscriptions from the database", e);
    } finally {
        closeResultSet (rs);
    }
    return subscriptions.elements ();
}


-----Function Pair=336=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public boolean actualizarNdivisiones (int idTorneo, int nDivisiones) {
    int intResult = 0;
    String sql = "UPDATE torneo" + " SET  numeroDivisiones=" + nDivisiones + " WHERE idTorneo=" + idTorneo;
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        intResult = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (intResult > 0);
}


-----Function Pair=337=-----==

protected static void clearTables () throws SQLException {
    Connection conn = null;
    Statement stmt = null;
    try {
        conn = FidoDataSource.getConnection ();
        conn.setAutoCommit (false);
        stmt = conn.createStatement ();
        ClearData.clearTables (stmt);
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (2, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (3, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (4, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (5, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (6, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (7, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (8, '')");
        conn.commit ();
    } catch (SQLException e) {
        if (conn != null) conn.rollback ();
        throw e;
    } finally {
        if (stmt != null) stmt.close ();
        if (conn != null) conn.close ();
    }
}


public void update () {
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        conn.setAutoCommit (false);
        String sql = "";
        sql = "update companyinfo set comname =? ,comman=?,comaddress=?, comtel=? ,commantel=?,commanmail=?,comremark=?  where comid = ?";
        conn.prepare (sql);
        conn.setString (1, getComnam ());
        conn.setString (2, getComman ());
        conn.setString (3, getComaddress ());
        conn.setString (4, getComtel ());
        conn.setString (5, getCommantel ());
        conn.setString (6, getCommanmail ());
        conn.setString (7, getComremark ());
        conn.setInt (8, getComid ());
        conn.executeUpdate ();
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=338=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        person.getAddresses ().add (address2);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private Date queryUpdateDate (Connection con) throws SQLException {
    Date updateDate = null;
    StringBuilder sbSql = new StringBuilder ();
    sbSql.append ("SELECT UPDATEDATE FROM ").append (getHarvestingTableName ()).append (" ");
    sbSql.append ("WHERE DOCUUID=?");
    PreparedStatement st = null;
    ResultSet rs = null;
    try {
        st = con.prepareStatement (sbSql.toString ());
        st.setString (1, getRepository ().getUuid ());
        logExpression (sbSql.toString ());
        rs = st.executeQuery ();
        if (rs.next ()) {
            updateDate = rs.getTimestamp (1);
        }
    } finally {
        closeResultSet (rs);
        closeStatement (st);
    }
    return updateDate;
}


-----Function Pair=339=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public boolean isAnalysis (int taskid) {
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        String sql = "";
        DbRs rs = null;
        sql = "select * from pal where taskid = ?";
        conn.prepare (sql);
        conn.setInt (1, taskid);
        rs = conn.executeQuery ();
        if (rs.size () > 0) {
            return true;
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
        } catch (Exception e) {
            e.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
    return false;
}


-----Function Pair=340=-----==

public List < Alert > getAllAlerts () throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Alert R";
        Query q = s.createQuery (query);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=341=-----==

public boolean update (String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {
    filasUpdate = 0;
    if (! consulta.contains (";")) {
        this.tipoConsulta = new Scanner (consulta);
        if (this.tipoConsulta.hasNext ()) {
            execConsulta = this.tipoConsulta.next ();
            if (execConsulta.equalsIgnoreCase ("update")) {
                Connection conexion = cx;
                Statement st = null;
                try {
                    conexion.setAutoCommit (autocommit);
                    if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {
                        conexion.setTransactionIsolation (transactionIsolation);
                    }
                    else {
                        throw new IllegalArgumentException ("Valor invalido sobre TransactionIsolation,\n TRANSACTION_NONE no es soportado por MySQL");
                    }
                    st = (Statement) conexion.createStatement (ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);
                    conexion.setReadOnly (false);
                    filasUpdate = st.executeUpdate (consulta.trim (), Statement.RETURN_GENERATED_KEYS);
                    if (filasUpdate > - 1) {
                        if (autocommit == false) {
                            conexion.commit ();
                        }
                        return true;
                    }
                    else {
                        return false;
                    }
                } catch (MySQLIntegrityConstraintViolationException e) {
                    System.out.println ("Posible duplicacion de DATOS");
                    if (autocommit == false) {
                        try {
                            conexion.rollback ();
                            System.out.println ("Se ejecuto un Rollback");
                        } catch (MySQLTransactionRollbackException sqlE) {
                            System.out.println ("No se ejecuto un Rollback");
                            sqlE.printStackTrace ();
                        } catch (SQLException se) {
                            se.printStackTrace ();
                        }
                    }
                    e.printStackTrace ();
                    return false;
                } catch (MySQLNonTransientConnectionException e) {
                    if (autocommit == false) {
                        try {
                            conexion.rollback ();
                            System.out.println ("Se ejecuto un Rollback");
                        } catch (MySQLTransactionRollbackException sqlE) {
                            System.out.println ("No se ejecuto un Rollback");
                            sqlE.printStackTrace ();
                        } catch (SQLException se) {
                            se.printStackTrace ();
                        }
                    }
                    e.printStackTrace ();
                    return false;
                } catch (MySQLDataException e) {
                    System.out.println ("Datos incorrectos");
                    if (autocommit == false) {
                        try {
                            conexion.rollback ();
                            System.out.println ("Se ejecuto un Rollback");
                        } catch (MySQLTransactionRollbackException sqlE) {
                            System.out.println ("No se ejecuto un Rollback");
                            sqlE.printStackTrace ();
                        } catch (SQLException se) {
                            se.printStackTrace ();
                        }
                    }
                    return false;
                } catch (MySQLSyntaxErrorException e) {
                    System.out.println ("Error en la sintaxis de la Consulta en MySQL");
                    if (autocommit == false) {
                        try {
                            conexion.rollback ();
                            System.out.println ("Se ejecuto un Rollback");
                        } catch (MySQLTransactionRollbackException sqlE) {
                            System.out.println ("No se ejecuto un Rollback");
                            sqlE.printStackTrace ();
                        } catch (SQLException se) {
                            se.printStackTrace ();
                        }
                    }
                    return false;
                } catch (SQLException e) {
                    if (autocommit == false) {
                        try {
                            conexion.rollback ();
                            System.out.println ("Se ejecuto un Rollback");
                        } catch (MySQLTransactionRollbackException sqlE) {
                            System.out.println ("No se ejecuto un Rollback");
                            sqlE.printStackTrace ();
                        } catch (SQLException se) {
                            se.printStackTrace ();
                        }
                    }
                    e.printStackTrace ();
                    return false;
                } finally {
                    try {
                        if (st != null) {
                            if (! st.isClosed ()) {
                                st.close ();
                            }
                        }
                        if (! conexion.isClosed ()) {
                            conexion.close ();
                        }
                    } catch (NullPointerException ne) {
                        ne.printStackTrace ();
                    } catch (SQLException e) {
                        e.printStackTrace ();
                    }
                }
            }
            else {
                throw new IllegalArgumentException ("No es una instruccion Update");
            }
        }
        else {
            try {
                throw new JMySQLException ("Error Grave , notifique al departamento de Soporte Tecnico \n" + email);
            } catch (JMySQLException ex) {
                Logger.getLogger (JMySQL.class.getName ()).log (Level.SEVERE, null, ex);
                return false;
            }
        }
    }
    else {
        throw new IllegalArgumentException ("No estan permitidas las MultiConsultas en este metodo");
    }
}


public List getLockList (String virtualWiki) throws Exception {
    List all = new ArrayList ();
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        PreparedStatement stmt = conn.prepareStatement (STATEMENT_GET_LOCK_LIST);
        stmt.setString (1, virtualWiki);
        ResultSet rs = stmt.executeQuery ();
        while (rs.next ()) {
            TopicLock lock = new TopicLock (rs.getString ("virtualWiki"), rs.getString ("topic"), rs.getTimestamp ("lockat"), rs.getString ("sessionkey"));
            all.add (lock);
        }
        rs.close ();
        stmt.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return all;
}


-----Function Pair=342=-----==

public boolean updateUser (String userDocument) {
    boolean ret = false;
    DBHelper helper = null;
    PreparedStatement psRollback = null;
    try {
        helper = new DBHelper ();
        UserDocument doc = UserDocument.Factory.parse (userDocument);
        psRollback = helper.prepareStatement (SQL.rollback ());
        PreparedStatement psBegin = helper.prepareStatement (SQL.begin ());
        PreparedStatement psCommit = helper.prepareStatement (SQL.commit ());
        PreparedStatement psUpdate = helper.prepareStatement (SQL.updateUser ());
        psUpdate.setString (1, doc.getUser ().getRoleno ());
        psUpdate.setString (2, doc.getUser ().getPassword ());
        psUpdate.setString (3, doc.getUser ().getTitle ());
        psUpdate.setString (4, doc.getUser ().getName ());
        psUpdate.setString (5, doc.getUser ().getSurname ());
        psUpdate.setString (6, doc.getUser ().getTelephone ());
        psUpdate.setString (7, doc.getUser ().getCellphone ());
        psUpdate.setString (8, doc.getUser ().getHospitalno ());
        psUpdate.setString (9, doc.getUser ().getUserno ());
        psBegin.executeUpdate ();
        psUpdate.executeUpdate ();
        psCommit.executeUpdate ();
        ret = true;
    } catch (Exception e) {
        ret = false;
        try {
            if (psRollback != null) {
                psRollback.executeUpdate ();
            }
        } catch (Exception ee) {
            ee.printStackTrace ();
        }
        e.printStackTrace ();
    } finally {
        try {
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return ret;
}


public static ArrayList < Departamento > selectByOrgao (int codigo) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Departamento objDepartamento = null;
    ArrayList < Departamento > al = new ArrayList < Departamento > ();
    if (c == null) {
        return null;
    }
    try {
        String sql = "SELECT distinct d.id_departamento, d.id_orgao, d.telefone " + ", d.sala, d.nome, d.cod_depto " + "FROM departamento d " + "where d.id_orgao = ? " + "order by d.nome";
        pst = c.prepareStatement (sql);
        pst.setInt (1, codigo);
        rs = pst.executeQuery ();
        while (rs.next ()) {
            objDepartamento = new Departamento ();
            objDepartamento.setCodigo (rs.getInt ("id_departamento"));
            objDepartamento.setNome (rs.getString ("nome"));
            objDepartamento.setSala (rs.getString ("sala"));
            objDepartamento.setTelefone (rs.getString ("telefone"));
            objDepartamento.setOrgao (OrgaoDAO.selectByID (rs.getString ("id_orgao")));
            al.add (objDepartamento);
            objDepartamento = null;
        }
    } catch (SQLException e) {
        System.out.println ("[DepartamentoDAO.selectByID] Erro ao atualizar -> " + e.getMessage ());
        al = null;
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return al;
}


-----Function Pair=343=-----==

private boolean hasInDatabase (TopicArea topic) throws SQLException {
    ensureConnection ();
    PreparedStatement statement = null;
    ResultSet rs = null;
    try {
        String query = "select id from fs.topic_area where (forum = ? and name= ?";
        if (topic.getIdentifier () != null) {
            query += " and uid = ?";
        }
        query += ") or id = ?";
        statement = m_connection.prepareStatement (query);
        if (topic.getDatabaseID () == null) statement.setNull (4, Types.NUMERIC);
        else statement.setLong (4, topic.getDatabaseID ());
        statement.setString (1, topic.getForum ().getName ());
        statement.setString (2, topic.getName ());
        if (topic.getIdentifier () != null) {
            statement.setString (3, topic.getIdentifier ());
        }
        rs = statement.executeQuery ();
        if (rs.next ()) {
            long id = rs.getLong ("id");
            if (topic.getDatabaseID () == null) {
                topic.setDatabaseID (id);
            }
            else if (id != topic.getDatabaseID ()) {
                topic.setDatabaseID (id);
            }
            return true;
        }
        return false;
    } finally {
        if (null != rs) {
            try {
                rs.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


public < V extends T > Boolean remove (final V entity) {
    if (entity == null) {
        return FALSE;
    }
    Boolean success = TRUE;
    final EntityManager entityManager = getEntityManager ();
    EntityTransaction tx = null;
    try {
        tx = entityManager.getTransaction ();
        if (! tx.isActive ()) {
            tx.begin ();
        }
        final V attachedEntity = (V) entityManager.find (entity.getClass (), entity.getEntityId ());
        if (attachedEntity == null) {
            tx.commit ();
            return FALSE;
        }
        if (! entityManager.contains (attachedEntity)) {
            tx.commit ();
            return FALSE;
        }
        entityManager.remove (attachedEntity);
        log.debug (entity + " removed");
        tx.commit ();
    } catch (Exception e) {
        try {
            log.warn (entity + " NOT removed", e);
        } catch (Exception e1) {
        }
        if (tx != null && tx.isActive ()) {
            tx.rollback ();
        }
        success = FALSE;
    }
    return success;
}


-----Function Pair=344=-----==

public RestServiceResult create (RestServiceResult serviceResult, MaSyntaticError maSyntaticError) {
    MaSyntaticErrorDAO maSyntaticErrorDAO = new MaSyntaticErrorDAO ();
    try {
        maSyntaticError.setErrorId (getSequence ("sq_ma_syntatic_error"));
        EntityManagerHelper.beginTransaction ();
        maSyntaticErrorDAO.save (maSyntaticError);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSyntaticError);
        log.info ("Error sintactico creado con �xito: " + maSyntaticError.getWrongSentence ());
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el error sintactico: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nQuestionId) {
    CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionId);
    if (coQuestion == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("question.search.notFound"));
    }
    else {
        List < CoQuestion > list = new ArrayList < CoQuestion > ();
        EntityManagerHelper.refresh (coQuestion);
        list.add (coQuestion);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("question.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=345=-----==

public boolean deleteAttachments (Attachments attachments) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.delete (attachments);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public List < Imagetypes > findImagetypeByName (String name) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Imagetypes as i where i.name = ?");
        query.setParameter (0, name);
        List < Imagetypes > types = query.list ();
        tr.commit ();
        return types;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=346=-----==

public jugadorxDivxRonda getJugadorxRonda (int idJugDiv, int idRonda) {
    jugadorxDivxRonda unjxdxr = null;
    try {
        String sql = " SELECT ronda_numeroRonda, resultado, idPareoRival, color, flotante, puntajeRonda, idPareo" + " FROM jugadorxdivxronda " + " WHERE ronda_numeroRonda = " + idRonda + " AND jugadorxDivision_idJugadorxDivision = " + idJugDiv;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            unjxdxr = populateArr (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return unjxdxr;
}


public String [] getTimeToExpirationLock (String uuid) throws DatabaseException {
    PreparedStatement selectSt = null;
    String timeToExpirationLock = null;
    try {
        selectSt = getConnection ().prepareStatement (SELECT_TIME_TO_EXPIRATION_LOCK);
        selectSt.setString (1, uuid);
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            timeToExpirationLock = rs.getString ("timeToExpLock");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    String [] parsedExpTime = new String [3];
    if (timeToExpirationLock.contains (" day")) {
        String [] splitedByDays = timeToExpirationLock.split (timeToExpirationLock.contains (" days ") ? " days " : " day ");
        parsedExpTime [0] = splitedByDays [0];
        parsedExpTime [1] = splitedByDays [1];
    }
    else {
        parsedExpTime [0] = "0";
        parsedExpTime [1] = timeToExpirationLock;
    }
    String [] splitedByColon = parsedExpTime [1].split (":");
    parsedExpTime [1] = splitedByColon [0];
    parsedExpTime [2] = splitedByColon [1];
    return parsedExpTime;
}


-----Function Pair=347=-----==

public int update (BusinessObject o) throws DAOException {
    int update = 0;
    Bill bill = (Bill) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("UPDATE_BILL"));
        pst.setInt (1, bill.getId ());
        update = pst.executeUpdate ();
        if (update <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (update > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return update;
}


public void testBasicIncompleteQuery () {
    try {
        EntityManager em = getEM ();
        EntityTransaction tx = em.getTransaction ();
        try {
            tx.begin ();
            Person p = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
            em.persist (p);
            em.createQuery ("SELECT T FROM " + Person.class.getName ()).getResultList ();
            fail ("should have thrown an exception");
        } catch (PersistenceException e) {
        } finally {
            if (tx.isActive ()) {
                tx.rollback ();
            }
            em.close ();
        }
    } finally {
        clean (Person.class);
    }
}


-----Function Pair=348=-----==

public void update (Run nu) {
    Session ssn = this.getSession (false);
    Query sql = null;
    Transaction tx = ssn.getTransaction ();
    if (tx == null || ! tx.isActive ()) tx = ssn.beginTransaction ();
    sql = ssn.createSQLQuery ("update	experiment" + "	set	name			= :name," + "		description		= :description," + "		cycles			= :cycles," + "		ref_lane		= :ref_lane" + " " + "where experiment_id	= :experiment_id");
    Integer ref_lane = nu.getRefLane ();
    if (ref_lane == null) {
        ref_lane = new Integer (1);
    }
    sql.setParameter ("name", nu.getName ());
    sql.setParameter ("description", nu.getDescription ());
    sql.setParameter ("cycles", nu.getCycles ());
    sql.setParameter ("ref_lane", ref_lane, Hibernate.INTEGER);
    sql.setParameter ("experiment_id", nu.getRunId (), Hibernate.INTEGER);
    if (sql.executeUpdate () != 1) {
        tx.rollback ();
    }
    else {
        ArrayList < Lane > lanes = new ArrayList (8);
        if (nu.getLane1 () != null) lanes.add (nu.getLane1 ());
        if (nu.getLane2 () != null) lanes.add (nu.getLane2 ());
        if (nu.getLane3 () != null) lanes.add (nu.getLane3 ());
        if (nu.getLane4 () != null) lanes.add (nu.getLane4 ());
        if (nu.getLane5 () != null) lanes.add (nu.getLane5 ());
        if (nu.getLane6 () != null) lanes.add (nu.getLane6 ());
        if (nu.getLane7 () != null) lanes.add (nu.getLane7 ());
        if (nu.getLane8 () != null) lanes.add (nu.getLane8 ());
        sql = ssn.createSQLQuery ("update	lane" + "	set	name			= :name," + "		organism		= :organism," + "		description		= :description," + "		tags			= :tags," + "		regions			= :regions," + "		skip			= :skip," + "		sample_name		= :sample_name," + "		sample_code		= :sample_code," + "		sample_type		= :sample_type," + "		experiment_id	= :experiment_id " + "where lane_id			= :lane_id " + "  and	(experiment_id		is null " + "		or experiment_id	= :experiment_id)");
        for (Lane lane : lanes) {
            sql.setParameter ("name", lane.getName ());
            sql.setParameter ("organism", lane.getOrganism ());
            sql.setParameter ("description", lane.getDescription ());
            sql.setParameter ("tags", lane.getTags ());
            sql.setParameter ("regions", lane.getRegions ());
            sql.setParameter ("skip", lane.getSkip ());
            sql.setParameter ("sample_name", lane.getSampleName ());
            sql.setParameter ("sample_code", lane.getSampleCode ());
            sql.setParameter ("sample_type", lane.getSampleType ());
            sql.setParameter ("experiment_id", nu.getRunId (), Hibernate.INTEGER);
            sql.setParameter ("lane_id", lane.getLaneId ());
            if (sql.executeUpdate () != 1) {
                tx.rollback ();
                if (! tx.isActive ()) tx.begin ();
                return;
            }
        }
        tx.commit ();
    }
    if (! tx.isActive ()) tx.begin ();
}


public int deleteObject (String name, String filter) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String q = "delete from " + name + " P ";
        if (filter != null) {
            q = q + " where P." + filter;
        }
        Query query = s.createQuery (q);
        int ret = query.executeUpdate ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=349=-----==

public static int getPhotoCount (SiteBean site, SessionUserObject user, int album_id, int month_stamp, int date) {
    boolean is_owner = site.isOwner (user);
    StringBuffer hql = new StringBuffer ("SELECT COUNT(*) FROM PhotoBean AS p WHERE p.site.id=:site");
    if (album_id > 0) hql.append (" AND p.album.id=:album");
    if (month_stamp > 190000 && month_stamp < 209912) {
        hql.append (" AND p.year=:year AND p.month=:month");
    }
    if (! is_owner) {
        hql.append (" AND p.status=:normal_status AND p.album.type=:public_album");
    }
    if (date > 0) {
        hql.append (" AND p.date=:date");
    }
    Session ssn = getSession ();
    try {
        Query q = ssn.createQuery (hql.toString ());
        q.setInteger ("site", site.getId ());
        if (album_id > 0) q.setInteger ("album", album_id);
        if (month_stamp > 190000 && month_stamp < 209912) {
            q.setInteger ("year", month_stamp / 100);
            q.setInteger ("month", month_stamp % 100);
        }
        if (! is_owner) {
            q.setInteger ("normal_status", PhotoBean.STATUS_NORMAL);
            q.setInteger ("public_album", AlbumBean.TYPE_PUBLIC);
        }
        if (date > 0) {
            q.setInteger ("date", date);
        }
        return ((Number) q.uniqueResult ()).intValue ();
    } finally {
        hql = null;
    }
}


public Integer updateDisplayorderIcons (List < Smilies > list) {
    int updateNumber = 0;
    if (list == null && list.size () <= 0) return updateNumber;
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        for (int i = 0; i < list.size (); i ++) {
            Smilies s = list.get (i);
            if (s != null) {
                Query query = session.createQuery ("update Smilies as s set s.displayorder = :displayorder  where s.id=:id");
                query.setShort ("displayorder", s.getDisplayorder ());
                query.setShort ("id", s.getId ());
                updateNumber += query.executeUpdate ();
            }
        }
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
    }
    return updateNumber;
}


-----Function Pair=350=-----==

public static void querywithfetchplan (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        ReadAllQuery raq = (ReadAllQuery) ((JpaQuery) query).getDatabaseQuery ();
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends"));
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends").anyOfAllowingNone ("friends"));
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getFriends ()) {
                System.out.println ("\twith friend: " + person1);
                for (Person person2 : person1.getFriends ()) {
                    System.out.println ("\t\twith friend: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


public boolean deleteImcompleteCartsClient (String mailClient) {
    Connection conexion = null;
    PreparedStatement deleteHistorialCarros = null;
    PreparedStatement deleteProdCarro = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        conexion.setAutoCommit (false);
        ArrayList < String > carrosIncompletos = this.requestIncompleteCarts (mailClient);
        if (carrosIncompletos != null) {
            deleteHistorialCarros = conexion.prepareStatement ("DELETE FROM " + nameBD + ".HistorialCarritos WHERE CodigoCarrito=?");
            deleteProdCarro = conexion.prepareStatement ("DELETE FROM " + nameBD + ".Carritos WHERE CodigoCarrito=?");
            for (int i = 0; i < carrosIncompletos.size (); i ++) {
                deleteHistorialCarros.setString (1, carrosIncompletos.get (i));
                deleteHistorialCarros.execute ();
                deleteHistorialCarros.clearParameters ();
                deleteProdCarro.setString (1, carrosIncompletos.get (i));
                deleteProdCarro.execute ();
                deleteProdCarro.clearParameters ();
            }
        }
        conexion.commit ();
        exito = true;
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error borrando los carritos incompletos de un usuario", ex);
        try {
            conexion.rollback ();
        } catch (SQLException ex1) {
            logger.log (Level.SEVERE, "Error haciendo rollback de la transacción para borrar carros incompletos de un usuario", ex1);
        }
    } finally {
        cerrarConexionYStatement (conexion, deleteHistorialCarros, deleteProdCarro);
    }
    return exito;
}


-----Function Pair=351=-----==

public ArrayList getAllMsg (String name, String group) {
    System.out.println ("Getting mail for user: " + name + ",Group: " + group);
    ArrayList aList = new ArrayList ();
    mail mail = null;
    PreparedStatement pstmt;
    try {
        pstmt = getCon ().prepareStatement ("select * from mail where toid = ? and gname = ?");
        pstmt.setString (1, name);
        pstmt.setString (2, group);
        ResultSet rs = pstmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                mail = new mail (rs.getInt ("pmid"), rs.getString ("title"), rs.getString ("fromid"), rs.getString ("stat"), rs.getString ("pmdatetime"));
                aList.add (mail);
            }
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return aList;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=352=-----==

public task retrieveByTask_id (int task_id) {
    task t = null;
    try {
        String query = "Select * from task where task_id = ?";
        PreparedStatement stmt = getCon ().prepareStatement (query);
        stmt.setInt (1, task_id);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                t = new task (rs.getInt ("task_id"), rs.getString ("task_name"), rs.getString ("task_endTime"), rs.getString ("task_endDate"), rs.getString ("task_status"), rs.getString ("task_description"), rs.getString ("group_name"));
            }
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return t;
}


public RestServiceResult delete (RestServiceResult serviceResult, CoMultipleChoiceE1 coMultipleChoiceE1) {
    String sMultipleChoiceE1Name = null;
    try {
        sMultipleChoiceE1Name = coMultipleChoiceE1.getMultipleChoiceName ();
        log.error ("Eliminando la pregunta de seleccion: " + coMultipleChoiceE1.getMultipleChoiceName ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_MULTIPLE_CHOICE_E1);
        query.setParameter (1, coMultipleChoiceE1.getMultipleChoiceE1Id ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMultipleChoiceE1);
        Object [] arrayParam = {sMultipleChoiceE1Name};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.delete.success"), arrayParam));
        log.info ("Eliminando la pregunta de seleccion: " + coMultipleChoiceE1.getMultipleChoiceName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la pregunta de seleccion: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {coMultipleChoiceE1.getMultipleChoiceName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=353=-----==

public ArrayList getAllAnnouncement (String gname) {
    ArrayList aList = new ArrayList ();
    announcement ann;
    try {
        PreparedStatement pstmt = getCon ().prepareStatement ("select * from announcement where gname = ?");
        pstmt.setString (1, gname);
        ResultSet rs = pstmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                ann = new announcement ();
                ann.setAid (rs.getInt ("aid"));
                ann.setUid (rs.getInt ("uid"));
                ann.setPdatetime (rs.getTimestamp ("pdatetime").toString ());
                ann.setTitle (rs.getString ("title"));
                ann.setContent (rs.getString ("content"));
                ann.setStat (rs.getString ("stat"));
                ann.setGname (rs.getString ("gname"));
                aList.add (ann);
            }
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return aList;
}


private boolean displayResults () {
    setMessage ("Preparing data for display");
    int fileRecordCount = fileMenus.size () + fileFieldTypes.size () + fileRecordTypes.size ();
    int databaseRecordCount = databaseMenus.size () + databaseFieldTypes.size () + databaseRecordTypes.size ();
    ArrayList fileRecords = new ArrayList (fileRecordCount);
    fileRecords.addAll (fileMenus.values ());
    fileRecords.addAll (fileFieldTypes);
    fileRecords.addAll (fileRecordTypes.values ());
    ArrayList databaseRecords = new ArrayList (databaseRecordCount);
    databaseRecords.addAll (databaseMenus.values ());
    databaseRecords.addAll (databaseFieldTypes);
    databaseRecords.addAll (databaseRecordTypes.values ());
    if (resultDialog == null) {
        resultDialog = new DBDImportResultsDialog (getMainWindow (), "Import Results", true);
        resultDialog.setApplicationProperties (getApplicationProperties ());
        resultDialog.center ();
    }
    resultDialog.setFileData (fileRecords, invalidFieldTypes);
    resultDialog.setDatabaseData (databaseRecords);
    try {
        SwingUtilities.invokeAndWait (new Runnable () {
            public void run () {
                resultDialog.setVisible (true);
            }
        }
        );
    } catch (java.lang.reflect.InvocationTargetException ex) {
        ex.printStackTrace ();
    } catch (java.lang.InterruptedException ex) {
        ex.printStackTrace ();
    }
    return resultDialog.getResult () == ImportResultsDialog.OK;
}


-----Function Pair=354=-----==

public static boolean delete (String codigo) {
    int result = 0;
    Connection c = DBConnection.getConnection ();
    Statement st = null;
    if (c == null) {
        return false;
    }
    try {
        st = c.createStatement ();
        String sql = "delete from funcionario where id_funcionario = " + codigo;
        result = st.executeUpdate (sql);
    } catch (SQLException e) {
        System.out.println ("[FuncionarioDAO.delete] Erro ao deletar -> " + e.getMessage ());
    } finally {
        DBConnection.closeStatement (st);
        DBConnection.closeConnection (c);
    }
    if (result > 0) return true;
    else return false;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nMultipleChoiceE3Id) {
    CoMultipleChoiceE3 coMultipleChoiceE3 = new CoMultipleChoiceE3DAO ().findById (nMultipleChoiceE3Id);
    if (coMultipleChoiceE3 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        List < CoMultipleChoiceE3 > list = new ArrayList < CoMultipleChoiceE3 > ();
        EntityManagerHelper.refresh (coMultipleChoiceE3);
        list.add (coMultipleChoiceE3);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=355=-----==

public static void updateHtmlLocation (String module_id, String html_location) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        boolean found = false;
        {
            sql = "SELECT module_id FROM module_htmlcontainer WHERE module_id = '" + module_id + "' ";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (found) sql = "UPDATE module_htmlcontainer SET html_url = '" + html_location + "' WHERE module_id = '" + module_id + "' ";
        else sql = "INSERT INTO module_htmlcontainer (module_id, html_url) VALUES ('" + module_id + "', '" + html_location + "')";
        stmt.executeUpdate (sql);
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public void testStaleNonVersionedInstanceFoundOnLock () {
    if (! readCommittedIsolationMaintained ("repeatable read tests")) {
        return;
    }
    if (getDialect ().doesReadCommittedCauseWritersToBlockReaders ()) {
        reportSkip ("lock blocking", "stale versioned instance");
        return;
    }
    String check = "Lock Modes";
    Session s1 = getSessions ().openSession ();
    Transaction t1 = s1.beginTransaction ();
    Part part = new Part (new Item ("EJB3 Specification"), check, "3.3.5.3", new BigDecimal (0.0));
    s1.save (part);
    t1.commit ();
    s1.close ();
    Long partId = part.getId ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    part = (Part) s1.get (Part.class, partId);
    Session s2 = getSessions ().openSession ();
    Transaction t2 = s2.beginTransaction ();
    Part part2 = (Part) s2.get (Part.class, partId);
    part2.setName ("Lock Mode Types");
    t2.commit ();
    s2.close ();
    s1.lock (part, LockMode.READ);
    part2 = (Part) s1.get (Part.class, partId);
    assertTrue (part == part2);
    assertEquals ("encountered non-repeatable read", check, part2.getName ());
    try {
        s1.lock (part, LockMode.UPGRADE);
    } catch (Throwable t) {
        t1.rollback ();
        t1 = s1.beginTransaction ();
    }
    part2 = (Part) s1.get (Part.class, partId);
    assertTrue (part == part2);
    assertEquals ("encountered non-repeatable read", check, part2.getName ());
    t1.commit ();
    s1.close ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    s1.delete (part);
    s1.delete (part.getItem ());
    t1.commit ();
    s1.close ();
}


-----Function Pair=356=-----==

public static void updateXMLData (String module_id, String xml, String xsl) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        boolean found = false;
        {
            sql = "SELECT module_id FROM xml_module WHERE module_id = '" + module_id + "' ";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (found) sql = "UPDATE xml_module SET xml = '" + xml + "', xsl = '" + xsl + "' WHERE module_id = '" + module_id + "' ";
        else sql = "INSERT INTO xml_module (module_id, xml, xsl) VALUES ('" + module_id + "', '" + xml + "', '" + xsl + "')";
        stmt.executeUpdate (sql);
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public boolean lockDigitalObject (String uuid, Long id, String description) throws DatabaseException {
    PreparedStatement updateSt = null;
    boolean successful = false;
    try {
        if (id != null) {
            updateSt = getConnection ().prepareStatement (INSERT_NEW_DIGITAL_OBJECTS_LOCK);
            updateSt.setString (1, uuid);
            updateSt.setString (2, description);
            updateSt.setLong (3, id);
        }
        else {
            updateSt = getConnection ().prepareStatement (UPDATE_DIGITAL_OBJECTS_TIMESTAMP_DESCRIPTION);
            updateSt.setString (1, description);
            updateSt.setString (2, uuid);
        }
    } catch (SQLException e) {
        LOGGER.error ("Could not get insert statement", e);
    } finally {
        closeConnection ();
    }
    int modified = 0;
    try {
        modified = updateSt.executeUpdate ();
        if (modified == 1) {
            getConnection ().commit ();
            LOGGER.debug ("DB has been updated. Queries: \"" + updateSt + "\"");
            successful = true;
        }
        else {
            getConnection ().rollback ();
            LOGGER.error ("DB has not been updated -> rollback! Queries: \"" + updateSt + "\"");
            successful = false;
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + updateSt, e);
    } finally {
        closeConnection ();
    }
    return successful;
}


-----Function Pair=357=-----==

public static void assignRoles (String module_id, String [] roles) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        sql = "DELETE FROM role_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        for (int i = 0; i < roles.length; i ++) {
            sql = "INSERT INTO role_module (module_id, user_role) VALUES ('" + module_id + "', '" + roles [i] + "')";
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public void testStaleVersionedInstanceFoundInQueryResult () {
    if (getDialect ().doesReadCommittedCauseWritersToBlockReaders ()) {
        reportSkip ("lock blocking", "stale versioned instance");
        return;
    }
    String check = "EJB3 Specification";
    Session s1 = getSessions ().openSession ();
    Transaction t1 = s1.beginTransaction ();
    Item item = new Item (check);
    s1.save (item);
    t1.commit ();
    s1.close ();
    Long itemId = item.getId ();
    long initialVersion = item.getVersion ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    item = (Item) s1.get (Item.class, itemId);
    Session s2 = getSessions ().openSession ();
    Transaction t2 = s2.beginTransaction ();
    Item item2 = (Item) s2.get (Item.class, itemId);
    item2.setName ("EJB3 Persistence Spec");
    t2.commit ();
    s2.close ();
    item2 = (Item) s1.createQuery ("select i from Item i").list ().get (0);
    assertTrue (item == item2);
    assertEquals ("encountered non-repeatable read", check, item2.getName ());
    assertEquals ("encountered non-repeatable read", initialVersion, item2.getVersion ());
    t1.commit ();
    s1.close ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    s1.createQuery ("delete Item").executeUpdate ();
    t1.commit ();
    s1.close ();
}


-----Function Pair=358=-----==

public void createScoredAnnouncement (CoScoreExercises2 coScoreExercises2) {
    String sExerciseName = coScoreExercises2.getCoExercises2 ().getExerciseName ();
    Long nUserId = coScoreExercises2.getMaUser ().getUserId ();
    String sUserName = coScoreExercises2.getMaUser ().getUserName ();
    Float nScore = new Float (coScoreExercises2.getScore ());
    String sScore = "";
    String sDate = Util.parseToLocalDate (new Date ());
    Long nAnnouncemntType = Constant.SCORED_EXERCISE;
    String sFlagScoreType = coScoreExercises2.getCoExercises2 ().getFlagScoreType ();
    if (sFlagScoreType.equals ("0")) {
        sScore = nScore.toString ();
    }
    else if (sFlagScoreType.equals ("1")) {
        if (nScore.equals (Common.EXCELLENT)) {
            sScore = "excelente";
        }
        else if (nScore.equals (Common.VERY_GOOD)) {
            sScore = "muy bien";
        }
        else if (nScore.equals (Common.GOOD)) {
            sScore = "bien";
        }
        else if (nScore.equals (Common.NEEDS_IMPROVEMENT)) {
            sScore = "necesita mejorar";
        }
        else {
            sScore = "inaceptable";
        }
    }
    Announcement announcement = UtilAnnouncement.buildAnnouncementForType (sExerciseName, sUserName, sScore, sDate, nAnnouncemntType, bundle);
    createAndSendAnnouncementForUser (announcement, nUserId, nAnnouncemntType);
}


private void processUpdateParams (PreparedStatement ps, Object obj) throws Exception {
    Class < ? extends Object > clses = obj.getClass ();
    PojoParser pojo = PojoParser.getInstances ();
    List < String > cols = pojo.getColsName (cls);
    List < String > types = pojo.getColsType (cls);
    for (int i = 0; i < cols.size (); ++ i) {
        Method m = clses.getMethod ("get" + SqlUtil.getFieldName (cols.get (i)), new Class [] {});
        Object value = m.invoke (obj, new Object [] {});
        if (types.get (i).equals ("long")) {
            ps.setLong (i + 1, (Long) value);
        }
        else if (types.get (i).equals ("string")) {
            ps.setString (i + 1, (String) value);
        }
        else if (types.get (i).equals ("date")) {
            if (value != null) ps.setTimestamp (i + 1, new java.sql.Timestamp (((Date) value).getTime ()));
            else ps.setTimestamp (i + 1, null);
        }
        else {
            ps.setDouble (i + 1, (Double) value);
        }
    }
    Object value = clses.getMethod ("get" + SqlUtil.getFieldName (pojo.getPriamryKey (cls)), new Class [] {}).invoke (obj, new Object [] {});
    if (pojo.getPriamryType (cls).equals ("long")) {
        ps.setLong (cols.size () + 1, ((Long) value).longValue ());
    }
    else {
        ps.setString (cols.size () + 1, (String) value);
    }
}


-----Function Pair=359=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public boolean addAccountCategory (AccountCategory c) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        if (c.getCategoryId () == null) {
            long id = IDGenerator.getInstance ().generateId (s);
            c.setCategoryId (id);
        }
        java.io.Serializable ret = s.save (c);
        System.out.println (c.getCategoryId () + ":" + c.getCategoryName () + " %% ");
        s.getTransaction ().commit ();
        return ret != null;
    } catch (Exception e) {
        s.getTransaction ().rollback ();
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=360=-----==

public void testResultSet0045 () throws Exception {
    try {
        Connection cx = getConnection ();
        Statement stmt = cx.createStatement ();
        ResultSet rs = stmt.executeQuery ("select 1");
        assertNotNull (rs);
        assertTrue ("Expected a result set", rs.next ());
        rs.getInt (1);
        assertTrue ("Expected no result set", ! rs.next ());
        rs.getInt (1);
        assertTrue ("Did not expect to reach here", false);
    } catch (java.sql.SQLException e) {
        assertTrue (e.getMessage ().startsWith ("No current row in the result set"));
    }
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=361=-----==

protected void fastDeleteItemsByID (long [] ids) {
    log.debug ("fastDeleteItemsByID entered");
    if (ids == null || ids.length == 0) {
        log.debug ("fastDeleteItemsByID exited (list empty)");
        return;
    }
    synchronized (session) {
        log.debug ("start delete " + ids.length + " items");
        Transaction tx = session.beginTransaction ();
        try {
            int currentIndex = 0;
            while (currentIndex < ids.length) {
                int nextGroup = Math.min (ids.length - currentIndex, 1000);
                StringBuilder sb = new StringBuilder ("delete from Learning_Filter_Item where id in (");
                for (int i = 0; i < nextGroup; i ++) {
                    sb.append (ids [currentIndex + i]).append (',');
                }
                sb.setCharAt (sb.length () - 1, ')');
                Query query = session.createSQLQuery (sb.toString ()).setCacheable (false);
                query.executeUpdate ();
                currentIndex += nextGroup;
            }
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in fastDeleteItems: ", e);
            tx.rollback ();
        }
        log.debug ("delete finished");
        maxHamOccurences = - 1;
        maxSpamOccurences = - 1;
        session.flush ();
        session.clear ();
        cache.resetCache ();
    }
    fireDataChange (PART.ITEMS);
    log.debug ("fastDeleteItemsByID exited");
}


public void modify (ModifyInterceptorChain chain, DistinguishedName dn, ArrayList < LDAPModification > mods, LDAPConstraints constraints) throws LDAPException {
    Connection con = (Connection) chain.getRequest ().get (JdbcInsert.MYVD_DB_CON + this.dbInsertName);
    if (con == null) {
        throw new LDAPException ("Operations Error", LDAPException.OPERATIONS_ERROR, "No Database Connection");
    }
    if (! chain.getRequest ().containsKey (DBAddOnModify.ADD_OR_MOD_FLAG) || chain.getRequest ().get (DBAddOnModify.ADD_OR_MOD_FLAG).equals (MOD_FLAG)) {
        modifyEntry (chain, dn, mods, con);
    }
    else {
        LDAPAttributeSet attribs = new LDAPAttributeSet ();
        HashMap < String, String > ldap2db = (HashMap < String, String >) chain.getRequest ().get (JdbcInsert.MYVD_DB_LDAP2DB + this.dbInsertName);
        HashMap < String, String > db2ldap = (HashMap < String, String >) chain.getRequest ().get (JdbcInsert.MYVD_DB_DB2LDAP + this.dbInsertName);
        Iterator < LDAPModification > it = mods.iterator ();
        while (it.hasNext ()) {
            LDAPModification mod = it.next ();
            attribs.add (new LDAPAttribute (mod.getAttribute ().getName (), mod.getAttribute ().getStringValue ()));
        }
        try {
            int id = this.insertRecord (attribs, con, db2ldap, null, true);
            chain.getRequest ().put (DB_ADD_ON_MOD_ID + this.name, id);
        } catch (SQLException e) {
            try {
                con.rollback ();
            } catch (SQLException e1) {
                throw new LDAPException ("Could not delete entry or rollback transaction", LDAPException.OPERATIONS_ERROR, e.toString (), e);
            }
            throw new LDAPException ("Could not delete entry", LDAPException.OPERATIONS_ERROR, e.toString (), e);
        }
    }
}


-----Function Pair=362=-----==

private void eliminar060 () throws Exception {
    Connection conn = null;
    PreparedStatement ps = null;
    int actualizados = 0;
    try {
        conn = ToolsBD.getConn ();
        String sentenciaSql = "DELETE FROM BZENTRA060  WHERE ENT_ANY=? AND ENT_OFI=? AND ENT_NUM=?";
        ps = conn.prepareStatement (sentenciaSql);
        ps.setString (1, anoEntrada);
        ps.setString (2, oficina);
        ps.setString (3, numeroEntrada);
        actualizados = ps.executeUpdate ();
        if (actualizados != 0) {
            System.out.println ("Municipi 060 eliminat:" + municipi060);
        }
        else {
            System.out.println ("Res per eliminar.");
        }
    } catch (Exception e) {
        throw e;
    } finally {
        ToolsBD.closeConn (conn, ps, null);
    }
}


public void insert (String [] power) {
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        String sql = "";
        sql = "select * from userinfo where role_id = ?";
        conn.prepare (sql);
        conn.setString (1, getId ());
        DbRs rs = conn.executeQuery ();
        if (rs != null && rs.size () > 0) {
            setErr ("此角色已经存在！");
            return;
        }
        conn.setAutoCommit (false);
        sql = "insert into roleinfo (role_id,role_name,show_order,role_desc)" + " values (?,?,?,?)";
        conn.prepare (sql);
        conn.setString (1, getId ());
        conn.setString (2, getRoleName ());
        conn.setInt (3, getShowOrder ());
        conn.setString (4, getRoleDesc ());
        conn.executeUpdate ();
        if (power != null && power.length > 0) {
            for (int i = 0; i < power.length; i ++) {
                sql = "insert into rolepower (role_id,power_id) values (" + "?,?)";
                conn.prepare (sql);
                conn.setString (1, getId ());
                conn.setString (2, power [i]);
                conn.executeUpdate ();
            }
        }
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception subEx) {
            subEx.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=363=-----==

private void savePeriod (String schema_code, Vector periods, Statement stmt, SQLRenderer r, String sql) throws SQLException, Exception {
    for (int i = 0; i < periods.size (); i ++) {
        Period period = (Period) periods.elementAt (i);
        Period parent = period.getParent ();
        String parent_id = "0";
        String parent_name = "";
        if (parent != null) {
            parent_id = parent.getId ();
            parent_name = parent.getName ();
        }
        else {
            period.setSequence (i + 1);
        }
        r.clear ();
        r.add ("period_root_id", schema_code);
        r.add ("period_id", period.getId ());
        r.add ("parent_id", parent_id);
        r.add ("period_level", period.getLevel ());
        r.add ("period_sequence", period.getSequence ());
        r.add ("period_name", period.getName ());
        sql = r.getSQLInsert ("period");
        stmt.executeUpdate (sql);
        if (period.hasChild ()) {
            savePeriod (schema_code, period.getChild (), stmt, r, sql);
        }
    }
}


public boolean saveRequest (String fechaHora, String requestedURL, String remoteAddr, String remoteHost, String method, String param, String userAgent) {
    Connection conexion = null;
    PreparedStatement insert = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        insert = conexion.prepareStatement ("INSERT INTO " + nameBD + ".Log VALUES (?,?,?,?,?,?,?)");
        insert.setString (1, fechaHora);
        insert.setString (2, requestedURL);
        insert.setString (3, remoteAddr);
        insert.setString (4, remoteHost);
        insert.setString (5, method);
        insert.setString (6, param);
        insert.setString (7, userAgent);
        int filasAfectadas = insert.executeUpdate ();
        if (filasAfectadas == 1) {
            exito = true;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error guardando log de petición", ex);
    } finally {
        cerrarConexionYStatement (conexion, insert);
    }
    return exito;
}


-----Function Pair=364=-----==

public User getUserByEMail (DatabaseAdapter db, String eMail) {
    if (eMail == null) {
        return null;
    }
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        String sql = "select a.ID_USER,a.ID_FIRM,a.FIRST_NAME,a.MIDDLE_NAME,a.LAST_NAME, " + "       a.DATE_START_WORK,a.DATE_FIRE,a.ADDRESS,a.TELEPHONE,a.EMAIL, a.IS_DELETED " + "from   WM_LIST_USER a " + "where  a.EMAIL=?";
        ps = db.prepareStatement (sql);
        ps.setString (1, eMail);
        rs = ps.executeQuery ();
        UserBean beanPortal = null;
        if (rs.next ()) {
            beanPortal = loadPortalUserFromResultSet (rs);
        }
        return beanPortal;
    } catch (Exception e) {
        String es = "Error search user for e-mail: " + eMail;
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


private void oraclePrepUpdateNullClob (JDBCDataObject baseObject, String fieldName, DBConnection theConnection) throws DataException {
    try {
        String whereClause = JDBCUtil.getInstance ().buildWhereClause (baseObject, false);
        FastStringBuffer prepStatement = FastStringBuffer.getInstance ();
        String theSQL = null;
        try {
            prepStatement.append ("UPDATE ");
            prepStatement.append (baseObject.getJDBCMetaData ().getTargetTable ());
            prepStatement.append (" SET ");
            prepStatement.append (fieldName);
            prepStatement.append (" = null ");
            prepStatement.append (whereClause);
            theSQL = prepStatement.toString ();
        } finally {
            prepStatement.release ();
            prepStatement = null;
        }
        theConnection.createPreparedStatement (theSQL);
        finalizeUpdate (theConnection);
    } catch (DBException ex) {
        throw new DataException ("Error prepping CLOB update", ex);
    }
}


-----Function Pair=365=-----==

public void save (Connection conn, boolean commit) throws SQLException {
    PreparedStatement stmt = null;
    if (! isValid ()) {
        String errorMessage = "Unable to save invalid DAO '" + getClass ().getName () + "'!";
        if (log.isErrorEnabled ()) {
            log.error (errorMessage);
        }
        throw new SQLException (errorMessage);
    }
    try {
        if (isNew ()) {
            primaryKey = createNewPrimaryKey ();
            stmt = conn.prepareStatement (getInsertSql ());
        }
        else {
            stmt = conn.prepareStatement (getUpdateSql ());
        }
        setValues (stmt);
        int rowCount = stmt.executeUpdate ();
        if (rowCount != 1) {
            primaryKey = OvUuid.NULL_UUID;
            if (commit) {
                conn.rollback ();
            }
            String errorMessage = "Invalid number of rows changed!";
            if (log.isErrorEnabled ()) {
                log.error (errorMessage);
            }
            throw new SQLException (errorMessage);
        }
        else {
            if (commit) {
                conn.commit ();
            }
        }
    } finally {
        OvJdbcUtils.closeStatement (stmt);
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=366=-----==

public GroupType findByLabel (String groupTypeLabel) throws DBConnectionException, SelectException {
    GroupType grpType = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("GROUP_TYPE_LABEL", groupTypeLabel);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            grpType = new GroupType ();
            while (result.next ()) {
                grpType.setId (result.getInt ("GROUP_TYPE_ID"));
                grpType.setLabel (result.getString ("GROUP_TYPE_LABEL"));
            }
        }
        else {
            throw new SelectException (TABLE_NAME + " Can't retieve record");
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return grpType;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=367=-----==

public boolean insertUserGroup (Usergroups userGroup) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.save (userGroup);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public String checarSitrevEstagio1234 (final Vector < Vector < Object > > vexped, Vector < Vector < Object > > vatend) {
    String result = (String) EstagioCheck.EPE.getValue ();
    for (Vector < Object > row : vexped) {
        result = (String) row.elementAt (EColExped.SITREVEXPED.ordinal ());
        if (EstagioCheck.EPE.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.EPE.getValue ();
        }
        else if (EstagioCheck.E1O.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E1O.getValue ();
        }
        else if (EstagioCheck.E2O.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E2O.getValue ();
        }
        else if (EstagioCheck.E1I.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E1I.getValue ();
            break;
        }
        else if (EstagioCheck.E2I.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E2I.getValue ();
            break;
        }
    }
    if (result.substring (2).equals ("O")) {
        for (Vector < Object > row : vatend) {
            result = (String) row.elementAt (EColAtend.SITREVATENDO.ordinal ());
            if (EstagioCheck.EPE.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.EPE.getValue ();
            }
            else if (EstagioCheck.E3O.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E3O.getValue ();
            }
            else if (EstagioCheck.E3I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E3I.getValue ();
                break;
            }
            else if (EstagioCheck.E4O.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E4O.getValue ();
            }
            else if (EstagioCheck.E4I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E4I.getValue ();
                break;
            }
            else if (EstagioCheck.E5I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E5I.getValue ();
                break;
            }
        }
    }
    return result;
}


-----Function Pair=368=-----==

public void testCache () throws Exception {
    Session s;
    Transaction tx;
    s = openSession ();
    tx = s.beginTransaction ();
    ZipCode zc = new ZipCode ();
    zc.code = "92400";
    s.persist (zc);
    tx.commit ();
    s.close ();
    getSessions ().getStatistics ().clear ();
    getSessions ().getStatistics ().setStatisticsEnabled (true);
    getSessions ().evict (ZipCode.class);
    s = openSession ();
    tx = s.beginTransaction ();
    s.get (ZipCode.class, zc.code);
    assertEquals (1, getSessions ().getStatistics ().getSecondLevelCachePutCount ());
    tx.commit ();
    s.close ();
    s = openSession ();
    tx = s.beginTransaction ();
    s.get (ZipCode.class, zc.code);
    assertEquals (1, getSessions ().getStatistics ().getSecondLevelCacheHitCount ());
    tx.commit ();
    s.close ();
}


private static boolean execute (String query) throws SQLException {
    boolean success = true;
    try {
        PreparedStatement stm = con.prepareStatement (query);
        stm.executeUpdate ();
        stm.close ();
        con.commit ();
    } catch (SQLException e) {
        try {
            con.rollback ();
        } catch (Exception rbex) {
            rbex.printStackTrace ();
        }
        success = false;
        throw e;
    }
    return success;
}


-----Function Pair=369=-----==

public RestServiceResult listPageNoSolveMChoiceForExercise3 (RestServiceResult serviceResult, Long nQuestionId, Long nUserId, int nRowStart, int nMaxResults) {
    CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionId);
    log.info ("Entro en el datamanager y el id de la pregunta es: " + nQuestionId);
    EntityManagerHelper.refresh (coQuestion);
    if (coQuestion == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_MULTIPLE_CHOICE_IN_QUESTION_2, CoMultipleChoiceE3.class);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        query.setParameter (1, nQuestionId);
        query.setParameter (2, nUserId);
        if (nRowStart > 0) query.setFirstResult (nRowStart);
        if (nMaxResults > 0) query.setMaxResults (nMaxResults);
        List < CoMultipleChoiceE3 > list = query.getResultList ();
        if (list.size () == 0) {
            Object [] arrayParam = {coQuestion.getQuestionName ()};
            serviceResult.setError (true);
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE3.notFound"), arrayParam));
            serviceResult.setNumResult (list.size ());
        }
        else {
            Object [] arrayParam = {list.size (), coQuestion.getQuestionName ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE3.success"), arrayParam));
            serviceResult.setObjResult (list);
            if ((nRowStart > 0) || (nMaxResults > 0)) {
                RestServiceResult serviceResult2 = listPageNoSolveMChoiceForExercise3 (new RestServiceResult (), nQuestionId, nUserId);
                int nNumMultipleChoice = serviceResult2.getNumResult ();
                serviceResult.setNumResult (nNumMultipleChoice);
            }
            else serviceResult.setNumResult (list.size ());
        }
    }
    return serviceResult;
}


void recalcCostoLin () {
    int nRow = jtLin.getRowCount ();
    double totCosto = deo_prcostE.getValorDec () * deo_kilosE.getValorDec ();
    double totFin = 0;
    deo_prcabE.setValorDec (totCosto);
    totCosto = 0;
    boolean swDesBloq = false;
    for (int n = 0; n < nRow; n ++) {
        if (! jtLin.getValBoolean (n, 7) && jtLin.getValorDec (n, 4) > 0) swDesBloq = true;
        totCosto += (jtLin.getValorDec (n, 4) * jtLin.getValorDec (n, 3));
    }
    if (! swDesBloq) {
        for (int n = 0; n < nRow; n ++) {
            jtLin.setValor ("" + jtLin.getValorDec (n, 4), n, 5);
            totFin += jtLin.getValorDec (n, 4) * jtLin.getValorDec (n, 3);
        }
        deo_prcostE1.setValorDec (totFin);
        return;
    }
    if (totCosto == 0) totCosto = deo_prcostE.getValorDec () * deo_kilosE.getValorDec ();
    double costo = 0;
    if (nRow == 1) {
        jtLin.setValor ("100", 0, 6);
    }
    else {
        for (int n = 0; n < nRow; n ++) {
            costo = jtLin.getValorDec (n, 3) * jtLin.getValorDec (n, 4);
            if (totCosto == 0) costo = 0;
            else costo = costo / totCosto * 100;
            jtLin.setValor ("" + costo, n, 6);
        }
    }
    totCosto = deo_prcabE.getValorDec ();
    if (totCosto == 0) {
        deo_prcostE1.setValorDec (0);
        return;
    }
    double totLin = 0;
    totFin = 0;
    double totFi1 = 0;
    boolean swAjus = false;
    for (int n = 0; n < nRow; n ++) {
        costo = totCosto * jtLin.getValorDec (n, 6) / 100;
        costo = costo / jtLin.getValorDec (n, 3);
        if (jtLin.getValBoolean (n, 7)) {
            swAjus = true;
            jtLin.setValor ("" + jtLin.getValorDec (n, 4), n, 5);
            totFin += jtLin.getValorDec (n, 4) * jtLin.getValorDec (n, 3);
            continue;
        }
        if (costo >= 0) {
            totFi1 += costo * jtLin.getValorDec (n, 3);
            totFin += costo * jtLin.getValorDec (n, 3);
            jtLin.setValor ("" + costo, n, 5);
            totLin += costo * jtLin.getValorDec (n, 3);
        }
        else jtLin.setValor ("0", n, 5);
    }
    if (swAjus) {
        double porc1;
        double dif = totCosto - totFin;
        for (int n = 0; n < nRow; n ++) {
            if (! jtLin.getValBoolean (n, 7)) {
                totLin = jtLin.getValorDec (n, 3) * jtLin.getValorDec (n, 5);
                porc1 = totLin / totFi1;
                jtLin.setValor ("" + (totLin + (porc1 * dif)) / jtLin.getValorDec (n, 3), n, 5);
            }
        }
        totLin = 0;
        for (int n = 0; n < nRow; n ++) {
            totLin += jtLin.getValorDec (n, 3) * jtLin.getValorDec (n, 5);
        }
    }
    deo_prcostE1.setValorDec (totLin);
}


-----Function Pair=370=-----==

public RestServiceResult listPageNoSolveMChoiceForExercise3 (RestServiceResult serviceResult, Long nQuestionId, Long nUserId, int nRowStart, int nMaxResults) {
    CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionId);
    log.info ("Entro en el datamanager y el id de la pregunta es: " + nQuestionId);
    EntityManagerHelper.refresh (coQuestion);
    if (coQuestion == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_MULTIPLE_CHOICE_IN_QUESTION_2, CoMultipleChoiceE3.class);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        query.setParameter (1, nQuestionId);
        query.setParameter (2, nUserId);
        if (nRowStart > 0) query.setFirstResult (nRowStart);
        if (nMaxResults > 0) query.setMaxResults (nMaxResults);
        List < CoMultipleChoiceE3 > list = query.getResultList ();
        if (list.size () == 0) {
            Object [] arrayParam = {coQuestion.getQuestionName ()};
            serviceResult.setError (true);
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE3.notFound"), arrayParam));
            serviceResult.setNumResult (list.size ());
        }
        else {
            Object [] arrayParam = {list.size (), coQuestion.getQuestionName ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE3.success"), arrayParam));
            serviceResult.setObjResult (list);
            if ((nRowStart > 0) || (nMaxResults > 0)) {
                RestServiceResult serviceResult2 = listPageNoSolveMChoiceForExercise3 (new RestServiceResult (), nQuestionId, nUserId);
                int nNumMultipleChoice = serviceResult2.getNumResult ();
                serviceResult.setNumResult (nNumMultipleChoice);
            }
            else serviceResult.setNumResult (list.size ());
        }
    }
    return serviceResult;
}


Vector getPage (int page, int size, Vector list) throws Exception {
    int elementstart = (page - 1) * size;
    int elementlast = 0;
    if (page * size < list.size ()) {
        elementlast = (page * size) - 1;
        isLastPage = false;
        context.put ("eol", new Boolean (false));
    }
    else {
        elementlast = list.size () - 1;
        isLastPage = true;
        context.put ("eol", new Boolean (true));
    }
    if (page == 1) context.put ("bol", new Boolean (true));
    else context.put ("bol", new Boolean (false));
    Vector v = new Vector ();
    for (int i = elementstart; i < elementlast + 1; i ++) {
        v.addElement (list.elementAt (i));
    }
    return v;
}


-----Function Pair=371=-----==

public ArrayList < Empregado > listAll () throws SQLException, ClassNotFoundException, Exception {
    ArrayList < Empregado > empregados = null;
    String sql = "";
    sql = "select cpf,nome,sexo,data_nascimento,data_admissao," + "data_desligamento,salario from empregado";
    this.criaConexao (false);
    PreparedStatement stmt = null;
    stmt = this.getConnection ().prepareStatement (sql);
    ResultSet rs = stmt.executeQuery ();
    empregados = new ArrayList < Empregado > ();
    while (rs.next ()) {
        Empregado e = new Empregado (rs.getString ("cpf"), rs.getString ("nome"), rs.getString ("sexo"), rs.getDate ("data_nascimento"), rs.getDate ("data_admissao"), rs.getDouble ("salario"), rs.getDate ("data_desligamento"));
        empregados.add (e);
    }
    this.getConnection ().close ();
    return empregados;
}


public User getUser (String uname) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from User R where R.userName=?";
        Query q = s.createQuery (query);
        q.setString (0, uname);
        User u = (User) q.uniqueResult ();
        s.getTransaction ().commit ();
        return u;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=372=-----==

public void testFloat1 () throws Exception {
    float value = 2.2f;
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #testFloat1 (data decimal(28,10))");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #testFloat1 (data) values (?)");
    pstmt.setFloat (1, value);
    assertTrue (pstmt.executeUpdate () == 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #testFloat1");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertTrue (value == rs.getFloat (1));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public final void deleteAll () throws RecordException {
    Connection conn = ConnectionManager.getConnection ();
    LoggableStatement pStat = null;
    Class < ? extends Record > actualClass = this.getClass ();
    try {
        StatementBuilder builder = new StatementBuilder ("delete from " + TableNameResolver.getTableName (actualClass));
        pStat = builder.getPreparedStatement (conn);
        log.log (pStat.getQueryString ());
        pStat.executeUpdate ();
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback");
        }
        throw new RecordException (e);
    } finally {
        try {
            if (pStat != null) {
                pStat.close ();
            }
            conn.commit ();
            conn.close ();
        } catch (SQLException e) {
            throw new RecordException ("Error closing connection");
        }
    }
}


-----Function Pair=373=-----=1=

public void addUser (String strUserName, String strPass, boolean isEncrypt) throws Exception {
    Connection con = null;
    PreparedStatement pstmt = null;
    try {
        con = DbForumFactory.getConnection ();
        con.setAutoCommit (false);
        int userID = DbSequenceManager.nextID (DbSequenceManager.USER);
        pstmt = con.prepareStatement (INSERT_USER);
        pstmt.setString (1, strUserName);
        if (isEncrypt) {
            pstmt.setString (2, SecurityUtil.md5ByHex (strPass));
        }
        else {
            pstmt.setString (2, strPass);
        }
        pstmt.setString (3, "");
        pstmt.setString (4, "");
        pstmt.setString (5, "");
        pstmt.setString (6, "");
        pstmt.setString (7, "");
        pstmt.setInt (8, userID);
        pstmt.executeUpdate ();
        pstmt.clearParameters ();
        pstmt = con.prepareStatement (INSERT_USERPROPS);
        pstmt.setString (1, "");
        pstmt.setString (2, "");
        pstmt.setString (3, "");
        pstmt.setInt (4, 0);
        pstmt.setString (5, "");
        pstmt.setInt (6, 0);
        pstmt.setInt (7, 0);
        pstmt.setString (8, "");
        pstmt.setString (9, "");
        pstmt.setString (10, "");
        pstmt.setInt (11, 0);
        pstmt.setInt (12, 0);
        pstmt.setInt (13, 0);
        pstmt.setInt (14, 0);
        pstmt.setString (15, "");
        pstmt.setString (16, "");
        pstmt.setString (17, "");
        pstmt.setString (18, "");
        pstmt.setString (19, "");
        pstmt.setString (20, "");
        pstmt.setString (21, "");
        pstmt.setString (22, "");
        pstmt.setString (23, "");
        pstmt.setInt (24, 0);
        pstmt.setInt (25, 0);
        pstmt.setInt (26, userID);
        pstmt.executeUpdate ();
        pstmt.clearParameters ();
        pstmt = con.prepareStatement (INSTER_USERGROUP);
        pstmt.setInt (1, 4);
        pstmt.setInt (2, userID);
        pstmt.setInt (3, 0);
        pstmt.executeUpdate ();
        con.commit ();
    } catch (Exception e) {
        try {
            con.rollback ();
        } catch (SQLException e1) {
        }
        log.error ("insert user Error: " + e.toString ());
    } finally {
        DbForumFactory.closeDB (null, pstmt, null, con);
    }
}


private void updateService (int nodeID, String interfaceIP, int serviceID, String notifyFlag) throws ServletException {
    Connection connection = null;
    final DBUtils d = new DBUtils (getClass ());
    try {
        connection = Vault.getDbConnection ();
        d.watch (connection);
        PreparedStatement stmt = connection.prepareStatement (UPDATE_SERVICE);
        d.watch (stmt);
        stmt.setString (1, notifyFlag);
        stmt.setInt (2, nodeID);
        stmt.setString (3, interfaceIP);
        stmt.setInt (4, serviceID);
        stmt.executeUpdate ();
    } catch (SQLException e) {
        try {
            connection.rollback ();
        } catch (SQLException sqlEx) {
            throw new ServletException ("Couldn't roll back update to service " + serviceID + " on interface " + interfaceIP + " notify as " + notifyFlag + " in the database.", sqlEx);
        }
        throw new ServletException ("Error when updating to service " + serviceID + " on interface " + interfaceIP + " notify as " + notifyFlag + " in the database.", e);
    } finally {
        d.cleanUp ();
    }
}


-----Function Pair=374=-----==

private LinkedHashMap < String, String > getActivityStudent (MaUser maUser) {
    LinkedHashMap < String, String > tableActivity = new LinkedHashMap < String, String > ();
    for (Iterator < CoCourseUser > iterator = maUser.getCoCourseUsers ().iterator (); iterator.hasNext ();) {
        CoCourseUser coCourseUser = iterator.next ();
        for (Iterator < CoUnit > iterator2 = coCourseUser.getCoCourse ().getCoUnits ().iterator (); iterator2.hasNext ();) {
            CoUnit coUnit = iterator2.next ();
            for (Iterator < CoSequence > iterator3 = coUnit.getCoSequences ().iterator (); iterator3.hasNext ();) {
                CoSequence coSequence = iterator3.next ();
                for (Iterator < CoActivity > iterator4 = coSequence.getCoActivities ().iterator (); iterator4.hasNext ();) {
                    CoActivity coActivity = (CoActivity) iterator4.next ();
                    tableActivity.put (coActivity.getActivityId ().toString (), coCourseUser.getCoCourse ().getCourseCod () + " - " + coActivity.getItem () + "." + coActivity.getActivityName ());
                }
            }
        }
    }
    log.info ("N�mero de actividades normales: " + tableActivity.size ());
    for (Iterator < CoCourseUser > iterator = maUser.getCoCourseUsers ().iterator (); iterator.hasNext ();) {
        CoCourseUser coCourseUser = (CoCourseUser) iterator.next ();
        for (Iterator < CoActivity > iterator2 = coCourseUser.getCoCourse ().getCoActivities ().iterator (); iterator2.hasNext ();) {
            CoActivity coActivity = (CoActivity) iterator2.next ();
            tableActivity.put (coActivity.getActivityId ().toString (), coCourseUser.getCoCourse ().getCourseCod () + " - " + coActivity.getItem () + "." + coActivity.getActivityName ());
        }
    }
    return tableActivity;
}


private void createPortalLogin (String login, String password, String name) throws Exception {
    String sql = "";
    Connection conn = null;
    Db db = null;
    try {
        db = new Db ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            sql = "select user_login from user where user_login = '" + login + "'";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (! found) {
            {
                r.add ("user_login", login);
                r.add ("user_password", password);
                r.add ("user_name", name);
                r.add ("user_role", "student");
                sql = r.getSQLInsert ("user");
                stmt.executeUpdate (sql);
            }
            {
                sql = "select css_name from user_css where user_login = 'student'";
                ResultSet rs = stmt.executeQuery (sql);
                String css_name = "default.css";
                if (rs.next ()) css_name = rs.getString ("css_name");
                sql = "insert into user_css (user_login, css_name) values ('" + login + "', '" + css_name + "')";
                stmt.executeUpdate (sql);
            }
            {
                Vector vector = new Vector ();
                {
                    sql = "select tab_id, tab_title, sequence, display_type from tab where user_login = 'student'";
                    ResultSet rs = stmt.executeQuery (sql);
                    while (rs.next ()) {
                        Hashtable h = new Hashtable ();
                        h.put ("tab_id", rs.getString ("tab_id"));
                        h.put ("tab_title", rs.getString ("tab_title"));
                        h.put ("sequence", rs.getString ("sequence"));
                        h.put ("display_type", rs.getString ("display_type"));
                        vector.addElement (h);
                    }
                }
                {
                    for (int i = 0; i < vector.size (); i ++) {
                        Hashtable h = (Hashtable) vector.elementAt (i);
                        r.clear ();
                        r.add ("tab_id", (String) h.get ("tab_id"));
                        r.add ("tab_title", (String) h.get ("tab_title"));
                        r.add ("sequence", Integer.parseInt ((String) h.get ("sequence")));
                        r.add ("display_type", (String) h.get ("display_type"));
                        r.add ("user_login", login);
                        sql = r.getSQLInsert ("tab");
                        stmt.executeUpdate (sql);
                    }
                }
            }
            {
                Vector vector = new Vector ();
                {
                    sql = "select tab_id, module_id, sequence, module_custom_title, column_number " + "from user_module where user_login = 'student'";
                    ResultSet rs = stmt.executeQuery (sql);
                    while (rs.next ()) {
                        Hashtable h = new Hashtable ();
                        h.put ("tab_id", rs.getString ("tab_id"));
                        h.put ("module_id", rs.getString ("module_id"));
                        h.put ("sequence", rs.getString ("sequence"));
                        h.put ("module_custom_title", lebah.db.Db.getString (rs, "module_custom_title"));
                        h.put ("column_number", rs.getString ("column_number"));
                        vector.addElement (h);
                    }
                }
                {
                    for (int i = 0; i < vector.size (); i ++) {
                        Hashtable h = (Hashtable) vector.elementAt (i);
                        r.clear ();
                        r.add ("tab_id", (String) h.get ("tab_id"));
                        r.add ("module_id", (String) h.get ("module_id"));
                        r.add ("sequence", Integer.parseInt ((String) h.get ("sequence")));
                        r.add ("module_custom_title", (String) h.get ("module_custom_title"));
                        r.add ("column_number", Integer.parseInt ((String) h.get ("column_number")));
                        r.add ("user_login", login);
                        sql = r.getSQLInsert ("user_module");
                        stmt.executeUpdate (sql);
                    }
                }
            }
        }
        else {
            r.add ("user_name", name);
            r.update ("user_login", login);
            sql = r.getSQLUpdate ("user");
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        try {
            conn.rollback ();
        } catch (SQLException rollex) {
        }
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=375=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("exercises1.search.notFound"));
    }
    else {
        List < CoExercises1 > list = new ArrayList < CoExercises1 > ();
        EntityManagerHelper.refresh (coExercises1);
        list.add (coExercises1);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public final void mergeAll (final Collection < ? extends T > objects) throws CannotConnectToDatabaseException {
    if (objects != null && ! objects.isEmpty ()) {
        final Session s = this.currentSession ();
        Transaction tx = null;
        try {
            tx = s.beginTransaction ();
            for (T obj : objects) {
                s.merge (obj);
            }
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (HibernateException he) {
            tx.rollback ();
            if (LOGGER.isErrorEnabled ()) {
                LOGGER.error ("Failed to merge entities - transaction was rolled back.", he);
            }
            he.printStackTrace ();
            throw he;
        } finally {
            s.close ();
        }
    }
}


-----Function Pair=376=-----==

private static void createInsertClassForPk (DbTableType table) throws Exception {
    String base = StringTools.capitalizeString (table.getName ());
    String className = "Insert" + base + "Item";
    String classNameItem = base + config.getClassNameSufix ();
    String s = "package " + packageClass + ";\n" + "\n" + (isApplModule ? "import org.riverock.a3.AuthSession;\n" + "import org.riverock.a3.AccessDeniedException;\n" + "import org.riverock.as.ApplicationInterface;\n" + "import org.riverock.schema.appl_server.ResourceRequestType;\n" + "import org.riverock.schema.appl_server.ResourceRequestParameterType;\n" + "import org.riverock.as.server.ApplicationTools;\n" : "") + "import " + config.getJavaPackageXmlSchema () + '.' + base + config.getClassNameSufix () + ";\n" + "\n" + "import java.sql.PreparedStatement;\n" + "import java.sql.ResultSet;\n" + "import java.sql.Types;\n" + "\n" + "public class " + className + " " + addInterfaceDeclaration (new String [] {isApplModule ? "ApplicationInterface" : "", isInsertInterface ? insertInterface : ""}) + "\n{\n" + initLogging (packageClass + '.' + className) + "\n" + "    public " + className + "(){}\n" + "\n" + (isInsertInterface ? putProcessEntityMethos (classNameItem) : "") + "    public static Long processData(" + db.getFactoryMethod () + " db_, " + classNameItem + " item) " + putExceptionDefinition () + "    {\n" + "        return new Long(process(db_, item));\n" + "    }\n" + "\n" + "    public static long process(" + db.getFactoryMethod () + " db_, " + classNameItem + " item) " + putExceptionDefinition () + "    {\n" + "        String sql_ =\n" + "            \"insert into " + table.getName () + "\"+\n" + buildInsertFieldList (table, 13) + "            \"values\"+\n" + "            \"(";
    boolean isFirst = true;
    for (int i = 0; i < table.getFieldsCount (); i ++) {
        DbFieldType field = table.getFields (i);
        if (field.getJavaType () == 1111) continue;
        if (isFirst) isFirst = false;
        else s += ", ";
        if (field.getJavaType () != Types.DATE && field.getJavaType () != Types.TIMESTAMP) s += " ?";
        else s += " \"+ db_.getNameDateBind()+\"";
    }
    s += ")\";\n" + "\n" + "        return process(db_, item, sql_);\n" + "    }\n" + "\n" + "    public static long process(" + db.getFactoryMethod () + " db_, " + classNameItem + " item, String sql_) " + putExceptionDefinition () + "    {\n" + "\n" + "        PreparedStatement ps = null;\n" + "        ResultSet rs = null;\n" + "        try\n" + "        {\n" + "            ps = db_.prepareStatement(sql_);\n" + "\n";
    int numParam = 0;
    for (int i = 0; i < table.getFieldsCount (); i ++) {
        ++ numParam;
        DbFieldType field = table.getFields (i);
        String capitalizeName = StringTools.capitalizeString (field.getName ()) + "()";
        if (isLogicField (field)) {
            s += storeBooleanField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls, field.getDefaultValue ());
        }
        else {
            if (isKeyField (field)) {
                s += storeLongField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls && getDeleteRule (table, field) != java.sql.DatabaseMetaData.importedKeyCascade);
            }
            else {
                switch (field.getJavaType ().intValue ()) {
                    case Types.DECIMAL :
                        if (field.getDecimalDigit () == null || field.getDecimalDigit () == 0) {
                            if (field.getSize () < 7) {
                                s += storeIntField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                            }
                            else {
                                s += storeLongField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                            }
                        }
                        else {
                            s += storeDoubleField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                        }
                        break;
                    case Types.INTEGER :
                        if (field.getSize () < 7) {
                            s += storeIntField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                        }
                        else {
                            s += storeLongField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                        }
                        break;
                    case Types.DOUBLE :
                        s += storeDoubleField (capitalizeName, numParam, field.getNullable () != DatabaseMetaData.columnNoNulls);
                        break;
                    case Types.VARCHAR :
                    case Types.LONGVARCHAR :
                    case Types.LONGVARBINARY :
                        if (field.getNullable () != DatabaseMetaData.columnNoNulls) {
                            s += "             if (item.get" + capitalizeName + "!=null)\n" + "                 ps.setString(" + numParam + ", item.get" + capitalizeName + " );\n" + "             else\n" + "                 ps.setNull(" + numParam + ", Types.VARCHAR);\n\n";
                        }
                        else s += "             ps.setString(" + numParam + ", item.get" + capitalizeName + " );\n";
                        break;
                    case Types.DATE :
                    case Types.TIMESTAMP :
                        if (field.getNullable () != DatabaseMetaData.columnNoNulls) {
                            s += "             if (item.get" + capitalizeName + "!=null)\n" + "                 db_.bindDate(ps, " + numParam + ", new java.sql.Timestamp( item.get" + capitalizeName + ".getTime()) );\n" + "             else\n" + "                 ps.setNull(" + numParam + ", Types.DATE);\n\n";
                        }
                        else s += "             db_.bindDate(ps, " + numParam + ", new java.sql.Timestamp( item.get" + capitalizeName + ".getTime()) );\n";
                        break;
                    default :
                        field.setJavaStringType ("unknown field type field - " + field.getName () + " javaType - " + field.getJavaType ());
                        System.out.println ("unknown field type field - " + field.getName () + " javaType - " + field.getJavaType ());
                }
            }
        }
    }
    s += "\n" + "             int countInsertRecord = ps.executeUpdate();\n" + "\n" + (config.getIsUseLogging () ? "             if (cat.isDebugEnabled())\n" + "                 cat.debug(\"Count of inserted records - \"+countInsertRecord);\n" : "") + "\n" + "             return countInsertRecord;\n" + "\n";
    s += getEndOfClassUID (className, classNameItem, table, "I", "sql_");
    s += getMainMethod (classNameItem, className, "test-" + table.getName ().toLowerCase () + "-item.xml");
    writeClass (className, s);
}


public List < AppData > findAppDesc (String user, String query) throws XregistryException {
    List < String [] > results = findResource (FIND_APP_DESC_SQL, query, QNAME, OWNER, HOST_NAME, RESOURCE_ID);
    List < AppData > returnValues = new ArrayList < AppData > ();
    for (String [] result : results) {
        String resourceID = ResourceUtils.getResourceID (DocType.AppDesc, result [0], result [2]);
        String allowedAction = isAccessible (resourceID, result [1], user);
        if (allowedAction != null) {
            AppData data = new AppData (QName.valueOf (result [0]), result [1], result [2]);
            data.allowedAction = allowedAction;
            data.resourceID = new QName (result [3]);
            data.resourcename = result [3];
            returnValues.add (data);
        }
    }
    return returnValues;
}


-----Function Pair=377=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nUnitId) {
    log.info ("Buscando Unidad: " + nUnitId);
    CoUnit coUnit = new CoUnitDAO ().findById (nUnitId);
    if (coUnit == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("unit.search.notFound"));
    }
    else {
        List < CoUnit > list = new ArrayList < CoUnit > ();
        EntityManagerHelper.refresh (coUnit);
        list.add (coUnit);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("unit.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


protected void downgradeHistory (Collection < String > versions) {
    Assert.notEmpty (versions);
    try {
        Connection connection = this.database.getDefaultConnection ();
        PreparedStatement statement = connection.prepareStatement ("UPDATE " + this.logTableName + " SET RESULT = 'DOWNGRADED' WHERE TYPE = 'B' AND TARGET = ? AND RESULT = 'COMPLETE'");
        boolean commit = false;
        try {
            for (String version : versions) {
                statement.setString (1, version);
                int modified = statement.executeUpdate ();
                Assert.isTrue (modified <= 1, "Expecting not more than 1 record to be updated, not " + modified);
            }
            commit = true;
        } finally {
            statement.close ();
            if (commit) connection.commit ();
            else connection.rollback ();
        }
    } catch (SQLException e) {
        throw new SystemException (e);
    }
}


-----Function Pair=378=-----==

public List < Artista > getListaArtistas () {
    Connection conn = null;
    PreparedStatement ps = null;
    HashMap < Integer, Artista > lista = new HashMap < Integer, Artista > ();
    try {
        conn = C3P0Pool.getConnection ();
        String sql = "select " + "a.numeroinscricao, a.nome, a.sexo, a.email, a.obs, a.telefone, " + "e.logradouro, e.cep, e.estado, e.bairro, e.cidade, e.pais " + "from artista a join endereco e on (a.numeroinscricao = e.fk_artista) " + "order by numeroinscricao;";
        ps = conn.prepareStatement (sql);
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            try {
                Artista artista = this.getArtista (rs);
                lista.put (artista.getNumeroInscricao (), artista);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        close (conn, ps);
    }
    return new ArrayList < Artista > (lista.values ());
}


public void testThreeLevelsOfFieldAccess () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Boiler boiler = new Boiler ("Baxi", "Calentador");
        Timer timer = new Timer ("Casio", true, boiler);
        boiler.setTimer (timer);
        em.persist (timer);
        em.flush ();
        List result = em.createQuery ("Select b.model FROM " + Boiler.class.getName () + " b " + "WHERE b.timer.make = 'Seiko'").getResultList ();
        assertEquals (0, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=379=-----==

public Semester store (Semester obj) throws InsertException, DBConnectionException, XmlIOException {
    if (obj.getYearOfStudy ().getId () == null || obj.getAcademicYear ().getId () == null) throw new InsertException ("Missing Foreign Key(s)");
    Semester toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getYearOfStudy ().getId ());
    values.add (obj.getDescription ());
    values.add (obj.getAcademicYear ().getId ());
    values.add (obj.getName ());
    values.add (obj.getLevel ());
    values.add (obj.getDescription ());
    values.add (obj.getSDate ());
    values.add (obj.getEDate ());
    try {
        stmt.executeUpdate (new InsertQuery (TABLE_NAME, values).toString ());
        toReturn = findByValues (obj.getName (), obj.getYearOfStudy ().getId (), obj.getAcademicYear ().getId ());
        if (toReturn != null) {
            toReturn.setAcademicYear (obj.getAcademicYear ());
            toReturn.setYearOfStudy (obj.getYearOfStudy ());
            toReturn.setTeachingUnit (obj.getTeachingUnitList ());
        }
        else throw new SelectException (TABLE_NAME + " Can't retieve record");
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


private void Delete (Connection conn, User user, String owner) throws NpsException {
    PreparedStatement pstmt = null;
    String sql = null;
    try {
        sql = "update article set creator=? where creator=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, owner);
        pstmt.setString (2, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update template set creator=? where creator=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, owner);
        pstmt.setString (2, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from userrole where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from topic_owner where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from site_owner where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from users where id=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=380=-----==

public Leilao getLeilao (Leilao leilao) throws SQLException {
    Connection conn = null;
    Leilao leilaoUpdate;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Leilao where idleilao = " + leilao.getIdLeilao ();
        leilao = null;
        ResultSet rs = stmt.executeQuery (sqlSelect);
        while (rs.next ()) {
            leilao = new Leilao ();
            leilao.setIdLeilao (rs.getInt ("idleilao"));
            leilao.setDataInicio (Utils.getDateFormat (rs.getString ("datainicio"), "yyyy-MM-dd"));
            leilao.setDataFim (Utils.getDateFormat (rs.getString ("datafim"), "yyyy-MM-dd"));
            return leilao;
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return null;
}


public boolean deleteTemplate (int id, boolean keepNotes, LinkedList < Integer > notes, LinkedList < Integer > templates) {
    if ((id != DatabaseInterface.MAIN_TEMPLATE) && (id != DatabaseInterface.EVENT_TEMPLATE_ID) && (id != DatabaseInterface.TODO_TEMPLATE_ID)) {
        try {
            try {
                conn.setAutoCommit (false);
                Statement stmt = conn.createStatement ();
                Template cur = main.getTemplate (id);
                Template newT = cur.getParent ();
                notes.addAll (deleteTemplate_notes (cur, newT, keepNotes, stmt));
                templates.addAll (deleteTemplate_templates (id, stmt));
                conn.commit ();
                return true;
            } catch (SQLException e) {
                e.printStackTrace ();
                conn.rollback ();
            }
            conn.setAutoCommit (true);
        } catch (SQLException eSQL) {
            eSQL.printStackTrace ();
            System.err.println ("Something terrible happened in delete template that required the second error catcher to rescue the first");
        }
    }
    return false;
}


-----Function Pair=381=-----==

public void executeInsert () {
    Session session = null;
    Transaction tx = null;
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        BasicUser user = (BasicUser) parameters.get (DataConnector.RECORD_PARAMETER);
        user.setIdString (user.getIdString ().toLowerCase ());
        user.setLastUpdate (new Date ());
        user.setLastUpdateBy (UserProfileManager.getUserId ());
        session.save (user);
        responseCode = 0;
        responseString = "Execution complete";
        tx.commit ();
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


public int instantiate (int objectId, String description) throws FidoDatabaseException, ObjectNotFoundException, ClassLinkTypeNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "insert into Objects (Description) " + "values ('" + description + "')";
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            if (contains (stmt, objectId) == false) throw new ObjectNotFoundException (objectId);
            stmt.executeUpdate (sql);
            int id;
            sql = "select currval('objects_objectid_seq')";
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new SQLException ("No rows returned from select currval() query");
            else id = rs.getInt (1);
            ObjectLinkTable objectLinkList = new ObjectLinkTable ();
            objectLinkList.linkObjects (stmt, id, "instance", objectId);
            conn.commit ();
            return id;
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=382=-----==

protected void performInsertTest () throws Exception {
    Connection conn = connect ();
    EntityDescriptor ed = repository.getEntityDescriptor (User.class);
    User testUser = new User ();
    Date now = new Date ();
    conn.setAutoCommit (false);
    testUser.setUsername ("rednose");
    testUser.setUCreated ("dbUtilTest");
    testUser.setUModified ("dbUtilTest");
    testUser.setDtCreated (now);
    testUser.setDtModified (now);
    String sql = dbUtil.genInsert (ed, testUser);
    Statement st = conn.createStatement ();
    long id = 0;
    System.err.println ("Insert: " + sql);
    int rv = st.executeUpdate (sql, dbUtil.supportsGeneratedKeyQuery () ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS);
    if (rv > 0) {
        if (dbUtil.supportsGeneratedKeyQuery ()) {
            ResultSet rs = st.getGeneratedKeys ();
            if (rs.next ()) id = rs.getLong (1);
        }
        else {
            id = queryId (ed, now, "dbUtilTest", conn, dbUtil);
        }
        if (id > 0) testUser.setId (id);
        else rv = 0;
    }
    conn.rollback ();
    assertTrue ("oups, insert failed?", id != 0);
    System.err.println ("successfully created user with id #" + id + " temporarily");
}


protected static void updateDocumentItemsOnStock (Connection conn, String documentID, boolean operationIsAdd) throws SQLException {
    Statement stmt = null;
    ResultSet rs = null;
    ArrayList updtQueries = new ArrayList ();
    boolean lastAutoCommit = conn.getAutoCommit ();
    try {
        conn.setAutoCommit (false);
        stmt = conn.createStatement ();
        rs = stmt.executeQuery ("select di.ProductID, di.Quantity from tbl_DocumentItem di,tbl_Product p" + " where p.ProductID = di.ProductID and p.ProductType in ('BOS','SOS','BSS') and di.Quantity is not null and di.DocumentID = " + documentID);
        while (rs.next ()) {
            String productID = rs.getString (1);
            double qty = rs.getDouble (2);
            logger.debug ("OK. Result = productID=" + productID + " and qty=" + qty + " and operationIsAdd=" + operationIsAdd);
            if (operationIsAdd) {
                updtQueries.add (" update tbl_Product set StockCurrent = StockCurrent + " + qty + " where ProductID = " + productID);
            }
            else {
                updtQueries.add (" update tbl_Product set StockCurrent = StockCurrent - " + qty + " where ProductID = " + productID);
            }
        }
        rs.close ();
        for (Iterator it = updtQueries.iterator (); it.hasNext ();) {
            String sql = (String) it.next ();
            logger.debug ("Executing: " + sql);
            stmt.execute (sql);
        }
        conn.commit ();
        stmt.close ();
        stmt = null;
        conn.setAutoCommit (lastAutoCommit);
    } catch (SQLException ex) {
        try {
            conn.rollback ();
            conn.setAutoCommit (lastAutoCommit);
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
        if (stmt != null) {
            stmt.close ();
        }
        throw ex;
    }
}


-----Function Pair=383=-----==

private void updateService (int nodeID, String interfaceIP, int serviceID, String notifyFlag) throws ServletException {
    Connection connection = null;
    final DBUtils d = new DBUtils (getClass ());
    try {
        connection = Vault.getDbConnection ();
        d.watch (connection);
        PreparedStatement stmt = connection.prepareStatement (UPDATE_SERVICE);
        d.watch (stmt);
        stmt.setString (1, notifyFlag);
        stmt.setInt (2, nodeID);
        stmt.setString (3, interfaceIP);
        stmt.setInt (4, serviceID);
        stmt.executeUpdate ();
    } catch (SQLException e) {
        try {
            connection.rollback ();
        } catch (SQLException sqlEx) {
            throw new ServletException ("Couldn't roll back update to service " + serviceID + " on interface " + interfaceIP + " notify as " + notifyFlag + " in the database.", sqlEx);
        }
        throw new ServletException ("Error when updating to service " + serviceID + " on interface " + interfaceIP + " notify as " + notifyFlag + " in the database.", e);
    } finally {
        d.cleanUp ();
    }
}


public static void generateKeys2 (int keySize, Path publicKey, Path privateKey) throws NoSuchAlgorithmException, IOException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance ("RSA");
    keyGen.initialize (keySize);
    KeyPair keyPair = keyGen.generateKeyPair ();
    PublicKey pubkey = keyPair.getPublic ();
    PrivateKey privkey = keyPair.getPrivate ();
    Files.createDirectories (publicKey.getParent ());
    Files.createFile (publicKey);
    Files.createDirectories (privateKey.getParent ());
    Files.createFile (privateKey);
    ObjectOutputStream oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (publicKey.toFile ())));
    oout.writeObject (pubkey);
    oout.close ();
    oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (privateKey.toFile ())));
    oout.writeObject (privkey);
    oout.close ();
}


-----Function Pair=384=-----==

private boolean importReportLineSet () {
    String sql = "select rls.rls_name, rls.rls_description from i_reportlineset rls where " + "rls.pa_reportlineset_id is null group by rls.rls_name, rls.rls_description";
    try {
        PreparedStatement pstmt = DB.prepareStatement (sql, trxName);
        ResultSet rs = pstmt.executeQuery ();
        while (rs.next ()) {
            MReportLineSet rls = new MReportLineSet (getCtx (), 0, trxName);
            rls.setName (rs.getString ("rls_name"));
            rls.setDescription (rs.getString ("rls_description"));
            rls.save (trxName);
            String upd_sql = "update i_reportlineset set pa_reportlineset_id=? where rls_name=? and rls_description=?";
            PreparedStatement upd_pstmt = DB.prepareStatement (upd_sql, trxName);
            upd_pstmt.setInt (1, rls.getPA_ReportLineSet_ID ());
            upd_pstmt.setString (2, rls.getName ());
            upd_pstmt.setString (3, rls.getDescription ());
            upd_pstmt.executeUpdate ();
        }
    } catch (SQLException e) {
        log.log (Level.SEVERE, "Fallo al crear el conjunto de lineas de informe: " + e);
        return false;
    }
    return true;
}


protected int transferOwnership (TransferOwnershipRequest request, String uuid, String newOwner) throws ImsServiceException, SQLException {
    PreparedStatement st = null;
    try {
        this.authorize (request, uuid);
        int ownerID = this.queryOwnerByUsername (newOwner);
        if (ownerID == - 1) {
            throw new ImsServiceException ("Unrecognized publisher: " + newOwner);
        }
        StringBuilder sql = new StringBuilder ();
        sql.append ("UPDATE ").append (this.getResourceTableName ());
        sql.append (" SET OWNER=? WHERE DOCUUID=?");
        logExpression (sql.toString ());
        Connection con = returnConnection ().getJdbcConnection ();
        st = con.prepareStatement (sql.toString ());
        st.setInt (1, ownerID);
        st.setString (2, uuid);
        int nRows = st.executeUpdate ();
        if (nRows > 0) {
            request.setActionStatus (ImsRequest.ACTION_STATUS_REPLACED);
        }
        return nRows;
    } finally {
        closeStatement (st);
    }
}


-----Function Pair=385=-----==

public RestServiceResult listScoreExerciseS1ForUser (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    if (maUser == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("coScoreExercises1.search.notFound"));
    }
    else {
        List < CoScoreExercises1 > list = new ArrayList < CoScoreExercises1 > (maUser.getCoScoreExercises1s ());
        Object [] arrayParam = {list.size (), maUser.getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.listScoreExerciseS1ForUser.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


protected int deleteBitstreamInfo (int id, Connection conn) {
    PreparedStatement stmt = null;
    int numDeleted = 0;
    try {
        stmt = conn.prepareStatement (DELETE_BITSTREAM_INFO);
        stmt.setInt (1, id);
        numDeleted = stmt.executeUpdate ();
        if (numDeleted > 1) {
            conn.rollback ();
            throw new IllegalStateException ("Too many rows deleted! Number of rows deleted: " + numDeleted + " only one row should be deleted for bitstream id " + id);
        }
    } catch (SQLException e) {
        LOG.error ("Problem deleting bitstream. " + e.getMessage (), e);
        throw new RuntimeException ("Problem deleting bitstream. " + e.getMessage (), e);
    } finally {
        cleanup (stmt);
    }
    return numDeleted;
}


-----Function Pair=386=-----==

public static void cancelDocumentDataFiles (Connection conn, String documentID, Map parms) throws Exception {
    logger.debug ("cancelDocumentDataFiles() - Entering method with documentID=" + documentID);
    if (parms == null) parms = getDocumentDataFilesParameters (conn, documentID);
    String baseFileStr = (String) parms.get ("basePDFFile");
    String origFileStr = (String) parms.get ("originalPDFFile");
    String dupFileStr = (String) parms.get ("duplicatePDFFile");
    File baseFile = new File (baseFileStr);
    File origFile = new File (origFileStr);
    File dupFile = new File (dupFileStr);
    if (! (baseFile.isFile () && origFile.isFile () && dupFile.isFile ())) {
        logger.debug ("cancelDocumentDataFiles() - no file exists... creating files first...");
        createDocumentDataFiles (conn, documentID, parms);
    }
    ResourceBundle rb = (ResourceBundle) parms.get ("resourceBundle");
    String textCancel = "ANULADO";
    if (rb != null) {
        textCancel = rb.getString ("doc.doc01.print.Cancel");
    }
    logger.debug ("cancelDocumentDataFiles() - canceling original file " + origFileStr);
    processCancelDocumentDataPDF (origFileStr, new FileOutputStream (origFileStr + ".tmp.pdf"), textCancel, (Properties) parms.get ("documentReportProps"));
    File tmpFile = new File (origFileStr + ".tmp.pdf");
    if (! tmpFile.renameTo (origFile)) {
        throw new Exception ("Cannot rename and cancel original document on file " + origFileStr);
    }
    logger.debug ("cancelDocumentDataFiles() - canceling duplicate file " + dupFileStr);
    processCancelDocumentDataPDF (dupFileStr, new FileOutputStream (dupFileStr + ".tmp.pdf"), textCancel, (Properties) parms.get ("documentReportProps"));
    tmpFile = new File (dupFileStr + ".tmp.pdf");
    if (! tmpFile.renameTo (dupFile)) {
        throw new Exception ("Cannot rename and cancel duplicate document on file " + dupFileStr);
    }
}


public static int deleteBlacklist (int ownerId, String [] otherIds) {
    if (otherIds == null || otherIds.length == 0) return 0;
    StringBuffer hql = new StringBuffer ("DELETE FROM MyBlackListBean f WHERE f.myId=? AND f.other.id IN (");
    for (int i = 0; i < otherIds.length; i ++) {
        hql.append ("?,");
    }
    hql.append ("?)");
    Session ssn = getSession ();
    try {
        beginTransaction ();
        Query q = ssn.createQuery (hql.toString ());
        q.setInteger (0, ownerId);
        int i = 0;
        for (; i < otherIds.length; i ++) {
            String s_id = (String) otherIds [i];
            int id = - 1;
            try {
                id = Integer.parseInt (s_id);
            } catch (Exception e) {
            }
            q.setInteger (i + 1, id);
        }
        q.setInteger (i + 1, - 1);
        int er = q.executeUpdate ();
        commit ();
        return er;
    } catch (HibernateException e) {
        rollback ();
        throw e;
    }
}


-----Function Pair=387=-----==

public IllnessStatsListDocument getDiagnosisMedicalStatsReport () {
    IllnessStatsListDocument doc = null;
    ResultSet rsReport = null;
    try {
        helper = new DBHelper ();
        PreparedStatement psReport = helper.prepareStatement (SQL.getDiagnosisMedicalStatsReport ());
        rsReport = psReport.executeQuery ();
        doc = IllnessStatsListDocument.Factory.newInstance ();
        doc.addNewIllnessStatsList ();
        while (rsReport.next ()) {
            MedicalIllness m = doc.getIllnessStatsList ().addNewStats ();
            m.setName (rsReport.getString ("NAME"));
            m.setTitle (rsReport.getString ("TITLE"));
            m.setSurname (rsReport.getString ("SURNAME"));
            m.setCount (new BigInteger (String.valueOf (rsReport.getInt ("COUNT"))));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsReport != null) {
                rsReport.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


public void deleteUserInfo (AuthSession authSession, AuthUserExtendedInfo infoAuth) {
    log.info ("Start delete auth");
    DatabaseAdapter db = null;
    try {
        db = DatabaseAdapter.getInstance ();
        DeleteWmAuthRelateAccgroupWithIdAuthUser.process (db, infoAuth.getAuthInfo ().getAuthUserId ());
        DeleteWmAuthUserWithIdAuthUser.process (db, infoAuth.getAuthInfo ().getAuthUserId ());
        db.commit ();
    } catch (Throwable e) {
        try {
            if (db != null) db.rollback ();
        } catch (Exception e001) {
        }
        final String es = "Error add user auth";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db);
        db = null;
        log.info ("End delete auth");
    }
}


-----Function Pair=388=-----==

public void loadChilds (Row row) {
    getRows ().clear ();
    row.getRowSet ().getRows ().clear ();
    StringBuffer sb = new StringBuffer (getBasicSQL ());
    sb.append (" WHERE ");
    Vector whereValues = new Vector ();
    Iterator pkColumnIter = pkColumns.iterator ();
    while (pkColumnIter.hasNext ()) {
        Column pkColumn = (Column) pkColumnIter.next ();
        if (pkColumn.getTableName ().equals (getMainTableName ())) {
            sb.append (pkColumn.getTableName () + "." + pkColumn.getColumnName () + "=? AND ");
            whereValues.add (ObjectUtil.findNewCell (row, pkColumn.getTableName (), pkColumn.getColumnName ()).getColumnValue ());
        }
    }
    sb.delete (sb.lastIndexOf ("AND"), sb.lastIndexOf ("AND") + 3);
    String sql = sb.toString ();
    DAO dao = DAO.getInstance ();
    dao.query (sql);
    for (int i = 0; i < whereValues.size (); i ++) {
        dao.setObject (i + 1, whereValues.get (i));
    }
    ResultSet rs = dao.executeQuery ();
    try {
        while (rs.next ()) {
            Row childRow = new Row (rs);
            row.getRowSet ().getRows ().add (childRow);
            getRows ().add (childRow);
        }
        rs.close ();
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
}


public static synchronized String getSequenceNumber (String SequenceName) {
    String result = "";
    Connection conn = null;
    Statement ps = null;
    ResultSet rs = null;
    try {
        conn = TPCW_Database.getConnection ();
        conn.setAutoCommit (false);
        String sql = "select num from sequence where name='" + SequenceName + "'";
        ps = conn.createStatement (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
        rs = ps.executeQuery (sql);
        long num = 0;
        while (rs.next ()) {
            num = rs.getLong (1);
            result = new Long (num).toString ();
        }
        num ++;
        sql = "update sequence set num=" + num + " where name='" + SequenceName + "'";
        int res = ps.executeUpdate (sql);
        if (res == 1) {
            conn.commit ();
        }
        else conn.rollback ();
    } catch (Exception e) {
        System.out.println ("Error Happens when trying to obtain the senquence number");
        e.printStackTrace ();
    } finally {
        try {
            if (conn != null) conn.close ();
            if (rs != null) rs.close ();
            if (ps != null) ps.close ();
        } catch (SQLException se) {
            se.printStackTrace ();
        }
    }
    return result;
}


-----Function Pair=389=-----==

public List getKeyWordList () throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    StringBuffer sqlStatCnt = new StringBuffer ();
    List listByRelationalWord = new ArrayList ();
    try {
        sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE");
        sqlStat.append (" FROM DMS_RELATIONAL_WORD A ");
        sqlStat.append (" WHERE A.PARENT_ID=?  AND A.RECORD_STATUS = ?  ");
        preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        this.setPrepareStatement (preStat, 1, "0");
        this.setPrepareStatement (preStat, 2, GlobalConstant.RECORD_STATUS_ACTIVE);
        rs = preStat.executeQuery ();
        while (rs.next ()) {
            DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
            tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
            tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
            tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
            tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
            tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
            tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
            tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
            tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
            tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
            tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
            tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
            tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
            listByRelationalWord.add (tmpDmsRelationalWord);
        }
        return listByRelationalWord;
    } catch (ApplicationException appEx) {
        throw appEx;
    } catch (SQLException sqle) {
        log.error (sqle, sqle);
        throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
    } catch (Exception e) {
        log.error (e, e);
        throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
    } finally {
        try {
            rs.close ();
        } catch (Exception ignore) {
        } finally {
            rs = null;
        }
        try {
            preStat.close ();
        } catch (Exception ignore) {
        } finally {
            preStat = null;
        }
    }
}


public void testHaving () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT P.firstName FROM " + Person.class.getName () + " P Group By P.firstName HAVING P.firstName = 'Fred'").getResultList ();
        assertEquals (1, result.size ());
        assertEquals ("Fred", result.get (0).toString ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=390=-----==

public BaseClass (int clsId, boolean t) {
    this.clsId = clsId;
    dao = DAO.getInstance ();
    dao.query (Resources.SELECT_CLS_SQL);
    dao.setInt (1, clsId);
    ResultSet rs = dao.executeQuery ();
    try {
        if (rs.next ()) {
            clsName = rs.getString ("CLSNAME");
            basicSQL = rs.getString ("BASICSQL");
            defCL = rs.getInt ("DEFCL");
        }
        rs.close ();
    } catch (SQLException sqle) {
    }
    initialMainTableName ();
    initialColumns ();
    initialI18n ();
    initialSlayerMaster ();
    initialGroupnames ();
    initialPkColumns ();
    initialRowType ();
    initialRows ();
}


public AbstractBaseObject getRelationalWordByType (String keyWord) throws ApplicationException {
    List relationalWordListByType = new ArrayList ();
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    StringBuffer sqlStatCnt = new StringBuffer ();
    try {
        sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE");
        sqlStat.append (" FROM DMS_RELATIONAL_WORD A ");
        sqlStat.append (" WHERE A.WORD = ? AND A.RECORD_STATUS = ?  AND A.TYPE = ?");
        preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        this.setPrepareStatement (preStat, 1, keyWord.trim ());
        this.setPrepareStatement (preStat, 2, GlobalConstant.RECORD_STATUS_ACTIVE);
        this.setPrepareStatement (preStat, 3, DmsRelationalWord.BI_DIRECTION);
        rs = preStat.executeQuery ();
        if (rs != null && rs.next ()) {
            DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
            tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
            tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
            tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
            tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
            tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
            tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
            tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
            tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
            tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
            tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
            tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
            tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
            return (tmpDmsRelationalWord);
        }
        else {
            return null;
        }
    } catch (ApplicationException appEx) {
        throw appEx;
    } catch (SQLException sqle) {
        log.error (sqle, sqle);
        throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
    } catch (Exception e) {
        log.error (e, e);
        throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
    } finally {
        try {
            rs.close ();
        } catch (Exception ignore) {
        } finally {
            rs = null;
        }
        try {
            preStat.close ();
        } catch (Exception ignore) {
        } finally {
            preStat = null;
        }
    }
}


-----Function Pair=391=-----==

public PTask stop (PTask task, SyrupConnection con) throws Exception {
    PreparedStatement s = null;
    ResultSet result = null;
    try {
        s = con.prepareStatementFromCache (sqlImpl ().sqlStatements ().checkWorkerStatement ());
        s.setString (1, task.key ());
        result = s.executeQuery ();
        con.commit ();
        if (result.next ()) {
            String url = result.getString ("worker");
            InputStream i = null;
            try {
                Object b = new URL (url).getContent ();
                if (b instanceof InputStream) {
                    i = (InputStream) b;
                    byte [] bb = new byte [256];
                    int ll = i.read (bb);
                    String k = new String (bb, 0, ll);
                    if (k.equals (task.key ())) {
                        return task;
                    }
                }
            } catch (Exception e) {
            } finally {
                if (i != null) {
                    i.close ();
                }
            }
            PreparedStatement s2 = null;
            s2 = con.prepareStatementFromCache (sqlImpl ().sqlStatements ().resetWorkerStatement ());
            s2.setString (1, task.key ());
            s2.executeUpdate ();
            task = sqlImpl ().queryFunctions ().readPTask (task.key (), con);
            sqlImpl ().loggingFunctions ().log (task.key (), LogEntry.STOPPED, con);
            con.commit ();
        }
    } finally {
        con.rollback ();
        close (result);
    }
    return task;
}


public Vector < Cliente > lista (int id, String pNombre, String pApellido1) throws errorSQL, errorConexionBD {
    Vector < Cliente > v = new Vector < Cliente > ();
    String strSQL = "";
    String strConsulta = "";
    if (id > 0) {
        if (strConsulta.isEmpty ()) {
            strConsulta = "AND cod_cliente = " + id + " ";
        }
        else {
            strConsulta = strConsulta + "AND cod_cliente = " + id + " ";
        }
    }
    if (! pNombre.isEmpty ()) {
        if (strConsulta.isEmpty ()) {
            strConsulta = "AND nombre like '" + pNombre + "' ";
        }
        else {
            strConsulta = strConsulta + "AND nombre like '" + pNombre + "' ";
        }
    }
    if (! pApellido1.isEmpty ()) {
        if (strConsulta.isEmpty ()) {
            strConsulta = "AND apellido1 like '" + pApellido1 + "' ";
        }
        else {
            strConsulta = strConsulta + "AND apellido1 like '" + pApellido1 + "' ";
        }
    }
    strSQL = "SELECT cod_cliente,nif,nombre,apellido1,apellido2," + "direccion,poblacion,telefono,movil,email,cod_Usuario,pasword," + "desactivado,tarjeta_credito,puntos,fecha_baja " + "FROM persona,usuario,cliente " + "WHERE cliente.cod_cliente = usuario.cod_usuario AND " + "cliente.cod_cliente = persona.id AND " + "desactivado = false " + strConsulta + "ORDER BY nif";
    Cliente cli = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        gd.begin ();
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (strSQL);
        while (rs.next ()) {
            cli = new Cliente ();
            cli.setId (rs.getInt ("cod_cliente"));
            cli.setNif (rs.getString ("nif"));
            cli.setNombre (rs.getString ("nombre"));
            cli.setApellido1 (rs.getString ("apellido1"));
            cli.setApellido2 (rs.getString ("apellido2"));
            cli.setDireccion (rs.getString ("direccion"));
            cli.setPoblacion (rs.getString ("poblacion"));
            cli.setTelefono (rs.getString ("telefono"));
            cli.setMovil (rs.getString ("movil"));
            cli.setEmail (rs.getString ("email"));
            cli.setFechaBaja (rs.getDate ("fecha_baja"));
            cli.setCodUsuario (Util.generarCodigo (rs.getInt ("cod_cliente")));
            cli.setTarjetaCredito (rs.getString ("tarjeta_credito"));
            cli.setPuntos (rs.getInt ("puntos"));
            v.add (cli);
        }
        rs.close ();
        stmt.close ();
        gd.commit ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
    return v;
}


-----Function Pair=392=-----==

private PreparedStatement createPreparedStatement (String sql, List < Object > params) throws SQLException {
    assert params != null;
    assert sql != null;
    PreparedStatement pstmt;
    try {
        pstmt = getConnection ().prepareStatement (sql);
    } catch (NullPointerException e) {
        ProblemManager.reportException (e, "Failed to execute SQL statement: '" + sql + "' with parameters: '" + params.toString () + "'");
        return null;
    }
    int i = 1;
    for (Object param : params) {
        if (param instanceof String) {
            pstmt.setString (i, (String) param);
        }
        else if (param instanceof Integer) {
            pstmt.setInt (i, (Integer) param);
        }
        else {
            assert false;
            pstmt.setObject (i, param);
        }
        ++ i;
    }
    return pstmt;
}


public int addPedido (Pedido pe) throws errorConexionBD, errorSQL {
    System.out.println ("GestorPedido.addPedido()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        gd.begin ();
        sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, pe.getIdCliente ());
        pstmt.setInt (2, pe.getIdPromocion ());
        pstmt.setInt (3, pe.getIdProducto ());
        pstmt.setFloat (4, pe.getImporte ());
        if (pe.getFecha () != null) {
            pstmt.setDate (5, new java.sql.Date (pe.getFecha ().getTime ()));
        }
        else {
            pstmt.setNull (5, Types.DATE);
        }
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        gd.commit ();
        System.out.println ("commit");
        pstmt.close ();
        rs.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorPedido.addPedido()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=393=-----==

public void forwardProperty () {
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        Statement stmt = con.createStatement ();
        String boUid = this.getDOBOUid (table);
        if (boUid == null) {
            log.warn ("boUid未制定：" + table + "可能未配置");
            return;
        }
        log.info ("");
        log.info ("正在处理业务对象:" + table);
        log.info ("正在产生业务属性添加语句。。。。。");
        int i = 1;
        for (Iterator itCol = this.getCols (table).iterator (); itCol.hasNext ();) {
            SqlCol sqlCol = (SqlCol) itCol.next ();
            if (! isModify (sqlCol.getName (), boUid)) {
                StringBuffer buffer = new StringBuffer ();
                buffer.append ("insert into DO_BO_Property(objuid,boUid,col_name,prop_name,l10n,dbType,isNull,isModify,order_num,dbSize,readonly) values(").append ("'").append (UUIDHex.getInstance ().generate ()).append ("',").append ("'").append (boUid).append ("',").append ("'").append (sqlCol.getName ()).append ("',").append ("'").append (sqlCol.getName ()).append ("',").append ("'").append (sqlCol.getName ()).append ("',").append (sqlCol.getDataType ()).append (",");
                if (sqlCol.isAllowedNull ()) {
                    buffer.append ("'1'");
                }
                else {
                    buffer.append ("'0'");
                }
                buffer.append (",").append ("'0'");
                buffer.append (",").append (i * 5);
                buffer.append (",").append (sqlCol.getSize ());
                buffer.append (",").append ("'0'");
                buffer.append (")");
                log.info (buffer);
                stmt.addBatch (buffer.toString ());
            }
            i ++;
        }
        log.info ("正在执行添加操作。。。。。");
        stmt.executeBatch ();
        log.info ("操作完成。");
    } catch (SQLException ex) {
        try {
            con.rollback ();
        } catch (SQLException ex2) {
            ex2.printStackTrace ();
        }
        ex.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
}


public ArrayList < Double > getListaPuntosRivales (int idPareo, int idDivision) {
    ArrayList < Double > lstpuntaje = new ArrayList < Double > ();
    double puntaje;
    String sql;
    try {
        sql = " SELECT puntajeTotal " + " FROM jugadorxDivision " + " WHERE divisionxTorneo_idDivisionxTorneo = " + idDivision + " AND numeroId " + "IN (SELECT DISTINCT idPareoRival " + " FROM jugadorxdivxronda, jugadorxDivision  " + " WHERE idPareo = " + idPareo + " AND divisionxTorneo_idDivisionxTorneo = " + idDivision + " AND jugadorxDivision_idJugadorxDivision = idJugadorxDivision)";
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            puntaje = populatePuntaje2 (resultSet);
            lstpuntaje.add (puntaje);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return lstpuntaje;
}


-----Function Pair=394=-----==

public static void test_irregular_form (PrintWriter out) {
    try {
        clearTables ();
        LanguageMorphologyTable languageTable = new LanguageMorphologyTable ();
        languageTable.add ("English", "plural", "child", "children");
        languageTable.add ("English", "plural", "*ch", "*ches");
        Collection recog = languageTable.recognize ("English", "children");
        if (recog.size () != 1) throw new Exception ("Recognizing 'children' produced " + recog.size () + ", not 1 result");
        Iterator it = recog.iterator ();
        MorphologyRecognizeMatch match = (MorphologyRecognizeMatch) it.next ();
        if (match.getRootString ().equals ("child") == false) throw new Exception ("Recognizing 'children' produced '" + match.getRootString () + "', not 'child'");
        Vector expTags = new Vector ();
        expTags.add ("plural");
        if (expTags.containsAll (match.getMorphologyTags ()) == false) throw new Exception ("Tags vectors did not match");
        String surface = languageTable.generate ("English", "plural", "child");
        if (surface.equals ("children") == false) throw new Exception ("Generating plural of 'child' produced '" + surface + "', not 'children'");
        testPassed (out);
    } catch (Exception e) {
        testFailed (e, out);
    }
}


public Collection < Cliente > listaPorNomre (String nombre) throws errorSQL {
    Vector < Cliente > v = new Vector < Cliente > ();
    Cliente cli = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        stmt = gd.getConexion ().createStatement ();
        String sql = "SELECT id, nif, nombre, apellido1, apellido2," + " direccion, poblacion, telefono, movil, email, fecha_baja, " + "cod_cliente, tarjeta_credito, puntos " + "FROM cliente,persona " + "WHERE id = cod_cliente AND nombre = '" + nombre + "'";
        System.out.println ("Ejecutando: \n" + sql);
        rs = stmt.executeQuery (sql);
        while (rs.next ()) {
            cli = new Cliente ();
            cli.setNif (rs.getString ("nif"));
            cli.setNombre (rs.getString ("nombre"));
            cli.setApellido1 (rs.getString ("apellido1"));
            cli.setApellido2 (rs.getString ("apellido2"));
            cli.setDireccion (rs.getString ("direccion"));
            cli.setPoblacion (rs.getString ("poblacion"));
            cli.setTelefono (rs.getString ("telefono"));
            cli.setMovil (rs.getString ("movil"));
            cli.setEmail (rs.getString ("email"));
            cli.setFechaBaja (rs.getDate ("fecha_baja"));
            cli.setTarjetaCredito (rs.getString ("tarjeta_credito"));
            cli.setPuntos (rs.getInt ("puntos"));
            v.add (cli);
        }
        rs.close ();
        stmt.close ();
    } catch (SQLException e) {
        throw new errorSQL (e.toString ());
    }
    return v;
}


-----Function Pair=395=-----==

public static String getMyMacAddress1 () throws SocketException, UnknownHostException {
    InetAddress ip = InetAddress.getByName ("192.168.0.12");
    System.out.println (ip.getHostAddress ());
    NetworkInterface network = NetworkInterface.getByInetAddress (ip);
    byte [] mac = network.getHardwareAddress ();
    String macStr = "";
    for (int i = 0; i < mac.length; i ++) {
        int a = mac [i] & 0xFF;
        if (a > 15) macStr += Integer.toHexString (a);
        else macStr += "0" + Integer.toHexString (a);
        if (i < (mac.length - 1)) {
            macStr += "-";
        }
    }
    return macStr;
}


private void processNewRoles (DatabaseAdapter db, List < RoleEditableBean > roles, Long authUserId) throws Exception {
    log.info ("Start insert new roles for authUserId: " + authUserId + ", roles list: " + roles);
    PreparedStatement ps = null;
    try {
        if (roles == null) {
            log.info ("Role list is null, return.");
            return;
        }
        for (RoleEditableBean role : roles) {
            log.info ("Role: " + role.getName () + ", id: " + role.getRoleId () + ", new: " + role.isNew () + ", delete: " + role.isDelete ());
            if (! role.isNew () || role.isDelete ()) {
                log.info ("Skip this role");
                continue;
            }
            CustomSequenceType seq = new CustomSequenceType ();
            seq.setSequenceName ("seq_WM_AUTH_RELATE_ACCGROUP");
            seq.setTableName ("WM_AUTH_RELATE_ACCGROUP");
            seq.setColumnName ("ID_RELATE_ACCGROUP");
            Long id = db.getSequenceNextValue (seq);
            ps = db.prepareStatement ("insert into WM_AUTH_RELATE_ACCGROUP " + "(ID_RELATE_ACCGROUP, ID_ACCESS_GROUP, ID_AUTH_USER ) " + "values" + "(?, ?, ? ) ");
            ps.setLong (1, id);
            ps.setLong (2, role.getRoleId ());
            ps.setLong (3, authUserId);
            ps.executeUpdate ();
            ps.close ();
            ps = null;
        }
    } finally {
        DatabaseManager.close (ps);
        ps = null;
        log.info ("End add roles");
    }
}


-----Function Pair=396=-----==

private boolean getRelateHoldingCompany (DatabaseAdapter ora_, Long companyId, Long holdingId) throws Exception {
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        ps = ora_.prepareStatement ("select null COUNT_REC from WM_LIST_R_HOLDING_COMPANY " + "where ID_COMPANY=? and ID_HOLDING=?");
        ps.setObject (1, companyId);
        ps.setObject (2, holdingId);
        rs = ps.executeQuery ();
        return rs.next ();
    } catch (Exception e) {
        log.error ("Error getRelateServiceFirm", e);
        throw e;
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


protected boolean delete (Long photoId) {
    String q = "delete from PhotoEn obj where obj.photoId=:photoId";
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        Query query = em.createQuery (q);
        query.setParameter ("photoId", photoId);
        tx.begin ();
        int result = query.executeUpdate ();
        tx.commit ();
        return (result >= 1);
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=397=-----==

public void testUpdateSetNullUnionSubclass () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("update Vehicle set owner = 'Steve'").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    count = s.createQuery ("update Vehicle set owner = null where owner = 'Steve'").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    count = s.createQuery ("delete Vehicle where owner is null").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    t.commit ();
    s.close ();
    data.cleanup ();
}


public void testAsQuery () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " AS T").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=398=-----==

private void processNewRoles (DatabaseAdapter db, List < RoleEditableBean > roles, Long authUserId) throws Exception {
    log.info ("Start insert new roles for authUserId: " + authUserId + ", roles list: " + roles);
    PreparedStatement ps = null;
    try {
        if (roles == null) {
            log.info ("Role list is null, return.");
            return;
        }
        for (RoleEditableBean role : roles) {
            log.info ("Role: " + role.getName () + ", id: " + role.getRoleId () + ", new: " + role.isNew () + ", delete: " + role.isDelete ());
            if (! role.isNew () || role.isDelete ()) {
                log.info ("Skip this role");
                continue;
            }
            CustomSequenceType seq = new CustomSequenceType ();
            seq.setSequenceName ("seq_WM_AUTH_RELATE_ACCGROUP");
            seq.setTableName ("WM_AUTH_RELATE_ACCGROUP");
            seq.setColumnName ("ID_RELATE_ACCGROUP");
            Long id = db.getSequenceNextValue (seq);
            ps = db.prepareStatement ("insert into WM_AUTH_RELATE_ACCGROUP " + "(ID_RELATE_ACCGROUP, ID_ACCESS_GROUP, ID_AUTH_USER ) " + "values" + "(?, ?, ? ) ");
            ps.setLong (1, id);
            ps.setLong (2, role.getRoleId ());
            ps.setLong (3, authUserId);
            ps.executeUpdate ();
            ps.close ();
            ps = null;
        }
    } finally {
        DatabaseManager.close (ps);
        ps = null;
        log.info ("End add roles");
    }
}


public List findByAsignatura (Asignatura asignatura) {
    List lista = new ArrayList ();
    Criteria criteria = null;
    try {
        Session session = HibernateUtil.currentSession ();
        Asignatura asig = (Asignatura) session.get (Asignatura.class, asignatura.getCodAsig ());
        criteria = session.createCriteria (Examen.class);
        criteria.add (Restrictions.eq ("asignatura", asig));
        lista = criteria.list ();
    } catch (HibernateException e) {
        log.error ("_____Error al obtener los registros de la clase Examen para la asignatura: " + asignatura.getNombreAsig (), e);
        throw new HibernateException (e);
    }
    return lista;
}


-----Function Pair=399=-----==

public int addPedido (Pedido pe) throws errorConexionBD, errorSQL {
    System.out.println ("GestorPedido.addPedido()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        gd.begin ();
        sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, pe.getIdCliente ());
        pstmt.setInt (2, pe.getIdPromocion ());
        pstmt.setInt (3, pe.getIdProducto ());
        pstmt.setFloat (4, pe.getImporte ());
        if (pe.getFecha () != null) {
            pstmt.setDate (5, new java.sql.Date (pe.getFecha ().getTime ()));
        }
        else {
            pstmt.setNull (5, Types.DATE);
        }
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        gd.commit ();
        System.out.println ("commit");
        pstmt.close ();
        rs.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorPedido.addPedido()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


public String render (Transferable transferable) {
    Object object = null;
    try {
        if (transferable != null) {
            object = transferable.getTransferData (DBEntityDataFlavor.dbEntityDataFlavor ());
            DBEntity entity = (DBEntity) object;
            SingleTableSelectStatement st = new SingleTableSelectStatement (entity);
            try {
                return SQLFormatter.format (st.getSelectString (this.conn.getMetaData ())) + ";";
            } catch (Exception e1) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e1, "Exception caught while dropping");
            }
        }
    } catch (UnsupportedFlavorException e) {
        try {
            return transferable.getTransferData (DataFlavor.stringFlavor).toString () + ";";
        } catch (UnsupportedFlavorException e1) {
            try {
                DataFlavor [] f = transferable.getTransferDataFlavors ();
                if (f != null && f.length > 0) return transferable.getTransferData (f [0]).toString ();
                else return "";
            } catch (UnsupportedFlavorException e2) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e2, "Exception caught while dropping");
            } catch (IOException e3) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e3, "Exception caught while dropping");
            }
        } catch (IOException e4) {
            ExceptionManagerFactory.getExceptionManager ().manageException (e4, "Exception caught while dropping");
        }
    } catch (IOException e5) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e5, "Exception caught while dropping");
    }
    return "";
}


-----Function Pair=400=-----==

public List < RoleBean > getUserRoleList (AuthSession authSession) {
    DatabaseAdapter db = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        db = DatabaseAdapter.getInstance ();
        ps = db.prepareStatement ("select c.ID_ACCESS_GROUP, c.NAME_ACCESS_GROUP " + "from   WM_AUTH_ACCESS_GROUP c, WM_AUTH_RELATE_ACCGROUP b " + "where  b.ID_AUTH_USER=? and b.ID_ACCESS_GROUP=c.ID_ACCESS_GROUP ");
        ps.setLong (1, authSession.getAuthInfo ().getAuthUserId ());
        rs = ps.executeQuery ();
        List < RoleBean > roles = new ArrayList < RoleBean > ();
        while (rs.next ()) {
            RoleBeanImpl roleImpl = new RoleBeanImpl ();
            roleImpl.setName (RsetTools.getString (rs, "NAME_ACCESS_GROUP"));
            roleImpl.setRoleId (RsetTools.getLong (rs, "ID_ACCESS_GROUP"));
            roles.add (roleImpl);
        }
        return roles;
    } catch (Exception e) {
        String es = "error";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


public String selJobLog (String userObj, String checkType, String objType) throws Exception {
    StringBuffer html = new StringBuffer ("");
    String strSql = "select OA.check_id userObj,T.user_name from COFFICE_JOBLOG_CHECKAUTH OA,T_SYS_USER T where" + " OA.user_id = ? and OA.check_type = ? and OA.obj_type = ? and oa.check_id = T.user_id";
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preStm = null;
    ResultSet ret = null;
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        preStm = connection.prepareStatement (strSql);
        preStm.setInt (1, Integer.parseInt (userObj));
        preStm.setInt (2, Integer.parseInt (checkType));
        preStm.setInt (3, Integer.parseInt (objType));
        ret = preStm.executeQuery ();
        while (ret.next ()) {
            html.append ("<option value=" + ret.getString (1) + ">").append (ret.getString (2)).append ("</option>");
        }
    } catch (Exception ex) {
        log.debug ((new Date ().toString ()) + " ������Ȩ��ʧ��! ");
        throw ex;
    } finally {
        close (ret, null, preStm, connection, dbo);
    }
    return html.toString ();
}


