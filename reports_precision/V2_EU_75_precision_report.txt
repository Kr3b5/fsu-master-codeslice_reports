Found 7/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public void commandStackChanged (EventObject event) {
    if (((CommandStack) event.getSource ()).isDirty ()) {
        setDirty (true);
    }
    else {
        boolean oneIsDirty = false;
        for (Iterator stacks = commandStacks.iterator (); stacks.hasNext ();) {
            CommandStack stack = (CommandStack) stacks.next ();
            if (stack.isDirty ()) {
                oneIsDirty = true;
                break;
            }
        }
        setDirty (oneIsDirty);
    }
}


public VisualizerFrame () {
    super ("Viewer");
    log.debug ("Constructing VisualizerFrame");
    this.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE);
    this.addWindowListener (this);
    this.addComponentListener (this);
    content = this.getContentPane ();
    content.setLayout (new BorderLayout ());
    glass = (JPanel) getGlassPane ();
    Date date = new Date (System.currentTimeMillis ());
    SimpleDateFormat sdf = new SimpleDateFormat ("HH:mm:ss");
    this.setWindowName ("Viewer_" + sdf.format (date));
    waitPanel = new WaitPanel ();
    idSet = new UniqueIDSet ();
}


-----Function Pair=2=-----==

public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (EJBTool.persistent.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, EJBTool.persistent.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            EJBTool.Root model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, EJBTool.persistent.edit.parts.PersistentViewEditPart.MODEL_ID, EJBTool.persistent.part.EJBToolDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (EJBTool.persistent.part.EJBToolDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (EJBTool.persistent.part.EJBToolDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                EJBTool.persistent.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        EJBTool.persistent.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=3=-----==

public static Resource createDiagram (URI diagramURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.MMUnitDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.MMUnitDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            de.hu_berlin.sam.mmunit.TestModel model = createInitialModel ();
            attachModelToResource (model, diagramResource);
            Diagram diagram = ViewService.createDiagram (model, TestModelEditPart.MODEL_ID, MMUnitDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                diagramResource.save (hub.metrik.lang.eprovide.usertrace.step.diagram.part.MMUnitDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                MMUnitDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        MMUnitDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


protected void initializeOverview () {
    LightweightSystem lws = new LightweightSystem (overview);
    RootEditPart rep = getGraphicalViewer ().getRootEditPart ();
    if (rep instanceof ScalableFreeformRootEditPart) {
        ScalableFreeformRootEditPart root = (ScalableFreeformRootEditPart) rep;
        thumbnail = new ScrollableThumbnail ((Viewport) root.getFigure ());
        thumbnail.setBorder (new MarginBorder (3));
        thumbnail.setSource (root.getLayer (LayerConstants.PRINTABLE_LAYERS));
        lws.setContents (thumbnail);
        disposeListener = new DisposeListener () {
            public void widgetDisposed (DisposeEvent e) {
                if (thumbnail != null) {
                    thumbnail.deactivate ();
                    thumbnail = null;
                }
            }
        }
        ;
        getEditor ().addDisposeListener (disposeListener);
    }
}


-----Function Pair=4=-----==

public void doSaveAs () {
    if (! isValidDiagram ()) {
        return;
    }
    Shell shell = getSite ().getShell ();
    IPath path;
    final Object opFile;
    if (file instanceof IFile) {
        SaveAsDialog saveAsDialog = new SaveAsDialog (shell);
        saveAsDialog.setOriginalFile ((IFile) file);
        if (saveAsDialog.open () != 0) {
            return;
        }
        path = saveAsDialog.getResult ();
        if (path == null) {
            return;
        }
        opFile = getWorkspaceRoot ().getFile (path);
    }
    else {
        FileDialog fileDialog = new FileDialog (shell);
        fileDialog.setText ("Save As");
        fileDialog.setFilterPath (((File) file).getPath ());
        fileDialog.setFileName (((File) file).getName ());
        String filePath = fileDialog.open ();
        if (filePath == null) {
            return;
        }
        path = new Path (filePath);
        opFile = path.toFile ();
    }
    IEditorInput editorInput = EditorInputFactory.getEditorInput (opFile);
    WorkspaceModifyOperation modifyOperation = new WorkspaceModifyOperation () {
        public void execute (IProgressMonitor iprogressmonitor) throws CoreException {
            storeToXMLFile (opFile);
        }
    }
    ;
    try {
        editorSaving = true;
        (new ProgressMonitorDialog (getSite ().getShell ())).run (false, false, modifyOperation);
        setInput (editorInput);
        getGraphicalViewer ().setContents (diagram);
        flushStack ();
        actionActivity = false;
        getCommandStack ().markSaveLocation ();
    } catch (Exception exception) {
    } finally {
        editorSaving = false;
    }
    return;
}


public void run () {
    IWorkbench workbench = PlatformUI.getWorkbench ();
    IWorkbenchWindow window = workbench.getWorkbenchWindows () [0];
    IEditorPart editeurActif = window.getActivePage ().getActiveEditor ();
    if (editeurActif instanceof ServiceEditor) {
        if (((ServiceEditor) editeurActif).isDirty ()) {
            ISxSRepository < Service > oldRepository = ((ServiceEditor) editeurActif).getRepository ();
            boolean major = ((ServiceEditor) editeurActif).isMajor ();
            boolean minor = ((ServiceEditor) editeurActif).isMinor ();
            editeurActif.doSave (null);
            if (! ((ServiceEditor) editeurActif).getKeepVersion ().getSelection () && (major || minor)) {
                try {
                    Service newService = ((ServiceEditor) editeurActif).getService ();
                    if (Application.getCurrentServiceRepository () == oldRepository) {
                        ServiceEditor newEditor = (ServiceEditor) window.getActivePage ().openEditor (new ServiceEditorInput (newService.getSelfSxSReference ()), ServiceEditor.ID);
                        window.getActivePage ().activate (newEditor);
                        IWorkbenchPage page = window.getActivePage ();
                        IEditorReference [] tabEditorsRefs = page.getEditorReferences ();
                        for (IEditorReference refEditor : tabEditorsRefs) {
                            IEditorPart editor = refEditor.getEditor (false);
                            if ((editor instanceof ServiceEditor) && (! editor.equals (newEditor))) {
                                Service s = ((ServiceEditor) editor).getService ();
                                if (s.getId ().equals (newService.getId ()) && s.getVersion ().equals (newService.getVersion ())) {
                                    page.closeEditor (editor, false);
                                }
                            }
                        }
                        newEditor.getKeepVersion ().setSelection (true);
                    }
                    else {
                        if (Application.isConnected ()) {
                            System.out.println ("PCREATOR - Veuillez vous déconnecter pour ouvrir le nouveau service");
                            MessageBox messageBox = new MessageBox (PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getShell (), SWT.OK | SWT.ICON_INFORMATION);
                            messageBox.setText ("Information");
                            messageBox.setMessage ("Nouveau service créé avec succès. Veuillez vous déconnecter pour l'ouvrir.");
                            messageBox.open ();
                        }
                        else {
                            System.out.println ("PCREATOR - Veuillez vous connecter pour ouvrir le nouveau service");
                            MessageBox messageBox = new MessageBox (PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getShell (), SWT.OK | SWT.ICON_INFORMATION);
                            messageBox.setText ("Information");
                            messageBox.setMessage ("Nouveau service créé avec succès. Veuillez vous connecter pour l'ouvrir.");
                            messageBox.open ();
                        }
                    }
                    window.getActivePage ().closeEditor (editeurActif, false);
                } catch (PartInitException e) {
                    e.printStackTrace ();
                }
            }
        }
        else {
            System.out.println ("PCREATOR - Aucune modification à sauvegarder");
        }
    }
}


-----Function Pair=5=-----==

protected void doGotoMarker (IMarker marker) {
    String elementId = marker.getAttribute (org.eclipse.gmf.runtime.common.core.resources.IMarker.ELEMENT_ID, null);
    if (elementId == null || ! (getEditor () instanceof DiagramEditor)) {
        return;
    }
    DiagramEditor editor = (DiagramEditor) getEditor ();
    Map editPartRegistry = editor.getDiagramGraphicalViewer ().getEditPartRegistry ();
    EObject targetView = editor.getDiagram ().eResource ().getEObject (elementId);
    if (targetView == null) {
        return;
    }
    EditPart targetEditPart = (EditPart) editPartRegistry.get (targetView);
    if (targetEditPart != null) {
        de.nordakademie.lejos.stateMachine.diagram.part.StateMachineDiagramEditorUtil.selectElementsInDiagram (editor, Arrays.asList (new EditPart [] {targetEditPart}));
    }
}


public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


-----Function Pair=6=-----==

public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.SystemDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.SystemDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            System model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, SystemEditPart.MODEL_ID, SystemDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (org.eclipse.epsilon.fptc.system.diagram.part.SystemDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (org.eclipse.epsilon.fptc.system.diagram.part.SystemDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                SystemDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        SystemDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=7=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.DrlModelDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.DrlModelDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            FinalInfProduct model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, FinalInfProductEditPart.MODEL_ID, DrlModelDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (org.spbu.pldoctoolkit.graph.diagram.fproduct.part.DrlModelDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (org.spbu.pldoctoolkit.graph.diagram.fproduct.part.DrlModelDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                DrlModelDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        DrlModelDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (EJBTool.persistent.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, EJBTool.persistent.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            EJBTool.Root model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, EJBTool.persistent.edit.parts.PersistentViewEditPart.MODEL_ID, EJBTool.persistent.part.EJBToolDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (EJBTool.persistent.part.EJBToolDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (EJBTool.persistent.part.EJBToolDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                EJBTool.persistent.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        EJBTool.persistent.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=8=-----==

public static BufferedImage convertRenderedImage (RenderedImage img) {
    if (img instanceof BufferedImage) {
        return (BufferedImage) img;
    }
    ColorModel cm = img.getColorModel ();
    int width = img.getWidth ();
    int height = img.getHeight ();
    WritableRaster raster = cm.createCompatibleWritableRaster (width, height);
    boolean isAlphaPremultiplied = cm.isAlphaPremultiplied ();
    Hashtable properties = new Hashtable ();
    String [] keys = img.getPropertyNames ();
    if (keys != null) {
        for (int i = 0; i < keys.length; i ++) {
            properties.put (keys [i], img.getProperty (keys [i]));
        }
    }
    BufferedImage result = new BufferedImage (cm, raster, isAlphaPremultiplied, properties);
    img.copyData (raster);
    return result;
}


private boolean fillInformation (Class testClass, String interName, PortTypeInfo portTypeInfo, Object implementor, boolean isEventHandler, boolean doAddToSupportedTypes) throws DPWSException {
    if (testClass != null && (testClass.getName ().equals (interName) || interName.equals ("java.lang.reflect.InvocationHandler"))) {
        if (! eventSource && ! isEventHandler && portTypeInfo.isEventSource ()) {
            eventSource = true;
            synchronized (eventSubscriptions) {
                eventSubscriptions.clear ();
            }
            WSDLInfo wsdlInfo = EventingWSDLInfoFactory.getWSDLInfo ("");
            Iterator it = wsdlInfo.getPortTypeInfos ().iterator ();
            while (it.hasNext ()) {
                PortTypeInfo pti = (PortTypeInfo) it.next ();
                Iterator itPti = pti.getOperations ().iterator ();
                while (itPti.hasNext ()) {
                    OperationInfo aoi = (OperationInfo) itPti.next ();
                    invokationMap.put (aoi.getInAction (), aoi);
                }
            }
        }
        if (doAddToSupportedTypes) this.supportedTypes.add (portTypeInfo.getName ());
        Collection operations = portTypeInfo.getOperations ();
        for (Iterator it = operations.iterator (); it.hasNext ();) {
            OperationInfo aoi = (OperationInfo) it.next ();
            if (aoi.isEvent () == isEventHandler) {
                invokationMap.put (isEventHandler ? aoi.getOutAction () : aoi.getInAction (), aoi);
                actionToImplementor.put (isEventHandler ? aoi.getOutAction () : aoi.getInAction (), implementor);
                operationMap.put (aoi.getName (), aoi);
            }
        }
        portTypeInfos.add (portTypeInfo);
        return true;
    }
    return false;
}


-----Function Pair=9=-----==

public QueryAtomContainer (IAtomContainer container) {
    this.atomCount = container.getAtomCount ();
    this.bondCount = container.getBondCount ();
    this.lonePairCount = container.getLonePairCount ();
    this.singleElectronCount = container.getSingleElectronCount ();
    this.atoms = new IAtom [this.atomCount];
    this.bonds = new IBond [this.bondCount];
    this.lonePairs = new ILonePair [this.lonePairCount];
    this.singleElectrons = new ISingleElectron [this.singleElectronCount];
    stereoElements = new ArrayList < IStereoElement > (atomCount / 2);
    for (int f = 0; f < container.getAtomCount (); f ++) {
        atoms [f] = container.getAtom (f);
        container.getAtom (f).addListener (this);
    }
    for (int f = 0; f < this.bondCount; f ++) {
        bonds [f] = container.getBond (f);
        container.getBond (f).addListener (this);
    }
    for (int f = 0; f < this.lonePairCount; f ++) {
        lonePairs [f] = container.getLonePair (f);
        container.getLonePair (f).addListener (this);
    }
    for (int f = 0; f < this.singleElectronCount; f ++) {
        singleElectrons [f] = container.getSingleElectron (f);
        container.getSingleElectron (f).addListener (this);
    }
}


private boolean processData (RdpPacket_Localised data, int [] ext_disc_reason) throws RdesktopException, OrderException {
    int data_type, ctype, clen, len, roff, rlen;
    data_type = 0;
    data.incrementPosition (6);
    len = data.getLittleEndian16 ();
    data_type = data.get8 ();
    ctype = data.get8 ();
    clen = data.getLittleEndian16 ();
    clen -= 18;
    switch (data_type) {
        case (Rdp.RDP_DATA_PDU_UPDATE) :
            logger.debug ("Rdp.RDP_DATA_PDU_UPDATE");
            this.processUpdate (data);
            break;
        case RDP_DATA_PDU_CONTROL :
            logger.debug (("Received Control PDU\n"));
            break;
        case RDP_DATA_PDU_SYNCHRONISE :
            logger.debug (("Received Sync PDU\n"));
            break;
        case (Rdp.RDP_DATA_PDU_POINTER) :
            logger.debug ("Received pointer PDU");
            this.processPointer (data);
            break;
        case (Rdp.RDP_DATA_PDU_BELL) :
            logger.debug ("Received bell PDU");
            break;
        case (Rdp.RDP_DATA_PDU_LOGON) :
            logger.debug ("User logged on");
            break;
        case RDP_DATA_PDU_DISCONNECT :
            ext_disc_reason [0] = processDisconnectPdu (data);
            logger.debug (("Received disconnect PDU\n"));
            return true;
        default :
            logger.warn ("Unimplemented Data PDU type " + data_type);
    }
    return false;
}


-----Function Pair=10=-----==

private int nextLesserThan8Bits (int bitsToGet) {
    byte b, next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = data [bp + 1];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
        }
    }
    else {
        throw new RuntimeException (MessageLocalization.getComposedMessage ("tiff.fill.order.tag.must.be.either.1.or.2"));
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int shift = bitsLeft - bitsToGet;
    int i1, i2;
    if (shift >= 0) {
        i1 = (b & table1 [bitsLeft])>>> shift;
        bitPointer += bitsToGet;
        if (bitPointer == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
    }
    else {
        i1 = (b & table1 [bitsLeft]) << (- shift);
        i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
        i1 |= i2;
        bytePointer ++;
        bitPointer = bitsFromNextByte;
    }
    return i1;
}


public void inLineEdit (final TableTreeEditor editor) {
    Control oldEditor = editor.getEditor ();
    if (oldEditor != null) oldEditor.dispose ();
    TableTreeItem [] selection = listEpsTree.getSelection ();
    if (selection.length == 0) return;
    final TableTreeItem item = selection [0];
    final Text text = new Text (listEpsTree.getTable (), SWT.NONE);
    editor.horizontalAlignment = SWT.LEFT;
    editor.grabHorizontal = true;
    editor.setEditor (text, item, 1);
    text.setText (item.getText (1));
    text.setFocus ();
    text.addKeyListener (new KeyListener () {
        public void keyPressed (KeyEvent e) {
            int escPressed = 0;
            switch (e.character) {
                case SWT.CR :
                    escPressed = 1;
                    break;
            }
            if (escPressed == 1) {
                lines [1] = item.getText (0);
                lines [2] = text.getText ();
                epiMaker = new EpiMaker ();
                epiMaker.commentWriter (pluginInterface, lines);
                Control oldEditor = editor.getEditor ();
                if (oldEditor != null) {
                    oldEditor.dispose ();
                }
                if (! item.isDisposed ()) item.setText (1, lines [2]);
            }
        } public void keyReleased (KeyEvent e) {
        }
    }
    );
}


-----Function Pair=11=-----==

public boolean processCommand (String [] cmdArgs, ORB orb, PrintStream out) {
    int serverId = illegalServerId;
    try {
        if (cmdArgs.length == 2) {
            if (cmdArgs [0].equals ("-serverid")) serverId = (Integer.valueOf (cmdArgs [1])).intValue ();
            else if (cmdArgs [0].equals ("-applicationName")) serverId = ServerTool.getServerIdForAlias (orb, cmdArgs [1]);
        }
        if (serverId == illegalServerId) return parseError;
        try {
            Activator activator = ActivatorHelper.narrow (orb.resolve_initial_references (ORBConstants.SERVER_ACTIVATOR_NAME));
            activator.uninstall (serverId);
        } catch (ServerHeldDown ex) {
        }
        Repository repository = RepositoryHelper.narrow (orb.resolve_initial_references (ORBConstants.SERVER_REPOSITORY_NAME));
        repository.unregisterServer (serverId);
        out.println (CorbaResourceUtil.getText ("servertool.unregister2"));
    } catch (ServerNotRegistered ex) {
        out.println (CorbaResourceUtil.getText ("servertool.nosuchserver"));
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return commandDone;
}


public static String getHiStyleName (final String styleName) {
    for (final String item : hiStyleNameList) {
        if (item.length () == styleName.length ()) {
            final String cp1 = sort (item);
            final String cp2 = sort (styleName);
            if (cp1.equals (cp2)) {
                return item;
            }
            else {
                continue;
            }
        }
        else {
            continue;
        }
    }
    hiStyleNameList.add (styleName);
    return styleName;
}


-----Function Pair=12=-----==

public void refresh_border (int ft) {
    if (ft < refrb_t) {
        return;
    }
    border_solid = - 1;
    int t = refrb_t;
    int b = canonic [border << 11];
    int p = refrb_p;
    int x = refrb_x;
    int r = refrb_r;
    loop : do {
        if ((refrb_y < 0) || (refrb_y >= pixelsY)) {
            do {
                if (screen [p] != b) {
                    screen [p] = b;
                    brdchg_ud |= r;
                }
                p ++;
                t += 4;
                if (++ x < (SCREENCOLS + Mh)) {
                    continue;
                }
                x = - Mh;
                t += (224 - (4 * (Mh + SCREENCOLS + Mh)));
                if ((++ refrb_y & 7) != 0) {
                    continue;
                }
                if (refrb_y == 0) {
                    r = 1;
                    continue loop;
                }
                else if (refrb_y == (pixelsY + (8 * Mv))) {
                    t = 99999;
                    break loop;
                }
                r <<= 1;
            }
            while (ft >= t);
            break;
        }
        for (;;) {
            if (x < 0) {
                for (;;) {
                    if (screen [p] != b) {
                        screen [p] = b;
                        brdchg_l |= r;
                    }
                    p ++;
                    t += 4;
                    if (++ x == 0) {
                        break;
                    }
                    if (ft < t) {
                        break loop;
                    }
                }
                x = SCREENCOLS;
                p += SCREENCOLS;
                t += (4 * SCREENCOLS);
                if (ft < t) {
                    break loop;
                }
            }
            for (;;) {
                if (screen [p] != b) {
                    screen [p] = b;
                    brdchg_r |= r;
                }
                p ++;
                t += 4;
                if (++ x == (SCREENCOLS + Mh)) {
                    break;
                }
                if (ft < t) {
                    break loop;
                }
            }
            x = - Mh;
            t += (224 - (4 * (Mh + SCREENCOLS + Mh)));
            if ((++ refrb_y & 7) == 0) {
                if (refrb_y == pixelsY) {
                    r = 1 << Mv;
                    continue loop;
                }
                r <<= 1;
            }
            if (ft < t) {
                break loop;
            }
        }
    }
    while (ft >= t);
    refrb_r = r;
    refrb_x = x;
    refrb_p = p;
    refrb_t = t;
}


protected double logSumExp (double [] a, int start, int end) {
    double max = - Double.MAX_VALUE;
    for (int i = start; i < end; i ++) {
        if (a [i] >= max) {
            max = a [i];
        }
    }
    double e = 0;
    for (int i = start; i < end; i ++) {
        if (! Double.isNaN (a [i])) {
            e += Math.exp (a [i] - max);
        }
    }
    return e > 0 ? max + Math.log (e) : Double.NaN;
}


-----Function Pair=13=-----==

public void load (File file) {
    try {
        if (! file.exists ()) {
            return;
        }
        FileInputStream fis = new FileInputStream (file);
        ObjectInputStream ois = new ObjectInputStream (fis);
        Object obj = ois.readObject ();
        ois.close ();
        fis.close ();
        if (BrowsingController.class.isInstance (obj)) {
            final BrowsingController browsingCtrl = (BrowsingController) obj;
            BrowsingInstance browsingInst = new BrowsingInstance (browsingCtrl);
            BrowsingPanel bp = browsingInst.getBrowsingPanel ();
            try {
                bp.display ();
            } catch (SQLException ex) {
                GuiController.getInstance ().displayException (ex, "Error loading saved browsing");
                Logger.getLogger (MainWindow.class.getName ()).log (Level.SEVERE, "Error loading saved browsing", ex);
            }
            gui.addTab ("Browsing", bp);
            GuiController.getInstance ().gui.validate ();
        }
        else {
            throw new IOException ("Wrong file format!");
        }
    } catch (IOException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


private static byte [] defineNestedVisitorParent (String interfName, Type enclosingType, List adaptiveRules, List testMethods) {
    ClassGen cg = new ClassGen (interfName, Object.class.getName (), "<generated>", ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT, null);
    ConstantPoolGen cp = cg.getConstantPool ();
    if (false == adaptiveRules.isEmpty ()) {
        Type [] arg_types = {new ArrayType (enclosingType, 1)};
        for (Iterator i = adaptiveRules.iterator (); i.hasNext ();) {
            final Field ruleField = (Field) i.next ();
            cg.addMethod (new MethodGen (ACC_PUBLIC | ACC_ABSTRACT, Type.VOID, arg_types, null, ruleField.getName (), interfName, null, cp).getMethod ());
        }
    }
    if (false == testMethods.isEmpty ()) {
        VisitorMethodArgtypesFactory argsFactory = new VisitorMethodArgtypesFactory (enclosingType);
        for (Iterator i = testMethods.iterator (); i.hasNext ();) {
            final Method m = (Method) i.next ();
            MethodGen mg = new MethodGen (ACC_PUBLIC | ACC_ABSTRACT, Type.getType (m.getReturnType ()), argsFactory.asVisitorMethodArgtypes (m.getParameterTypes ()), null, m.getName (), interfName, null, cp);
            if (0 < m.getExceptionTypes ().length) {
                mg.addException (Throwable.class.getName ());
            }
            cg.addMethod (mg.getMethod ());
        }
    }
    return cg.getJavaClass ().getBytes ();
}


-----Function Pair=14=-----==

public WordsEnumerator (IRebus rebus, RebusEnumerator enumerator) {
    AbstractWord [] words = new AbstractWord [rebus.getVisibleWords ().size ()];
    int k = 0;
    for (VisibleWord word : rebus.getVisibleWords ()) {
        words [k ++] = word.getElement ();
    }
    for (int j = 0; j < words.length; j ++) {
        for (int i = 0; i < words.length - 1; i ++) {
            if (words [i].compareTo (words [i + 1]) == - 1) {
                AbstractWord w = words [i];
                words [i] = words [i + 1];
                words [i + 1] = w;
            }
        }
    }
    myEnumerator = enumerator;
    myRebus = rebus;
    myWords = words;
    myHelpers = new EnumHelper [words.length];
}


protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getBlue ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


-----Function Pair=15=-----==

public static void runJob (String [] args) {
    if (m_bDebug) System.out.println ("JobWrapper::runJob(): jobclass=" + args [0]);
    Class < AbstractJob > cJob = getJobClass (args [0]);
    if (cJob != null) {
        AbstractJob job = getJobObject (cJob, getJobArgs (args));
        if (job != null) {
            if (job.isValid ()) {
                System.setProperty ("java.security.policy", ".policy");
                System.out.println ("-Djava.security.policy=" + System.getProperty ("java.security.policy"));
                String sLocal = System.getProperty ("local.space");
                boolean bLocal = (sLocal != null ? Boolean.parseBoolean (sLocal) : false);
                JobWrapper jw = new JobWrapper (bLocal);
                SpaceProxy proxy = jw.getProxy ();
                if (proxy != null) {
                    job.setId (UuidFactory.generate ());
                    SpaceJobRunner jr = new SpaceJobRunner (proxy, job);
                    jr.start ();
                }
            }
            else {
                System.err.println ("JobWrapper::runJob(): invalid job params");
            }
        }
        else {
            System.err.println ("JobWrapper::runJob(): null job object");
        }
    }
    else {
        System.err.println ("JobWrapper::runJob(): job class not found");
    }
}


public int promote (Move move, int num) {
    if (num < 0) throw new IllegalArgumentException ("cannot perform negative promotion");
    Move tmp = null;
    int newIndex = 0;
    int oldIndex = getIndex (move);
    if (oldIndex == - 1) throw new NullPointerException ("Move is not a current variation");
    else move = branches [oldIndex];
    if (num != 0) newIndex = oldIndex - num;
    if (newIndex < 0) throw new ArrayIndexOutOfBoundsException ("Move cannot be promoted beyond the main line");
    if (newIndex == 0 && branches [0] == null) {
        branches [oldIndex] = null;
        branches [0] = move;
        compressVariations ();
    }
    else {
        branches [oldIndex] = null;
        for (int i = newIndex; i <= oldIndex; i ++) {
            tmp = branches [i];
            branches [i] = move;
            move = tmp;
        }
        compressVariations ();
    }
    return newIndex;
}


-----Function Pair=16=-----==

public static void main (String [] args) {
    String dburl = "jdbc:oracle:thin:@//localhost:1521/xe";
    String dbuser = "system";
    String dbpass = "aquilina";
    String dbtable = "VIAS";
    Connection conn = null;
    System.out.println ("Creating JDBC connection...");
    try {
        DriverManager.registerDriver (new OracleDriver ());
        conn = DriverManager.getConnection (dburl, dbuser, dbpass);
        conn.setAutoCommit (false);
        long t1 = System.currentTimeMillis ();
        test1 (conn, dburl, dbuser, dbpass, dbtable);
        long t2 = System.currentTimeMillis ();
        System.out.println ("Tiempo de consulta1:" + (t2 - t1) + " milisegundos");
        conn.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}


public static byte [] shiftRight (final byte [] data, final int bits) {
    if (bits <= 0) {
        return data;
    }
    int d = 0;
    if (data.length == 1) {
        if (bits <= 8) {
            d = data [0] & 0xFF;
            d>>>= bits;
            data [0] = (byte) d;
        }
        else {
            data [0] = 0;
        }
    }
    else if (data.length > 1) {
        int carry = 0;
        if (bits < 8) {
            for (int i = data.length - 1; i > 0; -- i) {
                carry = data [i - 1] & (1 << (bits - 1));
                carry = carry << (8 - bits);
                d = data [i] & 0xFF;
                d>>>= bits;
                d |= carry;
                data [i] = (byte) d;
            }
            d = data [0] & 0xFF;
            d>>>= bits;
            data [0] = (byte) d;
        }
        else {
            for (int i = data.length - 1; i > 0; -- i) {
                data [i] = data [i - 1];
            }
            data [0] = 0;
            shiftRight (data, bits - 8);
        }
    }
    return data;
}


-----Function Pair=17=-----==

public void runTasks (float seconds, Object [] runners) {
    start = timer.getTimeInSeconds ();
    end = start + seconds;
    currenttasks.clear ();
    for (int k = 0; k < runners.length; k ++) {
        Task [] tasks = ((TaskRunner) runners [k]).getTasks ();
        for (int i = 0; i < tasks.length; i ++) {
            Task task = tasks [i];
            if (task != null && task.isUsingManager (this)) {
                if (task.isCompleted ()) {
                    completedTask (task);
                }
                else if (task.isPaused ()) {
                    task.prepareRun ();
                    currenttasks.add (tasks [i]);
                }
            }
        }
    }
    for (int k = 0; k < runners.length; k ++) {
        TaskRunner runner = (TaskRunner) runners [k];
        int tasksearch = tasklimit;
        int reserve = runner.reserveTask ();
        while (reserve != - 1 && -- tasksearch >= 0) {
            if (tasks [tasksearch].isUsingRunner (runner)) {
                Task task = tasks [tasksearch];
                tasks [tasksearch] = null;
                tasklimit --;
                for (int i = tasksearch; i < tasklimit; i ++) {
                    tasks [i] = tasks [i + 1];
                }
                task.assign (reserve);
                task.prepareRun ();
                currenttasks.add (task);
                reserve = runner.reserveTask ();
            }
            else {
            }
        }
        if (reserve != - 1) runner.cancelReserveTask (reserve);
    }
    Iterator it = currenttasks.iterator ();
    while (it.hasNext () && timeLeft () > 0) {
        Task task = (Task) it.next ();
        task.resume ();
    }
    it = currenttasks.iterator ();
    while (it.hasNext ()) {
        Task task = (Task) it.next ();
        task.attemptPause ();
    }
}


public static void main (String [] args) {
    CLI cli = new CLI ();
    String configProperties = System.getProperty (("org.openmolgrid.cli.config"));
    if (configProperties == null) configProperties = "cli_config.txt";
    Properties props = CommonTools.getCLIProperties (configProperties);
    try {
        String defaultsProps = System.getProperty (("org.openmolgrid.cli.defaults"));
        if (defaultsProps == null) defaultsProps = "userdefaults.txt";
        Properties defProps = CommonTools.getCLIProperties (defaultsProps);
        FileHandler fileHandler = new FileHandler (defProps.getProperty ("logger"));
        fileHandler.setFormatter (new SimpleFormatter ());
        logger.addHandler (fileHandler);
        logger.setLevel (Level.INFO);
        logger.info ("Logging started.");
        String logLevel = defProps.getProperty ("logging_level");
        Level level = null;
        try {
            level = Level.parse (logLevel);
        } catch (Exception ex) {
            logger.warning ("Unrecognised loglevel, going to INFO");
            level = Level.INFO;
            logLevel = "INFO (fallback)";
        }
        logger.setLevel (level);
        logger.info ("New log level " + logLevel);
        String email = defProps.getProperty ("userEmail", "");
        System.setProperty ("cli.userEmail", email);
    } catch (IOException ex) {
        System.out.println ("Could not create CLI logging: " + ex.getMessage ());
        return;
    }
    String classname = props.getProperty (args [0]);
    if (classname == null || classname.equals ("")) {
        logger.severe ("Unknown operation " + args [0]);
        System.out.println ("Unknown operation " + args [0]);
        return;
    }
    logger.info ("loading class: " + classname);
    System.out.println ("classname: " + classname);
    Object o = null;
    try {
        Class c = Class.forName (classname);
        o = c.newInstance ();
    } catch (Exception e) {
        logger.severe ("Could not load class " + classname);
        System.out.println ("Could not load class " + classname);
        return;
    }
    if (! (o instanceof AbstractClientInterface)) {
        logger.severe ("Wrong class type: " + classname);
        System.out.println ("Wrong class type: " + classname);
        return;
    }
    String [] options = new String [args.length - 1];
    for (int i = 0; i < args.length - 1; ++ i) options [i] = args [i + 1];
    try {
        ((AbstractClientInterface) o).setOptions (options);
        ((AbstractClientInterface) o).process ();
    } catch (Exception ex) {
        logger.severe ("Error occured!");
        logger.severe (ex.getMessage ());
        System.err.println ("Error occured!");
        ex.printStackTrace ();
        return;
    }
}


-----Function Pair=18=-----==

private int numericCompare (String a, String b) {
    if (a == b) return 0;
    if (a == null) return - 1;
    if (b == null) return 1;
    long al, bl;
    try {
        al = Long.parseLong (a);
    } catch (NumberFormatException nfe) {
        return numericCompareDouble (a, b);
    }
    try {
        bl = Long.parseLong (b);
    } catch (NumberFormatException nfe) {
        return numericCompareDouble (a, b);
    }
    if (al < bl) return - 1;
    if (al > bl) return 1;
    return 0;
}


private String doubleFormat (double val, int dec) {
    StringBuffer txt = new StringBuffer ();
    if (val < 0.0) {
        txt.append ("-");
        val = - val;
    }
    int i, k;
    k = (int) val;
    txt.append ("" + k);
    val -= k;
    if (dec > 0) {
        txt.append ('.');
    }
    for (i = 0; i < dec; i ++) {
        val *= 10;
        k = (int) (val + 0.001);
        txt.append ("" + k);
        val -= k;
    }
    return txt.toString ();
}


-----Function Pair=19=-----==

protected Object doRendezvous (Object x, boolean timed, long msecs) throws InterruptedException, TimeoutException, BrokenBarrierException {
    long startTime;
    if (timed) {
        startTime = System.currentTimeMillis ();
        if (! entryGate_.attempt (msecs)) {
            throw new TimeoutException (msecs);
        }
    }
    else {
        startTime = 0;
        entryGate_.acquire ();
    }
    synchronized (this) {
        Object y = null;
        int index = entries_ ++;
        slots_ [index] = x;
        try {
            if (entries_ == parties_) {
                departures_ = entries_;
                notifyAll ();
                try {
                    if (! broken_ && rendezvousFunction_ != null) rendezvousFunction_.rendezvousFunction (slots_);
                } catch (RuntimeException ex) {
                    broken_ = true;
                }
            }
            else {
                while (! broken_ && departures_ < 1) {
                    long timeLeft = 0;
                    if (timed) {
                        timeLeft = msecs - (System.currentTimeMillis () - startTime);
                        if (timeLeft <= 0) {
                            broken_ = true;
                            departures_ = entries_;
                            notifyAll ();
                            throw new TimeoutException (msecs);
                        }
                    }
                    try {
                        wait (timeLeft);
                    } catch (InterruptedException ex) {
                        if (broken_ || departures_ > 0) {
                            Thread.currentThread ().interrupt ();
                            break;
                        }
                        else {
                            broken_ = true;
                            departures_ = entries_;
                            notifyAll ();
                            throw ex;
                        }
                    }
                }
            }
        } finally {
            y = slots_ [index];
            if (-- departures_ <= 0) {
                for (int i = 0; i < slots_.length; ++ i) slots_ [i] = null;
                entryGate_.release (entries_);
                entries_ = 0;
            }
        }
        if (broken_) throw new BrokenBarrierException (index);
        else return y;
    }
}


public void draw_data (Graphics g, Rectangle bounds) {
    Color c;
    if (xaxis != null) {
        xmax = xaxis.maximum;
        xmin = xaxis.minimum;
    }
    if (yaxis != null) {
        ymax = yaxis.maximum;
        ymin = yaxis.minimum;
    }
    xrange = xmax - xmin;
    yrange = ymax - ymin;
    draw_legend (g, bounds);
    if (clipping) g.clipRect (bounds.x, bounds.y, bounds.width, bounds.height);
    c = g.getColor ();
    if (linestyle != DataSet.NOLINE) {
        if (linecolor != null) g.setColor (linecolor);
        else g.setColor (c);
        draw_lines (g, bounds);
    }
    if (marker > 0) {
        if (markercolor != null) g.setColor (markercolor);
        else g.setColor (c);
        draw_markers (g, bounds);
    }
    g.setColor (c);
}


-----Function Pair=20=-----==

private int decodeWhiteCodeWord () throws PdfException {
    int current, entry, bits, isT, twoBits, code = - 1;
    int runLength = 0;
    boolean isWhite = true;
    while (isWhite) {
        current = nextNBits (10);
        entry = white [current];
        isT = entry & 0x0001;
        bits = (entry>>> 1) & 0x0f;
        if (bits == 12) {
            twoBits = nextLesserThan8Bits (2);
            current = ((current << 2) & 0x000c) | twoBits;
            entry = additionalMakeup [current];
            bits = (entry>>> 1) & 0x07;
            code = (entry>>> 4) & 0x0fff;
            runLength += code;
            updatePointer (4 - bits);
        }
        else if (bits == 0) {
            throw new PdfException (("TIFFFaxDecoder0"));
        }
        else if (bits == 15) {
            throw new PdfException (("TIFFFaxDecoder1"));
        }
        else {
            code = (entry>>> 5) & 0x07ff;
            runLength += code;
            updatePointer (10 - bits);
            if (isT == 0) isWhite = false;
        }
    }
    return runLength;
}


void paintBrush (Graphics g, boolean paint_ovals, Color givencolor, Image side_image, Graphics g_side, boolean onRealPoints, int srcRectX, int srcRectY, double magnification) {
    try {
        if (givencolor == null) {
            int col = Integer.parseInt (color);
            givencolor = new Color (col, col, col);
        }
        g.setColor (givencolor);
        if (dragging) {
            fillPerimeterWithMagnification (g, srcRectX, srcRectY, magnification);
            for (int i = 0; i < temp_x.length; i ++) {
                g.fillOval ((int) ((temp_x [i] - temp_r [i] / 2 - srcRectX) * magnification), (int) ((temp_y [i] - temp_r [i] / 2 - srcRectY) * magnification), (int) ((temp_r [i] - srcRectX) * magnification), (int) ((temp_r [i] - srcRectY) * magnification));
                g_side.fillOval (temp_x [i] - temp_r [i] / 2, temp_y [i] - temp_r [i] / 2, temp_r [i], temp_r [i]);
            }
        }
        else {
            for (int i = 0; i < temp_x.length; i ++) {
                g_side.fillOval (temp_x [i] - temp_r [i] / 2, temp_y [i] - temp_r [i] / 2, temp_r [i], temp_r [i]);
            }
            if (onRealPoints) fillPerimeter (g_side);
            collectPerimeterPoints (side_image);
            if (x.length > 0) drawPerimeter (g, paint_ovals, srcRectX, srcRectY, magnification);
            temp_x = new int [0];
            temp_y = new int [0];
            temp_r = new int [0];
        }
    } catch (Exception e) {
        IJ.write ("Error ar paintBrush: " + e);
    }
}


-----Function Pair=21=-----==

public static void main (String [] args) {
    installLnF ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            ChooseToken frame = new ChooseToken ();
            Index index = new Index ();
            frame.setDefaultCloseOperation (ChooseToken.EXIT_ON_CLOSE);
            frame.setTitle ("ChooseToken");
            frame.getContentPane ().setPreferredSize (frame.getSize ());
            frame.pack ();
            frame.setLocationRelativeTo (null);
            frame.setVisible (true);
            index.dispose ();
        }
    }
    );
}


public double scalarProduct (final DoubleSquareMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawScalarProduct (m);
        default :
            if (numRows == m.rows ()) {
                double ans = 0.0;
                for (int j, i = 0; i < numRows; i ++) {
                    ans += matrix [i] [0] * m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) ans += matrix [i] [j] * m.getElement (i, j);
                }
                return ans;
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


-----Function Pair=22=-----==

protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getRed ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


public void cmdProc (Interp interp, TclObject argv []) throws TclException {
    try {
        CommandLine cl = parseCommandLine (argv);
        String args [] = cl.getArgs ();
        String attribute = null;
        TclObject newvalue = null;
        if (cl.hasOption ("help")) {
            new HelpFormatter ().printHelp ("jmx_set [-?] [-s server] [-m mbean] [ATTRIBUTE] NEW_VALUE", "======================================================================", opts, "======================================================================", false);
            System.out.println ("jmx_set updates the current value of the given attribute.");
            System.out.println ("If you do not specify server, mbean, or ATTRIBUTE, then the");
            System.out.println ("values in the global variables SERVER, MBEAN, and ATTROP,");
            System.out.println ("respectively, will be used.");
            return;
        }
        getDefaults (interp);
        server = cl.getOptionValue ("server", server);
        mbean = cl.getOptionValue ("mbean", mbean);
        attrop = cl.getOptionValue ("attrop", attrop);
        if (args.length > 1) {
            attribute = args [0];
            newvalue = argv [argv.length - args.length + 1];
        }
        else {
            attribute = attrop;
            newvalue = argv [argv.length - args.length];
        }
        if (server == null) {
            throw new TclException (interp, "No server specified; please set SERVER variable or use -s option.", TCL.ERROR);
        }
        if (mbean == null) {
            throw new TclException (interp, "No mbean specified; please set MBEAN variable or use -m option.", TCL.ERROR);
        }
        if (attribute == null) {
            throw new TclException (interp, "No attribute specified; please set ATTROP variable or add it to the command line.", TCL.ERROR);
        }
        if (newvalue == null) {
            throw new TclException (interp, "No new value provided for the attribute.", TCL.ERROR);
        }
        Jmx.getInstance ().setAttribute (server, mbean, attribute, newvalue);
    } catch (ParseException e) {
        throw new TclException (interp, e.getMessage (), 1);
    } catch (RuntimeException e) {
        throw new TclException (interp, e.getMessage (), 1);
    }
}


-----Function Pair=23=-----==

private int readEOL (boolean isFirstEOL) {
    if (fillBits == 0) {
        int next12Bits = nextNBits (12);
        if (isFirstEOL && next12Bits == 0) {
            if (nextNBits (4) == 1) {
                fillBits = 1;
                return 1;
            }
        }
        if (next12Bits != 1) {
            throw new Error (JaiI18N.getString ("TIFFFaxDecoder6"));
        }
    }
    else if (fillBits == 1) {
        int bitsLeft = 8 - bitPointer;
        if (nextNBits (bitsLeft) != 0) {
            throw new Error (JaiI18N.getString ("TIFFFaxDecoder8"));
        }
        if (bitsLeft < 4) {
            if (nextNBits (8) != 0) {
                throw new Error (JaiI18N.getString ("TIFFFaxDecoder8"));
            }
        }
        int n;
        while ((n = nextNBits (8)) != 1) {
            if (n != 0) {
                throw new Error (JaiI18N.getString ("TIFFFaxDecoder8"));
            }
        }
    }
    if (oneD == 0) {
        return 1;
    }
    else {
        return nextLesserThan8Bits (1);
    }
}


public void populateModelSet (boolean initialModelSet) {
    numModels = modelLibrary.length;
    if ((bagPercent != 1.0) && ! (stepwiseSortInitAll && initialModelSet)) {
        numModels *= bagPercent;
        for (int j = 0; j < modelLibrary.length; j ++) {
            int swap = r.nextInt (modelLibrary.length - j) + j;
            Model temp = modelLibrary [j];
            modelLibrary [j] = modelLibrary [swap];
            modelLibrary [swap] = temp;
        }
    }
    models = new Model [numModels];
    for (int i = 0; i < numModels; i ++) models [i] = modelLibrary [i];
    Arrays.sort (models);
}


-----Function Pair=24=-----==

public void plusEquals (AugmentableFeatureVector v, double factor) {
    if (indices != null && size - 1 != maxSortedIndex) sortIndices ();
    if (v.indices != null && v.size - 1 != v.maxSortedIndex) v.sortIndices ();
    int vl = 0;
    int vnl = v.size;
    assert (values != null);
    if (indices == null) {
        if (v.indices == null) {
            vnl = Math.min (vnl, size);
            for (int i = 0; i < vnl; i ++) values [i] += v.values [i];
        }
        else {
            for (int i = 0; i < vnl; i ++) {
                int index = v.indices [i];
                if (index < values.length) {
                    values [index] += v.values [i] * factor;
                    if (index >= size) size = index + 1;
                }
            }
        }
    }
    else {
        if (v.indices == null) {
            for (int i = 0; i < size; i ++) {
                if (indices [i] < vnl) values [i] += v.values [indices [i]];
            }
        }
        else {
            if (v.values == null) {
                for (int i = 0; i < size; i ++) {
                    while (vl < vnl && v.indices [vl] < indices [i]) vl ++;
                    if (vl < vnl && v.indices [vl] == indices [i]) values [i] += factor;
                }
            }
            else {
                for (int i = 0; i < size; i ++) {
                    while (vl < vnl && v.indices [vl] < indices [i]) vl ++;
                    if (vl < vnl && v.indices [vl] == indices [i]) values [i] += v.values [vl] * factor;
                }
            }
        }
    }
}


private void surfacePlotDotsNoLight () {
    int delta = Math.max (gridHeight, gridWidth) / 128;
    if (delta < 1) delta = 1;
    for (int row = 0; row < gridHeight; row += delta) {
        for (int col = 0; col < gridWidth - 1; col += delta) {
            int i = row * gridWidth + col;
            SurfacePlotData p0 = plotList [i];
            if (p0 != null) {
                tr.transform (p0);
                int x = (int) tr.X;
                int y = (int) tr.Y;
                if (x >= 0 && y >= 0 && x < bufferWidth - 1 && y < bufferHeight - 1) {
                    int pos = y * bufferWidth + x;
                    int z = (int) tr.Z;
                    if (z < zbufferPixels [pos]) {
                        int c0 = 0xFF000000 | getColor (p0);
                        zbufferPixels [pos] = z;
                        bufferPixels [pos] = c0;
                        zbufferPixels [pos + 1] = z;
                        zbufferPixels [pos + bufferWidth] = z;
                        zbufferPixels [pos + bufferWidth + 1] = z;
                        bufferPixels [pos + 1] = c0;
                        bufferPixels [pos + bufferWidth] = c0;
                        bufferPixels [pos + bufferWidth + 1] = c0;
                    }
                }
            }
        }
    }
}


-----Function Pair=25=-----==

static double [] [] getNewControlPointsAtDegreeElevation (BsplineKnotVector oldKnotData, BsplineKnotVector newKnotData, double [] [] oldControlPoints) {
    int i, j, k, l;
    BsplineKnotVector.ValidSegmentInfo oldValidSegments = oldKnotData.validSegments ();
    int oldNValidSegments = oldValidSegments.nSegments ();
    int newNControlPoints = oldKnotData.nControlPoints () + oldNValidSegments;
    double [] targetParams = new double [oldKnotData.degree () + 1];
    double [] blossomParams = new double [oldKnotData.degree ()];
    int dimension = oldControlPoints [0].length;
    double [] [] newControlPoints = new double [newNControlPoints] [dimension];
    for (i = 0; i < newNControlPoints; i ++) {
        for (k = 0, l = (i + 1); k < newKnotData.degree (); k ++, l ++) targetParams [k] = newKnotData.knotValueAt (l);
        int targetSegment = BsplineCurveEvaluation.getTargetSegmentOfBlossomingAtDegreeElevation (targetParams, oldKnotData.degree (), oldValidSegments);
        for (k = 0; k < dimension; k ++) newControlPoints [i] [k] = 0.0;
        for (j = 0; j < newKnotData.degree (); j ++) {
            for (k = 0, l = 0; k < oldKnotData.degree (); k ++, l ++) {
                if (k == j) l ++;
                blossomParams [k] = targetParams [l];
            }
            double [] blossomPoint = BsplineCurveEvaluation.blossoming (oldKnotData, oldControlPoints, targetSegment, blossomParams);
            for (k = 0; k < dimension; k ++) newControlPoints [i] [k] += blossomPoint [k] / newKnotData.degree ();
        }
    }
    return newControlPoints;
}


void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=26=-----==

public V remove (Object key) {
    V oldValue = get (key);
    if (oldValue != null) {
        int index = Arrays.binarySearch (_keys, 0, _size, key, _comparator);
        for (int i = index; i < _size - 1; i ++) {
            _keys [i] = _keys [i + 1];
            _values [i] = _values [i + 1];
        }
        _keys [_size - 1] = _values [_size - 1] = null;
        _size --;
        if (_size < _keys.length - 2 * INCREMENT) resize (_keys.length - INCREMENT);
    }
    return oldValue;
}


private HashMap getGivenKeyphrases (String str, boolean forEval) {
    FastVector vector = new FastVector ();
    HashMap hash = new HashMap ();
    StringTokenizer tok = new StringTokenizer (str, "\n");
    while (tok.hasMoreTokens ()) {
        String orig = tok.nextToken ();
        orig = orig.trim ();
        if (orig.length () > 0) {
            String modified;
            if (! forEval) {
                modified = internalFormat (orig);
            }
            else {
                modified = evalFormat (orig);
            }
            if (! hash.containsKey (modified)) {
                hash.put (modified, orig);
            }
            else {
                if (forEval) {
                    System.err.println ("WARNING: stem of author-assigned keyphrase " + orig + " matches existing stem (skipping it)!");
                }
            }
        }
    }
    if (hash.size () == 0) {
        return null;
    }
    else {
        return hash;
    }
}


-----Function Pair=27=-----==

private static int exch_bss_u (BsplineKnotVector uKnotData, BsplineKnotVector vKnotData, double [] [] [] cntrl_pnts, int dimension, double para) {
    double alp;
    int uj, vj, i, k;
    int uUicp = uKnotData.nControlPoints ();
    int vUicp = vKnotData.nControlPoints ();
    int uDegree = uKnotData.degree ();
    i = uKnotData.segmentIndex (para);
    double [] p0 = new double [dimension];
    double [] p1 = new double [dimension];
    for (vj = 0; vj < vUicp; vj ++) {
        for (uj = (i + 1); uj <= (i + uDegree); uj ++) {
            alp = (para - uKnotData.knotValueAt (uj)) / (uKnotData.knotValueAt (uj + uDegree) - uKnotData.knotValueAt (uj));
            for (k = 0; k < dimension; k ++) p1 [k] = (1.0 - alp) * cntrl_pnts [uj - 1] [vj] [k] + alp * cntrl_pnts [uj] [vj] [k];
            if (uj > (i + 1)) for (k = 0; k < dimension; k ++) cntrl_pnts [uj - 1] [vj] [k] = p0 [k];
            for (k = 0; k < dimension; k ++) p0 [k] = p1 [k];
        }
        for (uj = (i + uDegree); uj < uUicp; uj ++) {
            for (k = 0; k < dimension; k ++) {
                p1 [k] = cntrl_pnts [uj] [vj] [k];
                cntrl_pnts [uj] [vj] [k] = p0 [k];
                p0 [k] = p1 [k];
            }
        }
        for (k = 0; k < dimension; k ++) cntrl_pnts [uUicp] [vj] [k] = p0 [k];
    }
    return uUicp + 1;
}


private void calcHistogram () {
    if (image == null) return;
    Arrays.fill (histoData, 0);
    WritableRaster imgRast = image.getRaster ();
    int width = image.getWidth ();
    int height = image.getHeight ();
    int bands = imgRast.getNumBands ();
    if (bands != 1 && bands != 3) {
        System.out.println ("Wrong no of bands: " + bands);
        return;
    }
    for (int y = 0; y < height; y ++) {
        for (int x = 0; x < width; x ++) {
            int value = 0;
            if (bands == 1) {
                value = imgRast.getSample (x, y, 0);
            }
            else {
                int r = imgRast.getSample (x, y, 0);
                int g = imgRast.getSample (x, y, 1);
                int b = imgRast.getSample (x, y, 2);
                value = (r + g + b) / 3;
            }
            if (value < 0) value = 0;
            if (value > 255) value = 255;
            histoData [value] ++;
        }
    }
}


-----Function Pair=28=-----==

private final int getAntiAlias (float p1, boolean p1_up, float p2, boolean p2_up, float sz, float weight) {
    int ach = 0, rch = 0, gch = 0, bch = 0;
    if (isSimpleLookup) {
        p1 *= fastGradientArraySize;
        p2 *= fastGradientArraySize;
        int idx1 = (int) p1;
        int idx2 = (int) p2;
        int i, pix;
        if (p1_up && ! p2_up && (idx1 <= idx2)) {
            if (idx1 == idx2) return gradient [idx1];
            for (i = idx1 + 1; i < idx2; i ++) {
                pix = gradient [i];
                ach += ((pix>>> 20) & 0xFF0);
                rch += ((pix>>> 12) & 0xFF0);
                gch += ((pix>>> 4) & 0xFF0);
                bch += ((pix << 4) & 0xFF0);
            }
        }
        else {
            if (p1_up) {
                for (i = idx1 + 1; i < fastGradientArraySize; i ++) {
                    pix = gradient [i];
                    ach += ((pix>>> 20) & 0xFF0);
                    rch += ((pix>>> 12) & 0xFF0);
                    gch += ((pix>>> 4) & 0xFF0);
                    bch += ((pix << 4) & 0xFF0);
                }
            }
            else {
                for (i = 0; i < idx1; i ++) {
                    pix = gradient [i];
                    ach += ((pix>>> 20) & 0xFF0);
                    rch += ((pix>>> 12) & 0xFF0);
                    gch += ((pix>>> 4) & 0xFF0);
                    bch += ((pix << 4) & 0xFF0);
                }
            }
            if (p2_up) {
                for (i = idx2 + 1; i < fastGradientArraySize; i ++) {
                    pix = gradient [i];
                    ach += ((pix>>> 20) & 0xFF0);
                    rch += ((pix>>> 12) & 0xFF0);
                    gch += ((pix>>> 4) & 0xFF0);
                    bch += ((pix << 4) & 0xFF0);
                }
            }
            else {
                for (i = 0; i < idx2; i ++) {
                    pix = gradient [i];
                    ach += ((pix>>> 20) & 0xFF0);
                    rch += ((pix>>> 12) & 0xFF0);
                    gch += ((pix>>> 4) & 0xFF0);
                    bch += ((pix << 4) & 0xFF0);
                }
            }
        }
        int norm, isz;
        isz = (int) ((1 << 16) / (sz * fastGradientArraySize));
        ach = (ach * isz)>> 16;
        rch = (rch * isz)>> 16;
        gch = (gch * isz)>> 16;
        bch = (bch * isz)>> 16;
        if (p1_up) norm = (int) ((1 - (p1 - idx1)) * isz);
        else norm = (int) ((p1 - idx1) * isz);
        pix = gradient [idx1];
        ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
        rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
        gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
        bch += (((pix << 4) & 0xFF0) * norm)>> 16;
        if (p2_up) norm = (int) ((1 - (p2 - idx2)) * isz);
        else norm = (int) ((p2 - idx2) * isz);
        pix = gradient [idx2];
        ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
        rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
        gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
        bch += (((pix << 4) & 0xFF0) * norm)>> 16;
        ach = (ach + 0x08)>> 4;
        rch = (rch + 0x08)>> 4;
        gch = (gch + 0x08)>> 4;
        bch = (bch + 0x08)>> 4;
    }
    else {
        int idx1 = 0, idx2 = 0;
        int i1 = - 1, i2 = - 1;
        float f1 = 0, f2 = 0;
        for (int i = 0; i < gradientsLength; i ++) {
            if ((p1 < fractions [i + 1]) && (i1 == - 1)) {
                i1 = i;
                f1 = p1 - fractions [i];
                f1 = ((f1 / normalizedIntervals [i]) * GRADIENT_SIZE_INDEX);
                idx1 = (int) f1;
                if (i2 != - 1) break;
            }
            if ((p2 < fractions [i + 1]) && (i2 == - 1)) {
                i2 = i;
                f2 = p2 - fractions [i];
                f2 = ((f2 / normalizedIntervals [i]) * GRADIENT_SIZE_INDEX);
                idx2 = (int) f2;
                if (i1 != - 1) break;
            }
        }
        if (i1 == - 1) {
            i1 = gradients.length - 1;
            f1 = idx1 = GRADIENT_SIZE_INDEX;
        }
        if (i2 == - 1) {
            i2 = gradients.length - 1;
            f2 = idx2 = GRADIENT_SIZE_INDEX;
        }
        if (DEBUG) System.out.println ("I1: " + i1 + " Idx1: " + idx1 + " I2: " + i2 + " Idx2: " + idx2);
        if ((i1 == i2) && (idx1 <= idx2) && p1_up && ! p2_up) return gradients [i1] [(idx1 + idx2 + 1)>> 1];
        int pix, norm;
        int base = (int) ((1 << 16) / sz);
        if ((i1 < i2) && p1_up && ! p2_up) {
            norm = (int) ((base * normalizedIntervals [i1] * (GRADIENT_SIZE_INDEX - f1)) / GRADIENT_SIZE_INDEX);
            pix = gradients [i1] [(idx1 + GRADIENT_SIZE)>> 1];
            ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
            rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
            gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
            bch += (((pix << 4) & 0xFF0) * norm)>> 16;
            for (int i = i1 + 1; i < i2; i ++) {
                norm = (int) (base * normalizedIntervals [i]);
                pix = gradients [i] [GRADIENT_SIZE>> 1];
                ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
                rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
                gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
                bch += (((pix << 4) & 0xFF0) * norm)>> 16;
            }
            norm = (int) ((base * normalizedIntervals [i2] * f2) / GRADIENT_SIZE_INDEX);
            pix = gradients [i2] [(idx2 + 1)>> 1];
            ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
            rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
            gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
            bch += (((pix << 4) & 0xFF0) * norm)>> 16;
        }
        else {
            if (p1_up) {
                norm = (int) ((base * normalizedIntervals [i1] * (GRADIENT_SIZE_INDEX - f1)) / GRADIENT_SIZE_INDEX);
                pix = gradients [i1] [(idx1 + GRADIENT_SIZE)>> 1];
            }
            else {
                norm = (int) ((base * normalizedIntervals [i1] * f1) / GRADIENT_SIZE_INDEX);
                pix = gradients [i1] [(idx1 + 1)>> 1];
            }
            ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
            rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
            gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
            bch += (((pix << 4) & 0xFF0) * norm)>> 16;
            if (p2_up) {
                norm = (int) ((base * normalizedIntervals [i2] * (GRADIENT_SIZE_INDEX - f2)) / GRADIENT_SIZE_INDEX);
                pix = gradients [i2] [(idx2 + GRADIENT_SIZE)>> 1];
            }
            else {
                norm = (int) ((base * normalizedIntervals [i2] * f2) / GRADIENT_SIZE_INDEX);
                pix = gradients [i2] [(idx2 + 1)>> 1];
            }
            ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
            rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
            gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
            bch += (((pix << 4) & 0xFF0) * norm)>> 16;
            if (p1_up) {
                for (int i = i1 + 1; i < gradientsLength; i ++) {
                    norm = (int) (base * normalizedIntervals [i]);
                    pix = gradients [i] [GRADIENT_SIZE>> 1];
                    ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
                    rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
                    gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
                    bch += (((pix << 4) & 0xFF0) * norm)>> 16;
                }
            }
            else {
                for (int i = 0; i < i1; i ++) {
                    norm = (int) (base * normalizedIntervals [i]);
                    pix = gradients [i] [GRADIENT_SIZE>> 1];
                    ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
                    rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
                    gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
                    bch += (((pix << 4) & 0xFF0) * norm)>> 16;
                }
            }
            if (p2_up) {
                for (int i = i2 + 1; i < gradientsLength; i ++) {
                    norm = (int) (base * normalizedIntervals [i]);
                    pix = gradients [i] [GRADIENT_SIZE>> 1];
                    ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
                    rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
                    gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
                    bch += (((pix << 4) & 0xFF0) * norm)>> 16;
                }
            }
            else {
                for (int i = 0; i < i2; i ++) {
                    norm = (int) (base * normalizedIntervals [i]);
                    pix = gradients [i] [GRADIENT_SIZE>> 1];
                    ach += (((pix>>> 20) & 0xFF0) * norm)>> 16;
                    rch += (((pix>>> 12) & 0xFF0) * norm)>> 16;
                    gch += (((pix>>> 4) & 0xFF0) * norm)>> 16;
                    bch += (((pix << 4) & 0xFF0) * norm)>> 16;
                }
            }
        }
        ach = (ach + 0x08)>> 4;
        rch = (rch + 0x08)>> 4;
        gch = (gch + 0x08)>> 4;
        bch = (bch + 0x08)>> 4;
        if (DEBUG) System.out.println ("Pix: [" + ach + ", " + rch + ", " + gch + ", " + bch + "]");
    }
    if (weight != 1) {
        int aveW = (int) ((1 << 16) * (1 - weight));
        int aveA = ((gradientAverage>>> 24) & 0xFF) * aveW;
        int aveR = ((gradientAverage>> 16) & 0xFF) * aveW;
        int aveG = ((gradientAverage>> 8) & 0xFF) * aveW;
        int aveB = ((gradientAverage) & 0xFF) * aveW;
        int iw = (int) (weight * (1 << 16));
        ach = ((ach * iw) + aveA)>> 16;
        rch = ((rch * iw) + aveR)>> 16;
        gch = ((gch * iw) + aveG)>> 16;
        bch = ((bch * iw) + aveB)>> 16;
    }
    return ((ach << 24) | (rch << 16) | (gch << 8) | bch);
}


private static Scriptable js_concat (Context cx, Scriptable scope, Scriptable thisObj, Object [] args) {
    scope = getTopLevelScope (scope);
    Function ctor = ScriptRuntime.getExistingCtor (cx, scope, "Array");
    Scriptable result = ctor.construct (cx, scope, ScriptRuntime.emptyArgs);
    if (thisObj instanceof NativeArray && result instanceof NativeArray) {
        NativeArray denseThis = (NativeArray) thisObj;
        NativeArray denseResult = (NativeArray) result;
        if (denseThis.denseOnly && denseResult.denseOnly) {
            boolean canUseDense = true;
            int length = (int) denseThis.length;
            for (int i = 0; i < args.length && canUseDense; i ++) {
                if (args [i] instanceof NativeArray) {
                    final NativeArray arg = (NativeArray) args [i];
                    canUseDense = arg.denseOnly;
                    length += arg.length;
                }
                else {
                    length ++;
                }
            }
            if (canUseDense && denseResult.ensureCapacity (length)) {
                System.arraycopy (denseThis.dense, 0, denseResult.dense, 0, (int) denseThis.length);
                int cursor = (int) denseThis.length;
                for (int i = 0; i < args.length && canUseDense; i ++) {
                    if (args [i] instanceof NativeArray) {
                        NativeArray arg = (NativeArray) args [i];
                        System.arraycopy (arg.dense, 0, denseResult.dense, cursor, (int) arg.length);
                        cursor += (int) arg.length;
                    }
                    else {
                        denseResult.dense [cursor ++] = args [i];
                    }
                }
                denseResult.length = length;
                return result;
            }
        }
    }
    long length;
    long slot = 0;
    if (ScriptRuntime.instanceOf (thisObj, ctor, cx)) {
        length = getLengthProperty (cx, thisObj);
        for (slot = 0; slot < length; slot ++) {
            Object temp = getElem (cx, thisObj, slot);
            setElem (cx, result, slot, temp);
        }
    }
    else {
        setElem (cx, result, slot ++, thisObj);
    }
    for (int i = 0; i < args.length; i ++) {
        if (ScriptRuntime.instanceOf (args [i], ctor, cx)) {
            Scriptable arg = (Scriptable) args [i];
            length = getLengthProperty (cx, arg);
            for (long j = 0; j < length; j ++, slot ++) {
                Object temp = getElem (cx, arg, j);
                setElem (cx, result, slot, temp);
            }
        }
        else {
            setElem (cx, result, slot ++, args [i]);
        }
    }
    return result;
}


-----Function Pair=29=-----==

private HashMap getPhrasesForDictionary (String str) {
    String [] buffer = new String [m_MaxPhraseLength];
    HashMap hash = new HashMap ();
    StringTokenizer tok = new StringTokenizer (str, "\n");
    while (tok.hasMoreTokens ()) {
        String phrase = tok.nextToken ();
        int numSeen = 0;
        StringTokenizer wordTok = new StringTokenizer (phrase, " ");
        while (wordTok.hasMoreTokens ()) {
            String word = wordTok.nextToken ();
            for (int i = 0; i < m_MaxPhraseLength - 1; i ++) {
                buffer [i] = buffer [i + 1];
            }
            buffer [m_MaxPhraseLength - 1] = word;
            numSeen ++;
            if (numSeen > m_MaxPhraseLength) {
                numSeen = m_MaxPhraseLength;
            }
            if (m_Stopwords.isStopword (buffer [m_MaxPhraseLength - 1])) {
                continue;
            }
            StringBuffer phraseBuffer = new StringBuffer ();
            for (int i = 1; i <= numSeen; i ++) {
                if (i > 1) {
                    phraseBuffer.insert (0, ' ');
                }
                phraseBuffer.insert (0, buffer [m_MaxPhraseLength - i]);
                if ((i > 1) && (m_Stopwords.isStopword (buffer [m_MaxPhraseLength - i]))) {
                    continue;
                }
                if (i >= m_MinPhraseLength) {
                    String orig = phraseBuffer.toString ();
                    String internal = internalFormat (orig);
                    Counter count = (Counter) hash.get (internal);
                    if (count == null) {
                        hash.put (internal, new Counter ());
                    }
                    else {
                        count.increment ();
                    }
                }
            }
        }
    }
    return hash;
}


void gastexDrawTree (boolean dn, int parentnodeid, MappedPoint mp, double sangle, double eangle, int ox, int oy, int r, StringBuffer sb) {
    MappedPoint [] children = mp.getChildren ();
    if (children.length == 0) {
        return;
    }
    if (! (mp instanceof CycleMappedPoint) && ((sangle - eangle) == Math.PI)) {
        eangle = (eangle + sangle) / 2.0 + ((eangle + sangle) / 4.0);
        sangle = (eangle + sangle) / 2.0 - ((eangle + sangle) / 4.0);
    }
    double anglestep = (eangle - sangle) / (children.length - 1);
    double used_angle = sangle;
    if (children.length == 1) {
        used_angle = (eangle + sangle) / 2.0;
    }
    int x = 0;
    int y = 0;
    for (int i = 0; i < children.length; i ++) {
        x = ox + (int) (r * Math.cos (used_angle));
        y = oy + (int) (r * Math.sin (used_angle));
        if (hx < x) {
            hx = x;
        }
        if (lx > x) {
            lx = x;
        }
        if (hy < y) {
            hy = y;
        }
        if (ly > y) {
            ly = y;
        }
        if (dn) {
            sb.append ("\\node[Nadjust=wh](" + (node_counter ++) + ")(" + x + "," + y + "){" + children [i].getValue () + "}\n");
        }
        else {
            sb.append ("\\node[Nadjust=wh](" + (node_counter ++) + ")(" + x + "," + y + "){}\n");
        }
        sb.append ("\\drawedge(" + (node_counter - 1) + "," + parentnodeid + "){}\n");
        gastexDrawTree (dn, (node_counter - 1), children [i], sangle, eangle, x, y, r, sb);
        used_angle += anglestep;
    }
}


-----Function Pair=30=-----==

public boolean process (String [] args) throws CommandException {
    final DbCollection col = session.getContextCollection ();
    if (col == null) {
        throwException ("Context collection is not set");
    }
    final int type = ArrayUtils.indexOf (IDXTYPE, args [1]);
    if (type == ArrayUtils.INDEX_NOT_FOUND) {
        throwException ("Unexpected command");
    }
    final boolean status;
    switch (type) {
        case PATH_IDX :
            {
                try {
                    status = createPathIndex (col);
                } catch (Exception e) {
                    rethrowException (e);
                    return false;
                }
                break;
            }
        case VALUE_IDX :
            {
                final String [] result = parsePattern (args, DATATYPE_CMD);
                status = createValueIndex (col, result [0]);
                break;
            }
        case FULLTEXT_IDX :
            {
                status = createFullTextIndex (col);
                break;
            }
        default :
            throw new IllegalStateException ("Illegal type: " + type);
    }
    return status;
}


public static byte [] shiftRight (final byte [] data, final int bits) {
    if (bits <= 0) {
        return data;
    }
    int d = 0;
    if (data.length == 1) {
        if (bits <= 8) {
            d = data [0] & 0xFF;
            d>>>= bits;
            data [0] = (byte) d;
        }
        else {
            data [0] = 0;
        }
    }
    else if (data.length > 1) {
        int carry = 0;
        if (bits < 8) {
            for (int i = data.length - 1; i > 0; -- i) {
                carry = data [i - 1] & (1 << (bits - 1));
                carry = carry << (8 - bits);
                d = data [i] & 0xFF;
                d>>>= bits;
                d |= carry;
                data [i] = (byte) d;
            }
            d = data [0] & 0xFF;
            d>>>= bits;
            data [0] = (byte) d;
        }
        else {
            for (int i = data.length - 1; i > 0; -- i) {
                data [i] = data [i - 1];
            }
            data [0] = 0;
            shiftRight (data, bits - 8);
        }
    }
    return data;
}


-----Function Pair=31=-----==

private void calculateCoefficients () {
    int N = yy.length;
    a = new double [N];
    b = new double [N];
    c = new double [N];
    d = new double [N];
    if (N == 2) {
        a [0] = yy [0];
        b [0] = yy [1] - yy [0];
        return;
    }
    double [] h = new double [N - 1];
    for (int i = 0; i < N - 1; i ++) {
        a [i] = yy [i];
        h [i] = xx [i + 1] - xx [i];
        if (h [i] == 0.0) {
            h [i] = 0.01;
        }
    }
    a [N - 1] = yy [N - 1];
    double [] [] A = new double [N - 2] [N - 2];
    double [] y = new double [N - 2];
    for (int i = 0; i < N - 2; i ++) {
        y [i] = 3 * ((yy [i + 2] - yy [i + 1]) / h [i + 1] - (yy [i + 1] - yy [i]) / h [i]);
        A [i] [i] = 2 * (h [i] + h [i + 1]);
        if (i > 0) {
            A [i] [i - 1] = h [i];
        }
        if (i < N - 3) {
            A [i] [i + 1] = h [i + 1];
        }
    }
    solve (A, y);
    for (int i = 0; i < N - 2; i ++) {
        c [i + 1] = y [i];
        b [i] = (a [i + 1] - a [i]) / h [i] - (2 * c [i] + c [i + 1]) / 3 * h [i];
        d [i] = (c [i + 1] - c [i]) / (3 * h [i]);
    }
    b [N - 2] = (a [N - 1] - a [N - 2]) / h [N - 2] - (2 * c [N - 2] + c [N - 1]) / 3 * h [N - 2];
    d [N - 2] = (c [N - 1] - c [N - 2]) / (3 * h [N - 2]);
}


public static void quantizecolumns (float [] [] M, int qd, boolean extreme_values, int label) {
    int lines = M.length;
    int columns = M [0].length;
    normalTransformcolumns (M, extreme_values, label);
    for (int j = 0; j < columns - label; j ++) {
        if (M [0] [j] != skipvalue) {
            Vector negatives = new Vector ();
            Vector positives = new Vector ();
            float meanneg = 0;
            float meanpos = 0;
            for (int i = 0; i < lines; i ++) {
                if (M [i] [j] < 0) {
                    negatives.add (M [i] [j]);
                    meanneg += M [i] [j];
                }
                else {
                    positives.add (M [i] [j]);
                    meanpos += M [i] [j];
                }
            }
            meanneg /= negatives.size ();
            meanpos /= positives.size ();
            int indThreshold = 0;
            double increment = - meanneg / ((double) qd / 2);
            double [] threshold = new double [qd - 1];
            for (double i = meanneg + increment; i < 0; i += increment, indThreshold ++) {
                threshold [indThreshold] = i;
            }
            increment = meanpos / ((double) qd / 2);
            indThreshold = qd - 2;
            for (double i = meanpos - increment; i > 0; i -= increment, indThreshold --) {
                threshold [indThreshold] = i;
            }
            for (int i = 0; i < lines; i ++) {
                int k;
                for (k = 0; k < qd - 1; k ++) {
                    if (threshold [k] >= M [i] [j]) {
                        break;
                    }
                }
                M [i] [j] = k;
            }
        }
    }
}


-----Function Pair=32=-----==

public void init () {
    TitledBorder border = new TitledBorder (Msg.getMsg (Env.getCtx (), "CurrentLine"));
    setBorder (border);
    setLayout (new GridBagLayout ());
    GridBagConstraints gbc = new GridBagConstraints ();
    gbc.insets = INSETS2;
    gbc.gridy = 0;
    f_new = createButtonAction ("New", KeyStroke.getKeyStroke (KeyEvent.VK_INSERT, Event.SHIFT_MASK));
    gbc.gridx = 0;
    add (f_new, gbc);
    f_reset = createButtonAction ("Reset", null);
    gbc.gridx = GridBagConstraints.RELATIVE;
    add (f_reset, gbc);
    f_currency = new CLabel ("---");
    gbc.anchor = GridBagConstraints.EAST;
    gbc.weightx = .1;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    add (f_currency, gbc);
    f_price = new VNumber ("PriceActual", false, false, true, DisplayType.Amount, Msg.translate (Env.getCtx (), "PriceActual"));
    f_price.addActionListener (this);
    f_price.setColumns (10, 25);
    gbc.anchor = GridBagConstraints.WEST;
    gbc.weightx = 0;
    gbc.fill = GridBagConstraints.NONE;
    add (f_price, gbc);
    setPrice (Env.ZERO);
    f_uom = new CLabel ("--");
    gbc.anchor = GridBagConstraints.EAST;
    gbc.weightx = .1;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    add (f_uom, gbc);
    f_minus = createButtonAction ("Minus", null);
    gbc.anchor = GridBagConstraints.WEST;
    gbc.weightx = 0;
    gbc.fill = GridBagConstraints.NONE;
    add (f_minus, gbc);
    f_quantity = new VNumber ("QtyOrdered", false, false, true, DisplayType.Quantity, Msg.translate (Env.getCtx (), "QtyOrdered"));
    f_quantity.addActionListener (this);
    f_quantity.setColumns (5, 25);
    add (f_quantity, gbc);
    setQty (Env.ONE);
    f_plus = createButtonAction ("Plus", null);
    add (f_plus, gbc);
}


private static void doSort (byte [] a, int left, int right) {
    if (right - left + 1 < INSERTION_SORT_THRESHOLD) {
        for (int i = left + 1; i <= right; i ++) {
            byte ai = a [i];
            int j;
            for (j = i - 1; j >= left && ai < a [j]; j --) {
                a [j + 1] = a [j];
            }
            a [j + 1] = ai;
        }
    }
    else if (right - left + 1 > COUNTING_SORT_THRESHOLD_FOR_BYTE) {
        int [] count = new int [NUM_BYTE_VALUES];
        for (int i = left; i <= right; i ++) {
            count [a [i] - Byte.MIN_VALUE] ++;
        }
        for (int i = 0, k = left; i < count.length && k <= right; i ++) {
            byte value = (byte) (i + Byte.MIN_VALUE);
            for (int s = count [i]; s > 0; s --) {
                a [k ++] = value;
            }
        }
    }
    else {
        dualPivotQuicksort (a, left, right);
    }
}


-----Function Pair=33=-----==

public void removeItem (TreePath selectedTreePath) {
    if (selectedTreePath == null) {
    }
    else {
        Object [] path_o = selectedTreePath.getPath ();
        String [] path = new String [path_o.length - 1];
        for (int i = 0; i < path_o.length - 1; i ++) {
            DefaultMutableTreeNode currentPathElement = (DefaultMutableTreeNode) path_o [i + 1];
            String currentPathElementName;
            if (currentPathElement.getUserObject ().getClass ().equals (DefaultMutableTreeNode.class)) {
                DefaultMutableTreeNode currentPathElementName_node = (DefaultMutableTreeNode) currentPathElement.getUserObject ();
                currentPathElementName = (String) currentPathElementName_node.getUserObject ();
            }
            else {
                currentPathElementName = (String) currentPathElement.getUserObject ();
            }
            path [i] = currentPathElementName;
        }
        TreeMap currentFavoritesSubMenuElements = this.favoritesSubMenuElements;
        currentFavoritesSubMenuElements = removeSubItem (currentFavoritesSubMenuElements, path);
        this.favoritesSubMenuElements = currentFavoritesSubMenuElements;
    }
    this.build (this.favoritesSubMenuElements);
}


private int nextNBits (int bitsToGet) {
    byte b, next, next2next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = data [bp + 1];
            next2next = 0x00;
        }
        else {
            next = data [bp + 1];
            next2next = data [bp + 2];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
            next2next = 0x00;
        }
        else if ((bp + 1) == l) {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
            next2next = flipTable [data [bp + 2] & 0xff];
        }
    }
    else {
        throw new RuntimeException ("Invalid FillOrder");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int bitsFromNext2NextByte = 0;
    if (bitsFromNextByte > 8) {
        bitsFromNext2NextByte = bitsFromNextByte - 8;
        bitsFromNextByte = 8;
    }
    bytePointer ++;
    int i1 = (b & table1 [bitsLeft]) << (bitsToGet - bitsLeft);
    int i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
    int i3 = 0;
    if (bitsFromNext2NextByte != 0) {
        i2 <<= bitsFromNext2NextByte;
        i3 = (next2next & table2 [bitsFromNext2NextByte])>>> (8 - bitsFromNext2NextByte);
        i2 |= i3;
        bytePointer ++;
        bitPointer = bitsFromNext2NextByte;
    }
    else {
        if (bitsFromNextByte == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
        else {
            bitPointer = bitsFromNextByte;
        }
    }
    int i = i1 | i2;
    return i;
}


-----Function Pair=34=-----==

public boolean tryParseRecord (String line, int irec, DataSetBuilder builder) {
    int j = 0;
    int okayCount = 0;
    int failCount = 0;
    int tryCount = 0;
    int ipos = 0;
    if (fieldCount != fieldParsers.length) {
        return false;
    }
    String [] ss = new String [fieldCount];
    if (! splitRecord (line, ss)) {
        return false;
    }
    for (j = 0; j < fieldCount; j ++) {
        tryCount ++;
        if (doParseField [j]) {
            String parseable = ss [j];
            try {
                double d = fieldParsers [j].parseField (parseable, j);
                if (builder != null) builder.putValue (irec, j, d);
                okayCount ++;
            } catch (ParseException e) {
                if (showException) {
                    e.printStackTrace ();
                    showException = false;
                }
                failCount ++;
                if (builder != null) builder.putValue (irec, j, - 1e31);
            } catch (NumberFormatException e) {
                failCount ++;
                if (builder != null) builder.putValue (irec, j, - 1e31);
            }
        }
    }
    return (failCount < tryCount) && (okayCount > 1 || failCount < 3);
}


private static Service [] servicesArray () {
    RecordStore rs = null;
    int records = 0;
    Service [] services_array = new Service [0];
    try {
        rs = RecordStore.openRecordStore (RN, true);
        records = rs.getNumRecords ();
        if (records > 0) {
            services_array = new Service [records];
            RecordEnumeration e = rs.enumerateRecords (null, null, true);
            int arraypos = 0;
            while (e.hasNextElement ()) {
                int record = e.nextRecordId ();
                Service serviceTemp = new Service (new String (rs.getRecord (record)), record);
                services_array [arraypos] = serviceTemp;
                arraypos ++;
            }
            e.destroy ();
        }
    } catch (Exception e) {
    } finally {
        try {
            rs.closeRecordStore ();
        } catch (Exception e) {
        }
    }
    return services_array;
}


-----Function Pair=35=-----==

public void mouseMoved (MouseEvent event) {
    boolean newthumbMoused = false;
    int canvasHeight = getHeight () - fontHeight - 1;
    int w = getWidth ();
    if (canvasHeight < totalLinesHeight) {
        int x = event.getX ();
        int y = event.getY ();
        if (x > getWidth () - scrollWidth && y < canvasHeight) {
            newthumbMoused = true;
        }
    }
    if (thumbMoused != newthumbMoused) {
        thumbMoused = newthumbMoused;
        outputDirty = true;
        repaint ();
    }
}


public void mousePressed (MouseEvent arg0) {
    Object source = arg0.getSource ();
    if (source == imageRegion) {
        checkMove = 0;
        xStart = arg0.getX ();
        yStart = arg0.getY ();
        drag = true;
        dx = dy = 0;
        xdiff = 0;
        ydiff = 0;
        imageRegion.repaint ();
    }
    else if (source == slider1 || source == slider2) {
        drag = true;
    }
}


-----Function Pair=36=-----==

protected void newCluster () {
    newCluster = new SimpleNode ();
    newCluster.setHeight (newNodeHeight ());
    newCluster.addChild (clusters [abi]);
    newCluster.addChild (clusters [abj]);
    clusters [abi] = newCluster;
    clusters [abj] = null;
    for (int k = 0; k < numClusters; k ++) {
        if (k != besti && k != bestj) {
            int ak = alias [k];
            distance [ak] [abi] = distance [abi] [ak] = updatedDistance (besti, bestj, k);
            distance [ak] [abj] = distance [abj] [ak] = - 1.0;
        }
    }
    distance [abi] [abi] = 0.0;
    distance [abj] [abj] = - 1.0;
    for (int i = bestj; i < numClusters - 1; i ++) {
        alias [i] = alias [i + 1];
    }
    tipCount [abi] += tipCount [abj];
    tipCount [abj] = 0;
    numClusters --;
}


boolean isImageTypeSupported (RenderedImage ri) {
    boolean isSupported = true;
    imageType = evaluateImageType (ri);
    switch (numberOfComponents) {
        case 4 :
            if (imageType == BufferedImage.TYPE_4BYTE_ABGR) {
                if (abgrSupported) {
                    imageFormatType = ImageFormatType.TYPE_BYTE_ABGR;
                }
                else {
                    imageFormatType = ImageFormatType.TYPE_BYTE_RGBA;
                    isSupported = false;
                }
                unitsPerPixel = 4;
            }
            else if (imageType == BufferedImage.TYPE_INT_ARGB) {
                imageFormatType = ImageFormatType.TYPE_INT_ARGB;
                unitsPerPixel = 1;
            }
            else if (is4ByteRGBA (ri)) {
                imageFormatType = ImageFormatType.TYPE_BYTE_RGBA;
                unitsPerPixel = 4;
            }
            else {
                imageFormatType = ImageFormatType.TYPE_BYTE_RGBA;
                isSupported = false;
                unitsPerPixel = 4;
            }
            break;
        case 3 :
            if (imageType == BufferedImage.TYPE_3BYTE_BGR) {
                imageFormatType = ImageFormatType.TYPE_BYTE_BGR;
                unitsPerPixel = 3;
            }
            else if (imageType == BufferedImage.TYPE_INT_BGR) {
                imageFormatType = ImageFormatType.TYPE_INT_BGR;
                unitsPerPixel = 1;
            }
            else if (imageType == BufferedImage.TYPE_INT_RGB) {
                imageFormatType = ImageFormatType.TYPE_INT_RGB;
                unitsPerPixel = 1;
            }
            else if (is3ByteRGB (ri)) {
                imageFormatType = ImageFormatType.TYPE_BYTE_RGB;
                unitsPerPixel = 3;
            }
            else {
                imageFormatType = ImageFormatType.TYPE_BYTE_RGB;
                isSupported = false;
                unitsPerPixel = 3;
            }
            break;
        case 2 :
            imageFormatType = ImageFormatType.TYPE_BYTE_LA;
            isSupported = false;
            unitsPerPixel = 2;
            break;
        case 1 :
            if (imageType == BufferedImage.TYPE_BYTE_GRAY) {
                imageFormatType = ImageFormatType.TYPE_BYTE_GRAY;
                unitsPerPixel = 1;
            }
            else {
                imageFormatType = ImageFormatType.TYPE_BYTE_GRAY;
                isSupported = false;
                unitsPerPixel = 1;
            }
            break;
        default :
            throw new AssertionError ();
    }
    return isSupported;
}


-----Function Pair=37=-----==

static ImageProducer [] BitmapDir (byte [] imageData) {
    final int count = WORD (imageData, 4);
    final Order [] order = new Order [count];
    int offset = 6;
    for (int i = 0; i < count; ++ i) {
        order [i] = new Order (WORD (imageData, offset + 6), imageData [offset] & 0xff, Bitmap (imageData, DWORD (imageData, offset + 12), imageData [2]));
        offset += 16;
    }
    java.util.Arrays.sort (order);
    final ImageProducer [] producers = new ImageProducer [count];
    for (int i = 0; i < count; ++ i) {
        producers [i] = order [i].producer;
    }
    return producers;
}


public void doMemoryReadRaw (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    ret.append ("Actual memory (breakpoints shown as is):\n");
    int addr, count;
    switch (args.length) {
        case 0 :
            jdp_console.writeOutput (ret.toString ());
            printHelp (command);
            break;
        case 1 :
            try {
                addr = parseHex32 (args [0]);
                ret.append (user.mem.printRaw (addr, 5));
            } catch (NumberFormatException e) {
                ret.append ("bad address: " + args [0] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
        default :
            try {
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                ret.append (user.mem.printRaw (addr, count));
            } catch (NumberFormatException e) {
                ret.append ("bad address or count: " + args [0] + ", " + args [1] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
    }
}


-----Function Pair=38=-----==

void RefreshHintWindow () {
    ito = cursorPos;
    while (true) {
        if (ito == inputLine.length ()) break;
        if (! LispTokenizer.IsAlpha (inputLine.charAt (ito))) break;
        ito ++;
    }
    if (ito > 0) {
        int c = inputLine.charAt (ito - 1);
        if (c == ',' || c == ')') {
            int braces = - 1;
            if (c == ')') {
                ito --;
                braces = - 2;
            }
            while (braces != 0) {
                if (ito <= 0) break;
                if (inputLine.charAt (ito - 1) == '(') braces ++;
                if (inputLine.charAt (ito - 1) == ')') braces --;
                ito --;
            }
        }
    }
    if (ito > 0) {
        if (inputLine.charAt (ito - 1) == '(') {
            ito --;
        }
    }
    if (ito == 0) {
        while (true) {
            if (ito == cursorPos) break;
            if (! LispTokenizer.IsAlpha (inputLine.charAt (ito))) break;
            ito ++;
        }
    }
    int ifrom = ito;
    while (true) {
        if (ifrom == 0) break;
        char c = inputLine.charAt (ifrom - 1);
        if (! LispTokenizer.IsAlpha (c) && ! LispTokenizer.IsDigit (c)) break;
        ifrom --;
    }
    while (ifrom < ito && LispTokenizer.IsDigit (inputLine.charAt (ifrom))) ifrom ++;
    matchToInsert = "";
    lastMatchedWord = "";
    if (ito > ifrom) {
        lastMatchedWord = inputLine.substring (ifrom, ito);
    }
    hintWindow = null;
    if (lastMatchedWord.length () > 0) {
        int nr = lastMatchedWord.length ();
        int maxHintLines = 18;
        String texts [] = new String [maxHintLines + 1];
        int nrHintLines = 0;
        int i;
        for (i = 0; i < the_hints.nrHintTexts; i ++) {
            if (nrHintLines == maxHintLines) break;
            if (nr <= (the_hints.hintTexts [i].base).length () && lastMatchedWord.equals (the_hints.hintTexts [i].base.substring (0, nr))) {
                boolean add = true;
                if (nrHintLines > 0) {
                    if (texts [nrHintLines - 1].equals (the_hints.hintTexts [i].base)) add = false;
                }
                if (add) {
                    texts [nrHintLines ++] = the_hints.hintTexts [i].base;
                }
                if (nrHintLines == 1 && ito != cursorPos && lastMatchedWord.equals (the_hints.hintTexts [i].base)) {
                    break;
                }
            }
        }
        if (nrHintLines == maxHintLines) {
            texts [nrHintLines ++] = "...";
        }
        if (nrHintLines == 1) {
            if (lastMatchedWord.length () < texts [0].length ()) {
                matchToInsert = texts [0].substring (lastMatchedWord.length (), texts [0].length ());
            }
            hintWindow = TryToHint (texts [0], texts [0].length ());
        }
        else if (nrHintLines > 1) {
            hintWindow = CreateHints (12);
            hintWindow.iAllowSelection = true;
            for (i = 0; i < nrHintLines; i ++) {
                AddHintLine (hintWindow, texts [i], "");
            }
        }
    }
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=39=-----==

protected void receiveChatLogoff (YMSG9Packet pkt) {
    try {
        String netname = pkt.getValue ("104");
        String id = pkt.getValue ("109");
        YahooChatLobby ycl = YahooChatCategory.getLobby (netname);
        if (ycl == null) throw new NoSuchChatroomException ("Chatroom/lobby " + netname + " not found.");
        YahooChatUser ycu = ycl.getUser (id);
        if (ycu != null) ycl.removeUser (ycu);
        else ycu = createChatUser (pkt, 0);
        SessionChatEvent se = new SessionChatEvent (this, 1, ycl);
        se.setChatUser (0, ycu);
        new FireEvent ().fire (se, SERVICE_CHATLOGOFF);
    } catch (Exception e) {
        throw new YMSG9BadFormatException ("chat logoff", false, e);
    }
}


public static BreakpointLocation [] breakpointParse (String name, boolean isMethod) throws BmapNotFoundException {
    String origName = name;
    int line = - 1;
    int colon = name.indexOf (':');
    if (colon >= 0) {
        try {
            line = Integer.parseInt (name.substring (colon + 1));
        } catch (NumberFormatException e) {
            throw new BmapNotFoundException ("Bad line number in breakpoint location: " + origName);
        }
        name = name.substring (0, colon);
    }
    if (name.length () == 0) {
        throw new BmapNotFoundException ("Breakpoint location does not specify any class or method: " + origName);
    }
    int dot = name.lastIndexOf ('.');
    if (dot < 0 && isMethod) {
        throw new BmapNotFoundException ("Breakpoint location cannot be a method: " + origName);
    }
    Vector interpretationList = new Vector ();
    if (dot != - 1) {
        interpretationList.add (new BreakpointLocation (name.substring (0, dot), name.substring (dot + 1), line));
    }
    if (! isMethod || dot == - 1) {
        interpretationList.add (new BreakpointLocation (name, null, line));
    }
    BreakpointLocation [] result = new BreakpointLocation [interpretationList.size ()];
    interpretationList.copyInto (result);
    return result;
}


-----Function Pair=40=-----==

private void deleteFriend (YahooUser yu, String gr) {
    int idx, j;
    for (idx = 0; idx < groups.length; idx ++) if (groups [idx].getName ().equalsIgnoreCase (gr)) break;
    if (idx >= groups.length) return;
    j = groups [idx].getIndexOfFriend (yu.getId ());
    if (j < 0) return;
    groups [idx].removeUserAt (j);
    yu.adjustGroupCount (- 1);
    if (groups [idx].isEmpty ()) {
        YahooGroup [] arr = new YahooGroup [groups.length - 1];
        for (j = 0; j < idx; j ++) arr [j] = groups [j];
        for (j = idx; j < arr.length; j ++) arr [j] = groups [j + 1];
        groups = arr;
    }
}


private static Date couppcd (Date settle, Date maturi, int frequency, int basis) {
    GregorianCalendar couppcd = new GregorianCalendar ();
    GregorianCalendar settleD = new GregorianCalendar ();
    settleD.setTime (settle);
    couppcd.setTime (maturi);
    couppcd.set (Calendar.YEAR, settleD.get (Calendar.YEAR));
    if (couppcd.after (settleD)) {
        couppcd.add (Calendar.YEAR, - 1);
    }
    while (! couppcd.after (settleD)) {
        couppcd.add (Calendar.MONTH, frequency);
    }
    couppcd.add (Calendar.MONTH, - 1 * frequency);
    return couppcd.getTime ();
}


-----Function Pair=41=-----==

public static void main (String [] args) {
    try {
        DiagSignalHandler.install ("SIGINT");
        Class < ? > wrappedClass = Class.forName (args [0]);
        String wrappedArgs [] = new String [args.length - 1];
        for (int i = 0; i < wrappedArgs.length; i ++) {
            wrappedArgs [i] = args [i + 1];
        }
        Class < ? > [] argTypes = new Class [1];
        argTypes [0] = wrappedArgs.getClass ();
        Method mainMethod = wrappedClass.getMethod ("main", argTypes);
        Object [] argValues = new Object [1];
        argValues [0] = wrappedArgs;
        mainMethod.invoke (wrappedClass, argValues);
    } catch (Exception e) {
        System.out.println ("AppWrap exception " + e);
    }
}


Point2D.Double [] getPerimeterPoints_AveragePlusAdvance (int n_average, int n_advance) {
    if (n_advance == 0) n_advance = 1;
    if (n_average == 0) n_average = 1;
    double [] sx = new double [x.length];
    double [] sy = new double [x.length];
    int max = (int) (x.length / n_advance) * n_advance;
    int last_set = x.length - max;
    if (last_set < n_average) max -= n_average;
    else max -= last_set;
    int count = 0;
    for (int i = 0; i < max; i += n_advance) {
        sx [count] = x [i];
        sy [count] = y [i];
        for (int j = 1; j < n_average; j ++) {
            sx [count] += x [i + j];
            sy [count] += y [i + j];
        }
        sx [count] = sx [count] / n_average;
        sy [count] = sy [count] / n_average;
        count ++;
    }
    Point2D.Double [] points = new Point2D.Double [count];
    for (int k = 0; k < count; k ++) {
        points [k] = new Point2D.Double (sx [k], sy [k]);
    }
    return points;
}


-----Function Pair=42=-----==

public double getNumericValueAsDoubleSkipColNames (int numericColumnIndex, int row) {
    Object dataNumeric = dataSetNumericAndSpatial [numericColumnIndex + 1];
    double [] doubleData = null;
    double doubleVal = Double.NaN;
    if (dataNumeric instanceof double []) {
        doubleData = (double []) dataNumeric;
        doubleVal = doubleData [row];
    }
    else if (dataNumeric instanceof int []) {
        int [] intData = (int []) dataNumeric;
        doubleVal = intData [row];
    }
    else {
        String temp = ((String []) dataNumeric) [row];
        logger.finest ("\n" + dataNumeric.getClass () + "=" + temp + ", col=" + (numericColumnIndex + 1) + "(d=" + numNumericAttributes + "), row=" + row + "\n");
        throw new IllegalArgumentException ("Unable to parse values in column " + numericColumnIndex + " as a number");
    }
    return doubleVal;
}


public static String [] varParseField (String name) {
    String remain;
    String thisfield = name;
    int dot1, dot2, bracket;
    int numfield = varCountField (name);
    String fields [] = new String [numfield];
    remain = name;
    if (numfield == 0) {
        return null;
    }
    for (int i = 0; i < numfield; i ++) {
        dot1 = remain.indexOf ('.');
        dot2 = remain.indexOf ('.', dot1 + 1);
        if (dot1 != - 1 && dot2 != - 1) {
            thisfield = remain.substring (dot1 + 1, dot2);
            remain = remain.substring (dot1 + 1);
        }
        else if (dot1 != - 1 && dot2 == - 1) {
            thisfield = remain.substring (dot1 + 1);
        }
        else {
            System.out.println ("ERROR: parsing " + name);
        }
        bracket = thisfield.indexOf ('[');
        if (bracket != - 1) {
            fields [i] = thisfield.substring (0, bracket);
        }
        else {
            fields [i] = thisfield;
        }
    }
    return fields;
}


-----Function Pair=43=-----==

private RdpPacket_Localised receive (int [] type) throws IOException, RdesktopException, CryptoException, OrderException {
    int length = 0;
    if ((this.stream == null) || (this.next_packet >= this.stream.getEnd ())) {
        this.stream = SecureLayer.receive ();
        if (stream == null) return null;
        this.next_packet = this.stream.getPosition ();
    }
    else {
        this.stream.setPosition (this.next_packet);
    }
    length = this.stream.getLittleEndian16 ();
    if (length == 0x8000) {
        logger.warn ("32k packet keepalive fix");
        next_packet += 8;
        type [0] = 0;
        return stream;
    }
    type [0] = this.stream.getLittleEndian16 () & 0xf;
    if (stream.getPosition () != stream.getEnd ()) {
        stream.incrementPosition (2);
    }
    this.next_packet += length;
    return stream;
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=44=-----==

public void onModuleLoad () {
    rb = new RequestBuilder (RequestBuilder.POST, HOST);
    chat = new String [CHATLENGTH];
    for (int i = 0; i < chat.length; i ++) {
        chat [i] = "";
    }
    label = new Label ("Enter your nick:");
    nickField = new TextBox ();
    nickField.setMaxLength (8);
    button = new Button ("Submit");
    errorLabel = new Label ("");
    button.addClickListener (new ClickListener () {
        public void onClick (Widget w) {
            nick = nickField.getText ();
            nick = nick.replaceAll (" ", "");
            if (nick.length () > 0) {
                nick = nickField.getText ();
                send ("LOGIN", null);
            }
            else {
                errorLabel.setText ("Please enter a nick!");
            }
        }
    }
    );
    chatArea = new TextArea ();
    chatBox = new TextBox ();
    nickList = new ListBox ();
    nickList.setVisibleItemCount (15);
    chatArea.setSize ("640px", "480px");
    chatArea.setReadOnly (true);
    chatBox.setWidth ("640px");
    chatBox.addKeyboardListener (new KeyboardListener () {
        public void onKeyDown (Widget arg0, char arg1, int arg2) {
        } public void onKeyPress (Widget arg0, char arg1, int arg2) {
            if (arg1 == 13) {
                appendText (nick + ": " + chatBox.getText ());
                JSONObject o = new JSONObject ();
                o.put ("TEXT", new JSONString (chatBox.getText ()));
                chatBox.setText ("");
                send ("SAY", o);
            }
        } public void onKeyUp (Widget arg0, char arg1, int arg2) {
        }
    }
    );
    RootPanel.get ().add (label);
    RootPanel.get ().add (nickField);
    RootPanel.get ().add (button);
    RootPanel.get ().add (errorLabel);
}


private void getNextChangingElement (int a0, boolean isWhite, int [] ret) {
    int [] pce = this.prevChangingElems;
    int ces = this.changingElemSize;
    int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
    if (isWhite) {
        start &= ~ 0x1;
    }
    else {
        start |= 0x1;
    }
    int i = start;
    for (; i < ces; i += 2) {
        int temp = pce [i];
        if (temp > a0) {
            lastChangingElement = i;
            ret [0] = temp;
            break;
        }
    }
    if (i + 1 < ces) {
        ret [1] = pce [i + 1];
    }
}


-----Function Pair=45=-----==

public void bind (ServiceClass serviceClass, Object implementor, boolean doAddToSupportedTypes, boolean registerServiceClass) throws DPWSException {
    if (registerServiceClass) this.serviceClass = serviceClass;
    if (serviceClass == null) return;
    List portTypeInfos = serviceClass.getPortTypeInfos ();
    if (portTypeInfos == null) return;
    if (implementor != null) {
        if (implementor.getClass ().getSuperclass ().equals (eu.more.core.internal.MOREService.class)) {
            eu.more.core.internal.MOREService moresrv = (eu.more.core.internal.MOREService) implementor;
            if (moresrv.isproxy) {
                for (int i = 0; i < portTypeInfos.size (); i ++) {
                    PortTypeInfo pti = (PortTypeInfo) portTypeInfos.get (i);
                    String interName = pti.getServerInterface ().getName ();
                    for (int j = 0; j < portTypeInfos.size (); j ++) {
                        PortTypeInfo portTypeInfo = (PortTypeInfo) portTypeInfos.get (j);
                        Class serverInterface = portTypeInfo.getServerInterface ();
                        if (fillInformation (serverInterface, interName, portTypeInfo, implementor, false, doAddToSupportedTypes)) break;
                        Class handlerInterface = portTypeInfo.getHandlerInterface ();
                        if (fillInformation (handlerInterface, interName, portTypeInfo, implementor, true, doAddToSupportedTypes)) break;
                    }
                }
            }
        }
        Class [] inters = implementor.getClass ().getInterfaces ();
        for (int i = 0; i < inters.length; i ++) {
            String interName = inters [i].getName ();
            for (int j = 0; j < portTypeInfos.size (); j ++) {
                PortTypeInfo portTypeInfo = (PortTypeInfo) portTypeInfos.get (j);
                Class serverInterface = portTypeInfo.getServerInterface ();
                if (fillInformation (serverInterface, interName, portTypeInfo, implementor, false, doAddToSupportedTypes)) break;
                Class handlerInterface = portTypeInfo.getHandlerInterface ();
                if (fillInformation (handlerInterface, interName, portTypeInfo, implementor, true, doAddToSupportedTypes)) break;
            }
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=46=-----==

public static void main (String args []) throws Exception {
    String loc_str = System.getProperty ("java.class.path");
    String path_separator = System.getProperty ("path.separator");
    StringTokenizer strTok = new StringTokenizer (loc_str, path_separator);
    String [] locs = new String [strTok.countTokens ()];
    for (int i = 0; strTok.hasMoreElements (); i ++) {
        locs [i] = strTok.nextToken ();
    }
    Properties chxProps = getProperties ();
    loc_str = chxProps.getProperty ("locations");
    strTok = new StringTokenizer (loc_str, path_separator);
    String [] locs2 = new String [locs.length + strTok.countTokens ()];
    for (int i = 0; i < locs.length; i ++) {
        locs2 [i] = locs [i];
    }
    for (int i = locs.length; strTok.hasMoreElements (); i ++) {
        locs2 [i] = strTok.nextToken ();
    }
    Node node = TreeBuilder.buildTree (locs2);
    ClassLoader cloader = new ChxClassLoader (node);
    String [] prog_args = new String [args.length - 1];
    for (int i = 0; i < prog_args.length; i ++) {
        prog_args [i] = args [i + 1];
    }
    TreeViewer viewer = new TreeViewer (node);
    JFrame frame = new JFrame ("Tree Viewer");
    frame.getContentPane ().add (viewer, BorderLayout.CENTER);
    JButton go = new JButton ("Go");
    go.addActionListener (new Main (args [0], prog_args, cloader));
    frame.getContentPane ().add (go, BorderLayout.SOUTH);
    frame.addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            System.exit (0);
        }
    }
    );
    frame.setSize (300, 400);
    frame.show ();
}


String substitute (String input, String var, String [] fields, String [] fieldData) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        if (DEBUG) System.out.println ("checking for occurrence of " + var + " in :" + input.substring (oidx));
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        if (input.charAt (idx) != '.') throw new IOException ("no field");
        idx ++;
        int idx_save = idx;
        for (int i = 0; i < fields.length; i ++) {
            String fld = fields [i];
            int flen = fld.length ();
            if (DEBUG) System.out.println ("checking if it is field " + fld);
            if (input.regionMatches (idx, fld, 0, flen)) {
                String value = fieldData [i];
                if (DEBUG) System.out.println ("field matches. outputting data :" + value);
                out.append (value);
                idx += flen;
                break;
            }
        }
        if (idx == idx_save) throw new IOException ("unknown field");
        oidx = idx;
    }
    if (DEBUG) System.out.println ("no more variables left on this line");
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=47=-----==

public void inLineEdit (final TableTreeEditor editor) {
    Control oldEditor = editor.getEditor ();
    if (oldEditor != null) oldEditor.dispose ();
    TableTreeItem [] selection = listEpsTree.getSelection ();
    if (selection.length == 0) return;
    final TableTreeItem item = selection [0];
    final Text text = new Text (listEpsTree.getTable (), SWT.NONE);
    editor.horizontalAlignment = SWT.LEFT;
    editor.grabHorizontal = true;
    editor.setEditor (text, item, 1);
    text.setText (item.getText (1));
    text.setFocus ();
    text.addKeyListener (new KeyListener () {
        public void keyPressed (KeyEvent e) {
            int escPressed = 0;
            switch (e.character) {
                case SWT.CR :
                    escPressed = 1;
                    break;
            }
            if (escPressed == 1) {
                lines [1] = item.getText (0);
                lines [2] = text.getText ();
                epiMaker = new EpiMaker ();
                epiMaker.commentWriter (pluginInterface, lines);
                Control oldEditor = editor.getEditor ();
                if (oldEditor != null) {
                    oldEditor.dispose ();
                }
                if (! item.isDisposed ()) item.setText (1, lines [2]);
            }
        } public void keyReleased (KeyEvent e) {
        }
    }
    );
}


public SOCRobotNegotiator (SOCRobotBrain br) {
    brain = br;
    strategyType = br.getRobotParameters ().getStrategyType ();
    playerTrackers = brain.getPlayerTrackers ();
    ourPlayerTracker = brain.getOurPlayerTracker ();
    ourPlayerData = brain.getOurPlayerData ();
    buildingPlan = brain.getBuildingPlan ();
    decisionMaker = brain.getDecisionMaker ();
    game = brain.getGame ();
    isSellingResource = new boolean [SOCGame.MAXPLAYERS] [SOCResourceConstants.MAXPLUSONE];
    resetIsSelling ();
    wantsAnotherOffer = new boolean [SOCGame.MAXPLAYERS] [SOCResourceConstants.MAXPLUSONE];
    resetWantsAnotherOffer ();
    offersMade = new Vector ();
    targetPieces = new SOCPossiblePiece [SOCGame.MAXPLAYERS];
    resetTargetPieces ();
}


-----Function Pair=48=-----==

void updateHashtable (int to, int from) {
    byte [] data = new byte [3];
    int hash;
    Link temp;
    for (int i = to; i < from; i ++) {
        if (i + MIN_LENGTH > inLength) {
            break;
        }
        data [0] = in [i];
        data [1] = in [i + 1];
        data [2] = in [i + 2];
        hash = hash (data);
        if (window [nextWindow].previous != null) {
            window [nextWindow].previous.next = null;
        }
        else if (window [nextWindow].hash != 0) {
            hashtable [window [nextWindow].hash].next = null;
        }
        window [nextWindow].hash = hash;
        window [nextWindow].value = i;
        window [nextWindow].previous = null;
        temp = window [nextWindow].next = hashtable [hash].next;
        hashtable [hash].next = window [nextWindow];
        if (temp != null) {
            temp.previous = window [nextWindow];
        }
        nextWindow = nextWindow + 1;
        if (nextWindow == WINDOW) {
            nextWindow = 0;
        }
    }
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=49=-----==

private byte [] Encrypt (int [] timeData, int flag, int [] [] keyarray) {
    int i;
    byte [] encrypt = new byte [8];
    int flags = flag;
    int [] M = new int [64];
    int [] MIP_1 = new int [64];
    for (i = 0; i < 64; i ++) {
        M [i] = timeData [IP [i] - 1];
    }
    if (flags == 1) {
        for (i = 0; i < 16; i ++) {
            LoopF (M, i, flags, keyarray);
        }
    }
    else if (flags == 0) {
        for (i = 15; i > - 1; i --) {
            LoopF (M, i, flags, keyarray);
        }
    }
    for (i = 0; i < 64; i ++) {
        MIP_1 [i] = M [IP_1 [i] - 1];
    }
    GetEncryptResultOfByteArray (MIP_1, encrypt);
    return encrypt;
}


public static boolean containspID (Object anArray, Object anElement) {
    if (anArray == null) return false;
    if (anArray instanceof Object []) {
        Object [] oa = (Object []) anArray;
        for (int i = 0; i < oa.length; i ++) {
            if (oa [i] == anElement) return true;
        }
    }
    else {
        int len = Array.getLength (anArray);
        for (int i = 0; i < len; i ++) {
            if (Array.get (anArray, i) == anElement) return true;
        }
    }
    return false;
}


-----Function Pair=50=-----==

public IPalette getPalette () {
    if (m_src_index_color_model != null) {
        ColorModel color_model = m_src_index_color_model;
        if (color_model instanceof IndexColorModel) {
            IndexColorModel model = (IndexColorModel) color_model;
            int size = model.getMapSize ();
            byte [] ra = new byte [size];
            byte [] ga = new byte [size];
            byte [] ba = new byte [size];
            byte [] alphaa = new byte [size];
            model.getReds (ra);
            model.getGreens (ga);
            model.getBlues (ba);
            model.getAlphas (alphaa);
            int transparent_color_index = - 1;
            byte [] data = new byte [256 * 3];
            for (int i = 0, j = 0; (i < size) && (j < data.length); ++ i) {
                data [j ++] = ra [i];
                data [j ++] = ga [i];
                data [j ++] = ba [i];
                if (alphaa [i] == 0) transparent_color_index = i;
            }
            return new CPalette (data, (short) size, (short) transparent_color_index);
        }
    }
    return null;
}


private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandHMMStates (HMM [] hmms, edu.cmu.sphinx.decoder.linguist.UnitState unitState) {
    edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = new CombineState (unitState, 0);
    HMMStateArc [] arcs = new HMMStateArc [acousticModels.length];
    for (int i = 0; i < hmms.length; i ++) {
        HMMState hmmState = hmms [i].getInitialState ();
        ParallelHMMStateState firstHMMState = new ParallelHMMStateState (unitState, acousticModels [i].getName (), hmmState, tokenStackCapacity);
        firstHMMState.setColor (Color.GREEN);
        attachState (unitState, firstHMMState, 0.0, 0.0, 0.0);
        attachState (firstHMMState, lastState, 0.0, 0.0, 0.0);
        HMMStateArc selfTransition = getSelfTransition (hmmState);
        if (selfTransition != null) {
            double selfTransitionScore = logMath.linearToLog (selfTransition.getProbability ());
            attachState (lastState, firstHMMState, selfTransitionScore, 0.0, 0.0);
        }
        arcs [i] = getTransitionToNextState (hmmState);
    }
    for (int i = 1; i <= hmms [0].getOrder (); i ++) {
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState combineState = new CombineState (unitState, i);
        for (int a = 0; a < arcs.length; a ++) {
            HMMStateArc arc = arcs [a];
            HMMState hmmState = arc.getHMMState ();
            ParallelHMMStateState hmmStateState = new ParallelHMMStateState (unitState, acousticModels [a].getName (), hmmState, tokenStackCapacity);
            hmmStateState.setColor (Color.GREEN);
            attachState (lastState, hmmStateState, logMath.linearToLog (arc.getProbability ()), 0.0, 0.0);
            attachState (hmmStateState, combineState, 0.0, 0.0, 0.0);
            HMMStateArc selfTransition = getSelfTransition (hmmState);
            if (selfTransition != null) {
                double selfTransitionScore = logMath.linearToLog (selfTransition.getProbability ());
                attachState (combineState, hmmStateState, selfTransitionScore, 0.0, 0.0);
            }
            arcs [a] = getTransitionToNextState (hmmState);
        }
        lastState = combineState;
    }
    return lastState;
}


-----Function Pair=51=-----==

public Expression inline (Environment env, Context ctx) {
    if (implementation != null) return implementation.inline (env, ctx);
    try {
        if (right != null) {
            right = field.isStatic () ? right.inline (env, ctx) : right.inlineValue (env, ctx);
        }
        for (int i = 0; i < args.length; i ++) {
            args [i] = args [i].inlineValue (env, ctx);
        }
        ClassDefinition ctxClass = ctx.field.getClassDefinition ();
        Expression e = this;
        if (env.opt () && field.isInlineable (env, clazz.isFinal ()) && ((right == null) || (right.op == THIS) || field.isStatic ()) && ctxClass.permitInlinedAccess (env, field.getClassDeclaration ()) && ctxClass.permitInlinedAccess (env, field) && (right == null || ctxClass.permitInlinedAccess (env, env.getClassDeclaration (right.type))) && ((id == null) || ! id.equals (idInit)) && (! ctx.field.isInitializer ()) && ctx.field.isMethod () && (ctx.getInlineMemberContext (field) == null)) {
            Statement s = (Statement) field.getValue (env);
            if ((s == null) || (s.costInline (MAXINLINECOST, env, ctx) < MAXINLINECOST)) {
                e = inlineMethod (env, ctx, s, false);
            }
        }
        return e;
    } catch (ClassNotFound e) {
        throw new CompilerError (e);
    }
}


private double intensityLinInterval (double start, double end, int index) {
    final double dx = end - start;
    if (dx == 0) {
        return 0;
    }
    final double popStart = values [index];
    final double popDiff = (index < values.length - 1) ? values [index + 1] - popStart : 0.0;
    if (popDiff == 0.0) {
        return dx / popStart;
    }
    final double time0 = times [index];
    final double interval = intervals [index];
    assert (float) start <= (float) (time0 + interval) && start >= time0 && (float) end <= (float) (time0 + interval) && end >= time0;
    final double p1minusp0 = ((end - start) / interval) * popDiff;
    final double v = interval * (popStart / popDiff);
    final double p1overp0 = (v + (end - time0)) / (v + (start - time0));
    if (p1minusp0 == 0.0 || p1overp0 <= 0) {
        final double pop0 = popStart + ((start - time0) / interval) * popDiff;
        return dx / pop0;
    }
    return dx * Math.log (p1overp0) / p1minusp0;
}


-----Function Pair=52=-----==

private void findCloseIn (AuditTrailEntryList ates, AuditTrailEntry ate, int baseAteIndex, int distance, HashMap < String, Integer > ateIDMap, HashMap < String, Integer > iD2Ate, DoubleMatrix2D D, int numSimilarPIs, List < AuditTrailEntry > inSide) throws IOException {
    String ateSucs = ate.getAttributes ().get (ProcessInstance.ATT_ATE_POST);
    StringTokenizer st = new StringTokenizer (ateSucs, ",", false);
    while (st.hasMoreTokens ()) {
        String nextAteId = st.nextToken ();
        int nextAteIndex = ateIDMap.get (nextAteId).intValue ();
        if (distance == 0) {
            if (baseAteIndex == nextAteIndex) {
                Iterator < AuditTrailEntry > ateIt = inSide.iterator ();
                while (ateIt.hasNext ()) {
                    AuditTrailEntry ateInside = ateIt.next ();
                    int insideAteIndex = modelElements.findLogEventNumber (ateInside.getElement (), ateInside.getType ());
                    D.set (baseAteIndex, insideAteIndex, D.get (baseAteIndex, insideAteIndex) + numSimilarPIs);
                }
            }
        }
        else {
            AuditTrailEntry thisAte = ates.get (iD2Ate.get (nextAteId).intValue ());
            inSide.add (thisAte);
            findCloseIn (ates, thisAte, baseAteIndex, distance - 1, ateIDMap, iD2Ate, D, numSimilarPIs, inSide);
        }
    }
    if (distance == 0) {
        inSide.remove (inSide.size () - 1);
    }
}


private breakpoint setBreakpointAtStringClass (JDP_Field stringField) {
    JDP_Class stringClass = new JDP_Class ();
    stringClass.name = stringField.type;
    stringClass.address = stringField.address;
    try {
        user.bmap.classToJDPClass (stringClass.name, stringClass.address, false, stringClass);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field valueField = (JDP_Field) stringClass.fields.elementAt (0);
    String charArrayString = valueField.value;
    charArrayString = charArrayString.substring (1, charArrayString.indexOf ('}'));
    StringTokenizer st = new StringTokenizer (charArrayString, ", ", false);
    StringBuffer ret = new StringBuffer ();
    while (st.hasMoreTokens ()) {
        ret.append (st.nextToken ());
    }
    String className = ret.toString ();
    breakpoint bp = null;
    try {
        bp = user.bmap.findBreakpoint (className + ".main", null, user.reg.hardwareIP ());
    } catch (BmapMultipleException e1) {
        jdp_console.writeOutput (e1.getMessage ());
    } catch (BmapNotFoundException e2) {
        jdp_console.writeOutput (e2.getMessage ());
    }
    user.bpset.setBreakpoint (bp);
    return bp;
}


-----Function Pair=53=-----==

public void moveEvent (ScrEvent event, int newTime) {
    int index = indexOf (event);
    int newIndex = getIndexAfter (newTime);
    if (newIndex == NO_SUCH_EVENT) newIndex = events_fill_p - 1;
    else if (event.getTime () <= newTime) newIndex -= 1;
    if (index == NO_SUCH_EVENT) {
        System.err.println ("no such event error");
        for (int i = 0; i < length (); i ++) {
            System.err.println ("#" + i + " t " + getEventAt (i).getTime () + " p " + getEventAt (i).getPitch ());
        }
        return;
    }
    if (index == EMPTY_COLLECTION) index = 0;
    event.setTime (newTime);
    Object args [] = new Object [6];
    args [0] = new Integer (index);
    args [1] = new Integer (event.getTime ());
    args [2] = new Integer (event.getPitch ());
    args [3] = new Integer (event.getVelocity ());
    args [4] = new Integer (event.getDuration ());
    args [5] = new Integer (event.getChannel ());
    remoteCall (REMOTE_CHANGE, args);
    if (index < newIndex) {
        for (int i = index; i < newIndex; i ++) {
            events [i] = events [i + 1];
        }
    }
    else {
        for (int i = index; i > newIndex; i --) {
            events [i] = events [i - 1];
        }
        events [newIndex] = event;
    }
    events [newIndex] = event;
    notifyObjectMoved (event, index, newIndex);
}


private void paintCanvas (RepaintEvent ev) {
    Graphics2D g = ev.getGraphics ();
    paintAxes (g);
    g.setColor (Color.black);
    if (smoothBox.getState ()) {
        int lastx = handlePos [0].x, lasty = handlePos [0].y;
        for (int i = 0; i < handlePos.length - 1; i ++) {
            double dx = x [i + 1] - x [i];
            if (dx == 0.0) {
                g.drawLine (lastx, lasty, handlePos [i + 1].x, handlePos [i + 1].y);
                lastx = handlePos [i + 1].x;
                lasty = handlePos [i + 1].y;
                continue;
            }
            for (int j = 1; j < 8; j ++) {
                double xf = x [i] + j * 0.125 * dx, yf = editModule.calcValue (xf);
                int nextx = (int) (graphBounds.x + xf * graphBounds.width);
                int nexty = (int) (graphBounds.y + (maxy - yf) * graphBounds.height / (maxy - miny));
                g.drawLine (lastx, lasty, nextx, nexty);
                lastx = nextx;
                lasty = nexty;
            }
            g.drawLine (lastx, lasty, handlePos [i + 1].x, handlePos [i + 1].y);
            lastx = handlePos [i + 1].x;
            lasty = handlePos [i + 1].y;
        }
    }
    else for (int i = 0; i < handlePos.length - 1; i ++) g.drawLine (handlePos [i].x, handlePos [i].y, handlePos [i + 1].x, handlePos [i + 1].y);
    for (int i = 0; i < handlePos.length; i ++) {
        if (selected == i) g.setColor (Color.red);
        else g.setColor (Color.black);
        g.fillRect (handlePos [i].x - HANDLE_SIZE / 2, handlePos [i].y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
    }
}


-----Function Pair=54=-----==

public static float compare (Sequence ii, Sequence jj) {
    String si = ii.getSequence ();
    String sj = jj.getSequence ();
    int ilen = si.length ();
    int jlen = sj.length ();
    if (si.substring (ilen).equals ("-") || si.substring (ilen).equals (".") || si.substring (ilen).equals (" ")) {
        ilen --;
        while (si.substring (ilen, ilen + 1).equals ("-") || si.substring (ilen, ilen + 1).equals (".") || si.substring (ilen, ilen + 1).equals (" ")) {
            ilen --;
        }
    }
    if (sj.substring (jlen).equals ("-") || sj.substring (jlen).equals (".") || sj.substring (jlen).equals (" ")) {
        jlen --;
        while (sj.substring (jlen, jlen + 1).equals ("-") || sj.substring (jlen, jlen + 1).equals (".") || sj.substring (jlen, jlen + 1).equals (" ")) {
            jlen --;
        }
    }
    int count = 0;
    int match = 0;
    float pid = - 1;
    if (ilen > jlen) {
        for (int j = 0; j < jlen; j ++) {
            if (si.substring (j, j + 1).equals (sj.substring (j, j + 1))) {
                match ++;
            }
            count ++;
        }
        pid = (float) match / (float) ilen * 100;
    }
    else {
        for (int j = 0; j < jlen; j ++) {
            if (si.substring (j, j + 1).equals (sj.substring (j, j + 1))) {
                match ++;
            }
            count ++;
        }
        pid = (float) match / (float) jlen * 100;
    }
    return pid;
}


public void executeMath (String line, String arg) {
    int nr = getZmiennaByName (arg);
    if (nr >= 0) {
        String type = zmienna [nr].getType ();
        if (type.equalsIgnoreCase ("String")) {
            int nrT = getZmiennaByName (line.substring (0, line.length () - 1));
            if (nrT == - 1) {
                zmienna [nr].makeValue (line.substring (1, line.length () - 1));
            }
            else {
                zmienna [nr].makeValue (zmienna [nrT].getStringValue ());
            }
        }
        else if (type.equalsIgnoreCase ("boolean")) {
            int nrT = getZmiennaByName (line.substring (0, line.length () - 1));
            if (nrT == - 1) {
                if (line.substring (0, line.length () - 1).equalsIgnoreCase ("true")) {
                    zmienna [nr].makeValue (true);
                }
                else {
                    zmienna [nr].makeValue (false);
                }
            }
            else {
                zmienna [nr].makeValue (zmienna [nrT].getStringValue ());
            }
        }
        else {
            String wynik = countAritmetic (line, type);
            int intValue = 0;
            float floatValue = 0;
            if (type.equalsIgnoreCase ("integer")) {
                try {
                    intValue = Integer.parseInt (wynik);
                    zmienna [nr].makeValue (intValue);
                } catch (NumberFormatException e) {
                    intValue = 0;
                }
            }
            if (type.equalsIgnoreCase ("real")) {
                try {
                    floatValue = Float.parseFloat (wynik);
                    zmienna [nr].makeValue (floatValue);
                } catch (NumberFormatException e) {
                    floatValue = 0;
                }
            }
        }
    }
}


-----Function Pair=55=-----==

public void doMemoryReadRaw (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    ret.append ("Actual memory (breakpoints shown as is):\n");
    int addr, count;
    switch (args.length) {
        case 0 :
            jdp_console.writeOutput (ret.toString ());
            printHelp (command);
            break;
        case 1 :
            try {
                addr = parseHex32 (args [0]);
                ret.append (user.mem.printRaw (addr, 5));
            } catch (NumberFormatException e) {
                ret.append ("bad address: " + args [0] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
        default :
            try {
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                ret.append (user.mem.printRaw (addr, count));
            } catch (NumberFormatException e) {
                ret.append ("bad address or count: " + args [0] + ", " + args [1] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
    }
}


public static final int findBinary (int [] src, int key) {
    int high = src.length - 1;
    if (src [0] <= key && src [high] >= key) {
        int low = 0;
        for (int mid = (low + high)>> 1, v = src [mid]; low <= high; v = src [mid], mid = (low + high)>> 1) {
            if (v == key) {
                return mid;
            }
            else if (v < key) {
                low = mid + 1;
            }
            else {
                high = mid - 1;
            }
        }
    }
    return - 1;
}


-----Function Pair=56=-----==

public void notify (MauMauTableMessage m) {
    if (connected) {
        MauMauTableWatchDog wd = new MauMauTableWatchDog (Thread.currentThread (), playersName, "notify(" + m + ")");
        wd.start ();
        try {
            playersInterface.notify (m);
        } catch (SimonRemoteException s) {
            LOGGER.error (playersName + ".notify(" + m + ")", s);
            connected = false;
        } catch (ClassCastException c) {
            LOGGER.error (playersName + ".notify(" + m + ")", c);
            connected = false;
        } catch (InterruptedException i) {
            LOGGER.error (playersName + ".notify(" + m + ")", i);
            conditionTerminateMatchNameOfPlayerTimedOut = playersName;
        } finally {
            wd.interrupt ();
        }
    }
    else LOGGER.warn (playersName + ".notify(" + m + ") - not connected");
}


public RobotList sort_decr (RobotList list, String field) {
    if (list.clazz.equals (Float.class)) {
        return sort_decr_Float (list, field);
    }
    else if (list.clazz.equals (Resource.class)) {
        return sort_decr_Resource (list, field);
    }
    else if (list.clazz.equals (Enemy.class)) {
        return sort_decr_Enemy (list, field);
    }
    else if (list.clazz.equals (Percentage.class)) {
        return sort_decr_Percentage (list, field);
    }
    else if (list.clazz.equals (Location.class)) {
        return sort_decr_Location (list, field);
    }
    else {
        say ("impossible to sort list - nothing modified");
    }
    return list;
}


-----Function Pair=57=-----==

public DoubleSquareMatrix multiply (final DoubleTridiagonalMatrix m) {
    switch (m.storageFormat) {
        case TRIDIAGONAL :
            return rawMultiplyTridiagonal (m);
        default :
            int mRow = numRows;
            if (numCols == m.rows ()) {
                final double array [] [] = new double [mRow] [mRow];
                array [0] [0] = diag [0] * m.getElement (0, 0) + udiag [0] * m.getElement (1, 0);
                array [0] [1] = diag [0] * m.getElement (0, 1) + udiag [0] * m.getElement (1, 1);
                array [0] [2] = udiag [0] * m.getElement (1, 2);
                if (mRow > 3) {
                    array [1] [0] = ldiag [1] * m.getElement (0, 0) + diag [1] * m.getElement (1, 0);
                    array [1] [1] = ldiag [1] * m.getElement (0, 1) + diag [1] * m.getElement (1, 1) + udiag [1] * m.getElement (2, 1);
                    array [1] [2] = diag [1] * m.getElement (1, 2) + udiag [1] * m.getElement (2, 2);
                    array [1] [3] = udiag [1] * m.getElement (2, 3);
                }
                if (mRow == 3) {
                    array [1] [0] = ldiag [1] * m.getElement (0, 0) + diag [1] * m.getElement (1, 0);
                    array [1] [1] = ldiag [1] * m.getElement (0, 1) + diag [1] * m.getElement (1, 1) + udiag [1] * m.getElement (2, 1);
                    array [1] [2] = diag [1] * m.getElement (1, 2) + udiag [1] * m.getElement (2, 2);
                }
                else if (mRow > 4) {
                    for (int i = 2; i < mRow - 2; i ++) {
                        array [i] [i - 2] = ldiag [i] * m.getElement (i - 1, i - 2);
                        array [i] [i - 1] = ldiag [i] * m.getElement (i - 1, i - 1) + diag [i] * m.getElement (i, i - 1);
                        array [i] [i] = ldiag [i] * m.getElement (i - 1, i) + diag [i] * m.getElement (i, i) + udiag [i] * m.getElement (i + 1, i);
                        array [i] [i + 1] = diag [i] * m.getElement (i, i + 1) + udiag [i] * m.getElement (i + 1, i + 1);
                        array [i] [i + 2] = udiag [i] * m.getElement (i + 1, i + 2);
                    }
                }
                if (mRow > 3) {
                    array [mRow - 2] [mRow - 4] = ldiag [mRow - 2] * m.getElement (mRow - 3, mRow - 4);
                    array [mRow - 2] [mRow - 3] = ldiag [mRow - 2] * m.getElement (mRow - 3, mRow - 3) + diag [mRow - 2] * m.getElement (mRow - 2, mRow - 3);
                    array [mRow - 2] [mRow - 2] = ldiag [mRow - 2] * m.getElement (mRow - 3, mRow - 2) + diag [mRow - 2] * m.getElement (mRow - 2, mRow - 2) + udiag [mRow - 2] * m.getElement (mRow - 1, mRow - 2);
                    array [mRow - 2] [mRow - 1] = diag [mRow - 2] * m.getElement (mRow - 2, mRow - 1) + udiag [mRow - 2] * m.getElement (mRow - 1, mRow - 1);
                }
                mRow --;
                array [mRow] [mRow - 2] = ldiag [mRow] * m.getElement (mRow - 1, mRow - 2);
                array [mRow] [mRow - 1] = ldiag [mRow] * m.getElement (mRow - 1, mRow - 1) + diag [mRow] * m.getElement (mRow, mRow - 1);
                array [mRow] [mRow] = ldiag [mRow] * m.getElement (mRow - 1, mRow) + diag [mRow] * m.getElement (mRow, mRow);
                return new DoubleSquareMatrix (array);
            }
            else throw new MatrixDimensionException ("Incompatible matrices.");
    }
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=58=-----==

public void doRead (DataInputStream in) throws Exception {
    for (int i = 0; i < maxID; i ++) {
        users [i].numbertourneysbet = in.readInt ();
        users [i].totalturnover = in.readFloat ();
        users [i].messagevar = in.readBoolean ();
        users [i].nonoisevar = in.readBoolean ();
        users [i].eligible = in.readBoolean ();
        users [i].jin = in.readBoolean ();
        users [i].simOpen = in.readBoolean ();
        users [i].unpaidFT = in.readBoolean ();
        users [i].amountvar = in.readInt ();
        users [i].botvar = in.readInt ();
        users [i].initMasterPoints (in.readInt ());
        users [i].recordChips = in.readFloat ();
        users [i].selfBetType = in.readInt ();
        users [i].selfBetAmount = in.readInt ();
        users [i].slotProfits = in.readInt ();
        users [i].slotTurnover = in.readInt ();
        users [i].weeklySlotProfits = in.readInt ();
        users [i].weeklySlotTurnover = in.readInt ();
        users [i].monthlyFuturesTurnover = in.readInt ();
        users [i].doubleintmultiplier = in.readFloat ();
        int commentLength = in.readInt ();
        for (int j = 0; j < commentLength; j ++) {
            users [i].comments.addElement (new String (in.readLine ()));
        }
    }
}


public synchronized void decodeT6 (byte [] buffer, byte [] compData, int startX, int height, long tiffT6Options) {
    this.data = compData;
    compression = 4;
    bitPointer = 0;
    bytePointer = 0;
    int scanlineStride = (w + 7) / 8;
    int bufferOffset = 0;
    int a0, a1, b1, b2;
    int entry, code, bits;
    byte color;
    boolean isWhite;
    int currIndex;
    int temp [];
    int [] b = new int [2];
    uncompressedMode = (int) ((tiffT6Options & 0x02)>> 1);
    int [] cce = currChangingElems;
    changingElemSize = 0;
    cce [changingElemSize ++] = w;
    cce [changingElemSize ++] = w;
    int lineOffset = 0;
    int bitOffset;
    for (int lines = 0; lines < height; lines ++) {
        a0 = - 1;
        isWhite = true;
        temp = prevChangingElems;
        prevChangingElems = currChangingElems;
        cce = currChangingElems = temp;
        currIndex = 0;
        bitOffset = startX;
        lastChangingElement = 0;
        while (bitOffset < w) {
            getNextChangingElement (a0, isWhite, b);
            b1 = b [0];
            b2 = b [1];
            entry = nextLesserThan8Bits (7);
            entry = (int) (twoDCodes [entry] & 0xff);
            code = (entry & 0x78)>>> 3;
            bits = entry & 0x07;
            if (code == 0) {
                if (! isWhite) {
                    setToBlack (buffer, lineOffset, bitOffset, b2 - bitOffset);
                }
                bitOffset = a0 = b2;
                updatePointer (7 - bits);
            }
            else if (code == 1) {
                updatePointer (7 - bits);
                int number;
                if (isWhite) {
                    number = decodeWhiteCodeWord ();
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                    number = decodeBlackCodeWord ();
                    setToBlack (buffer, lineOffset, bitOffset, number);
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                }
                else {
                    number = decodeBlackCodeWord ();
                    setToBlack (buffer, lineOffset, bitOffset, number);
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                    number = decodeWhiteCodeWord ();
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                }
                a0 = bitOffset;
            }
            else if (code <= 8) {
                a1 = b1 + (code - 5);
                cce [currIndex ++] = a1;
                if (! isWhite) {
                    setToBlack (buffer, lineOffset, bitOffset, a1 - bitOffset);
                }
                bitOffset = a0 = a1;
                isWhite = ! isWhite;
                updatePointer (7 - bits);
            }
            else if (code == 11) {
                if (nextLesserThan8Bits (3) != 7) {
                    throw new Error (JaiI18N.getString ("TIFFFaxDecoder5"));
                }
                int zeros = 0;
                boolean exit = false;
                while (! exit) {
                    while (nextLesserThan8Bits (1) != 1) {
                        zeros ++;
                    }
                    if (zeros > 5) {
                        zeros = zeros - 6;
                        if (! isWhite && (zeros > 0)) {
                            cce [currIndex ++] = bitOffset;
                        }
                        bitOffset += zeros;
                        if (zeros > 0) {
                            isWhite = true;
                        }
                        if (nextLesserThan8Bits (1) == 0) {
                            if (! isWhite) {
                                cce [currIndex ++] = bitOffset;
                            }
                            isWhite = true;
                        }
                        else {
                            if (isWhite) {
                                cce [currIndex ++] = bitOffset;
                            }
                            isWhite = false;
                        }
                        exit = true;
                    }
                    if (zeros == 5) {
                        if (! isWhite) {
                            cce [currIndex ++] = bitOffset;
                        }
                        bitOffset += zeros;
                        isWhite = true;
                    }
                    else {
                        bitOffset += zeros;
                        cce [currIndex ++] = bitOffset;
                        setToBlack (buffer, lineOffset, bitOffset, 1);
                        ++ bitOffset;
                        isWhite = false;
                    }
                }
            }
            else {
                throw new Error (JaiI18N.getString ("TIFFFaxDecoder5"));
            }
        }
        cce [currIndex ++] = bitOffset;
        changingElemSize = currIndex;
        lineOffset += scanlineStride;
    }
}


-----Function Pair=59=-----==

private void addToJar (JarOutputStream out, InputStream in, String entryName, long length) throws IOException {
    byte [] buf = new byte [2048];
    ZipEntry entry = new ZipEntry (entryName);
    CRC32 crc = new CRC32 ();
    entry.setSize (length);
    entry.setCrc (crc.getValue ());
    out.putNextEntry (entry);
    int read = in.read (buf);
    while (read > 0) {
        crc.update (buf, 0, read);
        out.write (buf, 0, read);
        read = in.read (buf);
    }
    entry.setCrc (crc.getValue ());
    in.close ();
    out.closeEntry ();
}


protected boolean indexInStringArray (int field, int index) {
    int i = 1, add = 1, indexvalue = 0, count = 0;
    boolean found = false;
    int listType = getListType ();
    while (count < stringids [0]) {
        if (field == stringids [i] && index == stringids [i + 1]) {
            found = true;
            break;
        }
        if (PIMListImpl.getFieldDataTypeS (listType, stringids [i]) == PIMItem.STRING_ARRAY) add = PIMListImpl.getStringArraySizeS (listType, stringids [i]);
        i += 3;
        indexvalue += add;
        add = 1;
        count ++;
    }
    i2.int1 = i;
    i2.int2 = indexvalue;
    if (found || (field == - 1 && index == - 1)) return found;
    else throw new IndexOutOfBoundsException ();
}


-----Function Pair=60=-----==

private void bottomUpSink (Object [] src, Object element, int r, Comparator c) {
    int j = 0;
    int m = 1;
    while (m < r) {
        if (c.compare (src [m], src [m + 1]) == - 1) {
            src [j] = src [m + 1];
            j = m + 1;
        }
        else {
            src [j] = src [m];
            j = m;
        }
        m = j + j + 1;
    }
    if (m == r) {
        src [j] = src [r];
        j = r;
    }
    int i = ((j - 1) / 2);
    while (j > 0 && c.compare (src [i], element) == - 1) {
        src [j] = src [i];
        j = i;
        i = ((j - 1) / 2);
    }
    src [j] = element;
}


private int testOTP (String msg, String [] challenge) {
    String [] lines = Utilities.split (msg, "\r\n");
    for (int i = 0; i < lines.length; i ++) {
        String [] t = Utilities.split (lines [i], " ");
        for (int k = 1; k < t.length; k ++) {
            try {
                if (Pattern.matches ("[0-9]+", t [k])) {
                    challenge [0] = t [k];
                    challenge [1] = t [k + 1];
                    if (lines [i].indexOf ("md4") != - 1) return 4;
                    else return 5;
                }
            } catch (Exception e) {
            }
        }
    }
    return - 1;
}


-----Function Pair=61=-----==

public void visitSynchronized (JCSynchronized tree) {
    int limit = code.nextreg;
    final LocalItem lockVar = makeTemp (syms.objectType);
    genExpr (tree.lock, tree.lock.type).load ().duplicate ();
    lockVar.store ();
    code.emitop0 (monitorenter);
    code.state.lock (lockVar.reg);
    final Env < GenContext > syncEnv = env.dup (tree, new GenContext ());
    syncEnv.info.finalize = new GenFinalizer () {
        void gen () {
            genLast ();
            Assert.check (syncEnv.info.gaps.length () % 2 == 0);
            syncEnv.info.gaps.append (code.curPc ());
        } void genLast () {
            if (code.isAlive ()) {
                lockVar.load ();
                code.emitop0 (monitorexit);
                code.state.unlock (lockVar.reg);
            }
        }
    }
    ;
    syncEnv.info.gaps = new ListBuffer < Integer > ();
    genTry (tree.body, List.< JCCatch > nil (), syncEnv);
    code.endScopes (limit);
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=62=-----==

public dfp multiply (int x) {
    int r, rh, rl;
    int excp;
    int lostdigit;
    dfp result = newInstance (this);
    if (nans != FINITE) {
        if (nans == QNAN || nans == SNAN) return this;
        if (nans == INFINITE && x != 0) {
            result = newInstance (this);
            return result;
        }
        if (nans == INFINITE && x == 0) {
            ieeeFlags |= FLAG_INVALID;
            result = newInstance (zero);
            result.nans = QNAN;
            result = dotrap (FLAG_INVALID, "multiply", newInstance (zero), result);
            return result;
        }
    }
    if (x < 0 || x >= radix) {
        ieeeFlags |= FLAG_INVALID;
        result = newInstance (zero);
        result.nans = QNAN;
        result = dotrap (FLAG_INVALID, "multiply", result, result);
        return result;
    }
    rh = 0;
    for (int i = 0; i < DIGITS; i ++) {
        r = mant [i] * x + rh;
        rl = r % radix;
        rh = r / radix;
        result.mant [i] = rl;
    }
    lostdigit = 0;
    if (rh != 0) {
        lostdigit = result.mant [0];
        result.shiftRight ();
        result.mant [DIGITS - 1] = rh;
    }
    if (result.mant [DIGITS - 1] == 0) result.exp = 0;
    excp = result.round (lostdigit);
    if (excp != 0) result = dotrap (excp, "multiply", result, result);
    return result;
}


public void doPrintCommand (String command, String [] args) {
    int addr, frame;
    String varname;
    if (args.length == 0) {
        jdp_console.writeOutput (user.bmap.localVariableToString (0, null));
        return;
    }
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            addr = parseHex32 (args [1]);
            String classname = args [0].substring (1, rparen);
            try {
                jdp_console.writeOutput (classname + " = " + user.bmap.classToString (classname, addr, false));
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
        return;
    }
    frame = CommandLine.localParseFrame (args [0]);
    varname = CommandLine.localParseName (args [0]);
    if (frame != - 1) {
        if (varname == null) {
            jdp_console.writeOutput (user.bmap.localVariableToString (frame, null));
        }
        else {
            if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (frame, varname));
            else jdp_console.writeOutput (user.bmap.localVariableToString (frame, varname));
        }
        return;
    }
    if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (0, varname));
    else jdp_console.writeOutput (user.bmap.localVariableToString (0, varname));
    return;
}


-----Function Pair=63=-----==

private void locateCursor () {
    write ("\033[6n");
    read ();
    read ();
    cursorY = 0;
    for (;;) {
        int ch = read ();
        if (ch == ';') break;
        cursorY = cursorY * 10 + ch - '0';
    }
    cursorX = 0;
    for (;;) {
        int ch = read ();
        if (ch == 'R') break;
        cursorX = cursorX * 10 + ch - '0';
    }
}


private void fetchParameters () throws NoSuchFieldException {
    Parameter p;
    try {
        p = baseConfig.getParameterObjByKey ("Cut-off average boundary");
    } catch (NoSuchFieldException e) {
        logger.error ("No field called \"Cut-off average boundary\" found in " + methodName + "\n", e);
        throw e;
    }
    REMOVE_MULTIPLY_AVG = (Double) p.getValue ();
    try {
        p = baseConfig.getParameterObjByKey ("Minimal cell volume");
    } catch (NoSuchFieldException e) {
        logger.error ("No field called \"Minimal cell volume\" found in " + methodName + "\n", e);
        throw e;
    }
    minVolume = (Double) p.getValue ();
    try {
        p = baseConfig.getParameterObjByKey ("Minimal number of instances in cell");
    } catch (NoSuchFieldException e) {
        logger.error ("No field called \"Minimal number of instances in cell\" found in " + methodName + "\n", e);
        throw e;
    }
    minCount = (Integer) p.getValue ();
}


-----Function Pair=64=-----==

private Object [] fixMultiCommandPerLine (String [] [] code, int [] reallines) {
    LinkedList < String [] > output = new LinkedList < String [] > ();
    LinkedList < Integer > reallineslist = new LinkedList < Integer > ();
    for (int l = 0; l < code.length; l ++) {
        boolean ok = true;
        int pos = 0;
        for (int i = 0; i < code [l].length; i ++) {
            if (code [l] [i].length () != 0 && code [l] [i].charAt (0) == 59 && pos != i) {
                output.addLast (Arrays.copyOfRange (code [l], pos, i - 1));
                reallineslist.addLast (new Integer (reallines [l]));
                pos = i + 1;
                ok = false;
            }
        }
        if (! ok && pos != code [l].length) {
            output.addLast (Arrays.copyOfRange (code [l], pos, code [l].length));
            reallineslist.addLast (new Integer (reallines [l]));
        }
        if (ok) {
            output.addLast (code [l]);
            reallineslist.addLast (new Integer (reallines [l]));
        }
    }
    reallines = new int [reallineslist.size ()];
    ListIterator < Integer > it = reallineslist.listIterator ();
    int i = 0;
    while (it.hasNext ()) {
        reallines [i] = it.next ().intValue ();
        i ++;
    }
    return new Object [] {output.toArray (new String [0] [0]), reallines};
}


public static int [] varParseArrayDimension (String name) throws NumberFormatException {
    int bracketLeft, bracketRight;
    boolean gettingDimension = true;
    String dimString = name;
    int numDim = 0;
    int index = 0;
    int result [];
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        if (bracketRight == - 1) {
            gettingDimension = false;
        }
        else {
            numDim ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    result = new int [numDim];
    index = 0;
    dimString = name;
    gettingDimension = true;
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        bracketLeft = dimString.indexOf ('[');
        if (bracketRight == - 1 || bracketLeft == - 1) {
            gettingDimension = false;
        }
        else {
            result [index] = Integer.valueOf (dimString.substring (bracketLeft + 1, bracketRight)).intValue ();
            index ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    return result;
}


-----Function Pair=65=-----==

public void constructNetwork () {
    double layerError, firstLayerErr;
    iLayer = new InputLayer ();
    double sqerr;
    int i = 0;
    layerErr.reset ();
    myRandom.generateLearningAndTestingSet ((int) (group * (c.getVectorsInTestingSet () / 100.0)));
    maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
    actualLayer = i;
    layerError = firstLayerErr = Double.MAX_VALUE;
    GraphCanvas.getInstance ().setLayerConstruction (true);
    if (c.isJustTwo ()) {
        layer [i] = new Layer (i, iLayer, 2);
    }
    else {
        layer [i] = new Layer (i, iLayer, i + 2);
    }
    while ((sqerr = layer [i].teachLayer (iLayer)) < layerError) {
        if (i == 0) {
            firstLayerErr = sqerr;
        }
        if (i > 1) {
            if (((layerError - sqerr) * 30.0) < (firstLayerErr - layerError)) {
                if (! c.isBuildWhileDec ()) {
                    actualLayer = ++ i;
                    layerError = sqerr;
                    layerErr.add (sqerr);
                    break;
                }
            }
        }
        actualLayer = ++ i;
        layerError = sqerr;
        layerErr.add (sqerr);
        if (i > NetworkConfiguration.MAX_LAYERS - 2) {
            break;
        }
        maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
        if (c.isJustTwo ()) {
            layer [i] = new Layer (i, layer [i - 1], 2);
        }
        else {
            layer [i] = new Layer (i, layer [i - 1], i + 2);
        }
    }
    layerErr.add (sqerr);
    lastLayer = i - 1;
    ivector = oattr = null;
    crit = null;
    GraphCanvas.getInstance ().setLayerConstruction (false);
}


public void Run () {
    WriteOut ("IPX Tunneling utility for DosBox\n\n");
    if (cmd.GetCount () == 0) {
        WriteOut ("The syntax of this command is:\n\n");
        WriteOut ("IPXNET [ CONNECT | DISCONNECT | STARTSERVER | STOPSERVER | PING | HELP |\n         STATUS ]\n\n");
        return;
    }
    if ((temp_line = cmd.FindCommand (1)) != null) {
        temp_line = temp_line.toLowerCase ();
        if ("help".equals (temp_line)) {
            if ((temp_line = cmd.FindCommand (2)) == null) {
                WriteOut ("The following are valid IPXNET commands:\n\n");
                WriteOut ("IPXNET CONNECT        IPXNET DISCONNECT       IPXNET STARTSERVER\n");
                WriteOut ("IPXNET STOPSERVER     IPXNET PING             IPXNET STATUS\n\n");
                WriteOut ("To get help on a specific command, type:\n\n");
                WriteOut ("IPXNET HELP command\n\n");
            }
            else {
                HelpCommand (temp_line);
                return;
            }
            return;
        }
        if ("startserver".equals (temp_line)) {
            if (! isIpxServer) {
                if (incomingPacket.connected) {
                    WriteOut ("IPX Tunneling Client alreadu connected to another server.  Disconnect first.\n");
                    return;
                }
                boolean startsuccess;
                udpPort = 213;
                if ((temp_line = cmd.FindCommand (2)) != null) {
                    try {
                        udpPort = Integer.parseInt (temp_line);
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                }
                startsuccess = IPXServer.IPX_StartServer (udpPort);
                if (startsuccess) {
                    WriteOut ("IPX Tunneling Server started\n");
                    isIpxServer = true;
                    ConnectToServer ("localhost");
                }
                else {
                    WriteOut ("IPX Tunneling Server failed to start.\n");
                    if (udpPort < 1024) WriteOut ("Try a port number above 1024. See IPXNET HELP CONNECT on how to specify a port.\n");
                }
            }
            else {
                WriteOut ("IPX Tunneling Server already started\n");
            }
            return;
        }
        if ("stopserver".equals (temp_line)) {
            if (! isIpxServer) {
                WriteOut ("IPX Tunneling Server not running in this DosBox session.\n");
            }
            else {
                isIpxServer = false;
                DisconnectFromServer (false);
                IPXServer.IPX_StopServer ();
                WriteOut ("IPX Tunneling Server stopped.");
            }
            return;
        }
        if ("connect".equals (temp_line)) {
            String strHost;
            if (incomingPacket.connected) {
                WriteOut ("IPX Tunneling Client already connected.\n");
                return;
            }
            if ((temp_line = cmd.FindCommand (2)) == null) {
                WriteOut ("IPX Server address not specified.\n");
                return;
            }
            strHost = temp_line;
            udpPort = 213;
            if ((temp_line = cmd.FindCommand (3)) != null) {
                try {
                    udpPort = Integer.parseInt (temp_line);
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            }
            if (ConnectToServer (strHost)) {
                WriteOut ("IPX Tunneling Client connected to server at " + strHost + ".\n");
            }
            else {
                WriteOut ("IPX Tunneling Client failed to connect to server at " + strHost + ".\n");
            }
            return;
        }
        if ("disconnect".equals (temp_line)) {
            if (! incomingPacket.connected) {
                WriteOut ("IPX Tunneling Client not connected.\n");
                return;
            }
            WriteOut ("IPX Tunneling Client disconnected from server.\n");
            DisconnectFromServer (false);
            return;
        }
        if ("status".equals (temp_line)) {
            WriteOut ("IPX Tunneling Status:\n\n");
            WriteOut ("Server status: ");
            if (isIpxServer) WriteOut ("ACTIVE\n");
            else WriteOut ("INACTIVE\n");
            WriteOut ("Client status: ");
            if (incomingPacket.connected) {
                WriteOut ("CONNECTED -- Server at " + ipxServConnIp.getHostAddress () + " port " + udpPort + "\n");
            }
            else {
                WriteOut ("DISCONNECTED\n");
            }
            if (isIpxServer) {
                WriteOut ("List of active connections:\n\n");
                int i;
                for (i = 0; i < SOCKETTABLESIZE; i ++) {
                    IPXAddress addr = IPXServer.IPX_isConnectedToServer (i);
                    if (addr != null) {
                        WriteOut ("     " + addr.address.getHostAddress () + " from port " + addr.port + "\n");
                    }
                }
                WriteOut ("\n");
            }
            return;
        }
        if ("ping".equals (temp_line)) {
            long ticks;
            IPXHeader pingHead = new IPXHeader ();
            if (! incomingPacket.connected) {
                WriteOut ("IPX Tunneling Client not connected.\n");
                return;
            }
            Timer.TIMER_DelTickHandler (IPX_ClientLoop);
            WriteOut ("Sending broadcast ping:\n\n");
            pingSend ();
            ticks = Main.GetTicks ();
            while ((Main.GetTicks () - ticks) < 1500) {
                Callback.CALLBACK_Idle ();
                if (pingCheck (pingHead)) {
                    WriteOut ("Response from " + pingHead.src.addr.hostAsString () + ", port " + pingHead.src.addr.port () + " time=" + String.valueOf (Main.GetTicks () - ticks) + "ms\n");
                }
            }
            Timer.TIMER_AddTickHandler (IPX_ClientLoop);
            return;
        }
    }
}


-----Function Pair=66=-----==

private static int varCountField (String name) {
    String shortname;
    int dot, numfield;
    shortname = name;
    numfield = 0;
    while (true) {
        dot = shortname.indexOf ('.');
        if (dot != - 1) {
            numfield ++;
            shortname = shortname.substring (dot + 1);
        }
        else {
            break;
        }
    }
    return numfield;
}


public boolean keyUp (Event evt, int key) {
    if (key < 1000) {
        byte msg [] = {(byte) key};
        try {
            sOut.write (msg);
        } catch (Exception e) {
        }
    }
    else {
        byte msg2 [] = {};
        switch (key) {
            case 1004 :
                msg2 = ansiUp;
                break;
            case 1005 :
                msg2 = ansiDown;
                break;
            case 1006 :
                msg2 = ansiLeft;
                break;
            case 1007 :
                msg2 = ansiRight;
                break;
            default :
                System.out.println ("key...");
                System.out.println (key);
        }
        try {
            sOut.write (msg2);
        } catch (Exception e) {
        }
    }
    return (true);
}


-----Function Pair=67=-----==

public void setSize (int w, int h) {
    _prof.prof.cnt [467] ++;
    {
        _prof.prof.cnt [468] ++;
        if (started && ! firstFrame) {
            _prof.prof.cnt [469] ++;
            return;
        }
    }
    {
        _prof.prof.cnt [470] ++;
        width = w;
    }
    {
        _prof.prof.cnt [471] ++;
        height = h;
    }
    {
        _prof.prof.cnt [472] ++;
        if (width < 1) {
            _prof.prof.cnt [473] ++;
            width = 320;
        }
    }
    {
        _prof.prof.cnt [474] ++;
        if (height < 1) {
            _prof.prof.cnt [475] ++;
            height = 240;
        }
    }
    {
        _prof.prof.cnt [476] ++;
        sizeSet = true;
    }
}


protected void analyzePixels () {
    int len = pixels.length;
    int nPix = len / 3;
    indexedPixels = new byte [nPix];
    NeuQuant nq = new NeuQuant (pixels, len, sample);
    colorTab = nq.process ();
    for (int i = 0; i < colorTab.length; i += 3) {
        byte temp = colorTab [i];
        colorTab [i] = colorTab [i + 2];
        colorTab [i + 2] = temp;
        usedEntry [i / 3] = false;
    }
    int k = 0;
    for (int i = 0; i < nPix; i ++) {
        int index = nq.map (pixels [k ++] & 0xff, pixels [k ++] & 0xff, pixels [k ++] & 0xff);
        usedEntry [index] = true;
        indexedPixels [i] = (byte) index;
    }
    pixels = null;
    colorDepth = 8;
    palSize = 7;
    if (transparent != null) {
        transIndex = findClosest (transparent);
    }
}


-----Function Pair=68=-----==

public Double2M max (Spolecne.D3 F, double x, double y, double uhel, double krok, double phodn) {
    double hodn, t;
    for (int k = 1; k <= 6; k ++) {
        do {
            hodn = F.f (x, y, uhel);
            t = phodn;
            if (hodn > phodn) {
                phodn = hodn;
                uhel = uhel + krok;
            }
        }
        while (hodn >= t);
        phodn = hodn;
        krok = - krok / 10;
        uhel = uhel + krok;
    }
    return new Double2M (phodn, uhel - krok);
}


void setTextAndLines (ImageRegion imageRegion, Picture pic, Transform tr) {
    for (int i = 0; i < textPos.length; i ++) {
        tr.xyzPos (textPos [i]);
        imageRegion.setTextPos (i, tr.X, tr.Y, tr.Z);
    }
    int line = 0;
    for (int i = 0; i < 8; i ++) {
        tr.xyzPos (cornersRGB [i]);
        corner [i] [0] = tr.X;
        corner [i] [1] = tr.Y;
        corner [i] [2] = tr.Z;
        corner [i] [3] = 0;
    }
    int [] [] cor = new int [3] [];
    for (int i = 0; i < 4; i ++) {
        int k = 0;
        for (int j = 4; j < 8; j ++) {
            if (i + j != 7) cor [k ++] = corner [j];
        }
        if (corner [i] [2] >= corner [7 - i] [2] && Misc.inside (corner [i], cor [0], cor [1], cor [2])) corner [i] [3] = 1;
    }
    for (int j = 4; j < 8; j ++) {
        int k = 0;
        for (int i = 0; i < 4; i ++) {
            if (i + j != 7) cor [k ++] = corner [i];
        }
        if (corner [j] [2] >= corner [7 - j] [2] && Misc.inside (corner [j], cor [0], cor [1], cor [2])) corner [j] [3] = 1;
    }
    for (int i = 0; i < 4; i ++) for (int j = 4; j < 8; j ++) {
        if (i + j != 7) {
            if (corner [i] [3] == 1 || corner [j] [3] == 1) imageRegion.setLine (line, corner [i] [0], corner [i] [1], corner [j] [0], corner [j] [1], 1, backColor);
            else imageRegion.setLine (line, corner [i] [0], corner [i] [1], corner [j] [0], corner [j] [1], - 1, frontColor);
            line ++;
        }
    }
    cor = null;
}


-----Function Pair=69=-----==

public void run () {
    Common.urlIsUnknown = false;
    if (newArgs == null || newArgs [0].equals ("")) {
        if (! allowDownload) {
            stateBar.setText ("  沒有輸入網址 !!");
        }
        else {
            if (Common.missionCount > 0) {
                Flag.parseUrlFlag = false;
                startDownloadList (false);
            }
            else {
                stateBar.setText ("  沒有下載任務也沒有輸入網址 !!");
            }
        }
    }
    else if (! Common.isLegalURL (newArgs [0])) {
        stateBar.setText ("  網址錯誤，請輸入正確的網址 !!");
    }
    else {
        stateBar.setText ("  解析網址中");
        if (Common.withGUI ()) {
            trayIcon.setToolTip ("解析網址中");
        }
        Flag.allowDownloadFlag = false;
        Run.isAlive = true;
        String [] tempArgs = Common.getCopiedStrings (newArgs);
        mainRun = new Run (tempArgs, RunModeEnum.PARSE_MODE);
        mainRun.start ();
        String title = "";
        try {
            mainRun.join ();
        } catch (InterruptedException ex) {
            ex.printStackTrace ();
        }
        title = mainRun.getTitle ();
        Common.debugPrintln ("選擇集數前解析得到的title：" + title);
        if (Common.urlIsUnknown) {
            stateBar.setText ("  無法解析此網址 !!");
        }
        else if (Common.isMainPage) {
            runChoiceFrame (modifySelected, modifyRow, title, tempArgs [0]);
            if (allowDownload) {
                Flag.parseUrlFlag = false;
                startDownloadList (true);
            }
        }
        else {
            if (! allowDownload) {
                stateBar.setText ("  單集頁面無法加入下載佇列 !!");
            }
            else {
                stateBar.setText ("  正在下載單一集數");
                Flag.parseUrlFlag = false;
                startDownloadURL (tempArgs);
            }
        }
    }
    Flag.parseUrlFlag = false;
}


public void run () {
    try {
        Socket.setSocketImplFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        ServerSocket.setSocketFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        DatagramSocket.setDatagramSocketImplFactory (new DatagramSocketImplFactory () {
            public DatagramSocketImpl createDatagramSocketImpl () {
                throw new VM_UnimplementedError ("Need to implement JikesRVMDatagramSocketImpl");
            }
        }
        );
    } catch (java.io.IOException e) {
        VM.sysWrite ("trouble setting socket impl factories");
    }
    VM_Controller.boot ();
    ClassLoader cl = VM_ClassLoader.getApplicationClassLoader ();
    setContextClassLoader (cl);
    VM_Class cls = null;
    try {
        VM_Atom mainAtom = VM_Atom.findOrCreateUnicodeAtom (args [0].replace ('.', '/'));
        VM_TypeReference mainClass = VM_TypeReference.findOrCreate (cl, mainAtom.descriptorFromClassName ());
        cls = mainClass.resolve ().asClass ();
        cls.resolve ();
        cls.instantiate ();
        cls.initialize ();
    } catch (ClassNotFoundException e) {
        VM.sysWrite (e + "\n");
        return;
    }
    mainMethod = cls.findMainMethod ();
    if (mainMethod == null) {
        VM.sysWrite (cls + " doesn't have a \"public static void main(String[])\" method to execute\n");
        return;
    }
    String [] mainArgs = new String [args.length - 1];
    for (int i = 0, n = mainArgs.length; i < n; ++ i) mainArgs [i] = args [i + 1];
    mainMethod.compile ();
    VM_Callbacks.notifyStartup ();
    VM.debugBreakpoint ();
    VM_Magic.invokeMain (mainArgs, mainMethod.getCurrentCompiledMethod ().getInstructions ());
}


-----Function Pair=70=-----==

private boolean isValidLocation (Cell aCell, Point aLocation) {
    if (aLocation.x < rows.size ()) {
        if ((aLocation.y + aCell.colspan ()) > columns) {
            return false;
        }
        int difx = ((rows.size () - aLocation.x) > aCell.rowspan ()) ? aCell.rowspan () : rows.size () - aLocation.x;
        int dify = ((columns - aLocation.y) > aCell.colspan ()) ? aCell.colspan () : columns - aLocation.y;
        for (int i = aLocation.x; i < (aLocation.x + difx); i ++) {
            for (int j = aLocation.y; j < (aLocation.y + dify); j ++) {
                if (((Row) rows.get (i)).isReserved (j) == true) {
                    return false;
                }
            }
        }
    }
    else {
        if ((aLocation.y + aCell.colspan ()) > columns) {
            return false;
        }
    }
    return true;
}


public void buildGUI (Display display) {
    this.display = display;
    cGeneral = new Container ();
    cGeneral.setMinSize (754, 473);
    cGeneral.setSizeToMinSize ();
    cGeneral.getAppearance ().add (MenuPixmapBackgrounds.getPrepareBattlePixmapBackground ());
    cGeneral.setLayoutManager (new StaticLayout ());
    StaticLayout.center (cGeneral, display);
    display.addWidget (cGeneral);
    final Container cLabelBattleName = new Container ();
    cLabelBattleName.getAppearance ().setPadding (new Spacing (0, 10));
    cLabelBattleName.setLayoutManager (new RowLayout (false));
    cGeneral.addWidget (cLabelBattleName);
    final Container cPlayersTable = new Container ();
    cPlayersTable.getAppearance ().setPadding (new Spacing (0, 10));
    cPlayersTable.setLayoutManager (new RowLayout (false));
    cGeneral.addWidget (cPlayersTable);
    final Container cButtonBack = new Container ();
    cButtonBack.getAppearance ().setPadding (new Spacing (0, 10));
    cButtonBack.setLayoutManager (new RowLayout (true));
    cGeneral.addWidget (cButtonBack);
    final Container cReadyBack = new Container ();
    cReadyBack.getAppearance ().setPadding (new Spacing (0, 10));
    cReadyBack.setLayoutManager (new RowLayout (true));
    cGeneral.addWidget (cReadyBack);
    initComponents (cGeneral, display);
    buildComponents (cLabelBattleName, cPlayersTable, cButtonBack, cReadyBack, cGeneral);
    connectToServerAndRegisterPlayer ();
}


-----Function Pair=71=-----==

public void addPosterization (RasterFilterListManager filterManager, IRasterRendering rendering) throws FilterTypeException {
    EnhancementStretchListManager elm = new EnhancementStretchListManager (filterManager);
    LinearStretchParams leParams = new LinearStretchParams ();
    double min = data.getMin ();
    double max = data.getMax ();
    double [] stretchs = data.getStretchs ();
    double distance = max - min;
    for (int i = 0; i < stretchs.length; i ++) stretchs [i] = min + stretchs [i] * distance;
    double [] in = new double [(stretchs.length - 1) * 2 + 4];
    int [] out = new int [(stretchs.length - 1) * 2 + 4];
    in [0] = in [1] = min;
    out [0] = out [1] = 0;
    in [in.length - 1] = in [in.length - 2] = max;
    out [out.length - 1] = out [out.length - 2] = 255;
    boolean even = true;
    out [2] = 0;
    for (int i = 3; i < in.length - 2; i = i + 2) {
        if (even) out [i] = out [i + 1] = 255;
        else out [i] = out [i + 1] = 0;
        even = ! even;
    }
    out [out.length - 2] = 255;
    for (int i = 2; i < in.length - 2; i = i + 2) in [i] = in [i + 1] = stretchs [(int) (i / 2)];
    leParams.rgb = true;
    leParams.red.stretchIn = in;
    leParams.red.stretchOut = out;
    leParams.green.stretchIn = in;
    leParams.green.stretchOut = out;
    leParams.blue.stretchIn = in;
    leParams.blue.stretchOut = out;
    elm.addEnhancedStretchFilter (leParams, lyr.getDataSource ().getStatistics (), rendering.getRenderBands (), false);
}


private void smoothingFilter (int width, int height, int rad) {
    int size = 2 * rad + 1;
    float [] k = getBlurKernel (2 * rad + 1);
    for (int y = 0; y < height; y ++) {
        for (int x = 0; x < width; x ++) {
            int i = y * width + x;
            if (plotList [i] != null) {
                float sum = 0;
                float n = 0;
                for (int dy = - rad, ky = 0; dy <= rad; dy ++, ky += size) {
                    int y_ = Math.max (Math.min (y + dy, height - 1), 0);
                    int offset = y_ * width;
                    for (int dx = - rad, kx = 0; dx <= rad; dx ++, kx ++) {
                        int x_ = Math.max (Math.min (x + dx, width - 1), 0);
                        int j = offset + x_;
                        if (plotList [j] != null) {
                            float f = k [ky + kx];
                            sum += f * plotList [j].lum;
                            n += f;
                        }
                    }
                }
                plotList [i].z = (int) (sum / n - 128);
            }
        }
    }
}


-----Function Pair=72=-----==

private void openDownloadDirectory (int row) {
    String title = "";
    String url = "";
    if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.MISSION) {
        row = downTable.convertRowIndexToModel (row);
        title = String.valueOf (downTableModel.getRealValueAt (row, DownTableEnum.TITLE));
        url = downTableModel.getRealValueAt (row, DownTableEnum.URL).toString ();
    }
    else if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.BOOKMARK) {
        row = bookmarkTable.convertRowIndexToModel (row);
        title = String.valueOf (bookmarkTableModel.getValueAt (row, BookmarkTableEnum.TITLE));
        url = String.valueOf (bookmarkTableModel.getValueAt (row, BookmarkTableEnum.URL));
    }
    else if (tabbedPane.getSelectedIndex () == TabbedPaneEnum.RECORD) {
        row = recordTable.convertRowIndexToModel (row);
        title = String.valueOf (recordTableModel.getValueAt (row, RecordTableEnum.TITLE));
        url = String.valueOf (recordTableModel.getValueAt (row, RecordTableEnum.URL));
    }
    Common.debugPrintln ("開啟" + title + "的下載資料夾");
    if (url.matches ("(?s).*e-hentai(?s).*") || url.matches ("(?s).*exhentai(?s).*")) {
        if (Common.isWindows ()) {
            if (new File (SetUp.getOriginalDownloadDirectory () + title + ".zip").exists ()) {
                Common.runUnansiCmd ("explorer /select, ", SetUp.getOriginalDownloadDirectory () + title + ".zip");
            }
            else if (new File (SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ()).exists ()) {
                Common.runUnansiCmd ("explorer /select, ", SetUp.getOriginalDownloadDirectory () + title);
            }
            else {
                Common.runUnansiCmd ("explorer ", SetUp.getOriginalDownloadDirectory ());
            }
        }
        else if (Common.isMac ()) {
            Common.runCmd ("Finder ", SetUp.getOriginalDownloadDirectory ());
        }
        else {
            Common.runCmd ("nautilus ", SetUp.getOriginalDownloadDirectory ());
        }
    }
    else {
        if (Common.isWindows ()) {
            Common.runUnansiCmd ("explorer ", SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ());
        }
        else if (Common.isMac ()) {
            Common.runCmd ("Finder ", SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ());
        }
        else {
            Common.runCmd ("nautilus ", SetUp.getOriginalDownloadDirectory () + title + Common.getSlash ());
        }
    }
}


private void processSecondaryOrders (RdpPacket_Localised data) throws OrderException, RdesktopException {
    int length = 0;
    int type = 0;
    int flags = 0;
    int next_order = 0;
    length = data.getLittleEndian16 ();
    flags = data.getLittleEndian16 ();
    type = data.get8 ();
    next_order = data.getPosition () + length + 7;
    switch (type) {
        case RDP_ORDER_RAW_BMPCACHE :
            logger.debug ("Raw BitmapCache Order");
            this.processRawBitmapCache (data);
            break;
        case RDP_ORDER_COLCACHE :
            logger.debug ("Colorcache Order");
            this.processColorCache (data);
            break;
        case RDP_ORDER_BMPCACHE :
            logger.debug ("Bitmapcache Order");
            this.processBitmapCache (data);
            break;
        case RDP_ORDER_FONTCACHE :
            logger.debug ("Fontcache Order");
            this.processFontCache (data);
            break;
        case RDP_ORDER_RAW_BMPCACHE2 :
            try {
                this.process_bmpcache2 (data, flags, false);
            } catch (IOException e) {
                throw new RdesktopException (e.getMessage ());
            }
            break;
        case RDP_ORDER_BMPCACHE2 :
            try {
                this.process_bmpcache2 (data, flags, true);
            } catch (IOException e) {
                throw new RdesktopException (e.getMessage ());
            }
            break;
        default :
            logger.warn ("Unimplemented 2ry Order type " + type);
    }
    data.setPosition (next_order);
}


-----Function Pair=73=-----==

private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=74=-----==

Point transf (final Point p) {
    float deltax, deltay, den, t, u;
    int gaussx, gaussy;
    Point a = new Point (), b = new Point (), c = new Point (), d = new Point (), ptr = new Point ();
    p.x = (p.x - minx) * lx / (maxx - minx);
    p.y = (p.y - miny) * ly / (maxy - miny);
    gaussx = (int) p.x;
    gaussy = (int) p.y;
    if (gaussx < 0 || gaussx > lx || gaussy < 0 || gaussy > ly) {
        System.err.println ("ERROR: Coordinate limits exceeded in transf.\n");
        System.exit (1);
    }
    deltax = p.x - gaussx;
    deltay = p.y - gaussy;
    a.x = (1 - deltax) * x [gaussx].array [gaussy] + deltax * x [gaussx + 1].array [gaussy];
    a.y = (1 - deltax) * y [gaussx].array [gaussy] + deltax * y [gaussx + 1].array [gaussy];
    b.x = (1 - deltax) * x [gaussx].array [gaussy + 1] + deltax * x [gaussx + 1].array [gaussy + 1];
    b.y = (1 - deltax) * y [gaussx].array [gaussy + 1] + deltax * y [gaussx + 1].array [gaussy + 1];
    c.x = (1 - deltay) * x [gaussx].array [gaussy] + deltay * x [gaussx].array [gaussy + 1];
    c.y = (1 - deltay) * y [gaussx].array [gaussy] + deltay * y [gaussx].array [gaussy + 1];
    d.x = (1 - deltay) * x [gaussx + 1].array [gaussy] + deltay * x [gaussx + 1].array [gaussy + 1];
    d.y = (1 - deltay) * y [gaussx + 1].array [gaussy] + deltay * y [gaussx + 1].array [gaussy + 1];
    if (Math.abs (den = (b.x - a.x) * (c.y - d.y) + (a.y - b.y) * (c.x - d.x)) < 1e-12) {
        System.err.println ("ERROR: Transformed area element has parallel edges.\n");
    }
    t = ((c.x - a.x) * (c.y - d.y) + (a.y - c.y) * (c.x - d.x)) / den;
    u = ((b.x - a.x) * (c.y - a.y) + (a.y - b.y) * (c.x - a.x)) / den;
    if (t < - 1e-3 || t > 1 + 1e-3 || u < - 1e-3 || u > 1 + 1e-3) {
        System.err.println ("WARNING: Transformed area element non-convex.\n");
    }
    ptr.x = (1 - (a.x + t * (b.x - a.x)) / lx) * minx + ((a.x + t * (b.x - a.x)) / lx) * maxx;
    ptr.y = (1 - (a.y + t * (b.y - a.y)) / ly) * miny + ((a.y + t * (b.y - a.y)) / ly) * maxy;
    return ptr;
}


public static Object financialPrice (Object [] args, XelContext ctx) {
    Date settle = UtilFns.stringToDate (args [0].toString ());
    Date maturi = UtilFns.stringToDate (args [1].toString ());
    if (settle.after (maturi)) {
        throw new SSErrorXelException (SSError.NUM);
    }
    double rate = CommonFns.toNumber (args [2]).doubleValue ();
    double yld = CommonFns.toNumber (args [3]).doubleValue ();
    double redemption = CommonFns.toNumber (args [4]).doubleValue ();
    if (! (yld > 0 || rate > 0 || redemption > 0)) {
        throw new SSErrorXelException (SSError.NUM);
    }
    int freq = 1;
    try {
        freq = CommonFns.toNumber (args [5]).intValue ();
    } catch (ClassCastException e) {
        throw new SSErrorXelException (SSError.NUM);
    }
    if (freq != 1 && freq != 2 && freq != 4) {
        throw new SSErrorXelException (SSError.NUM);
    }
    int basis = 0;
    if (args.length == 7) {
        try {
            basis = basis (CommonFns.toNumber (args [6]).intValue ());
        } catch (ClassCastException e) {
            basis = 0;
        }
    }
    return new Double (price (settle, maturi, rate, yld, redemption, freq, basis));
}


-----Function Pair=75=-----==

public long read_longlong () {
    alignment (8);
    long val;
    int got;
    m_tmp_len.value = 8;
    if ((got = next (m_tmp_buf, m_tmp_off, m_tmp_len)) == 8) {
        val = ((m_tmp_buf.value [m_tmp_off.value] & 0xFFL) << (m_swap ? 0L : 56L)) | ((m_tmp_buf.value [m_tmp_off.value + 1] & 0xFFL) << (m_swap ? 8L : 48L)) | ((m_tmp_buf.value [m_tmp_off.value + 2] & 0xFFL) << (m_swap ? 16L : 40L)) | ((m_tmp_buf.value [m_tmp_off.value + 3] & 0xFFL) << (m_swap ? 24L : 32L)) | ((m_tmp_buf.value [m_tmp_off.value + 4] & 0xFFL) << (m_swap ? 32L : 24L)) | ((m_tmp_buf.value [m_tmp_off.value + 5] & 0xFFL) << (m_swap ? 40L : 16L)) | ((m_tmp_buf.value [m_tmp_off.value + 6] & 0xFFL) << (m_swap ? 48L : 8L)) | ((m_tmp_buf.value [m_tmp_off.value + 7] & 0xFFL) << (m_swap ? 56L : 0L));
    }
    else {
        val = 0;
        long shf = m_swap ? 0 : 56;
        while (true) {
            for (int i = 0; i < got; ++ i) {
                val = val | ((long) (m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << shf);
                shf += m_swap ? 8 : - 8;
            }
            if (m_swap ? (shf < 56) : (shf > 0)) {
                got = next (m_tmp_buf, m_tmp_off, m_tmp_len);
                continue;
            }
            break;
        }
    }
    postread (8);
    return val;
}


private static double db (double cost, double salvage, double life, double period, double month, double rate) {
    double db = cost * rate * month / 12;
    double d = cost * rate * month / 12;
    if (period > 1) {
        for (int i = 1; i <= period - 1; i ++) {
            if (i < life) {
                db = (cost - d) * rate;
                d = d + db;
            }
            else {
                db = (cost - d) * rate * (12 - month) / 12;
            }
        }
    }
    return db;
}


-----Function Pair=76=-----==

public void listAdd (MsnFriend friend) {
    Contact cw = getContactFactory ().create (friend.getLoginName (), MSNConnection.this);
    cw.getStatus ().setOnline (! friend.getStatus ().equals (UserStatus.OFFLINE));
    cw.setDisplayName (GeneralUtils.stripHTML (friend.getFormattedFriendlyName ()));
    try {
        log.fine ("friend " + friend.getStatus () + " group index " + friend.getGroupIndex ());
        rath.msnm.entity.Group msnGroup = connection.getBuddyGroup ().getGroupList ().getGroup (friend.getGroupIndex ());
        if (msnGroup != null) {
            Group gw = getGroupFactory ().create (msnGroup.getName ());
            gw.add (cw);
            getGroupList ().add (gw);
        }
        else {
        }
    } catch (NullPointerException e) {
        String bug = "Bug in msn implementation. ";
        try {
            bug = "Bug in msn implementation: " + (connection == null ? " connection is null" : (connection.getBuddyGroup () == null ? "connection.getBuddyGroup()==null" : (connection.getBuddyGroup ().getGroupList () == null ? "connection.getBuddyGroup().getGroupList() is null" : (friend.getGroupIndex () == null ? "friend.getGroupIndex() is null" : (connection.getBuddyGroup ().getGroupList ().getGroup (friend.getGroupIndex ()) == null ? "connection.getBuddyGroup().getGroupList().getGroup(friend.getGroupIndex()) is null" : "unknown problem")))));
        } catch (NullPointerException ex) {
        }
        log.log (Level.SEVERE, "Bug!", e);
        for (ConnectionEventListener eventHandler : eventHandlers) {
            eventHandler.errorOccured ("Found a bug in MSN protocol, please report back to us:\n" + bug, e);
        }
    }
}


protected void onKeyPressed (KeyEvent e) {
    if (e.isShiftDown ()) {
        return;
    }
    switch (e.getKeyCode ()) {
        case KeyEvent.VK_L :
            if (e.isControlDown ()) {
                SwingUtilities.getRoot (gameLog).setVisible (true);
            }
            break;
        case KeyEvent.VK_R :
            if (e.isControlDown ()) {
                screen.clearTexts ();
            }
            break;
        case KeyEvent.VK_LEFT :
        case KeyEvent.VK_RIGHT :
        case KeyEvent.VK_UP :
        case KeyEvent.VK_DOWN :
        case KeyEvent.VK_PAGE_UP :
        case KeyEvent.VK_END :
        case KeyEvent.VK_PAGE_DOWN :
        case KeyEvent.VK_HOME :
            Direction direction = keyCodeToDirection (e.getKeyCode ());
            if (e.isAltGraphDown ()) {
                User user = User.get ();
                EntityView view = screen.getEntityViewAt (user.getX () + direction.getdx (), user.getY () + direction.getdy () + 1);
                if (view != null) {
                    Entity entity = view.getEntity ();
                    if (! entity.equals (user)) {
                        entity.onAction (entity.defaultAction ());
                    }
                }
            }
            processDirectionPress (direction, e.isControlDown ());
    }
}


-----Function Pair=77=-----==

public j2DClient (MidhedavaClient client) {
    super (client);
    setDefault (this);
    frame = new JFrame ();
    frame.setTitle (ClientGameConfiguration.get ("GAME_NAME") + " " + midhedava.VERSION + " - The Age of Legends");
    URL url = SpriteStore.get ().getResourceURL (ClientGameConfiguration.get ("GAME_ICON"));
    frame.setIconImage (new ImageIcon (url).getImage ());
    frame.setDefaultCloseOperation (WindowConstants.DO_NOTHING_ON_CLOSE);
    Container content = frame.getContentPane ();
    content.setLayout (new BoxLayout (content, BoxLayout.Y_AXIS));
    pane = new JLayeredPane ();
    pane.setPreferredSize (new Dimension (SCREEN_WIDTH, SCREEN_HEIGHT));
    content.add (pane);
    JPanel panel = new JPanel ();
    panel.setLayout (null);
    panel.setPreferredSize (new Dimension (SCREEN_WIDTH, SCREEN_HEIGHT));
    pane.add (panel, JLayeredPane.DEFAULT_LAYER);
    canvas = new Canvas ();
    canvas.setBounds (0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    canvas.setIgnoreRepaint (true);
    panel.add (canvas);
    playerChatText = new JTextField ("");
    MidhedavaChatLineListener chatListener = new MidhedavaChatLineListener (client, playerChatText);
    playerChatText.addActionListener (chatListener);
    playerChatText.addKeyListener (chatListener);
    content.add (playerChatText);
    canvas.addFocusListener (new FocusListener () {
        public void focusGained (FocusEvent e) {
            playerChatText.requestFocus ();
        } public void focusLost (FocusEvent e) {
        }
    }
    );
    frame.addWindowListener (new WindowAdapter () {
        @Override
        public void windowOpened (WindowEvent ev) {
            playerChatText.requestFocus ();
        }@Override
        public void windowActivated (WindowEvent ev) {
            playerChatText.requestFocus ();
        }@Override
        public void windowGainedFocus (WindowEvent ev) {
            playerChatText.requestFocus ();
        }@Override
        public void windowClosing (WindowEvent e) {
            requestQuit ();
        }
    }
    );
    quitDialog = buildQuitDialog ();
    quitDialog.setVisible (false);
    pane.add (quitDialog, JLayeredPane.MODAL_LAYER);
    gameLog = new KTextEdit ();
    gameLog.setPreferredSize (new Dimension (SCREEN_WIDTH, 171));
    if (System.getProperty ("midhedava.onewindow") != null) {
        content.add (gameLog);
        frame.pack ();
    }
    else if (System.getProperty ("midhedava.onewindowtitle") != null || System.getProperty ("midhedava.refactoringguiui") != null) {
        JLabel header = new JLabel ();
        header.setText ("Game Chat and Events Log");
        header.setFont (new java.awt.Font ("Dialog", 3, 14));
        content.add (header);
        content.add (gameLog);
        frame.pack ();
    }
    else {
        final JDialog dialog = new JDialog (frame, "Game chat and events log");
        content = dialog.getContentPane ();
        content.setLayout (new BoxLayout (content, BoxLayout.Y_AXIS));
        content.add (gameLog);
        dialog.addFocusListener (new FocusListener () {
            public void focusGained (FocusEvent e) {
                playerChatText.requestFocus ();
            } public void focusLost (FocusEvent e) {
            }
        }
        );
        dialog.pack ();
        frame.addComponentListener (new ComponentAdapter () {
            @Override
            public void componentShown (ComponentEvent e) {
                Rectangle bounds = frame.getBounds ();
                dialog.setLocation (bounds.x, bounds.y + bounds.height);
                dialog.setVisible (true);
            }@Override
            public void componentMoved (ComponentEvent e) {
                Rectangle bounds = frame.getBounds ();
                dialog.setLocation (bounds.x, bounds.y + bounds.height);
            }
        }
        );
    }
    KeyListener keyListener = new GameKeyHandler ();
    playerChatText.addKeyListener (keyListener);
    canvas.addKeyListener (keyListener);
    if (! midhedava.SCREEN_SIZE.equals ("640x480")) {
        addEventLine ("Using window size cheat: " + midhedava.SCREEN_SIZE, Color.RED);
    }
    frame.setLocation (new Point (20, 20));
    frame.pack ();
    frame.setResizable (false);
    frame.setVisible (true);
    BufferStrategy strategy;
    canvas.createBufferStrategy (2);
    strategy = canvas.getBufferStrategy ();
    screen = new GameScreen (client, strategy, SCREEN_WIDTH, SCREEN_HEIGHT);
    screen.setComponent (canvas);
    GameScreen.setDefaultScreen (screen);
    client.setScreen (screen);
    baseframe = new WtBaseframe (screen);
    canvas.addMouseListener (baseframe);
    canvas.addMouseMotionListener (baseframe);
    ground = new GroundContainer (this);
    baseframe.addChild (ground);
    settings = new SettingsPanel (this, ground);
    ground.addChild (settings);
    WtWindowManager windowManager = WtWindowManager.getInstance ();
    windowManager.setDefaultProperties ("corpse", false, 0, 190);
    windowManager.setDefaultProperties ("chest", false, 100, 190);
    directionRelease = null;
    gameLoop ();
    chatListener.save ();
    logger.debug ("Exit");
    System.exit (0);
}


private void exportPerson (Row personRow) throws XMPPException {
    Long personId = personRow.getData (Data.personTable.id);
    StringBuilder name = new StringBuilder ();
    appendString (name, " ", personRow.getData (Data.personFirstName));
    appendString (name, " ", personRow.getData (Data.personMiddleName));
    appendString (name, " ", personRow.getData (Data.personLastName));
    if (name.length () == 0) return;
    Set < String > userGroups = new HashSet < String > ();
    for (Row personGroupsTableRow : Data.personGroupsTable) {
        Long groupPersonId = personGroupsTableRow.getData (Data.personTable.id);
        if (personId.equals (groupPersonId)) {
            Long groupId = personGroupsTableRow.getData (Data.personGroupTable.id);
            userGroups.add (GROUPS.get (groupId));
        }
    }
    if (userGroups.isEmpty ()) {
        log.error ("No groups for user : " + name);
    }
    log.info (name);
    for (Row personMessagingRow : Data.personMessagingTable) {
        if (! personMessagingRow.getData (Data.personTable.id).equals (personId)) continue;
        String type = personMessagingRow.getData (Data.personMessagingType);
        if (type.equals (Data.IM_TYPE_ICQ)) {
            String id = personMessagingRow.getData (Data.personMessagingId);
            String userJid = id + '@' + ICQ_JABBER_GATEWAY;
            checkConnection ();
            RosterEntry icqUser = roster.getEntry (userJid);
            if (icqUser == null) {
                try {
                    roster.createEntry (userJid, name.toString (), userGroups.toArray (new String [userGroups.size ()]));
                } catch (XMPPException e) {
                    log.error ("Exception occured : " + e);
                    checkConnection ();
                }
                icqUser = roster.getEntry (userJid);
                if (icqUser == null) return;
            }
            else {
                if (icqUser.getName () == null || ! icqUser.getName ().startsWith (name.toString ())) {
                    icqUser.setName (name.toString ());
                }
                for (String userGroup : userGroups) {
                    RosterGroup group = roster.getGroup (userGroup);
                    if (group == null) {
                        group = roster.createGroup (userGroup);
                    }
                    if (! group.contains (icqUser)) {
                        try {
                            group.addEntry (icqUser);
                        } catch (Exception e) {
                            log.error ("Exception occured : " + e);
                            checkConnection ();
                        }
                    }
                }
            }
            if (icqUser.getType () != RosterPacket.ItemType.both) {
                RosterPacket.ItemStatus status = icqUser.getStatus ();
                log.trace ("     User status : " + status);
                {
                    Presence presencePacket = new Presence (Presence.Type.subscribe);
                    presencePacket.setTo (userJid);
                    presencePacket.setFrom (conn.getUser ());
                    conn.sendPacket (presencePacket);
                }
                {
                    Presence presencePacket = new Presence (Presence.Type.subscribed);
                    presencePacket.setTo (userJid);
                    presencePacket.setFrom (conn.getUser ());
                    conn.sendPacket (presencePacket);
                }
                {
                    Presence presencePacket = new Presence (Presence.Type.available);
                    presencePacket.setTo (userJid);
                    presencePacket.setFrom (conn.getUser ());
                    conn.sendPacket (presencePacket);
                }
            }
        }
    }
}


-----Function Pair=78=-----==

private void initMenu () {
    JMenuBar jMenuBar1 = new JMenuBar ();
    setJMenuBar (jMenuBar1);
    {
        JMenu jMenu1 = new JMenu ();
        jMenuBar1.add (jMenu1);
        jMenu1.setText ("File");
        {
            JMenuItem jMenuItem1 = new JMenuItem ();
            jMenu1.add (jMenuItem1);
            jMenuItem1.setText ("Disconnect");
            JMenuItem jMenuItem2 = new JMenuItem ();
            jMenu1.add (jMenuItem2);
            jMenuItem2.setText ("Exit");
            jMenuItem2.addActionListener (new ActionListener () {
                public void actionPerformed (ActionEvent e) {
                    Client.getInstance ().getIO ().kill ();
                    System.exit (0);
                }
            }
            );
        }
    }
}


private void logoutFromGateway () throws Exception {
    log.trace ("    Logout from " + gatewayJid);
    Presence unavailable = new Presence (Presence.Type.unavailable);
    unavailable.setTo (gatewayJid);
    PacketCollector collector = conn.createPacketCollector (new PacketTypeFilter (Presence.class));
    conn.sendPacket (unavailable);
    boolean loggedOut = false;
    while (! loggedOut) {
        Presence p = (Presence) collector.nextResult (5 * 1000);
        if (p == null) {
            log.info ("Unable to get UNAVAILABLE packet...this may be due to JM not publishing the response");
            break;
        }
        if (p.getType ().equals (Presence.Type.unavailable)) {
            loggedOut = true;
        }
    }
    log.info ("Logout OK");
}


-----Function Pair=79=-----==

public FileInstanceAbstract [] listFilesAndDirectories () throws SearchLibException {
    FTPClient f = null;
    try {
        f = ftpConnect ();
        FTPFile [] files = f.listFiles (getPath ());
        return buildFileInstanceArray (files);
    } catch (SocketException e) {
        throw new SearchLibException (e);
    } catch (IOException e) {
        throw new SearchLibException (e);
    } catch (URISyntaxException e) {
        throw new SearchLibException (e);
    } catch (NoSuchAlgorithmException e) {
        throw new SearchLibException (e);
    } finally {
        ftpQuietDisconnect (f);
    }
}


public void delete (String fileToDelete) throws IOException {
    FTPClient ftp = new FTPClient ();
    try {
        int reply = 0;
        ftp.connect (this.endpointURL, this.endpointPort);
        reply = ftp.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            ftp.disconnect ();
            throw new IOException ("Ftp delete server refused connection.");
        }
        if (! ftp.login ("anonymous", "")) {
            ftp.logout ();
            throw new IOException ("FTP: server wrong passwd");
        }
        ftp.enterLocalPassiveMode ();
        log.debug ("Deleted: " + ftp.deleteFile (fileToDelete));
        ftp.logout ();
    } catch (Exception e) {
        throw new IOException (e.getMessage ());
    }
}


-----Function Pair=80=-----==

public void checkForMail () {
    try {
        POP3Client client = new POP3Client ();
        client.connect ("10.0.0.6", 110);
        if (client.login ("name", "password")) {
            POP3MessageInfo [] info = client.listMessages ();
            Reader reader = client.retrieveMessageTop (info [0].number, 1);
            BufferedReader bufferedReader = new BufferedReader (reader);
            String line = bufferedReader.readLine ();
            StringBuffer stringBuffer = new StringBuffer ();
            while (line != null) {
                stringBuffer.append (line + "\n\r");
                line = bufferedReader.readLine ();
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public static void Sample2 (String myField, String condition1, String condition2) throws SQLException {
    Connection connection = DriverManager.getConnection ("jdbc:postgresql://localhost/test", "user", "password");
    connection.setAutoCommit (false);
    Statement st = connection.createStatement ();
    String sql = "UPDATE myTable SET myField = '" + myField + "' WHERE myOtherField1 = '" + condition1 + "' AND myOtherField2 = '" + condition2 + "'";
    int numChanged = st.executeUpdate (sql);
    if (numChanged > 10) {
        connection.rollback ();
    }
    else {
        connection.commit ();
    }
    st.close ();
    connection.close ();
}


-----Function Pair=81=-----==

private void sendToFtp (String outputText) {
    String uid = this.properties.get (PROPERTY_OUTPUT_FTP_USERNAME);
    String pwd = this.properties.get (PROPERTY_OUTPUT_FTP_PASSWORD);
    String address = this.properties.get (PROPERTY_OUTPUT_FTP_ADDRESS);
    int port = 21;
    try {
        port = Integer.valueOf (this.properties.get (PROPERTY_OUTPUT_FTP_PORT));
    } catch (Exception ex) {
        LOG.log (Level.WARNING, "Could not read FTP port from properties. Using port 21");
    }
    String location = this.properties.get (PROPERTY_OUTPUT_FTP_LOCATION);
    String filename = this.properties.get (PROPERTY_OUTPUT_FTP_FILENAME);
    LOG.log (Level.INFO, "Uploading text output to {0}:{1}/{2}/{3}", new Object [] {address, port, location, filename});
    FTPClient ftpClient = new FTPClient ();
    try {
        ftpClient.connect (address, port);
        int reply = ftpClient.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            ftpClient.disconnect ();
            LOG.log (Level.SEVERE, "Could not connect to FTP server: {0}", reply);
            return;
        }
        if (! ftpClient.login (uid, pwd)) {
            LOG.log (Level.SEVERE, "Could not login to FTP server ({0}) with given credentials.", address);
            return;
        }
        ftpClient.setFileType (FTP.BINARY_FILE_TYPE);
        ftpClient.enterLocalPassiveMode ();
        if (ftpClient.storeFile (location + "/" + filename, new ByteArrayInputStream (outputText.getBytes ()))) {
            LOG.log (Level.INFO, "Transfer complete");
        }
        else {
            LOG.log (Level.WARNING, "Transfer incomplete");
        }
    } catch (SocketException ex) {
        LOG.log (Level.SEVERE, "Could not transfer file.", ex.getMessage ());
        LOG.log (Level.FINE, "", ex);
    } catch (IOException ex) {
        LOG.log (Level.SEVERE, "Could not transfer file.", ex.getMessage ());
        LOG.log (Level.FINE, "", ex);
    }
    if (ftpClient.isConnected ()) {
        try {
            ftpClient.disconnect ();
        } catch (IOException ex) {
            LOG.log (Level.SEVERE, "Could not disconnect from FTP.", ex.getMessage ());
            LOG.log (Level.FINE, "", ex);
        }
    }
}


private State connecting () {
    State state = State.CONNECTING;
    ChatService.this.notifyStateObserver (state);
    if (connection.isAuthenticated () && connection.isConnected ()) {
        state = State.CONNECTED;
        return state;
    }
    try {
        connection.connect ();
        SASLAuthentication.supportSASLMechanism ("PLAIN", 0);
        if (use_login_retry) {
            connection.login (username + this.login_retry, password);
        }
        else {
            connection.login (username, password);
        }
        if (connection.isAuthenticated () && connection.isConnected ()) {
            if (use_login_retry) {
                use_login_retry = ! use_login_retry;
                username = username + this.login_retry;
                this.login_retry = - 1;
                MainFrame.getInstance ().getJStockOptions ().setChatUsername (username);
            }
            this.connection.removeConnectionListener (connectionListener);
            this.connection.addConnectionListener (connectionListener);
            state = State.CONNECTED;
        }
    } catch (XMPPException ex) {
        log.error (null, ex);
        final XMPPError error = ex.getXMPPError ();
        if (error != null) {
            if (error.getCode () == 504) {
                state = State.CONNECTING;
            }
        }
        else {
            state = State.ACCOUNT_CREATING;
        }
    }
    return state;
}


-----Function Pair=82=-----==

public Object invoke (Object proxy, Method method, Object [] args) throws Exception {
    MethodInfo info = holdMethodMap.get (nodeId);
    if (info != null) {
        synchronized (info) {
            if (method.getName ().equals (info.name)) {
                if (info.hold) {
                    System.err.println (">>HOLD ChannelServer method: " + info.name + " to node: " + nodeId);
                    info.isHeld = true;
                    info.notifyAll ();
                    while (info.hold) {
                        try {
                            info.wait ();
                        } catch (InterruptedException e) {
                        }
                    }
                    info.isHeld = false;
                    System.err.println (">>RELEASE ChannelServer method: " + info.name + " to node: " + nodeId);
                }
            }
        }
    }
    try {
        return method.invoke (obj, args);
    } catch (InvocationTargetException e) {
        Throwable cause = e.getCause ();
        if (cause instanceof Exception) {
            throw (Exception) cause;
        }
        else if (cause instanceof Error) {
            throw (Error) cause;
        }
        else {
            throw new RuntimeException ("Unexpected exception:" + cause, cause);
        }
    }
}


public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


-----Function Pair=83=-----==

public void generateReport (List < XmlSuite > xmlSuites, List < ISuite > suites, String outputDirectory) {
    String fechaInicio = this.getTestContexts ().get (0).getStartDate ().toLocaleString ().replace (':', '.');
    indexSuite oldSuite = (indexSuite) this.getTestContexts ().get (0).getAttribute ("oldSuite");
    indexSuite suiteNew = new indexSuite (this.getTestContexts ().get (0).getStartDate (), this.getTestContexts ().get (0).getSuite ().getName ());
    if (oldSuite != null) {
        compareSuites cp = new compareSuites (oldSuite, suiteNew, outputDirectory + "-library\\", false);
    }
    File oldDirectory;
    File newDirectory;
    oldDirectory = new File (outputDirectory);
    newDirectory = new File (outputDirectory + "-library" + "\\" + fechaInicio);
    oldDirectory.renameTo (newDirectory);
    generateReportHTML (oldSuite, suiteNew, outputDirectory + "-library" + "\\" + fechaInicio);
}


public static void main (String [] args) {
    System.out.println ("Chapter 4: example FoxDogSupSubscript");
    System.out.println ("-> Creates a PDF file with the text");
    System.out.println ("   'Quick brown fox jumps over the lazy dog';");
    System.out.println ("   the text is somewhat jumpy.");
    System.out.println ("-> jars needed: iText.jar");
    System.out.println ("-> resulting PDF: fox_dog_supsubscript.pdf");
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapter04/fox_dog_supsubscript.pdf"));
        document.open ();
        String s = "quick brown fox jumps over the lazy dog";
        StringTokenizer st = new StringTokenizer (s, " ");
        float textrise = 6.0f;
        Chunk c;
        while (st.hasMoreTokens ()) {
            c = new Chunk (st.nextToken ());
            c.setTextRise (textrise);
            c.setUnderline (new Color (0xC0, 0xC0, 0xC0), 0.2f, 0.0f, 0.0f, 0.0f, PdfContentByte.LINE_CAP_BUTT);
            document.add (c);
            textrise -= 2.0f;
        }
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


-----Function Pair=84=-----==

public final void createIndex () {
    try {
        final Search search = RepositorySearch.getSearchesStatic ().getSearch (name);
        deleteDir (new File (search.getPath () + "_temp"));
        writer = new IndexWriter (search.getPath () + "_temp", new StandardAnalyzer (), true);
        writer.maxFieldLength = 1000000;
        if ("filesystem".equalsIgnoreCase (search.getType ())) {
            crawlFS (search);
        }
        else if ("crawler".equalsIgnoreCase (search.getType ())) {
            crawlPage (search);
        }
        writer.optimize ();
        writer.close ();
        deleteDir (new File (search.getPath ()));
        new File (search.getPath () + "_temp").renameTo (new File (search.getPath ()));
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public static void main (String [] args) {
    System.out.println ("Height");
    Document document = new Document (PageSize.A4);
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("CellHeights.pdf"));
        document.open ();
        PdfPTable table = new PdfPTable (2);
        table.setExtendLastRow (true);
        PdfPCell cell;
        cell = new PdfPCell (new Paragraph ("blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah blah"));
        table.addCell ("wrap");
        cell.setNoWrap (false);
        table.addCell (cell);
        table.addCell ("no wrap");
        cell.setNoWrap (true);
        table.addCell (cell);
        cell = new PdfPCell (new Paragraph ("1. blah blah\n2. blah blah blah\n3. blah blah\n4. blah blah blah\n5. blah blah\n6. blah blah blah\n7. blah blah\n8. blah blah blah"));
        table.addCell ("height");
        table.addCell (cell);
        table.addCell ("fixed height");
        cell.setFixedHeight (50f);
        table.addCell (cell);
        table.addCell ("minimum height");
        cell = new PdfPCell (new Paragraph ("x"));
        cell.setMinimumHeight (50f);
        table.addCell (cell);
        table.addCell ("extend last row");
        cell = new PdfPCell (new Paragraph ("almost no content, but the row is extended"));
        table.addCell (cell);
        document.add (table);
    } catch (Exception de) {
        de.printStackTrace ();
    }
    document.close ();
}


-----Function Pair=85=-----==

public static void main (String [] args) {
    System.out.println ("Chapter 4: example FoxDogParagraph");
    System.out.println ("-> Creates a PDF file with the text");
    System.out.println ("   'Quick brown fox jumps over the lazy dog';");
    System.out.println ("   the text is added using Paragraph objects.");
    System.out.println ("-> jars needed: iText.jar");
    System.out.println ("-> resulting PDF: fox_dog_paragraph.pdf");
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapter04/fox_dog_paragraph.pdf"));
        document.open ();
        Chunk space = new Chunk (' ');
        String text = "Quick brown fox jumps over the lazy dog.";
        Phrase phrase1 = new Phrase (text);
        Phrase phrase2 = new Phrase (new Chunk (text, new Font (Font.TIMES_ROMAN)));
        Phrase phrase3 = new Phrase (text, new Font (Font.COURIER));
        Paragraph paragraph = new Paragraph ();
        paragraph.add (phrase1);
        paragraph.add (space);
        paragraph.add (phrase2);
        paragraph.add (space);
        paragraph.add (phrase3);
        document.add (paragraph);
        document.add (paragraph);
        paragraph.setAlignment (Element.ALIGN_LEFT);
        document.add (paragraph);
        paragraph.setAlignment (Element.ALIGN_CENTER);
        document.add (paragraph);
        paragraph.setAlignment (Element.ALIGN_RIGHT);
        document.add (paragraph);
        paragraph.setAlignment (Element.ALIGN_JUSTIFIED);
        document.add (paragraph);
        paragraph.setSpacingBefore (10);
        document.add (paragraph);
        paragraph.setSpacingBefore (0);
        paragraph.setSpacingAfter (10);
        document.add (paragraph);
        paragraph.setIndentationLeft (20);
        document.add (paragraph);
        paragraph.setIndentationRight (20);
        document.add (paragraph);
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


public static void Sample1 (String myField, String condition1, String condition2) throws SQLException {
    Connection connection = DriverManager.getConnection ("jdbc:postgresql://localhost/test", "user", "password");
    connection.setAutoCommit (false);
    PreparedStatement ps = connection.prepareStatement ("UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?");
    ps.setString (1, myField);
    ps.setString (2, condition1);
    ps.setString (3, condition2);
    int numChanged = ps.executeUpdate ();
    if (numChanged > 10) {
        connection.rollback ();
    }
    else {
        connection.commit ();
    }
    ps.close ();
    connection.close ();
}


-----Function Pair=86=-----==

public static boolean copyDir (File srcFile, File destFile, boolean overwrite) {
    logger.debug ("Copy srcFile[" + srcFile.getAbsolutePath () + "] to destFile[" + destFile.getAbsolutePath () + "] and" + " overwrite file if present");
    boolean result = false;
    if (srcFile.isDirectory ()) {
        if (! destFile.isDirectory () && ! destFile.mkdirs ()) {
            return false;
        }
        File [] listFiles = srcFile.listFiles ();
        for (int i = 0; i < listFiles.length; i ++) {
            File curFile = listFiles [i];
            if (curFile.isDirectory ()) {
                result = copyDir (curFile, new File (destFile, curFile.getName ()), overwrite);
            }
            else {
                result = copyFile (curFile, new File (destFile, curFile.getName ()), overwrite);
            }
            if (result == false) {
                return result;
            }
        }
    }
    return result;
}


public void jar (File z, File root, FileFilter filter) {
    if (root.exists ()) {
        try {
            if (! z.exists ()) z.createNewFile ();
            if (root.isDirectory ()) {
                JarOutputStream jar = new JarOutputStream (new FileOutputStream (z));
                File [] jarFiles = listFiles (root, false, filter);
                for (int i = 0; i < jarFiles.length; i ++) {
                    addJarEntry (jar, jarFiles [i], filter, null);
                }
                File [] dirs = listDirectories (root, false);
                for (int i = 0; i < dirs.length; i ++) {
                    addJarEntry (jar, dirs [i], filter, null);
                }
                jar.close ();
            }
        } catch (IOException ex) {
        }
    }
}


-----Function Pair=87=-----==

private static void copyFile (File from, File to) throws IOException {
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try {
        bis = new BufferedInputStream (new FileInputStream (from));
        bos = new BufferedOutputStream (new FileOutputStream (to));
        byte bs [] = new byte [1024];
        int len;
        while ((len = bis.read (bs)) != - 1) {
            bos.write (bs, 0, len);
        }
        bos.flush ();
    } finally {
        if (bis != null) {
            bis.close ();
        }
        if (bos != null) {
            bos.close ();
        }
    }
}


private List addRecursive (File dir) {
    List jars = new LinkedList ();
    List subdirs = new LinkedList ();
    if (dir.isDirectory ()) {
        File [] subs = dir.listFiles ();
        for (int i = 0; i < subs.length; i ++) {
            if (subs [i].isDirectory ()) subdirs.add (subs [i]);
            else if (subs [i].getName ().endsWith (".jar")) {
                jars.add (subs [i]);
            }
        }
        Collections.sort (jars, fileComparator);
        Collections.sort (subdirs, fileComparator);
        for (Iterator i = subdirs.iterator (); i.hasNext ();) {
            File subdir = (File) i.next ();
            jars.addAll (addRecursive (subdir));
        }
        return jars;
    }
    return Collections.EMPTY_LIST;
}


-----Function Pair=88=-----==

public static boolean copyDirectory (File srcPath, File dstPath) throws IOException {
    if (srcPath.isDirectory ()) {
        if (! dstPath.exists ()) {
            dstPath.mkdir ();
        }
        String files [] = srcPath.list ();
        for (String file : files) {
            copyDirectory (new File (srcPath, file), new File (dstPath, file));
        }
    }
    else {
        if (! srcPath.exists ()) {
            logger.error ("File or directory does not exist.");
            return false;
        }
        else {
            InputStream in = new FileInputStream (srcPath);
            OutputStream out = new FileOutputStream (dstPath);
            byte [] buf = new byte [1024];
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.close ();
        }
    }
    logger.info ("Directory " + srcPath + " copied to " + dstPath);
    return true;
}


public static void zipDirectory (String directory, String fileExtention, String destinationFile, boolean report) throws IOException {
    File logDirectory = new File (directory);
    if (! logDirectory.exists ()) {
        return;
    }
    Vector < File > logFiles = new Vector < File > (100);
    collectAllFiles (logDirectory, new ExtentionFilter (fileExtention), logFiles);
    if (logFiles.size () == 0) {
        return;
    }
    if (report) {
        System.out.println ("Backup " + logFiles.size () + " files");
    }
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (destinationFile));
    int mod = logFiles.size () / 10;
    if (mod == 0) {
        mod = 1;
    }
    try {
        for (int i = 0; i < logFiles.size (); i ++) {
            if (report) {
                if ((i % mod) == 0) {
                    System.out.print (".");
                }
            }
            File f = (File) logFiles.elementAt (i);
            if (f.isFile ()) {
                addZipEntry (zipOut, f, logDirectory);
            }
        }
    } finally {
        try {
            zipOut.close ();
        } catch (IOException e) {
            log.log (Level.FINEST, "IOException trying to close ZipOutputStream");
        }
    }
}


-----Function Pair=89=-----==

protected void initListeners () {
    searchEnabledCheck.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (searchEnabledCheck.isSelected ()) {
                if (! searchBox.isAncestorOf (searchPane)) {
                    String searchText = searchTextField.getText ();
                    if (searchText == null || searchText.trim ().length () == 0) {
                        if (annotationEditor.getAnnotationCurrentlyEdited () != null && getOwner () != null) {
                            String annText = getOwner ().getDocument ().getContent ().toString ().substring (annotationEditor.getAnnotationCurrentlyEdited ().getStartNode ().getOffset ().intValue (), annotationEditor.getAnnotationCurrentlyEdited ().getEndNode ().getOffset ().intValue ());
                            searchTextField.setText (annText);
                        }
                    }
                    searchBox.add (searchPane);
                }
                searchEnabledCheck.setText ("");
                searchCaseSensChk.setVisible (true);
                searchRegExpChk.setVisible (true);
                searchWholeWordsChk.setVisible (true);
                searchHighlightsChk.setVisible (true);
                searchTextField.requestFocusInWindow ();
                searchTextField.selectAll ();
                annotationEditorWindow.pack ();
                annotationEditor.setPinnedMode (true);
            }
            else {
                if (searchBox.isAncestorOf (searchPane)) {
                    searchEnabledCheck.setText ("Open Search & Annotate tool");
                    searchBox.remove (searchPane);
                    searchCaseSensChk.setVisible (false);
                    searchRegExpChk.setVisible (false);
                    searchWholeWordsChk.setVisible (false);
                    searchHighlightsChk.setVisible (false);
                    if (annotationEditor.getAnnotationCurrentlyEdited () != null) {
                        annotationEditor.setEditingEnabled (true);
                    }
                    annotationEditorWindow.pack ();
                }
            }
        }
    }
    );
    this.addAncestorListener (new AncestorListener () {
        public void ancestorAdded (AncestorEvent event) {
            if (searchTextField.getText ().trim ().length () == 0 && getOwner ().getTextComponent ().getSelectedText () != null) {
                searchTextField.setText (getOwner ().getTextComponent ().getSelectedText ());
            }
        } public void ancestorRemoved (AncestorEvent event) {
            enableActions (false);
        } public void ancestorMoved (AncestorEvent event) {
        }
    }
    );
    searchTextField.getDocument ().addDocumentListener (new DocumentListener () {
        public void changedUpdate (DocumentEvent e) {
            enableActions (false);
        } public void insertUpdate (DocumentEvent e) {
            enableActions (false);
        } public void removeUpdate (DocumentEvent e) {
            enableActions (false);
        }
    }
    );
    searchCaseSensChk.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            enableActions (false);
        }
    }
    );
    searchRegExpChk.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            enableActions (false);
        }
    }
    );
    searchWholeWordsChk.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            enableActions (false);
        }
    }
    );
    searchHighlightsChk.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            enableActions (false);
        }
    }
    );
}


private void enablePreferenceManagement () {
    fontPreferenceListener = new IPreferenceListener () {
        @Override
        public void preferenceChanged (final String property) {
            if ("fontName".equals (property)) {
                setFont ();
            }
            else if ("fontSize".equals (property)) {
                setFont ();
            }
            else if ("editorTextFont".equals (property)) {
                setFont ();
            }
        }
    }
    ;
    EditorsPreference.getInstance ().addListener (fontPreferenceListener);
    textControl.addDisposeListener (new DisposeListener () {
        @Override
        public void widgetDisposed (final DisposeEvent e) {
            EditorsPreference.getInstance ().removeListener (fontPreferenceListener);
            SqlEditorPreference.getInstance ().removeListener (editorPreferenceListener);
        }
    }
    );
}


-----Function Pair=90=-----==

private Control addLabel (Control controlTop, String text) {
    Label label = new Label (dialog, SWT.LEFT);
    FormData formDatalabel = new FormData ();
    if (controlTop == null) {
        formDatalabel.top = new FormAttachment (0, padding);
        formDatalabel.bottom = new FormAttachment (0, padding + 16);
    }
    else {
        formDatalabel.top = new FormAttachment (controlTop, padding, SWT.BOTTOM);
        formDatalabel.bottom = new FormAttachment (controlTop, padding + 16, SWT.BOTTOM);
    }
    formDatalabel.left = new FormAttachment (0, padding);
    formDatalabel.right = new FormAttachment (100, - padding);
    label.setLayoutData (formDatalabel);
    label.setText (text);
    return label;
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=91=-----==

public static byte [] decodeHex (String encoded) {
    if (encoded == null) return null;
    int lengthData = encoded.length ();
    if (lengthData % 2 != 0) return null;
    char [] binaryData = encoded.toCharArray ();
    int lengthDecode = lengthData / 2;
    byte [] decodedData = new byte [lengthDecode];
    byte temp1, temp2;
    char tempChar;
    for (int i = 0; i < lengthDecode; i ++) {
        tempChar = binaryData [i * 2];
        temp1 = (tempChar < BASELENGTH) ? hexNumberTable [tempChar] : - 1;
        if (temp1 == - 1) return null;
        tempChar = binaryData [i * 2 + 1];
        temp2 = (tempChar < BASELENGTH) ? hexNumberTable [tempChar] : - 1;
        if (temp2 == - 1) return null;
        decodedData [i] = (byte) ((temp1 << 4) | temp2);
    }
    return decodedData;
}


private String [] parsePolicyAllRulesAndFacts (String policy) throws Exception {
    List < String > allRulesAndFacts = new ArrayList < String > ();
    int lastSuccessfulIndex = 0;
    boolean allowNextIndexOfQuotes = true;
    boolean ignoreDot = false;
    boolean missingClosingQuotes = false;
    Pattern pattDot = Pattern.compile ("\\.");
    Pattern pattQuotes = Pattern.compile ("\"");
    Matcher matcherDot = pattDot.matcher (policy);
    Matcher matcherQuotes = pattQuotes.matcher (policy);
    while (matcherDot.find ()) {
        if (ignoreDot && (matcherDot.start () < matcherQuotes.start ())) continue;
        ignoreDot = false;
        while (true) {
            if (allowNextIndexOfQuotes) if (! matcherQuotes.find ()) break;
            if (matcherQuotes.start () < matcherDot.start ()) {
                missingClosingQuotes = false;
                while (true) {
                    if (! matcherQuotes.find ()) {
                        missingClosingQuotes = true;
                        break;
                    }
                    if (! policy.startsWith ("\\", matcherQuotes.start () - 1)) break;
                }
                if (missingClosingQuotes) throw new Exception ("Unable to parse. Missing a closing quotes (\") in disclosure policy files.");
                allowNextIndexOfQuotes = true;
                if (matcherQuotes.start () > matcherDot.start ()) {
                    ignoreDot = true;
                    break;
                }
            }
            else {
                allowNextIndexOfQuotes = false;
                break;
            }
        }
        if (! ignoreDot) {
            allRulesAndFacts.add (policy.substring (lastSuccessfulIndex, matcherDot.start ()));
            lastSuccessfulIndex = matcherDot.end ();
        }
    }
    if (allRulesAndFacts.isEmpty ()) throw new Exception ("No rules parsed from disclosure policy files.");
    return allRulesAndFacts.toArray (new String [allRulesAndFacts.size ()]);
}


-----Function Pair=92=-----==

private Control addCheck (int width, Group parent, String text, Control controlLeft, Control controlRight, Control controlTop, boolean leftAlign, boolean selected) {
    Button button = new Button (parent, SWT.CHECK);
    FormData formDataButton = new FormData ();
    if (controlRight != null) {
        formDataButton.left = new FormAttachment (controlRight, - width, SWT.RIGHT);
        formDataButton.right = new FormAttachment (controlRight, 0, SWT.RIGHT);
    }
    else if (controlLeft != null) {
        formDataButton.left = new FormAttachment (controlLeft, padding, SWT.RIGHT);
        formDataButton.right = new FormAttachment (controlLeft, padding + width, SWT.RIGHT);
    }
    else {
        if (leftAlign) {
            formDataButton.left = new FormAttachment (0, padding);
            formDataButton.right = new FormAttachment (0, padding + width);
        }
        else {
            formDataButton.left = new FormAttachment (100, - padding - width);
            formDataButton.right = new FormAttachment (100, - padding);
        }
    }
    if (controlTop != null) {
        formDataButton.top = new FormAttachment (controlTop, padding, SWT.BOTTOM);
        formDataButton.bottom = new FormAttachment (controlTop, 21 + padding, SWT.BOTTOM);
    }
    else {
        formDataButton.top = new FormAttachment (0, 0);
        formDataButton.bottom = new FormAttachment (0, 21);
    }
    button.setLayoutData (formDataButton);
    if (selected) button.setSelection (true);
    button.setText (text);
    button.addSelectionListener (new SelectionListener () {
        public void widgetDefaultSelected (SelectionEvent e) {
        } public void widgetSelected (SelectionEvent e) {
            state.list.clear ();
        }
    }
    );
    return button;
}


private Map < String, String > getValue (String command) {
    Map < String, String > map = new HashMap < String, String > ();
    String [] commands = command.split ("\\s+");
    boolean flag = false;
    String name = null;
    StringBuilder sb = null;
    for (int i = 1; i < commands.length; i ++) {
        String c = commands [i];
        if (flag) {
            sb.append (" ");
            if (c.endsWith ("\"")) {
                sb.append (c.substring (0, c.length () - 1));
                map.put (name, sb.toString ());
                flag = false;
            }
            else {
                sb.append (c);
            }
        }
        else {
            int index = c.indexOf ('=');
            if (index >= 0) {
                String value = c.substring (index + 1);
                if (value.startsWith ("\"")) {
                    if (value.endsWith ("\"")) {
                        map.put (c.substring (0, index), value.substring (1, value.length () - 1));
                    }
                    else {
                        sb = new StringBuilder (value.substring (1));
                        flag = true;
                        name = c.substring (0, index);
                    }
                }
                else {
                    map.put (c.substring (0, index), value);
                }
            }
            else {
                map.put (c, "true");
            }
        }
    }
    return map;
}


-----Function Pair=93=-----==

public static String urlDecode (String s) throws UnsupportedEncodingException {
    Pattern pattern = Pattern.compile ("(%[a-fA-F0-9]{2})+|\\+");
    Matcher m = pattern.matcher (s);
    int start = 0;
    StringBuffer sb = new StringBuffer ();
    while (m.find (start)) {
        if (start < m.start ()) {
            sb.append (s.substring (start, m.start ()));
        }
        if ("+".equals (m.group ())) {
            sb.append (' ');
        }
        else {
            String hex = m.group ();
            byte [] bytes = new byte [hex.length () / 3];
            for (int i = 0; i < bytes.length; i ++) {
                int b = Integer.parseInt (hex.substring (i * 3 + 1, i * 3 + 3), 16);
                bytes [i] = (byte) b;
            }
            sb.append (new String (bytes, "UTF8"));
        }
        start = m.end ();
    }
    if (start < s.length ()) {
        sb.append (s.substring (start));
    }
    return sb.toString ();
}


public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


-----Function Pair=94=-----=1=

private void colorizeEdit (StyledText edit) {
    String findResult = edit.getText ();
    final Color COLOR_BLUE = dialog.getDisplay ().getSystemColor (SWT.COLOR_BLUE);
    int start = 0;
    int index = findResult.indexOf ("\n");
    while (index != - 1) {
        String subString = findResult.substring (start, index);
        if (subString.length () != 0 && subString.startsWith ("(") && subString.endsWith (")")) {
            StyleRange style = new StyleRange ();
            style.start = start;
            style.length = subString.length ();
            style.underline = true;
            ((StyledText) editResult).setStyleRange (style);
        }
        else {
            StyleRange style = new StyleRange ();
            style.start = start;
            style.length = subString.length ();
            style.foreground = COLOR_BLUE;
            ((StyledText) editResult).setStyleRange (style);
        }
        start = index + 1;
        index = findResult.indexOf ("\n", index + 1);
    }
    String subString = findResult.substring (start).replace ("\n", "");
    if (subString.length () != 0 && subString.startsWith ("(") && subString.endsWith (")")) {
        StyleRange style = new StyleRange ();
        style.start = start;
        style.length = subString.length ();
        style.underline = true;
        ((StyledText) editResult).setStyleRange (style);
    }
    else {
        StyleRange style = new StyleRange ();
        style.start = start;
        style.length = subString.length ();
        style.foreground = COLOR_BLUE;
        ((StyledText) editResult).setStyleRange (style);
    }
    if (! WorkspaceSaveContainerGlobal.findCurrent.equals ("")) {
        final Color COLOR_RED = dialog.getDisplay ().getSystemColor (SWT.COLOR_RED);
        if (WorkspaceSaveContainerGlobal.regularExpression) {
            Pattern pattern = null;
            try {
                if (WorkspaceSaveContainerGlobal.caseSensitive) pattern = Pattern.compile (WorkspaceSaveContainerGlobal.findCurrent);
                else pattern = Pattern.compile (WorkspaceSaveContainerGlobal.findCurrent, Pattern.CASE_INSENSITIVE);
            } catch (PatternSyntaxException e) {
                return;
            }
            String [] findResultList = findResult.split ("\n");
            int findResultListCount = findResultList.length;
            int findResultListIndex;
            int offset = 0;
            for (findResultListIndex = 0; findResultListIndex < findResultListCount; findResultListIndex ++) {
                Matcher matcher = pattern.matcher (findResultList [findResultListIndex]);
                while (matcher.find ()) {
                    int startIndex = matcher.start ();
                    int endIndex = matcher.end ();
                    StyleRange style = new StyleRange ();
                    style.start = startIndex + offset;
                    style.length = endIndex - startIndex;
                    style.fontStyle = SWT.BOLD;
                    style.foreground = COLOR_RED;
                    ((StyledText) editResult).setStyleRange (style);
                }
                offset += findResultList [findResultListIndex].length () + 1;
            }
        }
        else {
            String findCurrentLowerCase = WorkspaceSaveContainerGlobal.findCurrent.toLowerCase ();
            String findResultLowerCase = findResult.toLowerCase ();
            if (WorkspaceSaveContainerGlobal.caseSensitive) index = findResult.indexOf (WorkspaceSaveContainerGlobal.findCurrent);
            else index = findResultLowerCase.indexOf (findCurrentLowerCase);
            while (index != - 1) {
                StyleRange style = new StyleRange ();
                style.start = index;
                style.length = WorkspaceSaveContainerGlobal.findCurrent.length ();
                style.fontStyle = SWT.BOLD;
                style.foreground = COLOR_RED;
                ((StyledText) editResult).setStyleRange (style);
                if (WorkspaceSaveContainerGlobal.caseSensitive) index = findResult.indexOf (WorkspaceSaveContainerGlobal.findCurrent, index + 1);
                else index = findResultLowerCase.indexOf (findCurrentLowerCase, index + 1);
            }
        }
    }
}


private Class compile0 (String name, String source) throws CannotCompileException, NotFoundException {
    source = source.trim ();
    Map < String, StringBuilder > smap = new HashMap < String, StringBuilder > ();
    {
        StringBuilder sb = new StringBuilder ();
        StringBuilder sv = null;
        for (int i = 0; i < source.length (); i ++) {
            char c = source.charAt (i);
            if (c == '\\') {
                (sv != null ? sv : sb).append ('\\').append (source.charAt (++ i));
                continue;
            }
            if (c == '"') {
                if (sv == null) {
                    String k = "[!-" + i + "-!]";
                    smap.put (k, sv = new StringBuilder ().append (c));
                    sb.append (k);
                }
                else {
                    sv.append (c);
                    sv = null;
                }
            }
            else if (sv == null) {
                sb.append (c);
            }
            else {
                sv.append (c);
            }
        }
        source = sb.toString ();
    }
    CtClass ctCls = classPool.makeClass ("cn.webwheel.gen." + name);
    {
        String s = source.substring (0, source.indexOf ('{'));
        int ei = s.indexOf ("extends ");
        int ii = s.indexOf ("implements ");
        String es = null;
        String is = null;
        if (ii == - 1) {
            if (ei != - 1) {
                es = s.substring (ei + "extends ".length ());
            }
        }
        else if (ei == - 1) {
            if (ii != - 1) {
                is = s.substring (ii + "implements ".length ());
            }
        }
        else if (ii > ei) {
            es = s.substring (ei + "extends ".length (), ii);
            is = s.substring (ii + "implements ".length ());
        }
        else {
            is = s.substring (ii + "implements ".length (), ei);
            es = s.substring (ei + "extends ".length ());
        }
        if (es != null) {
            ctCls.setSuperclass (classPool.get (es.trim ()));
        }
        if (is != null) {
            String [] ss = is.split (",");
            CtClass [] cs = new CtClass [ss.length];
            for (int i = 0; i < ss.length; i ++) {
                cs [i] = classPool.get (ss [i].trim ());
            }
            ctCls.setInterfaces (cs);
        }
        source = source.substring (source.indexOf ('{') + 1, source.length () - 1);
    }
    {
        StringBuilder sb = new StringBuilder ();
        int i = 0;
        int j = 0;
        Pattern pat = Pattern.compile ("\\[!\\-(\\d+)\\-!\\]");
        List < String > ms = new ArrayList < String > ();
        for (; i < source.length (); i ++) {
            char c = source.charAt (i);
            sb.append (c);
            if (c == '{') {
                j ++;
            }
            else if (c == '}') {
                j --;
                if (j == 0) {
                    String s = sb.toString ();
                    Matcher matcher = pat.matcher (s);
                    sb = new StringBuilder ();
                    int end = 0;
                    while (matcher.find ()) {
                        sb.append (s.substring (end, matcher.start ()));
                        sb.append (smap.get (matcher.group ()));
                        end = matcher.end ();
                    }
                    sb.append (s.substring (end));
                    ms.add (sb.toString ());
                    sb = new StringBuilder ();
                }
            }
            else if (c == ';' && j == 0) {
                ctCls.addField (CtField.make (sb.toString (), ctCls));
                sb = new StringBuilder ();
            }
        }
        for (String m : ms) {
            ctCls.addMethod (CtMethod.make (m, ctCls));
        }
    }
    return ctCls.toClass (classLoader, null);
}


-----Function Pair=95=-----==

public static String [] parseActionCode (String input) {
    ArrayList < String > spliter = new ArrayList < String > ();
    ArrayList < String > content = new ArrayList < String > ();
    Pattern pattern = Pattern.compile ("([$][0-9]+|[$][$])");
    Matcher matcher = pattern.matcher (input);
    int index = 0;
    while (matcher.find ()) {
        int start = matcher.start ();
        int end = matcher.end ();
        if (start >= index) {
            content.add (input.substring (index, start));
        }
        spliter.add (input.substring (start + 1, end));
        index = end;
    }
    if (index < input.length ()) content.add (input.substring (index));
    String [] ret = new String [spliter.size () + content.size ()];
    for (int i = 0; i < ret.length; ++ i) {
        if ((i % 2) == 0) ret [i] = content.get (i / 2);
        else ret [i] = spliter.get (i / 2);
    }
    return ret;
}


public static ArrayList < Integer > getGroups (String pattern) {
    ArrayList < Integer > captGroups = new ArrayList < Integer > ();
    Pattern p1 = Pattern.compile ("(?:(?:^|[^\\\\])(?:\\\\\\\\)*)(\\(+)(?!\\?)");
    Matcher m1 = p1.matcher (pattern);
    Pattern p2 = Pattern.compile ("(?:^|[^\\\\])(?:\\\\\\\\)*(\\[[^\\]\\(]*\\([^\\]]*\\])");
    Matcher m2 = p2.matcher (pattern);
    Pattern p3 = Pattern.compile ("\\(");
    ArrayList < Integer > brackets = new ArrayList < Integer > ();
    while (m2.find ()) {
        Matcher m3 = p3.matcher (m2.group (1));
        while (m3.find ()) {
            brackets.add (m2.start (1) + m3.start ());
        }
    }
    ArrayList < Integer > groups = new ArrayList < Integer > ();
    while (m1.find ()) {
        Matcher m3 = p3.matcher (m1.group (1));
        while (m3.find ()) {
            groups.add (m1.start (1) + m3.start ());
        }
    }
    for (int group : groups) {
        if (! brackets.contains (group)) {
            captGroups.add (group);
        }
    }
    return captGroups;
}


-----Function Pair=96=-----==

private void resetDisplay () {
    if (lockDisplay) return;
    final PredictionResult proteins = new PredictionResultImpl ();
    Object obj = proteinListComboBox.getSelectedItem ();
    if (obj != null && obj instanceof Protein) {
        Protein protein = (Protein) obj;
        PredictionModel model = selectedModel ();
        proteins.addModel (model);
        proteins.addProtein (protein);
        proteins.setThreshold (model, result.getThreshold (model));
    }
    displayTable.setResult (proteins);
    displayTextPane.setResult (proteins);
}


public String getURL (ResultSet rs) throws SQLException {
    StringBuilder url = new StringBuilder (template);
    int dev = 0;
    for (int i = 0; i < ioc.length; i ++) {
        final int open = openPos [i] + dev;
        final int close = closePos [i] + dev;
        final String value;
        if (ioc [i] != null) {
            value = ioc [i].getURLEncodedValue (rs);
            url = url.replace (open, close, value);
        }
        else {
            value = "";
            url = url.delete (open, close);
        }
        dev = dev - (closePos [i] - openPos [i]) + value.length ();
    }
    return new String (url);
}


-----Function Pair=97=-----==

public static int isamax_f77 (int n, double x [], int incx) {
    double xmax;
    int isamax, i, ix;
    if (n < 1) {
        isamax = 0;
    }
    else if (n == 1) {
        isamax = 1;
    }
    else if (incx == 1) {
        isamax = 1;
        xmax = Math.abs (x [1]);
        for (i = 2; i <= n; i ++) {
            if (Math.abs (x [i]) > xmax) {
                isamax = i;
                xmax = Math.abs (x [i]);
            }
        }
    }
    else {
        isamax = 1;
        ix = 1;
        xmax = Math.abs (x [ix]);
        ix += incx;
        for (i = 2; i <= n; i ++) {
            if (Math.abs (x [ix]) > xmax) {
                isamax = i;
                xmax = Math.abs (x [ix]);
            }
            ix += incx;
        }
    }
    return isamax;
}


int getTotalLength (String data [] []) {
    int maxLength = 0;
    int totalLength = 0;
    for (int i = 0; i < data [0].length; i ++) {
        for (int j = 0; j < data.length; j ++) {
            if (data [j] [i].length () >= maxCellLength) {
                maxLength = maxCellLength;
                continue;
            }
            if (data [j] [i].length () > maxLength) maxLength = data [j] [i].length ();
        }
        totalLength += maxLength;
        maxLength = 0;
    }
    return totalLength;
}


-----Function Pair=98=-----==

private static double [] getHPDInterval (double proportion, double [] values) {
    double [] returnArray = new double [2];
    int length = values.length;
    int [] indices = new int [length];
    HeapSort.sort (values, indices);
    double minRange = Double.MAX_VALUE;
    int hpdIndex = 0;
    int diff = (int) Math.round (proportion * (double) length);
    for (int i = 0; i <= (length - diff); i ++) {
        double minValue = values [indices [i]];
        double maxValue = values [indices [i + diff - 1]];
        double range = Math.abs (maxValue - minValue);
        if (range < minRange) {
            minRange = range;
            hpdIndex = i;
        }
    }
    returnArray [0] = values [indices [hpdIndex]];
    returnArray [1] = values [indices [hpdIndex + diff - 1]];
    return returnArray;
}


public static List < int [] > loadList (final String fileName) throws IOException {
    InputStream in = Resources.openResource (fileName);
    BufferedReader reader = new BufferedReader (new InputStreamReader (in));
    List < int [] > records = new ArrayList < int [] > (10);
    String result = null;
    try {
        while ((result = reader.readLine ()) != null) {
            if (! "".equals (result)) {
                String [] stringArray = result.split (",");
                int size = stringArray.length;
                int [] intArray = new int [size];
                for (int i = 0; i < size; i ++) {
                    intArray [i] = Integer.parseInt (stringArray [i]);
                }
                records.add (intArray);
            }
        }
    } finally {
        if (reader != null) {
            try {
                reader.close ();
                reader = null;
            } catch (IOException ex) {
            }
        }
    }
    return records;
}


-----Function Pair=99=-----==

private static void QuickSortMinToMax (int a [], int lo0, int hi0) {
    int lo = lo0;
    int hi = hi0;
    int mid;
    if (hi0 > lo0) {
        mid = a [(int) Math.round ((lo0 + hi0) / 2.0)];
        while (lo <= hi) {
            while ((lo < hi0) && (a [lo] < mid)) ++ lo;
            while ((hi > lo0) && (a [hi] > mid)) -- hi;
            if (lo <= hi) {
                swap (a, lo, hi);
                ++ lo;
                -- hi;
            }
        }
        if (lo0 < hi) QuickSortMinToMax (a, lo0, hi);
        if (lo < hi0) QuickSortMinToMax (a, lo, hi0);
    }
}


public Matrix times (Matrix B) throws IllegalArgumentException {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


-----Function Pair=100=-----==

public static Element [] [] invertArray (Element [] [] D, int n) {
    Field field = D [0] [0].getField ();
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            D [i] [j + n] = field.newZeroElement ();
        }
        D [i] [i + n] = field.newOneElement ();
    }
    int n2 = 2 * n;
    for (int i = 0; i < n; i ++) {
        Element alpha = D [i] [i].duplicate ();
        if (alpha.isZero ()) {
            throw new IllegalArgumentException ("Singular matrix, cannot invert");
        }
        else {
            for (int j = 0; j < n2; j ++) {
                D [i] [j].div (alpha);
            }
            for (int k = 0; k < n; k ++) {
                if ((k - i) != 0) {
                    Element beta = D [k] [i].duplicate ();
                    for (int j = 0; j < n2; j ++) {
                        D [k] [j].sub (beta.duplicate ().mul (D [i] [j]));
                    }
                }
            }
        }
    }
    return D;
}


public static Matrix parseMatlab (String matlab) throws Exception {
    StringTokenizer tokRow;
    StringTokenizer tokCol;
    int rows;
    int cols;
    Matrix result;
    String cells;
    cells = matlab.substring (matlab.indexOf ("[") + 1, matlab.indexOf ("]")).trim ();
    tokRow = new StringTokenizer (cells, ";");
    rows = tokRow.countTokens ();
    tokCol = new StringTokenizer (tokRow.nextToken (), " ");
    cols = tokCol.countTokens ();
    result = new Matrix (rows, cols);
    tokRow = new StringTokenizer (cells, ";");
    rows = 0;
    while (tokRow.hasMoreTokens ()) {
        tokCol = new StringTokenizer (tokRow.nextToken (), " ");
        cols = 0;
        while (tokCol.hasMoreTokens ()) {
            result.set (rows, cols, Double.parseDouble (tokCol.nextToken ()));
            cols ++;
        }
        rows ++;
    }
    return result;
}


-----Function Pair=101=-----==

public void buildMeasure (double [] [] data) throws Exception {
    if (NUM_ATTRIBUTES == 0) {
        System.err.println ("Cannot build model (attribute present in data!)");
        return;
    }
    m_NumClasses = NUM_CLASSES;
    m_ClassIndex = CLASS_INDEX;
    m_NumAttributes = NUM_ATTRIBUTES;
    m_NumInstances = data.length;
    m_TotalAttValues = 0;
    m_StartAttIndex = new int [m_NumAttributes];
    m_NumAttValues = new int [m_NumAttributes];
    for (int i = 0; i < m_NumAttributes; i ++) {
        if (i != m_ClassIndex) {
            m_StartAttIndex [i] = m_TotalAttValues;
            m_NumAttValues [i] = infoMaps [i].size ();
            m_TotalAttValues += m_NumAttValues [i];
        }
        else {
            m_StartAttIndex [i] = - 1;
            m_NumAttValues [i] = m_NumClasses;
        }
    }
    m_ClassCounts = new int [m_NumClasses];
    m_AttCounts = new int [m_TotalAttValues];
    m_AttAttCounts = new int [m_TotalAttValues] [m_TotalAttValues];
    m_ClassAttAttCounts = new int [m_NumClasses] [m_TotalAttValues] [m_TotalAttValues];
    for (int k = 0; k < m_NumInstances; k ++) {
        int classVal = (int) data [k] [m_ClassIndex];
        m_ClassCounts [classVal] ++;
        int [] attIndex = new int [m_NumAttributes];
        for (int i = 0; i < m_NumAttributes; i ++) {
            if (i == m_ClassIndex) {
                attIndex [i] = - 1;
            }
            else {
                attIndex [i] = m_StartAttIndex [i] + ((Value) infoMaps [i].get (data [k] [i])).getValueIndex ();
                m_AttCounts [attIndex [i]] ++;
            }
        }
        for (int Att1 = 0; Att1 < m_NumAttributes; Att1 ++) {
            if (attIndex [Att1] == - 1) {
                continue;
            }
            for (int Att2 = 0; Att2 < m_NumAttributes; Att2 ++) {
                if ((attIndex [Att2] != - 1)) {
                    m_AttAttCounts [attIndex [Att1]] [attIndex [Att2]] ++;
                    m_ClassAttAttCounts [classVal] [attIndex [Att1]] [attIndex [Att2]] ++;
                }
            }
        }
    }
    m_mutualInformation = new double [m_NumAttributes];
    for (int att = 0; att < m_NumAttributes; att ++) {
        if (att == m_ClassIndex) {
            continue;
        }
        m_mutualInformation [att] = getMutualInfoWithClassAtt (att);
    }
}


public int [] [] fillAccMask_EPSG900913 (int startPolygon, int endPolygon, double longitude1, double latitude1, double longitude2, double latitude2, int width, int height, byte [] [] three_state_map, boolean noCellsReturned) {
    double divx = (longitude2 - longitude1) / width;
    double divy = (latitude2 - latitude1) / height;
    int i, j;
    int [] [] data = null;
    boolean cellsReturned = ! noCellsReturned;
    if (cellsReturned) {
        data = new int [width * height] [2];
    }
    int p = 0;
    for (j = 0; j < three_state_map [0].length; j ++) {
        for (i = 0; i < three_state_map.length; i ++) {
            if (three_state_map [i] [j] == GI_PARTIALLY_PRESENT) {
            }
            else if ((j == 0 || three_state_map [i] [j - 1] == GI_PARTIALLY_PRESENT)) {
                if (i > 0 && (three_state_map [i - 1] [j] == GI_FULLY_PRESENT || three_state_map [i - 1] [j] == GI_ABSENCE)) {
                    three_state_map [i] [j] = three_state_map [i - 1] [j];
                }
                else {
                    int count = 0;
                    for (int k = startPolygon; k <= endPolygon; k ++) {
                        count += isWithin_EPSG900913 (j * divx + divx / 2 + longitude1, i * divy + divy / 2 + latitude1) ? 1 : 0;
                    }
                    if (count % 2 == 1) {
                        three_state_map [i] [j] = GI_FULLY_PRESENT;
                    }
                }
            }
            else {
                three_state_map [i] [j] = three_state_map [i] [j - 1];
            }
            if (cellsReturned && three_state_map [i] [j] != GI_UNDEFINED) {
                data [p] [0] = j;
                data [p] [1] = i;
                p ++;
            }
        }
    }
    if (data != null) {
        data = java.util.Arrays.copyOf (data, p);
    }
    return data;
}


-----Function Pair=102=-----==

private static boolean [] getPeaks (List < Integer > [] distr) {
    boolean [] p = new boolean [distr.length];
    int [] s = new int [distr.length];
    int [] r = new int [distr.length];
    int [] l = new int [distr.length];
    for (int i = 0; i < p.length; i ++) s [i] = distr [i].size ();
    for (int i = 0; i < p.length; i ++) {
        if (i < p.length - 1) r [i] = s [i] < s [i + 1] ? - 1 : s [i] > s [i + 1] ? 1 : 0;
        else r [i] = s [i] > 0 ? 1 : 0;
        if (i > 0) l [i] = s [i] < s [i - 1] ? - 1 : s [i] > s [i - 1] ? 1 : 0;
        else l [i] = s [i] > 0 ? 1 : 0;
    }
    boolean goingStraight = false;
    for (int i = 0; i < p.length; i ++) {
        if (r [i] == 1 && l [i] == 1) {
            p [i] = true;
            goingStraight = false;
        }
        else if (r [i] == 0 && l [i] == 1) {
            goingStraight = true;
            p [i] = false;
        }
        else if (r [i] == 0 && l [i] == 0 && goingStraight) {
            p [i] = false;
        }
        else if (r [i] == 1 && l [i] == 0 && goingStraight) {
            p [i] = true;
            goingStraight = false;
        }
        else {
            p [i] = false;
            goingStraight = false;
        }
    }
    return p;
}


public static double [] shrinkRegionStartEnd (double start, double end, double proportion, int alignment) {
    StatisticsToolkit.checkValueIncreasing (0, proportion, 1);
    double position = 0;
    switch (alignment) {
        case SwingConstants.LEFT :
            position = start;
            break;
        case SwingConstants.CENTER :
            position = (start + end) / 2;
            break;
        case SwingConstants.RIGHT :
            position = end;
            break;
        default :
            throw new UnsupportedOperationException ();
    }
    return getRegionStartEnd (position, (end - start) * proportion, alignment);
}


-----Function Pair=103=-----==

private String getGenotypeText () {
    String genotypeText = null;
    File genotypesFile = new File (filesDir, FILE_GENOTYPES);
    SAXReader reader = new SAXReader ();
    Document document = null;
    try {
        document = reader.read (genotypesFile);
    } catch (DocumentException ex) {
        throw new RuntimeException (ex);
    }
    Element root = document.getRootElement ();
    for (Object obj : root.elements ("ch")) {
        Element element = (Element) obj;
        Integer parsedLinkagGroup = Integer.valueOf (element.attribute ("id").getText ());
        if (parsedLinkagGroup.equals (Integer.valueOf (linkageGroup))) {
            genotypeText = element.getText ();
            break;
        }
    }
    return genotypeText;
}


public static ArrayList < Integer > getClusterColumn (IDataGrid grid, int columnNr) {
    ArrayList < Integer > erg = new ArrayList < Integer > ();
    ArrayList < Integer > clusterCols = getClusterColumnPos (grid);
    if (clusterCols == null) {
        log.debug ("@@@@@@@@@@@@@@@@@@@@@ Return null @@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
        return null;
    }
    if ((clusterCols.size () > 0) && (columnNr < clusterCols.size ())) {
        for (int i = 0; i < grid.getNumRows (); i ++) {
            IClusterNumber cn = (IClusterNumber) grid.getPoint (i, clusterCols.get (columnNr));
            Integer j = cn.get ();
            erg.add (j);
        }
    }
    if (erg.size () == 0) {
        log.debug ("@@@@@@@@@@@@@@@@@@@@@ Return null @@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
        return null;
    }
    return erg;
}


-----Function Pair=104=-----==

private int [] [] checkHomeAwayMatchesUnevenTeamNumber (int [] [] matrix) {
    int n = d_clubs.size ();
    if (n % 2 == 0) {
        return matrix;
    }
    Stack < Integer > tooManyHomeGames = new Stack < Integer > ();
    Stack < Integer > notEnoughHomeGames = new Stack < Integer > ();
    int [] numHomeGames = new int [n];
    int expectedHomeGames = (n - 1) / 2;
    for (int i = 0; i < n; i ++) {
        notEnoughHomeGames.add (new Integer (i));
    }
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            if (i == j) continue;
            if (matrix [i] [j] <= n) {
                numHomeGames [i] ++;
                if (numHomeGames [i] == expectedHomeGames) {
                    notEnoughHomeGames.remove (new Integer (i));
                }
                else if (numHomeGames [i] > expectedHomeGames) {
                    tooManyHomeGames.push (new Integer (i));
                }
            }
        }
    }
    while (! tooManyHomeGames.isEmpty ()) {
        int i = tooManyHomeGames.pop ();
        int j = notEnoughHomeGames.pop ();
        while (matrix [i] [j] > n) {
            notEnoughHomeGames.add (new Integer (j));
            j = notEnoughHomeGames.pop ();
        }
        int tmp = matrix [i] [j];
        matrix [i] [j] = matrix [j] [i];
        matrix [j] [i] = tmp;
    }
    return matrix;
}


public static double colvdot_f77 (int nrow, double x [] [], double y [], int begin, int j) {
    double colvdot;
    int i, m, mpbegin, end;
    colvdot = 0.0;
    if (nrow <= 0) return colvdot;
    m = nrow % 5;
    mpbegin = m + begin;
    end = begin + nrow - 1;
    for (i = begin; i < mpbegin; i ++) {
        colvdot += x [i] [j] * y [i];
    }
    for (i = mpbegin; i <= end; i += 5) {
        colvdot += x [i] [j] * y [i] + x [i + 1] [j] * y [i + 1] + x [i + 2] [j] * y [i + 2] + x [i + 3] [j] * y [i + 3] + x [i + 4] [j] * y [i + 4];
    }
    return colvdot;
}


-----Function Pair=105=-----==

public static double [] [] singleRotation (double [] [] loadingFactorMatrix, int k, int l, double angle) {
    int nRows = loadingFactorMatrix.length;
    int nColumns = loadingFactorMatrix [0].length;
    double [] [] rotatedMatrix = new double [nRows] [nColumns];
    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nColumns; j ++) {
            rotatedMatrix [i] [j] = loadingFactorMatrix [i] [j];
        }
    }
    double sinphi = Math.sin (angle);
    double cosphi = Math.cos (angle);
    for (int j = 0; j < nColumns; j ++) {
        rotatedMatrix [k] [j] = loadingFactorMatrix [k] [j] * cosphi + loadingFactorMatrix [l] [j] * sinphi;
        rotatedMatrix [l] [j] = - loadingFactorMatrix [k] [j] * sinphi + loadingFactorMatrix [l] [j] * cosphi;
    }
    return rotatedMatrix;
}


private double calculatePairwiseDistance (int taxon1, int taxon2) {
    double [] total = new double [4];
    double [] transversions = new double [4];
    for (Pattern pattern : alignment.getPatterns ()) {
        State state1 = pattern.getState (taxon1);
        State state2 = pattern.getState (taxon2);
        double weight = pattern.getWeight ();
        if (! state1.isAmbiguous () && ! state2.isAmbiguous ()) {
            total [state1.getIndex ()] += weight;
            if (Nucleotides.isTransversion (state1, state2)) {
                transversions [state1.getIndex ()] += weight;
            }
        }
    }
    double totalTransversions = 0.0;
    for (int i = 0; i < 4; ++ i) {
        if (total [i] > 0) {
            totalTransversions += transversions [i] / total [i];
        }
    }
    double expDist = 1.0 - (totalTransversions / 2.0);
    return expDist > 0 ? - Math.log (expDist) : MAX_DISTANCE;
}


-----Function Pair=106=-----==

public static void printCompare (PrintWriter f, String msg, float [] [] A, double [] [] B) {
    int nr = A.length;
    int nc = A [0].length;
    f.println (msg);
    for (int ir = 0; ir < nr; ir ++) {
        f.print ("[ ");
        if (nc <= 5) {
            for (int ic = 0; ic < nc; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
        }
        else {
            for (int ic = 0; ic < 4; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
            f.print (" ... ");
            for (int ic = nc - 2; ic < nc; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
        }
        f.print ("] vs. [");
        if (nc <= 5) {
            for (int ic = 0; ic < nc; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
        }
        else {
            for (int ic = 0; ic < 4; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
            f.print (" ... ");
            for (int ic = nc - 2; ic < nc; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
        }
        f.println ("]");
    }
    f.flush ();
}


private boolean dopivot (double [] [] A, double [] [] I, int diag, int nelem) {
    if (A [diag] [diag] != 0.0) return true;
    int i;
    for (i = diag + 1; i < nelem; i ++) {
        if (A [i] [diag] != 0.0) {
            double [] t;
            t = A [diag];
            A [diag] = A [i];
            A [i] = t;
            t = I [diag];
            I [diag] = I [i];
            I [i] = t;
            break;
        }
    }
    return i < nelem;
}


-----Function Pair=107=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


-----Function Pair=108=-----==

private Instances setOutputFormat () throws Exception {
    if (m_eigenvalues == null) {
        return null;
    }
    double cumulative = 0.0;
    FastVector attributes = new FastVector ();
    for (int i = m_numAttribs - 1; i >= 0; i --) {
        StringBuffer attName = new StringBuffer ();
        double [] coeff_mags = new double [m_numAttribs];
        for (int j = 0; j < m_numAttribs; j ++) coeff_mags [j] = - Math.abs (m_eigenvectors [j] [m_sortedEigens [i]]);
        int num_attrs = (m_maxAttrsInName > 0) ? Math.min (m_numAttribs, m_maxAttrsInName) : m_numAttribs;
        int [] coeff_inds;
        if (m_numAttribs > 0) {
            coeff_inds = Utils.sort (coeff_mags);
        }
        else {
            coeff_inds = new int [m_numAttribs];
            for (int j = 0; j < m_numAttribs; j ++) coeff_inds [j] = j;
        }
        for (int j = 0; j < num_attrs; j ++) {
            double coeff_value = m_eigenvectors [coeff_inds [j]] [m_sortedEigens [i]];
            if (j > 0 && coeff_value >= 0) attName.append ("+");
            attName.append (Utils.doubleToString (coeff_value, 5, 3) + m_trainInstances.attribute (coeff_inds [j]).name ());
        }
        if (num_attrs < m_numAttribs) attName.append ("...");
        attributes.addElement (new Attribute (attName.toString ()));
        cumulative += m_eigenvalues [m_sortedEigens [i]];
        if ((cumulative / m_sumOfEigenValues) >= m_coverVariance) {
            break;
        }
    }
    if (m_hasClass) {
        attributes.addElement (m_trainHeader.classAttribute ().copy ());
    }
    Instances outputFormat = new Instances (m_trainInstances.relationName () + "_principal components", attributes, 0);
    if (m_hasClass) {
        outputFormat.setClassIndex (outputFormat.numAttributes () - 1);
    }
    m_outputNumAtts = outputFormat.numAttributes ();
    return outputFormat;
}


private void computeRootCorrelations () {
    SpecUnit root, outNeuron, sunit;
    for (int i = 0; i < vectors.length; i ++) {
        responses [i] = gamNet.getOutput (vectors [i]);
    }
    root = new SpecUnit (((Integer) (outputNeuronId * 2)).toString (), responses);
    mapUnits.put (((Integer) (outputNeuronId * 2)).toString (), root);
    outNeuron = (SpecUnit) mapUnits.get (((Integer) (outputNeuronId * 2)).toString ());
    infoWnd.actualID = outputNeuronId * 2;
    double correl;
    for (int i = 0; i < inputs.length; i ++) {
        sunit = new SpecUnit (((Integer) (i * 2)).toString (), inputs [i]);
        mapUnits.put (((Integer) (i * 2)).toString (), sunit);
        correl = computeCorrelation (outNeuron, sunit);
        mapCorrel.put (outNeuron.getName () + "-" + sunit.getName (), correl);
        frInOut [i] = correl;
        System.out.println ("correl " + outNeuron.getName () + " and " + sunit.getName () + " is: " + mapCorrel.get (outNeuron.getName () + "-" + sunit.getName ()));
    }
}


-----Function Pair=109=-----==

public static void clustMat (int nrow, int [] [] clusters, int clust1, int clust2, int ncl) {
    if ((clust1 == 0) || (clust2 == 0)) {
        for (int j = 0; j < nrow; j ++) {
            for (int i = 0; i < nrow; i ++) {
                clusters [i] [j] = 0;
            }
        }
        for (int i = 0; i < nrow; i ++) {
            clusters [i] [ncl - 1] = i + 1;
        }
        return;
    }
    int ncl1;
    ncl1 = ncl - 1;
    for (int i = 0; i < nrow; i ++) {
        clusters [i] [ncl1] = clusters [i] [ncl];
        if (clusters [i] [ncl1] == clust2) {
            clusters [i] [ncl1] = clust1;
        }
    }
}


public static void BubbleSortLong2 (long [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                long temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=110=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


public static double [] [] square (double [] [] mat) {
    int m = Matrix.getNumOfRows (mat);
    int n = Matrix.getNumOfColumns (mat);
    double [] [] res = Matrix.newMatrix (m, m);
    for (int i = 0; i < m; ++ i) {
        res [i] [i] = 0.0;
        for (int k = 0; k < n; ++ k) res [i] [i] += mat [i] [k] * mat [i] [k];
        for (int j = 0; j < i; ++ j) {
            res [i] [j] = 0.0;
            for (int k = 0; k < n; ++ k) res [i] [j] += mat [i] [k] * mat [j] [k];
            res [j] [i] = res [i] [j];
        }
    }
    return (res);
}


-----Function Pair=111=-----==

public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


public static MathComplexMatrix add (MathComplexMatrix matrixA, MathComplexMatrix matrixB) throws IllegalArgumentException {
    if (matrixA.getM () != matrixB.getM () && matrixA.getN () != matrixB.getN ()) {
        throw new IllegalArgumentException ("Matrices must have equal dimensions, for adding");
    }
    else {
        int m = matrixA.getM ();
        int n = matrixA.getN ();
        Complex [] [] dataA = matrixA.getAllItems ();
        Complex [] [] dataB = matrixB.getAllItems ();
        Complex [] [] newData = new Complex [m] [n];
        for (int ni = 0; ni < n; ni ++) {
            for (int mi = 0; mi < m; mi ++) {
                newData [mi] [ni] = Complex.add (dataA [mi] [ni], dataB [mi] [ni]);
            }
        }
        return new MathComplexMatrix (newData);
    }
}


-----Function Pair=112=-----==

public double [] [] Adjoint (final double [] [] a) {
    int tms = a.length;
    double m [] [] = new double [tms] [tms];
    int ii, jj, ia, ja;
    double det;
    for (int i = 0; i < tms; i ++) for (int j = 0; j < tms; j ++) {
        ia = ja = 0;
        double ap [] [] = new double [tms - 1] [tms - 1];
        for (ii = 0; ii < tms; ii ++) {
            for (jj = 0; jj < tms; jj ++) {
                if ((ii != i) && (jj != j)) {
                    ap [ia] [ja] = a [ii] [jj];
                    ja ++;
                }
            }
            if ((ii != i) && (jj != j)) {
                ia ++;
            }
            ja = 0;
        }
        det = Determinant (ap);
        m [i] [j] = (float) Math.pow (- 1, i + j) * det;
    }
    m = Transpose (m);
    return m;
}


public Matrix times (Matrix B) {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


-----Function Pair=113=-----==

public void mouseDragged (MouseEvent e) {
    if (lastPressedButtonWas != MouseEvent.BUTTON1) {
        return;
    }
    int w = getWidth () - rightMargin;
    double diff_x_dat = zoomMaxComp1 - zoomMinComp1;
    double diff_x_scr = w;
    double xpos = zoomMinComp1 + diff_x_dat * e.getX () / diff_x_scr;
    int h = getHeight ();
    double diff_y_dat = zoomMaxComp2 - zoomMinComp2;
    double diff_y_scr = h;
    double ypos = (zoomMinComp2 + diff_y_dat * (double) (h - e.getY ()) / diff_y_scr);
    if (selectionFirstClickComp1 == - 1) {
        selectionFirstClickComp1 = xpos;
        selectionFirstClickComp2 = ypos;
    }
    else {
        selectionLastClickComp1 = xpos;
        selectionLastClickComp2 = ypos;
        if (selectionLastClickComp1 < zoomMinComp1) {
            selectionLastClickComp1 = zoomMinComp1;
        }
        if (selectionLastClickComp1 > (zoomMaxComp1)) {
            selectionLastClickComp1 = zoomMaxComp1;
        }
        if (selectionLastClickComp2 < zoomMinComp2) {
            selectionLastClickComp2 = zoomMinComp2;
        }
        if (selectionLastClickComp2 > zoomMaxComp2) {
            selectionLastClickComp2 = zoomMaxComp2;
        }
        if (selectionLastClickComp1 > selectionFirstClickComp1) {
            mouseAreaStartComp1 = selectionFirstClickComp1;
            mouseAreaEndComp1 = selectionLastClickComp1;
        }
        else {
            mouseAreaStartComp1 = selectionLastClickComp1;
            mouseAreaEndComp1 = selectionFirstClickComp1;
        }
        if (selectionLastClickComp2 > selectionFirstClickComp2) {
            mouseAreaStartComp2 = selectionFirstClickComp2;
            mouseAreaEndComp2 = selectionLastClickComp2;
        }
        else {
            mouseAreaStartComp2 = selectionLastClickComp2;
            mouseAreaEndComp2 = selectionFirstClickComp2;
        }
        zoomToSelectionMenuItem.setEnabled (true);
        repaint ();
    }
    statBar.setStatusText ("");
}


public static int [] sort (final double [] items, boolean descending) {
    Integer [] itemIndices = new Integer [items.length];
    for (int i = 0; i < items.length; i ++) {
        itemIndices [i] = new Integer (i);
    }
    Arrays.sort (itemIndices, new Comparator () {
        @Override
        public int compare (Object index1, Object index2) {
            int intIndex1 = ((Integer) index1).intValue ();
            int intIndex2 = ((Integer) index2).intValue ();
            if (items [intIndex1] < items [intIndex2]) {
                return 1;
            }
            else if (items [intIndex1] > items [intIndex2]) {
                return - 1;
            }
            else {
                return 0;
            }
        }
    }
    );
    int [] sortedIndices = new int [items.length];
    for (int i = 0; i < items.length; i ++) {
        sortedIndices [i] = itemIndices [i].intValue ();
    }
    if (descending == false) {
        sortedIndices = reverse (sortedIndices);
    }
    return sortedIndices;
}


-----Function Pair=114=-----==

byte [] generateReply (Message query, byte [] in, int length, Socket s) throws IOException {
    Header header;
    boolean badversion;
    int maxLength;
    boolean sigonly;
    SetResponse sr;
    int flags = 0;
    header = query.getHeader ();
    if (header.getFlag (Flags.QR)) return null;
    if (header.getRcode () != Rcode.NOERROR) return errorMessage (query, Rcode.FORMERR);
    if (header.getOpcode () != Opcode.QUERY) return errorMessage (query, Rcode.NOTIMP);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = (TSIG) TSIGs.get (queryTSIG.getName ());
        if (tsig == null || tsig.verify (query, in, length, null) != Rcode.NOERROR) return formerrMessage (in);
    }
    OPTRecord queryOPT = query.getOPT ();
    if (queryOPT != null && queryOPT.getVersion () > 0) badversion = true;
    if (s != null) maxLength = 65535;
    else if (queryOPT != null) maxLength = Math.max (queryOPT.getPayloadSize (), 512);
    else maxLength = 512;
    if (queryOPT != null && (queryOPT.getFlags () & ExtendedFlags.DO) != 0) flags = FLAG_DNSSECOK;
    Message response = new Message (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.QR);
    if (query.getHeader ().getFlag (Flags.RD)) response.getHeader ().setFlag (Flags.RD);
    response.addRecord (queryRecord, Section.QUESTION);
    Name name = queryRecord.getName ();
    int type = queryRecord.getType ();
    int dclass = queryRecord.getDClass ();
    if (type == Type.AXFR && s != null) return doAXFR (name, query, tsig, queryTSIG, s);
    if (! Type.isRR (type) && type != Type.ANY) return errorMessage (query, Rcode.NOTIMP);
    byte rcode = addAnswer (response, name, type, dclass, 0, flags);
    if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage (query, rcode);
    addAdditional (response, flags);
    if (queryOPT != null) {
        int optflags = (flags == FLAG_DNSSECOK) ? ExtendedFlags.DO : 0;
        OPTRecord opt = new OPTRecord ((short) 4096, rcode, (byte) 0, optflags);
        response.addRecord (opt, Section.ADDITIONAL);
    }
    response.setTSIG (tsig, Rcode.NOERROR, queryTSIG);
    return response.toWire (maxLength);
}


private void parseSimpleProtFile (String fname) {
    try {
        BufferedReader inputStream = new BufferedReader (new FileReader (fname));
        String line;
        String seperators = ",\t;: ";
        String sep = null;
        line = inputStream.readLine ();
        int col = 0;
        int whichsep = 0;
        StringTokenizer tokens = null;
        while ((col <= 1) && (whichsep < seperators.length ())) {
            sep = seperators.substring (whichsep, whichsep + 1);
            tokens = new StringTokenizer (line, sep);
            col = tokens.countTokens ();
            whichsep ++;
        }
        if (col <= 1) {
            System.out.println ("Header line in " + fname + " does not contain identifiable seperators (tried comma, tab, semicolon, colon, space) - quitting");
            System.exit (1);
        }
        for (; col -- > 0;) {
            hdrNames.add (tokens.nextToken ());
        }
        Pattern pat = Pattern.compile ("(\\D+)(\\d+)");
        col = hdrNames.size ();
        Vector < String > tmp_groupNames = new Vector < String > ();
        for (int replicate = 2; replicate -- > 0;) {
            for (; col -- > 1;) {
                Matcher anum2 = pat.matcher (hdrNames.get (col));
                Boolean match2 = anum2.matches ();
                Matcher anum1 = pat.matcher (hdrNames.get (col - 1));
                nReplicates [replicate] += 1;
                if ((! anum1.matches ()) || (! match2) || (anum1.groupCount () != 2) || (anum2.groupCount () != 2) || (! anum1.group (1).equals (anum2.group (1)))) {
                    tmp_groupNames.add (anum2.group (1));
                    break;
                }
            }
        }
        for (int i = tmp_groupNames.size (); i -- > 0;) {
            groupNames.add (tmp_groupNames.get (i));
        }
        while (col < hdrNames.size ()) {
            hdrNames.remove (col);
        }
        int minReplicates = Math.min (nReplicates [0], nReplicates [1]);
        while ((line = inputStream.readLine ()) != null) {
            tokens = new StringTokenizer (line, sep);
            if (tokens.countTokens () != (nReplicates [0] + nReplicates [1] + hdrNames.size ())) {
                continue;
            }
            Vector < String > proteinInfo = new Vector < String > ();
            for (int h = hdrNames.size (); h -- > 0;) {
                proteinInfo.add (tokens.nextToken ());
            }
            double [] counts = new double [2 * minReplicates];
            double [] averages = {0, 0};
            int c = 0;
            for (int rep = 0; rep < 2; rep ++) {
                for (int i = 0; i < nReplicates [rep]; i ++) {
                    if (i < minReplicates) {
                        counts [c] = Double.parseDouble (tokens.nextToken ());
                        averages [rep] += counts [c ++];
                    }
                    else {
                        Double.parseDouble (tokens.nextToken ());
                    }
                }
            }
            proteinInfo.add (Double.toString (averages [0] / minReplicates));
            proteinInfo.add (Double.toString (averages [1] / minReplicates));
            Protein p = new Protein (proteinInfo, counts);
            proteinList.add (p);
        }
        inputStream.close ();
        hdrNames.add (this.groupNames.get (0) + " avgSC");
        hdrNames.add (this.groupNames.get (1) + " avgSC");
    } catch (IOException e) {
        System.out.println ("Error opening file " + fname + ": " + e.toString ());
        System.exit (1);
    }
}


-----Function Pair=115=-----==

private static void pipe_env_set_random_seed () throws IOException {
    String buf;
    int act, count = 0, action_case;
    Class partypes [];
    Method meth;
    Object arglist [];
    Object retobj2 = null;
    String buf2;
    double r;
    boolean term;
    try {
        buf = br.readLine ();
        while (buf == null) buf = br.readLine ();
        st = new StringTokenizer (buf);
        while (st.hasMoreTokens ()) {
            token [count] = st.nextToken ().trim ();
            if (! token [count].equals ("\n")) count ++;
        }
        if (count == 1) {
            action_case = 1;
            for (int i = 0; i < token [0].length (); i ++) if (token [0].charAt (i) == '.') action_case = 2;
        }
        else {
            action_case = 3;
            for (int i = 0; i < count; i ++) for (int j = 0; j < token [i].length (); j ++) if (token [i].charAt (j) == '.') action_case = 4;
        }
        if (action_case == 1) {
            ai = Integer.parseInt (token [0]);
            partypes = new Class [1];
            partypes [0] = Integer.TYPE;
            meth = agent.getMethod ("env_set_random_seed", partypes);
            arglist = new Object [1];
            arglist [0] = new Integer (ai);
            meth.invoke (retobj, arglist);
        }
        else if (action_case == 2) {
            af = Double.parseDouble (token [0]);
            partypes = new Class [1];
            partypes [0] = Double.TYPE;
            meth = agent.getMethod ("env_set_random_seed", partypes);
            arglist = new Object [1];
            arglist [0] = new Double (af);
            meth.invoke (retobj, arglist);
        }
        else if (action_case == 3) {
            aia = new int [count];
            for (int i = 0; i < count; i ++) aia [i] = Integer.parseInt (token [i]);
            partypes = new Class [1];
            partypes [0] = Class.forName ("[I");
            meth = agent.getMethod ("env_set_random_seed", partypes);
            arglist = new Object [1];
            arglist [0] = aia;
            meth.invoke (retobj, arglist);
        }
        else if (action_case == 4) {
            afa = new double [count];
            for (int i = 0; i < count; i ++) afa [i] = Double.parseDouble (token [i]);
            partypes = new Class [1];
            partypes [0] = Class.forName ("[D");
            meth = agent.getMethod ("env_set_random_seed", partypes);
            arglist = new Object [1];
            arglist [0] = afa;
            meth.invoke (retobj, arglist);
        }
        file.write ("IMPLEMENTED" + "\n");
        file.flush ();
    } catch (InvocationTargetException e) {
        System.err.println ("\nError: Error in your env_set_random_seed method!!\n");
        e.printStackTrace ();
    } catch (Throwable e) {
        file.write ("NOTIMPLEMENTED" + "\n");
        file.flush ();
    }
}


public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (r, section);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (r2, section);
            }
            return removed;
        }
    }
    return removed;
}


-----Function Pair=116=-----==

public static void copyFile1 (File srcFile, File destFile) throws IOException {
    if (! destFile.exists ()) {
        destFile.createNewFile ();
    }
    FileInputStream fis = new FileInputStream (srcFile);
    FileOutputStream fos = new FileOutputStream (destFile);
    FileChannel source = fis.getChannel ();
    FileChannel destination = fos.getChannel ();
    destination.transferFrom (source, 0, source.size ());
    source.close ();
    destination.close ();
    fis.close ();
    fos.close ();
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=117=-----==

void addRRset (Name name, Message response, RRset rrset, boolean sigonly) {
    Enumeration e;
    if (! sigonly) {
        e = rrset.rrs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
            response.addRecord (r, Section.ANSWER);
        }
    }
    e = rrset.sigs ();
    while (e.hasMoreElements ()) {
        Record r = (Record) e.nextElement ();
        if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
        response.addRecord (r, Section.ANSWER);
    }
}


static void takeReport (String screenshotname1, String screenshotname2, String caption, String warnOverrideMsg, String msg, String cmd, String prefix) {
    if (appListBox.getSelectedIndex () == - 1 && appListModel.size () > 1) {
        JOptionPane.showMessageDialog (frame, "Select a monitored application first.", "Report Bug", JOptionPane.ERROR_MESSAGE);
        return;
    }
    int index = appListBox.getSelectedIndex ();
    if (index == - 1) {
        index = 0;
    }
    if (take_screenshots) {
        shell ("python takescreenshot.py " + temp_dir + " " + screenshotname2);
        shell ("python compressscreenshot.py " + temp_dir + " " + screenshotname1 + " before");
        shell ("python compressscreenshot.py " + temp_dir + " " + screenshotname2 + " after");
    }
    Integer app_id = (Integer) appId.get (new Integer (index));
    ReportDialog r = new ReportDialog (frame, caption, warnOverrideMsg, msg, temp_dir + "/beforeScreenshot.jpg", temp_dir + "/afterScreenshot.jpg");
    if (! take_screenshots) {
        r.check_box.setSelected (false);
        r.check_box.setEnabled (false);
        r.beforeLabel.setIcon (r.noScreenshot);
        r.afterLabel.setIcon (r.noScreenshot);
    }
    r.pack ();
    r.setVisible (true);
    System.out.println ("w.abort=" + r.abort);
    if (! r.abort) {
        String picked = r.text_area.getText ().trim ();
        if (picked.equals ("")) {
            picked = "[no user comment]";
        }
        picked = prefix + ":  " + picked;
        System.out.println ("..." + picked + " " + app_id);
        if (! r.check_box.isSelected ()) {
            try {
                FileCopy.copy ("logo.jpg", temp_dir + "/beforeScreenshot.jpg", true);
                FileCopy.copy ("logo.jpg", temp_dir + "/afterScreenshot.jpg", true);
            } catch (IOException e) {
                System.out.println (e);
            }
        }
        out.println (cmd + " " + picked.replace ('\n', '@').replace (' ', '_') + " " + app_id + " " + r.warn_check_box.isSelected ());
    }
}


-----Function Pair=118=-----==

private DataSet (DataSet orig) {
    sitename = orig.sitename;
    plottype = orig.plottype;
    data = new Vector [orig.data.length];
    for (int i = 0; i < orig.data.length; i ++) {
        data [i] = (Vector) orig.data [i].clone ();
    }
    fit = new Double [orig.fit.length];
    for (int i = 0; i < orig.fit.length; i ++) {
        fit [i] = new Double (orig.fit [i].doubleValue ());
    }
    decYear = new Double (orig.decYear.doubleValue ());
    average = orig.average;
    detrend = orig.detrend;
    haveFit = orig.haveFit;
    haveDate = orig.haveDate;
    allowDemean = orig.allowDemean;
}


public static void main (String [] args) {
    LTabFileReader rdr = new LTabFileReader ();
    try {
        PrintWriter out = new PrintWriter (new FileOutputStream (".tfr.tmp"));
        out.println ("abc");
        out.println ("def\tghi");
        out.println ("jkl");
        out.println ("");
        out.println ("mno\tpqr");
        out.println ("stu\tvwx\tyz-");
        out.println ("ABC\tDEF");
        out.println ("GHI");
        out.println ("");
        out.println ("JKL");
        out.println ("MNO\tPQR");
        out.println ("STU\tVWX\tYZ_");
        out.close ();
        rdr.load (".tfr.tmp");
        int r = rdr.numRows ();
        String s;
        int c;
        for (int i = 0; i < r; i ++) {
            c = rdr.numCols (i);
            for (int j = 0; j < c; j ++) {
                if (j > 0) System.out.print ("\t");
                s = rdr.get (i, j);
                System.out.print (s);
            }
            System.out.println ("");
        }
    } catch (IOException e) {
        System.out.println (e);
    }
}


-----Function Pair=119=-----==

void addRRset (Name name, Message response, RRset rrset, byte section, boolean sigonly) {
    Enumeration e;
    for (byte s = 1; s <= section; s ++) if (response.findRRset (name, rrset.getType (), s)) return;
    if (! sigonly) {
        e = rrset.rrs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
    e = rrset.sigs ();
    while (e.hasMoreElements ()) {
        Record r = (Record) e.nextElement ();
        if (! name.isWild () && r.getName ().isWild ()) r = r.withName (name);
        response.addRecord (r, section);
    }
}


private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


-----Function Pair=120=-----==

private void unzip (File f) throws IOException {
    ZipFile zip;
    zip = new ZipFile (f);
    Enumeration e = zip.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry zen = (ZipEntry) e.nextElement ();
        if (zen.isDirectory ()) {
            continue;
        }
        int size = (int) zen.getSize ();
        InputStream zis = zip.getInputStream (zen);
        String extractfile = f.getParentFile ().getAbsolutePath () + File.separator + zen.getName ();
        writeFile (zis, new File (extractfile), size);
        zis.close ();
    }
    zip.close ();
}


public static void copyFile (File source, File dest) throws IOException {
    if (! dest.exists ()) {
        dest.createNewFile ();
    }
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (source);
        out = new FileOutputStream (dest);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
    } finally {
        in.close ();
        out.close ();
    }
}


-----Function Pair=121=-----==

public static void main (String [] args) {
    final String username = "username@gmail.com";
    final String password = "password";
    Properties props = new Properties ();
    props.put ("mail.smtp.auth", "true");
    props.put ("mail.smtp.starttls.enable", "true");
    props.put ("mail.smtp.host", "smtp.gmail.com");
    props.put ("mail.smtp.port", "587");
    Session session = Session.getInstance (props, new javax.mail.Authenticator () {
        protected PasswordAuthentication getPasswordAuthentication () {
            return new PasswordAuthentication (username, password);
        }
    }
    );
    try {
        Message message = new MimeMessage (session);
        message.setFrom (new InternetAddress ("from-email@gmail.com"));
        message.setRecipients (Message.RecipientType.TO, InternetAddress.parse ("to-email@gmail.com"));
        message.setSubject ("Testing Subject");
        message.setText ("Dear Mail Crawler," + "\n\n No spam to my email, please!");
        Transport.send (message);
    } catch (MessagingException e) {
        throw new RuntimeException (e);
    }
}


private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=122=-----==

public Controller restoreMostRecentTemporaryState (Color color) throws NoSuchDataException, InternalErrorException {
    long t = 0l;
    PersistedGame last = null;
    PersistedGame [] pgarr = listTemporaryGames ();
    for (int i = 0; i < pgarr.length; i ++) {
        String fname = getTemporaryGameFileName (pgarr [i].getName ());
        File f = new File (fname);
        long t2 = f.lastModified ();
        if (t2 > t) {
            last = pgarr [i];
            t = t2;
        }
    }
    if (last == null) throw new NoSuchDataException ("No active games to restore");
    GameId gid;
    if (color.equals (Color.BLACK)) {
        gid = last.getBlackId ();
    }
    else {
        gid = last.getWhiteId ();
    }
    return restoreTemporaryState (gid);
}


public void valueChanged (ListSelectionEvent e) {
    if (! e.getValueIsAdjusting () && ! fileSelectionsIsAdjusting) {
        Object target = getFileTable ();
        File [] selectedFiles = getSelectedFiles (target);
        if (selectedFiles.length > 0) {
            List < File > files = new ArrayList < File > ();
            for (File selectedFile : selectedFiles) {
                if ((getFileChooser ().isDirectorySelectionEnabled () && selectedFile.isDirectory ()) || (! getFileChooser ().isDirectorySelectionEnabled () && ! selectedFile.isDirectory ())) {
                    files.add (selectedFile);
                }
            }
            if (files.isEmpty ()) {
                if (getFileChooser ().isMultiSelectionEnabled ()) {
                    getFileChooser ().setSelectedFiles (new File [] {});
                }
                else {
                    getFileChooser ().setSelectedFile (null);
                }
            }
            else if (files.size () == 1) {
                if (getFileChooser ().isMultiSelectionEnabled ()) {
                    getFileChooser ().setSelectedFiles (files.toArray (new File [1]));
                }
                else {
                    getFileChooser ().setSelectedFile (files.get (0));
                }
            }
            else if (files.size () > 1) {
                getFileChooser ().setSelectedFiles (files.toArray (new File [files.size ()]));
            }
        }
        else if (! filePathSelectionIsAdjusting) {
            getFileChooser ().setSelectedFile (null);
        }
        approveButton.setEnabled (getFileChooser ().getSelectedFile () != null);
    }
}


-----Function Pair=123=-----==

public boolean addDownload (DownloadInfo di) {
    String filename = di.getResource ().getName () + "-" + Resources.sizeBytesToInt (di.getResource ().getID ()) + ".zip";
    String dirname = this.profile.getDownload_GlobalPath () + File.separatorChar + di.getResource ().getName () + dateformat.format (new Date ()) + "d" + Resources.sizeBytesToInt (di.getResource ().getID ());
    File dir = new File (dirname);
    String tmp = "d";
    while (dir.exists ()) {
        tmp += "d";
        dirname = this.profile.getDownload_GlobalPath () + File.separatorChar + di.getResource ().getName () + dateformat.format (new Date ()) + tmp + Resources.sizeBytesToInt (di.getResource ().getID ());
        dir = new File (dirname);
    }
    dir.mkdir ();
    di.getResource ().setPath (dirname + File.separatorChar + filename);
    di.setByteResidue (di.getResource ().getSize ());
    di.setStartDate (System.currentTimeMillis ());
    if (this.poolDown.addDownload (di)) {
        debug.println ("Provider: add download " + di.getIDString () + " in queue ,resource=" + di.getResource ().getName () + "/" + di.getResource ().getIDString ());
        return true;
    }
    debug.println ("Provider: download " + di.getResource ().getName () + " / " + di.getResource ().getIDString () + " not inserted in queue");
    return false;
}


private byte [] updatePathSettings (HTTPurl urlData) throws Exception {
    int minSpaceSoft = 1200;
    try {
        minSpaceSoft = Integer.parseInt (urlData.getParameter ("minSpaceSoft").trim ());
    } catch (Exception e) {
    }
    store.setServerProperty ("capture.minspacesoft", new Integer (minSpaceSoft).toString ());
    int minSpaceHard = 200;
    try {
        minSpaceHard = Integer.parseInt (urlData.getParameter ("minSpaceHard").trim ());
    } catch (Exception e) {
    }
    store.setServerProperty ("capture.minspacehard", new Integer (minSpaceHard).toString ());
    String deleteToFree = urlData.getParameter ("DeleteToFreeSpace");
    if ("true".equalsIgnoreCase (deleteToFree)) {
        store.setServerProperty ("capture.deletetofreespace", "1");
    }
    else {
        store.setServerProperty ("capture.deletetofreespace", "0");
    }
    store.setServerProperty ("capture.autoselectmethod", urlData.getParameter ("AutoSelectType").trim ());
    String include = urlData.getParameter ("IncludeThisCapture");
    if ("true".equalsIgnoreCase (include)) {
        store.setServerProperty ("capture.includecalculatedusage", "1");
    }
    else {
        store.setServerProperty ("capture.includecalculatedusage", "0");
    }
    int avgData = 7000000;
    try {
        avgData = Integer.parseInt (urlData.getParameter ("AverageDataRate").trim ());
    } catch (Exception e) {
    }
    store.setServerProperty ("capture.averagedatarate", new Integer (avgData).toString ());
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/SystemDataRes?action=27\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=124=-----==

public Viewer () {
    UIManager.put ("FileChooser.readOnly", Boolean.TRUE);
    resourceBundle = ResourceBundle.getBundle ("becta.viewer.framework.resources");
    JPopupMenu.setDefaultLightWeightPopupEnabled (false);
    ThemeManager.addThemeChangeListener (this);
    JFrame mainFrame = new JFrame ();
    Insets screenInsets = java.awt.Toolkit.getDefaultToolkit ().getScreenInsets (mainFrame.getGraphicsConfiguration ());
    Rectangle screenSize = mainFrame.getGraphicsConfiguration ().getBounds ();
    final Rectangle maxBounds = new Rectangle (screenInsets.left + screenSize.x, screenInsets.top + screenSize.y, screenSize.x + screenSize.width - screenInsets.right - screenInsets.left, screenSize.y + screenSize.height - screenInsets.bottom - screenInsets.top);
    mainFrame.setMaximizedBounds (maxBounds);
    mainFrame.setUndecorated (true);
    mainFrame.setTitle (resourceBundle.getString ("mainFrame.Title"));
    try {
        BufferedImage icon = ImageIO.read (Viewer.class.getResource ("resources/application_icon.png"));
        mainFrame.setIconImage (icon);
    } catch (Exception e) {
        Viewer.logException (e);
    }
    mainFrame.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE);
    mainFrame.addWindowListener (new WindowAdapter () {
        @Override
        public void windowClosing (WindowEvent evt) {
            try {
                for (becta.viewer.framework.Frame frame : getFrames ()) {
                    frame.close ();
                }
                exit ();
            } catch (Exception e) {
                Viewer.logException (e);
            }
        }@Override
        public void windowActivated (WindowEvent e) {
            if (Platform.isLinux && parentContainer.getHeight () < (maxBounds.getHeight () / 2)) {
                parentContainer.setSize (maxBounds.getSize ());
            }
        }
    }
    );
    parentContainer = mainFrame;
    menubar = new Menubar ();
    toolbar = new Toolbar ();
    Canvas.addSelectionModeListener (toolbar);
    desktop = new JPanel ();
    desktop.setLayout (new BorderLayout ());
    desktop.setBackground (AccessibilityColor.window);
    parentContainer.setJMenuBar (menubar);
    JPanel dummy = new JPanel ();
    dummy.setPreferredSize (new Dimension (0, 0));
    parentContainer.add (dummy, BorderLayout.NORTH);
    parentContainer.add (desktop, BorderLayout.CENTER);
    parentContainer.add (toolbar, BorderLayout.SOUTH);
    mainFrame.pack ();
    mainFrame.setExtendedState (JFrame.MAXIMIZED_BOTH);
    this.addFileChangeListener (menubar);
    this.addFileChangeListener (toolbar);
    addStateChangeListener (menubar);
    addStateChangeListener (toolbar);
}


private byte [] deleteFile (HTTPurl urlData) throws Exception {
    File thisFile = new File (urlData.getParameter ("file"));
    String requestedFilePath = thisFile.getCanonicalPath ();
    boolean inBounds = false;
    String [] paths = store.getCapturePaths ();
    for (int x = 0; x < paths.length; x ++) {
        String rootFilePath = new File (paths [x]).getCanonicalPath ();
        if (requestedFilePath.indexOf (rootFilePath) == 0) {
            inBounds = true;
            break;
        }
    }
    if (inBounds == false) {
        throw new Exception ("File out of bounds!");
    }
    if (thisFile != null && thisFile.exists ()) {
        System.out.println ("Deleting File : " + thisFile.getName ());
        thisFile.delete ();
    }
    String start = urlData.getParameter ("start");
    if (start == null) start = "0";
    start = start.trim ();
    StringBuffer out = new StringBuffer (256);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: /servlet/" + urlData.getServletClass () + "?path=" + URLEncoder.encode (thisFile.getParent (), "UTF-8") + "&start=" + start + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=125=-----==

public FileHandle getFileHandle (long fileNum) throws FileNotFoundException, ChecksumException, DatabaseException {
    Long fileId = Long.valueOf (fileNum);
    FileHandle fileHandle = null;
    try {
        while (true) {
            fileHandle = fileCache.get (fileId);
            boolean newHandle = false;
            if (fileHandle == null) {
                if (EnvironmentImpl.getFairLatches ()) {
                    fileCacheLatch.acquire ();
                    try {
                        fileHandle = fileCache.get (fileId);
                        if (fileHandle == null) {
                            newHandle = true;
                            fileHandle = addFileHandle (fileId);
                        }
                    } finally {
                        fileCacheLatch.release ();
                    }
                }
                else {
                    synchronized (fileCacheLatch) {
                        fileHandle = fileCache.get (fileId);
                        if (fileHandle == null) {
                            newHandle = true;
                            fileHandle = addFileHandle (fileId);
                        }
                    }
                }
            }
            if (newHandle) {
                boolean success = false;
                try {
                    openFileHandle (fileHandle, FileMode.READ_MODE);
                    success = true;
                } finally {
                    if (! success) {
                        fileHandle.release ();
                        clearFileCache (fileNum);
                    }
                }
            }
            else {
                fileHandle.latch ();
            }
            if (fileHandle.getFile () == null) {
                fileHandle.release ();
            }
            else {
                break;
            }
        }
    } catch (FileNotFoundException e) {
        throw e;
    } catch (IOException e) {
        throw new EnvironmentFailureException (envImpl, EnvironmentFailureReason.LOG_READ, e);
    }
    return fileHandle;
}


private boolean jarBuildDirectory (File dir, JarBuilder jarFile) throws IOException {
    LOG.log ("jarBuildDirectory(" + dir + " , " + jarFile + ")");
    java.io.FileFilter classFilter = new java.io.FileFilter () {
        public boolean accept (File f) {
            return f.isDirectory () || f.getName ().endsWith (".class");
        }
    }
    ;
    File [] files = dir.listFiles (classFilter);
    LOG.log ("\tfiles = " + files);
    if (files != null) {
        for (int i = 0; i < files.length; i ++) {
            LOG.log ("\t\tfiles[" + i + "] = " + files [i]);
            if (files [i] == null || ! files [i].exists ()) continue;
            try {
                if (files [i].isDirectory ()) {
                    LOG.log ("jarFile.addDirectoryRecursive(" + files [i] + ")");
                    jarFile.addDirectoryRecursive (files [i], files [i].getName (), classFilter);
                }
                else {
                    LOG.log ("jarFile.addFile(" + files [i] + ")");
                    jarFile.addFile (files [i], "", files [i].getName ());
                }
            } catch (IOException ioe) {
                _exceptions.add (ioe.getMessage ());
            }
        }
    }
    return true;
}


-----Function Pair=126=-----==

protected final boolean isDirEmpty (String path) {
    if (path == null) {
        return true;
    }
    File directory = new File (path);
    if (directory.isDirectory ()) {
        String [] list = directory.list ();
        if ((list == null) || (list.length == 0)) {
            list = null;
            directory = null;
            return true;
        }
        list = null;
    }
    directory = null;
    return false;
}


public void writeActivityLog () {
    if (activity == null) {
        return;
    }
    String fileName = Library.libraryDirectory + "ActivityLog";
    try {
        PrintWriter outFile = new PrintWriter (new BufferedWriter (new FileWriter (fileName, true)));
        outFile.println (activity.log.getText ());
        outFile.flush ();
        outFile.close ();
        System.out.println ("Wrote: " + fileName);
    } catch (IOException e) {
        System.out.println ("Activity Log write to disk failed:\n" + e + "\n\n");
    }
}


-----Function Pair=127=-----==

private void addDirectory (String path, String root) {
    File dir = new File (path);
    for (File file : dir.listFiles ()) {
        if (file.isDirectory ()) {
            addDirectory (file.getPath (), root);
        }
        else {
            String separator = File.separator;
            String relativePath = file.getPath ().replace (root, "");
            int separatorCount = relativePath.length () - relativePath.replace (separator, "").length ();
            String [] pathArray = new String [separatorCount + 1];
            for (int i = 0; i < separatorCount; i ++) {
                pathArray [i] = relativePath.substring (0, relativePath.indexOf (separator));
                relativePath = relativePath.substring (relativePath.indexOf (separator) + 1);
            }
            pathArray [separatorCount] = relativePath;
            files.add (pathArray, file.getPath ());
        }
    }
}


protected void runOndexMini (File workflowFile, String...workflowArguments) {
    File jarFile = new File (new File (ominiDir, "lib"), "ondex-mini-0.4.0-SNAPSHOT.jar");
    File dataDir = new File (ominiDir, "data");
    try {
        String relativeWorkflowPath = getRelativePath (ominiDir, workflowFile);
        List < String > execArgList = new ArrayList < String > (Arrays.asList (new String [] {"java", "-Xmx1G", "-D" + dataDir.getPath (), "-jar", jarFile.getCanonicalPath (), "-ubla", "-ptest", "-w" + relativeWorkflowPath}));
        for (String warg : workflowArguments) {
            execArgList.add ("-P" + warg);
        }
        String [] execArgs = execArgList.toArray (new String [execArgList.size ()]);
        System.out.println ("Executing: " + execArgs);
        Process process = Runtime.getRuntime ().exec (execArgs, null, ominiDir);
        BufferedReader errorReader = new BufferedReader (new InputStreamReader (process.getErrorStream ()));
        BufferedReader outReader = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        boolean moreOut = true;
        boolean moreErrors = true;
        while (moreErrors && moreOut) {
            String line;
            if (moreErrors) {
                if ((line = errorReader.readLine ()) == null) {
                    moreErrors = false;
                }
                else {
                    System.err.println (line);
                }
            }
            if (moreOut) {
                if ((line = outReader.readLine ()) == null) {
                    moreOut = false;
                }
                else {
                    System.out.println (line);
                }
            }
        }
        process.waitFor ();
        errorReader.close ();
        outReader.close ();
        process.getOutputStream ().close ();
        System.out.println ("Process terminated with exit value " + process.exitValue ());
        assert (process.exitValue () == 0);
    } catch (InterruptedException e) {
        throw new RuntimeException (e);
    } catch (IOException e) {
        throw new RuntimeException (e);
    }
}


-----Function Pair=128=-----==

public void doDelete () {
    if (JOptionPane.showConfirmDialog (getFileChooser (), "Are you sure ?", "Confirm", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
        Object source = filePopupMenu.getInvoker ();
        File [] files = getSelectedFiles (source);
        if (source == getFileTable ()) {
            for (File file : files) {
                delete (file);
                if (file.isDirectory ()) {
                    DirectoryTreeNode node = getDirectoryTreeNode (file);
                    node.removeFromParent ();
                }
            }
            rescanCurrentDirectory (getFileChooser ());
        }
        else {
            delete (currentNode.getFile ());
            DirectoryTreeNode parent = (DirectoryTreeNode) currentNode.getParent ();
            currentNode.removeFromParent ();
            currentNode = parent;
            rescanCurrentDirectory (getFileChooser ());
            getFileChooser ().setCurrentDirectory (currentNode.getFile ());
        }
    }
}


public static boolean saveBuffer (ByteBuffer buffer, File file, boolean forceFilesystemWrite) throws IOException {
    if (buffer == null) {
        String message = Logging.getMessage ("nullValue.BufferNull");
        Logging.logger ().severe (message);
        throw new IllegalArgumentException (message);
    }
    if (file == null) {
        String message = Logging.getMessage ("nullValue.FileIsNull");
        Logging.logger ().severe (message);
        throw new IllegalArgumentException (message);
    }
    FileOutputStream fos = null;
    FileChannel channel = null;
    FileLock lock;
    int numBytesWritten = 0;
    try {
        fos = new FileOutputStream (file);
        channel = fos.getChannel ();
        lock = channel.tryLock ();
        if (lock == null) {
            Logging.logger ().log (Level.FINER, "WWIO.UnableToAcquireLockFor", file.getPath ());
            return false;
        }
        for (buffer.rewind (); buffer.hasRemaining ();) {
            numBytesWritten += channel.write (buffer);
        }
        if (forceFilesystemWrite) channel.force (true);
        fos.flush ();
        return true;
    } catch (ClosedByInterruptException e) {
        Logging.logger ().log (Level.FINE, Logging.getMessage ("generic.interrupted", "WWIO.saveBuffer", file.getPath ()), e);
        if (numBytesWritten > 0) file.delete ();
        throw e;
    } catch (IOException e) {
        Logging.logger ().log (Level.SEVERE, Logging.getMessage ("WWIO.ErrorSavingBufferTo", file.getPath ()), e);
        if (numBytesWritten > 0) file.delete ();
        throw e;
    } finally {
        WWIO.closeStream (channel, file.getPath ());
        WWIO.closeStream (fos, file.getPath ());
    }
}


-----Function Pair=129=-----==

public void testConcurrency () throws Exception {
    int nThreads = 15;
    ExecutorService es = Executors.newFixedThreadPool (nThreads);
    Work work = new Work (getSessions ());
    ReverseWork reverseWork = new ReverseWork (getSessions ());
    long start = System.nanoTime ();
    int iteration = 100;
    for (int i = 0; i < iteration; i ++) {
        es.execute (work);
        es.execute (reverseWork);
    }
    es.shutdown ();
    es.awaitTermination (100, TimeUnit.MINUTES);
    getSessions ().close ();
    Assert.assertTrue ("Something was wrong in the concurrent threads, please check logs for stacktraces", allFine.get ());
    System.out.println (iteration + " iterations (8 tx per iteration) in " + nThreads + " threads: " + TimeUnit.NANOSECONDS.toMillis (System.nanoTime () - start));
}


static void preRegister (Context c, final Set < String > keys) {
    if (keys != null) {
        c.put (JavacMessages.messagesKey, new Context.Factory < JavacMessages > () {
            public JavacMessages make (Context c) {
                return new MessageTracker (c) {
                    @Override
                    public String getLocalizedString (Locale l, String key, Object...args) {
                        keys.add (key);
                        return super.getLocalizedString (l, key, args);
                    }
                }
                ;
            }
        }
        );
    }
}


-----Function Pair=130=-----==

private void informListeners (List listeners, int action, Object param, AbstractUIProgressHandler handler) {
    Iterator iter = listeners.iterator ();
    UninstallerListener il = null;
    while (iter.hasNext ()) {
        try {
            il = (UninstallerListener) iter.next ();
            switch (action) {
                case UninstallerListener.BEFORE_DELETION :
                    il.beforeDeletion ((List) param, handler);
                    break;
                case UninstallerListener.AFTER_DELETION :
                    il.afterDeletion ((List) param, handler);
                    break;
                case UninstallerListener.BEFORE_DELETE :
                    il.beforeDelete ((File) param, handler);
                    break;
                case UninstallerListener.AFTER_DELETE :
                    il.afterDelete ((File) param, handler);
                    break;
            }
        } catch (Throwable e) {
            handler.emitError ("Skipping custom action because exception caught during " + il.getClass ().getName (), e.toString ());
        }
    }
}


private byte [] moveTunerUp (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex > 0 && tunerIndex < devList.getDeviceCount ()) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex - 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=131=-----==

protected DataSearcher [] getTypeByRatings (String type, Normalizer [] norm, String [] ratings, boolean optional) {
    DataSearcher [] data = new DataSearcher [ratings.length];
    for (int i = 0; i < ratings.length; i ++) {
        data [i] = (DataSearcher) master.clone ();
        if (norm != null && norm [i] != null) data [i].setNormalizer (norm [i]);
        ArrayList < String > params = new ArrayList < String > ();
        params.add (ratings [i]);
        params.add (checkURI (type));
        String tripQuery = queryFinder.getQuery ("GetListOfTypedEntities", 2, params);
        if (optional) {
            tripQuery = queryFinder.getQuery ("GetListOfTypedEntitiesOptional", 1, params);
        }
        data [i].initSearch (tripQuery);
        if (data [i] instanceof SesameSearcher) ((SesameSearcher) data [i]).sort (2);
    }
    return data;
}


protected Expression getExpressionForClass (final Class clazz, final String sId) throws IllegalArgumentException {
    Constructor constr = EXPR_CONSTRUCTORCACHE.get (clazz);
    try {
        if (constr != null) {
            Object [] obj = {new IRI (sId)};
            return (Expression) constr.newInstance (obj);
        }
        else {
            Class [] params = {Id.class};
            constr = clazz.getConstructor (params);
            if (constr != null) {
                EXPR_CONSTRUCTORCACHE.put (clazz, constr);
                return getExpressionForClass (clazz, sId);
            }
            else {
                throw new IllegalArgumentException ("Can't find a Constructor for the class: " + clazz.getName ());
            }
        }
    } catch (InstantiationException e) {
        throw new IllegalArgumentException (e);
    } catch (IllegalAccessException e) {
        throw new IllegalArgumentException (e);
    } catch (InvocationTargetException e) {
        throw new IllegalArgumentException (e);
    } catch (SecurityException e) {
        throw new IllegalArgumentException (e);
    } catch (NoSuchMethodException e) {
        throw new IllegalArgumentException (e);
    }
}


-----Function Pair=132=-----==

public static void main (String [] args) {
    if (args.length == 0) {
        System.err.println ("Syntax: BehavioralLauncher <appclass> [plus args]");
        System.exit (1);
    }
    SimulationThread behClkThread = null;
    DVApplication app = null;
    try {
        Class appCls = null;
        try {
            appCls = Class.forName (args [0]);
        } catch (UnsupportedClassVersionError unsupportedClassVersionError) {
            System.err.println ("Could not load class" + args [0]);
            throw unsupportedClassVersionError;
        }
        assert (DVApplication.class.isAssignableFrom (appCls));
        final BehavioralSimulation sim = new BehavioralSimulation (Arrays.asList (args));
        final PRNGFactory rngFactory = PRNGFactoryFactory.getDefaultFactory ();
        final SimulationManager simManager = new SimulationManager ("BehavioralSimulation", rngFactory, rngFactory.newInstance (0));
        final OVAEngine ovaEngine = null;
        final DVSimulation dvSim = new DVSimulation (sim, simManager, ovaEngine);
        final String clockName = "DefaultClock";
        sim.createRegister (clockName, 1);
        behClkThread = dvSim.fork (clockName, new BehavioralClockGenerator (dvSim, clockName, 100));
        final Constructor < ? > appCtor = appCls.getConstructor (DVSimulation.class);
        app = (DVApplication) appCtor.newInstance (dvSim);
        app.start ();
        sim.run ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (behClkThread != null) {
            behClkThread.terminate ();
        }
        if (app != null) {
            app.finish ();
        }
    }
}


private void setupType (Collection < TolkCustomClassInterface > instanceCollection, JPanel comboboxPanel, String type) {
    boolean firstOne = true;
    for (TolkCustomClassInterface customClass : instanceCollection) {
        String className = customClass.getClass ().getName ();
        className = className.substring (className.lastIndexOf (Constants.DOT) + 1);
        JComboBox comboBox = null;
        if (firstOne) {
            comboBox = (JComboBox) comboboxPanel.getComponent (0);
            firstOne = false;
        }
        else {
            comboBox = getNewComboBox (type);
            comboboxPanel.add (comboBox);
            if (type.equals (Constants.INPUT)) {
                this.noInputs ++;
            }
            else if (type.equals (Constants.OUTPUT)) {
                this.noOutputs ++;
            }
            else if (type.equals (Constants.DATA_ENGINE)) {
                this.noDataEngines ++;
            }
        }
        for (int i = 0; i < comboBox.getItemCount (); i ++) {
            String item = (String) comboBox.getItemAt (i);
            if (item.startsWith (className)) {
                item = className + " " + customClass.getCurrentParms ();
                comboBox.addItem (item);
                comboBox.setSelectedItem (item);
                break;
            }
        }
    }
    if (type.equals (Constants.INPUT)) {
        comboboxPanel.setLayout (new GridLayout (this.noInputs, 1));
    }
    else if (type.equals (Constants.OUTPUT)) {
        comboboxPanel.setLayout (new GridLayout (this.noOutputs, 1));
    }
    else if (type.equals (Constants.DATA_ENGINE)) {
        comboboxPanel.setLayout (new GridLayout (this.noDataEngines, 1));
    }
    comboboxPanel.repaint ();
}


-----Function Pair=133=-----==

public synchronized void resetAllUsageParameters (SbbID sbbId) throws NullPointerException, UnrecognizedSbbException, InvalidArgumentException, ManagementException {
    if (logger.isDebugEnabled ()) {
        logger.debug ("resetAllUsageParameters: " + sbbId);
    }
    if (sbbId == null) throw new NullPointerException ("Sbb ID is null!");
    SbbComponent sbbComponent = sleeContainer.getComponentRepository ().getComponentByID (sbbId);
    if (sbbComponent == null) {
        throw new UnrecognizedSbbException (sbbId.toString ());
    }
    else {
        if (sbbComponent.getUsageParametersInterface () == null) {
            throw new InvalidArgumentException ("no usage parameter interface for " + sbbId);
        }
    }
    ServiceComponent serviceComponent = sleeContainer.getComponentRepository ().getComponentByID (getService ());
    if (! serviceComponent.getSbbIDs (sleeContainer.getComponentRepository ()).contains (sbbId)) {
        throw new UnrecognizedSbbException (sbbId.toString () + " is not part of " + getService ());
    }
    for (UsageMBeanImpl usageMBeanImpl : usageMBeans.values ()) {
        SbbNotification sbbNotification = (SbbNotification) usageMBeanImpl.getNotificationSource ();
        if (sbbNotification.getSbb ().equals (sbbId)) {
            usageMBeanImpl.resetAllUsageParameters ();
        }
    }
}


public String getIp () {
    String ip = "";
    try {
        Enumeration e = NetworkInterface.getNetworkInterfaces ();
        while (e.hasMoreElements ()) {
            NetworkInterface eth = (NetworkInterface) e.nextElement ();
            if (! eth.isLoopback ()) {
                Enumeration addresses = eth.getInetAddresses ();
                while (addresses.hasMoreElements ()) {
                    InetAddress a = (InetAddress) addresses.nextElement ();
                    if (a instanceof Inet4Address) {
                        ip += a.getHostAddress () + " ";
                    }
                }
            }
        }
    } catch (Exception e) {
    }
    return ip;
}


-----Function Pair=134=-----==

public static ClassLoader createClassLoader () {
    ClassLoader cl = null;
    try {
        Field field = null;
        Class cl_class = PermGenCleanerUtil.getCurrentClassLoader ().getClass ();
        while (field == null && cl_class != null) {
            try {
                field = cl_class.getDeclaredField ("ucp");
            } catch (NoSuchFieldException e1) {
                cl_class = cl_class.getSuperclass ();
            }
        }
        if (field == null) {
            throw new PermGenCleanerException ("Could not find member variable ucp in ClassLoader!");
        }
        field.setAccessible (true);
        URLClassPath ucp = (URLClassPath) field.get (PermGenCleanerUtil.getCurrentClassLoader ());
        cl = new URLClassLoader (ucp.getURLs (), null);
        field = null;
        cl_class = null;
        ucp = null;
    } catch (SecurityException e) {
        throw new PermGenCleanerException (e);
    } catch (IllegalArgumentException e) {
        throw new PermGenCleanerException (e);
    } catch (IllegalAccessException e) {
        throw new PermGenCleanerException (e);
    }
    return cl;
}


public void checkPathForArchiveStatus (String handlerPath) throws DuplicateArchiveException {
    for (Iterator iter = _archiveHandlers.iterator (); iter.hasNext ();) {
        ArchiveHandler ah = (ArchiveHandler) iter.next ();
        String ahPath = ah.getArchiveType ().getDirectory ().getPath ();
        if (ahPath.length () > handlerPath.length ()) {
            if (ahPath.startsWith (handlerPath)) {
                throw new DuplicateArchiveException (ahPath + " is already being archived");
            }
        }
        else {
            if (handlerPath.startsWith (ahPath)) {
                throw new DuplicateArchiveException (handlerPath + " is already being archived");
            }
        }
    }
}


-----Function Pair=135=-----==

public FtpReply canLogin (BaseFtpConnection baseconn, User user) {
    int count = getConfig ().getMaxUsersTotal ();
    if (user.isExempt ()) count = Math.max (count, count + getConfig ().getMaxUsersExempt ());
    int userCount = 0;
    int ipCount = 0;
    if (_conns.size () > count) return new FtpReply (550, "The site is full, try again later.");
    synchronized (_conns) {
        for (Iterator iter = _conns.iterator (); iter.hasNext ();) {
            BaseFtpConnection tempConnection = (BaseFtpConnection) iter.next ();
            try {
                User tempUser = tempConnection.getUser ();
                if (tempUser.getUsername ().equals (user.getUsername ())) {
                    userCount ++;
                    if (tempConnection.getClientAddress ().equals (baseconn.getClientAddress ())) {
                        ipCount ++;
                    }
                }
            } catch (NoSuchUserException ex) {
            }
        }
    }
    if (user.getMaxLoginsPerIP () > 0 && ipCount > user.getMaxLoginsPerIP ()) return new FtpReply (530, "Sorry, your maximum number of connections from this IP (" + user.getMaxLoginsPerIP () + ") has been reached.");
    if (user.getMaxLogins () > 0 && userCount > user.getMaxLogins ()) return new FtpReply (530, "Sorry, your account is restricted to " + user.getMaxLogins () + " simultaneous logins.");
    if (! baseconn.isSecure () && getConfig ().checkUserRejectInsecure (user)) {
        return new FtpReply (530, "USE SECURE CONNECTION");
    }
    else if (baseconn.isSecure () && getConfig ().checkUserRejectSecure (user)) {
        return new FtpReply (530, "USE INSECURE CONNECTION");
    }
    return null;
}


static void runTestOnArray (Object [] obj) throws java.lang.Exception {
    for (int i = 0; i < cs.length; i ++) {
        System.out.print (obj [i].getClass ().getName () + ": ");
        ByteArrayOutputStream bo1 = null, bo2 = null;
        try {
            SMPPPacket pak = (SMPPPacket) obj [i];
            if (pak == null) continue;
            bo1 = new ByteArrayOutputStream ();
            bo2 = new ByteArrayOutputStream ();
            pak.writeTo (bo1);
            SMPPPacket.readPacket (new ByteArrayInputStream (bo1.toByteArray ())).writeTo (bo2);
            int ret = checkSize (pak);
            if (ret == 0) {
                System.out.print ("pass.");
            }
            else {
                System.out.print ("FAILED (" + ret + ")");
                switch (ret) {
                    case 1 :
                        System.out.print ("\n    getCommandLen() = " + pak.getCommandLen ());
                        System.out.print ("\n    bytes: " + TestUtils.showBytes (bo1.toByteArray ()));
                        break;
                    case 2 :
                        System.out.print ("\n    getCommandLen() = " + pak.getCommandLen ());
                        System.out.print ("\n    bytes 1: " + TestUtils.showBytes (bo1.toByteArray ()) + "\n    bytes 2: " + TestUtils.showBytes (bo2.toByteArray ()));
                        break;
                }
            }
        } catch (Exception x) {
            System.out.print ("FAILED..exception." + "\n    bytes1: " + TestUtils.showBytes (bo1.toByteArray ()) + "\n    bytes2: " + TestUtils.showBytes (bo1.toByteArray ()) + "\n");
            x.printStackTrace ();
        }
        System.out.print ("\n");
    }
}


-----Function Pair=136=-----=1=

public static Object silentlyCreate (String className, Object [] constructorArgs) {
    try {
        Class clazz = Class.forName (className);
        Constructor [] constructors = clazz.getConstructors ();
        for (int i = 0; i < constructors.length; i ++) {
            if (constructors [i].getParameterTypes ().length == constructorArgs.length) {
                return constructors [i].newInstance (constructorArgs);
            }
        }
    } catch (Exception e) {
        if (logger != null) {
            logger.error ("Failed to create a " + className + " instance", e);
        }
        else {
            console.error ("Failed to create a " + className + " instance", e);
        }
    }
    return null;
}


public static ConfidenceInterval readFromXML (Element e) {
    if (e == null) return null;
    String type = e.getAttribute ("type");
    if (! XMLUtils.hasValue (type)) return null;
    Class c = null;
    try {
        c = Class.forName (PACKAGE + type);
    } catch (ClassNotFoundException cnfe) {
    }
    if (c == null) try {
        c = Class.forName (type);
    } catch (ClassNotFoundException cnfe) {
        return null;
    }
    try {
        Class [] paramTypes = new Class [] {Element.class};
        Constructor cnstr = c.getConstructor (paramTypes);
        return (ConfidenceInterval) cnstr.newInstance (new Object [] {e});
    } catch (Exception ex) {
        return null;
    }
}


-----Function Pair=137=-----==

public void actionPerformed (ActionEvent e) {
    final Stack activeVolume = getCurrentView ().getVolume ();
    disableMenus ();
    Thread r = new Thread () {
        public void run () {
            byte ff = (byte) 0xff;
            int count = 0;
            for (int z = 0; z < activeVolume.getDepth (); z ++) {
                if (isStopped) return;
                setProgress (z);
                short [] slice = activeVolume.getSlice (z);
                for (int i = 0; i < slice.length; i ++) {
                    if (slice [i] != 0 && slice [i] != ff) {
                        count ++;
                        slice [i] = 0;
                    }
                }
            }
            activeVolume.flush ();
            StringBuffer output = new StringBuffer ();
            output.append ("Removed " + count + " voxels \n");
            showResults (output, "Voxelcount");
            enableMenus ();
            updateImage ();
        }
    }
    ;
    r.start ();
}


public static Statistic getInstance (String name) {
    Statistic statistic = null;
    Constructor < ? > ctor = null;
    String fullyQualifiedClassName = "oldmcdata.analyzers.utils." + name;
    try {
        Class < ? > c = Class.forName (fullyQualifiedClassName);
        ctor = c.getConstructor ((Class []) null);
        statistic = (Statistic) ctor.newInstance ((Object []) null);
    } catch (ClassNotFoundException cfne) {
        handleException (cfne, "Class: " + fullyQualifiedClassName + " Does Not Exist, or not on CLASSPATH");
    } catch (NoSuchMethodException nsme) {
        handleException (nsme, "Class: " + fullyQualifiedClassName + " has no constructor with 0 arguments");
    } catch (InvocationTargetException ite) {
        handleException (ite, "Can not construct instance of Class: " + fullyQualifiedClassName);
    } catch (IllegalAccessException iae) {
        handleException (iae, "Can not access: " + fullyQualifiedClassName + " - not public");
    } catch (InstantiationException ie) {
        handleException (ie, "Class: " + fullyQualifiedClassName + " can not be constructed as it is an interface or abstract class");
    }
    return statistic;
}


-----Function Pair=138=-----==

public T newInstance (BeanDesc < T > beanDesc, Object [] args) {
    Class < ? > originalClass = beanDesc.getComponentClass ();
    Object thisInstance;
    if (originalClass.isInterface ()) {
        thisInstance = Proxy.newProxyInstance (ClassLoaderUtil.getClassLoader (originalClass), new Class [] {originalClass}, noOpInvocationHandler);
    }
    else {
        ConstructorDesc < T > cd = beanDesc.getConstructorDesc ();
        Constructor < T > c = cd.getSuitableConstructor (args);
        if (c == null) {
            throw new ConstructorNotFoundRuntimeException (beanDesc.getConcreteClass ().getName ());
        }
        thisInstance = ConstructorUtil.newInstance (c, args);
    }
    Class < ? > proxyClass = beanDesc.getEnhancedComponentClass ();
    ProxyInvocationHandler proxyHandler = new ProxyInvocationHandler (proxyInterceptorMap, thisInstance);
    Constructor < ? > proxyConstructor = ConstructorUtil.getConstructor (proxyClass, new Class [] {InvocationHandler.class});
    return (T) ConstructorUtil.newInstance (proxyConstructor, new Object [] {proxyHandler});
}


protected static IBpelAdmin createRemoteDebugImpl (Map aMap) throws SdlException {
    logger.debug ("createRemoteDebugImpl(Map)");
    try {
        Class c;
        String debugClassName;
        String eventLocatorClass;
        String bpLocatorClass;
        String defaultRDebugClass = ServiceRemoteDebugImpl.class.getName ();
        String defaultEventLocatorClass = "org.dbe.composer.wfengine.bpel.webserver.rdebug.client.ServiceEventHandlerLocator";
        String defaultBpLocatorClass = "org.dbe.composer.wfengine.bpel.webserver.rdebug.client.ServiceBreakpointHandlerLocator";
        if (aMap == null || aMap.isEmpty ()) {
            debugClassName = defaultRDebugClass;
            eventLocatorClass = defaultEventLocatorClass;
            bpLocatorClass = defaultBpLocatorClass;
        }
        else {
            debugClassName = (String) aMap.get (ISdlEngineConfiguration.REMOTE_DEBUG_IMPL_ENTRY);
            if (SdlUtil.isNullOrEmpty (debugClassName)) {
                debugClassName = defaultRDebugClass;
            }
            eventLocatorClass = (String) aMap.get (ISdlEngineConfiguration.EVENT_HANDLER_LOCATOR_ENTRY);
            if (SdlUtil.isNullOrEmpty (eventLocatorClass)) {
                eventLocatorClass = defaultEventLocatorClass;
            }
            bpLocatorClass = (String) aMap.get (ISdlEngineConfiguration.BREAKPOINT_HANDLER_LOCATOR_ENTRY);
            if (SdlUtil.isNullOrEmpty (bpLocatorClass)) {
                bpLocatorClass = defaultBpLocatorClass;
            }
        }
        c = Class.forName (debugClassName);
        Constructor constructor = c.getConstructor (new Class [] {String.class, String.class});
        return (IBpelAdmin) constructor.newInstance (new Object [] {eventLocatorClass, bpLocatorClass});
    } catch (Exception e) {
        logger.error ("Error: " + e);
        throw new SdlException ("Error creating remote debug engine implementation.", e);
    }
}


-----Function Pair=139=-----==

public void run () {
    byte ff = (byte) 0xff;
    int count = 0;
    for (int z = 0; z < activeVolume.getDepth (); z ++) {
        setProgress (z);
        short [] slice = activeVolume.getSlice (z);
        for (int i = 0; i < slice.length; i ++) {
            if (slice [i] != 0 && slice [i] != ff) {
                count ++;
                slice [i] = 0;
            }
        }
    }
    activeVolume.flush ();
    StringBuffer output = new StringBuffer ();
    output.append ("Reset " + count + " voxels \n");
    showResults (output, "Voxelcount");
    enableMenus ();
    updateImage ();
}


private void readPasswordParameters () {
    String encPasswordParam = readParameter ("ENCPASSWORD", false);
    if (encPasswordParam == null) {
        passwordParam = readParameter ("PASSWORD", false);
    }
    else {
        byte [] pw = {0, 0, 0, 0, 0, 0, 0, 0};
        int len = encPasswordParam.length () / 2;
        if (len > 8) len = 8;
        for (int i = 0; i < len; i ++) {
            String hex = encPasswordParam.substring (i * 2, i * 2 + 2);
            Integer x = new Integer (Integer.parseInt (hex, 16));
            pw [i] = x.byteValue ();
        }
        byte [] key = {23, 82, 107, 6, 35, 78, 88, 7};
        DesCipher des = new DesCipher (key);
        des.decrypt (pw, 0, pw, 0);
        passwordParam = new String (pw);
    }
}


-----Function Pair=140=-----==

private static Object locateBrowser () {
    if (browser != null) {
        return browser;
    }
    switch (jvm) {
        case MRJ_2_0 :
            try {
                Integer finderCreatorCode = (Integer) makeOSType.invoke (null, new Object [] {FINDER_CREATOR});
                Object aeTarget = aeTargetConstructor.newInstance (new Object [] {finderCreatorCode});
                Integer gurlType = (Integer) makeOSType.invoke (null, new Object [] {GURL_EVENT});
                Object appleEvent = appleEventConstructor.newInstance (new Object [] {gurlType, gurlType, aeTarget, kAutoGenerateReturnID, kAnyTransactionID});
                return appleEvent;
            } catch (IllegalAccessException iae) {
                browser = null;
                errorMessage = iae.getMessage ();
                return browser;
            } catch (InstantiationException ie) {
                browser = null;
                errorMessage = ie.getMessage ();
                return browser;
            } catch (InvocationTargetException ite) {
                browser = null;
                errorMessage = ite.getMessage ();
                return browser;
            }
        case MRJ_2_1 :
            File systemFolder;
            try {
                systemFolder = (File) findFolder.invoke (null, new Object [] {kSystemFolderType});
            } catch (IllegalArgumentException iare) {
                browser = null;
                errorMessage = iare.getMessage ();
                return browser;
            } catch (IllegalAccessException iae) {
                browser = null;
                errorMessage = iae.getMessage ();
                return browser;
            } catch (InvocationTargetException ite) {
                browser = null;
                errorMessage = ite.getTargetException ().getClass () + ": " + ite.getTargetException ().getMessage ();
                return browser;
            }
            String [] systemFolderFiles = systemFolder.list ();
            for (int i = 0; i < systemFolderFiles.length; i ++) {
                try {
                    File file = new File (systemFolder, systemFolderFiles [i]);
                    if (! file.isFile ()) {
                        continue;
                    }
                    Object fileType = getFileType.invoke (null, new Object [] {file});
                    if (FINDER_TYPE.equals (fileType.toString ())) {
                        Object fileCreator = getFileCreator.invoke (null, new Object [] {file});
                        if (FINDER_CREATOR.equals (fileCreator.toString ())) {
                            browser = file.toString ();
                            return browser;
                        }
                    }
                } catch (IllegalArgumentException iare) {
                    errorMessage = iare.getMessage ();
                    return null;
                } catch (IllegalAccessException iae) {
                    browser = null;
                    errorMessage = iae.getMessage ();
                    return browser;
                } catch (InvocationTargetException ite) {
                    browser = null;
                    errorMessage = ite.getTargetException ().getClass () + ": " + ite.getTargetException ().getMessage ();
                    return browser;
                }
            }
            browser = null;
            break;
        case MRJ_3_0 :
        case MRJ_3_1 :
            browser = "";
            break;
        case WINDOWS_NT :
            browser = "cmd.exe";
            break;
        case WINDOWS_9x :
            browser = "command.com";
            break;
        case OTHER :
        default :
            browser = "netscape";
            break;
    }
    return browser;
}


protected static void checkAttribute (ModuleAttributeInfo att, ComplexType mbean, CrawlerSettings settings, HttpServletRequest request, boolean expert) {
    Object currentAttribute = null;
    try {
        currentAttribute = mbean.getAttribute (settings, att.getName ());
    } catch (Exception e) {
        logger.severe ("Failed getting " + mbean.getAbsoluteName () + " attribute " + att.getName () + ": " + e.getMessage ());
        return;
    }
    if (logger.isLoggable (Level.FINE)) {
        logger.fine ("MBEAN: " + mbean.getAbsoluteName () + " " + att.getName () + " TRANSIENT " + att.isTransient () + " " + att.isExpertSetting () + " " + expert);
    }
    if (att.isTransient () == false && (att.isExpertSetting () == false || expert)) {
        if (currentAttribute instanceof ComplexType) {
            writeNewOrderFile ((ComplexType) currentAttribute, settings, request, expert);
        }
        else {
            String attName = att.getName ();
            String attAbsoluteName = mbean.getAbsoluteName () + "/" + attName;
            boolean override = (request.getParameter (attAbsoluteName + ".override") != null) && (request.getParameter (attAbsoluteName + ".override").equals ("true"));
            if (settings == null || override) {
                if (currentAttribute instanceof ListType) {
                    try {
                        ListType list = (ListType) currentAttribute;
                        Class cls = list.getClass ();
                        Constructor constructor = cls.getConstructor (String.class, String.class);
                        list = (ListType) constructor.newInstance (list.getName (), list.getDescription ());
                        String [] elems = request.getParameterValues (attAbsoluteName);
                        for (int i = 0; elems != null && i < elems.length; i ++) {
                            list.add (elems [i]);
                        }
                        writeAttribute (attName, attAbsoluteName, mbean, settings, list);
                    } catch (Exception e) {
                        e.printStackTrace ();
                        logger.severe ("Setting new list values on " + attAbsoluteName + ": " + e.getMessage ());
                        return;
                    }
                }
                else {
                    writeAttribute (attName, attAbsoluteName, mbean, settings, request.getParameter (attAbsoluteName));
                }
            }
            else if (settings != null && override == false) {
                try {
                    mbean.unsetAttribute (settings, attName);
                } catch (Exception e) {
                    e.printStackTrace ();
                    logger.severe ("Unsetting attribute on " + attAbsoluteName + ": " + e.getMessage ());
                    return;
                }
            }
        }
    }
}


-----Function Pair=141=-----==

protected void invokeTestMethod (Method method, RunNotifier notifier) {
    Description description = methodDescription (method);
    Object test;
    try {
        test = createTest ();
    } catch (InvocationTargetException e) {
        testAborted (notifier, description, e.getCause ());
        return;
    } catch (Exception e) {
        testAborted (notifier, description, e);
        return;
    }
    TestMethod testMethod = wrapMethod (method);
    new MethodRoadie (test, testMethod, notifier, description).run ();
}


public Object invoke (Object proxy, Method method, Object [] args) throws Throwable {
    Object result = null;
    if (method.getDeclaringClass () == java.lang.Object.class) {
        if (method.getName ().equals ("toString")) return super.toString ();
        else if (method.getName ().equals ("hashCode")) return Integer.valueOf (super.hashCode ());
        else if (method.getName ().equals ("equals")) return Boolean.valueOf (super.equals (args [0]));
        else throw new RuntimeException ("huh?");
    }
    System.out.println ("Invoke " + method);
    if (args == null || args.length == 0) {
        System.out.println (" (no args)");
    }
    else {
        for (int i = 0; i < args.length; i ++) System.out.println (" " + i + ": " + args [i]);
    }
    try {
        if (true) result = method.invoke (mObj, args);
        else result = - 1;
        System.out.println ("Success: method " + method.getName () + " res=" + result);
    } catch (InvocationTargetException ite) {
        throw ite.getTargetException ();
    } catch (IllegalAccessException iae) {
        throw new RuntimeException (iae);
    }
    return result;
}


-----Function Pair=142=-----==

static Object invokeMethod (Method method, Object object, Object [] args) throws ReflectError, InvocationTargetException {
    if (args == null) args = new Object [0];
    logInvokeMethod ("Invoking method (entry): ", method, args);
    Object [] tmpArgs = new Object [args.length];
    Class [] types = method.getParameterTypes ();
    try {
        for (int i = 0; i < args.length; i ++) tmpArgs [i] = Types.castObject (args [i], types [i], Types.ASSIGNMENT);
    } catch (UtilEvalError e) {
        throw new InterpreterError ("illegal argument type in method invocation: " + e);
    }
    tmpArgs = Primitive.unwrap (tmpArgs);
    logInvokeMethod ("Invoking method (after massaging values): ", method, tmpArgs);
    try {
        Object returnValue = method.invoke (object, tmpArgs);
        if (returnValue == null) returnValue = Primitive.NULL;
        Class returnType = method.getReturnType ();
        return Primitive.wrap (returnValue, returnType);
    } catch (IllegalAccessException e) {
        throw new ReflectError ("Cannot access method " + StringUtil.methodString (method.getName (), method.getParameterTypes ()) + " in '" + method.getDeclaringClass () + "' :" + e);
    }
}


public static int execR (String cmd) {
    try {
        String binR = u2w (rs_home + "/bin/R");
        if (isWin32) {
            binR += ".exe";
            File fin = File.createTempFile ("rboot", ".R");
            File fout = File.createTempFile ("rboot", ".tmp");
            PrintStream p = new PrintStream (new FileOutputStream (fin));
            p.println (cmd);
            p.close ();
            Process rp = Runtime.getRuntime ().exec (new String [] {binR, "CMD", "BATCH", "--no-restore", "--no-save", "--slave", fin.getAbsolutePath (), fout.getAbsolutePath ()});
            int i = rp.waitFor ();
            if (! fin.delete ()) fin.deleteOnExit ();
            if (! fout.delete ()) fout.deleteOnExit ();
            return i;
        }
        else {
            Process rp = Runtime.getRuntime ().exec (new String [] {"/bin/sh", "-c", "echo \"" + cmd + "\" |" + binR + " --no-restore --no-save --slave >/dev/null 2>&1"});
            return rp.waitFor ();
        }
    } catch (Exception e) {
        lastError = e.toString ();
        return - 1;
    }
}


-----Function Pair=143=-----==

static Object constructObject (Class clas, Object [] args) throws ReflectError, InvocationTargetException {
    if (clas.isInterface ()) throw new ReflectError ("Can't create instance of an interface: " + clas);
    Object obj = null;
    Class [] types = Types.getTypes (args);
    Constructor con = null;
    Constructor [] constructors = Capabilities.haveAccessibility () ? clas.getDeclaredConstructors () : clas.getConstructors ();
    if (Interpreter.DEBUG) Interpreter.debug ("Looking for most specific constructor: " + clas);
    con = findMostSpecificConstructor (types, constructors);
    if (con == null) throw cantFindConstructor (clas, types);
    if (! isPublic (con)) try {
        ReflectManager.RMSetAccessible (con);
    } catch (UtilEvalError e) {
    }
    args = Primitive.unwrap (args);
    try {
        obj = con.newInstance (args);
    } catch (InstantiationException e) {
        throw new ReflectError ("The class " + clas + " is abstract ");
    } catch (IllegalAccessException e) {
        throw new ReflectError ("We don't have permission to create an instance." + "Use setAccessibility(true) to enable access.");
    } catch (IllegalArgumentException e) {
        throw new ReflectError ("The number of arguments was wrong");
    }
    if (obj == null) throw new ReflectError ("Couldn't construct the object");
    return obj;
}


private TreeViewTreeNode getChildTreeNode (Node node) {
    Vector < TreeViewTreeNode > childTreeNodes = new Vector < TreeViewTreeNode > ();
    Object userObject = null;
    String className = null;
    String urlString = null;
    NodeList children = node.getChildNodes ();
    for (int j = 0; j < children.getLength (); j ++) {
        Node child = children.item (j);
        if (child.getNodeType () == Node.ELEMENT_NODE) {
            if ("class".equals (child.getNodeName ())) {
                className = child.getFirstChild ().getNodeValue ();
                Debug.println ("child: " + child.getNodeName () + ": " + className);
            }
            else if ("name".equals (child.getNodeName ())) {
                userObject = child.getFirstChild ().getNodeValue ();
                Debug.println ("child: " + child.getNodeName () + ": " + userObject);
            }
            else if ("url".equals (child.getNodeName ())) {
                urlString = child.getFirstChild ().getNodeValue ();
                Debug.println ("child: " + child.getNodeName () + ": " + urlString);
            }
            else if ("node".equals (child.getNodeName ())) {
                childTreeNodes.add (getChildTreeNode (child));
            }
            else {
                Debug.println ("invalid child: " + child.getNodeName ());
            }
        }
    }
    TreeViewTreeNode treeNode;
    if ("0.0.0".equals (version)) {
        treeNode = newInstance (className, userObject);
    }
    else if ("0.1.0".equals (version)) {
        treeNode = newInstance (className, urlString);
    }
    else {
        throw new IllegalStateException ("unknown version: " + version);
    }
    for (int j = 0; j < childTreeNodes.size (); j ++) {
        treeNode.add (childTreeNodes.elementAt (j));
    }
    return treeNode;
}


-----Function Pair=144=-----==

protected void compileResult (QueryExpression qs, String result) {
    final ScalarExpression [] resultExprs;
    if (result != null) {
        String resultDefinition = result;
        resultExprs = compileExpressionsFromString (resultDefinition);
        ((ResultExpressionsQueryable) candidates).setResultExpressions (resultExprs);
        Class [] resultTypes = new Class [resultExprs.length];
        for (int i = 0; i < resultExprs.length; i ++) {
            if (resultExprs [i] instanceof CollectionExpression) {
                throw new NucleusUserException (resultExprs [i].toStatementText (ScalarExpression.PROJECTION) + " is of type java.util.Collection and cannot be in the result.");
            }
            else if (resultExprs [i] instanceof MapExpression) {
                throw new NucleusUserException (resultExprs [i].toStatementText (ScalarExpression.PROJECTION) + " is of type java.util.Map and cannot be in the result.");
            }
            if (resultExprs [i].getMapping () != null) {
                if (resultExprs [i].getMapping ().getType () != null) {
                    resultTypes [i] = query.resolveClassDeclaration (resultExprs [i].getMapping ().getType ());
                }
                else {
                    resultTypes [i] = resultExprs [i].getMapping ().getJavaType ();
                }
            }
        }
        resultMetaData = new QueryResultsMetaData (resultTypes);
    }
    else {
        resultMetaData = new QueryResultsMetaData (new Class [] {candidateClass});
        resultExprs = null;
    }
    String resultClassName = query.getResultClassName ();
    if (resultClass == null && resultClassName != null) {
        ScalarExpression expr = compileExpressionFromString (resultClassName);
        resultClass = ((ClassExpression) expr).getCls ();
    }
    if (resultClass != null && resultExprs != null) {
        AccessController.doPrivileged (new PrivilegedAction () {
            public Object run () {
                if (QueryUtils.resultClassIsSimple (resultClass.getName ())) {
                    if (resultExprs.length > 1) {
                        throw new NucleusUserException (LOCALISER.msg ("021201", resultClass.getName ()));
                    }
                    Class exprType = resultExprs [0].getMapping ().getJavaType ();
                    boolean typeConsistent = false;
                    if (exprType == resultClass) {
                        typeConsistent = true;
                    }
                    else if (exprType.isPrimitive ()) {
                        Class resultClassPrimitive = ClassUtils.getPrimitiveTypeForType (resultClass);
                        if (resultClassPrimitive == exprType) {
                            typeConsistent = true;
                        }
                    }
                    if (! typeConsistent) {
                        throw new NucleusUserException (LOCALISER.msg ("021202", resultClass.getName (), exprType));
                    }
                }
                else if (QueryUtils.resultClassIsUserType (resultClass.getName ())) {
                    Class [] ctrTypes = new Class [resultExprs.length];
                    for (int i = 0; i < ctrTypes.length; i ++) {
                        ctrTypes [i] = resultExprs [i].getMapping ().getJavaType ();
                    }
                    Constructor ctr = ClassUtils.getConstructorWithArguments (resultClass, ctrTypes);
                    if (ctr == null && ! ClassUtils.hasDefaultConstructor (resultClass)) {
                        throw new NucleusUserException (LOCALISER.msg ("021205", resultClass.getName ()));
                    }
                    else if (ctr == null) {
                        for (int i = 0; i < resultExprs.length; i ++) {
                            String fieldName = resultExprs [i].getAlias ();
                            Class fieldType = resultExprs [i].getMapping ().getJavaType ();
                            if (fieldName == null && resultExprs [i].getMapping ().getMemberMetaData () != null) {
                                fieldName = resultExprs [i].getMapping ().getMemberMetaData ().getName ();
                            }
                            if (fieldName != null) {
                                Class resultFieldType = null;
                                boolean publicField = true;
                                try {
                                    Field fld = resultClass.getDeclaredField (fieldName);
                                    resultFieldType = fld.getType ();
                                    if (! ClassUtils.typesAreCompatible (fieldType, resultFieldType) && ! ClassUtils.typesAreCompatible (resultFieldType, fieldType)) {
                                        throw new NucleusUserException (LOCALISER.msg ("021211", fieldName, fieldType.getName (), resultFieldType.getName ()));
                                    }
                                    if (! Modifier.isPublic (fld.getModifiers ())) {
                                        publicField = false;
                                    }
                                } catch (NoSuchFieldException nsfe) {
                                    publicField = false;
                                }
                                if (! publicField) {
                                    Method setMethod = QueryUtils.getPublicSetMethodForFieldOfResultClass (resultClass, fieldName, resultFieldType);
                                    if (setMethod == null) {
                                        Method putMethod = QueryUtils.getPublicPutMethodForResultClass (resultClass);
                                        if (putMethod == null) {
                                            throw new NucleusUserException (LOCALISER.msg ("021212", resultClass.getName (), fieldName));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return null;
            }
        }
        );
    }
}


public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {
    boolean [] is_null = new boolean [args.length];
    for (int i = 0; i < args.length; i ++) {
        is_null [i] = (args [i] == null);
    }
    Constructor cons = getConstructor (o_clazz, clazzes, is_null);
    boolean access = cons.isAccessible ();
    cons.setAccessible (true);
    Object o;
    try {
        o = cons.newInstance (args);
    } catch (InvocationTargetException e) {
        throw e.getTargetException ();
    } finally {
        cons.setAccessible (access);
    }
    return o;
}


-----Function Pair=145=-----==

public Element lock () {
    state.locked = true;
    if (state.attributes != null) {
        for (Attribute att : state.attributes.values ()) {
            att.lock ();
        }
    }
    if (state.elements != null) {
        for (Object childObj : state.elements.values ()) {
            if (childObj instanceof Element) {
                ((Element) childObj).lock ();
            }
            else {
                for (Element child : castElementCollection (childObj)) {
                    child.lock ();
                }
            }
        }
    }
    return this;
}


public void actionPerformed (ActionEvent e) {
    final Reader reader = new Reader (masterModel);
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            try {
                IJ.showStatus ("Loading image");
                ImagePlus imp = reader.open ("", true);
                IJ.showStatus ("Image loaded");
                if (imp == null) return;
                imp.setPosition (1, 1, 1);
                imp.show ();
            } catch (OutOfMemoryError e) {
                IJ.outOfMemory ("Could not load lsm image.");
            }
        }
    }
    );
}


-----Function Pair=146=-----==

public void addDetail (Throwable error) {
    Document doc = null;
    try {
        doc = XMLUtil.createDocument ();
    } catch (ParserConfigurationException e) {
        return;
    }
    Element ex = doc.createElementNS (NS_EXCEPTION, EXCEPTION_ELEMENT);
    ex.setPrefix ("e");
    ex.setAttribute ("message", error.getMessage ());
    ex.setAttribute ("className", error.getClass ().getName ());
    ex.setAttribute ("xmlns:e", NS_EXCEPTION);
    StackTraceElement [] trace = error.getStackTrace ();
    for (int i = 0; i < trace.length; i ++) {
        StackTraceElement ste = trace [i];
        Element e = doc.createElementNS (NS_EXCEPTION, STACK_TRACE_ELEMENT);
        e.setPrefix ("e");
        e.setAttribute ("className", ste.getClassName ());
        e.setAttribute ("fileName", ste.getFileName ());
        e.setAttribute ("methodName", ste.getMethodName ());
        e.setAttribute ("lineNumber", String.valueOf (ste.getLineNumber ()));
        ex.appendChild (e);
    }
    addDetail (ex);
}


public static void main (String [] args) throws Throwable {
    if (args.length == 0) {
        for (String s : usage) {
            System.err.println (s);
        }
        System.exit (1);
    }
    computeJpfHome (args);
    addJpfClassPath ();
    if (System.getenv ("VERBOSE") != null) {
        System.err.println ("CLASSPATH: " + cpString);
    }
    String jpfClassName = "gov.nasa.jpf.JPF";
    String [] targetArgs = new String [args.length + 1];
    targetArgs [0] = "+jpf.basedir=" + jpfHome;
    System.arraycopy (args, 0, targetArgs, 1, args.length);
    if (System.getenv ("VERBOSE") != null) {
        System.err.print ("main & args: " + jpfClassName);
        for (int i = 0; i < targetArgs.length; i ++) {
            System.err.print (" ");
            System.err.print (targetArgs [i]);
        }
        System.err.println ();
    }
    try {
        ClassLoader cl = getClassPathClassLoader ();
        Class < ? > jpfClass = cl.loadClass (jpfClassName);
        Constructor < ? > jpfConst = jpfClass.getConstructor (new Class [] {String [].class});
        if (jpfConst == null || ! Runnable.class.isAssignableFrom (jpfClass)) {
            throw new ClassNotFoundException ("Invalid/out of date " + jpfClassName + " class");
        }
        Runnable jpf = (Runnable) jpfConst.newInstance (new Object [] {targetArgs});
        jpf.run ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        System.err.println ("Make sure you have compiled JPF into build/jpf.");
        System.err.println ("Try this:  java RunAnt");
        System.exit (1);
    } catch (NoSuchMethodException e) {
        e.printStackTrace ();
        System.exit (1);
    } catch (InvocationTargetException e) {
        printTrimmedStackTrace (e.getTargetException ());
        System.exit (1);
    }
}


-----Function Pair=147=-----==

public static void main (String [] args) {
    Mix proxyMe = new Mix ();
    Object proxy = createProxy (proxyMe);
    if (! Proxy.isProxyClass (proxy.getClass ())) System.err.println ("not a proxy class?");
    if (Proxy.getInvocationHandler (proxy) == null) System.err.println ("ERROR: Proxy.getInvocationHandler is null");
    Shapes shapes = (Shapes) proxy;
    shapes.circle (3);
    shapes.rectangle (10, 20);
    shapes.blob ();
    Quads quads = (Quads) proxy;
    quads.rectangle (15, 25);
    quads.trapezoid (6, 81.18, 4);
    Colors colors = (Colors) proxy;
    colors.red (1.0f);
    colors.blue (777);
    colors.mauve ("sorry");
    colors.blob ();
    try {
        shapes.upChuck ();
        System.out.println ("Didn't get expected exception");
    } catch (IndexOutOfBoundsException ioobe) {
        System.out.println ("Got expected ioobe");
    }
    try {
        shapes.upCheck ();
        System.out.println ("Didn't get expected exception");
    } catch (InterruptedException ie) {
        System.out.println ("Got expected ie");
    }
    System.out.println ("");
    Method [] methods = proxy.getClass ().getDeclaredMethods ();
    System.out.println ("Proxy methods: " + Arrays.deepToString (methods));
    Method meth = methods [methods.length - 1];
    System.out.println ("Decl annos: " + Arrays.deepToString (meth.getDeclaredAnnotations ()));
    Annotation [] [] paramAnnos = meth.getParameterAnnotations ();
    System.out.println ("Param annos (" + paramAnnos.length + ") : " + Arrays.deepToString (paramAnnos));
    Field [] fields = proxy.getClass ().getDeclaredFields ();
    System.out.println ("Proxy fields: " + Arrays.deepToString (fields));
}


static Object [] packageParameterFromVarArg (VM_Method targetMethod, int argAddress) {
    VM_Type [] argTypes = targetMethod.getParameterTypes ();
    int argCount = argTypes.length;
    Object [] argObjectArray = new Object [argCount];
    VM_JNIEnvironment env = VM_Thread.getCurrentThread ().getJNIEnv ();
    for (int i = 0, addr = argAddress; i < argCount; i ++) {
        int loword, hiword;
        hiword = VM_Magic.getMemoryWord (addr);
        addr += 4;
        if (argTypes [i].isFloatType ()) {
            loword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapFloat ((float) (Double.longBitsToDouble (doubleBits)));
        }
        else if (argTypes [i].isDoubleType ()) {
            loword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapDouble (Double.longBitsToDouble (doubleBits));
        }
        else if (argTypes [i].isLongType ()) {
            loword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapLong (longValue);
        }
        else if (argTypes [i].isBooleanType ()) {
            argObjectArray [i] = VM_Reflection.wrapBoolean (hiword);
        }
        else if (argTypes [i].isByteType ()) {
            argObjectArray [i] = VM_Reflection.wrapByte ((byte) hiword);
        }
        else if (argTypes [i].isCharType ()) {
            argObjectArray [i] = VM_Reflection.wrapChar ((char) hiword);
        }
        else if (argTypes [i].isShortType ()) {
            argObjectArray [i] = VM_Reflection.wrapShort ((short) hiword);
        }
        else if (argTypes [i].isReferenceType ()) {
            argObjectArray [i] = env.getJNIRef (hiword);
        }
        else if (argTypes [i].isIntType ()) {
            argObjectArray [i] = VM_Reflection.wrapInt (hiword);
        }
        else {
            return null;
        }
    }
    return argObjectArray;
}


-----Function Pair=148=-----==

public void endElement (String namespaceURI, String localName, String qualifiedName) throws SAXException {
    try {
        if (localName.equals ("")) {
            localName = qualifiedName;
        }
        if (elementSubstitutions.containsKey (localName)) {
            String replacement = (String) elementSubstitutions.get (localName);
            localName = replacement;
            qualifiedName.replaceFirst (localName, replacement);
        }
        StringOutputHelpers.writeOutput ("endElement: " + localName, 1);
        if (localName.endsWith ("_assn") || localName.endsWith ("_assnlist") || localName.endsWith ("_assnref") || localName.endsWith ("_assnreflist")) {
            Association association_info = (Association) associationStack.pop ();
            StringOutputHelpers.writeOutput ("  Popped " + association_info.name + " from association stack", 3);
        }
        else if (localName.endsWith ("_ref") || localName.endsWith ("_package") || localName.equals ("MAGE-ML")) {
        }
        else if (localName.indexOf ("_") < 0) {
            Object objInfo = objectStack.pop ();
            StringOutputHelpers.writeOutput ("  Popped " + objInfo.getClass ().getName () + " from object stack", 3);
        }
        else {
        }
        if (localName.equals ("DataInternal")) {
            if (pcDataStack != null) {
                pcDataStack = null;
            }
            else {
                throw new SAXException ("No object on pcDataStack when closing PCDATA containing element");
            }
        }
    } catch (Exception e) {
        System.err.println ("Caught exception in endElement: " + e);
        e.printStackTrace ();
    }
}


protected void setRoundedBorder (final int [] subst, final int borderWidth) {
    final Point size = mShell.getSize ();
    final Image image = new Image (mShell.getDisplay (), size.x, size.y);
    final GC gc = new GC (image);
    gc.setBackground (mShell.getDisplay ().getSystemColor (SWT.COLOR_WIDGET_BORDER));
    gc.fillRoundRectangle (0, 0, size.x, size.y, 20, 20);
    gc.setBackground (mShell.getDisplay ().getSystemColor (SWT.COLOR_WIDGET_BACKGROUND));
    gc.fillRoundRectangle (borderWidth, borderWidth, size.x - (2 * borderWidth), size.y - (2 * borderWidth), 20, 20);
    gc.dispose ();
    final Region region = new Region ();
    region.add (0, 0, size.x, size.y);
    for (int y = 0; y < subst.length; y ++) {
        region.subtract (0, y, subst [y], 1);
        region.subtract (size.x - subst [y], y, subst [y], 1);
    }
    for (int y = 0; y < subst.length; y ++) {
        region.subtract (0, size.y - y - 1, subst [y], 1);
        region.subtract (size.x - subst [y], size.y - y - 1, subst [y], 1);
    }
    mShell.setRegion (region);
    mShell.addPaintListener (new PaintListener () {
        public void paintControl (final PaintEvent e) {
            e.gc.drawImage (image, e.x, e.y, e.width, e.height, e.x, e.y, e.width, e.height);
        }
    }
    );
}


-----Function Pair=149=-----==

public void run () {
    try {
        ServerSocket s = new ServerSocket (Config.getInt ("portManager"));
        while (! (finished || stopped)) {
            System.out.println ("manager va attendre fin");
            Socket soc = s.accept ();
            System.out.println ("une fin de +");
            nbFinished ++;
            if (nbFinished == currentScenario.getPcNumber ()) {
                finished = true;
            }
            soc.close ();
        }
        System.out.println ("tout le monde il est mort");
        s.close ();
    } catch (IOException e) {
        LOG4J.fatal (e);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=150=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public void execLoad1 (String sql123) {
    try {
        st.executeUpdate (sql123);
    } catch (SQLException e) {
        System.out.println ("SAD");
        System.out.println (e.getMessage ());
        e.printStackTrace ();
        try {
            Class.forName (driver).newInstance ();
            con = DriverManager.getConnection (url + dbName, userName, password);
            st = con.createStatement ();
        } catch (Exception ex1) {
            System.out.println (ex1.getMessage ());
            ex1.printStackTrace ();
        }
    } catch (Exception e) {
        System.out.println ("SADDDD");
        System.out.println (e.getMessage ());
        e.printStackTrace ();
    }
}


-----Function Pair=151=-----==

public static String min (String [] s) {
    double dMin = new Double (s [0]).doubleValue ();
    int len = s.length;
    for (int i = 0; i <= len + 1; i ++) {
        double dArray = new Double (s [i]).doubleValue ();
        lf.finest ("dMin: " + dMin + " i: " + i + " dArray: " + dArray, "XAFunctoids", "min");
        if (dArray < dMin) {
            dMin = dArray;
        }
        if (i == len - 1) {
            break;
        }
    }
    lf.finest ("dMin: " + new Double (dMin).toString (), "XAFunctoids", "min");
    return new Double (dMin).toString ();
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=152=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


static Map parse_cmd_args (String [] args, Pattern opt_with_params, Pattern opt_no_params) throws Exception {
    Map ret = new HashMap ();
    for (int i = 0; i < args.length; i ++) {
        String arg = args [i];
        if (opt_no_params.matcher (arg).matches ()) {
            ret.put (arg, Boolean.TRUE);
        }
        else if (opt_with_params.matcher (arg).matches ()) {
            if (i + 1 >= args.length) throw new Exception ("option " + arg + " has no argumnet");
            ret.put (arg, args [++ i]);
        }
        else {
            List params = (List) ret.get ("#");
            if (params == null) {
                params = new ArrayList ();
                ret.put ("#", params);
            }
            params.add (arg);
        }
    }
    return ret;
}


-----Function Pair=153=-----==

private void setupProxy (IProxySettings proxySettings, HttpClient client, URL url) {
    if (proxySettings == null) {
        return;
    }
    if (! proxySettings.getHttpUseProxy ()) {
        return;
    }
    if (proxySettings.getHttpNonProxyHosts () != null && proxySettings.getHttpNonProxyHosts ().contains (url.getHost ())) {
        return;
    }
    String proxyHost = proxySettings.getHttpProxyServer ();
    int proxyPort = Integer.parseInt (proxySettings.getHttpProxyPort ());
    String proxyUsername = proxySettings.getHttpProxyUser ();
    String proxyPassword = proxySettings.getHttpProxyPassword ();
    client.getHostConfiguration ().setProxy (proxyHost, proxyPort);
    if (proxyUsername != null && ! "".equals (proxyUsername)) {
        Credentials credentials = new UsernamePasswordCredentials (proxyUsername, proxyPassword);
        client.getState ().setProxyCredentials (AuthScope.ANY, credentials);
    }
}


public void write (BufferedImage image, OutputStream out) throws IOException {
    LinkedList chunkList = new LinkedList ();
    int totalSize = 0;
    chunkList.add (getHeaderBytes ());
    chunkList.add (getIHDRBytes (image));
    gettEXtBytes (chunkList);
    chunkList.add (getgAMABytes ());
    chunkList.add (getPLTEBytes (image));
    chunkList.add (getIDATBytes (image));
    chunkList.add (getIENDBytes ());
    Iterator iterator = chunkList.iterator ();
    while (iterator.hasNext ()) {
        totalSize += ((byte []) iterator.next ()).length;
    }
    ByteBuffer buffer = ByteBuffer.allocate (totalSize);
    iterator = chunkList.iterator ();
    while (iterator.hasNext ()) {
        buffer.put ((byte []) iterator.next ());
    }
    out.write (buffer.array ());
}


-----Function Pair=154=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public void doShowImages () {
    if (noneSelected ()) return;
    final MatchListElement listItem = (MatchListElement) x_main_list.getModel ().getElementAt (x_main_list.getSelectedIndex ());
    final String leftName = listItem.m_leftFile.getAbsolutePath ();
    final String rightName = listItem.m_rightFile.getAbsolutePath ();
    final ImageIcon leftIcon = new ImageIcon (leftName);
    final ImageIcon rightIcon = new ImageIcon (rightName);
    final int leftWidth = leftIcon.getIconWidth ();
    final int leftHeight = leftIcon.getIconHeight ();
    final int rightWidth = rightIcon.getIconWidth ();
    final int rightHeight = rightIcon.getIconHeight ();
    x_showImages_left.setIcon (new ImageIcon (leftIcon.getImage ().getScaledInstance (leftWidth >= leftHeight ? 144 : - 1, leftHeight >= leftWidth ? 144 : - 1, Image.SCALE_SMOOTH)));
    x_showImages_right.setIcon (new ImageIcon (rightIcon.getImage ().getScaledInstance (rightWidth >= rightHeight ? 144 : - 1, rightHeight >= rightWidth ? 144 : - 1, Image.SCALE_SMOOTH)));
    x_showImages_left.setToolTipText (leftName + " - " + leftWidth + 'x' + leftHeight);
    x_showImages_right.setToolTipText (rightName + " - " + rightWidth + 'x' + rightHeight);
    x_showImages_left.setName (leftName);
    x_showImages_right.setName (rightName);
    fixDialog (getDialog ("showImages"), x_main);
}


-----Function Pair=155=-----==

private void zeichneFragmente () {
    if (this.RestriktionsResultList.size () > 1) {
        berechneDauer ();
        for (int i = 0; i < this.RestriktionsResultList.size (); i ++) {
            zeichneBezeichnung (i);
            zeichneFragmentVerlauf (i);
            positionsGrafikListVerwaltung (i);
            Point point = berechneFragmentPosition (i, 0);
            ArrayList < Integer > beschriftungsPositionen = new ArrayList < Integer > ();
            int letzteBeschriftung = 0;
            for (int y = 0; y < this.positonsGrafikList.size (); y ++) {
                if (this.positonsGrafikList.get (y).anzahlFragmente > 0) {
                    point.y = y;
                    int anzahlFragmente = this.positonsGrafikList.get (y).anzahlFragmente;
                    if (anzahlFragmente > 5) anzahlFragmente = 5;
                    if (this.RestriktionsResultList.get (i).issDNA ()) anzahlFragmente = 1;
                    ZeichneStrich (point.x, point.y, point.x + this.StrichLaenge, point.y, anzahlFragmente, getTransparentColor (this.fragmentFarbe, Color.white, 1 - (anzahlFragmente / 10.0)));
                    if (this.RestriktionsResultList.get (i).issDNA () && ((y - letzteBeschriftung) >= 9)) {
                        letzteBeschriftung = y;
                        beschriftungsPositionen.add (y);
                    }
                }
            }
            for (int p = 0; p < beschriftungsPositionen.size (); p ++) {
                point.y = beschriftungsPositionen.get (p);
                if (p == beschriftungsPositionen.size () - 1) zeichneFragmentBezeichnung (point, true);
                else zeichneFragmentBezeichnung (point, false);
            }
        }
    }
}


public boolean onTile (RSTile tile, String search, String action, double dx, double dy, int height) {
    Point checkScreen;
    checkScreen = calc.tileToScreen (tile, dx, dy, height);
    if (! calc.pointOnScreen (checkScreen)) {
        walkTile (tile);
        sleep (random (340, 1310));
    }
    try {
        Point screenLoc;
        for (int i = 0; i < 30; i ++) {
            screenLoc = calc.tileToScreen (tile, dx, dy, height);
            if (! calc.pointOnScreen (screenLoc)) {
                return false;
            }
            if (menu.getItems ().toString ().toLowerCase ().contains (search.toLowerCase ())) {
                break;
            }
            if (mouse.getLocation ().equals (screenLoc)) {
                break;
            }
            mouse.move (screenLoc);
        }
        if (menu.getItems ().length <= 1) {
            return false;
        }
        sleep (random (100, 200));
        if (menu.getItems ().toString ().toLowerCase ().contains (action.toLowerCase ())) {
            mouse.click (true);
            return true;
        }
        else {
            return menu.doAction (action);
        }
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
}


-----Function Pair=156=-----==

public Component getTreeCellRendererComponent (JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
    DefaultTreeCellRenderer dtcr = new DefaultTreeCellRenderer ();
    Component c = dtcr.getTreeCellRendererComponent (tree, value, selected, expanded, leaf, row, hasFocus);
    if (((DefaultMutableTreeNode) value).getUserObject () instanceof String) return c;
    final Color selectedColor = (Color) ((DefaultMutableTreeNode) value).getUserObject ();
    ((JLabel) c).setText ("(" + selectedColor.getRed () + "," + selectedColor.getGreen () + "," + selectedColor.getBlue () + ")");
    ((JLabel) c).setHorizontalTextPosition (0);
    ((JLabel) c).setHorizontalAlignment (JLabel.LEFT);
    Icon ic = new Icon () {
        public int getIconHeight () {
            return 15;
        } public int getIconWidth () {
            return 90;
        } public void paintIcon (Component c, Graphics g, int x, int y) {
            g.setColor (selectedColor);
            g.fillRect (x, y, 200, 100);
        }
    }
    ((JLabel) c).setIcon (ic);
    return c;
}


private void initGUI () {
    try {
        BorderLayout thisLayout = new BorderLayout ();
        this.getContentPane ().setLayout (thisLayout);
        this.addWindowListener (new WindowAdapter () {
            public void windowClosed (WindowEvent evt) {
                rootWindowClosed (evt);
            } public void windowClosing (WindowEvent evt) {
                rootWindowClosed (evt);
            }
        }
        );
        this.setSize ((int) (getMaximumSize ().width * 0.5), (int) (getMaximumSize ().height * 0.5));
        this.setTitle ("RegExSearchReplace - Regular Expression Search/Replace Tool ........ by Hitesh Viseria");
        {
            jMenuBar1 = new JMenuBar ();
            setJMenuBar (jMenuBar1);
            {
            }
            {
            }
            {
                jMenu5 = new JMenu ();
                jMenuBar1.add (jMenu5);
                jMenu5.setText ("Help");
                {
                    {
                        jPanel1 = new JPanel ();
                        this.getContentPane ().add (jPanel1, BorderLayout.NORTH);
                        GridBagLayout jPanel1Layout = new GridBagLayout ();
                        jPanel1.setLayout (jPanel1Layout);
                        jPanel1.setPreferredSize (new java.awt.Dimension (709, 139));
                        {
                            Search = new JLabel ();
                            jPanel1.add (Search, new GridBagConstraints (0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            Search.setText ("Search    : ");
                        }
                        {
                            SearchExp = new JTextField (140);
                            jPanel1.add (SearchExp, new GridBagConstraints (1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            SearchExp.setPreferredSize (new java.awt.Dimension (140, 20));
                            SearchExp.setText ("");
                        }
                        {
                            Folder = new JLabel ();
                            jPanel1.add (Folder, new GridBagConstraints (0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            Folder.setText ("Folder      : ");
                        }
                        {
                            Select = new JButton ();
                            jPanel1.add (Select, new GridBagConstraints (3, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            Select.setText ("Select  ");
                            Select.addActionListener (new ActionListener () {
                                public void actionPerformed (ActionEvent evt) {
                                    SelectActionPerformed (evt);
                                }
                            }
                            );
                        }
                        {
                            FolderName = new JTextField ();
                            jPanel1.add (FolderName, new GridBagConstraints (1, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            FolderName.setText ("Select Folder Name            ");
                        }
                        {
                            jLabel1 = new JLabel ();
                            jPanel1.add (jLabel1, new GridBagConstraints (0, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            jLabel1.setText ("File Name : ");
                        }
                        {
                            FileFilter = new JTextField ();
                            jPanel1.add (FileFilter, new GridBagConstraints (1, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            FileFilter.setText ("Enter fileName or file filter");
                        }
                        {
                            SelectFile = new JButton ();
                            jPanel1.add (SelectFile, new GridBagConstraints (3, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            SelectFile.setText ("Select  ");
                            SelectFile.addActionListener (new ActionListener () {
                                public void actionPerformed (ActionEvent evt) {
                                    SelectFileActionPerformed (evt);
                                }
                            }
                            );
                        }
                        {
                            Find = new JButton ();
                            jPanel1.add (Find, new GridBagConstraints (3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                            Find.setText ("Search");
                            Find.addActionListener (new ActionListener () {
                                public void actionPerformed (ActionEvent evt) {
                                    FindActionPerformed (evt, 0);
                                }
                            }
                            );
                        }
                        {
                            jLabel2 = new JLabel ();
                            jPanel1.add (jLabel2, new GridBagConstraints (11, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (0, 0, 0, 0), 0, 0));
                            jLabel2.setText ("Replace");
                        }
                        {
                            replaceField = new JTextField (60);
                            replaceField.setPreferredSize (new java.awt.Dimension (140, 20));
                            replaceField.setText ("Enter Text To Replace");
                            jPanel1.add (replaceField, new GridBagConstraints (12, 0, 1, 1, 0.5, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
                        }
                        {
                            preview = new JButton ();
                            jPanel1.add (preview, new GridBagConstraints (13, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (0, 0, 0, 0), 0, 0));
                            preview.setText ("Preview");
                            preview.addActionListener (new ActionListener () {
                                public void actionPerformed (ActionEvent evt) {
                                    System.out.println ("preview.actionPerformed, event=" + evt);
                                    FindActionPerformed (evt, 1);
                                }
                            }
                            );
                        }
                        {
                            Replace = new JButton ();
                            jPanel1.add (Replace, new GridBagConstraints (13, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (0, 0, 0, 0), 0, 0));
                            Replace.setText ("Replace");
                            Replace.addActionListener (new ActionListener () {
                                public void actionPerformed (ActionEvent evt) {
                                    System.out.println ("Replace.actionPerformed, event=" + evt);
                                    FindActionPerformed (evt, 2);
                                }
                            }
                            );
                        }
                        {
                            jLabel4 = new JLabel ();
                            jPanel1.add (jLabel4, new GridBagConstraints (11, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (0, 0, 0, 0), 0, 0));
                            jLabel4.setText ("                               ");
                        }
                        {
                            jLabel5 = new JLabel ();
                            jPanel1.add (jLabel5, new GridBagConstraints (1, 3, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (0, 0, 0, 0), 0, 0));
                            jLabel5.setText ("                                                       ");
                        }
                    }
                    {
                        jScrollPane1 = new JScrollPane ();
                        {
                            SearchResults = new JEditorPane ();
                            jScrollPane1.setViewportView (SearchResults);
                            SearchResults.setText ("Search Results");
                        }
                        this.getContentPane ().add (jScrollPane1, BorderLayout.CENTER);
                    }
                    helpMenuItem = new JMenuItem ();
                    jMenu5.add (helpMenuItem);
                    helpMenuItem.setText ("About");
                    helpMenuItem.addActionListener (new ActionListener () {
                        public void actionPerformed (ActionEvent evt) {
                            System.out.println ("about.actionPerformed, event=" + evt);
                            displayAbout (evt, 1);
                        }
                    }
                    );
                    readMeMenuItem = new JMenuItem ();
                    jMenu5.add (readMeMenuItem);
                    readMeMenuItem.setText ("ReadMe");
                    readMeMenuItem.addActionListener (new ActionListener () {
                        public void actionPerformed (ActionEvent evt) {
                            System.out.println ("about.actionPerformed, event=" + evt);
                            displayReadMe (evt, 1);
                        }
                    }
                    );
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=157=-----==

public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {
    this.applet = applet;
    if (applet == null) {
        frame = new JFrame (gc);
        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    }
    setLayout (new BorderLayout ());
    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));
    Action openAction = new AbstractAction ("Open File", new ImageIcon (getClass ().getResource ("/open.gif"))) {
        public void actionPerformed (ActionEvent e) {
            if (filechooser == null) {
                filechooser = new JFileChooser ();
                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
            }
            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                open (filechooser.getSelectedFile ());
            }
        }
    }
    ;
    JToolBar bar = new JToolBar ();
    bar.add (new ToolBarButton (openAction));
    add (bar, BorderLayout.NORTH);
    if (applet == null) {
        frame.setTitle ("Image Display - Control Panel");
        frame.getContentPane ().add (this, BorderLayout.CENTER);
        frame.pack ();
        frame.show ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=158=-----==

private static void output (String filename, ZipOutputStream os) {
    if (filename != null && ! filename.equals ("")) {
        FileInputStream fis = null;
        try {
            File f = new File (filename);
            if (! f.exists ()) return;
            os.putNextEntry (new ZipEntry (f.getName ()));
            fis = new FileInputStream (filename);
            int t;
            while ((t = fis.read ()) != - 1) {
                os.write (t);
            }
            os.flush ();
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            try {
                if (fis != null) fis.close ();
            } catch (IOException e) {
            }
        }
    }
}


public static void zip (File zipFile, File parentDir, File [] sources, char pathSeparator) throws IOException {
    String stripPath = (parentDir != null) ? parentDir.getPath () : "";
    if (stripPath.length () > 0 && ! stripPath.endsWith (File.separator)) {
        stripPath += File.separator;
    }
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    out.setMethod (ZipOutputStream.DEFLATED);
    try {
        for (int i = 0; i < sources.length; i ++) {
            if (! sources [i].exists ()) {
                throw new IllegalArgumentException ("File or directory does not exist: " + sources [i]);
            }
            if (sources [i].isDirectory ()) {
                zipDirectory (out, stripPath, sources [i], pathSeparator);
            }
            else {
                zipFile (out, stripPath, sources [i], pathSeparator);
            }
        }
    } finally {
        out.close ();
    }
}


-----Function Pair=159=-----==

public String getTermText (IdentifiedObject term) throws DataAdapterException {
    final StringBuffer buffer = new StringBuffer ();
    OutputStream os = new OutputStream () {
        @Override
        public void write (int b) {
            buffer.append ((char) b);
        }
    }
    ;
    try {
        ObjectOutputStream stream = new ObjectOutputStream (os);
        stream.writeObject (os);
    } catch (IOException ex) {
    }
    return buffer.toString ();
}


private void processEntry (final EntryPersistence entry, final LanguagePersistence language, final OutputStream outputStream) throws IOException {
    TranslationPersistence translation = null;
    if (language != null) {
        translation = projectDao.getTranslationByEntryAndLanguage (entry.getId (), language.getId ());
    }
    if (entry.getDescription () != null) {
        writeString (outputStream, "# Description: " + entry.getDescription () + "\n");
    }
    if (entry.getMeaning () != null) {
        writeString (outputStream, "# Meaning: " + entry.getMeaning () + "\n");
    }
    if (entry.getParameters () != null) {
        writeString (outputStream, "# " + entry.getParameters () + "\n");
    }
    if (translation == null) {
        writeString (outputStream, entry.getKey () + "=" + entry.getContent () + "\n");
    }
    else {
        writeString (outputStream, entry.getKey () + "=" + translation.getTranslation () + "\n");
    }
    writeString (outputStream, "\n");
}


-----Function Pair=160=-----==

private void addCell (Element rowElement, Object cellObject) {
    Element cellElement = rowElement.addElement ("c");
    if (cellObject == null) {
        return;
    }
    String text;
    if (cellObject instanceof String) {
        cellElement.addAttribute ("t", "str");
        text = (String) cellObject;
    }
    else if (cellObject instanceof Number) {
        cellElement.addAttribute ("t", "n");
        text = String.valueOf (((Number) cellObject).doubleValue ());
    }
    else if (cellObject instanceof Boolean) {
        cellElement.addAttribute ("t", "b");
        if (((Boolean) cellObject).booleanValue ()) {
            text = "1";
        }
        else {
            text = "0";
        }
    }
    else {
        Double excelDate = OpenXmlUtil.toExcelDate (cellObject);
        if (excelDate != null) {
            cellElement.addAttribute ("t", "n");
            text = excelDate.toString ();
        }
        else {
            log.warn ("Unknown data type found, add as String: " + cellObject.getClass ().getName ());
            cellElement.addAttribute ("t", "str");
            text = cellObject.toString ();
        }
    }
    Element valueElement = cellElement.addElement ("v");
    valueElement.setText (text);
}


boolean createSessionArchive (String archiveFilename) {
    byte [] buffer = new byte [1024];
    try {
        ZipOutputStream archive = new ZipOutputStream (new FileOutputStream (archiveFilename));
        for (mAnnotationsCursor.moveToFirst (); ! mAnnotationsCursor.isAfterLast (); mAnnotationsCursor.moveToNext ()) {
            FileInputStream in = new FileInputStream (mAnnotationsCursor.getString (ANNOTATIONS_FILE_NAME));
            archive.putNextEntry (new ZipEntry ("audio" + (mAnnotationsCursor.getPosition () + 1) + ".3gpp"));
            int length;
            while ((length = in.read (buffer)) > 0) archive.write (buffer, 0, length);
            archive.closeEntry ();
            in.close ();
        }
        archive.close ();
    } catch (IOException e) {
        Toast.makeText (mActivity, mActivity.getString (R.string.error_zip) + " " + e.getMessage (), Toast.LENGTH_SHORT).show ();
        return false;
    }
    return true;
}


-----Function Pair=161=-----==

public static File [] listDirectories (File baseDir, boolean recursive) {
    File [] files = baseDir.listFiles (new FileFilter () {
        public boolean accept (File f) {
            return f.isDirectory ();
        }
    }
    );
    if (recursive) {
        NSMutableArray < File > a = new NSMutableArray < File > (files);
        for (int i = files.length; i -- > 0;) {
            File currentDir = files [i];
            File [] currentDirs = listDirectories (currentDir, true);
            a.addObjects (currentDirs);
        }
        Object [] objects = a.objects ();
        files = new File [objects.length];
        System.arraycopy (objects, 0, files, 0, objects.length);
    }
    return files;
}


protected void closeExportFile (Element exportNode) throws IOException, SAXException {
    getSaxWriter ().writeClose (exportNode);
    CmsXmlSaxWriter xmlSaxWriter = (CmsXmlSaxWriter) getSaxWriter ().getContentHandler ();
    xmlSaxWriter.endDocument ();
    ZipEntry entry = new ZipEntry (CmsImportExportManager.EXPORT_MANIFEST);
    getExportZipStream ().putNextEntry (entry);
    StringBuffer result = ((StringWriter) xmlSaxWriter.getWriter ()).getBuffer ();
    int steps = result.length () / SUB_LENGTH;
    int rest = result.length () % SUB_LENGTH;
    int pos = 0;
    for (int i = 0; i < steps; i ++) {
        String sub = result.substring (pos, pos + SUB_LENGTH);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
        pos += SUB_LENGTH;
    }
    if (rest > 0) {
        String sub = result.substring (pos, pos + rest);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
    }
    getExportZipStream ().closeEntry ();
    getExportZipStream ().close ();
}


-----Function Pair=162=-----==

static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


protected Attributes loadAttributesBinary (InputStream in_strm) throws IOException {
    Attributes a = new Attributes ();
    DataInputStream in = new DataInputStream (in_strm);
    String file_class_name = in.readUTF ();
    if (a.getClass ().getName ().compareTo (file_class_name) != 0) {
        String message = getClass ().getName () + " can't load " + file_class_name;
        throw new IOException (message);
    }
    int file_version = in.readInt ();
    if (file_version > version) {
        System.out.println (getClass ().getName () + " replacing file version " + file_version + " with " + version);
        file_version = version;
    }
    if (file_version > 2) {
        a.setTimeKeyIndex (in.readInt ());
    }
    a.setName (in.readUTF ());
    if (file_version >= 11) {
        a.setID (in.readUTF ());
        a.setTheme (in.readUTF ());
    }
    try {
        Document doc = this.loadXMLDocument ("extent.xml");
        if (doc != null) {
            a.setExtents (new ExtentManager (in, doc, doc.getDocumentElement ()));
        }
        else {
            a.setExtents (new ExtentManager (in));
        }
    } catch (Exception e) {
        e.printStackTrace ();
        a.setExtents (new ExtentManager (in));
    }
    setXMLExtents ((ExtentManager) a.getExtents ());
    a.setMatrix (new Matrix (in));
    a.setPrecisionExtent (new PrecisionExtent (in, new Integer (file_version)));
    a.setUnitExtent (new UnitExtent (in, new Integer (file_version)));
    a.setDataLegendExtent (new DataLegendExtent (in, new Integer (file_version)));
    a.setGraphExtent (new GraphExtent (in, new Integer (file_version)));
    a.setSourceExtent (new SourceExtent (in, new Integer (file_version)));
    a.setNoteExtent (new NoteExtent (in, new Integer (file_version)));
    a.setLinkExtent (new LinkExtent (in, new Integer (file_version)));
    if (file_version >= 9) {
        a.setReferenceExtent (new ReferenceExtent (in, new Integer (file_version)));
    }
    else {
        a.setReferenceExtent (new ReferenceExtent (a.getExtents ().size ()));
    }
    a.setKeyedExtent (new KeyedExtent (a.getNoteExtent (), a.getSourceExtent (), a.getLinkExtent ()));
    try {
        String header = in.readUTF ();
        if (! header.equals (null)) {
            a.setHeader (header);
        }
    } catch (Exception ex) {
    }
    if (file_version >= 10) {
        a.setSampleExtent (new SampleExtent (in, new Integer (file_version)));
    }
    if (file_version >= 12) {
        a.setPublishExtent (new PublishExtent (in, new Integer (file_version)));
    }
    return a;
}


-----Function Pair=163=-----==

private void init (InputStream in) {
    byte [] buf = new byte [1024];
    BufferedInputStream bis = null;
    ZipInputStream zis = null;
    ZipEntry ze = null;
    try {
        bis = new BufferedInputStream (in);
        zis = new ZipInputStream (bis);
        while ((ze = zis.getNextEntry ()) != null) {
            String name = ze.getName ();
            if (ze.isDirectory ()) {
                entries.put (name, new byte [0]);
            }
            else {
                ByteArrayOutputStream out = new ByteArrayOutputStream ();
                int len;
                while ((len = zis.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.flush ();
                entries.put (name, out.toByteArray ());
            }
        }
    } catch (Exception ex) {
        String msg = "Unable to read the ODT file.";
        throw new DocumentException (msg, ex);
    } finally {
        try {
            if (bis != null) bis.close ();
            if (zis != null) zis.close ();
        } catch (Exception ex) {
            String msg = "Unable to read the ODT file.";
            throw new DocumentException (msg, ex);
        }
    }
}


static void createSaveFile (File file, JLayeredPane sp, String title) throws FileNotFoundException, IOException {
    int bgDisplay = 0;
    ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (file));
    String manifest = "<?xml version='1.0' encoding='utf-8'?>\n" + "<!DOCTYPE slideshow [" + "<!ELEMENT scrapbook (scrappage+)>\n" + "<!ELEMENT scrappage (color, imageelem*, textelem*)>\n" + "<!ELEMENT imageelem (file, scale, rotataion, xpos, ypos)>\n" + "<!ELEMENT textelem (text, fontname, fontsize, fontbold, fontitalis, color, scale, rotataion, xpos, ypos)>\n" + "<!ELEMENT color (red, green, blue)>]>\n" + "<scrapbook>\n" + "<scrappage>\n" + "<title><![CDATA[" + title + "]]></title>\n";
    for (int i = 0; i < sp.getComponentCount (); i ++) {
        if (sp.getComponent (i).getClass ().getName ().equals ("digiscrap.ScrapElementImage")) {
            String fName = "images/image" + i + ".png";
            manifest += manifestImage ((ScrapElementImage) (sp.getComponent (i)), fName);
            zip.putNextEntry (new ZipEntry (fName));
            ImageIO.write (((ScrapElementImage) (sp.getComponent (i))).getImg (), "png", zip);
        }
        else if (sp.getComponent (i).getClass ().getName ().equals ("digiscrap.ScrapElementText")) {
            manifest += manifestText ((ScrapElementText) (sp.getComponent (i)));
        }
        else if (sp.getComponent (i).getClass ().getName ().equals ("digiscrap.ScrapPanel")) {
            String fName = "images/background.png";
            bgDisplay = ((ScrapPanel) (sp.getComponent (i))).getBgDisplay ();
            manifest += "<bgManifested />";
            zip.putNextEntry (new ZipEntry (fName));
            ImageIO.write (((ScrapPanel) (sp.getComponent (i))).getBgImage (), "png", zip);
        }
    }
    manifest += "<background>\n" + "<color>\n" + "<red>" + sp.getBackground ().getRed () + "</red>\n" + "<green>" + sp.getBackground ().getGreen () + "</green>\n" + "<blue>" + sp.getBackground ().getBlue () + "</blue>\n" + "<bgDisplay>" + bgDisplay + "</bgDisplay>\n" + "</color>\n" + "</background>\n" + "</scrappage>\n" + "</scrapbook>\n";
    zip.putNextEntry (new ZipEntry ("digiscrap.xml"));
    zip.write (manifest.getBytes ());
    String fName = "previews/preview1.png";
    manifest += "<bgManifested />";
    zip.putNextEntry (new ZipEntry (fName));
    BufferedImage bi = new BufferedImage (1024, 1024, BufferedImage.TYPE_INT_ARGB);
    sp.print (bi.getGraphics ());
    ImageIO.write (bi, "png", zip);
    zip.close ();
}


-----Function Pair=164=-----==

public void exportMySelf (File f) {
    setQuality (true);
    BufferedImage exportImage = new BufferedImage (size [0], size [1], (f.getName ().endsWith ("jpg")) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = exportImage.createGraphics ();
    g.setRenderingHints (getRenderingHints ());
    drawMySelfHighQuality (g);
    Iterator it = ImageIO.getImageWriters (new ImageTypeSpecifier (exportImage), (f.getName ().endsWith ("jpg")) ? "jpg" : "png");
    if (! it.hasNext ()) {
        CDoxFrame.handleError (new Throwable (CDox.getLocalizer ().get ("nowriter")), false);
        setQuality (false);
        return;
    }
    ImageWriter iw = (ImageWriter) it.next ();
    try {
        ImageOutputStream ios = ImageIO.createImageOutputStream (f);
        iw.setOutput (ios);
        iw.write (exportImage);
        iw.dispose ();
        ios.flush ();
        ios.close ();
        System.gc ();
    } catch (IOException ioe) {
        setQuality (false);
        CDoxFrame.handleError (ioe, true);
    }
    setQuality (false);
}


public JFileChooser getOpenFileChooser () {
    if (fc == null) {
        fc = new JFileChooser ();
        fc.setCurrentDirectory (new File (System.getProperty ("user.dir")));
        try {
            Properties execMap = new Properties ();
            execMap.load (new FileInputStream (new File ("input.prop")));
            for (Object key : execMap.keySet ()) {
                String entry = key.toString ();
                if (entry.indexOf ('.') < 0) {
                    String command = execMap.getProperty (entry);
                    ExtensionFilter ef;
                    if (execMap.containsKey (entry + ".description")) {
                        String desc = execMap.getProperty (entry + ".description");
                        ef = new ExtensionFilter (desc);
                    }
                    else {
                        ef = new ExtensionFilter (entry + " files");
                    }
                    ef.addExtension (entry);
                    inputFilterCommands.put (entry, pathDelimConv (command));
                    if (execMap.containsKey (entry + ".alt")) {
                        String alt = execMap.getProperty (entry + ".alt");
                        StringTokenizer st = new StringTokenizer (alt);
                        while (st.hasMoreTokens ()) {
                            String token = st.nextToken ();
                            ef.addExtension (token);
                            inputFilterCommands.put (token, pathDelimConv (command));
                        }
                    }
                    fc.addChoosableFileFilter (ef);
                }
            }
        } catch (Exception e) {
        }
        ExtensionFilter sifafilter = new ExtensionFilter ("SIFA files (.sifa)");
        sifafilter.addExtension ("sifa");
        fc.addChoosableFileFilter (sifafilter);
        fc.setFileFilter (sifafilter);
    }
    return fc;
}


-----Function Pair=165=-----==

public static Configurable load (String filename, String type, String tempdir) throws EDITSException {
    File file = new File (filename);
    if (! file.exists ()) throw new EDITSException ("The file " + filename + " does not exist!");
    if (! file.canRead ()) throw new EDITSException ("The file " + filename + " can not be read.");
    if (tempdir == null) tempdir = EDITS.system ().tempdir ();
    if (new File (tempdir).exists ()) new File (tempdir).mkdir ();
    tempdir = tempdir + SerializationManager.getDate () + "/";
    new File (tempdir).mkdir ();
    SerializationManager.unzipModel (filename, tempdir);
    String confFile = tempdir + "/conf.xml";
    Configurations conf = loadConfigurations (confFile);
    ConfigurationLoader loader = new ConfigurationLoader (MODELPATH, tempdir);
    loader.processConfiguration (conf);
    Configurable c = ModuleLoader.loadModule (conf, type);
    if (c == null) throw new EDITSException ("The file " + filename + " does not contain " + type + "!");
    c.read (tempdir, DEFAILT_ID);
    SerializationManager.delete (new File (tempdir));
    return c;
}


public void testAddPackage () throws Exception {
    ConsoleUi cui = new ConsoleUi (TestHost.getInstance ());
    mPath1 = ROOT + File.separator + "com.google.android.cts.p1.zip";
    mPath2 = ROOT + File.separator + "com.google.android.cts.p2.zip";
    mPath3 = ROOT + File.separator + "net.sf.jlee.cts.p3.zip";
    final String expPackageName1 = "com.google.android.cts.p1";
    final String expPackageName2 = "com.google.android.cts.p2";
    final String expPackageName3 = "net.sf.jlee.cts.p3";
    HostConfig.getInstance ().removeTestPacakges ();
    ArrayList < String > pNames = HostConfig.getInstance ().getCaseRepository ().getPackageBinaryNames ();
    assertEquals (0, pNames.size ());
    createTestPackageZip (mPath1, expPackageName1);
    createTestPackageZip (mPath2, expPackageName2);
    createTestPackageZip (mPath3, expPackageName3);
    String cmdline = CTSCommand.ADD + " " + "-p" + " " + mPath1;
    cui.processCommand (CommandParser.parse (cmdline));
    pNames = HostConfig.getInstance ().getCaseRepository ().getPackageBinaryNames ();
    assertEquals (1, pNames.size ());
    assertTrue (pNames.contains (expPackageName1));
    cmdline = CTSCommand.ADD + " " + "-p" + " " + mPath2;
    cui.processCommand (CommandParser.parse (cmdline));
    pNames = HostConfig.getInstance ().getCaseRepository ().getPackageBinaryNames ();
    assertEquals (2, pNames.size ());
    assertTrue (pNames.contains (expPackageName1));
    assertTrue (pNames.contains (expPackageName2));
    cmdline = CTSCommand.ADD + " " + "-p" + " " + mPath3;
    cui.processCommand (CommandParser.parse (cmdline));
    pNames = HostConfig.getInstance ().getCaseRepository ().getPackageBinaryNames ();
    assertEquals (3, pNames.size ());
    assertTrue (pNames.contains (expPackageName1));
    assertTrue (pNames.contains (expPackageName2));
    assertTrue (pNames.contains (expPackageName3));
    deleteTestPackage (expPackageName1);
    deleteTestPackage (expPackageName2);
    deleteTestPackage (expPackageName3);
}


-----Function Pair=166=-----==

private static void parseDirectoryList (File file) {
    try {
        BufferedReader reader = new BufferedReader (new FileReader (file));
        String line;
        while ((line = reader.readLine ()) != null) {
            File dir = new File (line);
            if (dir.isDirectory ()) {
                System.out.println ("working on " + dir);
                makeIndex (dir);
            }
            else {
                System.err.println ("" + dir + " does not exists or is not a directory");
            }
        }
    } catch (FileNotFoundException e) {
        System.err.println (e.getLocalizedMessage ());
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public boolean creaRegistrosFichero (String rutaFichero, String registrosInicio) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'creaRegistrosFichero' ***********");
    boolean estado = false;
    try {
        FileWriter escritor = new FileWriter (rutaFichero);
        BufferedWriter salida = new BufferedWriter (escritor);
        PrintWriter imprime = new PrintWriter (salida);
        imprime.println (registrosInicio);
        imprime.close ();
        estado = true;
    } catch (FileNotFoundException e) {
        System.out.println ("No se encontro el Archivo: " + registrosInicio);
        e.printStackTrace ();
        estado = false;
    } catch (IOException e) {
        System.out.println ("Error de I/O");
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


-----Function Pair=167=-----==

public void sliceWritePositionScoreData (int rowChunkSize, File saveDirectory, ArrayList < File > files2Zip) {
    int beginningIndex = 0;
    int endIndex = 0;
    int numberPositions = sortedPositionScores.length;
    while (true) {
        PositionScore [] slice;
        if (rowChunkSize == - 1) {
            beginningIndex = 0;
            endIndex = numberPositions;
            slice = sortedPositionScores;
        }
        else {
            beginningIndex = endIndex;
            endIndex = beginningIndex + rowChunkSize;
            if (endIndex > numberPositions) {
                endIndex = numberPositions;
            }
            else {
                int endBP = sortedPositionScores [endIndex - 1].getPosition ();
                for (int i = endIndex; i < numberPositions; i ++) {
                    if (sortedPositionScores [i].getPosition () != endBP) {
                        break;
                    }
                    endIndex ++;
                }
            }
            int num = endIndex - beginningIndex;
            slice = new PositionScore [num];
            System.arraycopy (sortedPositionScores, beginningIndex, slice, 0, num);
        }
        PositionScoreData.updateSliceInfo (slice, sliceInfo);
        PositionScoreData pd = new PositionScoreData (slice, sliceInfo);
        File savedFile = pd.write (saveDirectory, true);
        files2Zip.add (savedFile);
        if (endIndex == numberPositions) break;
    }
}


private List < Element > getListOfNodeToInsert (Element textToAppend, TreeMap < String, String > mapOldIdToNewId) {
    ArrayList < Element > listOfNodes = new ArrayList < Element > ();
    for (Iterator j = textToAppend.elementIterator (); j.hasNext ();) {
        Element curNodeToInsert = (Element) j.next ();
        if (isNodeToInsertInOtherDoc (curNodeToInsert)) {
            Element copyNode = (Element) (curNodeToInsert.clone ());
            List < Element > listOfImages = Picture.getListReferenceForImagesAndOle (copyNode);
            if (! listOfImages.isEmpty ()) {
                if (! Picture.addNewReferences (listOfImages, mapOldIdToNewId)) {
                    return null;
                }
            }
            listOfNodes.add (copyNode);
        }
        else {
            if (logger.isDebugEnabled ()) {
                logger.debug ("node ignored for paragraph insertion:" + curNodeToInsert.getName () + " " + curNodeToInsert.getStringValue ());
            }
        }
    }
    return listOfNodes;
}


-----Function Pair=168=-----==

public static void replaceEntry (File file, String entryName, InputStream stream) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ".zargo");
        temporaryFile.deleteOnExit ();
        FileInputStream inputStream = new FileInputStream (file);
        ZipInputStream input = new ZipInputStream (inputStream);
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        ZipEntry entry = input.getNextEntry ();
        while (entry != null) {
            ZipEntry zipEntry = new ZipEntry (entry);
            zipEntry.setCompressedSize (- 1);
            output.putNextEntry (zipEntry);
            if (! entry.getName ().equals (entryName)) {
                IOUtils.copy (input, output);
            }
            else {
                IOUtils.copy (stream, output);
            }
            input.closeEntry ();
            output.closeEntry ();
            entry = input.getNextEntry ();
        }
        input.close ();
        inputStream.close ();
        output.close ();
        System.gc ();
        boolean isSuccess = file.delete ();
        if (! isSuccess) {
            throw new PersistenceException ();
        }
        isSuccess = temporaryFile.renameTo (file);
        if (! isSuccess) {
            throw new PersistenceException ();
        }
    } catch (IOException e) {
        throw new PersistenceException (e);
    }
}


public void process (String filename) {
    StopWatch watch = new StopWatch ();
    watch.tic ();
    Console.println (Console.TARGET_MAIN, "Saving file " + filename + ".");
    Console.startProgress ("Saving file.");
    Session s = mainFrame.getSession ();
    VisualONDEXGraph vog = mainFrame.getVisualONDEXGraph ();
    VisualGDSBuilder vgb = new VisualGDSBuilder (s, vog, visible, visual);
    try {
        System.setProperty ("javax.xml.stream.XMLOutputFactory", "com.ctc.wstx.stax.WstxOutputFactory");
        BufferedWriter writer;
        if (packed) {
            String zipname = filename + ".zip";
            ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (zipname));
            File file = new File (filename);
            zip.putNextEntry (new ZipEntry (file.getName ()));
            writer = new BufferedWriter (new OutputStreamWriter (zip));
        }
        else {
            writer = new BufferedWriter (new FileWriter (filename));
        }
        XMLOutputFactory2 xmlof = (XMLOutputFactory2) XMLOutputFactory2.newInstance ();
        xmlof.configureForSpeed ();
        XMLStreamWriter2 xmlw = xmlof.createXMLStreamWriter (writer, "UTF-8");
        backend.exchange.xml.export.ondex.Export builder = new backend.exchange.xml.export.ondex.Export (s);
        builder.buildDocument (xmlw, new MemoryONDEXIterator < AbstractConcept > (vgb.getConcepts ()), new MemoryONDEXIterator < AbstractRelation > (vgb.getRelations ()));
        xmlw.flush ();
        xmlw.close ();
        writer.flush ();
        writer.close ();
    } catch (IOException ioe) {
        Console.printmsg (Console.TARGET_MAIN, ioe);
        Console.stopProgress ();
    } catch (XMLStreamException xmlse) {
        Console.printmsg (Console.TARGET_MAIN, xmlse);
        Console.stopProgress ();
    } catch (URISyntaxException urise) {
        Console.printmsg (Console.TARGET_MAIN, urise);
        Console.stopProgress ();
    }
    double time = watch.toc ();
    Console.println (Console.TARGET_MAIN, "Saving finished. - " + time + " s");
    Console.stopProgress ();
}


-----Function Pair=169=-----==

public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegionScoreTexts [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
            int currentStart = sortedRegionScoreTexts [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegionScoreTexts.length; i ++) {
            int diff = sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    fileType = fileType + USeqUtilities.FLOAT + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedRegionScoreTexts [0].start);
        int bp = sortedRegionScoreTexts [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


public boolean addEntry (File file) {
    if (file == null) {
        log.warning ("addEntry - No File");
        return false;
    }
    if (! file.exists () || file.isDirectory ()) {
        log.warning ("addEntry - not added - " + file + ", Exists=" + file.exists () + ", Directory=" + file.isDirectory ());
        return false;
    }
    log.fine ("addEntry - " + file);
    String name = file.getName ();
    byte [] data = null;
    try {
        FileInputStream fis = new FileInputStream (file);
        ByteArrayOutputStream os = new ByteArrayOutputStream ();
        byte [] buffer = new byte [1024 * 8];
        int length = - 1;
        while ((length = fis.read (buffer)) != - 1) {
            os.write (buffer, 0, length);
        }
        fis.close ();
        data = os.toByteArray ();
        os.close ();
    } catch (IOException ioe) {
        log.log (Level.SEVERE, "addEntry (file)", ioe);
    }
    return addEntry (name, data);
}


-----Function Pair=170=-----==

private boolean uploadZip (Preference preference, File file) {
    boolean result = true;
    PostMethod filePost = new PostMethod (preference.getDmsUrl ());
    try {
        filePost.getParams ().setBooleanParameter (HttpMethodParams.USE_EXPECT_CONTINUE, true);
        Part [] parts = {new FilePart ("upload", file)};
        filePost.setRequestEntity (new MultipartRequestEntity (parts, filePost.getParams ()));
        HttpClient client = new HttpClient ();
        client.getHttpConnectionManager ().getParams ().setConnectionTimeout (5000);
        int status = client.executeMethod (filePost);
        if (status == HttpStatus.SC_OK) {
            System.out.println ("Upload success");
        }
        else {
            result = false;
            System.out.println ("Upload failed");
        }
    } catch (Exception e) {
        result = false;
        e.printStackTrace ();
    } finally {
        if (filePost != null) {
            filePost.releaseConnection ();
        }
    }
    return result;
}


public static void compressFile (ZipOutputStream zos, File file, String dir) throws IOException {
    if (file.isDirectory ()) {
        File [] fs = file.listFiles ();
        for (File f : fs) {
            if (! dir.equals ("")) {
                compressFile (zos, f, dir + "\\" + file.getName ());
            }
            else {
                compressFile (zos, f, file.getName ());
            }
        }
    }
    else {
        String entryName = null;
        if (! dir.equals ("")) {
            entryName = dir + "\\" + file.getName ();
        }
        else {
            entryName = file.getName ();
        }
        ZipEntry entry = new ZipEntry (entryName);
        zos.putNextEntry (entry);
        InputStream is = new FileInputStream (file);
        int len = 0;
        while ((len = is.read ()) != - 1) {
            zos.write (len);
        }
        is.close ();
    }
}


-----Function Pair=171=-----==

public static String [] parseColumn (File file, int index) {
    ArrayList al = new ArrayList ();
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line;
        String [] tokens;
        while ((line = in.readLine ()) != null) {
            tokens = line.split ("\\t");
            if (tokens.length <= index) al.add ("");
            else al.add (tokens [index].trim ());
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        Misc.printExit ("\nError: problem parsing matcher file, aborting.\n");
    }
    String [] col = new String [al.size ()];
    al.toArray (col);
    return col;
}


public String getZipChildName (String unZipfileName) {
    StringBuffer rtn = new StringBuffer ();
    try {
        this.zipFile = new ZipFile (unZipfileName);
        String fullName = "";
        for (Enumeration entries = this.zipFile.getEntries (); entries.hasMoreElements ();) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            if (! entry.isDirectory ()) {
                fullName = entry.getName ();
                fullName = fullName.substring (fullName.indexOf ("/") + 1);
                rtn.append (",").append (fullName);
            }
        }
        this.zipFile.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    return rtn.toString ().substring (1);
}


-----Function Pair=172=-----==

public static boolean zip (File [] filesToZip, File zipFile) {
    byte [] buf = new byte [2048];
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
        for (int i = 0; i < filesToZip.length; i ++) {
            FileInputStream in = new FileInputStream (filesToZip [i]);
            out.putNextEntry (new ZipEntry (filesToZip [i].getName ()));
            int len;
            while ((len = in.read (buf)) != - 1) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
        System.err.println ("Can't zip()");
        e.printStackTrace ();
        return false;
    }
    return true;
}


private static String extractXMLInfo (File file) {
    String result = "";
    TransformerFactory factory2 = TransformerFactory.newInstance ();
    Source source = new StreamSource (new StringReader (XSLFILTER));
    try {
        Transformer f = factory2.newTransformer (source);
        StringWriter stringWriter = new StringWriter ();
        StreamResult outputTarget = new StreamResult (stringWriter);
        XMLReader xmlReader = XMLReaderFactory.createXMLReader ();
        xmlReader.setEntityResolver (new EntityResolver () {
            public InputSource resolveEntity (String publicId, String systemId) throws SAXException, IOException {
                return new InputSource (new StringReader ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>"));
            }
        }
        );
        SAXSource source1 = new SAXSource (xmlReader, new InputSource (new FileInputStream (file)));
        f.transform (source1, outputTarget);
        result = stringWriter.toString ().trim ();
    } catch (Exception e) {
        System.err.println ("problem reading information for" + file.getAbsolutePath ());
        e.printStackTrace ();
        result = "";
    }
    return result;
}


-----Function Pair=173=-----==

public static String unzip (File zipSrc, String destination) {
    try {
        ZipEntry entry;
        ZipFile zipfile = new ZipFile (zipSrc);
        Enumeration e = zipfile.entries ();
        (new File (destination)).mkdirs ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            if (entry.isDirectory ()) (new File (destination + File.separator + entry.getName ())).mkdirs ();
            else {
                File entryFile = new File (destination + File.separator + entry.getName ());
                entryFile.getParentFile ().mkdirs ();
                entryFile.createNewFile ();
                Streamer.bufferedStreamCopy (zipfile.getInputStream (entry), new FileOutputStream (entryFile));
            }
        }
        return zipfile.entries ().nextElement ().getName ();
    } catch (IOException e) {
        e.printStackTrace ();
        logger.error (e.getLocalizedMessage ());
        return "";
    }
}


public static Collection transformList (Collection toTransform, String...methodName) {
    List transformed = new LinkedList ();
    try {
        if (toTransform == null || toTransform.size () == 0) return toTransform;
        for (Object o : toTransform) {
            Object result = o;
            if (methodName == null) {
                result = o.toString ();
            }
            else {
                for (String theMethodName : methodName) {
                    Method method;
                    method = result.getClass ().getMethod (theMethodName);
                    result = method.invoke (result);
                }
            }
            transformed.add (result);
        }
        return transformed;
    } catch (Exception e) {
        return transformed;
    }
}


-----Function Pair=174=-----==

protected void restoreAbsoluteLinks (ShapesContainer sc, File f) throws IOException {
    for (Iterator it = sc.iterator (); it.hasNext ();) {
        try {
            AbstractShape abs = (AbstractShape) it.next ();
            abs.addListener ((ShapeListener) sc.getComponent ());
            if (! (abs instanceof Linkable)) {
                continue;
            }
            Linkable l = (Linkable) abs;
            File parent = f.getParentFile ();
            if (parent == null) {
                parent = new File ("./");
            }
            String link = l.getLink ();
            if ((link != null) && (! link.equals (""))) {
                File nl = new File (parent, link);
                l.setLink (nl.getCanonicalPath ());
            }
        } catch (ClassCastException cce) {
        }
    }
}


private static void createJarFilesWith (ZipOutputStream out, List < String > filesFullPath) {
    byte [] data = new byte [COMPRESS_OUTPUTSTREAM_BUFFER_SIZE];
    BufferedInputStream origin = null;
    int counter = 0;
    for (Iterator < ? > i = filesFullPath.iterator (); i.hasNext ();) {
        String filename = (String) i.next ();
        try {
            addFileToJar (origin, out, data, filename);
            counter ++;
        } catch (FileNotFoundException e) {
            logger.error ("File '" + filename + "' couldn't be added to jar file because it doesn't exist file.", e);
        } catch (IOException e1) {
            logger.error ("File '" + filename + "' couldn't be added to jar file cause of an input/ouput error.", e1);
        }
    }
    try {
        out.close ();
        logger.debug ("Zip file was created and '" + counter + "' files was added succesfully.");
    } catch (IOException e) {
        logger.error ("Zip file couldn't be closed correctly cause by a input / output error.");
    }
}


-----Function Pair=175=-----==

private void dailyRollOver () {
    if (datePattern == null) {
        errorHandler.error ("Missing DatePattern option in rollOver().");
        return;
    }
    String datedFilename = fileName + sdf.format (now);
    initLogPath (datedFilename);
    if (scheduledFilename.equals (datedFilename)) {
        return;
    }
    this.closeFile ();
    if (compress) {
        Thread thZip = new Thread (new ZipLogFiles ());
        thZip.start ();
    }
    File target = new File (scheduledFilename);
    if (target.exists ()) {
        target.delete ();
    }
    File file = new File (fileName);
    boolean result = file.renameTo (target);
    if (result) {
        LogLog.debug (fileName + " -> " + scheduledFilename);
    }
    else {
        LogLog.error ("Failed to rename [" + fileName + "] to [" + scheduledFilename + "].");
    }
    try {
        this.setFile (fileName, true, this.bufferedIO, this.bufferSize);
    } catch (IOException e) {
        errorHandler.error ("setFile(" + fileName + ", true) call failed.");
    }
    scheduledFilename = datedFilename;
}


public static String get_ssl_header (String s) throws Exception {
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault ();
    SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket ("www.google.com", 443);
    PrintStream outStream = new PrintStream (sslsocket.getOutputStream ());
    outStream.println (s);
    outStream.flush ();
    DataInputStream inStream = new DataInputStream (sslsocket.getInputStream ());
    StringBuffer stb = new StringBuffer ();
    int ch = ' ';
    for (ch = inStream.read (); ch > 0; ch = inStream.read ()) {
        stb.append ((char) ch);
        if (stb.indexOf ("\r\n\r\n") > - 1) break;
    }
    inStream.close ();
    outStream.close ();
    sslsocket.close ();
    return stb.toString ();
}


-----Function Pair=176=-----==

public void run () {
    try {
        FileOutputStream fos = new FileOutputStream (file + ".zip");
        BufferedOutputStream bos = new BufferedOutputStream (fos);
        ZipOutputStream zos = new ZipOutputStream (bos);
        File inFile = new File (file);
        FileInputStream fis = new FileInputStream (inFile);
        BufferedInputStream bis = new BufferedInputStream (fis);
        ZipEntry zipEntry = new ZipEntry (inFile.getName ());
        zipEntry.setMethod (ZipEntry.DEFLATED);
        zos.putNextEntry (zipEntry);
        byte [] buffer = new byte [BUFFER];
        int length;
        while ((length = bis.read (buffer)) != - 1) {
            zos.write (buffer, 0, length);
        }
        zos.closeEntry ();
        zos.close ();
        bis.close ();
        if (new File (file).exists ()) {
            boolean isDel = new File (file).delete ();
            if (isDel) _LOG (file + " 파일을 삭제 했습니다.");
            else _LOG (file + " 파일을 삭제하지 못 했습니다.");
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


public String getDataFileName (String xml) throws Exception {
    if (xml == null) throw new Exception ("Null volume xml");
    VolumeTimeSeries retvol = null;
    ByteArrayInputStream bais = new ByteArrayInputStream (xml.getBytes ());
    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance ();
    DocumentBuilder builder = builderFactory.newDocumentBuilder ();
    Document doc = builder.parse (bais);
    NodeList list = doc.getElementsByTagName ("QVIIVOLUMETIMESERIES");
    if (list.getLength () < 1) throw new Exception ("QVIIVOLUMETIMESERIES element not found");
    Element rootel = (Element) list.item (0);
    list = rootel.getElementsByTagName ("VOLUME");
    if (list.getLength () < 1) throw new Exception ("VOLUME element not found");
    Element volel = (Element) list.item (0);
    return volel.getAttribute ("datafile");
}


-----Function Pair=177=-----==

public static File [] extractFiles (File directory) {
    File [] files = null;
    String [] fileNames;
    if (directory.isDirectory ()) {
        fileNames = directory.list ();
        int num = fileNames.length;
        ArrayList < File > al = new ArrayList < File > ();
        try {
            String path = directory.getCanonicalPath ();
            Pattern pat = Pattern.compile ("^\\w+.*");
            Matcher mat;
            for (int i = 0; i < num; i ++) {
                mat = pat.matcher (fileNames [i]);
                if (mat.matches ()) al.add (new File (path, fileNames [i]));
            }
            if (al.size () != 0) {
                files = new File [al.size ()];
                al.toArray (files);
            }
        } catch (IOException e) {
            System.out.println ("Problem extractFiles() " + directory);
            e.printStackTrace ();
            return null;
        }
    }
    if (files == null) {
        files = new File [1];
        files [0] = directory;
    }
    Arrays.sort (files);
    return files;
}


public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


-----Function Pair=178=-----==

public static PositionTextData merge (ArrayList < PositionTextData > pdAL) {
    PositionTextData [] pdArray = new PositionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionTexts.length;
    PositionText [] concatinate = new PositionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionText [] slice = pdArray [i].sortedPositionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionTextData (concatinate, sliceInfo);
}


private Reply doSend (ConsignJob request, PortfolioTh [] portfolios) throws Connection.Exception {
    if (portfolios == null) return doSend (request);
    try {
        if (output == null) {
            output = new ObjectOutputStream (socket.getOutputStream ());
        }
        output.reset ();
        output.writeObject (request);
        output.flush ();
        ZipOutputStream zos = getDataOutputStream ();
        for (int i = 0; i < portfolios.length; i ++) {
            String dir_name = portfolios [i].getPortfolio ().getUPLDirectoryName () + "/";
            for (int j = 0; j < portfolios [i].getFiles ().length; j ++) {
                if (portfolios [i].getFiles () [j].exists ()) {
                    String name;
                    if (portfolios [i].getDestinationNames () == null) {
                        name = portfolios [i].getFiles () [j].getName ();
                    }
                    else {
                        name = portfolios [i].getDestinationNames () [j];
                    }
                    transferFiles (dir_name, portfolios [i].getFiles () [j], name, zos);
                }
                else {
                    CLogger.status ("Adding no overwrite marker to stream <" + dir_name + "> " + portfolios [i].getFiles () [j].getName ());
                    ZipEntry marker = new ZipEntry (dir_name);
                    marker.setExtra (new byte [1]);
                    zos.putNextEntry (marker);
                    zos.closeEntry ();
                }
            }
        }
        CLogger.status ("Done sending streamed");
        doneWithDataOutputStream ();
        return (Reply) getObjectInputStream ().readObject ();
    } catch (java.lang.Exception ex) {
        _close ();
        throw new Connection.Exception ("Error sending Request with streamed: " + ex.getMessage ());
    }
}


-----Function Pair=179=-----==

public static File [] extractFiles (File dirOrFile, String extension) {
    if (dirOrFile == null) return null;
    File [] files = null;
    Pattern p = Pattern.compile (".*" + extension + "$", Pattern.CASE_INSENSITIVE);
    Matcher m;
    if (dirOrFile.isDirectory ()) {
        files = dirOrFile.listFiles ();
        int num = files.length;
        ArrayList < File > chromFiles = new ArrayList < File > ();
        for (int i = 0; i < num; i ++) {
            m = p.matcher (files [i].getName ());
            if (m.matches ()) chromFiles.add (files [i]);
        }
        files = new File [chromFiles.size ()];
        chromFiles.toArray (files);
    }
    else {
        m = p.matcher (dirOrFile.getName ());
        if (m.matches ()) {
            files = new File [1];
            files [0] = dirOrFile;
        }
    }
    if (files != null) Arrays.sort (files);
    return files;
}


public void actionPerformed (ActionEvent ae) {
    JFileChooser choix = new JFileChooser ();
    choix.setFileFilter (new MyFileFilter ("zip"));
    choix.setFileSelectionMode (JFileChooser.FILES_ONLY);
    choix.showSaveDialog (choix);
    File file = choix.getSelectedFile ();
    if (file != null) {
        Database e = new Database ();
        for (int i = 0; i < filmsSelect.size (); i ++) {
            try {
                e.add (((DataRecord) filmsSelect.get (i)).getData ());
            } catch (MEMOexception me) {
                me.printStackTrace ();
            }
        }
        File f = new File ("Base.xml");
        e.saveAs (f);
        try {
            ajouterAuZip (file.getAbsolutePath () + ".zip", filmsSelect, nbFilm);
        } catch (FileNotFoundException e1) {
            e1.printStackTrace ();
        }
        f.delete ();
        dispose ();
    }
}


-----Function Pair=180=-----==

private List addFeaturesToList (String siteXML, List featureList, IIncludedFeatureReference [] iIncludedFeatureReferences, Map availableLocales, Map perFeatureLocales) throws CoreException {
    String directoryName = (new File (siteXML)).getParent ();
    if (! directoryName.endsWith (File.separator)) {
        directoryName = directoryName + File.separator;
    }
    directoryName = directoryName + "features" + File.separator;
    for (int i = 0; i < iIncludedFeatureReferences.length; i ++) {
        String featureURL = directoryName + iIncludedFeatureReferences [i].getVersionedIdentifier () + ".jar";
        if (! (isFeatureAlreadyInList (featureList, featureURL))) {
            try {
                System.out.println ("Extracting locales from included feature " + featureURL);
                processLocalesInJar (availableLocales, featureURL, perFeatureLocales, true);
            } catch (IOException e) {
                if (iIncludedFeatureReferences [i].isOptional ()) continue;
                System.out.println ("Error while extracting locales from included feature " + featureURL);
                e.printStackTrace ();
                throw new CoreException (new Status (IStatus.ERROR, "", IStatus.OK, "Error while extracting locales from included feature " + featureURL, e));
            }
            featureList.add (featureURL);
        }
    }
    return featureList;
}


public static void appendFile (String namePrefix, File baseDir, File file, ZipOutputStream zipOut) throws IOException {
    Assert.Arg.notNull (baseDir, "baseDir");
    Assert.Arg.notNull (file, "file");
    Assert.Arg.notNull (zipOut, "zipOut");
    if (namePrefix == null) namePrefix = "";
    String path = FileSystemUtils.getRelativePath (baseDir, file);
    ZipEntry zipEntry = new ZipEntry (namePrefix + path);
    zipOut.putNextEntry (zipEntry);
    InputStream fileInput = FileUtils.openInputStream (file);
    try {
        org.apache.commons.io.IOUtils.copyLarge (fileInput, zipOut);
    } finally {
        fileInput.close ();
    }
}


-----Function Pair=181=-----==

public void read (DataInputStream dis) {
    try {
        header = dis.readUTF ();
        int numberPositions = sliceInfo.getNumberRecords ();
        sortedPositionTexts = new PositionText [numberPositions];
        sortedPositionTexts [0] = new PositionText (dis.readInt (), dis.readUTF ());
        String fileType = sliceInfo.getBinaryType ();
        if (USeqUtilities.POSITION_TEXT_INT_TEXT.matcher (fileType).matches ()) {
            for (int i = 1; i < numberPositions; i ++) {
                sortedPositionTexts [i] = new PositionText (sortedPositionTexts [i - 1].position + dis.readInt (), dis.readUTF ());
            }
        }
        else if (USeqUtilities.POSITION_TEXT_SHORT_TEXT.matcher (fileType).matches ()) {
            for (int i = 1; i < numberPositions; i ++) {
                sortedPositionTexts [i] = new PositionText (sortedPositionTexts [i - 1].position + dis.readShort () + 32768, dis.readUTF ());
            }
        }
        else {
            throw new IOException ("Incorrect file type for creating a PositionText[] -> '" + fileType + "' in " + binaryFile + "\n");
        }
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (dis);
    }
}


private byte [] setServerProperty (HTTPurl urlData) throws Exception {
    String out = "";
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String [] parameter = urlData.getParameterList ();
    for (int x = 0; x < parameter.length; x ++) {
        if (! parameter [x].equals ("action") && ! parameter [x].equals ("sessionID")) {
            String value = urlData.getParameter (parameter [x]);
            if (value != null) {
                store.setServerProperty (parameter [x], value);
            }
        }
    }
    return out.getBytes ();
}


-----Function Pair=182=-----==

public static int zip (Resource resource, List names, OutputStream out) throws IOException {
    ZipOutputStream zip;
    InputStream in;
    Iterator i;
    String s;
    byte [] buf;
    int n;
    int u;
    if (out instanceof ZipOutputStream) {
        zip = (ZipOutputStream) out;
    }
    else {
        zip = new ZipOutputStream (out);
    }
    buf = new byte [BUFFER_SIZE];
    for (u = 0, i = names.iterator (); i.hasNext ();) {
        s = (String) i.next ();
        in = resource.getInputStream (s);
        if (in == null) {
            continue;
        }
        zip.putNextEntry (new ZipEntry (s));
        u ++;
        while ((n = in.read (buf)) > 0) {
            zip.write (buf, 0, n);
        }
        in.close ();
        zip.closeEntry ();
    }
    if (u > 0) {
        zip.finish ();
    }
    return u;
}


void initManifest () {
    isoSamples = samplePackage.getSamples ();
    files = SampleContextMacros.extractFiles (isoSamples);
    sourceIndexes = SampleContextMacros.extractIndexes (isoSamples);
    ZUtilities.prefixPath (files, packageLocation);
    nonNullFileCount = files.length - ZUtilities.numNulls (files);
    file2SrcIndexMap = new TreeMap ();
    for (int i = 0; i < isoSamples.length; i ++) if (files [i] != null) file2SrcIndexMap.put (files [i], sourceIndexes [i]);
    nonNullFiles = (File []) file2SrcIndexMap.keySet ().toArray (new File [file2SrcIndexMap.keySet ().size ()]);
    nonNullValidFiles = ZUtilities.filesThatExist (nonNullFiles);
    nonNullValidFileCount = nonNullValidFiles.length;
    ArrayList missing = new ArrayList ();
    for (int i = 0; i < files.length; i ++) if (files [i] != null && ! files [i].exists ()) missing.add (isoSamples [i]);
    this.missing = (IsolatedSample []) missing.toArray (new IsolatedSample [missing.size ()]);
}


-----Function Pair=183=-----==

private static boObject getDocument (boObject object, String [] docTree, String bridge) throws boRuntimeException {
    int treeSize = docTree.length;
    int treeIndex = 0;
    bridgeHandler bHandler = object.getBridge (bridge);
    bHandler.beforeFirst ();
    while (bHandler.next ()) {
        boObject objHandler = bHandler.getObject ();
        if ("Ebo_Folder".equals (objHandler.getBoDefinition ().getName ())) {
            if (objHandler.getAttribute ("description").getValueString ().equals (docTree [treeIndex])) {
                treeIndex ++;
                String [] subDocTree = new String [treeSize - 1];
                System.arraycopy (docTree, treeIndex, subDocTree, 0, treeSize - 1);
                if (subDocTree.length > 0) {
                    return getDocument (objHandler, subDocTree, "details");
                }
                else {
                    return objHandler;
                }
            }
        }
    }
    return object;
}


protected final void includeClass (String className) throws BuildException {
    String osPath = className.replace ('.', File.separatorChar) + ".class";
    String urlPath = className.replace ('.', '/') + ".class";
    for (int i = 0; i < classpathFileList.length; ++ i) {
        File cpBase = classpathFileList [i];
        if (! cpBase.exists ()) continue;
        if (cpBase.isDirectory ()) {
            File testFile = fileUtils.resolveFile (cpBase, osPath);
            if (testFile.exists ()) {
                FileSet fileSet = new FileSet ();
                fileSet.setDir (cpBase);
                fileSet.setIncludes (osPath);
                super.addFileset (fileSet);
                return;
            }
            continue;
        }
        if (cpBase.isFile ()) {
            if (classpathZipList [i] == null) {
                try {
                    classpathZipList [i] = new ZipFile (cpBase);
                } catch (IOException ioe) {
                    classpathZipList [i] = null;
                    continue;
                }
            }
            if (classpathZipList [i].getEntry (urlPath) != null) {
                ZipFileSet zipFileSet = new ZipFileSet ();
                zipFileSet.setSrc (classpathFileList [i]);
                zipFileSet.setIncludes (urlPath);
                super.addZipfileset (zipFileSet);
                return;
            }
            continue;
        }
    }
    throw new BuildException ("Cannot locate class in classpath: " + className);
}


-----Function Pair=184=-----==

public static void unZip (String unZipfileName, String outputDirectory) throws IOException, FileNotFoundException {
    FileOutputStream fileOut;
    File file;
    ZipEntry zipEntry;
    ZipInputStream zipIn = new ZipInputStream (new BufferedInputStream (new FileInputStream (unZipfileName)), encoder);
    while ((zipEntry = zipIn.getNextEntry ()) != null) {
        file = new File (outputDirectory + File.separator + zipEntry.getName ());
        if (zipEntry.isDirectory ()) {
            createDirectory (file.getPath (), "");
        }
        else {
            File parent = file.getParentFile ();
            if (! parent.exists ()) {
                createDirectory (parent.getPath (), "");
            }
            fileOut = new FileOutputStream (file);
            int readedBytes;
            while ((readedBytes = zipIn.read (buf)) > 0) {
                fileOut.write (buf, 0, readedBytes);
            }
            fileOut.close ();
        }
        zipIn.closeEntry ();
    }
}


public static void addFileToZipFile (final String zipFileName, final String nameOfFileToAdd, final String pathToFileInZipFile) throws IOException {
    final File zipFile = new File (zipFileName);
    final String oldZipFileName = zipFileName + ".old";
    final File oldZipFile = new File (oldZipFileName);
    renameFile (zipFile, oldZipFile);
    final File newZipFile = new File (zipFileName);
    boolean copyCompleted = false;
    boolean fileClosingCompleted = false;
    try {
        ZipFile fromZip = null;
        ZipOutputStream toZipOutputStream = null;
        try {
            fromZip = new ZipFile (oldZipFile);
            toZipOutputStream = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (newZipFile)));
            final byte [] copyBuffer = new byte [10240];
            addFileToZip (nameOfFileToAdd, pathToFileInZipFile, toZipOutputStream, copyBuffer);
            copyExistingZipFiles (fromZip, toZipOutputStream, pathToFileInZipFile, copyBuffer);
            copyCompleted = true;
        } finally {
            if (fromZip != null) {
                fromZip.close ();
                fromZip = null;
            }
            if (toZipOutputStream != null) {
                toZipOutputStream.close ();
                toZipOutputStream = null;
            }
            fileClosingCompleted = true;
        }
    } finally {
        if (copyCompleted && fileClosingCompleted) {
            deleteFile (oldZipFile);
        }
        else {
            try {
                deleteFile (newZipFile);
                renameFile (oldZipFile, zipFile);
            } catch (final IOException e) {
            }
        }
    }
}


-----Function Pair=185=-----==

public static Site GetSite (NpsContext ctxt, ZipFile file, User importer) throws Exception {
    Site asite = null;
    try {
        Unit aunit = Unit.GetUnit (ctxt.GetConnection (), file);
        if (aunit == null) throw new NpsException (ErrorHelper.ZIP_NOUNIT);
        asite = GetSite (file, aunit);
        if (asite == null) throw new NpsException (ErrorHelper.ZIP_NOSITE);
        if (ctxt.GetSite (asite.id) != null) asite.Save (ctxt, false);
        else asite.Save (ctxt, true);
        Hashtable templates_indexby_oldid = asite.GetTemplates (ctxt, file, asite, importer);
        asite.topic_tree = TopicTree.LoadTree (ctxt, asite, templates_indexby_oldid, file);
    } catch (Exception e1) {
        asite = null;
        com.microfly.util.DefaultLog.error (e1);
    }
    try {
        if (asite != null && asite.GetTopicTree () != null) asite.GetTopicTree ().CreateDsTable (ctxt);
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    }
    return asite;
}


public static void replaceTemplateVariables (Writer writer, Reader reader, Map < String, String > variables) throws IOException {
    StreamTokenizer stk = new StreamTokenizer (reader);
    stk.resetSyntax ();
    stk.wordChars (0, Integer.MAX_VALUE);
    stk.ordinaryChar ('$');
    stk.ordinaryChar ('{');
    stk.ordinaryChar ('}');
    stk.ordinaryChar ('\n');
    String variableName = null;
    StringBuffer tmpBuf = new StringBuffer ();
    ParserExpects parserExpects = ParserExpects.NORMAL;
    while (stk.nextToken () != StreamTokenizer.TT_EOF) {
        String stringToWrite = null;
        if (stk.ttype == StreamTokenizer.TT_WORD) {
            switch (parserExpects) {
                case VARIABLE :
                    parserExpects = ParserExpects.BRACKET_CLOSE;
                    variableName = stk.sval;
                    tmpBuf.append (variableName);
                    break;
                case NORMAL :
                    stringToWrite = stk.sval;
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + stk.sval;
                    tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '\n') {
            stringToWrite = new String (new char [] {(char) stk.ttype});
            if (parserExpects != ParserExpects.NORMAL) {
                parserExpects = ParserExpects.NORMAL;
                stringToWrite = tmpBuf.toString () + stringToWrite;
                tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '$') {
            if (parserExpects != ParserExpects.NORMAL) {
                stringToWrite = tmpBuf.toString ();
                tmpBuf.setLength (0);
            }
            tmpBuf.append ((char) stk.ttype);
            parserExpects = ParserExpects.BRACKET_OPEN;
        }
        else if (stk.ttype == '{') {
            switch (parserExpects) {
                case NORMAL :
                    stringToWrite = new String (new char [] {(char) stk.ttype});
                    break;
                case BRACKET_OPEN :
                    tmpBuf.append ((char) stk.ttype);
                    parserExpects = ParserExpects.VARIABLE;
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + (char) stk.ttype;
                    tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '}') {
            switch (parserExpects) {
                case NORMAL :
                    stringToWrite = new String (new char [] {(char) stk.ttype});
                    break;
                case BRACKET_CLOSE :
                    parserExpects = ParserExpects.NORMAL;
                    tmpBuf.append ((char) stk.ttype);
                    if (variableName == null) throw new IllegalStateException ("variableName is null!!!");
                    stringToWrite = variables.get (variableName);
                    if (stringToWrite == null) {
                        logger.warn ("Variable " + tmpBuf.toString () + " occuring in template is unknown!");
                        stringToWrite = tmpBuf.toString ();
                    }
                    tmpBuf.setLength (0);
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + (char) stk.ttype;
                    tmpBuf.setLength (0);
            }
        }
        if (stringToWrite != null) writer.write (stringToWrite);
    }
}


-----Function Pair=186=-----==

public static boolean isZipFile (File file) throws IOException {
    final byte [] sig = new byte [] {0x50, 0x4B, 0x3, 0x4};
    if (file != null && file.canRead ()) {
        byte [] buf = new byte [4];
        FileInputStream is = null;
        try {
            is = new FileInputStream (file);
            is.read (buf);
        } finally {
            if (is != null) {
                is.close ();
            }
        }
        for (int i = 0; i < buf.length; i ++) {
            if (buf [i] != sig [i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}


private void writeQuadrilateral (GeometryArray geometryArray, int vertexIndex1, int vertexIndex2, int vertexIndex3, int vertexIndex4, int [] vertexIndexSubstitutes, int [] normalIndexSubstitutes, int [] textureCoordinatesIndexSubstitutes, boolean textureCoordinatesGenerated) throws IOException {
    if (textureCoordinatesGenerated || (geometryArray.getVertexFormat () & GeometryArray.TEXTURE_COORDINATE_2) != 0) {
        if ((geometryArray.getVertexFormat () & GeometryArray.NORMALS) != 0) {
            this.out.write ("f " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex1]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex1]) + "/" + (this.normalOffset + normalIndexSubstitutes [vertexIndex1]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex2]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex2]) + "/" + (this.normalOffset + normalIndexSubstitutes [vertexIndex2]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex3]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex3]) + "/" + (this.normalOffset + normalIndexSubstitutes [vertexIndex3]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex4]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex4]) + "/" + (this.normalOffset + normalIndexSubstitutes [vertexIndex4]) + "\n");
        }
        else {
            this.out.write ("f " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex1]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex1]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex2]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex2]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex3]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex3]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex4]) + "/" + (this.textureCoordinatesOffset + textureCoordinatesIndexSubstitutes [vertexIndex4]) + "\n");
        }
    }
    else {
        if ((geometryArray.getVertexFormat () & GeometryArray.NORMALS) != 0) {
            this.out.write ("f " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex1]) + "//" + (this.normalOffset + normalIndexSubstitutes [vertexIndex1]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex2]) + "//" + (this.normalOffset + normalIndexSubstitutes [vertexIndex2]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex3]) + "//" + (this.normalOffset + normalIndexSubstitutes [vertexIndex3]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex4]) + "//" + (this.normalOffset + normalIndexSubstitutes [vertexIndex4]) + "\n");
        }
        else {
            this.out.write ("f " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex1]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex2]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex3]) + " " + (this.vertexOffset + vertexIndexSubstitutes [vertexIndex4]) + "\n");
        }
    }
}


-----Function Pair=187=-----==

public File createArchiveFile (String archiveType, IModule module, List < IModuleResource > resources, IProgressMonitor monitor) throws IOException {
    String suffix = ".zip";
    if (archiveType.equalsIgnoreCase ("zip")) {
        suffix = ".zip";
    }
    else if (archiveType.equalsIgnoreCase ("jar")) {
        suffix = ".jar";
    }
    if (monitor == null) monitor = new NullProgressMonitor ();
    String tempDir = System.getProperty ("java.io.tmpdir");
    File tempFile = new File (tempDir, module.getName () + suffix);
    FileOutputStream fileOutput = new FileOutputStream (tempFile);
    ZipOutputStream zipOutput = new ZipOutputStream (fileOutput);
    try {
        writeResourcesToZipFile (module, resources.toArray (new IModuleResource [0]), zipOutput);
    } finally {
        zipOutput.close ();
    }
    return tempFile;
}


private void addFileToZip (final File file, final ZipOutputStream zipOutputStream) {
    if (file.exists ()) {
        InputStream in = null;
        try {
            in = new BufferedInputStream (new FileInputStream (file));
            final ZipEntry ze = new ZipEntry (File.separator + file.getName ());
            ze.setTime (file.lastModified ());
            zipOutputStream.putNextEntry (ze);
            final byte [] buf = new byte [8192];
            int len;
            while ((len = in.read (buf)) > 0) {
                zipOutputStream.write (buf, 0, len);
            }
        } catch (final IOException ioe) {
            log.error ("addFileToZip : IO failure : ", ioe);
        } finally {
            try {
                zipOutputStream.closeEntry ();
                if (in != null) {
                    in.close ();
                }
            } catch (final IOException ioe) {
                log.error ("addFileToZip : IO close error : ", ioe);
            }
        }
    }
}


-----Function Pair=188=-----==

public void getNext (HTTPurl urlData, HashMap < String, String > headers, OutputStream out) throws Exception {
    XmlDoc xmlDoc = new XmlDoc ("schedule_next");
    ScheduleItem [] itemsArray = store.getScheduleArray ();
    Arrays.sort (itemsArray);
    Vector < ScheduleItem > nextItems = new Vector < ScheduleItem > ();
    ScheduleItem firstNext = null;
    for (int x = 0; x < itemsArray.length; x ++) {
        if (nextItems.size () == 0 && itemsArray [x].getState () == ScheduleItem.WAITING && itemsArray [x].getStop ().getTime () > new Date ().getTime ()) {
            firstNext = itemsArray [x];
            nextItems.add (itemsArray [x]);
        }
        else if (firstNext != null && itemsArray [x].getState () == ScheduleItem.WAITING && itemsArray [x].getStart ().getTime () < firstNext.getStop ().getTime ()) {
            nextItems.add (itemsArray [x]);
        }
    }
    for (int x = 0; x < nextItems.size (); x ++) {
        ScheduleItem next = nextItems.get (x);
        Element sch = xmlDoc.createElement ("schedule");
        addSchedule2Doc (xmlDoc, sch, next, false);
        xmlDoc.getRoot ().appendChild (sch);
    }
    out.write (xmlDoc.getDocBytes ());
}


private void addAllUploadedFiles (Environment en, ZipOutputStream zipout, int progressStart, int progressLength) throws IOException, FileNotFoundException {
    File uploadPath = en.uploadPath (virtualWiki, "");
    String [] files = uploadPath.list ();
    int bytesRead = 0;
    byte byteArray [] = new byte [4096];
    for (int i = 0; i < files.length; i ++) {
        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / (double) files.length), 99);
        logger.debug ("Adding uploaded file " + files [i]);
        ZipEntry entry = new ZipEntry (safename (files [i]));
        try {
            FileInputStream in = new FileInputStream (en.uploadPath (virtualWiki, files [i]));
            zipout.putNextEntry (entry);
            while (in.available () > 0) {
                bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
                zipout.write (byteArray, 0, bytesRead);
            }
            zipout.closeEntry ();
            zipout.flush ();
        } catch (FileNotFoundException e) {
            logger.warn ("Could not open file!", e);
        } catch (IOException e) {
            logger.warn ("IOException!", e);
            try {
                zipout.closeEntry ();
                zipout.flush ();
            } catch (IOException e1) {
            }
        }
    }
}


-----Function Pair=189=-----==

public static String getDateTime (Date date) {
    GregorianCalendar calendar = new GregorianCalendar ();
    calendar.setTime (date);
    calendar.setTimeZone (SimpleTimeZone.getTimeZone ("GMT"));
    StringBuffer buf = new StringBuffer ("");
    buf.append (calendar.get (Calendar.YEAR));
    if (calendar.get (Calendar.MONTH) < 9) {
        buf.append ("0");
    }
    buf.append (calendar.get (Calendar.MONTH) + 1);
    if (calendar.get (Calendar.DAY_OF_MONTH) < 10) {
        buf.append ("0");
    }
    buf.append (calendar.get (Calendar.DAY_OF_MONTH));
    buf.append ("-");
    if (calendar.get (Calendar.HOUR_OF_DAY) < 10) {
        buf.append ("0");
    }
    buf.append (calendar.get (Calendar.HOUR_OF_DAY));
    if (calendar.get (Calendar.MINUTE) < 10) {
        buf.append ("0");
    }
    buf.append (calendar.get (Calendar.MINUTE));
    return buf.toString ();
}


private boolean deleteDestination (File destination) {
    if (! destination.canWrite ()) {
        return false;
    }
    if (destination.isFile ()) {
        return destination.delete ();
    }
    File [] children = destination.listFiles ();
    for (int i = 0; i < children.length; i ++) {
        if (! deleteDestination (children [i])) {
            return false;
        }
    }
    return destination.delete ();
}


-----Function Pair=190=-----==

public static Date getDateTime (String parseDate) {
    try {
        int i = 0;
        int year = Integer.parseInt (parseDate.substring (i, i += 4));
        int month = Integer.parseInt (parseDate.substring (i, i += 2)) - 1;
        int day = Integer.parseInt (parseDate.substring (i, i += 2));
        i ++;
        int hour = Integer.parseInt (parseDate.substring (i, i += 2));
        int minute = Integer.parseInt (parseDate.substring (i, i += 2));
        GregorianCalendar pope = new GregorianCalendar (year, month, day, hour, minute);
        pope.setTimeZone (SimpleTimeZone.getTimeZone ("GMT"));
        return pope.getTime ();
    } catch (Exception e) {
        return null;
    }
}


public static void zipComponent (String inPath, String outPath) {
    try {
        File directory = new File (inPath);
        File [] files = directory.listFiles ();
        byte [] buffer = new byte [1024];
        String outFilename = outPath + ".flw";
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < files.length; i ++) {
            FileInputStream in = new FileInputStream (files [i]);
            out.putNextEntry (new ZipEntry (files [i].getName ()));
            int len;
            while ((len = in.read (buffer)) > 0) {
                out.write (buffer, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=191=-----==

public static boolean copyFileCover (String srcFileName, String descFileName, boolean coverlay) {
    File srcFile = new File (srcFileName);
    if (! srcFile.exists ()) {
        System.out.println ("�����ļ�ʧ�ܣ�Դ�ļ�" + srcFileName + "������!");
        return false;
    }
    else if (! srcFile.isFile ()) {
        System.out.println ("�����ļ�ʧ�ܣ�" + srcFileName + "����һ���ļ�!");
        return false;
    }
    File descFile = new File (descFileName);
    if (descFile.exists ()) {
        if (coverlay) {
            System.out.println ("Ŀ���ļ��Ѵ��ڣ�׼��ɾ��!");
            if (! FileOperateUtils.delFile (descFileName)) {
                System.out.println ("ɾ��Ŀ���ļ�" + descFileName + "ʧ��!");
                return false;
            }
        }
        else {
            System.out.println ("�����ļ�ʧ�ܣ�Ŀ���ļ�" + descFileName + "�Ѵ���!");
            return false;
        }
    }
    else {
        if (! descFile.getParentFile ().exists ()) {
            System.out.println ("Ŀ���ļ����ڵ�Ŀ¼�����ڣ�����Ŀ¼!");
            if (! descFile.getParentFile ().mkdirs ()) {
                System.out.println ("����Ŀ���ļ����ڵ�Ŀ¼ʧ��!");
                return false;
            }
        }
    }
    int readByte = 0;
    InputStream ins = null;
    OutputStream outs = null;
    try {
        ins = new FileInputStream (srcFile);
        outs = new FileOutputStream (descFile);
        byte [] buf = new byte [1024];
        while ((readByte = ins.read (buf)) != - 1) {
            outs.write (buf, 0, readByte);
        }
        System.out.println ("���Ƶ����ļ�" + srcFileName + "��" + descFileName + "�ɹ�!");
        return true;
    } catch (Exception e) {
        System.out.println ("�����ļ�ʧ�ܣ�" + e.getMessage ());
        return false;
    } finally {
        if (outs != null) {
            try {
                outs.close ();
            } catch (IOException oute) {
                oute.printStackTrace ();
            }
        }
        if (ins != null) {
            try {
                ins.close ();
            } catch (IOException ine) {
                ine.printStackTrace ();
            }
        }
    }
}


public static File compress (String outputFilePath, List < File > files) {
    final int BUFFER = 2048;
    BufferedInputStream bufferedInputStream;
    File outputFile = new File (outputFilePath);
    try {
        FileUtils.touch (outputFile);
    } catch (IOException e) {
        logger.error ("create zip file fail.", e);
        throw new FileOperationException ("create zip file fail.", e);
    }
    FileOutputStream fileOutputStream = null;
    ZipOutputStream zipOutputStream = null;
    FileInputStream fileInputStream;
    try {
        fileOutputStream = new FileOutputStream (outputFilePath);
        zipOutputStream = new ZipOutputStream (new BufferedOutputStream (fileOutputStream));
        byte data [] = new byte [BUFFER];
        for (File file : files) {
            if (! file.exists ()) {
                continue;
            }
            fileInputStream = new FileInputStream (file);
            bufferedInputStream = new BufferedInputStream (fileInputStream, BUFFER);
            ZipEntry entry = new ZipEntry (file.getName ());
            entry.setSize (file.length ());
            entry.setTime (file.lastModified ());
            zipOutputStream.putNextEntry (entry);
            int count;
            while ((count = bufferedInputStream.read (data, 0, BUFFER)) != - 1) {
                zipOutputStream.write (data, 0, count);
            }
            zipOutputStream.closeEntry ();
            if (fileInputStream != null) fileInputStream.close ();
            if (bufferedInputStream != null) bufferedInputStream.close ();
        }
    } catch (FileNotFoundException e) {
        logger.error ("Can't find the output file.", e);
        throw new FileOperationException ("Can't find the output file.", e);
    } catch (IOException e) {
        logger.error ("Can't compress file to zip archive, occured IOException", e);
        throw new FileOperationException ("Can't compress file to zip archive, occured IOException", e);
    } finally {
        try {
            if (zipOutputStream != null) zipOutputStream.close ();
            if (fileOutputStream != null) fileOutputStream.close ();
        } catch (IOException e) {
            logger.error ("Close zipOutputStream and fileOutputStream occur IOException", e);
        }
    }
    return outputFile;
}


-----Function Pair=192=-----==

public boolean addEntry (File file) {
    if (file == null) {
        log.warning ("addEntry - No File");
        return false;
    }
    if (! file.exists () || file.isDirectory ()) {
        log.warning ("addEntry - not added - " + file + ", Exists=" + file.exists () + ", Directory=" + file.isDirectory ());
        return false;
    }
    log.fine ("addEntry - " + file);
    String name = file.getName ();
    byte [] data = null;
    try {
        FileInputStream fis = new FileInputStream (file);
        ByteArrayOutputStream os = new ByteArrayOutputStream ();
        byte [] buffer = new byte [1024 * 8];
        int length = - 1;
        while ((length = fis.read (buffer)) != - 1) {
            os.write (buffer, 0, length);
        }
        fis.close ();
        data = os.toByteArray ();
        os.close ();
    } catch (IOException ioe) {
        log.log (Level.SEVERE, "addEntry (file)", ioe);
    }
    return addEntry (name, data);
}


public static void batchUpdateCPUTimeLimit (List < ExperimentResult > v) throws SQLException {
    boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        final String query = "UPDATE " + table + " SET CPUTimeLimit=? WHERE idJob=?";
        PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
        curSt = st;
        for (ExperimentResult r : v) {
            st.setInt (1, r.getCPUTimeLimit ());
            st.setInt (2, r.getId ());
            st.addBatch ();
        }
        st.executeBatch ();
        st.close ();
    } catch (SQLException e) {
        DatabaseConnector.getInstance ().getConn ().rollback ();
        throw e;
    } finally {
        curSt = null;
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
    }
}


-----Function Pair=193=-----==

public void notifyChanged (Notification msg) {
    super.notifyChanged (msg);
    if (msg.getEventType () == Notification.ADD) {
        if (msg.getNewValue () instanceof IDiagramModelImageProvider) {
            IDiagramModelImageProvider imageProvider = (IDiagramModelImageProvider) msg.getNewValue ();
            String imagePath = imageProvider.getImagePath ();
            if (imagePath != null && ! fLoadedImagePaths.contains (imagePath)) {
                fLoadedImagePaths.add (imagePath);
            }
        }
    }
    else if (msg.getEventType () == Notification.SET) {
        if (msg.getFeature () == IArchimatePackage.Literals.DIAGRAM_MODEL_IMAGE_PROVIDER__IMAGE_PATH) {
            String imagePath = (String) msg.getNewValue ();
            if (imagePath != null && ! fLoadedImagePaths.contains (imagePath)) {
                fLoadedImagePaths.add (imagePath);
            }
        }
    }
}


private List < FileEx > getFileEx (List < FileEx > fileExs, String name) {
    final File dir = new File (org.yccheok.jstock.gui.Utils.getUserDataDirectory () + name);
    if (dir.isDirectory ()) {
        String [] children = dir.list ();
        for (String child : children) {
            getFileEx (fileExs, name + File.separator + child);
        }
    }
    else {
        if (name.equalsIgnoreCase ("config" + File.separator + "options.xml")) {
        }
        else {
            fileExs.add (FileEx.newInstance (dir, name));
        }
    }
    return fileExs;
}


-----Function Pair=194=-----==

public static void timeTest () {
    SimpleDateFormat sdf = new SimpleDateFormat ("yyMM");
    for (int i = 0; i < 12; i ++) {
        Calendar cal = Calendar.getInstance ();
        cal.set (Calendar.MONTH, i);
        cal.add (Calendar.MONTH, 1);
        String thisMonth = sdf.format (cal.getTime ());
        cal = Calendar.getInstance ();
        cal.set (Calendar.MONTH, i);
        cal.add (Calendar.MONTH, 2);
        String nextMonth = sdf.format (cal.getTime ());
        cal = Calendar.getInstance ();
        cal.set (Calendar.MONTH, i);
        cal.add (Calendar.MONTH, (5 - cal.get (Calendar.MONTH) % 3));
        String nextSeason = sdf.format (cal.getTime ());
        cal = Calendar.getInstance ();
        cal.set (Calendar.MONTH, i);
        cal.add (Calendar.MONTH, (8 - cal.get (Calendar.MONTH) % 3));
        String nextHalfYear = sdf.format (cal.getTime ());
        System.out.println ((i + 1) + ": \t" + thisMonth + "\t" + nextMonth + "\t" + nextSeason + "\t" + nextHalfYear);
    }
}


public static Object unzipObject (byte [] b) {
    if (b == null) return null;
    Object returnValue = null;
    try {
        ZipInputStream zis = new ZipInputStream (new ByteArrayInputStream (b));
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        zis.getNextEntry ();
        byte [] bufik = new byte [4096];
        while (zis.available () != 0) {
            int numRead = zis.read (bufik);
            if (numRead > 0) baos.write (bufik, 0, numRead);
        }
        ObjectInputStream ois = new ObjectInputStream (new ByteArrayInputStream (baos.toByteArray ()));
        returnValue = ois.readObject ();
    } catch (IOException ex) {
    } catch (ClassNotFoundException ex) {
    }
    return returnValue;
}


-----Function Pair=195=-----==

public static Backup newBackupFromZipArchive (File backupFile) throws Exception {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
    factory.setIgnoringComments (true);
    factory.setValidating (false);
    factory.setIgnoringElementContentWhitespace (true);
    DocumentBuilder docBuilder = factory.newDocumentBuilder ();
    File unzipFolder = new File (backupFile.getParent (), backupFile.getName ().substring (0, backupFile.getName ().lastIndexOf (".")));
    unzipFolder.mkdir ();
    unZipFile (new ZipFile (backupFile), unzipFolder);
    File xmlDetailsFile = new File (unzipFolder, ConfigurationManager.BACKUP_DETAILS_FILE);
    Document document = docBuilder.parse (new FileInputStream (xmlDetailsFile));
    Backup backup = new Backup (document);
    backup.setZipLocationPath (backupFile.getAbsolutePath ());
    return backup;
}


public Hashtable queryP (User user, byte [] xpath, String docName, String s_id, Hashtable parameters) throws EXistException, PermissionDeniedException {
    String xpathString = null;
    try {
        xpathString = new String (xpath, "UTF-8");
    } catch (UnsupportedEncodingException e) {
        throw new EXistException ("failed to decode xpath expression");
    }
    if (xpathString.charAt (xpathString.length () - 1) == 0x0) xpathString = xpathString.substring (0, xpathString.length () - 1);
    RpcConnection con = pool.get ();
    try {
        return con.queryP (user, xpathString, docName, s_id, parameters);
    } catch (Exception e) {
        handleException (e);
        return null;
    } finally {
        pool.release (con);
    }
}


-----Function Pair=196=-----==

public static Backup newBackupFromZipArchive (File backupFile) throws Exception {
    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
    factory.setIgnoringComments (true);
    factory.setValidating (false);
    factory.setIgnoringElementContentWhitespace (true);
    DocumentBuilder docBuilder = factory.newDocumentBuilder ();
    File unzipFolder = new File (backupFile.getParent (), backupFile.getName ().substring (0, backupFile.getName ().lastIndexOf (".")));
    unzipFolder.mkdir ();
    unZipFile (new ZipFile (backupFile), unzipFolder);
    File xmlDetailsFile = new File (unzipFolder, ConfigurationManager.BACKUP_DETAILS_FILE);
    Document document = docBuilder.parse (new FileInputStream (xmlDetailsFile));
    Backup backup = new Backup (document);
    backup.setZipLocationPath (backupFile.getAbsolutePath ());
    return backup;
}


private byte [] enableTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String enabled = urlData.getParameter ("enabled");
    String name = urlData.getParameter ("name");
    TaskCommand taskCommand = (TaskCommand) tasks.get (name);
    if (taskCommand != null) {
        if ("true".equals (enabled)) taskCommand.setEnabled (true);
        else taskCommand.setEnabled (false);
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


-----Function Pair=197=-----==

public static Object executeIfSupported (Object ob, Object [] args, String methname) {
    try {
        Object retob = null;
        Method [] mt = ob.getClass ().getMethods ();
        int t = 0;
        for (; t < mt.length; t ++) {
            int numparms = 0, numargs = 0;
            if (args != null) numargs = args.length;
            if (mt [t].getParameterTypes () != null) numparms = mt [t].getParameterTypes ().length;
            String nm = mt [t].getName ();
            if ((nm.equals (methname)) && (numparms == numargs)) {
                try {
                    Method mx = mt [t];
                    retob = mx.invoke (ob, args);
                    break;
                } catch (Exception e) {
                    if (false) Logger.logWarn ("ResourceLoader.executeIfSupported() Method NOT supported: " + methname + " in " + ob.getClass ().getName () + " for arguments " + StringTool.arrayToString (args));
                    return null;
                }
            }
        }
        if (false) if (t == mt.length) Logger.logWarn ("ResourceLoader.executeIfSupported() Method NOT found: " + methname + " in " + ob.getClass ().getName () + " for arguments " + StringTool.arrayToString (args));
        return retob;
    } catch (NoSuchMethodError e) {
        return null;
    }
}


public StreamParcel (String pType, String pFileName, App pApp, UCon pConnection, boolean pCache, String pSessionCookie) {
    mSessionCookie = pSessionCookie;
    if (pType == null) {
        throw new ExInternal ("New StreamParcel requires a Type and null was passed.");
    }
    if (pType == TYPE_ZIP_FILE || pType == TYPE_STANDARD) {
        mType = pType;
    }
    else {
        throw new ExInternal ("New StreamParcel requires a type. Currently only " + TYPE_ZIP_FILE + " or " + TYPE_STANDARD + " are accepted.");
    }
    if (pConnection != null) {
        mConnection = pConnection;
        mConnection.registerInterest (this);
    }
    mFileName = pFileName;
    mApp = pApp;
    if (pCache) {
        synchronized (gStreamParcelMap) {
            gStreamParcelMap.put (mStreamParcelID, this);
        }
    }
}


-----Function Pair=198=-----==

public static void ObjectInMapTest () {
    Map < Integer, String > strMap = new HashMap < Integer, String > ();
    strMap.put (1, "aa");
    System.out.println (strMap.get (1));
    @SuppressWarnings ("unused")
    String str = strMap.get (1);
    str = "bb";
    System.out.println (strMap.get (1));
    Map < String, User > beanMap = new HashMap < String, User > ();
    User bean = new User ("reniaL", "m", 25);
    beanMap.put ("a", bean);
    System.out.println (beanMap.get ("a").getName ());
    User bean2 = beanMap.get ("a");
    bean2.setName ("Peter");
    System.out.println (beanMap.get ("a").getName ());
    Map < String, String > map1 = new HashMap < String, String > ();
    Map < String, String > map2 = new HashMap < String, String > ();
    Map < String, String > curMap = new HashMap < String, String > ();
    curMap = map1;
    curMap.put ("a", "a1");
    curMap = map2;
    curMap.put ("b", "b2");
    System.out.println ("map1:");
    for (String key : map1.keySet ()) {
        System.out.println (map1.get (key));
    }
    System.out.println ("map2:");
    for (String key : map2.keySet ()) {
        System.out.println (map2.get (key));
    }
}


public void zipit (String outString, String name) throws Exception {
    File saveFile;
    ZipEntry ze;
    if (m_zipOut == null) {
        saveFile = new File (m_destination, name + ".gz");
        DataOutputStream dout = new DataOutputStream (new GZIPOutputStream (new FileOutputStream (saveFile)));
        dout.writeBytes (outString);
        dout.close ();
    }
    else {
        ze = new ZipEntry (name);
        m_zs.putNextEntry (ze);
        m_zipOut.writeBytes (outString);
        m_zs.closeEntry ();
    }
}


-----Function Pair=199=-----==

protected void processRequest (final HttpServletRequest request, final HttpServletResponse response) throws ServletException {
    final String pathInfo = request.getPathInfo ();
    if (log.isInfoEnabled ()) {
        log.info ("DownloadServlet : pathInfo = " + pathInfo);
    }
    final int pos = pathInfo.indexOf ("/", 1);
    final String user = (pos > 0) ? pathInfo.substring (1, pos) : null;
    if ((user != null) && user.equals (request.getRemoteUser ())) {
        File file = new File (FileManager.ARCHIVE + pathInfo);
        if (log.isInfoEnabled ()) {
            log.info ("DownloadServlet : file = " + file.getAbsolutePath ());
        }
        if (file.isFile ()) {
            downloadFile (request, response, file);
        }
        else {
            downloadDirectory (request, response, file);
        }
    }
    else {
        showError (request, response, "User " + request.getRemoteUser () + " is not alllowed to retrieve results created by " + user);
    }
}


public void write (OutputStream out) throws IOException, MetsException, UnsupportedEncodingException {
    ZipOutputStream zip = new ZipOutputStream (out);
    zip.setComment ("METS archive created by DSpaceSIP");
    zip.setLevel (compression);
    zip.setMethod (ZipOutputStream.DEFLATED);
    ZipEntry me = new ZipEntry (MANIFEST_FILE);
    zip.putNextEntry (me);
    finishManifest (zip);
    zip.closeEntry ();
    for (Map.Entry < String, PackageFile > e : zipFiles.entrySet ()) {
        PackageFile pf = e.getValue ();
        ZipEntry ze = new ZipEntry (pf.zipPath);
        ze.setTime (pf.absPath.lastModified ());
        zip.putNextEntry (ze);
        copyStream (new FileInputStream (pf.absPath), zip);
        zip.closeEntry ();
    }
    zip.close ();
    zipFiles = null;
}


-----Function Pair=200=-----=1=

private boolean writeEntry (File f, JarOutputStream out, String RelativePath) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            fPath = f.getPath ().substring (f.getPath ().lastIndexOf (FILESEPARATOR));
            en = RelativePath + fPath;
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, RelativePath);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


private void saveProjectMenuItemActionPerformed (java.awt.event.ActionEvent evt) {
    JFileChooser fc = new JFileChooser ();
    int returnVal = fc.showSaveDialog (this);
    String path = "c:\\";
    String fileName = "TestSave";
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        path = fc.getSelectedFile ().getParent ();
        fileName = fc.getSelectedFile ().getName ();
    }
    else {
        return;
    }
    save (path + fileName + "-Map.jpg", colorMapImage);
    ImageIcon originalimage = (ImageIcon) originalLabel.getIcon ();
    BufferedImage oi = (BufferedImage) originalimage.getImage ();
    save (path + fileName + "-Marked.jpg", oi);
    save (path + fileName + "-original.jpg", im.getImage ());
    byte [] buffer = new byte [18024];
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (path + fileName + ".zip"));
        out.setLevel (Deflater.DEFAULT_COMPRESSION);
        FileInputStream in1 = new FileInputStream (path + fileName + "-Map.jpg");
        FileInputStream in2 = new FileInputStream (path + fileName + "-Marked.jpg");
        FileInputStream in3 = new FileInputStream (path + fileName + "-original.jpg");
        out.putNextEntry (new ZipEntry (fileName + "-Map.jpg"));
        int len;
        while ((len = in1.read (buffer)) > 0) {
            out.write (buffer, 0, len);
        }
        out.putNextEntry (new ZipEntry (fileName + "-Marked.jpg"));
        len = 0;
        while ((len = in2.read (buffer)) > 0) {
            out.write (buffer, 0, len);
        }
        out.putNextEntry (new ZipEntry (fileName + "-original.jpg"));
        len = 0;
        while ((len = in3.read (buffer)) > 0) {
            out.write (buffer, 0, len);
        }
        out.close ();
        in1.close ();
        in2.close ();
        in3.close ();
        File originalFile = new File (path + fileName + "-original.jpg");
        File mapFile = new File (path + fileName + "-Map.jpg");
        File markedFile = new File (path + fileName + "-Marked.jpg");
        originalFile.delete ();
        mapFile.delete ();
        markedFile.delete ();
    } catch (IllegalArgumentException iae) {
        iae.printStackTrace ();
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


-----Function Pair=201=-----==

private void addFileToStream (final File file, final OutputStream outputStream) {
    if (file.exists ()) {
        InputStream in = null;
        try {
            in = new BufferedInputStream (new FileInputStream (file));
            final byte [] buf = new byte [8192];
            int len;
            while ((len = in.read (buf)) > 0) {
                outputStream.write (buf, 0, len);
            }
        } catch (final IOException ioe) {
            log.error ("addFileToStream : IO failure : ", ioe);
        } finally {
            try {
                if (in != null) {
                    in.close ();
                }
            } catch (final IOException ioe) {
                log.error ("addFileToStream : IO close error : ", ioe);
            }
        }
    }
}


public byte [] encode () {
    byte [] result = null;
    try {
        ByteArrayOutputStream bao = new ByteArrayOutputStream ();
        ZipOutputStream zipOut = new ZipOutputStream (bao);
        zipOut.putNextEntry (new ZipEntry ("root-Job"));
        zipOut.setLevel (9);
        ObjectOutputStream oos = new ObjectOutputStream (zipOut);
        oos.writeObject (this);
        oos.flush ();
        bao.flush ();
        oos.close ();
        result = bao.toByteArray ();
    } catch (IOException ex) {
        logger.log (Level.WARNING, "Encoding job " + this + " failed.", ex);
    }
    return result;
}


-----Function Pair=202=-----=1=

public static Boolean compress (String sSourceDir, ArrayList < String > aFiles, String sDestinationFilename) {
    log.info ("PentahoReport() sourceDir: " + sSourceDir + " destination:" + sDestinationFilename);
    BufferedInputStream oOrigin = null;
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    Iterator < String > oIterator;
    byte [] aData;
    try {
        oDestination = new FileOutputStream (sDestinationFilename);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        aData = new byte [BUFFER_SIZE];
        oIterator = aFiles.iterator ();
        while (oIterator.hasNext ()) {
            String sFilename = (String) oIterator.next ();
            FileInputStream fisInput = new FileInputStream (sSourceDir + File.separator + sFilename);
            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);
            ZipEntry oEntry = new ZipEntry (sFilename.replace ('\\', '/'));
            oOutput.putNextEntry (oEntry);
            int iCount;
            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {
                oOutput.write (aData, 0, iCount);
            }
            oOrigin.close ();
        }
        oOutput.close ();
    } catch (Exception oException) {
        log.error (oException.getMessage ());
        oException.printStackTrace ();
        return false;
    }
    return true;
}


protected static void zipDir (File zipDir, ZipOutputStream zos, File root) throws IOException {
    String [] dirList = zipDir.list ();
    if (dirList != null) {
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                zipDir (f, zos, root);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String relPath = f.getPath ().substring (root.getPath ().length () + 1);
            ZipEntry anEntry = new ZipEntry (relPath);
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) zos.write (readBuffer, 0, bytesIn);
            fis.close ();
        }
    }
}


-----Function Pair=203=-----==

public void copiaArchivoRutaNueva (String rutaArchivoOrigen, String rutaArchivoDestino) {
    try {
        File archivoOrigen = new File (rutaArchivoOrigen);
        File archivoDestino = new File (rutaArchivoDestino);
        this.validaFichero_01 (rutaArchivoOrigen, rutaArchivoDestino);
        System.out.println ("");
        if (archivoDestino.exists () == true) {
            System.out.println ("********* Archivo de DESTINO, 'existente' *********");
        }
        else {
            System.out.println ("********* Archivo de DESTINO, 'NO existente' *********");
            this.validaFichero_02 (rutaArchivoDestino, rutaArchivoDestino);
        }
        this.guardarCopiaArchivo (archivoOrigen, archivoDestino);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private int generateXmlDoc (String orgId, WqxOperationType operationType, String outfileBaseName, String templateName, String docId) {
    velocityHelper.setTemplateArg (TEMPLATE_MAKE_HEADER, makeHeader);
    if (makeHeader) {
        velocityHelper.setTemplateArg (TEMPLATE_AUTHOR_NAME, authorName);
        velocityHelper.setTemplateArg (TEMPLATE_AUTHOR_ORG, authorOrg);
        velocityHelper.setTemplateArg (TEMPLATE_CONTACT_INFO, contactInfo);
    }
    velocityHelper.setTemplateArg (TEMPLATE_ORG_ID, orgId);
    velocityHelper.setTemplateArg (TEMPLATE_DOC_ID, docId);
    if (null != startDate) {
        velocityHelper.setTemplateArg (TEMPLATE_START_DATE, startDate.toString ());
        velocityHelper.setTemplateArg (TEMPLATE_END_DATE, endDate.toString ());
    }
    else {
        Timestamp lastProcessedTimestamp = getLastProcessedTimestamp (orgId, operationType);
        if (null == lastProcessedTimestamp) {
            velocityHelper.setTemplateArg (TEMPLATE_LAST_PROCESSED, ARBITRARY_START_DATE);
        }
        else {
            velocityHelper.setTemplateArg (TEMPLATE_LAST_PROCESSED, lastProcessedTimestamp.toString ());
        }
    }
    setTempFilePath (FilenameUtils.concat (getSettingService ().getTempDir ().getAbsolutePath (), outfileBaseName + docId + XML_EXT));
    return velocityHelper.merge (templateName, getTempFilePath ());
}


-----Function Pair=204=-----==

public void execute () throws BuildException {
    try {
        Integer.parseInt (version);
    } catch (NumberFormatException e) {
        throw new BuildException ("Error: 'version' property must only contain digits");
    }
    if (destfile == null) {
        throw new BuildException ("Error: 'destfile' property must be set.");
    }
    if (modulename == null) {
        modulename = new File (destfile).getName ().toUpperCase ();
        if (modulename.endsWith (".MAR")) {
            modulename = modulename.substring (0, modulename.length () - 4);
        }
    }
    else {
        modulename = modulename.toUpperCase ();
    }
    if (parts.size () == 0) {
        throw new BuildException ("Error: at least on 'part' task must exists in a mar configuration.");
    }
    String partsString = parts.get (0).getName ();
    for (int i = 1; i < parts.size (); i ++) {
        partsString += "," + parts.get (i).getName ();
    }
    if (verbose) {
        System.out.println ("Generating Module Archive : " + modulename);
        System.out.println ("  Version                 : " + version);
        System.out.println ("  Default Description     : " + (description == null ? "" : description));
        System.out.println ("  Destination             : " + destfile);
        System.out.println ("  Parts                   : " + partsString);
        System.out.println ("");
    }
    Properties desc = new Properties ();
    desc.setProperty (MARFileParser.MARDESCRIPTOR_VERSION, version);
    if (description != null) {
        desc.setProperty (MARFileParser.MARDESCRIPTOR_DEFAULTDESCRIPTION, description);
    }
    desc.setProperty (MARFileParser.MARDESCRIPTOR_MODULENAME, modulename);
    desc.setProperty (MARFileParser.MARDESCRIPTOR_PARTS, partsString);
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (destfile));
        out.putNextEntry (new ZipEntry (MARFileParser.MARDESCRIPTOR_PATH));
        desc.store (out, "MAR Descriptor generated by ANT task.");
        out.closeEntry ();
        for (PartAntTask part : parts) {
            zipFilesInPart (out, part);
        }
        out.close ();
    } catch (IOException e) {
        throw new BuildException ("Error: IO Exception when generated MAR file : " + e.getMessage ());
    }
    super.execute ();
}


public static Color getColor (String hexColorTriplet) {
    Color color = null;
    final int REQUIRED_LENGTH = 6;
    final int INVALID_VALUE = - 1;
    if (hexColorTriplet != null && hexColorTriplet.length () == REQUIRED_LENGTH) {
        String redString = hexColorTriplet.substring (0, 2);
        String greenString = hexColorTriplet.substring (2, 4);
        String blueString = hexColorTriplet.substring (4, 6);
        int redInt = INVALID_VALUE;
        int greenInt = INVALID_VALUE;
        int blueInt = INVALID_VALUE;
        try {
            redInt = Integer.parseInt (redString, HEX_RADIX);
            greenInt = Integer.parseInt (greenString, HEX_RADIX);
            blueInt = Integer.parseInt (blueString, HEX_RADIX);
        } catch (NumberFormatException e) {
        }
        if (redInt != INVALID_VALUE && greenInt != INVALID_VALUE && blueInt != INVALID_VALUE) color = new Color (redInt, greenInt, blueInt);
    }
    return color;
}


-----Function Pair=205=-----==

private void saveMenuActionPerformed (java.awt.event.ActionEvent evt) {
    ImageFrame coloredFrame = (ImageFrame) colorizer.getColoredFrame ();
    if (coloredFrame == null) {
        JOptionPane.showMessageDialog (this, "No Colored Image To Save");
        return;
    }
    JFileChooser fc = new JFileChooser ();
    int returnVal = fc.showSaveDialog (this);
    String path = "c:\\";
    String fileName = "TestSave";
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        ImageManip.save (fc.getSelectedFile ().getAbsolutePath (), coloredFrame.getColoredImage ());
    }
    else {
        return;
    }
}


public static final String compressToBase64Str (byte [] bytes) {
    byte [] compressed;
    ByteArrayOutputStream out = null;
    ZipOutputStream zout = null;
    try {
        out = new ByteArrayOutputStream ();
        zout = new ZipOutputStream (out);
        zout.putNextEntry (new ZipEntry ("0"));
        zout.write (bytes);
        zout.closeEntry ();
        compressed = out.toByteArray ();
    } catch (IOException e) {
        compressed = null;
    } finally {
        if (zout != null) {
            try {
                zout.close ();
            } catch (IOException e) {
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
    return new sun.misc.BASE64Encoder ().encodeBuffer (compressed);
}


-----Function Pair=206=-----==

private static void writeSamplePackage (SamplePackage pkg, ObjectOutputStream os, File smplDir, ProgressCallback prog) throws PackageGenerationException {
    if (! (pkg instanceof Impl_SamplePackage)) {
        throw new PackageGenerationException ("General packaging error");
    }
    IsolatedSample [] samples = pkg.getSamples ();
    prepareSampleDirectory (smplDir, romSampleCount (samples) != samples.length);
    prog.updateLabel ("Writing sample package");
    ProgressCallback [] progs = prog.splitTask (SampleContextMacros.userSampleCount (samples), true);
    int pi = 0;
    try {
        for (int i = 0; i < samples.length; i ++) {
            if (! samples [i].isROMSample ()) {
                try {
                    final String isFileName;
                    try {
                        isFileName = getIndexedFileName (samples [i]);
                    } catch (IOException e) {
                        throw new PackageGenerationException (e.getMessage ());
                    } catch (UnsupportedAudioFileException e) {
                        throw new PackageGenerationException (e.getMessage ());
                    }
                    samples [i].setLocalFile (new File (smplDir, isFileName), true);
                    try {
                        progs [pi].updateLabel ("Writing sample " + ZUtilities.quote (samples [i].getName ()));
                        samples [i].assertSample (progs [pi]);
                        samples [i].setLocalFile (new File (smplDir.getName (), isFileName), false);
                    } catch (IsolatedSampleUnavailableException e) {
                        for (int s = 0; s < i; s ++) samples [s].zDispose ();
                        throw new PackageGenerationException ("Could not retrieve samples");
                    }
                } finally {
                    progs [pi ++].updateProgress (1);
                }
            }
        }
        makeIsolatedSamplesSerializable ((Impl_SamplePackage) pkg);
        try {
            os.writeObject (pkg.getHeader ());
            os.writeObject (pkg);
        } catch (IOException e) {
            throw new PackageGenerationException (e.getMessage ());
        }
    } finally {
        prog.updateProgress (1);
    }
}


private static String diff (String name, Object desc1, Object desc2) {
    if (desc1 instanceof String) {
        if (desc2 instanceof String) {
            if (desc1.equals (desc2)) {
                return null;
            }
            return (name + ": Contents should be '" + ((String) desc1).replace ('\n', '|') + "', not '" + ((String) desc2).replace ('\n', '|') + "'");
        }
        return name + " should be a plain member / ZIP entry";
    }
    if (desc2 instanceof String) {
        return name + " should be a directory or ZIP file";
    }
    name += name.endsWith (".zip") ? '!' : '/';
    SortedMap < String, Object > entries1 = new TreeMap < String, Object > ();
    {
        Object [] oa = (Object []) desc1;
        for (int i = 0; i < oa.length;) {
            entries1.put ((String) oa [i ++], oa [i ++]);
        }
    }
    SortedMap < String, Object > entries2 = new TreeMap < String, Object > ();
    {
        Object [] oa = (Object []) desc2;
        for (int i = 0; i < oa.length;) {
            entries2.put ((String) oa [i ++], oa [i ++]);
        }
    }
    for (Iterator < Entry < String, Object > > it1 = entries1.entrySet ().iterator (), it2 = entries2.entrySet ().iterator ();;) {
        if (it1.hasNext ()) {
            Entry < String, Object > entry1 = it1.next ();
            if (it2.hasNext ()) {
                Entry < String, Object > entry2 = it2.next ();
                String name1 = entry1.getKey ();
                String name2 = entry2.getKey ();
                int cmp = name1.compareTo (name2);
                if (cmp < 0) return name + name1 + " missing";
                if (cmp > 0) return "Unexpected " + name + name2;
                String diff = diff (name + name1, entry1.getValue (), entry2.getValue ());
                if (diff != null) return diff;
            }
            else {
                return name + entry1.getKey () + " missing";
            }
        }
        else {
            if (it2.hasNext ()) {
                return "Unexpected " + name + it2.next ().getKey ();
            }
            else {
                break;
            }
        }
    }
    return null;
}


-----Function Pair=207=-----==

public static void extract (byte [] source, File destination) throws IOException {
    if (! destination.exists ()) {
        destination.mkdirs ();
    }
    else if (! destination.isDirectory ()) {
        throw new IOException ("Extraction can be done into directory only!");
    }
    ZipInputStream is = new ZipInputStream (new ByteArrayInputStream (source));
    ZipEntry ze;
    while ((ze = is.getNextEntry ()) != null) {
        if (ze.getName ().endsWith (Constants.PATH_SEPARATOR)) {
            File dir = new File (destination, ze.getName ());
            dir.mkdir ();
        }
        else {
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            byte [] buffer = new byte [1024];
            int br;
            while ((br = is.read (buffer)) > 0) {
                baos.write (buffer, 0, br);
            }
            baos.close ();
            String name = URLDecoder.decode (ze.getName (), Constants.DEFAULT_ENCODING);
            File file = new File (destination, name);
            File dir = file.getParentFile ();
            if (! dir.exists ()) {
                dir.mkdirs ();
            }
            file.createNewFile ();
            FSUtils.writeFile (file, baos.toByteArray ());
        }
    }
    is.close ();
}


private List < FileSystemItem > createFileList (String dir, List < FileSystemNode > nodes, List < FileSystemItem > list, MutableInt size) throws UserFormException {
    if (list == null) {
        list = new ArrayList < FileSystemItem > ();
    }
    for (FileSystemNode node : nodes) {
        String fileName = node.getFileName ();
        if (node.isFolder ()) {
            createFileList (fileName, node.getFileNodes (), list, size);
        }
        else {
            String relativePath = (dir == null) ? fileName : (dir + "/" + fileName);
            size.add (node.getDirEntry ().getSize ());
            FileSystemItem item = new ClientFileSystemItem (node);
            item.setFile (relativePath);
            item.setFolder (node.isFolder ());
            list.add (item);
        }
        if (size.intValue () >= MAX_EMAIL_SIZE) {
            throw new UserFormException ("sendBtn", "too_heavy_to_send");
        }
    }
    return list;
}


-----Function Pair=208=-----==

private List < File > ungzipFile (File directory, File compressedFile) throws IOException {
    List < File > files = new ArrayList < File > ();
    TarArchiveInputStream in = new TarArchiveInputStream (new GZIPInputStream (new FileInputStream (compressedFile)));
    try {
        TarArchiveEntry entry = in.getNextTarEntry ();
        while (entry != null) {
            if (entry.isDirectory ()) {
                log.warn ("TAR archive contains directories which are being ignored");
                entry = in.getNextTarEntry ();
                continue;
            }
            String fn = new File (entry.getName ()).getName ();
            if (fn.startsWith (".")) {
                log.warn ("TAR archive contains a hidden file which is being ignored");
                entry = in.getNextTarEntry ();
                continue;
            }
            File targetFile = new File (directory, fn);
            if (targetFile.exists ()) {
                log.warn ("TAR archive contains duplicate filenames, only the first is being extracted");
                entry = in.getNextTarEntry ();
                continue;
            }
            files.add (targetFile);
            log.debug ("Extracting file: " + entry.getName () + " to: " + targetFile.getAbsolutePath ());
            OutputStream fout = new BufferedOutputStream (new FileOutputStream (targetFile));
            InputStream entryIn = new FileInputStream (entry.getFile ());
            IOUtils.copy (entryIn, fout);
            fout.close ();
            entryIn.close ();
        }
    } finally {
        in.close ();
    }
    return files;
}


private static void buildJAR (Set classNames) throws IOException {
    Manifest manifest = new Manifest ();
    manifest.getMainAttributes ().putValue ("Manifest-Version", "1.0");
    manifest.getMainAttributes ().putValue ("Main-Class", "jtcpfwd.Main");
    final JarOutputStream jos = new JarOutputStream (new FileOutputStream ("jTCPfwd-lite-custom.jar"), manifest);
    final byte [] buf = new byte [4096];
    int len;
    for (Iterator it = classNames.iterator (); it.hasNext ();) {
        String className = (String) it.next ();
        final String classFileName = className.replace ('.', '/') + ".class";
        jos.putNextEntry (new ZipEntry (classFileName));
        final InputStream in = CustomLiteBuilder.class.getResourceAsStream ("/" + classFileName);
        while ((len = in.read (buf)) != - 1) {
            jos.write (buf, 0, len);
        }
        in.close ();
    }
    jos.close ();
}


-----Function Pair=209=-----==

private byte [] process (byte [] bytes) throws Exception {
    ClassReader reader = new ClassReader (new ByteArrayInputStream (bytes));
    String name [] = ClassNameReader.getClassInfo (reader);
    ClassWriter w = new DebuggingClassWriter (ClassWriter.COMPUTE_MAXS);
    ClassTransformer t = getClassTransformer (name);
    if (t != null) {
        if (verbose) {
            log ("processing " + name [0]);
        }
        new TransformingClassGenerator (new ClassReaderGenerator (new ClassReader (new ByteArrayInputStream (bytes)), attributes (), getFlags ()), t).generateClass (w);
        ByteArrayOutputStream out = new ByteArrayOutputStream ();
        out.write (w.toByteArray ());
        return out.toByteArray ();
    }
    return bytes;
}


public byte [] getQuadConstStateBuffer (final String id) throws RemoteException {
    byte [] buffer = null;
    try {
        ZipFile zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
        ZipEntry entry = zipFile.getEntry ("const.bin");
        buffer = new byte [(int) entry.getSize ()];
        this.inFile = new DataInputStream (zipFile.getInputStream (entry));
        readStateBuffer (buffer);
        this.inFile.close ();
        zipFile.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return buffer;
}


-----Function Pair=210=-----==

private void saveComponent (ZipOutputStream zip, HardwareComponent component) throws IOException {
    LOGGING.log (Level.FINE, "snapshot saving {0}", component);
    int i = 0;
    while (true) {
        ZipEntry entry = new ZipEntry (component.getClass ().getName () + "#" + i);
        try {
            zip.putNextEntry (entry);
            break;
        } catch (ZipException e) {
            if (e.getMessage ().matches (".*(duplicate entry).*")) {
                i ++;
            }
            else {
                throw e;
            }
        }
    }
    DataOutputStream dout = new DataOutputStream (zip);
    component.saveState (dout);
    dout.flush ();
    zip.closeEntry ();
}


public static ZipOutputStream createZip (File zipFile, String manifestText) throws ImportExportException {
    if (zipFile.isDirectory ()) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.MUST_BE_FILE, "File passed to createZip can not be a directory. " + zipFile.getPath ());
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    }
    JarOutputStream zos = null;
    try {
        zos = new JarOutputStream (new FileOutputStream (zipFile), getManifest (manifestText));
    } catch (FileNotFoundException e) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.ZIP_FILE_NOT_FOUND, "Zip file not found " + zipFile.getPath ());
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    } catch (IOException e) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.FAILED_TO_ADD_MANIFEST, "Failed to add manifest", e);
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    }
    return zos;
}


-----Function Pair=211=-----==

protected void processClassFile (File file) throws Exception {
    logger.verbose ("Starting class file : " + file.toURL ());
    byte [] bytes = ByteCodeHelper.readByteCode (file);
    ClassDescriptor descriptor = getClassDescriptor (bytes);
    ClassTransformer transformer = getClassTransformer (descriptor);
    if (transformer == null) {
        logger.verbose ("skipping file : " + file.toURL ());
        return;
    }
    logger.info ("processing class [" + descriptor.getName () + "]; file = " + file.toURL ());
    byte [] transformedBytes = transformer.transform (getClass ().getClassLoader (), descriptor.getName (), null, null, descriptor.getBytes ());
    OutputStream out = new FileOutputStream (file);
    try {
        out.write (transformedBytes);
        out.flush ();
    } finally {
        try {
            out.close ();
        } catch (IOException ignore) {
        }
    }
}


private void implantSelf () throws IOException {
    InputStream manifest = getClass ().getClassLoader ().getResourceAsStream ("META-INF/manifest.mf");
    log ("my classloader is " + getClass ().getClassLoader ().getClass ().getName ());
    ClassLoader loader = getClass ().getClassLoader ();
    if (manifest == null || loader == null || (loader.getClass ().getName ().indexOf ("Applet") == - 1 && loader.getClass ().getName ().indexOf ("Plugin") == - 1)) return;
    BufferedReader br = new BufferedReader (new InputStreamReader (manifest));
    Vector entries = new Vector ();
    String s = null;
    while ((s = br.readLine ()) != null) if (s.startsWith ("Name: ")) entries.addElement (s.substring (6));
    String ext_dirs = System.getProperty ("java.ext.dirs");
    log ("java.ext.dirs = " + ext_dirs);
    ext_dirs = ext_dirs + File.pathSeparatorChar + System.getProperty ("user.home") + File.separatorChar + ".vexi";
    StringTokenizer st = new StringTokenizer (ext_dirs, File.pathSeparatorChar + "");
    while (st.hasMoreTokens ()) {
        String dir = st.nextToken ();
        new File (dir).mkdirs ();
        try {
            if (! st.hasMoreTokens ()) modifyPolicyFile ();
            implantInDirectory (dir, entries);
            return;
        } catch (IOException e) {
            log ("Failed to implant in " + dir + " due to " + e);
        }
    }
    log ("Failed to implant self!");
}


-----Function Pair=212=-----==

private void setDataSourceQuery (Layer layer, String filename) throws Exception {
    DataSource dataSource = null;
    if ((filename.toLowerCase ()).endsWith (".shp")) dataSource = (DataSource) StandardReaderWriterFileDataSource.Shapefile.class.newInstance ();
    if ((filename.toLowerCase ()).endsWith (".jml")) dataSource = (DataSource) StandardReaderWriterFileDataSource.JML.class.newInstance ();
    if ((filename.toLowerCase ()).endsWith (".gml")) dataSource = (DataSource) StandardReaderWriterFileDataSource.GML.class.newInstance ();
    if ((filename.toLowerCase ()).endsWith (".fme")) dataSource = (DataSource) StandardReaderWriterFileDataSource.FMEGML.class.newInstance ();
    if ((filename.toLowerCase ()).endsWith (".wkt")) dataSource = (DataSource) StandardReaderWriterFileDataSource.WKT.class.newInstance ();
    if (dataSource != null) {
        HashMap properties = new HashMap ();
        properties.put (DataSource.COORDINATE_SYSTEM_KEY, "Unspecified");
        properties.put (DataSource.FILE_KEY, filename);
        dataSource.setProperties (properties);
        DataSourceQuery dataSourceQuery = new DataSourceQuery (dataSource, layer.getName (), null);
        layer.setDataSourceQuery (dataSourceQuery).setFeatureCollectionModified (false);
    }
}


public static final byte [] gzipDecompress (byte [] dataBytes) throws IOException {
    ByteArrayInputStream fis = null;
    ByteArrayOutputStream fos = null;
    GZIPInputStream gis = null;
    try {
        fis = new ByteArrayInputStream (dataBytes);
        fos = new ByteArrayOutputStream ();
        gis = new GZIPInputStream (fis);
        IOUtil.getBytes (gis, fos);
    } finally {
        IOUtil.safeClose (gis);
        IOUtil.safeClose (fis);
        IOUtil.safeClose (fos);
    }
    return fos.toByteArray ();
}


-----Function Pair=213=-----==

public void writeContextToXml (InteractionContext context, File file) {
    if (context.getInteractionHistory ().isEmpty ()) return;
    try {
        if (! file.exists ()) {
            file.createNewFile ();
        }
        String handleIdentifier = context.getHandleIdentifier ();
        String encoded = URLEncoder.encode (handleIdentifier, InteractionContextManager.CONTEXT_FILENAME_ENCODING);
        ZipOutputStream outputStream = new ZipOutputStream (new FileOutputStream (file));
        ZipEntry zipEntry = new ZipEntry (encoded + InteractionContextManager.CONTEXT_FILE_EXTENSION_OLD);
        outputStream.putNextEntry (zipEntry);
        outputStream.setMethod (ZipOutputStream.DEFLATED);
        writer.setOutputStream (outputStream);
        writer.writeContextToStream (context);
        outputStream.closeEntry ();
        outputStream.flush ();
        outputStream.close ();
    } catch (IOException e) {
        StatusHandler.fail (e, "Could not write: " + file.getAbsolutePath (), true);
    }
}


public static TimeLoopGroundOverlay toTimeLoopGroundOverlay (KMLDocument doc) {
    GroundOverlay [] govs = doc.groundOverlays;
    ScreenOverlayLayer legend = null;
    if (govs == null || govs.length == 0) return null;
    final String cachePath = "Earth/" + Messages.forCachePath (doc.name) + "/";
    TimeLoopGroundOverlay aov = new TimeLoopGroundOverlay (doc.name);
    aov.setDescription (doc.description);
    if (doc.screenOverlays != null) {
        final ScreenOverlay so = getLegend (doc.screenOverlays);
        legend = (so.icon != null) ? new ScreenOverlayLayer (so.name, so.icon, so.position) : new ScreenOverlayLayer (so.name, so.iconPath, so.position);
        if (so.sizeX != null && so.sizeY != null && so.sizeX.equals ("0") && so.sizeY.equals ("0")) legend.setResizeBehavior (ScreenOverlayLayer.RESIZE_KEEP_FIXED_SIZE);
        aov.setLegend (legend);
    }
    logger.debug ("Loop overlay " + doc.name + " " + govs.length + " frames " + " Legend=" + legend);
    for (GroundOverlay go : govs) {
        final Sector sector = new Sector (Angle.fromDegrees (go.bbox.south), Angle.fromDegrees (go.bbox.north), Angle.fromDegrees (go.bbox.west), Angle.fromDegrees (go.bbox.east));
        final GroundOverlayLayer overlay = new GroundOverlayLayer (go.name, sector, go.icon, ParserUtils.getIconSuffix (go.icon.toString ()));
        overlay.setBaseCachePath (cachePath);
        aov.add (overlay);
    }
    return aov;
}


-----Function Pair=214=-----==

public static void acceptJoin (Galaxy galaxy, Race race) {
    race.log ("Accepted for game");
    Map < String, Object > arguments = new HashMap < String, Object > ();
    arguments.put ("Galaxy.Name", galaxy.getName ());
    arguments.put ("Races.Count", galaxy.getRaces ().size ());
    arguments.put ("Race.Name", race.getName ());
    String subject = MailFactory.getSubject ("join_notification", arguments, OGSserver.getMessageParameters ());
    arguments.put ("Race.Password", race.getPassword ());
    arguments.put ("Race.PasswordPrefix", race.getPasswordPrefix ());
    MailFactory.sendMessage (race.getAddress (GamerAddress.Mode.ANSWER), subject, MailFactory.getMessage ("join_notification", arguments, OGSserver.getMessageParameters ()));
    if ("auto".equalsIgnoreCase (galaxy.props.getProperty ("Galaxy.StopJoin"))) {
        if (canAutoGenerate (galaxy)) {
            Schedule sch = Schedule.getSchedule (galaxy.getGameDir ());
            Calendar calendar = Calendar.getInstance (Locale.ROOT);
            calendar.add (Calendar.DAY_OF_WEEK, galaxy.firstTurnPause);
            sch.updateNextScheduleDate (1, calendar.getTime ());
            if (sch.getDateGenerate () == null) MailFactory.informGameMind ("Game " + galaxy.getName () + " recruiting is completed but schedule for turn 0 is not defined");
            Schedule.commitSchedule (galaxy.getGameDir (), sch);
            Galaxy.getLogger ().info ("Generate " + galaxy.getName () + " turn " + (galaxy.getTurn () + 1) + " by autostart");
            generateGame (galaxy);
        }
    }
    else if ("flexible".equalsIgnoreCase (galaxy.props.getProperty ("Galaxy.StopJoin"))) {
        Schedule sch = Schedule.getSchedule (galaxy.getGameDir ());
        if (sch.getDateGenerate () != null) sendPreInvitation (galaxy, race, sch);
        else if (canAutoGenerate (galaxy)) {
            Calendar calendar = Calendar.getInstance (Locale.ROOT);
            calendar.add (Calendar.DAY_OF_WEEK, galaxy.firstTurnPause);
            sch.updateNextScheduleDate (0, calendar.getTime ());
            if (sch.getDateGenerate () == null) MailFactory.informGameMind ("Game " + galaxy.getName () + " recruiting is completed but schedule for turn 0 is not defined");
            else {
                Schedule.commitSchedule (galaxy.getGameDir (), sch);
                sendPreInvitations (galaxy, sch);
                MailFactory.informGameMind ("Game " + galaxy.getName () + " will started at " + sch.getDateGenerate ());
            }
        }
    }
    else {
        Schedule sch = Schedule.getSchedule (galaxy.getGameDir ());
        if (sch.getDateGenerate () != null) sendPreInvitation (galaxy, race, sch);
    }
}


public static LinkedList < Instance > getAllByExperimentId (int id) throws SQLException, InstanceClassMustBeSourceException, IOException {
    Vector < Property > props = new Vector < Property > ();
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT DISTINCT i.idInstance, i.md5, i.name" + getPropertySelect (props) + "FROM " + table + " as i JOIN Experiment_has_Instances as ei ON " + "i.idInstance = ei.Instances_idInstance " + getPropertyFrom (props) + " WHERE ei.Experiment_idExperiment = ?");
    st.setInt (1, id);
    ResultSet rs = st.executeQuery ();
    LinkedList < Instance > res = new LinkedList < Instance > ();
    while (rs.next ()) {
        Instance c = cache.getCached (rs.getInt ("i.idInstance"));
        if (c != null) {
            res.add (c);
        }
        else {
            Instance i = getInstance (rs, props);
            i.setSaved ();
            cache.cache (i);
            res.add (i);
        }
    }
    rs.close ();
    st.close ();
    return res;
}


-----Function Pair=215=-----==

private void printCmdOutput (Process p, String cmdName) throws IOException {
    BufferedReader psIn = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    BufferedReader psErr = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
    int n = 0;
    System.out.println ("  --- start " + cmdName + " ---");
    String inLine = psIn.readLine ();
    String errLine = psErr.readLine ();
    while ((inLine != null) || (errLine != null)) {
        if (inLine != null) System.out.println ("  " + inLine);
        if (errLine != null) System.err.println ("  " + errLine);
        inLine = psIn.readLine ();
        errLine = psErr.readLine ();
    }
    psIn.close ();
    psErr.close ();
    System.out.println ("  --- end   " + cmdName + " ---");
}


public static boolean restore () {
    String ret;
    try {
        String filename = "tyrant.sav";
        FileDialog fd = new FileDialog (new Frame (), "Load Game", FileDialog.LOAD);
        fd.setFile (filename);
        fd.setVisible (true);
        if (fd.getFile () != null) {
            filename = fd.getDirectory () + fd.getFile ();
        }
        else {
            return false;
        }
        ret = tryToRestore (filename);
        if (ret == null) return true;
    } catch (Exception e) {
        ret = e.toString ();
        System.out.println (e);
    }
    Game.message ("Load game failed: " + ret);
    if (QuestApplet.isapplet) {
        Game.message ("This may be due to browser security restrictions");
        Game.message ("If so, run the downloaded application version instead");
    }
    return false;
}


-----Function Pair=216=-----==

private void generateInstallCode (File javaFile, String instTemplate, String classLoader) throws IOException {
    PrintWriter writer = new PrintWriter (new FileWriter (javaFile));
    int read = 0;
    byte [] buf = new byte [128];
    InputStream is = getClass ().getResourceAsStream ("/" + instTemplate);
    InputStreamReader isr = new InputStreamReader (is);
    LineNumberReader reader = new LineNumberReader (isr);
    System.out.println (VAGlobals.i18n ("VAArchiver_GeneratingInstallClassCode"));
    String line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassName"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("public class " + instClassName_ + " {");
    writer.println ("  private static final Class installClass=new " + instClassName_ + "().getClass();");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ArchivingMethod"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String ARCH_METHOD=\"" + archMethod_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> TargetType"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String TARGET_TYPE=\"" + currentTarget_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassOffset"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long ICLASS_OFFSET=" + installClassOffset_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassSize"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    if (installClassSize_ != archOffset_) writer.println ("  private static long ICLASS_SIZE=" + installClassSize_ + "L;");
    else writer.println ("  private static long ICLASS_SIZE=-1234543210L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ArchiveOffset"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long ARCH_OFFSET=" + archOffset_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> JarSize"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long JAR_SIZE=" + jarSize_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIMode"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_MODE=\"" + uiMode_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIBluescreen"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_BLUESCREEN=\"" + uiBluescreen_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIBluescreenColor"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_BLUESCREEN_COLOR=\"" + uiBluescreenColor_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> DestPath"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String DEST_PATH=\"" + destPath_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> AppInfo"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String APP_NAME=\"" + appName_ + "\";");
    writer.println ("  private static String APP_VERSION=\"" + appVersion_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> LinkInfos"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String LINK_SECTION_NAME=\"" + linkSectionName_ + "\";");
    writer.println ("  private static String LINK_SECTION_ICON=\"" + linkSectionIcon_ + "\";");
    writer.println ("  private static String LINK_ENTRY_NAME=\"" + linkEntryName_ + "\";");
    writer.println ("  private static String LINK_ENTRY_ICON=\"" + linkEntryIcon_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> LicenseKey"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String LICENSE_KEY_SUPPORT_NAME=\"" + licenseKeySupportClassName_ + "\";");
    System.out.println (VAGlobals.i18n ("VAArchiver_AppendingClassloader"));
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ClassLoader"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    InputStream isClassLoader = getClass ().getResourceAsStream ("/" + classLoader);
    System.out.println ("  CLASSLOADER = " + "/" + classLoader);
    writer.println ("  private static String[] CL_CLASS={");
    read = isClassLoader.read (buf);
    while (read > 0) {
        writer.println ("\"" + codeLine (buf, read) + "\",");
        read = isClassLoader.read (buf);
    }
    isClassLoader.close ();
    writer.println ("  };\n}");
    reader.close ();
    writer.close ();
    is.close ();
    isr.close ();
}


protected ModelAndView handleRequestAfterValidation (HttpServletRequest request, HttpServletResponse response) throws Exception {
    String filename = getFilename ();
    response.setContentType (mimeTypes.getContentType (filename));
    response.setHeader ("Cache-Control", "private");
    response.setHeader ("Content-Disposition", "attachment; filename=\"" + filename + "\"");
    ZipOutputStream zipOut = new ZipOutputStream (response.getOutputStream ());
    Map formData = request.getParameterMap ();
    Iterator itFormData = formData.entrySet ().iterator ();
    while (itFormData.hasNext ()) {
        Map.Entry me = (Map.Entry) itFormData.next ();
        if (((String) me.getKey ()).startsWith ("id_")) {
            String defId = ((String) me.getKey ()).substring (3);
            if (defId.startsWith ("%")) defId = defId.substring (1);
            if (Validator.isNotNull (defId)) {
                try {
                    NamedDocument doc = getDocumentForId (defId);
                    zipOut.putNextEntry (new ZipEntry (Validator.replacePathCharacters (doc.name) + ".xml"));
                    XmlFileUtil.writeFile (doc.doc, zipOut);
                } catch (Exception ex) {
                }
            }
        }
    }
    zipOut.finish ();
    return null;
}


-----Function Pair=217=-----==

public boolean appendAllParagraph (Element paragraphToAppend, TreeMap < String, String > mapOldIdToNewId) {
    List listParagraphToInsert = getListOfNodeToInsert (paragraphToAppend, mapOldIdToNewId);
    if (listParagraphToInsert == null) {
        return false;
    }
    Element body = getDocumentBody ();
    for (Iterator i = body.elementIterator (); i.hasNext ();) {
        Element curNode = (Element) i.next ();
        if (! isNodeParagraphOrTable (curNode) && ! isNodeIndentText (curNode)) {
            for (Iterator iter = listParagraphToInsert.iterator (); iter.hasNext ();) {
                Node elementtoInsert = (Node) iter.next ();
                body.elements ().add (body.elements ().indexOf (curNode), elementtoInsert);
            }
            return true;
        }
    }
    Iterator iter = listParagraphToInsert.iterator ();
    while (iter.hasNext ()) {
        logger.debug ("appending to body");
        Node curNodeToInsert = (Node) iter.next ();
        body.elements ().add (curNodeToInsert);
    }
    return true;
}


public Image getLayerLegend (Component ImageCreator, String layerCompositeName) {
    FontMetrics font_metrics = Toolkit.getDefaultToolkit ().getFontMetrics (configuration.getMapLegendFont ());
    l_height = 0;
    l_max_w = 0;
    Layer slayer = map.getLayerNode (layerCompositeName);
    calculateLegendHeight (map, slayer, font_metrics, 0, 0);
    Dimension layers_legend_size = new Dimension (l_max_w + 10, l_height);
    Dimension ruler_size = getPreferredRulerSize (font_metrics);
    whole_map_legend_size = new Dimension (Math.max (layers_legend_size.width, ruler_size.width), layers_legend_size.height + space_between_legend_ruler + ruler_size.height + 2);
    BufferedImage OffScreenImage = new BufferedImage (whole_map_legend_size.width, whole_map_legend_size.height, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = (Graphics2D) OffScreenImage.getGraphics ();
    g2d.setFont (configuration.getMapLegendFont ());
    g2d.setColor (Color.white);
    g2d.fillRect (0, 0, whole_map_legend_size.width, whole_map_legend_size.height);
    g2d.setColor (Color.black);
    l_height = 0;
    paintLayerLegend (map, slayer, 0, g2d, 0);
    return OffScreenImage;
}


-----Function Pair=218=-----=1=

static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


public void zipPackege (final String dirName, final String urldoPliku, String ikony) throws IOException, FileNotFoundException {
    final String nazwaPliku = urldoPliku;
    int x;
    final ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (nazwaPliku)));
    zos.setMethod (ZipOutputStream.STORED);
    String filePath = dirName + "/" + "Paczka.kml";
    BufferedInputStream in = new BufferedInputStream (new FileInputStream (filePath));
    ZipEntry entry = new ZipEntry ("Paczka.kml");
    entry.setMethod (ZipEntry.STORED);
    entry.setSize (new File (filePath).length ());
    entry.setCrc (doChecksum (filePath));
    zos.putNextEntry (entry);
    while ((x = in.read ()) != - 1) {
        zos.write (x);
    }
    in.close ();
    for (String s : conditionsNames) {
        filePath = ikony + "/" + s + ".png";
        in = new BufferedInputStream (new FileInputStream (filePath));
        entry = new ZipEntry ("icons/" + s + ".png");
        entry.setMethod (ZipEntry.STORED);
        entry.setSize (new File (filePath).length ());
        entry.setCrc (doChecksum (filePath));
        zos.putNextEntry (entry);
        while ((x = in.read ()) != - 1) {
            zos.write (x);
        }
        in.close ();
    }
    for (int i = start; i < end; i ++) {
        for (String s : layers) {
            filePath = dirName + "/" + s + "_" + i + ".png";
            in = new BufferedInputStream (new FileInputStream (filePath));
            entry = new ZipEntry (s + "_" + i + ".png");
            entry.setMethod (ZipEntry.STORED);
            entry.setSize (new File (filePath).length ());
            entry.setCrc (doChecksum (filePath));
            zos.putNextEntry (entry);
            while ((x = in.read ()) != - 1) {
                zos.write (x);
            }
            in.close ();
        }
    }
    zos.close ();
}


-----Function Pair=219=-----==

public void newFile (ActionFormEvent event) throws PortletException {
    String userName = (String) ((Map) event.getActionRequest ().getAttribute (PortletRequest.USER_INFO)).get ("user.name");
    String sideParam = event.getActionRequest ().getParameter ("side");
    TextFieldBean textFieldBean = event.getTextFieldBean ("resourceName" + sideParam);
    String resourceName = textFieldBean.getValue ();
    UserData userData = (UserData) event.getActionRequest ().getPortletSession ().getAttribute ("userData");
    if (resourceName != null && ! resourceName.equals ("")) {
        try {
            String path = userData.getPath (sideParam);
            File f = new File (userData.getChrootDir () + path);
            if (! f.isDirectory ()) {
                f.mkdirs ();
            }
            File newFile = new File (userData.getChrootDir () + path + resourceName);
            newFile.createNewFile ();
            textFieldBean.setValue ("");
            readDirectories (userName, userData);
        } catch (IOException e) {
            log.error ("Unable to create new file", e);
            event.getActionResponse ().setRenderParameter ("errorMessage", "Unable to create newfile");
        }
    }
}


public void addToZip (String zipFilePath, String files []) throws Exception {
    File tmpFile = new File ("temp.zip");
    ZipFile zipFile = new ZipFile (new File (zipFilePath));
    ZipOutputStream zo = new ZipOutputStream (new FileOutputStream (tmpFile));
    ZipEntry entry = null;
    ZipEntry outEntry = null;
    java.util.Enumeration e = zipFile.getEntries ();
    while (e.hasMoreElements ()) {
        entry = (ZipEntry) e.nextElement ();
        outEntry = new ZipEntry (entry.getName ());
        InputStream zi = zipFile.getInputStream (entry);
        zo.putNextEntry (outEntry);
        while (true) {
            int n = zi.read (buffer);
            if (n < 0) break;
            zo.write (buffer, 0, n);
        }
        zi.close ();
        zo.closeEntry ();
    }
    for (int i = 0; i < files.length; i ++) {
        File file = new File (files [i]).getAbsoluteFile ();
        prefix = file.getParent ();
        if (! prefix.endsWith (File.separator)) prefix = prefix + File.separator;
        doZip (zo, file);
    }
    zo.close ();
    zipFile.close ();
    File oldZipFile = new File (zipFilePath);
    String zipFileName = oldZipFile.getName ();
    oldZipFile.delete ();
    tmpFile.renameTo (new File (zipFileName));
}


-----Function Pair=220=-----==

public void move (ActionFormEvent event) throws PortletException {
    String userName = (String) ((Map) event.getActionRequest ().getAttribute (PortletRequest.USER_INFO)).get ("user.name");
    String sideParam = event.getActionRequest ().getParameter ("side");
    UserData userData = (UserData) event.getActionRequest ().getPortletSession ().getAttribute ("userData");
    if (userData.getPath ("left").equals (userData.getPath ("right"))) {
        event.getActionResponse ().setRenderParameter ("errorMessage", "Source and the destination is the same!");
        return;
    }
    String sourcePath = userData.getPath (sideParam);
    String destinationPath = (sideParam.equals ("left") ? userData.getPath ("right") : userData.getPath ("left"));
    ArrayList < MyFile > resources = (sideParam.equals ("left") ? userData.getLeftFileList () : userData.getRightFileList ());
    Enumeration params = event.getActionRequest ().getParameterNames ();
    while (params.hasMoreElements ()) {
        String param = (String) params.nextElement ();
        if (util.match ("m!^" + sideParam + "_(\\d)+$!", param)) {
            File f = new File (userData.getChrootDir () + sourcePath + resources.get (Integer.parseInt (util.group (1))).getName ());
            f.renameTo (new File (userData.getChrootDir () + destinationPath + resources.get (Integer.parseInt (util.group (1))).getName ()));
        }
    }
    readDirectories (userName, userData);
}


public void unzipFile (File zippedFile) {
    checkFile (zippedFile);
    File parentDir = zippedFile.getParentFile ();
    String fileNamewithoutExtenson = JefbUtils.extractFileNameWithoutExtension (zippedFile);
    File destFile = new File (parentDir.getAbsolutePath (), fileNamewithoutExtenson);
    destFile = createNonExistentDestinationFile (destFile);
    try {
        ZipFile zipFile = new ZipFile (zippedFile);
        Enumeration < ? extends ZipEntry > zipEntryEnum = zipFile.entries ();
        while (zipEntryEnum.hasMoreElements ()) {
            ZipEntry zipEntry = zipEntryEnum.nextElement ();
            extractEntry (zipFile, zipEntry, destFile.getAbsolutePath ());
        }
    } catch (Exception e) {
        String errorMessage = "Unable to unzip file [" + zippedFile.getName () + "].";
        log.error (errorMessage, e);
        throw new FileSystemException ("filemanager.msg.unable_to_unzip", errorMessage);
    }
}


-----Function Pair=221=-----==

private static void zip (File dir, File base, ZipOutputStream out) throws IOException {
    File [] files = dir.listFiles ();
    byte [] buffer = new byte [8192];
    final String FILE_SEP = System.getProperty ("file.separator");
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            zip (files [i], base, out);
        }
        else {
            FileInputStream fin = new FileInputStream (files [i]);
            ZipEntry entry = new ZipEntry (files [i].getPath ().substring (base.getPath ().length () + 1).replace (FILE_SEP, "/"));
            out.putNextEntry (entry);
            int bytes_read = 0;
            while ((bytes_read = fin.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
            }
            fin.close ();
        }
    }
}


protected final void includeClass (String className) throws BuildException {
    String osPath = className.replace ('.', File.separatorChar) + ".class";
    String urlPath = className.replace ('.', '/') + ".class";
    for (int i = 0; i < classpathFileList.length; ++ i) {
        File cpBase = classpathFileList [i];
        if (! cpBase.exists ()) continue;
        if (cpBase.isDirectory ()) {
            File testFile = fileUtils.resolveFile (cpBase, osPath);
            if (testFile.exists ()) {
                FileSet fileSet = new FileSet ();
                fileSet.setDir (cpBase);
                fileSet.setIncludes (osPath);
                super.addFileset (fileSet);
                return;
            }
            continue;
        }
        if (cpBase.isFile ()) {
            if (classpathZipList [i] == null) {
                try {
                    classpathZipList [i] = new ZipFile (cpBase);
                } catch (IOException ioe) {
                    classpathZipList [i] = null;
                    continue;
                }
            }
            if (classpathZipList [i].getEntry (urlPath) != null) {
                ZipFileSet zipFileSet = new ZipFileSet ();
                zipFileSet.setSrc (classpathFileList [i]);
                zipFileSet.setIncludes (urlPath);
                super.addZipfileset (zipFileSet);
                return;
            }
            continue;
        }
    }
    throw new BuildException ("Cannot locate class in classpath: " + className);
}


-----Function Pair=222=-----==

public void finish () throws IOException {
    if (entries == null) return;
    if (curEntry != null) closeEntry ();
    int numEntries = 0;
    int sizeEntries = 0;
    Enumeration e = entries.elements ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        int method = entry.getMethod ();
        writeLeInt (CENSIG);
        writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
        writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
        writeLeShort (entry.flags);
        writeLeShort (method);
        writeLeInt (entry.getDOSTime ());
        writeLeInt ((int) entry.getCrc ());
        writeLeInt ((int) entry.getCompressedSize ());
        writeLeInt ((int) entry.getSize ());
        byte [] name;
        try {
            name = entry.getName ().getBytes ("UTF-8");
        } catch (UnsupportedEncodingException uee) {
            throw new Error (uee.toString ());
        }
        if (name.length > 0xffff) throw new ZipException ("Name too long.");
        byte [] extra = entry.getExtra ();
        if (extra == null) extra = new byte [0];
        String str = entry.getComment ();
        byte [] comment;
        try {
            comment = str != null ? str.getBytes ("UTF-8") : new byte [0];
        } catch (UnsupportedEncodingException uee) {
            throw new Error (uee.toString ());
        }
        if (comment.length > 0xffff) throw new ZipException ("Comment too long.");
        writeLeShort (name.length);
        writeLeShort (extra.length);
        writeLeShort (comment.length);
        writeLeShort (0);
        writeLeShort (0);
        writeLeInt (0);
        writeLeInt (entry.offset);
        out.write (name);
        out.write (extra);
        out.write (comment);
        numEntries ++;
        sizeEntries += CENHDR + name.length + extra.length + comment.length;
    }
    writeLeInt (ENDSIG);
    writeLeShort (0);
    writeLeShort (0);
    writeLeShort (numEntries);
    writeLeShort (numEntries);
    writeLeInt (sizeEntries);
    writeLeInt (offset);
    writeLeShort (zipComment.length);
    out.write (zipComment);
    out.flush ();
    entries = null;
}


public static void unzip (String destDir, String zipPath) {
    PrintWriter stdout = new PrintWriter (System.out, true);
    int read = 0;
    byte [] data = new byte [1024];
    ZipEntry entry;
    try {
        ZipInputStream in = new ZipInputStream (new FileInputStream (zipPath));
        stdout.println (zipPath);
        while ((entry = in.getNextEntry ()) != null) {
            if (entry.getMethod () == ZipEntry.DEFLATED) {
                stdout.println ("  Inflating: " + entry.getName ());
            }
            else {
                stdout.println (" Extracting: " + entry.getName ());
            }
            FileOutputStream out = new FileOutputStream (destDir + File.separator + entry.getName ());
            while ((read = in.read (data, 0, 1024)) != - 1) {
                out.write (data, 0, read);
            }
            out.close ();
        }
        in.close ();
        stdout.println ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=223=-----==

public void saveSolverConfigurations (Tasks task) throws SQLException, InterruptedException, InvocationTargetException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, NoConnectionToDBException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException, Exception {
    task.setStatus ("Checking jobs..");
    boolean yta = false;
    for (Solver solver : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (solver)) {
            if (entry.isModified () && entry.hasEmptyValues ()) {
                String [] options = {"Yes", "Yes to all", "No"};
                int userinput = JOptionPane.showOptionDialog (Tasks.getTaskView (), "The solver configuration " + entry.getName () + " has no value for a parameter which must have a value.\nDo you want to continue?", "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options [0]);
                if (userinput == 1) {
                    yta = true;
                    break;
                }
                else if (userinput == 2) {
                    return;
                }
            }
        }
        if (yta) {
            break;
        }
    }
    experimentResultCache.updateExperimentResults ();
    ArrayList < SolverConfiguration > deletedSolverConfigurations = solverConfigCache.getAllDeleted ();
    final ArrayList < ExperimentResult > deletedJobs = new ArrayList < ExperimentResult > ();
    final HashSet < Integer > scIds = new HashSet < Integer > ();
    for (SolverConfiguration sc : deletedSolverConfigurations) {
        scIds.add (sc.getId ());
    }
    for (ExperimentResult job : experimentResultCache.values ()) {
        if (scIds.contains (job.getSolverConfigId ())) {
            deletedJobs.add (job);
        }
    }
    ArrayList < SolverConfiguration > modifiedSolverConfigurations = solverConfigurationEntryModel.getModifiedSolverConfigurations ();
    yta = false;
    boolean nta = false;
    for (SolverConfiguration sc : modifiedSolverConfigurations) {
        int userinput = - 1;
        if (! yta && ! nta) {
            String [] options = {"Yes", "Yes to all", "No", "No to all"};
            userinput = JOptionPane.showOptionDialog (Tasks.getTaskView (), "The parameter values of the solver configuration " + sc.getName () + " have been changed.\nDo you want to delete the affected jobs?", "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options [0]);
            if (userinput == 1) {
                yta = true;
            }
            else if (userinput == 3) {
                nta = true;
            }
        }
        if (! nta && (yta || userinput == 0)) {
            deletedJobs.addAll (ExperimentResultDAO.getAllBySolverConfiguration (sc));
        }
    }
    if (deletedJobs.size () > 0) {
        int notDeletableJobsCount = 0;
        for (ExperimentResult job : deletedJobs) {
            if (job.getStatus () != StatusCode.NOT_STARTED) {
                notDeletableJobsCount ++;
            }
        }
        String msg = "";
        if (notDeletableJobsCount > 0) {
            msg = "There are " + notDeletableJobsCount + " started jobs and " + (deletedJobs.size () - notDeletableJobsCount) + " jobs waiting in the database which would be deleted. ";
        }
        else {
            msg = "There are " + deletedJobs.size () + " jobs waiting in the database which would be deleted. ";
        }
        msg += "Do you want to continue?";
        int userInput = javax.swing.JOptionPane.showConfirmDialog (Tasks.getTaskView (), msg, "Jobs would be changed", javax.swing.JOptionPane.YES_NO_OPTION);
        if (userInput == 1) {
            return;
        }
        else {
            task.setStatus ("Deleting jobs..");
            ExperimentResultDAO.deleteExperimentResults (deletedJobs);
        }
    }
    task.setStatus ("Saving solver configurations..");
    List < SolverConfiguration > solverConfigurations = new LinkedList < SolverConfiguration > ();
    for (Solver s : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (s)) {
            if (entry.getSolverConfig () == null) {
                SolverConfiguration sc = new SolverConfiguration ();
                sc.setSolverBinary (entry.getSolverBinary ());
                sc.setExperiment_id (activeExperiment.getId ());
                sc.setSeed_group (entry.getSeedGroup ());
                sc.setName (entry.getName ());
                sc.setHint (entry.getHint ());
                entry.setSolverConfig (sc);
                solverConfigurations.add (sc);
            }
        }
    }
    solverConfigCache.createAll (solverConfigurations);
    List < ParameterInstance > parameterInstances = new LinkedList < ParameterInstance > ();
    for (Solver s : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (s)) {
            if (entry.getSolverConfig () == null) {
                entry.setSolverConfig (solverConfigCache.createSolverConfiguration (entry.getSolverBinary (), activeExperiment.getId (), entry.getSeedGroup (), entry.getName (), entry.getHint ()));
            }
            else {
                entry.getSolverConfig ().setSolverBinary (entry.getSolverBinary ());
                entry.getSolverConfig ().setName (entry.getName ());
                entry.getSolverConfig ().setSeed_group (entry.getSeedGroup ());
                entry.getSolverConfig ().setHint (entry.getHint ());
            }
            parameterInstances.addAll (entry.getParameterInstances ());
        }
    }
    ParameterInstanceDAO.saveBulk (parameterInstances);
    solverConfigCache.saveAll ();
    refreshGenerateJobsModel ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            Util.updateTableColumnWidth (main.tblGenerateJobs, 1);
        }
    }
    );
}


public String getBibliographicDetails (String xmlStr) {
    Element response = new Element ("Response");
    Element success = new Element ("Success");
    try {
        Element request = newGenXMLGenerator.getRootElementFromXMLDocument (xmlStr);
        String mode = request.getChildText ("Mode");
        Integer id = null;
        if (mode.equals ("D")) {
            ACQ_REQUEST_AMKey acqRequestAmKey = new ACQ_REQUEST_AMKey ();
            acqRequestAmKey.request_Id = new Integer (request.getChildText ("Id"));
            acqRequestAmKey.library_Id = new Integer (request.getChildText ("LibId"));
            LocalACQ_REQUEST_AM localAcqRequestAm = ((LocalACQ_REQUEST_AMHome) homeFactory.getHome ("ACQ_REQUEST_AM")).findByPrimaryKey (acqRequestAmKey);
            if (localAcqRequestAm != null) {
                if (localAcqRequestAm.getRequest_Type ().equals ("F")) {
                    mode = "A";
                    id = localAcqRequestAm.getAss_Request_Id ();
                }
                else if (localAcqRequestAm.getRequest_Type ().equals ("O")) {
                    mode = "B";
                    id = localAcqRequestAm.getOn_Approval_Id ();
                }
            }
        }
        if (mode.equals ("A")) {
            ACQ_REQUESTKey acqRequestKey = new ACQ_REQUESTKey ();
            if (id != null) acqRequestKey.request_Id = id;
            else acqRequestKey.request_Id = new Integer (request.getChildText ("Id"));
            acqRequestKey.library_Id = new Integer (request.getChildText ("LibId"));
            LocalACQ_REQUEST localAcqRequest = ((LocalACQ_REQUESTHome) homeFactory.getHome ("ACQ_REQUEST")).findByPrimaryKey (acqRequestKey);
            if (localAcqRequest != null) {
                Element title = new Element ("Title");
                title.setText (utility.getTestedString (localAcqRequest.getTitle ()));
                response.addContent (title);
                Element author = new Element ("Author");
                author.setText (utility.getTestedString (localAcqRequest.getAuthor ()));
                response.addContent (author);
                Element edition = new Element ("Edition");
                edition.setText (utility.getTestedString (localAcqRequest.getEdition ()));
                response.addContent (edition);
                Element isbn = new Element ("ISBN");
                isbn.setText (utility.getTestedString (localAcqRequest.getIsbn ()));
                response.addContent (isbn);
                Element series = new Element ("Series");
                series.setText (utility.getTestedString (localAcqRequest.getSeries ()));
                response.addContent (series);
                Element publishYear = new Element ("PublishYear");
                publishYear.setText (utility.getTestedString (localAcqRequest.getPublish_Year ()));
                response.addContent (publishYear);
                Element publisher = new Element ("Publisher");
                publisher.setText (utility.getTestedString (localAcqRequest.getPublisher ()));
                response.addContent (publisher);
                Element publishPlace = new Element ("PublishPlace");
                publishPlace.setText (utility.getTestedString (localAcqRequest.getPublish_Place ()));
                response.addContent (publishPlace);
                Element volume = new Element ("Volume");
                volume.setText (utility.getTestedString (localAcqRequest.getVolume_No ()));
                response.addContent (volume);
            }
        }
        else if (mode.equals ("B")) {
            ACQ_ON_APPROVALKey acqOnApprovalKey = new ACQ_ON_APPROVALKey ();
            if (id != null) acqOnApprovalKey.on_Approval_Id = id;
            else acqOnApprovalKey.on_Approval_Id = new Integer (request.getChildText ("Id"));
            acqOnApprovalKey.library_Id = new Integer (request.getChildText ("LibId"));
            LocalACQ_ON_APPROVAL localAcqOnApproval = ((LocalACQ_ON_APPROVALHome) homeFactory.getHome ("ACQ_ON_APPROVAL")).findByPrimaryKey (acqOnApprovalKey);
            if (localAcqOnApproval != null) {
                Element title = new Element ("Title");
                title.setText (utility.getTestedString (localAcqOnApproval.getTitle ()));
                response.addContent (title);
                Element author = new Element ("Author");
                author.setText (utility.getTestedString (localAcqOnApproval.getAuthor ()));
                response.addContent (author);
                Element edition = new Element ("Edition");
                edition.setText (utility.getTestedString (localAcqOnApproval.getEdition ()));
                response.addContent (edition);
                Element isbn = new Element ("ISBN");
                isbn.setText (utility.getTestedString (localAcqOnApproval.getIsbn ()));
                response.addContent (isbn);
                Element series = new Element ("Series");
                series.setText (utility.getTestedString (localAcqOnApproval.getSeries ()));
                response.addContent (series);
                Element publishYear = new Element ("PublishYear");
                publishYear.setText (utility.getTestedString (localAcqOnApproval.getPublish_Year ()));
                response.addContent (publishYear);
                Element publisher = new Element ("Publisher");
                publisher.setText (utility.getTestedString (localAcqOnApproval.getPublisher ()));
                response.addContent (publisher);
                Element publishPlace = new Element ("PublishPlace");
                publishPlace.setText (utility.getTestedString (localAcqOnApproval.getPublish_Place ()));
                response.addContent (publishPlace);
                Element volume = new Element ("Volume");
                volume.setText (utility.getTestedString (localAcqOnApproval.getVolume_No ()));
                response.addContent (volume);
            }
        }
        else if (mode.equals ("C")) {
            ACQ_SOLI_REQUESTKey acqSoliRequestKey = new ACQ_SOLI_REQUESTKey ();
            acqSoliRequestKey.request_Id = new Integer (request.getChildText ("Id"));
            acqSoliRequestKey.library_Id = new Integer (request.getChildText ("LibId"));
            LocalACQ_SOLI_REQUEST localAcqSoliRequest = ((LocalACQ_SOLI_REQUESTHome) homeFactory.getHome ("ACQ_SOLI_REQUEST")).findByPrimaryKey (acqSoliRequestKey);
            if (localAcqSoliRequest != null) {
                Element title = new Element ("Title");
                title.setText (utility.getTestedString (localAcqSoliRequest.getTitle ()));
                response.addContent (title);
                Element author = new Element ("Author");
                author.setText (utility.getTestedString (localAcqSoliRequest.getAuthor ()));
                response.addContent (author);
                Element edition = new Element ("Edition");
                edition.setText (utility.getTestedString (localAcqSoliRequest.getEdition ()));
                response.addContent (edition);
                Element isbn = new Element ("ISBN");
                isbn.setText (utility.getTestedString (localAcqSoliRequest.getIsbn ()));
                response.addContent (isbn);
                Element series = new Element ("Series");
                series.setText ("");
                response.addContent (series);
                Element publishYear = new Element ("PublishYear");
                publishYear.setText (utility.getTestedString (localAcqSoliRequest.getPublish_Year ()));
                response.addContent (publishYear);
                Element publisher = new Element ("Publisher");
                publisher.setText (utility.getTestedString (localAcqSoliRequest.getPublisher ()));
                response.addContent (publisher);
                Element publishPlace = new Element ("PublishPlace");
                publishPlace.setText (utility.getTestedString (localAcqSoliRequest.getPublish_Place ()));
                response.addContent (publishPlace);
                Element volume = new Element ("Volume");
                volume.setText (utility.getTestedString (localAcqSoliRequest.getVolume_No ()));
                response.addContent (volume);
            }
        }
        success.setText ("Y");
    } catch (Exception e) {
        success.setText ("N");
        e.printStackTrace ();
    }
    response.addContent (success);
    return newGenXMLGenerator.buildXMLDocument (response);
}


-----Function Pair=224=-----==

public void assignQueuesToExperiment (ArrayList < GridQueue > queues) throws SQLException {
    boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        for (GridQueue q : queues) {
            if (ExperimentHasGridQueueDAO.getByExpAndQueue (activeExperiment, q) != null) {
                continue;
            }
            ExperimentHasGridQueueDAO.createExperimentHasGridQueue (activeExperiment, q);
        }
        ArrayList < ExperimentHasGridQueue > ehgqs = ExperimentHasGridQueueDAO.getExperimentHasGridQueueByExperiment (activeExperiment);
        for (ExperimentHasGridQueue egq : ehgqs) {
            boolean found = false;
            for (GridQueue q : queues) {
                if (egq.getIdGridQueue () == q.getId ()) {
                    found = true;
                    break;
                }
            }
            if (! found) {
                ExperimentHasGridQueueDAO.removeExperimentHasGridQueue (egq);
            }
        }
    } catch (SQLException e) {
        DatabaseConnector.getInstance ().getConn ().rollback ();
        throw e;
    } finally {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
    }
}


public String toStr (String str, int radix) {
    char [] baseStrs = new char [94];
    for (int i = 0; i < baseStrs.length; i ++) {
        baseStrs [i] = (char) (i + 33);
    }
    String tempStr = "";
    if (baseStrs.length >= radix && radix > 1) {
        while (! str.equals ("") && new BigInteger (str, 10).compareTo (new BigInteger ("" + radix, 10)) == 1) {
            BigInteger bint = new BigInteger (str, 10);
            int temp = bint.mod (new BigInteger ("" + radix, 10)).intValue ();
            tempStr = baseStrs [temp] + tempStr;
            str = (bint.subtract (new BigInteger ("" + temp, 10))).divide (new BigInteger ("" + radix, 10)).toString ();
        }
        return tempStr;
    }
    else {
        return "";
    }
}


-----Function Pair=225=-----==

public static BigHash getRandomBigHashStartsWith (String prefix) {
    final int modulus = prefix.length () % 4;
    if (modulus != 0) {
        int toAdd = 4 - modulus;
        prefix = prefix + RandomUtil.getString (toAdd);
    }
    byte [] prefixBytes = Base64.decode (prefix);
    if (prefixBytes.length > BigHash.HASH_LENGTH) {
        throw new RuntimeException ("Found prefix with " + prefixBytes.length + " bytes, must be less than " + BigHash.HASH_LENGTH);
    }
    byte [] randomBytes = new byte [BigHash.HASH_LENGTH - prefixBytes.length];
    RandomUtil.getBytes (randomBytes);
    byte [] bigHashBytes = new byte [BigHash.HASH_LENGTH];
    System.arraycopy (prefixBytes, 0, bigHashBytes, 0, prefixBytes.length);
    System.arraycopy (randomBytes, 0, bigHashBytes, prefixBytes.length, randomBytes.length);
    return BigHash.createFromBytes (bigHashBytes);
}


public static byte [] readZipFileBinary (File file) {
    if (! file.isFile () || file.length () == 0) {
        return null;
    }
    final int bufferSize = 4096;
    ZipInputStream zis = null;
    ByteArrayOutputStream out = null;
    try {
        zis = new ZipInputStream (new FileInputStream (file));
        out = new ByteArrayOutputStream ();
        zis.getNextEntry ();
        byte [] zipData = new byte [bufferSize];
        while (true) {
            int len = zis.read (zipData);
            if (len < 0) {
                break;
            }
            out.write (zipData, 0, len);
        }
        zis.close ();
        return out.toByteArray ();
    } catch (FileNotFoundException e) {
        logger.log (Level.SEVERE, "Exception catched", e);
    } catch (IOException e) {
        try {
            if (zis != null) zis.close ();
        } catch (Throwable t) {
        }
        try {
            if (out != null) out.close ();
        } catch (Throwable t) {
        }
        logger.log (Level.SEVERE, "Exception thrown in readZipFile(String path) \n" + "Offending file saved as badfile.zip, send to a dev for analysis", e);
        copyFile (file.getPath (), "badfile.zip");
    }
    return null;
}


-----Function Pair=226=-----==

public void calculateCosts (Tasks task, String costFunction, ArrayList < SolverConfiguration > solverConfigs) throws Exception {
    task.setOperationName ("Calculating cost for " + costFunction);
    if (costFunction == null) {
        throw new IllegalArgumentException ("cost function cannot be null");
    }
    else if (solverConfigs == null || solverConfigs.isEmpty ()) {
        throw new IllegalArgumentException ("no solver configurations for cost calculation selected");
    }
    else if (activeExperiment == null) {
        throw new IllegalArgumentException ("no experiment loaded");
    }
    for (SolverConfiguration solverConfig : solverConfigs) {
        if (solverConfig.getExperiment_id () != activeExperiment.getId ()) {
            throw new IllegalArgumentException ("calculating costs for other experiments than the loaded experiment is currently not supported");
        }
    }
    CostFunction cFunction = costFunctionByName (costFunction);
    if (cFunction == null) {
        throw new Exception ("invalid cost function");
    }
    task.setStatus ("Updating jobs..");
    experimentResultCache.updateExperimentResults ();
    task.setStatus ("Calculating..");
    for (SolverConfiguration solverConfig : solverConfigs) {
        Float cost = cFunction.calculateCost (experimentResultCache.getResults (solverConfig.getId ()));
        solverConfig.setCost (cost);
        solverConfig.setCost_function (cFunction.databaseRepresentation ());
    }
}


protected ActionForward doAdmin (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    ExportOntologyForm eof = (ExportOntologyForm) form;
    String filename;
    try {
        URL oUrl = new URL (eof.getOntologyURI ());
        filename = oUrl.getFile ();
    } catch (MalformedURLException mue) {
        filename = eof.getOntologyURI ();
    }
    if (eof.getZip () == null || eof.getZip ().equals ("none")) {
        response.setContentType ("application/xml");
        if (eof.getSaveToDisk ()) {
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".owl");
        }
        response.getWriter ().write ("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
        ModelCache.getSingleton ().exportOntology (eof.getOntologyURI (), response.getWriter ());
    }
    else if (eof.getZip ().equals ("zip") || eof.getZip ().equals ("gzip")) {
        OutputStream compressedOut;
        if (eof.getZip ().equals ("zip")) {
            response.setContentType ("application/zip");
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".zip");
            ZipOutputStream zipout = new ZipOutputStream (response.getOutputStream ());
            zipout.putNextEntry (new ZipEntry (filename));
            compressedOut = zipout;
        }
        else {
            response.setContentType ("application/gzip");
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".gz");
            compressedOut = new GZIPOutputStream (response.getOutputStream ());
        }
        OutputStreamWriter osw = new OutputStreamWriter (compressedOut);
        osw.write ("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
        ModelCache.getSingleton ().exportOntology (eof.getOntologyURI (), osw);
        osw.close ();
    }
    return null;
}


-----Function Pair=227=-----==

private void updateRapidMiner (InputStream openStream, String version) throws IOException {
    File updateDir = new File (FileSystemService.getRapidMinerHome (), "update");
    if (! updateDir.exists ()) {
        if (! updateDir.mkdir ()) {
            throw new IOException ("Cannot create update directory. Please ensure you have administrator permissions.");
        }
    }
    if (! updateDir.canWrite ()) {
        throw new IOException ("Cannot write to update directory. Please ensure you have administrator permissions.");
    }
    File updateFile = new File (updateDir, "rmupdate-" + version + ".jar");
    Tools.copyStreamSynchronously (openStream, new FileOutputStream (updateFile), true);
    File ruInstall = new File (FileSystemService.getRapidMinerHome (), "RUinstall");
    ZipFile zip = new ZipFile (updateFile);
    Enumeration < ? extends ZipEntry > en = zip.entries ();
    while (en.hasMoreElements ()) {
        ZipEntry entry = en.nextElement ();
        if (entry.isDirectory ()) {
            continue;
        }
        String name = entry.getName ();
        if ("META-INF/UPDATE".equals (name)) {
            Tools.copyStreamSynchronously (zip.getInputStream (entry), new FileOutputStream (new File (updateDir, "UPDATE")), true);
            continue;
        }
        if (name.startsWith ("rapidminer/")) {
            name = name.substring ("rapidminer/".length ());
        }
        File dest = new File (ruInstall, name);
        File parent = dest.getParentFile ();
        if (parent != null && ! parent.exists ()) {
            parent.mkdirs ();
        }
        Tools.copyStreamSynchronously (zip.getInputStream (entry), new FileOutputStream (dest), true);
    }
    zip.close ();
    updateFile.delete ();
    LogService.getRoot ().info ("Prepared RapidMiner for update. Restart required.");
}


private void zip (String base, Set < DataFile > dss, ZipOutputStream zout) throws IOException, Exception {
    for (DataFile ds : dss) {
        if (ds.isDirectory ()) {
            ZipEntry entry = new ZipEntry (base + ds.getName () + "/");
            entry.setMethod (ZipEntry.DEFLATED);
            try {
                zout.putNextEntry (entry);
                zout.closeEntry ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
                Core.Logger.log (ioe.getMessage (), Level.WARNING);
            }
            zip (base + ds.getName () + "/", ds.children (), zout);
        }
        else {
            int read;
            byte [] buff = new byte [0x800];
            ZipEntry entry = new ZipEntry (base + ds.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            try {
                InputStream in = ds.getInputStream ();
                zout.putNextEntry (entry);
                progress_bytes_max = ds.size ();
                progress_bytes_current = 0;
                while ((read = in.read (buff)) != - 1) {
                    zout.write (buff, 0, read);
                    progress_bytes_current += read;
                    if (stopped) throw new Exception ("Thread stopped by user input.");
                }
                zout.closeEntry ();
                progress_file_current ++;
                in.close ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
                Core.Logger.log (ioe.getMessage (), Level.WARNING);
            }
        }
    }
}


-----Function Pair=228=-----==

public void unpack (InputStream in0, JarOutputStream out) throws IOException {
    assert (Utils.currentInstance.get () == null);
    TimeZone tz = (_props.getBoolean (Utils.PACK_DEFAULT_TIMEZONE)) ? null : TimeZone.getDefault ();
    try {
        Utils.currentInstance.set (this);
        if (tz != null) TimeZone.setDefault (TimeZone.getTimeZone ("UTC"));
        final int verbose = _props.getInteger (Utils.DEBUG_VERBOSE);
        BufferedInputStream in = new BufferedInputStream (in0);
        if (Utils.isJarMagic (Utils.readMagic (in))) {
            if (verbose > 0) Utils.log.info ("Copying unpacked JAR file...");
            Utils.copyJarFile (new JarInputStream (in), out);
        }
        else if (_props.getBoolean (Utils.DEBUG_DISABLE_NATIVE)) {
            (new DoUnpack ()).run (in, out);
            in.close ();
            Utils.markJarFile (out);
        }
        else {
            (new NativeUnpack (this)).run (in, out);
            in.close ();
            Utils.markJarFile (out);
        }
    } finally {
        _nunp = null;
        Utils.currentInstance.set (null);
        if (tz != null) TimeZone.setDefault (tz);
    }
}


public Map < String, Set < Object > > extractEclipseTargetProperties () throws ZipException, IOException, FileNotFoundException {
    Map < String, Set < Object > > propertiesMap = new HashMap < String, Set < Object > > ();
    InputStream jarPluginInputStream = new FileInputStream (eclipseInstallPlugin.getPluginLocation ());
    ZipInputStream inputStream = new ZipInputStream (jarPluginInputStream);
    ZipEntry entry;
    while ((entry = inputStream.getNextEntry ()) != null) {
        String entryName = entry.getName ();
        if (entryName.endsWith (Messages.getString ("Extensions_properties"))) {
            Properties properties = new Properties ();
            properties.load (inputStream);
            propertiesMap.put (entry.getName (), new HashSet < Object > (properties.keySet ()));
        }
    }
    return propertiesMap;
}


-----Function Pair=229=-----==

public static ResultDataFile parseXMLContent (Source rawdata, Element cross) throws FactoryConfigurationError, IOException, ParserConfigurationException, SAXException {
    logger.debug ("create transfomer");
    ToDatafileTransformHandler handler = new ToDatafileTransformHandler ();
    logger.debug ("calculate parameters");
    try {
        XmlHandling.logXML (logger, cross);
    } catch (Exception e) {
    }
    List headers = cross.getChild ("header").getChildren ("param");
    Iterator it = headers.iterator ();
    while (it.hasNext ()) {
        String headerContent = ((Element) it.next ()).getAttributeValue ("value");
        logger.debug ("defining header: " + headerContent);
        handler.addHeader (headerContent);
    }
    logger.info ("set key: " + cross.getAttributeValue ("attribute"));
    handler.setKey (cross.getAttributeValue ("attribute"));
    logger.debug ("create parser");
    SAXParserFactory factory = SAXParserFactory.newInstance ();
    factory.setValidating (false);
    InputStream stream = rawdata.getStream ();
    SAXParser builder = factory.newSAXParser ();
    logger.debug ("parse document into handler");
    builder.parse (stream, handler);
    stream.close ();
    logger.debug ("parsing is done");
    stream = null;
    builder = null;
    factory = null;
    System.gc ();
    ResultDataFile file = maskDatafile (handler, headers);
    combineBins (cross, file);
    file.setResultId (handler.getResultId ());
    file.setDatabase (handler.getDatabase ());
    return file;
}


public static String getFormattedTimeString (long milliSec, String separator, String dateSeparator, String timeSeparator) {
    Calendar cal = Calendar.getInstance ();
    cal.setTimeInMillis (milliSec);
    int year = cal.get (Calendar.YEAR);
    int month = cal.get (Calendar.MONTH) + 1;
    int date = cal.get (Calendar.DATE);
    int hour = cal.get (Calendar.HOUR_OF_DAY);
    int min = cal.get (Calendar.MINUTE);
    int sec = cal.get (Calendar.SECOND);
    Formatter fmt = new Formatter ();
    if ((separator == null) || (separator.length () == 0)) {
        separator = "_";
    }
    if ((dateSeparator == null) || (dateSeparator.length () == 0)) {
        dateSeparator = ".";
    }
    if ((timeSeparator == null) || (timeSeparator.length () == 0)) {
        timeSeparator = ".";
    }
    final String formatStr = "%4d" + dateSeparator + "%02d" + dateSeparator + "%02d" + separator + "%02d" + timeSeparator + "%02d" + timeSeparator + "%02d";
    fmt.format (formatStr, year, month, date, hour, min, sec);
    return fmt.toString ();
}


-----Function Pair=230=-----==

public static long getDifDate (String data1, String data2) {
    long dif = 0;
    if (Util.isNull (data1) || Util.isNull (data2)) {
        return 0;
    }
    try {
        int d1 = Integer.parseInt (getDia (data1));
        int m1 = Integer.parseInt (getMes (data1));
        int a1 = Integer.parseInt (getAno (data1));
        int d2 = Integer.parseInt (getDia (data2));
        int m2 = Integer.parseInt (getMes (data2));
        int a2 = Integer.parseInt (getAno (data2));
        GregorianCalendar g1 = new GregorianCalendar (a1, m1 - 1, d1, 0, 0);
        GregorianCalendar g2 = new GregorianCalendar (a2, m2 - 1, d2, 0, 0);
        dif = g2.getTimeInMillis () - g1.getTimeInMillis ();
    } catch (NumberFormatException ex) {
        ex.printStackTrace ();
    }
    return (dif / 1000) / 60 / 60 / 24;
}


public void onClick (DialogInterface dialog, int whichButton) {
    EditText label = (EditText) mAnnotationLabelDialog.findViewById (R.id.annotation_label_text);
    ContentValues values = new ContentValues ();
    String labelText = label.getText ().toString ();
    values.put (Annotations.LABEL, labelText);
    ContentResolver resolver = mActivity.getContentResolver ();
    Uri renamedAnnotationUri = ContentUris.withAppendedId (Annotations.CONTENT_URI, mAnnotationLabelId);
    resolver.update (renamedAnnotationUri, values, null, null);
    String [] projection = {Annotations._ID, Annotations.FILE_NAME};
    Cursor renamedAnnotationCursor = resolver.query (renamedAnnotationUri, projection, null, null, Annotations.DEFAULT_SORT_ORDER);
    if (renamedAnnotationCursor.getCount () >= 1) {
        renamedAnnotationCursor.moveToFirst ();
        String oldFileName = renamedAnnotationCursor.getString (1);
        File oldFile = new File (oldFileName);
        String newFileName = oldFile.getParent () + "/audio_" + mAnnotationLabelId + "_" + labelText.replaceAll (" ", "_").replaceAll ("[^a-zA-Z0-9_]", "") + oldFileName.substring (oldFileName.length () - 4);
        Log.d (SessionPlayback.class.getName (), "renaming file " + oldFileName + " to " + newFileName);
        File newFile = new File (newFileName);
        boolean success = oldFile.renameTo (newFile);
        if (success) {
            ContentValues renamedValues = new ContentValues ();
            renamedValues.put (Annotations.FILE_NAME, newFileName);
            resolver.update (renamedAnnotationUri, renamedValues, null, null);
        }
    }
    renamedAnnotationCursor.close ();
    mAnnotationLabelDialog = null;
}


-----Function Pair=231=-----==

private static void getWatcherOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT watcherOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("watcherOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


public static void zippaCartella (String strPathOrigine, String strPathDestinazione, String [] tipofiles) throws Exception {
    String strTemp = "";
    int i = 0;
    try {
        File f = new File (strPathOrigine);
        File fList [] = f.listFiles ();
        for (i = 0; i < fList.length; i ++) {
            if (fList [i].isFile ()) {
                strTemp = fList [i].getName ().toLowerCase ();
                if (strTemp.substring (strTemp.length () - 4).indexOf (".zip") == - 1) {
                    for (String tipo : tipofiles) {
                        if (tipo.equals (strTemp.substring (strTemp.lastIndexOf (".")))) {
                            FileOutputStream dest = new FileOutputStream (strPathDestinazione + "/" + strTemp.substring (0, strTemp.length () - 4) + ".zip");
                            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
                            aggFile (out, strPathOrigine, strTemp);
                            out.close ();
                            out = null;
                            dest.close ();
                            dest = null;
                            break;
                        }
                    }
                }
            }
        }
        fList = null;
        f = null;
    } catch (Exception e) {
        new Exception ("\n zippaCartella : " + e.getMessage ());
    }
}


-----Function Pair=232=-----==

public void deleteEntry (int id, int dbid) throws StatementNotExecutedException, EntriesException, NoRightException {
    Key recordID = new Key (id, dbid);
    Key projID = query.getInputUnitManager ().getProjectID (recordID);
    Project proj = query.getProjectManager ().getProject (projID.getID (), projID.getDBNumber ());
    Right right = query.getUserManager ().getRight (project.getProjectKey ());
    if (right != Right.WRITE) {
        throw new NoRightException (NoRightException.Rights.NOWRITE);
    }
    Key massid = query.getInputUnitManager ().getMassKey (recordID);
    query.getMeasurementManager ().deleteValue (massid);
    Key wearstage2Key = query.getInputUnitManager ().getWearstage2Key (recordID);
    Key artefactID = query.getInputUnitManager ().getArtefactId (recordID);
    query.getArtefactManager ().deleteValue (artefactID);
    query.getInputUnitManager ().deleteValue (recordID);
    query.getWearstage2Manager ().deleteValue (wearstage2Key);
    query.getAnimalManager ().deleteValue (recordID);
    query.getBoneElementManager ().deleteValue (recordID);
    query.getGeneLibaryManager ().deleteValue (recordID);
}


public static void writeEntry (File file, File input) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ARGOUML_EXT);
        temporaryFile.deleteOnExit ();
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        FileInputStream inputStream = new FileInputStream (input);
        ZipEntry entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT);
        output.putNextEntry (new ZipEntry (entry));
        IOUtils.copy (inputStream, output);
        output.closeEntry ();
        inputStream.close ();
        entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + ".argo");
        output.putNextEntry (new ZipEntry (entry));
        output.write (ArgoWriter.getArgoContent (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT).getBytes ());
        output.closeEntry ();
        output.close ();
        temporaryFile.renameTo (file);
    } catch (IOException ioe) {
        throw new PersistenceException (ioe);
    }
}


-----Function Pair=233=-----==

public void deleteEntry (int id, int dbid) throws StatementNotExecutedException, EntriesException, NoRightException {
    Key recordID = new Key (id, dbid);
    Key projID = query.getInputUnitManager ().getProjectID (recordID);
    Project proj = query.getProjectManager ().getProject (projID.getID (), projID.getDBNumber ());
    Right right = query.getUserManager ().getRight (project.getProjectKey ());
    if (right != Right.WRITE) {
        throw new NoRightException (NoRightException.Rights.NOWRITE);
    }
    Key massid = query.getInputUnitManager ().getMassKey (recordID);
    query.getMeasurementManager ().deleteValue (massid);
    Key wearstage2Key = query.getInputUnitManager ().getWearstage2Key (recordID);
    Key artefactID = query.getInputUnitManager ().getArtefactId (recordID);
    query.getArtefactManager ().deleteValue (artefactID);
    query.getInputUnitManager ().deleteValue (recordID);
    query.getWearstage2Manager ().deleteValue (wearstage2Key);
    query.getAnimalManager ().deleteValue (recordID);
    query.getBoneElementManager ().deleteValue (recordID);
    query.getGeneLibaryManager ().deleteValue (recordID);
}


public static void unzip (final File _zipFile, final File _dirToUnzip, ProgressionInterface _prog) throws IOException {
    ZipFile zf = null;
    try {
        zf = new ZipFile (_zipFile);
        int nbFiles = 0;
        int indFile = 0;
        if (_prog != null) {
            _prog.setProgression (0);
            nbFiles = zf.size ();
        }
        for (Enumeration < ? extends ZipEntry > e = zf.entries (); e.hasMoreElements ();) {
            ZipEntry entry = e.nextElement ();
            if (entry.isDirectory ()) {
                new File (_dirToUnzip, entry.getName ()).mkdirs ();
            }
            else {
                new File (_dirToUnzip, entry.getName ()).getParentFile ().mkdirs ();
                FileOutputStream fout = new FileOutputStream (new File (_dirToUnzip, entry.getName ()));
                copyStream (zf.getInputStream (entry), fout, false, true);
            }
            if (_prog != null) {
                indFile ++;
                _prog.setProgression ((int) ((indFile / (double) nbFiles) * 85) + 10);
            }
        }
    } finally {
        if (zf != null) {
            zf.close ();
        }
        if (_prog != null) _prog.setProgression (100);
    }
}


-----Function Pair=234=-----==

public ErrorSet checkContents () {
    ErrorSet err = super.checkContents ();
    if (usite == null) {
        err.add (new UError (id, "No Usite selected."));
    }
    else {
        boolean foundUsite = false;
        Vector knownUsites = ResourceManager.getUsites ();
        for (int i = 0; i < knownUsites.size (); i ++) {
            if (knownUsites.elementAt (i).equals (usite)) {
                foundUsite = true;
                usite = (Usite) knownUsites.elementAt (i);
                break;
            }
        }
        if (! foundUsite) {
            usite = null;
            err.add (new UError (id, res.getString ("NO_USITE")));
        }
        else {
            boolean foundVsite = false;
            Vector knownVsites = ResourceManager.getVsites (usite);
            for (int i = 0; i < knownVsites.size (); i ++) {
                Vsite knownVsite = (Vsite) knownVsites.elementAt (i);
                if ((vsite != null) && vsite.equals (knownVsite)) {
                    foundVsite = true;
                    vsite = knownVsite;
                    break;
                }
            }
            if (! foundVsite) {
                vsite = null;
            }
            else if (! ResourceManager.isVsiteAvailable (vsite)) {
                err.add (new UError (id, ResourceManager.getVsiteErrorMessage (vsite)));
            }
            if (vsite == null || vsite.getAddress () == null || vsite.getName () == null) {
                err.add (new UError (id, res.getString ("NO_VSITE_ENTRY")));
            }
        }
    }
    if (getTasks ().isEmpty ()) {
        err.add (new UError (id, res.getString ("EMPTY_GROUP")));
    }
    if (err.containsError ()) {
        updateIcon (Color.red);
    }
    else {
        updateIcon (Color.green);
    }
    setErrors (err);
    selectJPAIcon ();
    return err;
}


public static void main (final String [] args) throws IOException {
    File f = new File (args [0]);
    InputStream is = new GZIPInputStream (new FileInputStream (f));
    BufferedReader lnr = new LineNumberReader (new InputStreamReader (is));
    while (true) {
        String line = lnr.readLine ();
        if (line != null) {
            if (line.startsWith ("class")) {
                String c = line.substring (6, line.lastIndexOf (' '));
                String sc = line.substring (line.lastIndexOf (' ') + 1);
                HIERARCHY.put (c, sc);
            }
            else {
                API.add (line);
            }
        }
        else {
            break;
        }
    }
    optimize (new File (args [1]));
}


-----Function Pair=235=-----==

private void extractEntries (String [] entryNames, String [] fileNames, boolean overWrite) {
    try {
        ZipInputStream zin = new ZipInputStream (new FileInputStream (selfFile));
        ZipEntry entry;
        while ((entry = zin.getNextEntry ()) != null) {
            int index = getContainEntry (entry.getName (), entryNames);
            if ((index != - 1) && (overWrite || ! FileUtil.isFileExist (fileNames [index]))) {
                byte [] buf = new byte [4096];
                BufferedInputStream bin = new BufferedInputStream (zin);
                FileUtil.makeDirectory (fileNames [index]);
                BufferedOutputStream bout = new BufferedOutputStream (new FileOutputStream (fileNames [index]));
                while (bin.read (buf, 0, 1) != - 1) {
                    bout.write (buf, 0, 1);
                }
                bout.close ();
                bin.close ();
            }
            zin.closeEntry ();
        }
        zin.close ();
    } catch (IOException e) {
        logger.error (e.getLocalizedMessage ());
    }
}


private static void writeZipBytes (int rootLength, File file, ZipOutputStream out) throws Exception {
    if (file.isFile ()) {
        final int BUFFER = 2048;
        byte data [] = new byte [BUFFER];
        FileInputStream fin = new FileInputStream (file);
        BufferedInputStream original = new BufferedInputStream (fin, BUFFER);
        String entryName = file.getAbsolutePath ().substring (rootLength + 1);
        ZipEntry entry = new ZipEntry (entryName);
        out.putNextEntry (entry);
        int readed;
        while ((readed = original.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, readed);
        }
        original.close ();
    }
    else {
        File [] files = file.listFiles ();
        for (File _file : files) {
            writeZipBytes (rootLength, _file, out);
        }
    }
}


-----Function Pair=236=-----==

private void addDir (File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (files [i], out);
            continue;
        }
        String dir = dirObj.toString ();
        dir = dir.substring (dir.indexOf (File.separator) + 1);
        FileInputStream in = new FileInputStream (dirObj + File.separator + files [i].getName ());
        out.putNextEntry (new ZipEntry (dir + File.separator + files [i].getName ()));
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


protected EObject getEObjectByID (String id) {
    Map < String, EObject > map = getIntrinsicIDToEObjectMap ();
    if (map != null) {
        EObject eObject = map.get (id);
        if (eObject != null) {
            return eObject;
        }
    }
    EObject result = null;
    for (TreeIterator < EObject > i = getAllProperContents (getContents ()); i.hasNext ();) {
        EObject eObject = i.next ();
        String eObjectId = EcoreUtil.getID (eObject);
        if (eObjectId != null) {
            if (map != null) {
                map.put (eObjectId, eObject);
            }
            if (eObjectId.equals (id)) {
                result = eObject;
                if (map == null) {
                    break;
                }
            }
        }
    }
    return result;
}


-----Function Pair=237=-----==

private void copyFiles (File fromParent, File toParent, boolean include, boolean specialDir) throws IOException {
    File [] files = fromParent.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory () && ! files [i].isHidden ()) {
            if (specialDir) {
                String name = files [i].getName ();
                if ("resource".equals (name)) {
                    copyFiles (files [i], toParent, true, false);
                    continue;
                }
                else if ("template".equals (name)) {
                    continue;
                }
                File newDir = new File (toParent, files [i].getName ());
                newDir.mkdirs ();
                copyFiles (files [i], newDir, true, true);
                if (newDir.listFiles ().length == 0) {
                    newDir.delete ();
                }
            }
            else {
                File newDir = new File (toParent, files [i].getName ());
                newDir.mkdirs ();
                copyFiles (files [i], newDir, false, false);
                if (newDir.listFiles ().length == 0) {
                    newDir.delete ();
                }
            }
        }
        else if (files [i].isFile () && ! includeFile (files [i], exceptLocalFiles) && (include || ! includeFile (files [i], exceptFiles))) {
            File newFile = new File (toParent, files [i].getName ());
            FileInputStream fis = new FileInputStream (files [i]);
            FileOutputStream fos = new FileOutputStream (newFile);
            byte [] buf = new byte [1024];
            int begin;
            while ((begin = fis.read (buf, 0, 1024)) != - 1) {
                fos.write (buf, 0, begin);
            }
            fis.close ();
            fos.close ();
        }
    }
}


public static LinkedList < Instance > getAllByInstanceClasses (Vector < InstanceClass > allChoosen) throws NoConnectionToDBException, SQLException {
    if (! allChoosen.isEmpty ()) {
        String query = "SELECT i.idInstance, i.md5, i.name" + " FROM " + table + " as i " + " LEFT JOIN Instances_has_instanceClass as ii ON i.idInstance = ii.Instances_idInstance " + " WHERE ii.instanceClass_idinstanceClass = " + allChoosen.get (0).getInstanceClassID ();
        for (int i = 1; i < allChoosen.size (); i ++) {
            query += " OR ii.instanceClass_idinstanceClass = " + allChoosen.get (i).getInstanceClassID ();
        }
        Statement st = DatabaseConnector.getInstance ().getConn ().createStatement ();
        ResultSet rs = st.executeQuery (query);
        LinkedList < Instance > res = new LinkedList < Instance > ();
        ArrayList < Instance > instanceHasPropertyAssignList = new ArrayList < Instance > ();
        while (rs.next ()) {
            Instance c = cache.getCached (rs.getInt ("i.idInstance"));
            if (c != null) {
                res.add (c);
                continue;
            }
            Instance i = new Instance ();
            i.setId (rs.getInt ("i.idInstance"));
            i.setMd5 (rs.getString ("i.md5"));
            i.setName (rs.getString ("i.name"));
            i.setSaved ();
            cache.cache (i);
            res.add (i);
            instanceHasPropertyAssignList.add (i);
        }
        rs.close ();
        InstanceHasPropertyDAO.assign (instanceHasPropertyAssignList);
        return res;
    }
    return null;
}


-----Function Pair=238=-----==

public static void saveZipComponents (ZipComponents zipComponents, File zipFile) throws FileNotFoundException, IOException, Exception {
    ZipOutputStream zipOutStream = new ZipOutputStream (new FileOutputStream (zipFile));
    for (ZipComponent comp : zipComponents.getComponents ()) {
        ZipEntry newEntry = new ZipEntry (comp.getName ());
        zipOutStream.putNextEntry (newEntry);
        if (comp.isDirectory ()) {
        }
        else {
            if (comp.getName ().endsWith ("document.xml") || comp.getName ().endsWith ("document.xml.rels")) {
            }
            InputStream inputStream = comp.getInputStream ();
            IOUtils.copy (inputStream, zipOutStream);
            inputStream.close ();
        }
    }
    zipOutStream.close ();
}


File zip (File dir, File zipFile) throws IOException {
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
    for (File file : dir.listFiles ()) {
        if (file.isFile ()) {
            byte [] data = new byte [(int) file.length ()];
            DataInputStream in = new DataInputStream (new FileInputStream (file));
            in.readFully (data);
            in.close ();
            zipOut.putNextEntry (new ZipEntry (file.getName ()));
            zipOut.write (data, 0, data.length);
            zipOut.closeEntry ();
        }
    }
    zipOut.close ();
    return zipFile;
}


-----Function Pair=239=-----==

private void openAndReadInfo () {
    try {
        File sourceZipFile = new File (fileName);
        zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
        ZipEntry infoEntry = zipFile.getEntry ("info.bin");
        inFile = new DataInputStream (zipFile.getInputStream (infoEntry));
        int version = inFile.readInt ();
        int minorversion = inFile.readInt ();
        intervall_s = inFile.readDouble ();
        OTFVisConfig config = (OTFVisConfig) Gbl.getConfig ().getModule (OTFVisConfig.GROUP_NAME);
        config.setFileVersion (version);
        config.setFileMinorVersion (minorversion);
    } catch (IOException e1) {
        e1.printStackTrace ();
    }
}


public void drawPlanePNG () {
    final BufferedImage img = new BufferedImage (planeSize, planeSize, BufferedImage.TYPE_INT_RGB);
    final Graphics2D gr = img.createGraphics ();
    paintComponent (gr);
    nf.setMinimumIntegerDigits (5);
    nf.setMaximumIntegerDigits (5);
    nf.setGroupingUsed (false);
    try {
        final String filename = "visualization" + nf.format (frame_nr) + ".png";
        final File f = new File (filename);
        final FileOutputStream out = new FileOutputStream (f);
        javax.imageio.ImageIO.write (img, "png", out);
        out.close ();
        System.err.println ("output saved as: " + f.getAbsolutePath ());
        filenames.add (filename);
        frame_nr ++;
    } catch (final Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=240=-----==

private String readUTF () throws IOException {
    int utflen = bb.getShort ();
    StringBuffer str = new StringBuffer (utflen);
    byte [] bytearr = new byte [utflen];
    int c;
    int char2;
    int char3;
    int count = 0;
    bb.get (bytearr, 0, utflen);
    while (count < utflen) {
        c = (int) bytearr [count] & 0xff;
        switch (c>> 4) {
            case 0 :
            case 1 :
            case 2 :
            case 3 :
            case 4 :
            case 5 :
            case 6 :
            case 7 :
                count ++;
                str.append ((char) c);
                break;
            case 12 :
            case 13 :
                count += 2;
                if (count > utflen) {
                    UTFDataFormatException ex = new UTFDataFormatException ();
                    X3DLog.print (ex);
                    throw ex;
                }
                char2 = (int) bytearr [count - 1];
                if ((char2 & 0xC0) != 0x80) {
                    UTFDataFormatException ex = new UTFDataFormatException ();
                    X3DLog.print (ex);
                    throw ex;
                }
                str.append ((char) (((c & 0x1F) << 6) | (char2 & 0x3F)));
                break;
            case 14 :
                count += 3;
                if (count > utflen) {
                    UTFDataFormatException ex = new UTFDataFormatException ();
                    X3DLog.print (ex);
                    throw ex;
                }
                char2 = (int) bytearr [count - 2];
                char3 = (int) bytearr [count - 1];
                if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80)) {
                    UTFDataFormatException ex = new UTFDataFormatException ();
                    X3DLog.print (ex);
                    throw ex;
                }
                str.append ((char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0)));
                break;
            default :
                UTFDataFormatException ex = new UTFDataFormatException ();
                X3DLog.print (ex);
                throw ex;
        }
    }
    return (new String (str));
}


private Actor findWitness (Actor closest_npc []) {
    Vector < GameObject > npcs = new Vector < GameObject > ();
    mainActor.findNearbyActors (npcs, EConst.c_any_shapenum, 12, 0x28);
    closest_npc [0] = null;
    int closest_dist = 5000;
    Actor witness = null;
    int closest_witness_dist = 5000;
    for (GameObject each : npcs) {
        Actor npc = (Actor) each;
        if (npc instanceof MonsterActor || npc.getFlag (GameObject.in_party) || (npc.getFrameNum () & 15) == Actor.sleep_frame || npc.getNpcNum () >= numNpcs1) continue;
        int dist = npc.distance (mainActor);
        if (dist >= closest_witness_dist || ! PathFinder.FastClient.isGrabable (npc, mainActor)) continue;
        int dir = npc.getDirection (mainActor);
        int facing = npc.getDirFacing ();
        int dirdiff = (dir - facing + 8) % 8;
        if (dirdiff < 3 || dirdiff > 5) {
            witness = npc;
            closest_witness_dist = dist;
        }
        else if (dist < closest_dist) {
            closest_npc [0] = npc;
            closest_dist = dist;
        }
    }
    return witness;
}


-----Function Pair=241=-----==

public void addResourcesFromFolder (final ZipOutStreamTaskAdapter out, final TreeItemDecorator < FolderEntity > folder, final String zipPath) throws IOException, TaskTimeoutException {
    addFolder (out, folder.getEntity (), zipPath);
    List < String > childrenNames = new ArrayList < String > ();
    for (TreeItemDecorator < FolderEntity > child : folder.getChildren ()) {
        addResourcesFromFolder (out, child, zipPath + child.getEntity ().getName () + "/");
        childrenNames.add (child.getEntity ().getName ());
    }
    if (zipPath.startsWith ("page/")) {
        String pageURL = zipPath.replace ("page", "");
        if (! pageURL.equals ("/")) {
            pageURL = pageURL.substring (0, pageURL.length () - 1);
        }
        List < PageEntity > children = getDao ().getPageDao ().getByParent (pageURL);
        for (PageEntity child : children) {
            if (! childrenNames.contains (child.getPageFriendlyURL ())) {
                addResourcesFromPage (out, child.getFriendlyURL (), zipPath + child.getPageFriendlyURL () + "/");
            }
        }
        List < PageEntity > pages = getDao ().getPageDao ().selectByUrl (pageURL);
        if (pages.size () > 0) {
            addPageFiles (out, pages.get (0), zipPath);
        }
    }
    List < FileEntity > files = getDao ().getFileDao ().getByFolder (folder.getEntity ().getId ());
    for (FileEntity file : files) {
        String filePath = zipPath + file.getFilename ();
        if (! out.isSkip (filePath)) {
            out.putNextEntry (new ZipEntry (filePath));
            out.write (getDao ().getFileDao ().getFileContent (file));
            out.closeEntry ();
            out.nextFile ();
        }
    }
}


private static void unzip (File srcFile, File dstDir) throws IOException {
    byte [] buffer = new byte [ZIP_BUFFER_SIZE];
    int bytes;
    ZipFile zipFile = new ZipFile (srcFile);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.isDirectory ()) {
            File newDirectory = new File (entry.getName ());
            if (! newDirectory.exists ()) newDirectory.mkdirs ();
            continue;
        }
        File newFile = new File (dstDir, entry.getName ());
        File newFileDir = newFile.getParentFile ();
        if (! newFileDir.exists ()) newFileDir.mkdirs ();
        InputStream in = zipFile.getInputStream (entry);
        OutputStream out = new BufferedOutputStream (new FileOutputStream (newFile));
        while ((bytes = in.read (buffer)) >= 0) out.write (buffer, 0, bytes);
        in.close ();
        out.close ();
    }
    zipFile.close ();
}


-----Function Pair=242=-----==

public static ZipContents extractZip (final File zipFile, final File tmpDir) throws IOException {
    final File tmpCopy = File.createTempFile (FileUtils.sanitizeFileName (zipFile.getName ()), "copy");
    FileUtils.copyFile (zipFile, tmpCopy);
    final ZipFile zip = new ZipFile (tmpCopy, ZipFile.OPEN_READ);
    final Map < String, File > fileEntryMap = new LinkedHashMap < String, File > ();
    final File tmpPathDir = new File (tmpDir.getAbsolutePath () + File.separator + FileUtils.sanitizeFileName (zipFile.getName ()));
    tmpPathDir.mkdirs ();
    final Enumeration < ZipEntry > enumerated = (Enumeration < ZipEntry >) zip.entries ();
    while (enumerated.hasMoreElements ()) {
        final ZipEntry zipEntry = enumerated.nextElement ();
        final File out = FileUtils.copyFileFromZip (zip, zipEntry, tmpPathDir);
        fileEntryMap.put (out.getAbsolutePath (), out);
    }
    return new ZipContents (fileEntryMap, tmpPathDir);
}


public static byte [] zipEntriesAndFiles (Map < ZipEntry, byte [] > files) throws IOException {
    ByteArrayOutputStream dest = new ByteArrayOutputStream ();
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    byte [] data = new byte [2048];
    Iterator < Entry < ZipEntry, byte [] > > itr = files.entrySet ().iterator ();
    while (itr.hasNext ()) {
        Entry < ZipEntry, byte [] > entry = itr.next ();
        ByteArrayInputStream bytesIn = new ByteArrayInputStream (entry.getValue ());
        BufferedInputStream origin = new BufferedInputStream (bytesIn, 2048);
        out.putNextEntry (entry.getKey ());
        int count;
        while ((count = origin.read (data, 0, 2048)) != - 1) {
            out.write (data, 0, count);
        }
        bytesIn.close ();
        origin.close ();
    }
    out.close ();
    byte [] outBytes = dest.toByteArray ();
    dest.close ();
    return outBytes;
}


-----Function Pair=243=-----==

public static String zir (String zips) throws Exception {
    String s = "", ss = "", sz = "";
    int n = 0;
    File f = new File (zips);
    for (int i = 0; i < f.list ().length; i ++) {
        s = f.list () [i];
        s = s.substring (s.indexOf ("-") + 1, s.indexOf ("."));
        n = n + Integer.parseInt (s);
    }
    int j = (int) (n * Math.random ());
    n = 0;
    for (int i = 0; i < f.list ().length; i ++) {
        s = f.list () [i];
        sz = s;
        s = s.substring (s.indexOf ("-") + 1, s.indexOf ("."));
        n = n + Integer.parseInt (s);
        if (j < n) {
            break;
        }
    }
    s = "";
    int i = Integer.parseInt (sz.substring (sz.indexOf ("-") + 1, sz.indexOf (".")));
    int k = (int) (i * Math.random ()) + 1;
    ZipFile zipFile = new ZipFile (new File (zips + "/" + sz));
    ZipEntry entry = zipFile.getEntry (k + ".txt");
    BufferedReader br = new BufferedReader (new InputStreamReader (zipFile.getInputStream (entry), "UTF-8"));
    while ((ss = br.readLine ()) != null) {
        s = s + ss;
    }
    br.close ();
    zipFile.close ();
    return s;
}


public void zip (String zipName, String dirName) {
    ZipOutputStream out = null;
    FileOutputStream dest = null;
    CheckedOutputStream checksum = null;
    try {
        dest = new FileOutputStream (new File (zipName));
        checksum = new CheckedOutputStream (dest, new Adler32 ());
        out = new ZipOutputStream (new BufferedOutputStream (checksum));
        File dir = new File (dirName);
        String parent = dir.getParent ();
        int length = parent.length ();
        String substring = parent.substring (0, length);
        addToZip (out, dir, substring);
        System.out.println (">>>> checksum: " + checksum.getChecksum ().getValue ());
    } catch (Exception e) {
        e.printStackTrace ();
    } catch (Error err) {
        err.printStackTrace ();
    } finally {
        try {
            out.flush ();
            out.finish ();
            out.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        } catch (Error err) {
            err.printStackTrace ();
        }
    }
}


-----Function Pair=244=-----==

public synchronized String getCommandLineArg (String userID, String selected_concrete, String selected_job) {
    String actual_param = "";
    try {
        Vector wfconfig = getConfigData (userID, selected_concrete);
        for (int i = 0; i < wfconfig.size (); ++ i) {
            JobPropertyBean jobprop = (JobPropertyBean) wfconfig.get (i);
            if (jobprop.getName ().equals (new String (selected_job))) {
                actual_param = (String) jobprop.getExe ().get ("params");
            }
        }
    } catch (ClassNotFoundException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return actual_param;
}


public static boolean writeZipFile (byte [] content, String entry, File file) {
    if (content == null || content.length == 0) {
        Exception e = new Exception ();
        e.fillInStackTrace ();
        logger.log (Level.SEVERE, "Tried to zip an empty file!  Send this output to a dev" + " and describe what you were doing.", e);
        return false;
    }
    try {
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (file));
        zos.setLevel (9);
        ZipEntry ze = new ZipEntry (entry);
        ze.setSize (content.length);
        zos.putNextEntry (ze);
        zos.write (content);
        zos.flush ();
        zos.closeEntry ();
        zos.close ();
        return true;
    } catch (Throwable e) {
        logger.log (Level.SEVERE, "Exception thrown in writeZipFile(byte[] content, String entry, File file)", e);
        return false;
    }
}


-----Function Pair=245=-----==

public static File createZip (final String fileName, final File dirToZip, final File destDir) throws IOException {
    if (! destDir.exists () || ! destDir.isDirectory ()) {
        throw new IOException ("The destination dir doesn't exist or isn't a directory");
    }
    if (! dirToZip.exists () || ! dirToZip.isDirectory ()) {
        throw new IOException ("The directory to zip doesn't exist or isn't a directory");
    }
    final File outFile = new File (destDir.getAbsolutePath () + File.separator + fileName);
    outFile.getParentFile ().mkdirs ();
    final ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (outFile));
    try {
        zipDir (dirToZip, zos, "");
    } finally {
        zos.close ();
    }
    return outFile;
}


public static void writeZipBytesToFile (byte [] bytes, String aFileName) {
    try {
        logger.debug ("unzipping file: " + aFileName);
        if (bytes == null) {
            logger.debug ("null bytes");
        }
        File f = new File (aFileName);
        FileOutputStream ostr = new FileOutputStream (f);
        BufferedOutputStream bstr = new BufferedOutputStream (ostr);
        bstr.write (bytes, 0, bytes.length);
        bstr.close ();
    } catch (Exception e) {
        logger.error ("Unable to write zipped file from byte stream:" + e);
    }
}


-----Function Pair=246=-----==

private boolean convertDOCXActionParams (String [] args) {
    File dirOut = null;
    String lang = "en";
    for (int i = 1; i < args.length; i ++) {
        if (i == 1) {
            root = new File (args [i]);
            continue;
        }
        if (args [i].equalsIgnoreCase ("-d")) {
            dirOut = new File (args [++ i]);
            if (dirOut.exists () && ! dirOut.isDirectory ()) {
                throw new RuntimeException (args [i] + " is not a directory.");
            }
            if (! dirOut.exists ()) dirOut.mkdirs ();
            continue;
        }
        if (args [i].equalsIgnoreCase ("-noo")) noo = true;
        if (args [i].equalsIgnoreCase ("-l")) lang = args [++ i];
        if (args [i].equalsIgnoreCase ("-noe")) EPUBMetaData.doNotEmbedOTFFonts = true;
        if (args [i].equalsIgnoreCase ("-nopb")) BaseRenderer.noPageBreakEmit = true;
    }
    DOCX2EPUB conv = new DOCX2EPUB (root, dirOut == null ? root : dirOut);
    conv.recurse (root);
    return true;
}


public static String CreateZip (String [] filesToZip, String zipFileName) {
    byte [] buffer = new byte [18024];
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));
        out.setLevel (Deflater.BEST_COMPRESSION);
        for (int i = 0; i < filesToZip.length; i ++) {
            FileInputStream in = new FileInputStream (filesToZip [i]);
            String fileName = null;
            for (int X = filesToZip [i].length () - 1; X >= 0; X --) {
                if (filesToZip [i].charAt (X) == '\\' || filesToZip [i].charAt (X) == '/') {
                    fileName = filesToZip [i].substring (X + 1);
                    break;
                }
                else if (X == 0) fileName = filesToZip [i];
            }
            out.putNextEntry (new ZipEntry (fileName));
            int len;
            while ((len = in.read (buffer)) > 0) out.write (buffer, 0, len);
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IllegalArgumentException e) {
        return "Failed to create zip: " + e.toString ();
    } catch (FileNotFoundException e) {
        return "Failed to create zip: " + e.toString ();
    } catch (IOException e) {
        return "Failed to create zip: " + e.toString ();
    }
    return "Success";
}


-----Function Pair=247=-----==

Set < String > addResourcesFromOrganizations (Content content, Document document, Organizations organizations, Element resourcesElement) {
    HashSet < String > includedChapters = new HashSet < String > ();
    Iterator < ToolMenu > organizationsIter = organizations.iterator ();
    while (organizationsIter.hasNext ()) {
        ToolMenu organization = organizationsIter.next ();
        List < ToolMenuItem > toolMenuItems = organization.getChildren ();
        try {
            includedChapters.addAll (addItemsToResources (toolMenuItems, content, document, resourcesElement));
        } catch (DirectoryItemNotFoundException e) {
            log.error ("Tool menu Item " + e.getFilePath () + " not found");
        }
    }
    if (document != null) {
        Node manifestDomNode = document.getFirstChild ();
        manifestDomNode.appendChild (resourcesElement);
    }
    return includedChapters;
}


public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


-----Function Pair=248=-----==

private static void unzip (File srcFile, File dstDir) throws IOException {
    byte [] buffer = new byte [ZIP_BUFFER_SIZE];
    int bytes;
    ZipFile zipFile = new ZipFile (srcFile);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.isDirectory ()) {
            File newDirectory = new File (entry.getName ());
            if (! newDirectory.exists ()) newDirectory.mkdirs ();
            continue;
        }
        File newFile = new File (dstDir, entry.getName ());
        File newFileDir = newFile.getParentFile ();
        if (! newFileDir.exists ()) newFileDir.mkdirs ();
        InputStream in = zipFile.getInputStream (entry);
        OutputStream out = new BufferedOutputStream (new FileOutputStream (newFile));
        while ((bytes = in.read (buffer)) >= 0) out.write (buffer, 0, bytes);
        in.close ();
        out.close ();
    }
    zipFile.close ();
}


private void createNewGameDataFiles (String [] dataFiles, Map map) throws IOException {
    String tmpGameFile = GAME_DATA_FILENAME, tmpTurnFile = TURN_DATA_FILENAME;
    Player [] playerObjects = new Player [dataFiles.length];
    Hashtable fleets = new Hashtable ();
    Fleet fleet = null;
    PlayerAndFleetWrapper playerFleet;
    try {
        EleconicsXmlParser xmlParser = null;
        for (int file = 0; file < dataFiles.length; file ++) {
            xmlParser = new EleconicsXmlParser (new InputStreamReader (new FileInputStream (dataFiles [file])));
            playerFleet = new PlayerAndFleetWrapper (xmlParser);
            playerObjects [file] = playerFleet.getPlayer ();
            playerObjects [file].setFleetNumber (file + 1);
            fleet = playerFleet.getFleet ();
            fleet.setFleetNumber (file + 1);
            fleet.shiftLocation (map.getLocation (file + 1));
            fleet.rotate (map.getAxisAngle (file + 1), map.getLocation (file + 1));
            fleets.put (playerFleet.getFleet ().fleetName (), playerFleet.getFleet ());
            xmlParser.close ();
        }
    } catch (MultiplayerException e) {
        Utilities.popUp (e.getMessage ());
        e.printStackTrace ();
    }
    Players players = new Players (playerObjects);
    world = new World (fleets);
    XmlProcessor xmlProcessor = new XmlProcessor ();
    xmlProcessor.startElement (MultiplayerXmlProcessor.GAME_TAG);
    players.ToXml (xmlProcessor);
    world.ToXml (xmlProcessor);
    xmlProcessor.endElement ();
    BufferedWriter out = new BufferedWriter (new FileWriter (tmpGameFile, false));
    out.write (xmlProcessor.stream.toString ());
    out.close ();
    xmlProcessor.resetWriter ();
    xmlProcessor.startElement (MultiplayerXmlProcessor.TURN_TAG);
    xmlProcessor.XmlNode (MultiplayerXmlProcessor.VIEWING_PLAYER_NUMBER_TAG, "1");
    xmlProcessor.XmlNode (MultiplayerXmlProcessor.FIRST_EXECUTING_ACTIONS_PLAYER_NUMBER_TAG, "1");
    xmlProcessor.XmlNode (MultiplayerXmlProcessor.TURN_ACTIONS_TAG, "");
    xmlProcessor.XmlNode (MultiplayerXmlProcessor.START_TURN_TAG, "true");
    xmlProcessor.endElement ();
    out = new BufferedWriter (new FileWriter (tmpTurnFile, false));
    out.write (xmlProcessor.stream.toString ());
    out.close ();
    byte b [] = new byte [512];
    ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (zipDataFileName));
    InputStream in = new FileInputStream (tmpGameFile);
    ZipEntry e = new ZipEntry (tmpGameFile.replace (File.separatorChar, '/'));
    zout.putNextEntry (e);
    int len = 0;
    while ((len = in.read (b)) != - 1) {
        zout.write (b, 0, len);
    }
    zout.closeEntry ();
    in = new FileInputStream (tmpTurnFile);
    e = new ZipEntry (tmpTurnFile.replace (File.separatorChar, '/'));
    zout.putNextEntry (e);
    len = 0;
    while ((len = in.read (b)) != - 1) {
        zout.write (b, 0, len);
    }
    zout.closeEntry ();
    zout.close ();
}


-----Function Pair=249=-----==

protected void writeTarFile (Blog blog, List files, OutputStream out) throws IOException {
    GZIPOutputStream gzos = new GZIPOutputStream (out);
    TarOutputStream tos = new TarOutputStream (gzos);
    tos.setLongFileMode (TarOutputStream.LONGFILE_GNU);
    FileRetrieverService frs = FileRetrieverService.getInstance ();
    for (Iterator i = files.iterator (); i.hasNext ();) {
        String path = (String) i.next ();
        AbstractFileResource file = frs.getFile (blog, path);
        TarEntry te;
        if (path.startsWith ("/")) path = path.substring (1);
        if (file.isDirectory ()) {
            if (! path.endsWith ("/")) path = path + "/";
            te = new TarEntry (path);
        }
        else {
            if (file.isOriginal () || file.getSize () == 0) continue;
            te = new TarEntry (path);
            te.setSize (file.getSize ());
            te.setModTime (file.getLastModified ());
            tos.putNextEntry (te);
            InputStream fis = file.getFileAsInputStream ();
            tos.copyEntryContents (fis);
            fis.close ();
        }
        tos.closeEntry ();
    }
    tos.close ();
}


public static void zipDir (File zipDir, ZipOutputStream zos, String path) {
    try {
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                zipDir (f, zos, path + f.getName () + "/");
            }
            else {
                FileInputStream fis = new FileInputStream (f);
                ZipEntry anEntry = new ZipEntry (path + f.getName ());
                zos.putNextEntry (anEntry);
                while ((bytesIn = fis.read (readBuffer)) != - 1) {
                    zos.write (readBuffer, 0, bytesIn);
                }
                fis.close ();
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=250=-----==

public BuildProcess saveImageThumb (String src_file, String dst_file, float scale) {
    try {
        File jpg = new File (dir, src_file);
        if (jpg.exists ()) {
            BufferedImage src = Tools.readImage (jpg.getPath ());
            BufferedImage tag = new BufferedImage ((int) (src.getWidth () * scale), (int) (src.getHeight () * scale), BufferedImage.TYPE_INT_RGB);
            tag.getGraphics ().drawImage (src, 0, 0, tag.getWidth (), tag.getHeight (), null);
            File thumb_file = new File (dir, dst_file);
            Tools.writeImage (thumb_file.getPath (), "jpg", tag);
        }
    } catch (Exception err) {
        err.printStackTrace ();
    }
    return this;
}


public static Job GetJob (NpsContext ctxt, String id) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Job job = null;
    try {
        String sql = "select a.*,b.name creator_name,c.name site_name,d.name runas_name from job a,users b,site c,users d" + " where a.creator=b.id and a.site=c.id and a.runas=d.id" + " and a.id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (! rs.next ()) return null;
        return GetJob (rs);
    } catch (Exception e) {
        job = null;
        nps.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    return job;
}


-----Function Pair=251=-----==

public static boolean copyFileCover (String srcFileName, String descFileName, boolean coverlay) {
    File srcFile = new File (srcFileName);
    if (! srcFile.exists ()) {
        System.out.println ("复制文件失败，源文件" + srcFileName + "不存在!");
        return false;
    }
    else if (! srcFile.isFile ()) {
        System.out.println ("复制文件失败，" + srcFileName + "不是一个文件!");
        return false;
    }
    File descFile = new File (descFileName);
    if (descFile.exists ()) {
        if (coverlay) {
            System.out.println ("目标文件已存在，准备删除!");
            if (! FileOperateUtils.delFile (descFileName)) {
                System.out.println ("删除目标文件" + descFileName + "失败!");
                return false;
            }
        }
        else {
            System.out.println ("复制文件失败，目标文件" + descFileName + "已存在!");
            return false;
        }
    }
    else {
        if (! descFile.getParentFile ().exists ()) {
            System.out.println ("目标文件所在的目录不存在，创建目录!");
            if (! descFile.getParentFile ().mkdirs ()) {
                System.out.println ("创建目标文件所在的目录失败!");
                return false;
            }
        }
    }
    int readByte = 0;
    InputStream ins = null;
    OutputStream outs = null;
    try {
        ins = new FileInputStream (srcFile);
        outs = new FileOutputStream (descFile);
        byte [] buf = new byte [1024];
        while ((readByte = ins.read (buf)) != - 1) {
            outs.write (buf, 0, readByte);
        }
        System.out.println ("复制单个文件" + srcFileName + "到" + descFileName + "成功!");
        return true;
    } catch (Exception e) {
        System.out.println ("复制文件失败：" + e.getMessage ());
        return false;
    } finally {
        if (outs != null) {
            try {
                outs.close ();
            } catch (IOException oute) {
                oute.printStackTrace ();
            }
        }
        if (ins != null) {
            try {
                ins.close ();
            } catch (IOException ine) {
                ine.printStackTrace ();
            }
        }
    }
}


private File selectFile (File workingDir, String dialogTitle, String approveTip, boolean useAllFilter, String filefilter, String filterTip, int dialogType) {
    File result = null;
    m_FChooser = null;
    m_FChooser = new JFileChooser (workingDir);
    m_FChooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
    javax.swing.filechooser.FileFilter ft = m_FChooser.getAcceptAllFileFilter ();
    m_FChooser.removeChoosableFileFilter (ft);
    if (dialogType != - 1) m_FChooser.setDialogType (dialogType);
    if (dialogTitle != null) m_FChooser.setDialogTitle (dialogTitle);
    if (approveTip != null) m_FChooser.setApproveButtonToolTipText (approveTip);
    if (filefilter != null) {
        CustomizedFileFilter filter = new CustomizedFileFilter (filefilter, filterTip);
        m_FChooser.addChoosableFileFilter (filter);
    }
    if (dialogType == JFileChooser.OPEN_DIALOG) {
        if (m_FChooser.showOpenDialog (this) == JFileChooser.APPROVE_OPTION) result = m_FChooser.getSelectedFile ();
    }
    else if (dialogType == JFileChooser.SAVE_DIALOG) {
        if (m_FChooser.showSaveDialog (this) == JFileChooser.APPROVE_OPTION) result = m_FChooser.getSelectedFile ();
    }
    else if (dialogType == - 1) {
        if (m_FChooser.showDialog (this, "Print") == JFileChooser.APPROVE_OPTION) result = m_FChooser.getSelectedFile ();
    }
    update (getGraphics ());
    Window [] windows = this.getOwnedWindows ();
    for (int i = 0; i < windows.length; i ++) {
        if (windows [i].toString ().matches ("title=New Problem Type Selection")) {
            windows [i].dispose ();
        }
    }
    return result;
}


-----Function Pair=252=-----==

private void calculateTranslations (double [] [] xy, int p, double min, double [] left, double [] right) {
    double vx0 = xy [p - 1] [0] - xy [p] [0];
    double vy0 = xy [p - 1] [1] - xy [p] [1];
    double l0 = Math.sqrt ((vx0 * vx0) + (vy0 * vy0));
    vx0 /= l0;
    vy0 /= l0;
    double vx1 = xy [p + 1] [0] - xy [p] [0];
    double vy1 = xy [p + 1] [1] - xy [p] [1];
    double l1 = Math.sqrt ((vx1 * vx1) + (vy1 * vy1));
    vx1 /= l1;
    vy1 /= l1;
    double vx = (vx1 - vx0) / 2;
    double vy = (vy1 - vy0) / 2;
    double l = Math.sqrt ((vx * vx) + (vy * vy));
    if (l == 0) {
        vx = vx1;
        vy = vy1;
    }
    else {
        vx /= l;
        vy /= l;
    }
    double nx = - vy;
    double ny = vx;
    double npx0 = xy [p] [0];
    double npy0 = xy [p] [1];
    double npx1 = npx0 + nx;
    double npy1 = npy0 + ny;
    double lx = - vy1;
    double ly = vx1;
    this.intersect (npx0, npy0, npx1, npy1, xy [p] [0], xy [p] [1], xy [p + 1] [0], xy [p + 1] [1], lx, ly, min, left);
    this.intersect (npx0, npy0, npx1, npy1, xy [p] [0], xy [p] [1], xy [p + 1] [0], xy [p + 1] [1], lx, ly, - min, right);
}


private void recurse (Node nodo) throws Exception {
    boolean printTag = true;
    NamedNodeMap attr = nodo.getAttributes ();
    if (nodo.getNodeType () == Node.TEXT_NODE) {
        String tc = nodo.getTextContent ();
        tc = Utils.toXMLText (tc);
        pw.print (tc);
        return;
    }
    if (procStyles && attr != null && attr.getNamedItem ("style") != null) {
        procStyleAttr (nodo);
    }
    String n = nodo.getNodeName ();
    if (n.equals ("HEAD")) {
        head = nodo;
    }
    else if (n.equals ("IMG")) {
        try {
            String href = attr.getNamedItem ("src").getNodeValue ();
            if (href.toLowerCase ().startsWith ("file:")) href = href.substring ("file:".length ());
            File fimg = new File (htmlDoc.getHTMLFile ().getParentFile (), href);
            FileInputStream fis = new FileInputStream (fimg);
            next (fimg.getPath ().substring (1 + htmlDoc.getHTMLFile ().getParentFile ().getAbsolutePath ().length ()), fis);
        } catch (Exception e) {
        }
    }
    else if (n.equals ("HTML")) {
        html = nodo;
    }
    else if (n.equals ("A")) {
        Node nodName = attr.getNamedItem ("name");
        if (nodName != null) {
            String name = nodName.getNodeValue ();
            if (name != null) {
                String newDest = pname + "-" + pageNumber + ".xhtml#" + name;
                anchorDest.put (name, newDest);
            }
        }
    }
    if (printTag) printOpeningTag (nodo);
    NodeList list = nodo.getChildNodes ();
    if (list != null) {
        for (int i = 0; i < list.getLength (); i ++) {
            recurse (list.item (i));
        }
    }
    if (printTag) {
        printClosingTag (nodo);
        pw.flush ();
        if (n.equals ("DIV") || n.equals ("P")) {
            if (paginateKB >= 50 && bos.size () > paginateKB * 1024) {
                pw.println ("</body></html>");
                next (pname + "-" + (pageNumber) + ".html", bos);
                pageNumber ++;
                bos = new ByteArrayOutputStream ();
                pw = new PrintWriter (bos);
                printOpeningTag (html);
                recurse (head);
                pw.println ("<body>");
            }
        }
    }
}


-----Function Pair=253=-----==

public static boolean copyFileStream (final File _fileFrom, final File _fileTo, final boolean _append) {
    boolean r = true;
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (_fileFrom);
        out = new FileOutputStream (_fileTo, _append);
        return copyStream (in, out, false, false);
    } catch (final IOException _e1) {
        r = false;
    } finally {
        IOException io = null;
        if (in != null) {
            io = close (in);
            if (io != null) {
                r = false;
            }
        }
        if (out != null) {
            io = close (out);
            if (io != null) {
                r = false;
            }
        }
    }
    return r;
}


public void execute () throws MojoExecutionException {
    displayPluginInfo ();
    JarOutputStream out = null;
    JarInputStream template = null;
    try {
        File onejarFile = new File (outputDirectory, filename);
        out = new JarOutputStream (new FileOutputStream (onejarFile, false), getManifest ());
        if (getLog ().isDebugEnabled ()) {
            getLog ().debug ("Adding main jar main/[" + mainJarFilename + "]");
        }
        addToZip (new File (outputDirectory, mainJarFilename), "main/", out);
        List < File > jars = getFilesForStrings (artifacts, false, true);
        if (getLog ().isDebugEnabled ()) {
            getLog ().debug ("Adding [" + jars.size () + "] libaries...");
        }
        for (File jar : jars) {
            if (jar.isFile () && jar.getName ().endsWith (".jar")) {
                addToZip (jar, "lib/", out);
            }
            else {
                addToZip (jar, "binlib/", out);
            }
        }
        getLog ().debug ("Adding one-jar components...");
        template = openOnejarTemplateArchive ();
        ZipEntry entry;
        while ((entry = template.getNextEntry ()) != null) {
            if (! "boot-manifest.mf".equals (entry.getName ())) {
                addToZip (out, entry, template);
            }
        }
        if (this.policyFile != null) {
            addToZip (out, new ZipEntry (this.policyFile.getName ()), new FileInputStream (this.policyFile));
        }
        final String format = this.project.getArtifact ().getType ();
        getLog ().debug ("format:" + format);
        getLog ().debug ("file:" + onejarFile.getAbsolutePath ());
        projectHelper.attachArtifact (this.project, format, "one-jar", onejarFile);
    } catch (IOException e) {
        getLog ().error (e);
    } finally {
        IOUtils.closeQuietly (out);
        IOUtils.closeQuietly (template);
    }
}


-----Function Pair=254=-----==

public static void addToZip (File f, ZipOutputStream zip) throws IOException {
    if (f.isDirectory ()) {
        for (File s : f.listFiles ()) {
            addToZip (s, zip);
        }
    }
    else {
        String baseName = FileDestDir.getCanonicalPath ();
        String fullPath = f.getCanonicalPath ();
        String nameSufix = fullPath.substring (baseName.length () + 1);
        FileInputStream in = new FileInputStream (f);
        byte [] data = new byte [in.available ()];
        in.read (data);
        ZipEntry entry = new ZipEntry (nameSufix.replace ('\\', '/'));
        entry.setSize (data.length);
        entry.setTime (f.lastModified ());
        zip.putNextEntry (entry);
        zip.write (data);
        zip.closeEntry ();
    }
}


public static boolean makeZip (final Shell shell, String folder) {
    String zipName;
    FileDialog dialog = new FileDialog (shell, SWT.SAVE);
    dialog.setFilterNames (new String [] {"Zip Files"});
    dialog.setFilterExtensions (new String [] {"*.zip", "*.*"});
    try {
        File f = new File (folder);
        File [] filenames = f.listFiles ();
        if (filenames.length == 0) return false;
        dialog.setFilterPath (Options.getOptionValue (Options.LOGS_FOLDER));
        dialog.setFileName (f.getName () + ".zip");
        zipName = dialog.open ();
        if (zipName == null || zipName.equals ("")) {
            return false;
        }
        try {
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipName));
            zipRecursively (out, f, "");
            out.closeEntry ();
            out.close ();
            return true;
        } catch (IOException e) {
            e.printStackTrace ();
        }
    } catch (OptionNotFoundException e1) {
        e1.printStackTrace ();
    }
    return false;
}


-----Function Pair=255=-----==

protected ActionForward doAdmin (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    ExportOntologyForm eof = (ExportOntologyForm) form;
    String filename;
    try {
        URL oUrl = new URL (eof.getOntologyURI ());
        filename = oUrl.getFile ();
    } catch (MalformedURLException mue) {
        filename = eof.getOntologyURI ();
    }
    if (eof.getZip () == null || eof.getZip ().equals ("none")) {
        response.setContentType ("application/xml");
        if (eof.getSaveToDisk ()) {
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".owl");
        }
        response.getWriter ().write ("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
        ModelCache.getSingleton ().exportOntology (eof.getOntologyURI (), response.getWriter ());
    }
    else if (eof.getZip ().equals ("zip") || eof.getZip ().equals ("gzip")) {
        OutputStream compressedOut;
        if (eof.getZip ().equals ("zip")) {
            response.setContentType ("application/zip");
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".zip");
            ZipOutputStream zipout = new ZipOutputStream (response.getOutputStream ());
            zipout.putNextEntry (new ZipEntry (filename));
            compressedOut = zipout;
        }
        else {
            response.setContentType ("application/gzip");
            response.setHeader ("Content-Disposition", "attachment; filename=" + eof.getOntologyURI () + ".gz");
            compressedOut = new GZIPOutputStream (response.getOutputStream ());
        }
        OutputStreamWriter osw = new OutputStreamWriter (compressedOut);
        osw.write ("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
        ModelCache.getSingleton ().exportOntology (eof.getOntologyURI (), osw);
        osw.close ();
    }
    return null;
}


private static void zipFiles (final ZipOutputStream zipout, final File file, final File sourceDirectory) throws IOException {
    if (file.isDirectory ()) {
        for (File subFile : file.listFiles ()) {
            zipFiles (zipout, subFile, sourceDirectory);
        }
    }
    else {
        final String entryName = getZipEntryName (file, sourceDirectory);
        LOG.debug ("Zipping file '" + file.getAbsolutePath () + "' as entry '" + entryName + "'.");
        final ZipEntry entry = new ZipEntry (entryName);
        BufferedInputStream fileInput = null;
        try {
            fileInput = new BufferedInputStream (new FileInputStream (file), BUFFER_SIZE);
            byte [] buffer = new byte [BUFFER_SIZE];
            zipout.putNextEntry (entry);
            int count = fileInput.read (buffer, 0, BUFFER_SIZE);
            while (count != - 1) {
                zipout.write (buffer, 0, count);
                count = fileInput.read (buffer, 0, BUFFER_SIZE);
            }
            zipout.closeEntry ();
        } finally {
            PtCloseUtil.close (fileInput);
        }
    }
}


-----Function Pair=256=-----==

private String PaintDHXTree (String dhxtree, String parentid, Iterator childs, boolean show_all) {
    String jstree = "";
    while (childs.hasNext ()) {
        Node node = (Node) childs.next ();
        String id = node.GetId ();
        if (! "-1".equalsIgnoreCase (id)) {
            Topic topic = (Topic) node.GetValue ();
            if (! show_all && ! topic.IsVisible ()) continue;
            String top_nodeid = "topic" + id;
            jstree += dhxtree + ".insertNewItem(\"" + parentid + "\"," + "\"" + top_nodeid + "\"," + "\"" + Utils.TransferToHtmlEntity (topic.GetName ()) + "\");";
            jstree += dhxtree + ".setUserData(\"" + top_nodeid + "\"," + "\"siteid\"," + "\"" + site.GetId () + "\");";
            jstree += dhxtree + ".setUserData(\"" + top_nodeid + "\"," + "\"sitename\"," + "\"" + Utils.TransferToHtmlEntity (treename) + "\");";
            jstree += dhxtree + ".setUserData(\"" + top_nodeid + "\"," + "\"topid\"," + "\"" + id + "\");";
            jstree += dhxtree + ".setUserData(\"" + top_nodeid + "\"," + "\"topname\"," + "\"" + Utils.TransferToHtmlEntity (topic.GetName ()) + "\");";
            if (topic.GetTable () != null && topic.GetTable ().length () > 0) jstree += dhxtree + ".setUserData(\"" + top_nodeid + "\"," + "\"tname\"," + "\"" + topic.GetTable () + "\");";
            if (node.HasChilds ()) jstree += PaintDHXTree (dhxtree, top_nodeid, node.GetChilds (), show_all);
        }
        else {
            if (node.HasChilds ()) jstree += PaintDHXTree (dhxtree, parentid, node.GetChilds (), show_all);
        }
    }
    return jstree;
}


public ByteArray zip (Value request) throws FaultException {
    ByteArrayOutputStream bbstream = new ByteArrayOutputStream ();
    try {
        ZipOutputStream zipStream = new ZipOutputStream (bbstream);
        ZipEntry zipEntry;
        byte [] bb;
        for (Entry < String, ValueVector > entry : request.children ().entrySet ()) {
            zipEntry = new ZipEntry (entry.getKey ());
            zipStream.putNextEntry (zipEntry);
            bb = entry.getValue ().first ().byteArrayValue ().getBytes ();
            zipStream.write (bb, 0, bb.length);
            zipStream.closeEntry ();
        }
        zipStream.close ();
    } catch (IOException e) {
        throw new FaultException (e);
    }
    return new ByteArray (bbstream.toByteArray ());
}


-----Function Pair=257=-----==

public boolean writeAboutHtmlFile (File resource, JarOutputStream out) throws Exception {
    try {
        ZipEntry newEntry;
        InputStream inputStream;
        if (eclipseInstallPlugin.isJar ()) {
            JarFile pluginJar = new JarFile (this.eclipseInstallPlugin.getPluginLocation ());
            newEntry = pluginJar.getJarEntry (ABOUT_FILE);
            out.putNextEntry (newEntry);
            inputStream = pluginJar.getInputStream (newEntry);
        }
        else {
            newEntry = new ZipEntry (resource.getName ());
            out.putNextEntry (newEntry);
            inputStream = new FileInputStream (resource);
        }
        writeToOutputStream (out, inputStream);
        out.closeEntry ();
        return true;
    } catch (IOException e) {
        System.out.println (e.getMessage ());
        return false;
    }
}


private void compileProject () {
    String sep = getPathsFileSeparator ();
    String runPath = data.projectDirectory + sep + projectCompileFile;
    System.out.println ("Compiling gwt application - This may take a minute to complete! Be patient.");
    try {
        Runtime rt = Runtime.getRuntime ();
        Process proc = rt.exec (runPath);
        proc.waitFor ();
    } catch (Throwable t) {
        System.out.println ("If you get a permission error on linux, 'chmod 777 project-compile'");
        System.out.println ("Was not able to exec the project-compile file to compile project");
        t.printStackTrace ();
        System.exit (1);
    }
    System.out.println ("Done compiling gwt application");
}


-----Function Pair=258=-----==

public static Set < String > pack (final PluginRegistry registry, final PathResolver pathResolver, final File destFile, final Filter filter) throws IOException {
    Set < String > result;
    ZipOutputStream zipStrm = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (destFile, false)));
    try {
        zipStrm.setComment ("JPF plug-ins archive");
        ZipEntry entry = new ZipEntry (DESCRIPTOR_ENTRY_NAME);
        entry.setComment ("JPF plug-ins archive descriptor");
        zipStrm.putNextEntry (entry);
        result = writeDescripor (registry, filter, new ObjectOutputStream (zipStrm));
        zipStrm.closeEntry ();
        for (PluginDescriptor descr : registry.getPluginDescriptors ()) {
            if (! result.contains (descr.getUniqueId ())) {
                continue;
            }
            URL url = pathResolver.resolvePath (descr, "/");
            File file = IoUtil.url2file (url);
            if (file == null) {
                throw new IOException ("resolved URL " + url + " is not local file system location pointer");
            }
            entry = new ZipEntry (descr.getUniqueId () + "/");
            entry.setComment ("Content for JPF plug-in " + descr.getId () + " version " + descr.getVersion ());
            entry.setTime (file.lastModified ());
            zipStrm.putNextEntry (entry);
            File [] files = file.listFiles ();
            for (int i = 0; i < files.length; i ++) {
                packEntry (zipStrm, entry, files [i]);
            }
        }
        for (PluginFragment fragment : registry.getPluginFragments ()) {
            if (! result.contains (fragment.getUniqueId ())) {
                continue;
            }
            URL url = pathResolver.resolvePath (fragment, "/");
            File file = IoUtil.url2file (url);
            if (file == null) {
                throw new IOException ("resolved URL " + url + " is not local file system location pointer");
            }
            entry = new ZipEntry (fragment.getUniqueId () + "/");
            entry.setComment ("Content for JPF plug-in fragment " + fragment.getId () + " version " + fragment.getVersion ());
            entry.setTime (file.lastModified ());
            zipStrm.putNextEntry (entry);
            File [] files = file.listFiles ();
            for (int i = 0; i < files.length; i ++) {
                packEntry (zipStrm, entry, files [i]);
            }
        }
    } finally {
        zipStrm.close ();
    }
    return result;
}


private final void toTar (TarOutputStream out, File file, String path) throws IOException {
    if (file.isFile ()) {
        TarEntry entry = new TarEntry (path + file.getName ());
        if (file.length () > 0) {
            entry.setSize (file.length ());
        }
        out.putNextEntry (entry);
        BufferedInputStream origin = null;
        byte data [] = new byte [BUFFER];
        FileInputStream fi = new FileInputStream (file);
        origin = new BufferedInputStream (fi, BUFFER);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    else {
        File [] files = file.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            toTar (out, files [i], path + file.getName () + "/");
        }
    }
}


-----Function Pair=259=-----==

public Object getContent (ModelVersionManager versionManager, String fileVersion) throws IOException {
    try {
        if (versionManager != null) {
            Reader r = getFileAsReader (CONTENT_FILE);
            String xml = IOUtils.toString (r);
            xml = versionManager.transform (xml, fileVersion);
            return xstream.fromXML (xml);
        }
        else {
            return getFileObject (CONTENT_FILE);
        }
    } catch (NullPointerException npe) {
        log.error ("Problem finding/converting content file", npe);
        return null;
    }
}


public void addFile (File file) throws Exception {
    FileInputStream tFINS = new FileInputStream (file);
    final int bufLength = 1024;
    byte [] buffer = new byte [bufLength];
    int readReturn = 0;
    zOut.putNextEntry (new ZipEntry (file.getName ()));
    do {
        readReturn = tFINS.read (buffer);
        if (readReturn != - 1) {
            zOut.write (buffer, 0, readReturn);
        }
    }
    while (readReturn != - 1);
    zOut.closeEntry ();
    fileCount ++;
}


-----Function Pair=260=-----==

private boolean writeResource (PluginProxy eclipseInstallPlugin, ResourceProxy translation, LocaleProxy locale) throws Exception {
    String translationResourceName = determineTranslatedResourceName (translation, locale);
    String pluginNameInDirFormat = eclipseInstallPlugin.getName ().replace (Messages.getString ("Characters_period"), File.separator);
    if (translation.getRelativePath ().contains (pluginNameInDirFormat)) {
        return writeResourceToBundleClasspath (translation, locale);
    }
    else if (translationResourceName.contains (File.separator)) {
        String resourcePath = translationResourceName.substring (0, translationResourceName.lastIndexOf (File.separatorChar));
        File resourcePathDirectory = new File (directory.getPath () + File.separatorChar + resourcePath);
        resourcePathDirectory.mkdirs ();
    }
    File fragmentResource = new File (directory.getPath () + File.separatorChar + translationResourceName);
    File translatedResource = new File (translation.getFileResource ().getAbsolutePath ());
    FileChannel inputChannel = new FileInputStream (translatedResource).getChannel ();
    FileChannel outputChannel = new FileOutputStream (fragmentResource).getChannel ();
    inputChannel.transferTo (0, inputChannel.size (), outputChannel);
    inputChannel.close ();
    outputChannel.close ();
    return true;
}


public static final Collection < File > unZip (final ZipInputStream in, final File outDir) {
    final Collection < File > result = new ArrayList < File > (4);
    try {
        ZipEntry entry;
        BufferedOutputStream out = null;
        final byte data [] = new byte [10240];
        while (true) {
            out = null;
            try {
                entry = in.getNextEntry ();
                if (null == entry) break;
                int count;
                final File outFile = new File (outDir, entry.getName ());
                outFile.getParentFile ().mkdirs ();
                out = new BufferedOutputStream (new FileOutputStream (outFile));
                while ((count = in.read (data)) != - 1) out.write (data, 0, count);
                out.flush ();
                result.add (outFile);
            } catch (final Exception ioex) {
                ioex.printStackTrace ();
            } finally {
                closeIO (out);
            }
        }
    } catch (final Exception e) {
        e.printStackTrace ();
    } finally {
        closeIO (in);
    }
    return result;
}


-----Function Pair=261=-----==

public static byte [] zipFiles (Map < String, byte [] > files) throws IOException {
    ByteArrayOutputStream dest = new ByteArrayOutputStream ();
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    Iterator < Entry < String, byte [] > > itr = files.entrySet ().iterator ();
    while (itr.hasNext ()) {
        Entry < String, byte [] > entry = itr.next ();
        ZipEntry zipEntry = new ZipEntry (entry.getKey ());
        out.putNextEntry (zipEntry);
        IOUtils.write (entry.getValue (), out);
    }
    out.close ();
    byte [] outBytes = dest.toByteArray ();
    dest.close ();
    return outBytes;
}


public static void zipFilesStream (File src, File out, FileFilters pattern, boolean verbos) throws Exception {
    src = src.getCanonicalFile ();
    out = out.getCanonicalFile ();
    if (! src.isHidden ()) {
        String root = "";
        if (src.isDirectory ()) {
            root = src.getCanonicalPath ();
        }
        else if (src.isFile ()) {
            root = src.getParentFile ().getCanonicalPath ();
        }
        out.createNewFile ();
        FileOutputStream baos = new FileOutputStream (out);
        ZipOutputStream zos = new ZipOutputStream (baos);
        zipFiles (src, pattern, root, zos, verbos);
        baos.flush ();
        zos.close ();
    }
}


-----Function Pair=262=-----==

public static boolean restaurarCopiaSeguridad (File copia) {
    boolean retorno = true;
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (copia);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        int count;
        byte data [] = new byte [BUFFER];
        ZipEntry entry;
        String destino = DATOS;
        Conexion.apargarBD ();
        while ((entry = zis.getNextEntry ()) != null) {
            if (! entry.isDirectory ()) {
                String entryName = entry.getName ();
                String destFN = destino + entry.getName ();
                FileOutputStream fos = new FileOutputStream (destFN);
                dest = new BufferedOutputStream (fos, BUFFER);
                while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
            }
        }
        zis.close ();
        Conexion.getConexion ();
        retorno = Conexion.isConectado ();
    } catch (Exception ex) {
        Logger.getLogger (Conexion.class.getName ()).log (Level.SEVERE, null, ex);
        retorno = false;
    }
    return retorno;
}


private void sendFileList (SubMonitor subMonitor) throws LocalCancellationException {
    if (this.pInfos == null) {
        subMonitor.setTaskName ("Creating file list...");
        subMonitor.setWorkRemaining (100);
        useVersionControl = sarosSession.useVersionControl ();
        pInfos = new ArrayList < ProjectExchangeInfo > (this.projects.size ());
        for (IProject iProject : this.projects) {
            if (subMonitor.isCanceled ()) throw new LocalCancellationException (null, CancelOption.NOTIFY_PEER);
            try {
                String projectID = sarosSession.getProjectID (iProject);
                String projectName = iProject.getName ();
                FileList projectFileList = FileListFactory.createFileList (iProject, this.selectedProjectResources.get (iProject), useVersionControl, subMonitor.newChild (0));
                projectFileList.setProjectID (projectID);
                boolean partial = ! sarosSession.isCompletelyShared (iProject);
                ProjectExchangeInfo pInfo = new ProjectExchangeInfo (projectID, "", projectName, partial, projectFileList);
                pInfos.add (pInfo);
            } catch (CoreException e) {
                throw new LocalCancellationException (e.getMessage (), CancelOption.NOTIFY_PEER);
            }
            subMonitor.worked (100 / projects.size ());
        }
    }
    if (subMonitor.isCanceled ()) throw new LocalCancellationException (null, CancelOption.NOTIFY_PEER);
    subMonitor.subTask ("");
    log.debug ("Inv" + Utils.prefix (peer) + ": Sending file list...");
    subMonitor.setTaskName ("Sending file list...");
    this.sarosSession.sendActivity (sarosSession.getUser (peer), new ProjectsAddedActivity (sarosSession.getLocalUser (), pInfos, processID, this.doStream));
    subMonitor.done ();
}


-----Function Pair=263=-----==

private File gzip (File file) throws FileNotFoundException, IOException {
    if (file.isDirectory ()) {
        throw new IOException ("Unable to gzip a directory");
    }
    File destFile = new File (file.getAbsolutePath () + ".gz");
    FileOutputStream dest = new FileOutputStream (destFile);
    GZIPOutputStream out = new GZIPOutputStream (dest);
    byte data [] = new byte [BUFFER];
    FileInputStream fi = new FileInputStream (destFile);
    BufferedInputStream origin = new BufferedInputStream (fi, BUFFER);
    int count;
    while ((count = origin.read (data, 0, BUFFER)) != - 1) {
        out.write (data, 0, count);
    }
    origin.close ();
    out.close ();
    return destFile;
}


File zip (File dir, File zipFile) throws IOException {
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
    for (File file : dir.listFiles ()) {
        if (file.isFile ()) {
            byte [] data = new byte [(int) file.length ()];
            DataInputStream in = new DataInputStream (new FileInputStream (file));
            in.readFully (data);
            in.close ();
            zipOut.putNextEntry (new ZipEntry (file.getName ()));
            zipOut.write (data, 0, data.length);
            zipOut.closeEntry ();
        }
    }
    zipOut.close ();
    return zipFile;
}


-----Function Pair=264=-----==

private static ZipInputStream createDirectoriesAux (ZipEntry entry, String path, ZipInputStream inStream) throws IOException {
    if (entry == null) return inStream;
    if (entry.isDirectory ()) {
        return createDirectoriesAux (inStream.getNextEntry (), path, inStream);
    }
    else {
        String tmpPath = entry.getName ();
        tmpPath = tmpPath.replace ('/', '\\');
        int endIndex = tmpPath.indexOf ('\\');
        while (endIndex != - 1) {
            String dirToCreate = tmpPath.substring (0, endIndex);
            File f = new File (path + "\\" + dirToCreate);
            f.mkdir ();
            endIndex = tmpPath.indexOf ("\\", endIndex + 1);
            int x = 10;
            x = x + 1;
        }
        return createDirectoriesAux (inStream.getNextEntry (), path, inStream);
    }
}


private byte [] getScheduleTable (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "schedulelist.html");
    String showOverlap = urlData.getParameter ("ShowOverlap");
    boolean showOverlapStatus = false;
    if ("1".equals (showOverlap)) {
        showOverlapStatus = true;
        String overlapIcon = "<a href='/servlet/ScheduleDataRes' class='noUnder'>" + "<img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'> " + "<span class='areaTitle'>Hide Overlaps</span></a>";
        template.replaceAll ("$OverlapIcon", overlapIcon);
    }
    else {
        showOverlapStatus = false;
        String overlapIcon = "<a href='/servlet/ScheduleDataRes?ShowOverlap=1' class='noUnder'>" + "<img border=0 src='/images/log.png' align='absmiddle' width='24' height='24'> " + "<span class='areaTitle'>Show Overlaps</span></a>";
        template.replaceAll ("$OverlapIcon", overlapIcon);
    }
    StringBuffer content = new StringBuffer ();
    ScheduleItem [] itemsArray = store.getScheduleArray ();
    ScheduleItem [] temp = filterItems (itemsArray, true);
    int totalItmes = 0;
    if (temp.length > 0) {
        totalItmes += temp.length;
        content.append ("<tr><td colspan='9' class='itemheading'>Past Schedules</td></tr>");
        getSchTblData (temp, content, showOverlapStatus);
        content.append ("<tr><td colspan='9'><br></td></tr>");
        template.replaceAll ("$PastSchedules", content.toString ());
    }
    else template.replaceAll ("$PastSchedules", "");
    temp = filterItems (itemsArray, false);
    content = new StringBuffer ();
    if (temp.length > 0) {
        totalItmes += temp.length;
        content.append ("<tr><td colspan='9' class='itemheading'>Pending Schedules</td></tr>");
        getSchTblData (temp, content, showOverlapStatus);
        template.replaceAll ("$PendingSchedules", content.toString ());
    }
    else template.replaceAll ("$PendingSchedules", "");
    if (totalItmes == 0) {
        content = new StringBuffer ();
        content.append ("<tr><td colspan='9' class='itemheading'>No Schedule Items</td></tr>");
        template.replaceAll ("$NoSchedules", content.toString ());
    }
    else template.replaceAll ("$NoSchedules", "");
    template.addCookie ("backURL", urlData.getReqString ());
    int autoDelSchedAction = Integer.parseInt (store.getProperty ("sch.autodel.action"));
    String autoAction = "";
    if (autoDelSchedAction == 0) {
        autoAction += "<option value='0' selected='selected'>Archive</option>\n";
        autoAction += "<option value='1'>Delete</option>";
    }
    else {
        autoAction += "<option value='0'>Archive</option>\n";
        autoAction += "<option value='1' selected='selected'>Delete</option>";
    }
    template.replaceAll ("$deleteAction", autoAction);
    String autoDel = store.getProperty ("sch.autodel.time");
    template.replaceAll ("$deleteAfter", autoDel);
    return template.getPageBytes ();
}


-----Function Pair=265=-----==

public long getResourceLength (String resourceUri, String methodName) throws ServiceAccessException, AccessDeniedException, ObjectNotFoundException {
    long resourceLength = 0;
    if (isRootOrPesonalOrPublicFolder (resourceUri)) {
        return resourceLength;
    }
    try {
        DmsDocument dmsDocument = null;
        dmsDocument = getMappingDocumentByUrl (resourceUri);
        if (dmsDocument != null) {
            if (GET_METHED_NAME.equals (methodName) && DmsDocument.COMPOUND_DOC_TYPE.equals (dmsDocument.getDocumentType ())) {
                resourceLength = 1000000;
            }
            else if (dmsDocument.getItemSize () != null) {
                resourceLength = dmsDocument.getItemSize ().longValue ();
            }
        }
    } catch (SecurityException e) {
        log.error (e);
        throw new AccessDeniedException (resourceUri, e.getMessage (), "read");
    } catch (Exception e) {
        log.error (e);
        throw new AccessDeniedException (resourceUri, e.getMessage (), "read");
    }
    return resourceLength;
}


public String getDocumentAsString (User user, String name, int prettyPrint, String stylesheet) throws EXistException, PermissionDeniedException {
    RpcConnection con = pool.get ();
    try {
        Hashtable parametri = new Hashtable ();
        if (prettyPrint > 0) {
            parametri.put (OutputKeys.INDENT, "yes");
        }
        else {
            parametri.put (OutputKeys.INDENT, "no");
        }
        if (stylesheet != null) {
            parametri.put (EXistOutputKeys.STYLESHEET, stylesheet);
        }
        String xml = con.getDocument (user, name, parametri);
        if (xml == null) throw new EXistException ("document " + name + " not found!");
        else return xml;
    } catch (Exception e) {
        handleException (e);
        return null;
    } finally {
        pool.release (con);
    }
}


-----Function Pair=266=-----==

public SpantusBundle read (File zipFile) {
    SpantusBundle bundle = new SpantusBundle ();
    ZipFile input;
    IExtractorInputReader reader;
    MarkerSetHolder holder;
    try {
        input = new ZipFile (zipFile);
        InputStream inputStream = input.getInputStream (input.getEntry (BUNDLE_FILE_SAMPLE));
        reader = WorkServiceFactory.createReaderDao ().read (inputStream);
        inputStream = input.getInputStream (input.getEntry (BUNDLE_FILE_MARKER));
        holder = WorkServiceFactory.createMarkerDao ().read (inputStream);
    } catch (ZipException e) {
        throw new RuntimeException (e);
    } catch (IOException e) {
        throw new RuntimeException (e);
    }
    bundle.setHolder (holder);
    bundle.setReader (reader);
    return bundle;
}


private void readASchedule (InputStream sfile, int index, Actor npc, int entsize, Vector < Integer > offsets, byte ent []) throws IOException {
    int cnt = offsets.elementAt (index) - offsets.elementAt (index - 1);
    Schedule.ScheduleChange schedules [] = cnt > 0 ? new Schedule.ScheduleChange [cnt] : null;
    if (entsize == 4) {
        for (int j = 0; j < cnt; j ++) {
            sfile.read (ent, 0, 4);
            schedules [j] = new Schedule.ScheduleChange ();
            schedules [j].set4 (ent);
        }
    }
    else {
        for (int j = 0; j < cnt; j ++) {
            sfile.read (ent, 0, 8);
            schedules [j] = new Schedule.ScheduleChange ();
            schedules [j].set8 (ent);
        }
    }
    if (npc != null) npc.setSchedules (schedules);
}


-----Function Pair=267=-----=1=

public static boolean execute (final File source, final File destination, final boolean deleteSource) throws IOException {
    if (source.exists ()) {
        FileInputStream fis = new FileInputStream (source);
        FileOutputStream fos = new FileOutputStream (destination);
        ZipOutputStream zos = new ZipOutputStream (fos);
        ZipEntry zipEntry = new ZipEntry (source.getName ());
        zos.putNextEntry (zipEntry);
        byte [] inbuf = new byte [8102];
        int n;
        while ((n = fis.read (inbuf)) != - 1) {
            zos.write (inbuf, 0, n);
        }
        zos.close ();
        fis.close ();
        if (deleteSource && ! source.delete ()) {
            LogLog.warn ("Unable to delete " + source.toString () + ".");
        }
        return true;
    }
    return false;
}


public void createZipFile (File fileToAdd, File cssFile) {
    try {
        byte [] buf = new byte [4096];
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (getOutFile (fileToAdd)));
        out.setLevel (9);
        FileInputStream in = new FileInputStream (fileToAdd);
        out.putNextEntry (new ZipEntry (fileToAdd.getName ()));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in = new FileInputStream (cssFile);
        out.putNextEntry (new ZipEntry (cssFile.getName ()));
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
        fileToAdd.deleteOnExit ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=268=-----==

public Archive save (OutputStream dest) throws IOException {
    ZipOutputStream out;
    InputStream in;
    List < Node > content;
    List < Node > files;
    out = new ZipOutputStream (dest);
    out.putNextEntry (new ZipEntry ("/"));
    out.closeEntry ();
    if (manifest != null) {
        out.putNextEntry (new ZipEntry (MANIFEST));
        manifest.write (out);
        out.closeEntry ();
    }
    content = data.find ("**/*");
    files = new ArrayList < Node > ();
    for (Node node : content) {
        if (isManifest (node)) {
            throw new ArchiveException ("manifest file not allowed");
        }
        else if (node.isFile ()) {
            files.add (node);
        }
        else {
            out.putNextEntry (new ZipEntry (node.getPath () + "/"));
            out.closeEntry ();
        }
    }
    for (Node file : files) {
        in = file.createInputStream ();
        out.putNextEntry (new ZipEntry (file.getPath ()));
        file.getIO ().getBuffer ().copy (in, out);
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    return this;
}


private byte [] editTaskPage (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskEdit.html");
    String captcha = store.getProperty ("security.captcha");
    if ("1".equals (captcha)) {
        template.replaceAll ("$usingCAPTCHA$", "true");
    }
    else {
        template.replaceAll ("$usingCAPTCHA$", "false");
    }
    String taskName = urlData.getParameter ("name");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    TaskCommand task = (TaskCommand) tasks.get (taskName);
    if (task != null) {
        template.replaceAll ("$taskName", taskName);
        String command = task.getCommand ();
        command = command.replaceAll ("\"", "&#34;");
        command = command.replaceAll ("<", "&lt;");
        command = command.replaceAll (">", "&gt;");
        template.replaceAll ("$taskCommand", command);
        template.replaceAll ("$taskDelayFor", new Integer (task.getDelay ()).toString ());
        if (task.getAutoRemove ()) template.replaceAll ("$autoRemove", "checked");
        else template.replaceAll ("$autoRemove", "");
        template.replaceAll ("$concurrentTasks", new Integer (task.getConcurrent ()).toString ());
        template.replaceAll ("$timeToNextSchedule", new Integer (task.getTimeToNextSchedule ()).toString ());
        if (task.getWhenNotCapturing ()) template.replaceAll ("$whenNotCapturing", "checked");
        else template.replaceAll ("$whenNotCapturing", "");
    }
    else {
        String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
        return out.getBytes ();
    }
    return template.getPageBytes ();
}


-----Function Pair=269=-----==

private void createHeadingLabels (int headingLines, Color back) {
    headingLabels = new JLabel [headingLines + 1];
    headingLabels [0] = new JLabel ("");
    headingLabels [0].setFont (headingLabels [0].getFont ().deriveFont (Font.BOLD));
    Color foreground = null;
    if (installdata.guiPrefs.modifier.containsKey ("headingForegroundColor")) {
        foreground = Color.decode (installdata.guiPrefs.modifier.get ("headingForegroundColor"));
        headingLabels [0].setForeground (foreground);
    }
    if (installdata.guiPrefs.modifier.containsKey ("headingFontSize")) {
        float fontSize = Float.parseFloat (installdata.guiPrefs.modifier.get ("headingFontSize"));
        if (fontSize > 0.0 && fontSize <= 5.0) {
            float currentSize = headingLabels [0].getFont ().getSize2D ();
            headingLabels [0].setFont (headingLabels [0].getFont ().deriveFont (currentSize * fontSize));
        }
    }
    if (imageLeft) {
        headingLabels [0].setAlignmentX (Component.RIGHT_ALIGNMENT);
    }
    for (int i = 1; i < headingLines; ++ i) {
        headingLabels [i] = new JLabel ();
        if (imageLeft) {
            headingLabels [i].setAlignmentX (Component.RIGHT_ALIGNMENT);
        }
        else {
            headingLabels [i].setBorder (BorderFactory.createEmptyBorder (0, 30, 0, 8));
        }
    }
}


private String getTaskList (ScheduleItem item) {
    StringBuffer buff = new StringBuffer (1024);
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String selectedTask = store.getProperty ("tasks.deftask");
    if (item != null) {
        selectedTask = item.getPostTask ();
    }
    String [] keys = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    if (selectedTask.length () == 0) buff.append ("<label><input type='radio' name='task' value='none' checked>none</label><br>\n");
    else buff.append ("<label><input type='radio' name='task' value='none'>none</label><br>\n");
    for (int x = 0; x < keys.length; x ++) {
        if (keys [x].equals (selectedTask)) buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "' checked>" + keys [x] + "</label><br>\n");
        else buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "'>" + keys [x] + "</label><br>\n");
    }
    return buff.toString ();
}


-----Function Pair=270=-----==

private static String _getRelativePath (File baseDir, String file) throws IOException {
    if (! baseDir.isAbsolute ()) throw new IllegalArgumentException ("baseDir \"" + baseDir.getPath () + "\" is not absolute!");
    File absFile;
    File tmpF = new File (file);
    if (tmpF.isAbsolute ()) absFile = tmpF;
    else absFile = new File (baseDir, file);
    String absFileStr = null;
    String baseDirStr = null;
    for (int mode_base = 0; mode_base < 2; ++ mode_base) {
        switch (mode_base) {
            case 0 :
                baseDirStr = simplifyPath (baseDir);
                break;
            case 1 :
                baseDirStr = baseDir.getCanonicalPath ();
                break;
            default :
                throw new IllegalStateException ("this should never happen!");
        }
        for (int mode_abs = 0; mode_abs < 2; ++ mode_abs) {
            baseDirStr = addFinalSlash (baseDirStr);
            switch (mode_abs) {
                case 0 :
                    absFileStr = simplifyPath (absFile);
                    break;
                case 1 :
                    absFileStr = absFile.getCanonicalPath ();
                    break;
                default :
                    throw new IllegalStateException ("this should never happen!");
            }
            if (! absFileStr.startsWith (baseDirStr)) {
                if (mode_base >= 1 && mode_abs >= 1) return null;
            }
            else break;
        }
    }
    if (baseDirStr == null) throw new NullPointerException ("baseDirStr == null");
    if (absFileStr == null) throw new NullPointerException ("absFileStr == null");
    return absFileStr.substring (baseDirStr.length (), absFileStr.length ());
}


public static String getInterfacesIPv4 (String netInterface) {
    String networkInterfaceIP = null;
    try {
        @SuppressWarnings ("rawtypes")
        Enumeration e = NetworkInterface.getNetworkInterfaces ();
        while (e.hasMoreElements ()) {
            NetworkInterface ni = (NetworkInterface) e.nextElement ();
            if (ni.getName ().toString ().equals (netInterface)) {
                NetworkLog.logMsg (NetworkLog.LOG_INFO, Tools.class, "Your network interface is: " + ni.getName ().toString ());
                @SuppressWarnings ("rawtypes")
                Enumeration e2 = ni.getInetAddresses ();
                patternipv4 = Pattern.compile (ipv4Pattern);
                while (e2.hasMoreElements ()) {
                    InetAddress ip = (InetAddress) e2.nextElement ();
                    ipv4 = ip.toString ().replace ("/", "");
                    matcheripv4 = patternipv4.matcher (ipv4);
                    if (matcheripv4.matches ()) {
                        networkInterfaceIP = ipv4;
                    }
                }
            }
        }
    } catch (Exception e) {
        Log.error (Tools.class, e.getMessage ());
    }
    return networkInterfaceIP;
}


-----Function Pair=271=-----==

public static void copyFile (File source, File destination) throws IOException {
    if ((destination.getParentFile () != null) && (! destination.getParentFile ().exists ())) {
        destination.getParentFile ().mkdirs ();
    }
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream (source);
        fos = new FileOutputStream (destination);
        byte [] buffer = new byte [1024 * 4];
        int n = 0;
        while ((n = fis.read (buffer)) != - 1) {
            fos.write (buffer, 0, n);
        }
    } catch (IOException e) {
        throw new IOException (e.getMessage () + " Source: " + source + " Destination: " + destination);
    } finally {
        closeStream (fis);
        closeStream (fos);
    }
}


public static String RTF2HTML (String entrada) {
    StringReader stream;
    if (entrada == null) {
        return "";
    }
    try {
        entrada = entrada.replace ('\'', '�');
        stream = new StringReader (entrada);
        RTFEditorKit kit = new RTFEditorKit ();
        javax.swing.text.Document doc = kit.createDefaultDocument ();
        kit.read (stream, doc, 0);
        return doc.getText (0, doc.getLength ());
    } catch (Exception e) {
        return e.toString ();
    }
}


-----Function Pair=272=-----==

public static boolean copyFile (File pSource, File pDestination) {
    InputStream in;
    OutputStream out;
    try {
        in = new FileInputStream (pSource);
        out = new FileOutputStream (pDestination);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
        return true;
    } catch (IOException e) {
        return false;
    }
}


public static void stringToFile (String s, File f, String encoding) throws IOException {
    if (s == null) throw new IllegalArgumentException ("string argument cannot be null");
    if (f == null) throw new IllegalArgumentException ("file argument cannot be null");
    if (encoding == null) throw new IllegalArgumentException ("encoding argument cannot be null");
    Reader reader = new BufferedReader (new StringReader (s));
    FileOutputStream fos = new FileOutputStream (f);
    Writer out;
    if (encoding == null) out = new BufferedWriter (new OutputStreamWriter (fos));
    else out = new BufferedWriter (new OutputStreamWriter (fos, encoding));
    char buf [] = new char [1024 * 50];
    int read = - 1;
    while ((read = reader.read (buf)) != - 1) {
        out.write (buf, 0, read);
    }
    reader.close ();
    out.flush ();
    out.close ();
}


-----Function Pair=273=-----==

public static String getTableHtml (ZoieIndexLogProcessor zp, boolean addGraphs, String outputDir, String subFolderForOutput, int imgWidth, int imgHeight, int numGraphsPerRow) throws Exception {
    if (! zp._isProcessed) {
        zp.process ();
    }
    if (zp._fpd == null) {
        return "";
    }
    String [] scenarios = new String [] {"Time to fill RAM Buffer (ms)", "Average Flush Rate (per second)", "Items Flushed"};
    String itemKey = "Item";
    GenericStatisticsUtil [] utils = new GenericStatisticsUtil [3];
    utils [0] = new GenericStatisticsUtil (zp._fpd.getNonNumericNthColumn (2));
    utils [0].process ();
    utils [1] = new GenericStatisticsUtil (zp._fpd.getNonNumericNthColumn (3));
    utils [1].process ();
    utils [2] = new GenericStatisticsUtil (zp._fpd.getNonNumericNthColumn (4));
    utils [2].process ();
    String tab = ZoieHtmlCreator.getSimpleTableHtmlString (itemKey, scenarios, utils, null);
    if (addGraphs) {
        tab = tab + "<br><br>\n" + getTableHtmlForGraphs (zp, outputDir, subFolderForOutput, "Series", imgWidth, imgHeight, true, false, "center", numGraphsPerRow);
    }
    return tab;
}


public static String isoToOracleTimeStamp (String isoDate) {
    if ((isoDate == null) || ! (isoDate.length () > 0) || isoDate.startsWith ("%")) return "";
    int monthNo = new Integer (isoDate.substring (4, 6)).intValue ();
    String monthName = monthNoToName (monthNo);
    String amPm = "AM";
    String HH = isoDate.substring (8, 10);
    int hour = new Integer (HH).intValue ();
    if (hour == 0) {
        HH = "12";
    }
    if (hour > 12) {
        hour -= 12;
        amPm = "PM";
        HH = new Integer (hour).toString ();
    }
    return isoDate.substring (6, 8) + "-" + monthName + "-" + isoDate.substring (0, 4) + " " + HH + ":" + isoDate.substring (10, 12) + ":" + isoDate.substring (12) + ".0" + amPm;
}


-----Function Pair=274=-----==

public static void main (String [] args) {
    try {
        out = new FileWriter (System.getProperty ("generateToDir") + "/OPT_Assembler.java");
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    try {
        lowLevelAsm = Class.forName ("VM_Assembler");
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    emit ("import instructionFormats.*;\n\n");
    emit ("\n\n");
    emit ("/**\n");
    emit (" *  This class is the automatically-generated assembler for\n");
    emit (" * the optimizing compiler.  It consists of methods that\n");
    emit (" * understand the possible operand combinations of each\n");
    emit (" * instruction type, and how to translate those operands to\n");
    emit (" * calls to the VM_Assember low-level emit method\n");
    emit (" *\n");
    emit (" * @see GenerateAssembler\n");
    emit (" *\n");
    emit (" * @author Julian Dolby\n");
    emit (" * @author {@link GenerateAssembler}\n");
    emit (" */\n");
    emit ("class OPT_Assembler extends OPT_AssemblerBase {\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  This class requires no special construction;\n");
    emitTab (1);
    emit (" * this constructor simply invokes the\n");
    emitTab (1);
    emit (" * constructor for VM_Assembler\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @see VM_Assembler\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("OPT_Assembler(int bcSize, boolean print) {\n");
    emitTab (2);
    emit ("super(bcSize, print);\n");
    emitTab (1);
    emit ("}");
    emit ("\n\n");
    Method [] emitters = lowLevelAsm.getDeclaredMethods ();
    Set opcodes = getOpcodes (emitters);
    Iterator i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        setCurrentOpcode (opcode);
        emitTab (1);
        emit ("/**\n");
        emitTab (1);
        emit (" *  Emit the given instruction, assuming that\n");
        emitTab (1);
        emit (" * it is a " + currentFormat + " instruction\n");
        emitTab (1);
        emit (" * and has a " + currentOpcode + " operator\n");
        emitTab (1);
        emit (" *\n");
        emitTab (1);
        emit (" * @param inst the instruction to assemble\n");
        emitTab (1);
        emit (" */\n");
        emitTab (1);
        emit ("private void do" + opcode + "(OPT_Instruction inst) {\n");
        EmitterSet emitter = buildSetForOpcode (emitters, opcode);
        boolean [] [] tp = new boolean [4] [encoding.length];
        emitter.emitSet (opcode, tp, 2);
        emitTab (1);
        emit ("}\n\n");
    }
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  The number of instructions emitted so far\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("private int instructionCount = 0;\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  Assemble the given instruction\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @param inst the instruction to assemble\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("void doInst(OPT_Instruction inst) {\n");
    emitTab (2);
    emit ("resolveForwardReferences(++instructionCount);\n");
    emitTab (2);
    emit ("switch (inst.getOpcode()) {\n");
    Set emittedOpcodes = new HashSet ();
    i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        Iterator operators = getMatchingOperators (opcode).iterator ();
        while (operators.hasNext ()) {
            Object operator = operators.next ();
            emitTab (3);
            emittedOpcodes.add (operator);
            emit ("case IA32_" + operator + "_opcode:\n");
        }
        emitTab (4);
        emit ("do" + opcode + "(inst);\n");
        emitTab (4);
        emit ("break;\n");
    }
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IA32_LOCK_opcode:\n");
    emitTab (4);
    emit ("emitLockNextInstruction();\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IG_PATCH_POINT_opcode:\n");
    emitTab (4);
    emit ("emitPatchPoint();\n");
    emitTab (4);
    emit ("break;\n");
    Set errorOpcodes = getErrorOpcodes (emittedOpcodes);
    if (! errorOpcodes.isEmpty ()) {
        i = errorOpcodes.iterator ();
        while (i.hasNext ()) {
            emitTab (3);
            emit ("case IA32_" + i.next () + "_opcode:\n");
        }
        emitTab (4);
        emit ("throw new OPT_OptimizingCompilerException(inst + \" has unimplemented IA32 opcode (check excludedOpcodes)\");\n");
    }
    emitTab (2);
    emit ("}\n");
    emitTab (2);
    emit ("inst.setmcOffset( mi );\n");
    emitTab (1);
    emit ("}\n\n");
    emit ("\n}\n");
    try {
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void Update (String primaryKey, String JSONitem) {
    Method [] methods = clazz.getDeclaredMethods ();
    Poll poll = new Poll ();
    try {
        Map obj = (Map) new JSONParser ().parse (JSONitem);
        for (Field classFeild : clazz.getDeclaredFields ()) {
            Annotation ann = classFeild.getAnnotation (Column.class);
            if (ann == null) {
                continue;
            }
            if (null == obj.get (classFeild.getName ())) {
                continue;
            }
            ann = classFeild.getAnnotation (Id.class);
            boolean isPrimaryKey = false;
            if (ann != null) {
                isPrimaryKey = true;
            }
            String methodName = "set" + classFeild.getName ().substring (0, 1).toUpperCase () + classFeild.getName ().substring (1);
            Method m = null;
            try {
                for (Method method : methods) {
                    if (method.getName ().equals (methodName)) {
                        Logger.getLogger (Polls.class.getName ()).info (methodName);
                        m = method;
                        break;
                    }
                }
                String s = obj.get (classFeild.getName ()).toString ();
                Object parameterObject;
                if (isPrimaryKey) {
                    parameterObject = Conversion.Cast (primaryKey, m.getParameterTypes () [0]);
                }
                else {
                    parameterObject = Conversion.Cast (s, m.getParameterTypes () [0]);
                }
                m.invoke (poll, new Object [] {parameterObject});
            } catch (Exception ex) {
                Logger.getLogger (Polls.class.getName ()).log (Level.SEVERE, null, ex);
            }
        }
        poll.Update ();
    } catch (Exception ex) {
        Logger.getLogger (Polls.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


-----Function Pair=275=-----==

public boolean runCommand () {
    String cmd;
    String cmd_args [];
    if (macro.next ()) {
        String cmd_arg_string = " ";
        cmd = macro.cmd ();
        cmd_args = macro.args ();
        for (int i = 0; i < cmd_args.length; i ++) {
            cmd_arg_string += cmd_args [i] + " ";
        }
        jdp_console.writeOutput ("\n");
        jdp_console.writeOutput ("Macro line " + macro.currentLine () + ": " + cmd + cmd_arg_string);
    }
    else {
        jdp_console.readCommand (user);
        cmd = jdp_console.cmd ();
        cmd_args = jdp_console.args ();
    }
    if (! cmd.equals ("")) {
        if (cmd.equals ("quit") || cmd.equals ("q")) {
            return true;
        }
        else {
            try {
                return jdpCommand (cmd, cmd_args);
            } catch (Exception e) {
                jdp_console.writeOutput ("ERROR executing jdp command: " + e.getMessage ());
                jdp_console.writeOutput ("email to jvm-coders or try again . . . ");
            }
        }
    }
    return false;
}


private boolean matchResultToString (String methodName, String expectedResult, String returnedResult) {
    if (expectedResult.equals (returnedResult)) {
        System.out.println ("SUCCESS@" + methodName);
        System.out.println ("EXPECTED");
        System.out.println (expectedResult);
        System.out.println ("RETURNED");
        System.out.println (returnedResult + "\n");
        return true;
    }
    else {
        System.out.println ("FAILURE@" + methodName);
        System.out.println ("EXPECTED");
        System.out.println (expectedResult);
        System.out.println ("RETURNED");
        System.out.println (returnedResult + "\n");
        return false;
    }
}


-----Function Pair=276=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=277=-----==

public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=278=-----==

public void process () {
    System.out.printf ("\n> Processing %s\n", tester.getClass ());
    boolean failed = false;
    for (Method m : tester.getClass ().getDeclaredMethods ()) {
        Test anno = m.getAnnotation (Test.class);
        Ignore ignore = m.getAnnotation (Ignore.class);
        if (anno != null) {
            if (ignore == null) {
                System.out.println (">> Invoking test " + m.getName ());
                Object result;
                try {
                    result = m.invoke (tester);
                } catch (Exception e) {
                    throw new Error ("Test invocation failed", e);
                }
                boolean ok = true;
                if (Collection.class.isAssignableFrom (m.getReturnType ())) {
                    ok = verifyResults ((Collection) result, anno.result (), anno.ordered ());
                }
                else if (m.getReturnType () != void.class) {
                    ok = verifyResult (result, anno.result ());
                }
                if (! ok) {
                    System.out.println (">>> Expected: " + anno);
                    System.out.println (">>> Got: " + result);
                    failed = true;
                }
            }
            else {
                System.out.println (">> Ignoring test " + m.getName ());
                if (ignore.value ().length () > 0) {
                    System.out.println (">>> Reason: " + ignore.value ());
                }
            }
        }
    }
    if (failed) {
        throw new Error ("Test(s) returned unexpected result");
    }
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=279=-----==

public void run () {
    Method [] methods = this.getClass ().getMethods ();
    int countTestCases = 0;
    int countSuccessTestCases = 0;
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().length () > 4) {
            if (methods [i].getName ().substring (0, 4).equals ("Test")) {
                countTestCases ++;
                try {
                    if ((Boolean) (methods [i].invoke (this, methods [i].getName ().substring (4)))) {
                        countSuccessTestCases ++;
                    }
                } catch (IllegalArgumentException e) {
                    e.printStackTrace ();
                } catch (IllegalAccessException e) {
                    e.printStackTrace ();
                } catch (InvocationTargetException e) {
                    e.printStackTrace ();
                }
            }
        }
    }
    System.out.println ("------------------------");
    System.out.println ("Testcases: " + countTestCases);
    System.out.println ("Success  : " + countSuccessTestCases);
    System.out.println ("Failure  : " + (countTestCases - countSuccessTestCases));
}


private static void getstaticmethods () throws TestException {
    Method [] m;
    System.out.print ("    * getStaticMethods( RJavaTools_Test ) ");
    m = RJavaTools.getStaticMethods (RJavaTools_Test.class);
    String [] expected = new String [] {"getStaticX", "main", "runtests"};
    int count = 0;
    if (m.length != expected.length) {
        throw new TestException (" getStaticMethods( RJavaTools_Test ).length != 2");
    }
    for (int i = 0; i < m.length; i ++) {
        for (int j = 0; j < expected.length; j ++) {
            if (m [i].getName ().equals (expected [j])) {
                count ++;
                break;
            }
        }
    }
    if (count != expected.length) {
        throw new TestException (" getStaticMethods( RJavaTools_Test ) != c('main', 'getStaticX', 'runtests' ) ");
    }
    System.out.println ("  : ok");
    System.out.print ("    * getStaticMethods( Object ) ");
    m = RJavaTools.getStaticMethods (Object.class);
    if (m != null) {
        throw new TestException (" getStaticMethods( Object ) != null");
    }
    System.out.println ("  : ok");
}


-----Function Pair=280=-----==

public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


void convertPropsSequenceToString (SkinProperty newProp) {
    String newPropValue = null;
    String seqPropNamePrefix = newProp.name;
    int index = 0;
    String seqPropName = seqPropNamePrefix + index;
    String seqPropValue = (String) romizedProps.get (seqPropName);
    while (seqPropValue != null) {
        if (newPropValue == null) {
            newPropValue = seqPropValue;
        }
        else {
            newPropValue += "," + seqPropValue;
        }
        index += 1;
        seqPropName = seqPropNamePrefix + index;
        seqPropValue = (String) romizedProps.get (seqPropName);
    }
    newProp.value = newPropValue;
}


-----Function Pair=281=-----==

public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


-----Function Pair=282=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=283=-----==

private void showAppInstructions () {
    Container pane = getContentPane ();
    TableLayout layout = (TableLayout) pane.getLayout ();
    layout.deleteRow (2);
    layout.insertRow (2, 600);
    InstuctionsPanel appPanel = new InstuctionsPanel ();
    JScrollPane applicationScrollPane;
    applicationScrollPane = new JScrollPane (appPanel);
    this.addComponentListener (appPanel);
    pane.add (applicationScrollPane, "0, 2");
    setVisible (false);
    setSize (799, 699);
    setSize (800, 700);
    setVisible (true);
}


public String doInBackground () {
    ok.setEnabled (false);
    BufferedReader in = null;
    try {
        URL url = new URL (net.mjrz.fm.ui.utils.UIDefaults.LATEST_VERSION_URL);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
        int status = conn.getResponseCode ();
        if (status == 200) {
            in = new BufferedReader (new InputStreamReader (conn.getInputStream ()));
            StringBuilder str = new StringBuilder ();
            while (true) {
                String line = in.readLine ();
                if (line == null) break;
                str.append (line);
            }
            return str.toString ();
        }
        else {
            logger.error ("Unable to retrieve latest version: HTTP ERROR CODE: " + status);
            return "";
        }
    } catch (Exception e) {
        logger.error ("Unable to retrieve latest version: HTTP ERROR CODE: " + e.getMessage ());
        return null;
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (Exception e) {
                logger.error (e);
            }
        }
    }
}


-----Function Pair=284=-----==

public static String getFileContent (File file, Charset enc, int maxLength) throws IOException {
    if (file == null || ! file.isFile ()) {
        return "";
    }
    FileInputStream fis = null;
    try {
        fis = new FileInputStream (file);
        InputStreamReader isr = new InputStreamReader (fis, enc);
        int length = (int) Math.min (maxLength, file.length ());
        char [] chars = new char [length];
        int loaded = isr.read (chars);
        return new String (chars, 0, loaded);
    } finally {
        if (fis != null) {
            fis.close ();
        }
    }
}


private void prepareBuffer () {
    if (rawImage == null) {
        bufferedImage = null;
        return;
    }
    BufferedImage gradient = null;
    int height = rawImage.getIconHeight ();
    int width = rawImage.getIconWidth ();
    Graphics2D g2D = null;
    bufferedImage = new BufferedImage (width, height << 1, BufferedImage.TYPE_INT_ARGB);
    try {
        gradient = new BufferedImage (width, height, BufferedImage.TYPE_INT_ARGB);
        g2D = gradient.createGraphics ();
        GradientPaint painter = new GradientPaint (0.0f, 0.0f, opac1, 0.0f, height / 2.0f, opac2);
        g2D.setPaint (painter);
        g2D.fill (new Rectangle2D.Double (0, 0, width, height));
        g2D.dispose ();
        gradient.flush ();
        g2D = bufferedImage.createGraphics ();
        g2D.drawImage (rawImage.getImage (), null, null);
        g2D.translate (0, height << 1);
        g2D.drawImage (rawImage.getImage (), reflectTransform, null);
        g2D.translate (0, - (height << 1));
        g2D.setComposite (AlphaComposite.DstOut);
        g2D.drawImage (gradient, null, 0, height);
    } finally {
        if (gradient != null) {
            gradient.flush ();
        }
        if (g2D != null) {
            g2D.dispose ();
        }
    }
}


-----Function Pair=285=-----==

public static String [] compactStrings (String [] as) {
    String as1 [] = new String [as.length];
    int i = 0;
    for (int j = 0; j < as.length; j ++) {
        i += as [j].length ();
    }
    char ac [] = new char [i];
    i = 0;
    for (int k = 0; k < as.length; k ++) {
        as [k].getChars (0, as [k].length (), ac, i);
        i += as [k].length ();
    }
    String s = new String (ac);
    i = 0;
    for (int l = 0; l < as.length; l ++) {
        as1 [l] = s.substring (i, i += as [l].length ());
    }
    return as1;
}


public static < T > T max (final T [] array, final double [] scores) {
    if (array.length != scores.length) {
        throw new IllegalArgumentException ("array.length(" + array.length + ") != scores.length(" + scores.length + ")");
    }
    T obj = null;
    double d = Double.MIN_VALUE;
    for (int i = 0; i < scores.length; i ++) {
        final double score = scores [i];
        if (score > d) {
            d = score;
            obj = array [i];
        }
    }
    return obj;
}


-----Function Pair=286=-----==

public static void setValue (Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) {
    if (propertyDescriptor instanceof IndexedPropertyDescriptor) {
        try {
            IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor;
            Method method = ipd.getIndexedWriteMethod ();
            if (method != null) {
                method.invoke (bean, new Object [] {new Integer (index), convert (value, ipd.getIndexedPropertyType ())});
                return;
            }
        } catch (Exception ex) {
            throw new RuntimeException ("Cannot access property: " + propertyDescriptor.getName () + ", " + ex.getMessage ());
        }
    }
    Object collection = getValue (bean, propertyDescriptor);
    if (isCollection (collection)) {
        setValue (collection, index, value);
    }
    else if (index == 0) {
        setValue (bean, propertyDescriptor, value);
    }
    else {
        throw new RuntimeException ("Not a collection: " + propertyDescriptor.getName ());
    }
}


private BeanWrapperImpl getNestedBeanWrapper (String nestedProperty) throws BeansException {
    if (this.nestedBeanWrappers == null) {
        this.nestedBeanWrappers = new HashMap ();
    }
    PropertyTokenHolder tokens = getPropertyNameTokens (nestedProperty);
    String canonicalName = tokens.canonicalName;
    Object propertyValue = getPropertyValue (tokens);
    if (propertyValue == null) {
        throw new NullValueInNestedPathException (getRootClass (), this.nestedPath + canonicalName);
    }
    BeanWrapperImpl nestedBw = (BeanWrapperImpl) this.nestedBeanWrappers.get (canonicalName);
    if (nestedBw == null || nestedBw.getWrappedInstance () != propertyValue) {
        if (logger.isDebugEnabled ()) {
            logger.debug ("Creating new nested BeanWrapper for property '" + canonicalName + "'");
        }
        nestedBw = newNestedBeanWrapper (propertyValue, this.nestedPath + canonicalName + NESTED_PROPERTY_SEPARATOR);
        copyDefaultEditorsTo (nestedBw);
        copyCustomEditorsTo (nestedBw, canonicalName);
        this.nestedBeanWrappers.put (canonicalName, nestedBw);
    }
    else {
        if (logger.isDebugEnabled ()) {
            logger.debug ("Using cached nested BeanWrapper for property '" + canonicalName + "'");
        }
    }
    return nestedBw;
}


-----Function Pair=287=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static void BubbleSortByte2 (byte [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                byte temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=288=-----==

public void deleteObject (PropertyModel propertyModel, Object selectedChoice) {
    Object values = propertyModel.getObject ();
    if (values.getClass ().isArray ()) {
        Object [] valuesArray = (Object []) values;
        int selectedChoiceIndex = getIndex (selectedChoice, valuesArray);
        if (selectedChoiceIndex >= 0) {
            Object [] newArray = (Object []) Array.newInstance (valuesArray.getClass ().getComponentType (), valuesArray.length - 1);
            System.arraycopy (valuesArray, 0, newArray, 0, selectedChoiceIndex);
            System.arraycopy (valuesArray, selectedChoiceIndex + 1, newArray, selectedChoiceIndex, valuesArray.length - selectedChoiceIndex - 1);
            PropertyUtil.setPropertyValue (propertyModel.getTarget (), propertyModel.getPropertyExpression (), newArray);
        }
    }
    else if (List.class.isAssignableFrom (values.getClass ())) {
        List valuesCollection = (List) values;
        int selectedChoiceIndex = valuesCollection.indexOf (selectedChoice);
        if (selectedChoiceIndex != - 1) {
            valuesCollection.remove (selectedChoiceIndex);
        }
    }
}


private static Object mergeArrays (Object thisArray, Object otherArray) {
    if (thisArray == null) {
        return otherArray;
    }
    if (thisArray instanceof ArrayOfReferences && otherArray instanceof ArrayOfReferences) {
        ArrayOfReferences arr1 = (ArrayOfReferences) thisArray;
        ArrayOfReferences arr2 = (ArrayOfReferences) otherArray;
        if (arr1.getReferences ().length == arr2.getReferences ().length) {
            mergeArrays (arr1.getReferences (), arr2.getReferences ());
            return thisArray;
        }
        else {
            return otherArray;
        }
    }
    int lenThis = Array.getLength (thisArray);
    int lenOther = Array.getLength (otherArray);
    if (lenThis != lenOther) {
        return otherArray;
    }
    for (int i = 0; i < lenThis; i ++) {
        Object otherObject = Array.get (otherArray, i);
        Array.set (thisArray, i, otherObject);
    }
    return thisArray;
}


-----Function Pair=289=-----==

public void screenPublish (ScreenPublisher publisher) {
    this.publisher = publisher;
    try {
        this.robot = new Robot ();
        logger.debug ("setup capture thread");
        capture = new CaptureScreen (VirtualScreenBean.vScreenSpinnerX, VirtualScreenBean.vScreenSpinnerY, VirtualScreenBean.vScreenSpinnerWidth, VirtualScreenBean.vScreenSpinnerHeight);
        if (thread == null) {
            thread = new Thread (capture);
            thread.start ();
        }
        capture.start ();
        startButton.setEnabled (false);
        stopButton.setEnabled (true);
        startPublish = true;
    } catch (Exception e) {
        logger.error ("screenPublish error " + e);
        e.printStackTrace ();
        showBandwidthWarning ("Internal error capturing screen, see log file");
    }
}


static Popup getInstance (Component owner, Component contents, int x, int y, Popup delegate) {
    ShadowPopup result;
    synchronized (ShadowPopup.class) {
        if (cache == null) {
            cache = new ArrayList (MAX_CACHE_SIZE);
        }
        if (cache.size () > 0) {
            result = (ShadowPopup) cache.remove (0);
        }
        else {
            result = new ShadowPopup ();
        }
    }
    result.reset (owner, contents, x, y, delegate);
    return result;
}


-----Function Pair=290=-----==

private byte [] encode (final byte [] current, final byte [] previous, final int blockWidth, final int blockHeight, final int width, final int height) throws Exception {
    ByteArrayOutputStream baos = new ByteArrayOutputStream (16 * 1024);
    if (previous == null) {
        baos.write (getTag (0x01, 0x03));
    }
    else {
        baos.write (getTag (0x02, 0x03));
    }
    final int wh = width + ((blockWidth / 16 - 1) << 12);
    final int hh = height + ((blockHeight / 16 - 1) << 12);
    writeShort (baos, wh);
    writeShort (baos, hh);
    int y0 = height;
    int x0 = 0;
    int bwidth = blockWidth;
    int bheight = blockHeight;
    while (y0 > 0) {
        bheight = Math.min (y0, blockHeight);
        y0 -= bheight;
        bwidth = blockWidth;
        x0 = 0;
        while (x0 < width) {
            bwidth = (x0 + blockWidth > width) ? width - x0 : blockWidth;
            final boolean changed = isChanged (current, previous, x0, y0, bwidth, bheight, width, height);
            if (changed) {
                ByteArrayOutputStream blaos = new ByteArrayOutputStream (4 * 1024);
                DeflaterOutputStream dos = new DeflaterOutputStream (blaos);
                for (int y = 0; y < bheight; y ++) {
                    dos.write (current, 3 * ((y0 + bheight - y - 1) * width + x0), 3 * bwidth);
                }
                dos.finish ();
                final byte [] bbuf = blaos.toByteArray ();
                final int written = bbuf.length;
                writeShort (baos, written);
                baos.write (bbuf, 0, written);
            }
            else {
                writeShort (baos, 0);
            }
            x0 += bwidth;
        }
    }
    return baos.toByteArray ();
}


public void init () {
    GraphicsConfiguration gc = SimpleUniverse.getPreferredConfiguration ();
    cv = new Canvas3D (gc);
    setLayout (new BorderLayout ());
    add (cv, BorderLayout.CENTER);
    updater = new DNACanvas_3.ShadowUpdater ();
    TextArea text = new TextArea ();
    text.setMaximumSize (new Dimension (100, 20));
    Button setBand = new Button ("Sett baseparfarge");
    setBand.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            currentWord = JOptionPane.showInputDialog (null, "mm");
            refreshShadow ();
        }
    }
    );
    Button scrShot = new Button ("Ta skjermdump");
    scrShot.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            takeScreenShot ();
            status.setText ("");
            status.append ("Screenshot taken");
        }
    }
    );
    Button wf = new Button ("Toggle Wireframe");
    wf.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (setWireframe == false) {
                pa.setPolygonMode (PolygonAttributes.POLYGON_LINE);
                polyAttr.setPolygonMode (PolygonAttributes.POLYGON_LINE);
                pa.setCullFace (PolygonAttributes.CULL_BACK);
                pa.setBackFaceNormalFlip (true);
                setWireframe = true;
                status.setText ("");
                status.append ("Wireframe Mode On");
            }
            else {
                pa.setCullFace (PolygonAttributes.CULL_BACK);
                pa.setPolygonMode (PolygonAttributes.POLYGON_FILL);
                polyAttr.setPolygonMode (PolygonAttributes.POLYGON_FILL);
                setWireframe = false;
                status.setText ("");
                status.append ("Texture Mode On");
            }
        }
    }
    );
    Panel buttonframe = new Panel ();
    buttonframe.setLayout (new GridBagLayout ());
    GridBagConstraints gbc = new GridBagConstraints ();
    gbc.gridy = 0;
    gbc.gridx = 0;
    buttonframe.add (setBand, gbc);
    gbc.gridx = 1;
    buttonframe.add (scrShot, gbc);
    gbc.gridx = 2;
    buttonframe.add (wf, gbc);
    add (buttonframe, BorderLayout.NORTH);
    status = new JTextArea ("Texture Mode On");
    status.setEditable (false);
    status.setBackground (Color.BLACK);
    status.setForeground (Color.WHITE);
    add (status, BorderLayout.SOUTH);
    VirtualUniverse vu = new VirtualUniverse ();
    Locale loc = new Locale (vu);
    BranchGroup bgView = createViewBranch (cv);
    bgView.compile ();
    loc.addBranchGraph (bgView);
    BranchGroup bg = createContentBranch ();
    loc.addBranchGraph (bg);
    SettingsFrame sf = new SettingsFrame ();
}


-----Function Pair=291=-----==

public void repaint () {
    Graphics g = this.getGraphics ();
    g.setColor (Color.red);
    w = lastPoint.x - startPoint.x;
    h = lastPoint.y - startPoint.y;
    width = Math.abs (w);
    height = Math.abs (h);
    this.paintComponents (g);
    if (this.flag_prepare) {
        g.setColor (Color.lightGray);
        g.fillRect (lastPoint.x + 20, lastPoint.y, 150, 20);
        g.drawRect (lastPoint.x + 20, lastPoint.y, 150, 20);
        g.setColor (Color.red);
        g.drawString ("点击鼠标拖动,开始截图!", lastPoint.x + 25, lastPoint.y + 15);
    }
    else {
        if (((w) < 0) && ((h) < 0)) {
            head.x = lastPoint.x;
            head.y = lastPoint.y;
        }
        else if (((w) > 0) && ((h) < 0)) {
            head.x = startPoint.x;
            head.y = lastPoint.y;
        }
        else if (((w) < 0) && ((h) > 0)) {
            head.x = lastPoint.x;
            head.y = startPoint.y;
        }
        else if (((w) > 0) && ((h) > 0)) {
            head.x = startPoint.x;
            head.y = startPoint.y;
        }
        selectRect.x = head.x;
        selectRect.y = head.y;
        selectRect.width = width;
        selectRect.height = height;
        g.drawString (" " + width + "*" + height + " ", head.x, head.y - 15);
        g.drawRect (head.x, head.y, width, height);
        g.fillRect (head.x - 1, head.y - 1, 3, 3);
        g.fillRect (head.x - 1, head.y + height - 1, 3, 3);
        g.fillRect (head.x - 1, head.y + height / 2 - 1, 3, 3);
        g.fillRect (head.x + width - 1, head.y - 1, 3, 3);
        g.fillRect (head.x + width / 2 - 1, head.y - 1, 3, 3);
        g.fillRect (head.x + width - 1, head.y + height - 1, 3, 3);
        g.fillRect (head.x + width - 1, head.y + height / 2 - 1, 3, 3);
        g.fillRect (head.x + width / 2 - 1, head.y + height - 1, 3, 3);
        rec [0].x = head.x - 5;
        rec [0].y = head.y - 5;
        rec [1].x = head.x + width / 2 - 5;
        rec [1].y = head.y - 5;
        rec [2].x = head.x + width - 5;
        rec [2].y = head.y - 5;
        rec [3].x = head.x + width - 5;
        rec [3].y = head.y + height / 2 - 5;
        rec [4].x = head.x + width - 5;
        rec [4].y = head.y + height - 5;
        rec [5].x = head.x + width / 2 - 5;
        rec [5].y = head.y + height - 5;
        rec [6].x = head.x - 5;
        rec [6].y = head.y + height - 5;
        rec [7].x = head.x - 5;
        rec [7].y = head.y + height / 2 - 5;
        for (int i = 0; i < rec.length; i ++) {
            rec [i].height = 10;
            rec [i].width = 10;
        }
    }
}


public static String takeAPictureToWebPageAndSaveIt (String absolutePath, String picd, String browser, int wait) {
    try {
        Process p = Runtime.getRuntime ().exec (browser + " " + absolutePath);
        Thread.sleep (wait);
        Robot robot = new Robot ();
        BufferedImage image = robot.createScreenCapture (new Rectangle (Toolkit.getDefaultToolkit ().getScreenSize ()));
        String imagefile = "img" + ORDER ++ + ".gif";
        ImageIO.write (image, "gif", new File (picd + "/" + imagefile));
        p.destroy ();
        return imagefile;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return "false.gif";
}


-----Function Pair=292=-----==

public void actionPerformed (ActionEvent e) {
    try {
        System.out.println ("Creating desktop.jpg");
        ScreenImage.createDesktopImage ("desktop.jpg");
        System.out.println ("Creating frame.jpg");
        ScreenImage.createImage (frame, "frame.jpg");
        System.out.println ("Creating scrollpane.jpg");
        ScreenImage.createImage (scrollPane, "scrollpane.jpg");
        System.out.println ("Creating textarea.jpg");
        ScreenImage.createImage (textArea, "textarea.jpg");
        System.out.println ("Creating button.jpg");
        ScreenImage.createImage (button, "button.jpg");
        button.setText ("button refreshed");
        button.paintImmediately (button.getBounds ());
        System.out.println ("Creating refresh.jpg");
        ScreenImage.createImage (button, "refresh.jpg");
        System.out.println ("Creating region.jpg");
        Rectangle r = new Rectangle (0, 0, 100, 16);
        ScreenImage.createImage (textArea, r, "region.png");
    } catch (Exception exc) {
        System.out.println (exc);
    }
}


protected void openFile () {
    my_chooser = new JFileChooser (".");
    SimpleFilter filter = new SimpleFilter ("png", "PNG Image Files");
    my_chooser.setFileFilter (filter);
    if (my_chooser.showOpenDialog (this) != JFileChooser.APPROVE_OPTION) return;
    final File fChoosen = my_chooser.getSelectedFile ();
    if (fChoosen == null || ! fChoosen.exists ()) return;
    if (this.offScreenGraphics != null) this.offScreenGraphics.dispose ();
    setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
    Thread runner = new Thread () {
        public void run () {
            try {
                if (fChoosen.toString ().endsWith ("jpg") || fChoosen.toString ().endsWith ("JPG") || fChoosen.toString ().endsWith ("jpeg") || fChoosen.toString ().endsWith ("JPEG")) {
                    FileInputStream in = new FileInputStream (fChoosen);
                    JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder (in);
                    open_img = decoder.decodeAsBufferedImage ();
                    in.close ();
                }
                else if (fChoosen.toString ().endsWith ("png") || fChoosen.toString ().endsWith ("PNG")) {
                    openimgFile = true;
                    open_img = ImageIO.read (fChoosen);
                    repaint ();
                }
            } catch (Exception ex) {
                ex.printStackTrace ();
                System.err.println ("openFile: " + ex.toString ());
            }
            setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));
        }
    }
    ;
    runner.start ();
}


-----Function Pair=293=-----==

public void runDialog () {
    final List throwables = new ArrayList ();
    final TestDialogThread th = new TestDialogThread (_title + " TestDialogThread") {
        public void run () {
            try {
                Robot.delay (1000);
                waitForInvokeDialogFailureOrShellShowing (_title, this);
                if (! _invokeDialogFailed) {
                    waitForDialogShowing ();
                    testDialog ();
                }
            } catch (Throwable t) {
                Log.log (t);
                throwables.add (t);
            } finally {
                _done = true;
            }
        }
    }
    ;
    th.start ();
    try {
        invokeDialog ();
    } catch (Throwable t) {
        Log.log (t);
        th.setInvokeFailed ();
        AssertionError ae = new AssertionError ("Failed to invoke Dialog: " + _title);
        ae.initCause (t);
        throw ae;
    }
    try {
        Robot.wait (new Condition () {
            public boolean test () {
                return _done;
            } public String toString () {
                return _title + " did not complete its doTestDialog() method within " + _timeoutMinutes + " minutes.";
            }
        }
        , _timeoutMinutes * 60000, 1000);
    } catch (Throwable t) {
        Log.log (t);
        throwables.add (t);
        attemptCloseDialog (throwables);
    } finally {
        if (! throwables.isEmpty ()) {
            AssertionError ae = new AssertionError ("Failed while testing dialog: " + _title);
            ae.initCause (ExceptionHelper.chainThrowables (throwables));
            throw ae;
        }
    }
}


private int [] calculate2DMapSizeAndScreenLoc (J2DEarthPanel twoDmapPanel) {
    Point pt = twoDmapPanel.getLocationOnScreen ();
    int width = twoDmapPanel.getWidth ();
    int height = twoDmapPanel.getHeight ();
    double aspectRatio = 2.0;
    int newWidth = 1, newHeight = 1;
    if (height != 0) {
        if (width / height > aspectRatio) {
            newHeight = height;
            newWidth = (int) (height * aspectRatio);
        }
        else {
            newWidth = width;
            newHeight = (int) (width * 1.0 / aspectRatio);
        }
        int deltaW = width - newWidth;
        int deltaH = height - newHeight;
        pt.y = pt.y + (int) (deltaH / 2.0);
        pt.x = pt.x + (int) (deltaW / 2.0);
        width = newWidth;
        height = newHeight;
    }
    return new int [] {width, height, pt.x, pt.y};
}


-----Function Pair=294=-----==

public ProgressDialog (Shell parent, int style) {
    shell = new Shell (parent, SWT.BORDER | SWT.TITLE | SWT.APPLICATION_MODAL);
    GridLayout gridLayout = new GridLayout ();
    shell.setLayout (gridLayout);
    shell.setText (getResourceString ("progressDialog." + operationKeyName [style] + ".title"));
    shell.addShellListener (new ShellAdapter () {
        public void shellClosed (ShellEvent e) {
            isCancelled = true;
        }
    }
    );
    messageLabel = new Label (shell, SWT.HORIZONTAL);
    messageLabel.setLayoutData (new GridData (GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_FILL));
    messageLabel.setText (getResourceString ("progressDialog." + operationKeyName [style] + ".description"));
    progressBar = new ProgressBar (shell, SWT.HORIZONTAL | SWT.WRAP);
    progressBar.setLayoutData (new GridData (GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_FILL));
    progressBar.setMinimum (0);
    progressBar.setMaximum (0);
    detailLabel = new Label (shell, SWT.HORIZONTAL);
    GridData gridData = new GridData (GridData.FILL_HORIZONTAL | GridData.VERTICAL_ALIGN_BEGINNING);
    gridData.widthHint = 400;
    detailLabel.setLayoutData (gridData);
    cancelButton = new Button (shell, SWT.PUSH);
    cancelButton.setLayoutData (new GridData (GridData.HORIZONTAL_ALIGN_END | GridData.VERTICAL_ALIGN_FILL));
    cancelButton.setText (getResourceString ("progressDialog.cancelButton.text"));
    cancelButton.addSelectionListener (new SelectionAdapter () {
        public void widgetSelected (SelectionEvent e) {
            isCancelled = true;
            cancelButton.setEnabled (false);
        }
    }
    );
}


private int YExpansion (Component current, int cavityHeight) {
    PackRecord pr = (PackRecord) component_table.get (current);
    int numExpand, minExpand, curExpand;
    int childHeight;
    minExpand = cavityHeight;
    numExpand = 0;
    for (; current != null; current = pr.next) {
        pr = (PackRecord) component_table.get (current);
        childHeight = current.getPreferredSize ().height + (pr.pady * 2) + pr.ipady;
        if (pr.side == SIDE_OBJ_LEFT || pr.side == SIDE_OBJ_RIGHT) {
            curExpand = (cavityHeight - childHeight) / numExpand;
            if (curExpand < minExpand) minExpand = curExpand;
        }
        else {
            cavityHeight -= childHeight;
            if (pr.expand == EXPAND_OBJ_TRUE) {
                numExpand ++;
            }
        }
    }
    curExpand = cavityHeight / numExpand;
    if (curExpand < minExpand) minExpand = curExpand;
    if (minExpand < 0) return 0;
    else return minExpand;
}


-----Function Pair=295=-----==

private static boolean generateFile (File root) {
    String name = generateName ();
    File file = new File (root, name);
    OutputStream out = null;
    try {
        out = new FileOutputStream (file);
        int fileSize = random.nextInt (maxFileSize);
        byte [] buf = new byte [fileSize];
        random.nextBytes (buf);
        out.write (buf);
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        return false;
    }
    return true;
}


public ElectronCloud nudgeToLowerEnergy () {
    for (int i = 0; i < numPlayers; ++ i) {
        SectorCoords sectorCoords = playerCoords [i];
        double startEnergy = getEnergy (i, sectorCoords);
        for (SectorCoords neighbour : sectorCoords.getNeighbours (size, 1)) {
            if (alreadyExists (i, neighbour)) {
                continue;
            }
            double newEnergy = getEnergy (i, neighbour);
            if (newEnergy < startEnergy) {
                ElectronCloud nudged = this.clone ();
                nudged.setPlayerCoord (i, neighbour);
                return nudged;
            }
        }
    }
    return null;
}


-----Function Pair=296=-----==

public static < T > void shuffle3 (T [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        T tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public static void BubbleSortLong1 (long [] num) {
    boolean flag = true;
    long temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=297=-----==

public static < T > void shuffle3 (T [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        T tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public Float Mul (Float value) {
    if (value.Equal (ZERO) || this.Equal (ZERO)) return new Float (ZERO);
    if (value.Equal (ONE)) return new Float (this);
    boolean negative1 = (m_Val < 0);
    if (negative1) m_Val = - m_Val;
    boolean negative2 = (value.m_Val < 0);
    if (negative2) value.m_Val = - value.m_Val;
    do {
        if (value.m_Val > m_Val) {
            if (Long.MAX_VALUE / m_Val < value.m_Val) {
                value.m_Val /= 10;
                value.m_E ++;
            }
            else break;
        }
        else {
            if (Long.MAX_VALUE / value.m_Val < m_Val) {
                m_Val /= 10;
                m_E ++;
            }
            else break;
        }
    }
    while (true);
    if (negative1) m_Val = - m_Val;
    if (negative2) value.m_Val = - value.m_Val;
    long e = m_E + value.m_E;
    long v = m_Val * value.m_Val;
    return new Float (v, e);
}


-----Function Pair=298=-----==

public void createUser (String newUser, String description, boolean isAdmin) throws XregistryException {
    Connection connection = context.createConnection ();
    try {
        PreparedStatement statement = connection.prepareStatement (ADD_USER_SQL);
        statement.setString (1, Utils.canonicalizeDN (newUser));
        statement.setString (2, description);
        statement.setBoolean (3, isAdmin);
        statement.executeUpdate ();
        log.info ("User " + newUser + " created");
        users.put (newUser, new User (newUser));
    } catch (SQLException e) {
        throw new XregistryException (e);
    } finally {
        context.closeConnection (connection);
    }
}


public List < Forums > getForumsList (List < Short > fidList) {
    Session session = null;
    Transaction tran = null;
    Forums forum = null;
    List < Forums > list = new ArrayList < Forums > ();
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tran = session.beginTransaction ();
        for (int i = 0; i < fidList.size (); i ++) {
            forum = (Forums) session.get (Forums.class, fidList.get (i));
            if (forum != null) {
                list.add (forum);
            }
            else {
                try {
                    throw new Exception ("û�л��ID��ָ����Forumsʵ��");
                } catch (Exception exception) {
                    exception.printStackTrace ();
                }
            }
        }
        tran.commit ();
    } catch (HibernateException e) {
        if (tran != null) {
            tran.rollback ();
        }
        e.printStackTrace ();
    }
    return list;
}


-----Function Pair=299=-----==

public String [] listUsers () throws XregistryException {
    Connection connection = context.createConnection ();
    ArrayList < String > users = new ArrayList < String > ();
    try {
        Statement statement = connection.createStatement ();
        ResultSet results = statement.executeQuery (SQLConstants.GET_ALL_USERS_SQL);
        while (results.next ()) {
            String userID = results.getString (USERID);
            users.add (userID);
        }
    } catch (SQLException e) {
        throw new XregistryException (e);
    } finally {
        context.closeConnection (connection);
    }
    return Utils.toStrListToArray (users);
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=300=-----==

public static boolean doExecuteBatchSQL (List < String > sql) {
    session = currentSession ();
    Connection conn = session.connection ();
    PreparedStatement ps = null;
    try {
        conn.setAutoCommit (false);
        Iterator iter = sql.iterator ();
        while (iter.hasNext ()) {
            String sqlstr = (String) iter.next ();
            log ("[SmsManager] doing sql:" + sqlstr);
            ps = conn.prepareStatement (sqlstr);
            ps.executeUpdate ();
        }
        conn.commit ();
        conn.setAutoCommit (true);
        return true;
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
        return false;
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
        if (ps != null) {
            try {
                ps.close ();
            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
        closeHibernateSession ();
    }
}


public boolean findByFindPorperty (Words words) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Words as w where w.find like :find");
        query.setString ("find", words.getFind ());
        List list = query.list ();
        tr.commit ();
        if (list.size () > 0) {
            return true;
        }
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
            tr = null;
        }
        he.printStackTrace ();
    }
    return false;
}


-----Function Pair=301=-----==

private void delete (Connection conn, int itemId) throws SQLException {
    Statement statement = null;
    try {
        conn.setAutoCommit (false);
        deleteComponents (conn, itemId);
        statement = conn.createStatement ();
        StringBuffer sqlBuff = new StringBuffer ("DELETE FROM ");
        sqlBuff.append (m_dbItemName);
        sqlBuff.append (" WHERE ");
        sqlBuff.append (m_dbItemIdFieldColName);
        sqlBuff.append (" = ");
        sqlBuff.append (Integer.toString (itemId));
        String sql = sqlBuff.toString ();
        statement.executeUpdate (sql);
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
        throw ex;
    } finally {
        if (statement != null) {
            statement.close ();
        }
    }
}


public static void assignRoles (String module_id, String [] roles) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        sql = "DELETE FROM role_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        for (int i = 0; i < roles.length; i ++) {
            sql = "INSERT INTO role_module (module_id, user_role) VALUES ('" + module_id + "', '" + roles [i] + "')";
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=302=-----==

public Map < Integer, Project > readProjects () throws AdaptationException {
    Map < Integer, Project > projects = new HashMap < Integer, Project > ();
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM Projects";
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        while (resultSet.next ()) {
            Project project = getProject (resultSet);
            projects.put (project.getID (), project);
        }
    } catch (SQLException ex) {
        String msg = "SQLException in readProjects";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return projects;
}


protected E query (String sql, Object [] args) {
    E entity = null;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        conn = JdbcUtils.getConnection ();
        pstmt = conn.prepareStatement (sql);
        this.setParameters (pstmt, args);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            entity = mapping (rs);
        }
    } catch (SQLException e) {
        throw new JdbcDaoException (e.getMessage (), e);
    } finally {
        JdbcUtils.free (rs, pstmt, conn);
    }
    return entity;
}


-----Function Pair=303=-----==

public void deleteProject (String id) throws Exception {
    String tmp = "";
    PreparedStatement prepStmt = null;
    try {
        if (id == null || id.length () == 0) throw new Exception ("Invalid parameter");
        con = database.getConnection ();
        prepStmt = con.prepareStatement ("update proposal set PROJECT_ID=" + UNKNOWN_ID + " where PROJECT_ID=" + id + "and proposal_id=" + this.getProposalId ());
        prepStmt.executeUpdate ();
        String delType = "delete from project where PROJECT_ID=" + id;
        prepStmt = con.prepareStatement (delType);
        prepStmt.executeUpdate ();
        prepStmt.close ();
        con.close ();
    } catch (Exception e) {
        try {
            if (! con.isClosed ()) {
                prepStmt.close ();
                con.close ();
            }
        } catch (Exception ex) {
        }
    }
}


public RestServiceResult createPublicationComment (RestServiceResult serviceResult, String sPublicationId, ToComment toComment) {
    try {
        Query query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_PUBLICATION_COMMENT);
        query.setParameter (1, toComment.getCommentId ());
        query.setParameter (2, new Long (sPublicationId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {toComment.getCommentId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.create.success"), arrayParam));
    } catch (PersistenceException e) {
        e.printStackTrace ();
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la asociaci�n - Publicacion - Material: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.create.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


-----Function Pair=304=-----==

private String findTerm (String column, String value, String namespaceId, Element asd) throws SQLException {
    String statement = getDAO ().getStatement (TABLE_KEY, "FIND_BY_" + column.toUpperCase ());
    statement = getDAO ().getStatement (statement, 1, "'" + value + "'");
    Statement stmt = null;
    ResultSet rs = null;
    try {
        stmt = conn.createStatement ();
        rs = stmt.executeQuery (statement + namespaceId);
        String response = findTerms (rs, asd);
        rs.close ();
        return response;
    } catch (Exception e) {
        throw new SQLException (e.getMessage ());
    } finally {
        if (rs != null) rs.close ();
        if (stmt != null) stmt.close ();
    }
}


public void testStaleNonVersionedInstanceFoundInQueryResult () {
    if (getDialect ().doesReadCommittedCauseWritersToBlockReaders ()) {
        reportSkip ("lock blocking", "stale versioned instance");
        return;
    }
    String check = "Lock Modes";
    Session s1 = getSessions ().openSession ();
    Transaction t1 = s1.beginTransaction ();
    Part part = new Part (new Item ("EJB3 Specification"), check, "3.3.5.3", new BigDecimal (0.0));
    s1.save (part);
    t1.commit ();
    s1.close ();
    Long partId = part.getId ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    part = (Part) s1.get (Part.class, partId);
    Session s2 = getSessions ().openSession ();
    Transaction t2 = s2.beginTransaction ();
    Part part2 = (Part) s2.get (Part.class, partId);
    part2.setName ("Lock Mode Types");
    t2.commit ();
    s2.close ();
    part2 = (Part) s1.createQuery ("select p from Part p").list ().get (0);
    assertTrue (part == part2);
    assertEquals ("encountered non-repeatable read", check, part2.getName ());
    t1.commit ();
    s1.close ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    s1.delete (part2);
    s1.delete (part2.getItem ());
    t1.commit ();
    s1.close ();
}


-----Function Pair=305=-----==

public void testDatetimeRounding5 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 994);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 993);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr5 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr5 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr5");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public boolean setRecipeToTimetable (int recipeId, Timestamp time, int meal) {
    System.out.println ("setRecipeToTimetable");
    PreparedStatement statement = null;
    StringBuffer query = new StringBuffer ("insert into timetable (recipe_id, time, meal) values (?,?,?)");
    try {
        conn = getConnection ();
        statement = conn.prepareStatement (query.toString ());
        statement.setInt (1, recipeId);
        statement.setTimestamp (2, time);
        statement.setInt (3, meal);
        statement.executeUpdate ();
        conn.commit ();
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (Exception ex) {
        }
        MainFrame.appendStatusText ("Error when trying to execute sql: " + e.getMessage ());
    } finally {
        try {
            if (statement != null) statement.close ();
            statement = null;
        } catch (Exception ex) {
            MainFrame.appendStatusText ("Can't close database connection.");
        }
    }
    return true;
}


-----Function Pair=306=-----==

public List < Threads > findThreadsByHql (String hql, int start, int maxrow) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery (hql);
        query.setFirstResult (start);
        query.setMaxResults (maxrow);
        List < Threads > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public boolean addUser (Usuario user) {
    Connection conexion = null;
    boolean exito = false;
    PreparedStatement insert = null;
    try {
        conexion = pool.getConnection ();
        insert = conexion.prepareStatement ("INSERT INTO " + nameBD + ".Usuarios VALUES (?,?,?,?,?)");
        insert.setString (1, user.getMail ());
        insert.setString (2, user.getNombre ());
        insert.setString (3, user.getDir ());
        insert.setString (4, user.getPass ());
        insert.setObject (5, user.getPermisos (), java.sql.Types.CHAR, 1);
        int filasAfectadas = insert.executeUpdate ();
        if (filasAfectadas == 1) {
            exito = true;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error insertando usuario", ex);
    } finally {
        cerrarConexionYStatement (conexion, insert);
    }
    return exito;
}


-----Function Pair=307=-----==

public void testEra () throws SQLException {
    Statement st = con.createStatement ();
    st.execute ("create table #testEra(data datetime)");
    st.close ();
    String date = "2000-11-11";
    Date original = Date.valueOf (date);
    PreparedStatement in = con.prepareStatement ("insert into #testEra values(?)");
    PreparedStatement out = con.prepareStatement ("select * from #testEra");
    ResultSet rs = null;
    in.setDate (1, Date.valueOf (date));
    in.execute ();
    rs = out.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (original, rs.getDate (1));
    rs.close ();
    try {
        GregorianCalendar gc = new GregorianCalendar ();
        gc.set (GregorianCalendar.ERA, GregorianCalendar.BC);
        gc.set (GregorianCalendar.YEAR, 300);
        gc.set (GregorianCalendar.MONTH, GregorianCalendar.JANUARY);
        gc.set (GregorianCalendar.DAY_OF_MONTH, 1);
        in.setDate (1, new Date (gc.getTime ().getTime ()));
        assertTrue ("invalid date should cause an exception", false);
    } catch (SQLException e) {
    }
    rs = out.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (original, rs.getDate (1));
    rs.close ();
    in.close ();
    out.close ();
}


public String getInsertOrderString () {
    List < String > tMyTable = getAllTables ();
    if (tMyTable.size () == 0) return StringUtil.EMPTY;
    StringBuffer tOutput = new StringBuffer ();
    String tTableName = tMyTable.get (0);
    String tNextTable = null;
    boolean isCanInsert = true;
    while (! tMyTable.isEmpty ()) {
        List < String > tRefTable = getRefTable (tTableName);
        isCanInsert = true;
        for (String s : tRefTable) {
            if (! s.equals (tTableName)) {
                tNextTable = s;
                if (tMyTable.contains (tNextTable)) {
                    tTableName = tNextTable;
                    isCanInsert = false;
                    break;
                }
            }
        }
        if (isCanInsert) {
            if (tMyTable.remove (tTableName)) {
                tOutput.append (tTableName).append (";");
            }
            if (tMyTable.size () > 0) {
                tTableName = tMyTable.get (0);
            }
        }
    }
    return tOutput.toString ();
}


-----Function Pair=308=-----==

private static final String getHistorySortInfo (String rawInfo) {
    String defaultSortOrder = "finish DESC";
    String sortOrder = null;
    if (rawInfo != null && rawInfo.length () > 0) {
        sortOrder = "";
        String [] cols = rawInfo.split (";");
        for (String c : cols) {
            boolean validCol = true;
            String [] colInfo = c.split (":");
            if (colInfo [1].equals ("2")) sortOrder = sortOrder.concat ("type");
            else if (colInfo [1].equals ("3")) sortOrder = sortOrder.concat ("start");
            else if (colInfo [1].equals ("4")) sortOrder = sortOrder.concat ("finish");
            else if (colInfo [1].equals ("5")) sortOrder = sortOrder.concat ("host");
            else validCol = false;
            if (validCol) {
                if (colInfo [0].equals ("a")) sortOrder = sortOrder.concat (" ASC,");
                else sortOrder = sortOrder.concat (" DESC,");
            }
        }
    }
    if (sortOrder != null && sortOrder.length () > 0) return sortOrder.substring (0, sortOrder.length () - 1);
    return defaultSortOrder;
}


public List < RoleBean > getRoleList (AuthSession authSession) {
    DatabaseAdapter db = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        db = DatabaseAdapter.getInstance ();
        ps = db.prepareStatement ("select  ID_ACCESS_GROUP, NAME_ACCESS_GROUP " + "from    WM_AUTH_ACCESS_GROUP ");
        rs = ps.executeQuery ();
        return internalGetRoleList (rs);
    } catch (Exception e) {
        String es = "error";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


-----Function Pair=309=-----==

public String hasPermission (Element root, DTSPermission permit) throws SQLException, XMLException {
    if (permit == null) {
        return getTrueResult ();
    }
    String accessType = permit.getAccessType ();
    if (accessType.equals (DTSUsers.WRITE_ACCESS_TYPE)) {
        String namespaceId = root.getAttribute (ID);
        Vector stored_namespace_ids = permit.getNamespaceIds ();
        boolean isPermitted = stored_namespace_ids.contains (namespaceId);
        if (isPermitted) {
            return getTrueResult ();
        }
    }
    return getFalseResult ();
}


public Serializable load (String oid, String key) throws PersisterException {
    String lock = getLock (oid);
    if (lock == null) {
        throw new PersisterException ("Object does not exist: OID = " + oid);
    }
    else if (! NULL.equals (lock) && (! lock.equals (key))) {
        throw new PersisterException ("The object is currently locked with another key: OID = " + oid + ", LOCK = " + lock + ", KEY = " + key);
    }
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    Serializable obj = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("select " + _data_col + " from " + _table_name + " where " + _oid_col + " = ?");
        ps.setString (1, oid);
        rs = ps.executeQuery ();
        if (rs.next ()) {
            obj = deserialize (rs.getBinaryStream (_data_col));
            if (rs.wasNull ()) {
                obj = null;
            }
        }
    } catch (Throwable th) {
        throw new PersisterException ("Failed read lock key for object: OID = " + oid, th);
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (Throwable th) {
            }
        }
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
    if (obj == null) {
        throw new PersisterException ("Object has been deleted: OID = " + oid);
    }
    return obj;
}


-----Function Pair=310=-----==

public Subset [] getConceptSubsets (int conceptId, int namespaceId) throws SQLException, IOException {
    ArrayList list = new ArrayList ();
    if (this.getConceptSubsetPs == null) {
        String getConSubsStmt = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_CONCEPT_SUBSETS);
        this.getConceptSubsetPs = this.conn.prepareStatement (getConSubsStmt);
    }
    getConceptSubsetPs.setInt (1, conceptId);
    getConceptSubsetPs.setInt (2, namespaceId);
    ResultSet rs = this.getConceptSubsetPs.executeQuery ();
    while (rs.next ()) {
        int subset_id = rs.getInt (1);
        String name = rs.getString (2);
        Subset si = new Subset ();
        si.setId (subset_id);
        si.setName (name);
        list.add (si);
    }
    rs.close ();
    Subset [] array = new Subset [list.size ()];
    list.toArray (array);
    return array;
}


private void getDefiningConcepts (Concept con, long conceptGID, int localNamespaceId, PreparedStatement defineConceptStmt) throws SQLException {
    defineConceptStmt.setLong (1, conceptGID);
    ResultSet rs = null;
    boolean isRoot = true;
    try {
        rs = defineConceptStmt.executeQuery ();
        ArrayList defConList = new ArrayList ();
        while (rs.next ()) {
            isRoot = false;
            int definingNamespaceId = rs.getInt (3);
            String conceptRefBy = rs.getString (2);
            long defConceptGID = rs.getLong (1);
            gidMap.put (conceptRefBy, new Long (defConceptGID));
            ConceptRef ref = ConceptRef.Factory.newInstance ();
            ref.setIdentifier (conceptRefBy);
            ref.setNamespaceId (String.valueOf (definingNamespaceId));
            defConList.add (ref);
        }
        if (defConList.size () > 0) {
            con.setDefinedParentArray ((ConceptRef []) defConList.toArray (new ConceptRef [0]));
        }
        if (isRoot) {
            throw new SQLException ("No defining Super Concepts");
        }
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
}


-----Function Pair=311=-----==

public boolean delete (Long personId) {
    int affectedRows = 0;
    String sql = "delete from PERSONS where PERSON_ID = ?";
    if (true) {
        System.out.println (sql);
    }
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = ConnHelper.getConnectionByDriverManager ();
        pstmt = conn.prepareStatement (sql);
        pstmt.setLong (1, personId);
        affectedRows = pstmt.executeUpdate ();
        System.out.printf ("affectedRows = %d%n%n", affectedRows);
    } catch (Exception e) {
        e.printStackTrace (System.out);
    } finally {
        ConnHelper.close (conn, pstmt, null);
    }
    return affectedRows > 0;
}


public Connection getRepositoryConnection (boApplication app, String reposiToryName, int type) {
    String repositoryNameLower = reposiToryName.toLowerCase ();
    Connection ret = (Connection) p_connectionCache.get (repositoryNameLower + "[" + type + "]");
    try {
        if (ret == null || ret.isClosed ()) {
            if (type == 1) {
                ret = boRepository.getRepository (app, repositoryNameLower).getDedicatedConnection ();
            }
            else if (type == 2) {
                ret = boRepository.getRepository (app, repositoryNameLower).getDedicatedConnectionDef ();
            }
            p_connectionCache.put (repositoryNameLower + "[" + type + "]", ret);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return ret;
}


-----Function Pair=312=-----==

public void atualizar (Object entidade) {
    EntityManager em = EMUtil.getEntityManager ();
    EntityTransaction tx = null;
    try {
        tx = em.getTransaction ();
        tx.begin ();
        em.merge (entidade);
        tx.commit ();
    } catch (Exception e) {
        if (tx != null && tx.isActive ()) tx.rollback ();
        e.printStackTrace ();
    } finally {
        em.close ();
    }
}


private void publishToRestHosts (Message message) {
    if (message.getTargetHost () != null) {
        Set < Entry < Registry, String > > map = registryMap.entrySet ();
        for (Entry < Registry, String > entry : map) {
            if (message.getTargetHost ().equals (entry.getValue ())) {
                publish (message, entry.getKey ());
                break;
            }
        }
    }
    else {
        lock.lock ();
        if (registries != null && registries.size () > 0) {
            Set < Entry < Registry, String > > map = registryMap.entrySet ();
            for (Entry < Registry, String > entry : map) {
                if (! entry.getValue ().equals (message.getFromHost ())) {
                    publish (message, entry.getKey ());
                }
            }
        }
        if (offlineServers != null && offlineServers.size () > 0) {
            for (String server : offlineServers) {
                if (! server.equals (message.getFromHost ())) saveMessage (server, message);
            }
        }
        lock.unlock ();
    }
}


-----Function Pair=313=-----==

public Website load (int id) {
    Website website = null;
    Connection conn = null;
    try {
        conn = db.getConnection ();
        String sql1 = "SELECT url, name, description FROM websites WHERE id=?";
        PreparedStatement ps1 = conn.prepareStatement (sql1);
        ps1.setInt (1, id);
        ResultSet rs1 = ps1.executeQuery ();
        if (rs1.next ()) {
            String url = rs1.getString ("url");
            String name = rs1.getString ("name");
            String description = rs1.getString ("description");
            String sql2 = "SELECT id, keyphrase FROM keyphrases WHERE website_id=? ORDER BY id";
            PreparedStatement ps2 = conn.prepareStatement (sql2);
            ps2.setInt (1, id);
            ResultSet rs2 = ps2.executeQuery ();
            List < Keyphrase > keyphrases = new ArrayList < Keyphrase > ();
            while (rs2.next ()) {
                keyphrases.add (new Keyphrase (rs2.getInt ("id"), id, rs2.getString ("keyphrase")));
            }
            website = new Website (id, url, name, description, keyphrases);
            rs2.close ();
            ps2.close ();
        }
        rs1.close ();
        ps1.close ();
    } catch (SQLException ex) {
        throw new OsseoFailure ("SQL error: cannot read website with id " + id + ".", ex);
    } finally {
        db.putConnection (conn);
    }
    return website;
}


public Vector getFlightDialogTableData (int currentPilot) throws SQLException {
    Object data [] = null;
    Statement stmt;
    ResultSet rs = null;
    int columnCount;
    int y = 0;
    String s = "";
    Vector rows = null, row = null;
    try {
        String sQuery = "select nr, dato, flytype.navn, " + "svaevetid, distance, airfield1.name, airfield2.name, flyvning.id " + "from flyvning, flytype, airfield as airfield1, airfield as airfield2  " + "where flytype.id = flytype_id " + "and pilot_id = " + currentPilot + " " + "and airfield1.id = startsted_id " + "and airfield2.id = landingssted_id " + "order by nr";
        stmt = conn.getStatement ();
        rs = stmt.executeQuery (sQuery);
        columnCount = rs.getMetaData ().getColumnCount ();
        rows = new Vector (200);
        if (! rs.next ()) {
            log.info ("Oops, no rows selected in flyvning, creating fake");
            row = new Vector (8);
            row.addElement (new Integer (0));
            row.addElement (Calendar.getInstance ().getTime ());
            row.addElement (s);
            row.addElement (new Integer (0));
            row.addElement (new Integer (0));
            row.addElement (s);
            row.addElement (s);
            row.addElement (new Integer (0));
            rows.addElement (row);
        }
        else {
            do {
                row = new Vector (columnCount);
                for (y = 0; y < columnCount; y ++) {
                    row.addElement (rs.getObject (y + 1));
                    if (row.get (y) == null) {
                        row.set (y, s);
                    }
                }
                row.set (1, new java.util.Date (rs.getLong (2)));
                rows.addElement (row);
            }
            while (rs.next ());
        }
    } catch (SQLException sqle) {
        log.debug (sqle);
        throw sqle;
    }
    if (rs != null) rs.close ();
    if (stmt != null) stmt.close ();
    return rows;
}


-----Function Pair=314=-----==

public Object execute () throws Exception {
    Session session = HibernateUtil.getNewSession ();
    session.setFlushMode (org.hibernate.FlushMode.NEVER);
    session.beginTransaction ();
    try {
        IBaseModel model = get (modelClass, id, session, call);
        session.clear ();
        return model;
    } catch (Exception ex) {
        Log.exception (ex);
        session.getTransaction ().rollback ();
        throw ex;
    } finally {
        session.close ();
    }
}


public boolean deleteHoliday (int vactionId) {
    boolean flag = false;
    Session session = HibernateUtil.getSessionFactory ().openSession ();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction ();
        Holidays holiday = (Holidays) session.get (Holidays.class, vactionId);
        session.delete (holiday);
        transaction.commit ();
        flag = true;
        session.close ();
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return flag;
}


-----Function Pair=315=-----==

public LocalFileState storeArchived (LocalFileState in) throws Exception {
    if (trialRun) return in;
    if (in == null) return null;
    synchronized (lock) {
        switch (in.state) {
            case RUNNING :
            case READY :
            case SUCCESS :
                in.state = FileStates.SUCCESS_ARCHIVED;
                break;
            case IGNORED :
                in.state = FileStates.IGNORED_ARCHIVED;
                break;
            case SUPERCEDED :
                in.state = FileStates.SUPERCEDED_ARCHIVED;
                break;
            case DUPLICATE :
                in.state = FileStates.DUPLICATE_ARCHIVED;
                break;
            case FAILURE :
                in.state = FileStates.FAILURE_ARCHIVED;
                break;
            default :
                return in;
        }
        in.to_archive = false;
        in.to_errors_archive = false;
        Db db = getDb ();
        try {
            db.begin ();
            if (in.local_file_state_id == 0) throw new IllegalArgumentException ("Should have database id for " + in.filename);
            ps_update_state.setInt (1, in.state.getId ());
            ps_update_state.setInt (2, in.local_file_state_id);
            int upd = db.executeUpdate (ps_update_state);
            if (upd != 1) {
                _logger.warn ("Error updating file state for " + in.filename);
            }
            updateMetadataInTx (in);
            return in;
        } catch (Exception e) {
            db.rollback ();
            throw e;
        } finally {
            db.commitUnless ();
        }
    }
}


public List < Forums > findExceptFupEqualZero () {
    Session session = null;
    Transaction transaction = null;
    List < Forums > forums = null;
    String hql = "from Forums where fup <> 0";
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        Query query = session.createQuery (hql);
        forums = query.list ();
        transaction.commit ();
    } catch (Exception exception) {
        if (transaction != null) {
            transaction.rollback ();
        }
        exception.printStackTrace ();
    }
    return forums;
}


-----Function Pair=316=-----==

public static int deleteHql (String deleteHql, List < ISParameter > qualifications, ServiceCall call) throws Exception {
    Session session = HibernateUtil.getNewSession ();
    session.setFlushMode (org.hibernate.FlushMode.NEVER);
    session.beginTransaction ();
    try {
        int rows = deleteHql (session, deleteHql, qualifications, call);
        session.clear ();
        return rows;
    } catch (Exception ex) {
        Log.exception (ex);
        session.getTransaction ().rollback ();
        throw ex;
    } finally {
        session.close ();
    }
}


public Boolean isCandidatoAtividade (IUsuario usuario, Atividade atividade) throws SQLException {
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Atividade_has_recurso_humano where usuario_idusuario = " + usuario.getIdUsuario ();
        usuario = null;
        ResultSet rs = stmt.executeQuery (sqlSelect);
        while (rs.next ()) {
            return true;
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return false;
}


-----Function Pair=317=-----==

public static void queryByEnum (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        TypedQuery < Person > query = entityManager.createQuery ("SELECT p FROM Person p WHERE p.homeState = :homestate", Person.class);
        query.setParameter ("homestate", State.CT);
        Collection < Person > collection = query.getResultList ();
        System.out.println ("From State.CT ...");
        for (Person person : collection) {
            System.out.println ("found: " + person);
        }
        query = entityManager.createQuery ("SELECT p FROM Person p WHERE p.income >= :income", Person.class);
        query.setParameter ("income", IncomeGroup.average);
        collection = query.getResultList ();
        System.out.println ("With income of at least average ...");
        for (Person person : collection) {
            System.out.println ("found: " + person);
        }
    } finally {
        entityManager.close ();
    }
}


public Vector getMeasures () {
    PreparedStatement stat = null;
    ResultSet rs = null;
    Vector v = new Vector ();
    try {
        conn = getConnection ();
        stat = conn.prepareStatement ("SELECT name FROM measure");
        rs = stat.executeQuery ();
        while (rs.next ()) {
            System.out.println ("getMeasures -- Mittayksikk�: " + rs.getString (1));
            v.add (rs.getString (1));
        }
    } catch (Exception e) {
        MainFrame.appendStatusText ("Can't get measures, the exception was " + e.getMessage ());
    } finally {
        try {
            if (rs != null) rs.close ();
            rs = null;
            if (stat != null) stat.close ();
            stat = null;
        } catch (Exception ex) {
            MainFrame.appendStatusText ("Can't close database connection.");
        }
    }
    return v;
}


-----Function Pair=318=-----==

public Vector getChild (Connection con) throws Exception {
    Vector allChildOrg = new Vector ();
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT ot.organize_id,ot.organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_TABLE + " ot, " + Common.ORGANIZE_RELATION_TABLE + " ort " + "WHERE ot.organize_id = ort.child_id " + "AND ot.organize_type_id=ort.child_type_id " + "AND ort.organize_id = '" + this.organizeID + "' " + "AND ort.organize_type_id = '" + this.organizeTypeID + "' ";
    try {
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        int i = 1;
        ValueAsc va = new ValueAsc (i);
        while (result.next ()) {
            i = 1;
            va.setStart (i);
            Organize oTemp = Organize.generateOrganize (result, va);
            allChildOrg.addElement (oTemp);
        }
        va = null;
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.getParent(): SQLException while getting inferior organize " + "where child organize_id = " + this.organizeID + " :\n\t" + se);
    } finally {
        closeResultSet (result);
        closePreparedStatement (ps);
    }
    return allChildOrg;
}


private static void shuffle (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        Person person1 = collection.iterator ().next ();
        Person person2 = new Person ();
        person2.setFirstName ("William");
        person2.setLastName ("Bush");
        Address address = person1.getAddresses ().iterator ().next ();
        person1.getAddresses ().remove (address);
        entityManager.flush ();
        person2.getAddresses ().add (address);
        entityManager.persist (person2);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=319=-----==

public Ranks findRanksById (short rankId) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Ranks rank = (Ranks) session.get (Ranks.class, rankId);
        tr.commit ();
        return rank;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public int update (BusinessObject o) throws DAOException {
    int update = 0;
    Currency curr = (Currency) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("UPDATE_CURRENCY"));
        pst.setString (1, curr.getName ());
        pst.setInt (2, curr.getIdBase ());
        pst.setDouble (3, curr.getValue ());
        pst.setInt (4, curr.getId ());
        update = pst.executeUpdate ();
        if (update <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (update > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return update;
}


-----Function Pair=320=-----==

private void gantiBeratItem () {
    if (! transaksiTable.getValueAt (transaksiTable.getSelectedRow (), 0).toString ().isEmpty ()) {
        try {
            Double beratlama = null;
            Double beratbaru = null;
            Integer nomor;
            Integer menu;
            Date tanggal;
            String input;
            tanggal = dateDisplay.parse (tanggalField.getText ());
            nomor = Integer.valueOf (invoiceField.getText ());
            menu = Integer.valueOf (transaksiTable.getValueAt (transaksiTable.getSelectedRow (), 0).toString ());
            beratlama = cfg.getBeratItem (tanggal, nomor, menu);
            input = JOptionPane.showInputDialog (null, "Total berat item", floatDisplay.format (beratlama));
            if ((input != null) && ! input.isEmpty ()) {
                beratbaru = Double.valueOf (input);
            }
            if ((beratlama != beratbaru) && (beratbaru != null)) {
                updateBerat (nomor, tanggal, menu, beratbaru);
                openTransaksiForm (nomor, tanggal);
            }
        } catch (ParseException ex) {
            ex.printStackTrace ();
            Logger.getLogger (TransaksiView.class.getName ()).log (Level.SEVERE, null, ex);
        } catch (NumberFormatException ex) {
            ex.printStackTrace ();
            JOptionPane.showMessageDialog (null, "Harap masukan berat item!");
        }
    }
}


public void testProjectionOfManyToOneField () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Farm farm1 = new Farm ("High Farm");
        Farm farm2 = new Farm ("Low Farm");
        Animal a1 = new Animal ("Dog");
        Animal a2 = new Animal ("Sheep");
        Animal a3 = new Animal ("Cow");
        farm1.getAnimals ().add (a1);
        farm1.getAnimals ().add (a2);
        farm2.getAnimals ().add (a3);
        em.persist (farm1);
        em.persist (farm2);
        em.flush ();
        List results = em.createQuery ("SELECT a.farm FROM " + Animal.class.getName () + " a ", Farm.class).getResultList ();
        assertEquals (3, results.size ());
        Object result = results.get (0);
        assertNotNull (result);
        assertTrue ("Result is of incorrect type", result instanceof Farm);
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=321=-----==

protected boolean update (String sql, int requiredRows, int maxRows) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("executing " + sql + "...");
    }
    Connection connection = null;
    boolean oldAutoCommit = true;
    try {
        connection = dataSource.getConnection ();
        connection.clearWarnings ();
        oldAutoCommit = connection.getAutoCommit ();
        connection.setAutoCommit (false);
        Statement statement = connection.createStatement ();
        int rowsAffected = statement.executeUpdate (sql);
        if (requiredRows != - 1 && rowsAffected < requiredRows) {
            LOG.warn ("(" + rowsAffected + ") less than " + requiredRows + " rows affected, rolling back...");
            connection.rollback ();
            return false;
        }
        if (maxRows != - 1 && rowsAffected > maxRows) {
            LOG.warn ("(" + rowsAffected + ") more than " + maxRows + " rows affected, rolling back...");
            connection.rollback ();
            return false;
        }
        connection.commit ();
        return true;
    } catch (SQLException e) {
        LOG.error ("Unable to update database using: " + sql, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.setAutoCommit (oldAutoCommit);
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


public Group updateGroupUsers (Group bean) throws SitoolsException {
    checkGroup ();
    Connection cx = null;
    try {
        cx = ds.getConnection ();
        PreparedStatement st = cx.prepareStatement (jdbcStoreResource.DELETE_GROUPUSERS);
        st.setString (1, bean.getName ());
        st.executeUpdate ();
        st.close ();
        for (Resource res : bean.getUsers ()) {
            PreparedStatement st2 = cx.prepareStatement (jdbcStoreResource.CREATE_GROUPUSERS);
            st2.setString (1, res.getId ());
            st2.setString (2, bean.getName ());
            st2.executeUpdate ();
            st2.close ();
        }
        if (! cx.getAutoCommit ()) {
            cx.commit ();
        }
    } catch (SQLException e) {
        throw new SitoolsException ("UPDATE_GROUPUSERS " + e.getMessage (), e);
    } finally {
        closeConnection (cx);
    }
    return getGroupById (bean.getName ());
}


-----Function Pair=322=-----==

public Collection get (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select SenseNumber, ObjectId from ProperNouns " + "where Noun = '" + name + "'";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector objs = new Vector ();
            while (rs.next () == true) {
                ProperNoun noun = new ProperNoun (name, rs.getInt (1), rs.getInt (2));
                objs.add (noun);
            }
            return objs;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            LOGGER.info ("found: " + person);
            for (Address address : person.getAddresses ()) {
                LOGGER.info ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=323=-----==

public static void querywithfetchplan (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        ReadAllQuery raq = (ReadAllQuery) ((JpaQuery) query).getDatabaseQuery ();
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends"));
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends").anyOfAllowingNone ("friends"));
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getFriends ()) {
                System.out.println ("\twith friend: " + person1);
                for (Person person2 : person1.getFriends ()) {
                    System.out.println ("\t\twith friend: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


public final boolean exists (Integer id) throws RecordException {
    Connection conn = ConnectionManager.getConnection ();
    LoggableStatement pStat = null;
    Class < ? extends RecordBase > actualClass = this.getClass ();
    String tableName = TableNameResolver.getTableName (actualClass);
    String sql = "select * from " + tableName + " where id = :id";
    StatementBuilder builder = new StatementBuilder (sql);
    builder.set ("id", id);
    try {
        pStat = builder.getPreparedStatement (conn);
        log.log (pStat.getQueryString ());
        ResultSet rs = pStat.executeQuery ();
        boolean exists = rs.next ();
        return exists;
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback");
        }
        throw new RecordException (e);
    } finally {
        try {
            if (pStat != null) {
                pStat.close ();
            }
            conn.commit ();
            conn.close ();
        } catch (SQLException e) {
            throw new RecordException ("Error closing connection");
        }
    }
}


-----Function Pair=324=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoParagraphBaseKnowledge coParagraphBaseKnowledge) {
    CoParagraphBaseKnowledgeDAO coParagraphBaseKnowledgeDAO = new CoParagraphBaseKnowledgeDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        coParagraphBaseKnowledgeDAO.update (coParagraphBaseKnowledge);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coParagraphBaseKnowledge);
        Object [] args = {coParagraphBaseKnowledge.getKnowledgeId ()};
        if (bundle != null) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.update.success"), args));
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el knowledge: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void create () {
    Connection conn = OrmHandler.getInstance ().getSession ().getConnection (this);
    Statement stat = null;
    StringBuilder sql = new StringBuilder (256);
    try {
        getRenderer ().printCreateDatabase (this, sql);
        conn = createConnection ();
        stat = conn.createStatement ();
        stat.executeUpdate (sql.toString ());
        conn.commit ();
        if (LOGGER.isLoggable (Level.INFO)) {
            LOGGER.info (sql.toString ());
        }
    } catch (Throwable e) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (SQLException ex) {
                LOGGER.log (Level.WARNING, "Can't rollback DB" + toString (), ex);
            }
        }
        throw new IllegalArgumentException ("Statement error:\n" + sql, e);
    } finally {
        try {
            close (conn, stat, null, true);
        } catch (IllegalStateException ex) {
            LOGGER.log (Level.WARNING, "Can't rollback DB" + toString (), ex);
        }
    }
}


-----Function Pair=325=-----=1=

public ProgramProfilingMessageSymbol deleteProfilingMessageSymbol (int id) throws AdaptationException {
    ProgramProfilingMessageSymbol profilingMessageSymbol = null;
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM ProgramProfilingMessageSymbols " + "WHERE id = " + id;
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        if (! resultSet.next ()) {
            connection.rollback ();
            String msg = "Attempt to delete program profiling message " + "symbol failed.";
            log.error (msg);
            throw new AdaptationException (msg);
        }
        profilingMessageSymbol = getProfilingMessageSymbol (resultSet);
        query = "DELETE FROM ProgramProfilingMessageSymbols " + "WHERE id = " + id;
        statement.executeUpdate (query);
        connection.commit ();
    } catch (SQLException ex) {
        try {
            connection.rollback ();
        } catch (Exception e) {
        }
        String msg = "SQLException in deleteProfilingMessageSymbol";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return profilingMessageSymbol;
}


public void processSaveHolding (Holding holdingBean, AuthSession authSession) {
    if (authSession == null) {
        return;
    }
    DatabaseAdapter dbDyn = null;
    PreparedStatement ps = null;
    try {
        dbDyn = DatabaseAdapter.getInstance ();
        String sql = "UPDATE WM_LIST_HOLDING " + "SET " + "   full_name_HOLDING=?, " + "   NAME_HOLDING=? " + "WHERE ID_HOLDING = ? and ID_HOLDING in ";
        switch (dbDyn.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                String idList = authSession.getGrantedHoldingId ();
                sql += " (" + idList + ") ";
                break;
            default :
                sql += "(select z1.ID_ROAD from v$_read_list_road z1 where z1.user_login = ?)";
                break;
        }
        ps = dbDyn.prepareStatement (sql);
        int num = 1;
        ps.setString (num ++, holdingBean.getName ());
        ps.setString (num ++, holdingBean.getShortName ());
        RsetTools.setLong (ps, num ++, holdingBean.getId ());
        switch (dbDyn.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                break;
            default :
                ps.setString (num ++, authSession.getUserLogin ());
                break;
        }
        int i1 = ps.executeUpdate ();
        if (log.isDebugEnabled ()) log.debug ("Count of updated record - " + i1);
        processDeleteRelatedCompany (dbDyn, holdingBean, authSession);
        processInsertRelatedCompany (dbDyn, holdingBean, authSession);
        dbDyn.commit ();
    } catch (Exception e) {
        try {
            if (dbDyn != null) dbDyn.rollback ();
        } catch (Exception e001) {
        }
        String es = "Error save holding";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (dbDyn, ps);
        dbDyn = null;
        ps = null;
    }
}


-----Function Pair=326=-----==

public RestServiceResult createPublicationComment (RestServiceResult serviceResult, String sPublicationId, ToComment toComment) {
    try {
        Query query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_PUBLICATION_COMMENT);
        query.setParameter (1, toComment.getCommentId ());
        query.setParameter (2, new Long (sPublicationId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {toComment.getCommentId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.create.success"), arrayParam));
    } catch (PersistenceException e) {
        e.printStackTrace ();
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la asociaci�n - Publicacion - Material: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.create.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


public Connection connect (RowSetInternal caller) throws SQLException {
    if (caller.getConnection () != null) {
        userCon = true;
        return caller.getConnection ();
    }
    else if (((RowSet) caller).getDataSourceName () != null) {
        try {
            Context ctx = new InitialContext ();
            DataSource ds = (DataSource) ctx.lookup (((RowSet) caller).getDataSourceName ());
            if (((RowSet) caller).getUsername () != null) {
                return ds.getConnection (((RowSet) caller).getUsername (), ((RowSet) caller).getPassword ());
            }
            else {
                return ds.getConnection ();
            }
        } catch (javax.naming.NamingException ex) {
            SQLException sqlEx = new SQLException (resBundle.handleGetObject ("crsreader.connect").toString ());
            sqlEx.initCause (ex);
            throw sqlEx;
        }
    }
    else if (((RowSet) caller).getUrl () != null) {
        return DriverManager.getConnection (((RowSet) caller).getUrl (), ((RowSet) caller).getUsername (), ((RowSet) caller).getPassword ());
    }
    else {
        return null;
    }
}


-----Function Pair=327=-----==

public String [] getRegisteredEvents () {
    String qry = "SELECT DISTINCT event FROM listeners";
    Statement stmt = null;
    ResultSet rs = null;
    ArrayList < String > list = new ArrayList < String > ();
    try {
        stmt = conn.createStatement ();
        logQry (qry);
        rs = stmt.executeQuery (qry);
        while (rs.next ()) list.add (rs.getString (1));
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
    } finally {
        try {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
    return list.toArray (new String [list.size ()]);
}


public RestServiceResult create (RestServiceResult serviceResult, ToForum toForum) {
    ToForumDAO toForumDAO = new ToForumDAO ();
    try {
        toForum.setForumId (getSequence ("sq_to_forum"));
        EntityManagerHelper.beginTransaction ();
        toForumDAO.save (toForum);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toForum);
        log.info ("El foro" + toForum.getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toForum.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel foro: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=328=-----==

boolean addOverride (int airingId, String title, String subtitle, boolean active) {
    boolean autoCommit = false;
    try {
        autoCommit = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        overrideRmQry.setInt (1, airingId);
        overrideRmQry.executeUpdate ();
        overrideInsQry.setInt (1, airingId);
        overrideInsQry.setString (2, title);
        overrideInsQry.setString (3, subtitle);
        overrideInsQry.setBoolean (4, active);
        overrideInsQry.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            LOG.error (SQL_ERROR, e1);
        }
        LOG.error (SQL_ERROR, e);
        return false;
    } finally {
        try {
            conn.setAutoCommit (autoCommit);
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
    return true;
}


public boolean deleteSubmission (String username, int subid) {
    DBConnection con = null;
    int rs = 0;
    boolean result = true;
    con = DBServiceManager.allocateConnection ();
    try {
        rs = con.executeUpdate ("DELETE FROM mdir_Submission_Category WHERE di_submitcat_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    result = result && (rs != 0);
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Language1 WHERE di_submit_language1_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Language2 WHERE di_submit_language2_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Location1 WHERE di_submit_location1_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Location2 WHERE di_submit_location2_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Url1 WHERE di_submit_URL1_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission_Url2 WHERE di_submit_URL2_subid=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    try {
        con.executeUpdate ("DELETE FROM mdir_Submission WHERE di_submission_id=" + subid);
    } catch (SQLException sqle) {
        sqle.printStackTrace ();
    }
    if (con != null) {
        con.release ();
    }
    result = result & (rs != 0);
    return result;
}


-----Function Pair=329=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public void addPropertyColumns (WCAChannel destination, Set < Property > properties) throws SQLException {
    Session session = HibernateUtil.getSessionFactory ().openSession ();
    Connection con = session.connection ();
    try {
        createPropertyTable (destination);
        extendPropertyList (destination, properties);
        Statement statement = con.createStatement ();
        for (Property property : properties) {
            String propertyName = removeBadChars (property.getName ());
            statement.executeUpdate (alterTable.format (new Object [] {getTableName (destination), propertyName, property.getDBColumnType ()}));
        }
        con.commit ();
        con.close ();
        session.close ();
    } catch (SQLException e) {
        con.rollback ();
        session.close ();
        throw e;
    }
}


-----Function Pair=330=-----==

public int update (FileBean bean) throws SQLException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Connection conn = null;
    int nbrow = 0;
    try {
        DataSource ds = getDataSource (DEFAULT_DATASOURCE);
        conn = ds.getConnection ();
        if (log.isDebugEnabled ()) {
            log.debug ("FileDAOImpl.update() " + UPDATE_FILE);
        }
        pstmt = conn.prepareStatement (UPDATE_FILE);
        pstmt.setLong (1, bean.getMimeTypeId ());
        pstmt.setLong (2, bean.getStorageId ());
        pstmt.setString (3, bean.getAbsolutePath ());
        pstmt.setString (4, bean.getName ());
        pstmt.setLong (5, bean.getStatus ());
        pstmt.setLong (6, bean.getId ());
        nbrow = pstmt.executeUpdate ();
    } catch (SQLException e) {
        log.error ("FileDAOImpl.update() : erreur technique", e);
        throw e;
    } finally {
        closeRessources (conn, pstmt, rs);
    }
    return nbrow;
}


protected boolean isOwnAncestor (Context context) throws DataStoreException {
    boolean result = false;
    Integer category = context.getValueAsInteger (keyField);
    if (category != null) {
        int cat = category.intValue ();
        Connection db = null;
        PreparedStatement ps = null;
        try {
            db = context.getConnection ();
            ps = db.prepareStatement ("select parent from category where category = ?");
            while (cat != CATEGORYROOT) {
                ps.setInt (1, cat);
                ResultSet r = ps.executeQuery ();
                if (r.next ()) {
                    cat = r.getInt (1);
                }
                else {
                    throw new DataFormatException ("Serious: category ancestry is corrupt.");
                }
                if (cat == category.intValue ()) {
                    result = true;
                }
            }
        } catch (SQLException sex) {
            throw new DataStoreException ("Could not read category ancestry");
        } finally {
            try {
                if (db != null) {
                    context.releaseConnection (db);
                }
            } catch (Exception e1) {
            }
        }
    }
    return result;
}


-----Function Pair=331=-----==

public Set < Post > loadPost (Question question) throws SQLException {
    String query = "select * from fs.post where question = ? and deleted = ?";
    ensureConnection ();
    PreparedStatement statement = null;
    Savepoint savepoint = null;
    ResultSet result = null;
    Set < Post > set = new TreeSet < Post > ();
    try {
        savepoint = m_connection.setSavepoint ();
        statement = m_connection.prepareStatement (query, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
        statement.setLong (1, question.getDatabaseID ());
        statement.setBoolean (2, false);
        result = statement.executeQuery ();
        while (result.next ()) {
            Post post = question.getConfig ().createPost (question, result.getString ("author"), result.getTimestamp ("posted_date"), result.getString ("pid"), PostType.valueOf (result.getString ("type")));
            post.setDatabaseID (result.getLong ("id"));
            if (! result.getBoolean ("path")) {
                String text = result.getString ("text");
                if (text.length () > m_configuration.getThresholdByteSize ()) {
                    result.updateBoolean ("path", true);
                    String path = getPath (post);
                    IOUtils.writeIntoFile (new File (m_configuration.getRepository (), path), text);
                    result.updateString ("text", path);
                    result.updateRow ();
                    post.setText (new DelayedLoadString (new File (m_configuration.getRepository (), path)));
                }
                else post.setText (text);
            }
            else {
                File file = new File (m_configuration.getRepository (), result.getString ("text"));
                if (file.isDirectory ()) throw new SQLException ("The date file '" + file.getAbsolutePath () + "' is a directory.");
                else if (! file.exists ()) throw new SQLException ("The data file '" + file.getAbsolutePath () + "' is not found.");
                else if (! file.canRead ()) throw new SQLException ("The data file '" + file.getAbsolutePath () + "' can't be read.");
                post.setText (new DelayedLoadString (file));
            }
            set.add (post);
        }
        m_connection.commit ();
        return set;
    } catch (SQLException e) {
        m_connection.rollback (savepoint);
        throw e;
    } catch (IOException e) {
        m_connection.rollback (savepoint);
        SQLException ex = new SQLException ();
        ex.initCause (e);
        throw ex;
    } finally {
        if (null != result) {
            try {
                result.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


public static void updateViaScraping (final ResultProgressHandle progress, final GameTitle game) throws Exception {
    if (! (game instanceof WtGameTitle)) throw new IllegalArgumentException ("game must be a WtGameTitle");
    Session session = null;
    Transaction tx = null;
    try {
        session = openSession ();
        tx = session.beginTransaction ();
        for (Game g : Game.getByTitle (game)) {
            if (null != progress) progress.setBusy ("Downloading song list for " + g);
            List < WtSong > songs = WtSongScraper.scrape ((WtGame) g);
            LOG.finer ("scraped " + songs.size () + " songs for " + g);
            assert null != WtSongScraper.lastScrapedTiers;
            LOG.finer ("remapping " + WtSongScraper.lastScrapedTiers.size () + " tiers");
            Tiers tiers = new Tiers (WtSongScraper.lastScrapedTiers);
            Tiers.setTiers (g, tiers);
            ((WtGame) g).mapTiers (tiers);
            int i = 0, total = songs.size ();
            for (WtSong song : songs) {
                if (null != progress) progress.setProgress (String.format ("Processing song %s of %s", i + 1, total), i, total);
                WtSong result = (WtSong) session.createQuery ("FROM WtSong WHERE scoreHeroId=:shid AND gameTitle=:gameTtl").setInteger ("shid", song.getScoreHeroId ()).setString ("gameTtl", song.getGameTitle ().title).uniqueResult ();
                if (null == result) {
                    LOG.info ("Inserting song: " + song);
                    session.save (song);
                }
                else {
                    LOG.finest ("found song: " + result);
                    if (result.update (song, false)) {
                        LOG.info ("Updating song to: " + result);
                        session.update (result);
                    }
                    else {
                        LOG.finest ("No changes to song: " + result);
                    }
                }
                i ++;
            }
            if (((WtGameTitle) g.title).supportsExpertPlus) {
                if (null != progress) progress.setBusy ("Checking Expert+ song status for " + g);
                songs = WtSongScraper.scrape ((WtGame) g, Instrument.Group.DRUMS, Difficulty.EXPERT_PLUS);
                LOG.finer ("scraped " + songs.size () + " songs for expert+ check for " + g);
                i = 0;
                total = songs.size ();
                for (WtSong song : songs) {
                    if (null != progress) progress.setProgress (String.format ("Processing song %s of %s", i + 1, total), i, total);
                    WtSong result = (WtSong) session.createQuery ("FROM WtSong WHERE scoreHeroId=:shid AND gameTitle=:gameTtl").setInteger ("shid", song.getScoreHeroId ()).setString ("gameTtl", song.getGameTitle ().title).uniqueResult ();
                    if (null == result) {
                        LOG.warning ("Didn't find song in DB during Expert+ check: " + song);
                    }
                    else {
                        LOG.finest ("found song: " + result);
                        result.setExpertPlusSupported (true);
                        LOG.info ("Updating song to supprot Expert+: " + result);
                        session.update (result);
                    }
                    if (i % 64 == 0) {
                        session.flush ();
                        session.clear ();
                    }
                    i ++;
                }
            }
        }
        Tiers.write ();
        LOG.info ("Deleting old song orders");
        int deletedOrderCount = session.createQuery ("delete SongOrder where gameTitle=:gameTitle").setString ("gameTitle", game.toString ()).executeUpdate ();
        LOG.finer ("deleted " + deletedOrderCount + " old song orders");
        for (Game g : Game.getByTitle (game)) {
            if (null != progress) progress.setBusy ("Downloading song order lists for " + g);
            List < SongOrder > orders = WtSongScraper.scrapeOrders (progress, (WtGame) g);
            LOG.finer ("scraped " + orders.size () + " song orderings for " + g);
            int i = 0, total = orders.size ();
            for (SongOrder order : orders) {
                LOG.info ("Inserting song order: " + order);
                session.save (order);
                if (i % 64 == 0) {
                    session.flush ();
                    session.clear ();
                    if (null != progress) progress.setProgress ("Processing song order lists...", i, total);
                }
                i ++;
            }
        }
        tx.commit ();
    } catch (HibernateException e) {
        if (null != tx && tx.isActive ()) tx.rollback ();
        LOG.throwing ("WtSongUpdater", "updateViaScraping", e);
        throw e;
    } finally {
        if (null != session && session.isOpen ()) session.close ();
    }
}


-----Function Pair=332=-----==

public RestServiceResult create (RestServiceResult result, ToGlossary toGlossary) {
    ToGlossaryDAO toGlossaryDAO = new ToGlossaryDAO ();
    try {
        toGlossary.setGlossaryId (getSequence ("sq_to_glossary"));
        EntityManagerHelper.beginTransaction ();
        toGlossaryDAO.save (toGlossary);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toGlossary);
        Object [] args = {toGlossary.getTerm (), toGlossary.getGlossaryId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("glossary.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar el termino del glosario : " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=333=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nGlossaryId) {
    ToGlossary toGlossary = new ToGlossaryDAO ().findById (nGlossaryId);
    EntityManagerHelper.refresh (toGlossary);
    if (toGlossary == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("glossary.search.notFound"));
    }
    else {
        List < ToGlossary > list = new ArrayList < ToGlossary > ();
        EntityManagerHelper.refresh (toGlossary);
        list.add (toGlossary);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("glossary.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        Person jesse = null;
        Person anne = null;
        for (Person person : collection) {
            if ("Jesse".equals (person.getFirstName ())) {
                jesse = person;
            }
            else if ("Anne".equals (person.getFirstName ())) {
                anne = person;
            }
        }
        anne.getFriends ().add (jesse);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=334=-----==

public void testDontTrackOpenResources () throws Exception {
    Properties props = new Properties ();
    props.setProperty ("dontTrackOpenResources", "true");
    Connection noTrackConn = null;
    Statement noTrackStatement = null;
    PreparedStatement noTrackPstmt = null;
    ResultSet rs2 = null;
    try {
        noTrackConn = getConnectionWithProps (props);
        noTrackStatement = noTrackConn.createStatement ();
        noTrackPstmt = noTrackConn.prepareStatement ("SELECT 1");
        rs2 = noTrackPstmt.executeQuery ();
        rs2.next ();
        this.rs = noTrackStatement.executeQuery ("SELECT 1");
        this.rs.next ();
        noTrackConn.close ();
        this.rs.getString (1);
        rs2.getString (1);
    } finally {
        if (rs2 != null) {
            rs2.close ();
        }
        if (noTrackStatement != null) {
            noTrackStatement.close ();
        }
        if (noTrackConn != null & ! noTrackConn.isClosed ()) {
            noTrackConn.close ();
        }
    }
}


private boolean hasInDatabase (Post post) throws SQLException {
    ensureConnection ();
    PreparedStatement statement = null;
    ResultSet rs = null;
    try {
        statement = m_connection.prepareStatement ("select id from fs.post where (forum = ? and tid = ? and qid = ? and pid = ?) or id = ?");
        if (post.getDatabaseID () == null) statement.setNull (5, Types.NUMERIC);
        else statement.setLong (5, post.getDatabaseID ());
        statement.setString (1, post.getQuestion ().getTopicArea ().getForum ().getName ());
        statement.setString (2, post.getQuestion ().getTopicArea ().getIdentifier ());
        statement.setString (3, post.getQuestion ().getIdentifier ());
        statement.setString (4, post.getIdentifier ());
        rs = statement.executeQuery ();
        if (rs.next ()) {
            long id = rs.getLong ("id");
            if (post.getDatabaseID () == null) {
                post.setDatabaseID (id);
            }
            else if (post.getDatabaseID () != id) {
                post.setDatabaseID (id);
            }
            return true;
        }
        return false;
    } finally {
        if (null != rs) {
            try {
                rs.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


-----Function Pair=335=-----==

public void testDontTrackOpenResources () throws Exception {
    Properties props = new Properties ();
    props.setProperty ("dontTrackOpenResources", "true");
    Connection noTrackConn = null;
    Statement noTrackStatement = null;
    PreparedStatement noTrackPstmt = null;
    ResultSet rs2 = null;
    try {
        noTrackConn = getConnectionWithProps (props);
        noTrackStatement = noTrackConn.createStatement ();
        noTrackPstmt = noTrackConn.prepareStatement ("SELECT 1");
        rs2 = noTrackPstmt.executeQuery ();
        rs2.next ();
        this.rs = noTrackStatement.executeQuery ("SELECT 1");
        this.rs.next ();
        noTrackConn.close ();
        this.rs.getString (1);
        rs2.getString (1);
    } finally {
        if (rs2 != null) {
            rs2.close ();
        }
        if (noTrackStatement != null) {
            noTrackStatement.close ();
        }
        if (noTrackConn != null & ! noTrackConn.isClosed ()) {
            noTrackConn.close ();
        }
    }
}


private static String getEndOfClassUID (String className, String classNameItem, DbTableType table, String accessAction, String sqlName) throws Exception {
    String s = "         }\n" + "         catch (Exception e) {\n";
    if (config.getIsUseLogging ()) {
        for (int i = 0; i < table.getFieldsCount (); i ++) {
            DbFieldType field = table.getFields (i);
            String capitalizeName = StringTools.capitalizeString (field.getName ()) + "()";
            s += "             cat.error(\"Item get" + capitalizeName + ", value - \"+item.get" + capitalizeName + ");\n";
        }
    }
    if (config.getIsUseLogging ()) s += "             cat.error(\"SQL \"+" + sqlName + ");\n" + "             cat.error(\"Exception insert data in db\", e);\n";
    if (config.getPersistenceExceptionName () != null && config.getPersistenceExceptionName ().getExceptionType ().getType () == ExceptionDefinitionTypeExceptionTypeType.WRAP_PERSISTENCE_TYPE) {
        if (config.getPersistenceExceptionName ().getPersistenceExceptionName () == null) throw new IllegalArgumentException ("Not defined PersistebceExceptionName");
        s += "            throw new " + config.getPersistenceExceptionName ().getPersistenceExceptionName () + "( e.getMessage(), e );\n";
    }
    else s += "            throw e;\n";
    s += "        }\n" + "        finally {\n" + putCloseFactoryMethod () + "            rs = null;\n" + "            ps = null;\n" + "        }\n" + "\n" + "    }\n" + "\n" + (isApplModule ? "     public byte[] processRequest( ResourceRequestType applReq, AuthSession authSession )\n" + "         throws Exception\n" + "     {\n" + "          if (applReq==null || applReq.getParametersCount()==0)\n" + "              return null;\n" + "\n" + putAuthCheck (table, accessAction, className) + "\n" + "          " + classNameItem + " item = null;\n" + "          for (int i=0; i<applReq.getParametersCount(); i++)\n" + "          {\n" + "              ResourceRequestParameterType param = applReq.getParameters(i);\n" + "              if (\"mill.item\".equals( param.getNameParameter()))\n" + "              {\n" + "                  String stringParam = ApplicationTools.decodeParameter( param );\n" + "\n" + (config.getIsUseLogging () ? "                  if (cat.isDebugEnabled())\n" + "                      cat.debug(\"Parameter is \"+stringParam);\n" : "") + "\n" + "                  org.xml.sax.InputSource inSrc = new org.xml.sax.InputSource( new java.io.StringReader(stringParam) );\n" + "                  item = (" + classNameItem + ") org.exolab.castor.xml.Unmarshaller.unmarshal(" + classNameItem + ".class, inSrc);\n" + "                  break;\n" + "              }\n" + "          }\n" + "          if (item == null )\n" + "              return null;\n" + "\n" + "          " + db.getFactoryMethod () + " db_ = null;\n" + "          try" + "          {\n" + "              db_ = " + db.getFactoryMethod () + ".getInstance( true );\n" + "              db_.getConnection().setAutoCommit(false);\n" + "              long resultLong = " + className + ".process( db_, item );\n" + "              db_.commit();\n" + "              org.riverock.schema.appl_server.LongResultType result = new org.riverock.schema.appl_server.LongResultType();\n" + "              result.setResult(resultLong);\n" + "              return org.riverock.generic.tools.XmlTools.getXml(result, null);\n" + "          }\n" + "          catch(Exception e)\n" + "          {\n" + (config.getIsUseLogging () ? "              cat.error(\"Exception " + className + "process\", e);\n" : "") + "              db_.rollback();\n" + "              throw e;\n" + "          }\n" + "          catch(Error e)\n" + "          {\n" + (config.getIsUseLogging () ? "              cat.error(\"Error " + className + "process\", e);\n" : "") + "              db_.rollback();\n" + "              throw e;\n" + "          }\n" + "          finally\n" + "          {\n" + "              " + db.getFactoryMethod () + ".close( db_ );\n" + "              db_ = null;\n" + "          }\n" + "      }\n" + "\n" : "");
    return s;
}


-----Function Pair=336=-----==

private boolean hasInDatabase (Question question) throws SQLException {
    ensureConnection ();
    PreparedStatement statement = null;
    ResultSet rs = null;
    try {
        statement = m_connection.prepareStatement ("select id, asker from question where (topic = ? and qid = ?) or id = ?");
        if (question.getDatabaseID () == null) statement.setNull (3, Types.NUMERIC);
        else statement.setLong (3, question.getDatabaseID ());
        statement.setLong (1, question.getTopicArea ().getDatabaseID ());
        statement.setString (2, question.getIdentifier ());
        rs = statement.executeQuery ();
        if (rs.next ()) {
            long id = rs.getLong ("id");
            if (question.getDatabaseID () == null) {
                question.setDatabaseID (id);
                if (question.getAsker () == null) question.setAsker (rs.getString ("asker"));
            }
            else if (id != question.getDatabaseID ()) {
                question.setDatabaseID (id);
                if (question.getAsker () == null) question.setAsker (rs.getString ("asker"));
            }
            return true;
        }
        return false;
    } finally {
        if (null != rs) {
            try {
                rs.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


public void testNoTransactiopn () throws Exception {
    InitialContext ic = new InitialContext ();
    TransactionManager tm = (TransactionManager) ic.lookup ("TransactionManager");
    DataSource ds = (DataSource) ic.lookup ("TestDS");
    assertNotNull (ds);
    Connection conn = null;
    Statement s = null;
    ResultSet rs = null;
    tm.begin ();
    try {
        conn = (Connection) ds.getConnection ();
        executeUpdate (conn, "insert into test(id) values (1)");
    } finally {
        close (rs);
        close (s);
        close (conn);
        tm.commit ();
    }
    try {
        conn = (Connection) ds.getConnection ();
        s = conn.createStatement ();
        rs = s.executeQuery ("select id from test");
        assertTrue (rs.next ());
        assertEquals (1, rs.getInt ("id"));
        assertFalse (rs.next ());
    } finally {
        close (rs);
        close (s);
        close (conn);
    }
}


-----Function Pair=337=-----==

private boolean hasInDatabase (Post post) throws SQLException {
    ensureConnection ();
    PreparedStatement statement = null;
    ResultSet rs = null;
    try {
        statement = m_connection.prepareStatement ("select id from fs.post where (forum = ? and tid = ? and qid = ? and pid = ?) or id = ?");
        if (post.getDatabaseID () == null) statement.setNull (5, Types.NUMERIC);
        else statement.setLong (5, post.getDatabaseID ());
        statement.setString (1, post.getQuestion ().getTopicArea ().getForum ().getName ());
        statement.setString (2, post.getQuestion ().getTopicArea ().getIdentifier ());
        statement.setString (3, post.getQuestion ().getIdentifier ());
        statement.setString (4, post.getIdentifier ());
        rs = statement.executeQuery ();
        if (rs.next ()) {
            long id = rs.getLong ("id");
            if (post.getDatabaseID () == null) {
                post.setDatabaseID (id);
            }
            else if (post.getDatabaseID () != id) {
                post.setDatabaseID (id);
            }
            return true;
        }
        return false;
    } finally {
        if (null != rs) {
            try {
                rs.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        LOGGER.info ("*** insert ***");
        insert (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** update ***");
        update (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


-----Function Pair=338=-----==

public PEntry getPerson (String code) throws SQLException {
    Statement stmt = conn.createStatement ();
    PEntry pei = new PEntry ();
    ResultSet rset = stmt.executeQuery ("SELECT * FROM personal WHERE personalbs = '" + code + "';");
    if (! rset.next ()) return null;
    pei.setName (rset.getString ("preName") + " " + rset.getString ("name"));
    pei.setLang (rset.getString ("lang"));
    pei.setPersonalId (rset.getInt ("personalnr"));
    pei.setState (rset.getInt ("stamppersonalid"));
    if (pei.getState () != 0) {
        rset = stmt.executeQuery ("SELECT * FROM stampzk, zeitk, posten, best, sachb, kunde, funcs, images WHERE stampzk.outtime='0' AND " + "stampzk.personalid = '" + pei.getPersonalId () + "' AND " + "stampzk.zeitkid=zeitk.zeitkid AND zeitk.postennr=posten.postennr AND " + "posten.ordernr=best.ordernr AND best.sachbnr=sachb.sachbnr AND " + "sachb.clientnr=kunde.clientnr AND stampzk.funcsid=funcs.funcsid AND " + "posten.zgnr=images.imagesnr AND stampzk.sf='0' ORDER BY stampzk.intime ASC;");
        while (rset.next ()) {
            Workitem wi = new Workitem ();
            wi.setStampZkId (rset.getInt ("stampzkid"));
            wi.setInfoString (rset.getString ("firm") + ": " + rset.getString ("description") + ": " + rset.getString (pei.getLang ()));
            int firstId = rset.getInt ("firstid");
            if (firstId == 0) wi.setIntime (rset.getLong ("intime"));
            else {
                ResultSet zres = conn.createStatement ().executeQuery ("SELECT intime FROM stampzk WHERE stampzkid='" + firstId + "';");
                zres.next ();
                wi.setIntime (zres.getLong ("intime"));
            }
            pei.addItem (wi);
        }
        rset = stmt.executeQuery ("SELECT * FROM stampzk, specialfuncs WHERE stampzk.outtime='0' AND stampzk.personalid = '" + pei.getPersonalId () + "' AND stampzk.zeitkid=specialfuncs.specialfuncsid AND stampzk.sf='1';");
        while (rset.next ()) {
            Workitem spec = new Workitem ();
            spec.setStampZkId (rset.getInt ("stampzkid"));
            spec.setInfoString (rset.getString (pei.getLang ()));
            int firstId = rset.getInt ("firstid");
            if (firstId == 0) spec.setIntime (rset.getLong ("intime"));
            else {
                ResultSet zres = conn.createStatement ().executeQuery ("SELECT intime FROM stampzk WHERE stampzkid='" + firstId + "';");
                zres.next ();
                spec.setIntime (zres.getLong ("intime"));
            }
            spec.setIntime (rset.getLong ("intime"));
            pei.addSpecialItem (spec);
        }
    }
    return pei;
}


public Vector getFlightDialogTableData (int currentPilot) throws SQLException {
    Object data [] = null;
    Statement stmt;
    ResultSet rs = null;
    int columnCount;
    int y = 0;
    String s = "";
    Vector rows = null, row = null;
    try {
        String sQuery = "select nr, dato, flytype.navn, " + "svaevetid, distance, airfield1.name, airfield2.name, flyvning.id " + "from flyvning, flytype, airfield as airfield1, airfield as airfield2  " + "where flytype.id = flytype_id " + "and pilot_id = " + currentPilot + " " + "and airfield1.id = startsted_id " + "and airfield2.id = landingssted_id " + "order by nr";
        stmt = conn.getStatement ();
        rs = stmt.executeQuery (sQuery);
        columnCount = rs.getMetaData ().getColumnCount ();
        rows = new Vector (200);
        if (! rs.next ()) {
            log.info ("Oops, no rows selected in flyvning, creating fake");
            row = new Vector (columnCount);
            row.addElement (new Integer (0));
            row.addElement (Calendar.getInstance ().getTime ());
            row.addElement (s);
            row.addElement (new Integer (0));
            row.addElement (new Integer (0));
            row.addElement (s);
            row.addElement (s);
            row.addElement (new Integer (0));
            rows.addElement (row);
        }
        else {
            do {
                row = new Vector (columnCount);
                for (y = 0; y < columnCount; y ++) {
                    row.addElement (rs.getObject (y + 1));
                    if (row.get (y) == null) {
                        row.set (y, s);
                    }
                }
                row.set (1, new java.util.Date (rs.getLong (2)));
                rows.addElement (row);
            }
            while (rs.next ());
        }
    } catch (SQLException sqle) {
        log.debug (sqle);
        throw sqle;
    }
    if (rs != null) rs.close ();
    if (stmt != null) stmt.close ();
    return rows;
}


-----Function Pair=339=-----==

public boolean updateBookmark (BookmarkReference bookmark) throws SQLException {
    Object [] bindVariables = new Object [5];
    int [] types = new int [5];
    types [0] = Types.VARCHAR;
    types [1] = Types.BOOLEAN;
    types [2] = Types.VARCHAR;
    types [2] = Types.VARCHAR;
    types [4] = Types.BIGINT;
    bindVariables [0] = bookmark.getName ();
    bindVariables [1] = Boolean.valueOf (bookmark.isFavorite ());
    bindVariables [2] = bookmark.getPath ();
    ColorLabel colorLabel = bookmark.getColorLabel ();
    bindVariables [3] = colorLabel == null ? null : colorLabel.name ();
    bindVariables [4] = new Long (bookmark.getId ());
    PreparedStatement preparedStatement = null;
    try {
        preparedStatement = embeddedConnection.prepareStatement (BOOKMARK_UPDATE_LITE);
        for (int i = 0; i < bindVariables.length; i ++) {
            if (bindVariables [i] == null) {
                preparedStatement.setNull (i + 1, types [i]);
            }
            else {
                preparedStatement.setObject (i + 1, bindVariables [i]);
            }
        }
        int affected = preparedStatement.executeUpdate ();
        return affected == 1;
    } finally {
        if (preparedStatement != null) {
            try {
                preparedStatement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


private static Long getNextPkValueForEntity (String ename) {
    Long pk = cachedPkValue (ename);
    if (encodeHostInPkValue ()) {
        long l = pk.longValue ();
        if (l > MAX_PK_VALUE) {
            throw new IllegalStateException ("max PK value reached for entity " + ename + " cannot continue!");
        }
        long realPk = l << HOST_CODE_LENGTH;
        realPk = realPk | hostCode ();
        if (log.isDebugEnabled ()) {
            log.debug ("new pk value for " + ename + "(" + ((ERXModelGroup) ERXApplication.erxApplication ().defaultModelGroup ()).entityCode (ename) + "), db value = " + pk + ", new value = " + realPk);
        }
        pk = new Long (realPk);
    }
    if (encodeEntityInPkValue ()) {
        long l = pk.longValue ();
        if (l > MAX_PK_VALUE) {
            throw new IllegalStateException ("max PK value reached for entity " + ename + " cannot continue!");
        }
        long realPk = l << CODE_LENGTH;
        realPk = realPk | ((ERXModelGroup) ERXApplication.erxApplication ().defaultModelGroup ()).entityCode (ename);
        if (log.isDebugEnabled ()) {
            log.debug ("new pk value for " + ename + "(" + ((ERXModelGroup) ERXApplication.erxApplication ().defaultModelGroup ()).entityCode (ename) + "), db value = " + pk + ", new value = " + realPk);
        }
        pk = new Long (realPk);
    }
    return pk;
}


-----Function Pair=340=-----==

private void removeAID (String aid) throws SQLException {
    PreparedStatements pss = getPreparedStatements ();
    pss.stm_selNrOfDescrForAID.setString (1, aid);
    ResultSet rs = pss.stm_selNrOfDescrForAID.executeQuery ();
    int found = 0;
    if (rs.next ()) found = Integer.parseInt (rs.getString (1));
    if (found == 0) {
        pss.stm_delAgentUserDefSlot.setString (1, aid);
        pss.stm_delAgentUserDefSlot.execute ();
        Collection resolverAIDs = getResolverAIDs (aid);
        Iterator iter = resolverAIDs.iterator ();
        while (iter.hasNext ()) {
            removeAID ((String) iter.next ());
        }
        pss.stm_delAgentResolver.setString (1, aid);
        pss.stm_delAgentResolver.execute ();
        pss.stm_delAgentAddress.setString (1, aid);
        pss.stm_delAgentAddress.execute ();
    }
}


public Collection createCollection (String name) throws XMLDBException {
    Connection conn = null;
    Collection coll = null;
    try {
        conn = ConnectionManager.createConnection ();
        conn.setAutoCommit (false);
        String sql = "INSERT INTO XDB_COLLECTION (XDB_COLLECTION_OID,NAME,PARENT) VALUES (?,?,?)";
        PreparedStatement pstmt = conn.prepareStatement (sql);
        long oid = getNewCollectionOID (conn);
        long parentOID = getParentCollectionOID ();
        pstmt.setLong (1, oid);
        pstmt.setString (2, name);
        pstmt.setLong (3, parentOID);
        pstmt.executeUpdate ();
        pstmt.close ();
        coll = new CollectionImpl (name, oid, collection);
        coll.setProperty (Constants.XDB_COLLECTION_ABSOLUTE_PATH, collection.getProperty (Constants.XDB_COLLECTION_ABSOLUTE_PATH) + "/" + name);
        conn.commit ();
        conn.close ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    } catch (java.sql.SQLException se) {
        se.printStackTrace ();
    }
    return coll;
}


-----Function Pair=341=-----==

public void run () {
    try {
        con.rollback ();
        PreparedStatement pstmt = con.prepareStatement ("SELECT id, data FROM #TEST WHERE id = ?", ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        for (int i = 1; i <= LOOP_MAX; i ++) {
            pstmt.clearParameters ();
            pstmt.setInt (1, i);
            ResultSet rs = pstmt.executeQuery ();
            while (rs.next ()) {
                rs.getInt (1);
                rs.getString (2);
            }
        }
        pstmt.close ();
    } catch (Exception e) {
        System.err.print ("ID=" + threadId + ' ');
        e.printStackTrace ();
        error = e;
    }
    synchronized (this.getClass ()) {
        live --;
    }
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=342=-----==

public void query () throws Exception {
    Connection conn = s.getConnection ();
    PreparedStatement ps = conn.prepareStatement ("select * from t_test");
    ResultSet rs = ps.executeQuery ();
    FileOutputStream fos = new FileOutputStream ("d:/bbb.xls");
    int len = - 1;
    while (rs.next ()) {
        InputStream is = rs.getBlob (6).getBinaryStream ();
        while ((len = is.read ()) != - 1) {
            fos.write (len);
        }
        fos.close ();
        is.close ();
    }
    rs.close ();
    ps.close ();
}


public String render (Transferable transferable) {
    Object object = null;
    try {
        if (transferable != null) {
            object = transferable.getTransferData (DBEntityDataFlavor.dbEntityDataFlavor ());
            DBEntity entity = (DBEntity) object;
            SingleTableSelectStatement st = new SingleTableSelectStatement (entity);
            try {
                return SQLFormatter.format (st.getSelectString (this.conn.getMetaData ())) + ";";
            } catch (Exception e1) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e1, "Exception caught while dropping");
            }
        }
    } catch (UnsupportedFlavorException e) {
        try {
            return transferable.getTransferData (DataFlavor.stringFlavor).toString () + ";";
        } catch (UnsupportedFlavorException e1) {
            try {
                DataFlavor [] f = transferable.getTransferDataFlavors ();
                if (f != null && f.length > 0) return transferable.getTransferData (f [0]).toString ();
                else return "";
            } catch (UnsupportedFlavorException e2) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e2, "Exception caught while dropping");
            } catch (IOException e3) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e3, "Exception caught while dropping");
            }
        } catch (IOException e4) {
            ExceptionManagerFactory.getExceptionManager ().manageException (e4, "Exception caught while dropping");
        }
    } catch (IOException e5) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e5, "Exception caught while dropping");
    }
    return "";
}


-----Function Pair=343=-----==

private static void lock (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManagerA = entityManagerFactory.createEntityManager ();
    EntityManager entityManagerB = entityManagerFactory.createEntityManager ();
    try {
        entityManagerA.getTransaction ().begin ();
        entityManagerB.getTransaction ().begin ();
        Query queryA = entityManagerA.createQuery ("SELECT p FROM Person p");
        Collection < Person > collectionA = (Collection < Person >) queryA.getResultList ();
        Person personA = collectionA.iterator ().next ();
        entityManagerA.lock (personA, LockModeType.READ);
        Query queryB = entityManagerB.createQuery ("SELECT p FROM Person p");
        Collection < Person > collectionB = (Collection < Person >) queryB.getResultList ();
        Person personB = collectionB.iterator ().next ();
        entityManagerB.lock (personB, LockModeType.READ);
        entityManagerA.flush ();
        entityManagerB.flush ();
        entityManagerA.getTransaction ().commit ();
        entityManagerB.getTransaction ().commit ();
    } finally {
        if (entityManagerA.getTransaction ().isActive ()) {
            entityManagerA.getTransaction ().rollback ();
        }
        entityManagerA.close ();
        if (entityManagerB.getTransaction ().isActive ()) {
            entityManagerB.getTransaction ().rollback ();
        }
        entityManagerB.close ();
    }
}


public void testCurrentDate () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        DateHolder d1 = new DateHolder ();
        Calendar cal = Calendar.getInstance ();
        cal.set (2006, 11, 01);
        d1.setDateField (cal.getTime ());
        em.persist (d1);
        DateHolder d2 = new DateHolder ();
        Calendar cal2 = Calendar.getInstance ();
        cal2.set (2012, 11, 01);
        d2.setDateField (cal2.getTime ());
        em.persist (d2);
        em.flush ();
        List result = em.createQuery ("SELECT Object(D) FROM " + DateHolder.class.getName () + " D WHERE D.dateField < CURRENT_DATE").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=344=-----==

public ArrayList < Integer > getContrincantesxRonda (int idJugadorDivision) {
    ArrayList < Integer > arr = new ArrayList < Integer > ();
    int dato;
    try {
        String sql = " SELECT idPareoRival FROM jugadorxdivxronda A, ronda B" + " WHERE A.ronda_numeroRonda = B.numeroRonda AND " + " A.jugadorxDivision_idJugadorxDivision = " + idJugadorDivision + " ORDER BY B.nRonda";
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            dato = populateContrincantes (resultSet);
            arr.add (dato);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return arr;
}


public RestServiceResult listByLanguagueId (RestServiceResult serviceResult, Long nLanguagueId) {
    List < MaSingleTextForm > listMaSingleText = null;
    Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.SELECT_MA_SINGLE_TEXT_FORM_LANG, MaSingleTextForm.class);
    query.setParameter (1, nLanguagueId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listMaSingleText = query.getResultList ();
    if (listMaSingleText == null || listMaSingleText.size () == 0) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("singleText.search.notFound"));
    }
    else {
        Object [] arrayParam = {listMaSingleText.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("singleText.search.success"), arrayParam));
        serviceResult.setObjResult (listMaSingleText);
        serviceResult.setNumResult (listMaSingleText.size ());
    }
    return serviceResult;
}


-----Function Pair=345=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoMatrixExercises2 coMatrixExercises2) {
    CoMatrixExercises2DAO coMatrixExercises2DAO = new CoMatrixExercises2DAO ();
    String sExerciseName = coMatrixExercises2.getCoExercises2 ().getExerciseName ();
    try {
        log.info ("Actualizando la matriz tipo 2: " + sExerciseName);
        EntityManagerHelper.beginTransaction ();
        coMatrixExercises2DAO.update (coMatrixExercises2);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMatrixExercises2);
        Object [] arrayParam = {sExerciseName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises2.update.success"), arrayParam));
        log.info ("Se actualizo la matriz tipo 2 con �xito: " + sExerciseName);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la matriz tipo 2: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


public void create (DisciplinaDTO disciplina) {
    try {
        this.criaConexao (false);
    } catch (ClassNotFoundException ex) {
        java.util.logging.Logger.getLogger (PostgresqlDisciplinaDAO.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (SQLException ex) {
        java.util.logging.Logger.getLogger (PostgresqlDisciplinaDAO.class.getName ()).log (Level.SEVERE, null, ex);
    }
    String sql = "insert into Disciplina select nextval('sq_Disciplina') as id, ? as nome";
    PreparedStatement stmt = null;
    try {
        stmt = this.getConnection ().prepareStatement (sql);
        stmt.setString (1, disciplina.getNome ());
        int retorno = stmt.executeUpdate ();
        if (retorno == 0) {
            this.getConnection ().rollback ();
            throw new SQLException ("Ocorreu um erro inesperado no momento de inserir dados de Disciplina no banco!");
        }
        this.getConnection ().commit ();
    } catch (SQLException e) {
        try {
            this.getConnection ().rollback ();
        } catch (SQLException ex) {
            java.util.logging.Logger.getLogger (PostgresqlDisciplinaDAO.class.getName ()).log (Level.SEVERE, null, ex);
        }
        try {
            throw e;
        } catch (SQLException ex) {
            java.util.logging.Logger.getLogger (PostgresqlDisciplinaDAO.class.getName ()).log (Level.SEVERE, null, ex);
        }
    } finally {
        try {
            stmt.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            try {
                throw e;
            } catch (SQLException ex) {
                java.util.logging.Logger.getLogger (PostgresqlDisciplinaDAO.class.getName ()).log (Level.SEVERE, null, ex);
            }
        }
    }
}


-----Function Pair=346=-----==

public int update (BusinessObject o) throws DAOException {
    int update = 0;
    Bill bill = (Bill) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("UPDATE_BILL"));
        pst.setInt (1, bill.getId ());
        update = pst.executeUpdate ();
        if (update <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (update > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return update;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=347=-----==

public SysSequences getSeqs (String tableName) throws SQLException {
    SysSequences seq = new SysSequences ();
    if (tableName == null || tableName.trim ().equals ("")) return null;
    Connection conn = null;
    try {
        conn = ConnectUtil.getConnect ();
        conn.setAutoCommit (false);
        PreparedStatement ps = conn.prepareStatement ("update ss_sys_sequences set next_value=next_value+step_value where table_name='" + tableName + "'");
        ps.executeUpdate ();
        ps.close ();
        ps = conn.prepareStatement ("select * from ss_sys_sequences where table_name='" + tableName + "'");
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            long nextValue = rs.getLong (2);
            long stepValue = rs.getLong (3);
            seq.setTableName (tableName);
            seq.setNextValue (nextValue - stepValue + 1);
            seq.setStepValue (stepValue);
        }
        rs.close ();
        ps.close ();
        if (seq.getTableName () == null) {
            ps = conn.prepareStatement ("insert into ss_sys_sequences values('" + tableName + "'," + (Constants.DEFAULT_CURR_VALUE + Constants.DEFAULT_STEP_VALUE) + "," + Constants.DEFAULT_STEP_VALUE + ")");
            ps.executeUpdate ();
            ps.close ();
            seq.setTableName (tableName);
            seq.setNextValue (Constants.DEFAULT_CURR_VALUE + 1);
            seq.setStepValue (Constants.DEFAULT_STEP_VALUE);
        }
        conn.commit ();
    } catch (Exception e) {
        conn.rollback ();
        e.printStackTrace ();
    } finally {
        try {
            conn.setAutoCommit (true);
        } catch (Exception e) {
        }
        ConnectUtil.closeConn (conn);
    }
    return seq;
}


public String [] getSiteChannelPaths (String docTypPath, boolean isFindParentNode) throws Exception {
    if (docTypPath == null) {
        return new String [0];
    }
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    List list = new ArrayList ();
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        resultSet = dbo.select ("select chan_path from t_ip_doctype_channel where doctype_path='" + docTypPath + "'");
        while (resultSet.next ()) {
            list.add (resultSet.getString (1));
        }
    } catch (Exception ex) {
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
    String [] result = new String [list.size ()];
    for (int i = 0; i < result.length; i ++) {
        result [i] = (String) list.get (i);
    }
    return result;
}


-----Function Pair=348=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public RestServiceResult listbyId (RestServiceResult serviceResult, Long nSingleTextFormId) {
    MaSingleTextForm maSingleTextForm = new MaSingleTextFormDAO ().findById (nSingleTextFormId);
    EntityManagerHelper.refresh (maSingleTextForm);
    if (maSingleTextForm == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("singleTextForm.search.notFound"));
    }
    else {
        List < MaSingleTextForm > list = new ArrayList < MaSingleTextForm > ();
        if (list.size () == 0) {
            Object [] arrayParam = {maSingleTextForm.getSingleTextFormId ()};
            serviceResult.setError (true);
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("singleTextForm.listbyId.notFound"), arrayParam));
        }
        else {
            Object [] arrayParam = {list.size (), maSingleTextForm.getSingleTextFormId ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("singleTextForm.listbyId.success"), arrayParam));
            serviceResult.setObjResult (list);
            serviceResult.setNumResult (list.size ());
        }
    }
    return serviceResult;
}


-----Function Pair=349=-----==

public boolean sendMessage (mail mail) {
    boolean result = false;
    PreparedStatement pstmt;
    try {
        pstmt = getCon ().prepareStatement ("insert into mail(toid,fromid,pmdatetime,title,content,stat,gname) values (?,?,?,?,?,?,?)");
        pstmt.setString (1, mail.getToid ());
        pstmt.setString (2, mail.getFromid ());
        pstmt.setString (3, mail.getPmdatetime ());
        pstmt.setString (4, mail.getTitle ());
        pstmt.setString (5, mail.getContent ());
        pstmt.setString (6, mail.getStat ());
        pstmt.setString (7, mail.getGname ());
        int num = pstmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return result;
}


public int createTaxFeatures (int C_Country_ID, String defaultEntry) {
    int C_TaxCategory_ID = getNextID (getAD_Client_ID (), "C_TaxCategory");
    StringBuffer sqlCmd = new StringBuffer ("INSERT INTO C_TaxCategory ");
    sqlCmd.append ("(C_TaxCategory_ID,").append (m_stdColumns).append (",");
    sqlCmd.append (" Name,IsDefault) VALUES (");
    sqlCmd.append (C_TaxCategory_ID).append (",").append (m_stdValues).append (", ");
    if (C_Country_ID == 100) {
        sqlCmd.append ("'Sales Tax','Y')");
    }
    else {
        sqlCmd.append (defaultEntry).append ("'Y')");
    }
    int no = DB.executeUpdate (sqlCmd.toString (), m_trx.getTrxName ());
    if (no != 1) {
        log.log (Level.SEVERE, "TaxCategory NOT inserted");
    }
    MTax tax = new MTax (m_ctx, "Standard", Env.ZERO, C_TaxCategory_ID, m_trx.getTrxName ());
    tax.setIsDefault (true);
    tax.setTaxType (MTax.TAXTYPE_General);
    if (tax.save ()) {
        m_info.append (Msg.translate (m_lang, "C_Tax_ID")).append ("=").append (tax.getName ()).append ("\n");
    }
    else {
        log.log (Level.SEVERE, "Tax NOT inserted");
    }
    return C_TaxCategory_ID;
}


-----Function Pair=350=-----==

public Map getAllWords (int currentpage) {
    Map map = new HashMap ();
    List < Words > list = null;
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Words as w");
        session.flush ();
        int totalsize = query.list ().size ();
        int pagesize = 30;
        int totalpage = 1;
        int startid = 0;
        if (totalsize > pagesize) {
            if (totalsize % pagesize == 0) {
                totalpage = (int) ((double) totalsize / (double) pagesize);
            }
            else {
                totalpage = (int) (1.0 + (double) totalsize / (double) pagesize);
            }
        }
        if (currentpage > 1) {
            if (currentpage > totalpage) {
                currentpage = totalpage;
            }
        }
        else {
            currentpage = 1;
        }
        startid = (currentpage - 1) * pagesize;
        query.setFetchSize (pagesize);
        query.setFirstResult (startid);
        query.setMaxResults (pagesize);
        list = query.list ();
        map.put (PageForm.LIST, list);
        map.put (PageForm.CURRENTPAGE, currentpage);
        map.put (PageForm.TOTALPAGE, totalpage);
        map.put (PageForm.TOTALSIZE, totalsize);
        session.flush ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
    }
    if (tr != null) tr.commit ();
    return map;
}


public Object executeQuery (String query, int queryTimeOut, int type) throws DException {
    if (verbose) PrintHandler.print (query, null, verboseUser);
    try {
        if (connectionStatus) throw new DException ("DSE279", null);
        Object parsedQuery = Parser.parseQuery (query);
        if (parsedQuery instanceof queryexpression) {
            {
                userSession.startTransaction ();
            }
            queryexpression qurexp = (queryexpression) parsedQuery;
            int tp = IteratorConstants.NONSCROLLABLE;
            ServerSessionWrapper sersewr = new ServerSessionWrapper (this);
            if (type == IteratorConstants.UPDATABLE) tp = qurexp.isSimpleQuery (sersewr) ? IteratorConstants.UPDATABLE : IteratorConstants.NONSCROLLABLE;
            sersewr.setType (tp);
            _Executer executer = (_Executer) qurexp.run (sersewr);
            return executer.execute ((Object []) null);
        }
    } catch (DException de) {
        throw de;
    } catch (RuntimeException de) {
        throw de;
    }
    throw new DException ("DSE86", null);
}


-----Function Pair=351=-----==

public Value getValue (Identifier iid) {
    try {
        RIdentifier id = (RIdentifier) iid;
        Statement stm = getConnection ().createStatement ();
        RKeyValue kv = id.getKeyValue ();
        RKey k = kv.getKey ();
        String keyAttribute = k.getName ();
        String keyTable = k.getTable ();
        String keyValue = kv.getKeyRef ();
        String valueAttribute = id.getName ();
        Chrono.setMode (Chrono.QUERY_MODE);
        String queryString = "SELECT " + valueAttribute + " " + "FROM " + keyTable + " " + "WHERE " + keyAttribute + "='" + keyValue + "'";
        logger.debug ("queryString=" + queryString);
        ResultSet rs = stm.executeQuery (queryString);
        rs.next ();
        Value v = ValueFactory.createValue (rs.getString (1));
        stm.close ();
        Chrono.setMode (Chrono.CPU_MODE);
        return v;
    } catch (Exception e) {
        logger.debug (e);
        return null;
    }
}


public static void batchInsertOrder (Order o) throws AppException {
    Connection conn = DBUtils.getDataConnection ();
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    String sqlOrder = null;
    String sqlDetail = null;
    try {
        conn.setAutoCommit (false);
        sqlOrder = "insert into SO_SOMain (ID,cSOCode,dDate," + "cBusType,cCusCode,cCusName," + "cDepCode,cSTCode," + "iVTid,cMaker,cMemo) values (?,?,?,?,?,?,?,?,?,?,?)";
        sqlDetail = "insert into SO_SODetails (ID,cSOCode,cInvCode,cInvName," + "iNum,iQuantity,iTaxUnitPrice,iSum,dPreDate,iSOsID,cFree1,cUnitID) values(?,?,?,?,?,?,?,?,?,?,?,?)";
        pstmt = conn.prepareStatement (sqlOrder);
        long maxId = getMaxID (conn, pstmt, rs);
        maxId ++;
        pstmt.setLong (1, maxId);
        Long l = maxId;
        o.setId (l.intValue ());
        String code = o.getCode ();
        long maxCSOCode = getMaxCSOCode (code, conn, pstmt, rs);
        String csOCode = getCSOCode (code, maxCSOCode);
        o.setCode (csOCode);
        pstmt.setString (2, csOCode);
        pstmt.setDate (3, DateUtil.getSqlDateFormUtilDate (o.getOrderDate ()));
        pstmt.setString (4, o.getBusinessType ());
        pstmt.setString (5, o.getC ().getId ());
        pstmt.setString (6, o.getC ().getName ());
        pstmt.setString (7, o.getP ().getDept ().getId ());
        pstmt.setString (8, o.getSaleType ().getId ());
        pstmt.setInt (9, o.getiVtid ());
        pstmt.setString (10, o.getP ().getName ());
        pstmt.setString (11, o.getRemark ());
        pstmt.executeUpdate ();
        pstmt.clearParameters ();
        pstmt = conn.prepareStatement (sqlDetail);
        ArrayList < OrderDetail > ods = o.getOds ();
        long iSOsID = getiSOsID (conn, pstmt, rs);
        for (OrderDetail od : ods) {
            pstmt.setLong (1, maxId);
            pstmt.setString (2, csOCode);
            pstmt.setString (3, od.getInventory ().getId ());
            pstmt.setString (4, od.getInventory ().getName ());
            pstmt.setInt (5, od.getPiece ());
            pstmt.setBigDecimal (6, od.getCount ());
            pstmt.setBigDecimal (7, od.getPrice ());
            pstmt.setBigDecimal (8, od.getSum ());
            pstmt.setDate (9, DateUtil.getSqlDateFormUtilDate (od.getSendDate ()));
            pstmt.setLong (10, ++ iSOsID);
            pstmt.setString (11, od.getPacking ().getcValue ());
            pstmt.setString (12, od.getInventory ().getSAComUnitCode ());
            pstmt.executeUpdate ();
            pstmt.clearParameters ();
        }
        conn.commit ();
    } catch (SQLException sqle) {
        try {
            conn.rollback ();
            throw new AppException (sqle.getMessage ());
        } catch (SQLException ex) {
            Logger.getLogger (OrderDAO.class.getName ()).log (Level.SEVERE, null, ex);
            throw new AppException (ex.getMessage ());
        }
    } finally {
        DBUtils.closeAll (rs, pstmt, conn);
    }
}


-----Function Pair=352=-----==

public ArrayList getAllocateByTID (int tid) {
    ArrayList aList = new ArrayList ();
    allocate al = null;
    try {
        PreparedStatement pstmt = getCon ().prepareStatement ("select * from allocate where tid = ?");
        pstmt.setInt (1, tid);
        ResultSet rs = pstmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                al = new allocate ();
                al.setUid (rs.getInt ("uid"));
                al.setTid (rs.getInt ("tid"));
                aList.add (al);
            }
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return aList;
}


public List < Forums > getForumsList (List < Short > fidList) {
    Session session = null;
    Transaction tran = null;
    Forums forum = null;
    List < Forums > list = new ArrayList < Forums > ();
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tran = session.beginTransaction ();
        for (int i = 0; i < fidList.size (); i ++) {
            forum = (Forums) session.get (Forums.class, fidList.get (i));
            if (forum != null) {
                list.add (forum);
            }
            else {
                try {
                    throw new Exception ("û�л��ID��ָ����Forumsʵ��");
                } catch (Exception exception) {
                    exception.printStackTrace ();
                }
            }
        }
        tran.commit ();
    } catch (HibernateException e) {
        if (tran != null) {
            tran.rollback ();
        }
        e.printStackTrace ();
    }
    return list;
}


-----Function Pair=353=-----==

public void doNew (Vector userId, String shareFlag, String folderId) throws AddrException {
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement ps = null;
    ResultSet rset = null;
    String sql = "insert into " + SHARE_TABLE + " values(?,?,?)";
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        connection.setAutoCommit (false);
        for (int i = 0; i < userId.size (); i ++) {
            String user = (String) userId.elementAt (i);
            ps = connection.prepareStatement (sql);
            ps.setInt (1, Integer.parseInt (folderId));
            ps.setInt (2, Integer.parseInt (user));
            ps.setString (3, shareFlag);
            int resultCount = ps.executeUpdate ();
            if (resultCount != 1) {
                throw new Exception ("error");
            }
        }
        connection.commit ();
    } catch (Exception ex) {
        if (connection != null) {
            try {
                connection.rollback ();
            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
        logger.error ("���������ļ�����Ϣʧ��, " + ex.getMessage ());
        throw new AddrException ("���������ļ�����Ϣʧ��,һ�������ļ���ֻ�ܹ����ͬһ�û�һ��!");
    } finally {
        close (rset, null, ps, connection, dbo);
    }
}


protected void fastDeleteItemsByID (long [] ids) {
    log.debug ("fastDeleteItemsByID entered");
    if (ids == null || ids.length == 0) {
        log.debug ("fastDeleteItemsByID exited (list empty)");
        return;
    }
    synchronized (session) {
        log.debug ("start delete " + ids.length + " items");
        Transaction tx = session.beginTransaction ();
        try {
            int currentIndex = 0;
            while (currentIndex < ids.length) {
                int nextGroup = Math.min (ids.length - currentIndex, 1000);
                StringBuilder sb = new StringBuilder ("delete from Learning_Filter_Item where id in (");
                for (int i = 0; i < nextGroup; i ++) {
                    sb.append (ids [currentIndex + i]).append (',');
                }
                sb.setCharAt (sb.length () - 1, ')');
                Query query = session.createSQLQuery (sb.toString ()).setCacheable (false);
                query.executeUpdate ();
                currentIndex += nextGroup;
            }
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in fastDeleteItems: ", e);
            tx.rollback ();
        }
        log.debug ("delete finished");
        maxHamOccurences = - 1;
        maxSpamOccurences = - 1;
        session.flush ();
        session.clear ();
        cache.resetCache ();
    }
    fireDataChange (PART.ITEMS);
    log.debug ("fastDeleteItemsByID exited");
}


-----Function Pair=354=-----==

public void updateSmsRecptnInf (SmsRecptn smsRecptn) throws Exception {
    Connection conn = null;
    PreparedStatement pstmt = null;
    StringBuffer buffer = new StringBuffer ();
    try {
        buffer.append ("UPDATE COMTNSMSRECPTN SET\n");
        buffer.append ("  RESULT_CODE = ?,\n");
        buffer.append ("  RESULT_MSSAGE = ?\n");
        buffer.append ("WHERE \n");
        buffer.append ("  SMS_ID = ? AND RECPTN_TELNO = ?");
        conn = SmsBasicDBUtil.getConnection ();
        pstmt = conn.prepareStatement (buffer.toString ());
        int index = 0;
        pstmt.setString (++ index, smsRecptn.getResultCode ());
        pstmt.setString (++ index, smsRecptn.getResultMssage ());
        pstmt.setString (++ index, smsRecptn.getSmsId ());
        pstmt.setString (++ index, smsRecptn.getRecptnTelno ());
        pstmt.executeUpdate ();
    } finally {
        SmsBasicDBUtil.close (null, pstmt, conn);
    }
}


public List getContacts (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Contact R where R.userId=? order by R.fullName";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=355=-----==

public static Funcionario selectByLogin (String login) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Funcionario objFuncionario = null;
    if (c == null) {
        return null;
    }
    try {
        String sql = "Select * from funcionario where login = ?";
        pst = c.prepareStatement (sql);
        pst.setString (1, login);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objFuncionario = new Funcionario ();
            objFuncionario.setCodigo (rs.getInt ("id_funcionario"));
            objFuncionario.setNome (rs.getString ("nome"));
            objFuncionario.setCpf (rs.getString ("cpf"));
            objFuncionario.setEmail (rs.getString ("email"));
            objFuncionario.setLogin (rs.getString ("login"));
            objFuncionario.setSenha (rs.getString ("senha"));
            objFuncionario.setTelefone (rs.getString ("telefone"));
            objFuncionario.setCargo (CargoDAO.selectByID (rs.getString ("id_cargo")));
        }
    } catch (SQLException e) {
        System.out.println ("[FuncionarioDAO.selectByLogin] Erro ao atualizar -> " + e.getMessage ());
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objFuncionario;
}


public static void delete (JDCConnection oConn, String sFolderId, String sMimeMsgId) throws SQLException, IOException {
    Statement oStmt;
    CallableStatement oCall;
    if (DebugFile.trace) {
        DebugFile.writeln ("Begin DBMimeMessage.delete([Connection], " + sMimeMsgId + ")");
        DebugFile.incIdent ();
    }
    oStmt = oConn.createStatement (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    ResultSet oRSet = oStmt.executeQuery ("SELECT " + DB.file_name + " FROM " + DB.k_mime_parts + " WHERE " + DB.gu_mimemsg + "='" + sMimeMsgId + "' AND " + DB.id_disposition + "='reference'");
    while (oRSet.next ()) {
        String sFileName = oRSet.getString (1);
        if (! oRSet.wasNull ()) {
            try {
                File oRef = new File (sFileName);
                oRef.delete ();
            } catch (SecurityException se) {
                if (DebugFile.trace) DebugFile.writeln ("SecurityException " + sFileName + " " + se.getMessage ());
            }
        }
    }
    oRSet.close ();
    oRSet = null;
    oStmt.close ();
    oStmt = null;
    if (oConn.getDataBaseProduct () == JDCConnection.DBMS_POSTGRESQL) {
        oStmt = oConn.createStatement ();
        oStmt.executeQuery ("SELECT k_sp_del_mime_msg('" + sMimeMsgId + "')");
        oStmt.close ();
    }
    else {
        oCall = oConn.prepareCall ("{ call k_sp_del_mime_msg(?) }");
        oCall.setString (1, sMimeMsgId);
        oCall.execute ();
        oCall.close ();
    }
    if (DebugFile.trace) {
        DebugFile.decIdent ();
        DebugFile.writeln ("End DBMimeMessage.delete()");
    }
}


-----Function Pair=356=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


protected boolean isExist (Connection con) throws Exception {
    boolean returnValue = false;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT record_no FROM " + Common.ORGANIZE_BAK_RECORD_TABLE + " WHERE record_no = ?";
    try {
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.recordNO);
        result = ps.executeQuery ();
        if (! result.next ()) {
            returnValue = false;
        }
        else {
            String strTemp = result.getString (1);
            returnValue = true;
        }
    } catch (SQLException se) {
        throw new CesSystemException ("Organize_backup.isExist(): SQLException: \n\t" + se);
    } finally {
        closeResultSet (result);
        closePreparedStatement (ps);
    }
    return returnValue;
}


-----Function Pair=357=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            if (person.getHomeState () == State.AZ) {
                person.setIncome (IncomeGroup.aboveaverage);
            }
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public String recognizeSubBlock (BufferedReader reader, char action, Vector block) throws IOException {
    if (! reader.ready ()) return null;
    String current;
    do {
        current = reader.readLine ();
        if (current == null || current.length () == 0) continue;
        switch (current.charAt (0)) {
            case comment :
                continue;
            case createSchema :
            case createTable :
            case insert :
            case dropSchema :
            case dropTable :
                return current;
            default :
                block.addElement (current);
        }
    }
    while (reader.ready ());
    return null;
}


-----Function Pair=358=-----==

public void testMultipleResults0015 () throws Exception {
    Connection cx = getConnection ();
    dropTable ("#t0015");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("create table #t0015 " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    PreparedStatement pStmt = cx.prepareStatement ("insert into #t0015 values (?, ?)");
    int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pStmt.setInt (1, i);
        pStmt.setString (2, theString.substring (0, i));
        count += pStmt.executeUpdate ();
    }
    assertTrue (count == rowsToAdd);
    stmt = cx.createStatement ();
    ResultSet rs = stmt.executeQuery ("select s from #t0015 select i from #t0015");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    assertTrue (stmt.getMoreResults ());
    rs = stmt.getResultSet ();
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    rs = stmt.executeQuery ("select i, s from #t0015");
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    cx.close ();
}


public List < List > selectBySQL (String nomeConsulta, Parametro parametros) throws ExcecaoSistema, ExcecaoNegocio {
    NullPointerException nullEx = null;
    if (nomeConsulta == null) {
        nullEx = new NullPointerException ("O argumento nomeConsulta possui valor nulo.");
        logger.fatal ("Erro ao inicializar os parametros do selec", nullEx);
        throw nullEx;
    }
    logger.debug ("selectBySQL >> [Consulta por querySQL : " + nomeConsulta + "]");
    EntityManager manager = this.getSessao ().getEntityManager ();
    Query query = manager.createNamedQuery (nomeConsulta);
    List < List > lista = null;
    if (parametros != null) {
        for (Map.Entry < String, Object > e : parametros.entrySet ()) {
            logger.debug ("Parametros para consulta - [nomeCampo = " + e.getKey () + "][valorProcurado = " + e.getValue () + "]");
            query.setParameter (e.getKey (), e.getValue ());
        }
    }
    else {
        logger.debug ("Os parametros para esta consulta s�o nulos");
    }
    try {
        logger.debug ("transa��o iniciada...");
        lista = query.getResultList ();
        logger.debug ("pesquisa finalizada...");
    } catch (Exception ex) {
        logger.error ("Erro ao tentar executar uma consulta por SQL " + nomeConsulta, ex);
        GerenciadorExcecao.tratarExcecao (ex, nomeConsulta);
    } finally {
        if (manager.getTransaction ().isActive ()) {
            logger.debug ("transa��o ainda est� ativa...");
            logger.debug ("fechando transa��o...");
            manager.getTransaction ().rollback ();
            logger.debug ("transa��o fechada com sucesso...");
        }
    }
    if (lista != null && lista.size () > 0) {
        for (Object m : lista) {
            logger.debug ("Objeto localizado: " + m);
        }
    }
    else {
        this.lancarExcecaoEntidadeNaoEncontrada ();
    }
    logger.debug ("select <<");
    return lista;
}


-----Function Pair=359=-----==

public static boolean insereAutor (final Connection con) {
    Autor aut = new Autor ();
    GeraID.gerarCodAutor (con, aut);
    aut.setNome (TelaNovoAutor.getNomeTF ().getText ());
    aut.setEmail (TelaNovoAutor.getEmailTF ().getText ());
    String nome = aut.getNome ().replaceAll ("['\"]", "");
    String email = aut.getEmail ().replaceAll ("['\"]", "");
    try {
        Statement smt = con.createStatement ();
        smt.executeUpdate ("INSERT INTO autor VALUES(" + aut.getCodAutor () + ",'" + nome + "','" + email + "')");
        TelaCadastro.getAutorCB ().setModel (new DefaultComboBoxModel (recuperaNomeAutores (con)));
        return true;
    } catch (SQLException e) {
        System.err.print (e.getMessage ());
        return false;
    }
}


public void run () throws Exception {
    logger.debug ("#run enter");
    logger.debug ("#run lineId : " + lineId);
    logger.debug ("#run quantityNew : " + quantityNew);
    logger.debug ("#run priceNew : " + priceNew);
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        connection.setAutoCommit (false);
        Integer itemId = null;
        Integer quantity = null;
        ps = connection.prepareStatement (SQL_SELECT_ORDER_LINE);
        ps.setInt (1, lineId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            itemId = rs.getInt ("ITEM_ID");
            quantity = rs.getInt ("QUANTITY");
        }
        rs.close ();
        ps.close ();
        ps = connection.prepareStatement (SQL_UPDATE_ITEM_BALANCE);
        ps.setInt (1, quantityNew - quantity);
        ps.setInt (2, itemId);
        ps.executeUpdate ();
        ps = connection.prepareStatement (SQL_UPDATE_ORDER_LINE);
        ps.setDouble (1, priceNew);
        ps.setInt (2, quantityNew);
        ps.setInt (3, lineId);
        ps.executeUpdate ();
        ps.close ();
        ps.close ();
        connection.commit ();
    } catch (SQLException ex) {
        logger.error ("SQLException", ex);
        connection.rollback ();
        throw new Exception ("Не удалось обновить позицию в заказе. Ошибка : " + ex.getMessage ());
    } finally {
        connection.setAutoCommit (true);
    }
    logger.debug ("#run exit");
}


-----Function Pair=360=-----==

public static void main (String [] args) {
    try {
        Class.forName ("org.hsqldb.jdbcDriver");
    } catch (ClassNotFoundException e) {
        System.out.println ("HSQL Driver not found.");
        System.exit (1);
    }
    Connection con = null;
    try {
        con = DriverManager.getConnection ("jdbc:hsqldb:.", "sa", "");
        con.setAutoCommit (false);
    } catch (SQLException e) {
        System.out.println ("Connection error: " + e.getMessage ());
        System.exit (e.getErrorCode ());
    }
    String createTable = "CREATE TABLE NAMES (NAME VARCHAR(100))";
    Statement stmt = null;
    try {
        stmt = con.createStatement ();
        con.commit ();
        stmt.executeUpdate (createTable);
        con.commit ();
    } catch (SQLException e) {
        System.out.println ("Create table error: " + e.getMessage ());
        try {
            con.rollback ();
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    Vector names = new Vector (4);
    names.addElement ("FRANK");
    names.addElement ("FRED");
    names.addElement ("JACK");
    names.addElement ("JIM");
    String ins = "INSERT INTO NAMES VALUES (?)";
    PreparedStatement pstmt = null;
    try {
        con.commit ();
        pstmt = con.prepareStatement (ins);
        for (int i = 0; i < names.size (); i ++) {
            pstmt.setString (1, (String) names.elementAt (i));
            pstmt.executeUpdate ();
        }
        con.commit ();
    } catch (SQLException e) {
        System.out.println ("Insert error: " + e.getMessage ());
        try {
            con.rollback ();
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    String selAll = "SELECT * FROM NAMES";
    ResultSet rs = null;
    stmt = null;
    try {
        stmt = con.createStatement ();
        rs = stmt.executeQuery (selAll);
        System.out.println ("SELECT * FROM NAMES");
        while (rs.next ()) {
            String name = rs.getString (1);
            System.out.println ("\t" + name);
        }
        stmt.close ();
    } catch (SQLException e) {
        System.out.println ("Select All error: " + e.getMessage ());
        try {
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    String selectLike = "SELECT * FROM NAMES WHERE NAME LIKE 'F%'";
    rs = null;
    stmt = null;
    try {
        stmt = con.createStatement ();
        rs = stmt.executeQuery (selectLike);
        System.out.println ("SELECT * FROM NAMES WHERE NAME LIKE 'F%'");
        while (rs.next ()) {
            String name = rs.getString (1);
            System.out.println ("\t" + name);
        }
        stmt.close ();
    } catch (SQLException e) {
        System.out.println ("Select Like error: " + e.getMessage ());
        try {
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    try {
        con.close ();
    } catch (SQLException e) {
    }
}


public List < FrostMessageObject > retrieveAllMessages () throws SQLException {
    LinkedList < FrostMessageObject > list = new LinkedList < FrostMessageObject > ();
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    String sql = "SELECT " + "primkey,messageid,inreplyto,msgdatetime,msgindex,fromname,subject,recipient," + "signaturestatus,publickey,isdeleted,isnew,isreplied,isjunk,isflagged,isstarred," + "hasfileattachment,hasboardattachment,idlinepos,idlinelen,board";
    sql += " FROM " + getMessageTableName ();
    PreparedStatement ps = db.prepareStatement (sql);
    ResultSet rs = ps.executeQuery ();
    while (rs.next ()) {
        int boardIx = rs.getInt ("board");
        Board board = MainFrame.getInstance ().getTofTreeModel ().getBoardByPrimaryKey (new Integer (boardIx));
        if (board == null) {
            continue;
        }
        FrostMessageObject mo = resultSetToFrostMessageObject (rs, board, true, true);
        list.add (mo);
    }
    rs.close ();
    ps.close ();
    return list;
}


-----Function Pair=361=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoCourse coCourse) {
    String sCourseName = null;
    try {
        sCourseName = coCourse.getCourseName ();
        log.error ("Eliminando el curso: " + coCourse.getCourseName ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_COURSE);
        query.setParameter (1, coCourse.getCourseId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sCourseName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.delete.success"), arrayParam));
        log.info ("Eliminando el curso: " + coCourse.getCourseName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coCourse.getCourseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


public static Vector getCourseList () throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        {
            r.clear ();
            r.add ("course_id");
            r.add ("course_code");
            r.add ("course_name");
            sql = r.getSQLSelect ("study_course");
            ResultSet rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("course_id"));
                h.put ("code", rs.getString ("course_code"));
                h.put ("name", rs.getString ("course_name"));
                list.addElement (h);
            }
            return list;
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=362=-----==

public Integer getAcDataProjectCount (Integer projectId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (AcDataProject.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" data.id = '" + projectId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public static File chooseFileOpen (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showOpenDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


-----Function Pair=363=-----==

public RestServiceResult addStudent (RestServiceResult serviceResult, Long nCourseId, String sArrayStudent, boolean isFile) {
    List < MaUser > listUserInsert = null;
    String sSql = "";
    Query query = null;
    try {
        CoCourse coCourse = new CoCourseDAO ().findById (nCourseId);
        if (coCourse == null) {
            serviceResult.setMessage (bundle.getString ("course.search.notFound"));
            serviceResult.setError (true);
        }
        else {
            EntityManagerHelper.beginTransaction ();
            if (! isFile) {
                sSql = Statements.UPDATE_FLAG_Y_STUDENTS;
                sSql = sSql.replaceFirst ("v1", sArrayStudent);
                query = EntityManagerHelper.createNativeQuery (sSql);
                query.setParameter (1, "Y");
                query.setParameter (2, nCourseId);
                query.executeUpdate ();
            }
            sSql = Statements.UPDATE_FLAG_N_STUDENTS;
            sSql = sSql.replaceFirst ("v1", sArrayStudent);
            query = EntityManagerHelper.createNativeQuery (sSql);
            query.setParameter (1, "N");
            query.setParameter (2, nCourseId);
            query.executeUpdate ();
            sSql = Statements.SELECT_MA_USER_IN;
            sSql = sSql.replaceFirst ("v1", sArrayStudent);
            query = EntityManagerHelper.createNativeQuery (sSql, MaUser.class);
            query.setHint (QueryHints.REFRESH, HintValues.TRUE);
            listUserInsert = query.getResultList ();
            for (Iterator < MaUser > iterator = listUserInsert.iterator (); iterator.hasNext ();) {
                MaUser maUser = iterator.next ();
                query = EntityManagerHelper.createNativeQuery (Statements.SELECT_EXIST_STUDENT_COURSE, CoCourseUser.class);
                query.setParameter (1, maUser.getUserId ());
                query.setParameter (2, nCourseId);
                query.setHint (QueryHints.REFRESH, HintValues.TRUE);
                Vector vecResult = (Vector) query.getResultList ();
                if (vecResult.size () == 0) {
                    CoCourseUserId coCourseUserHistoryId = new CoCourseUserId (maUser.getUserId (), coCourse.getCourseId ());
                    CoCourseUser coCourseUser = new CoCourseUser ();
                    coCourseUser.setCoCourse (coCourse);
                    coCourseUser.setMaUser (maUser);
                    coCourseUser.setFlagDeleted ("N");
                    coCourseUser.setId (coCourseUserHistoryId);
                    new CoCourseUserDAO ().save (coCourseUser);
                }
                else {
                }
            }
            EntityManagerHelper.commit ();
            Object [] arrayParam = {coCourse.getCourseName ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.addStudent.success"), arrayParam));
        }
    } catch (PersistenceException e) {
        e.printStackTrace ();
        Object [] arrayParam = {e.getMessage ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.addStudent.error)"), arrayParam));
        serviceResult.setError (true);
        EntityManagerHelper.rollback ();
    }
    return serviceResult;
}


public static Vector getAvailableSessions (String student_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        Hashtable statusList = new Hashtable ();
        {
            sql = "select status_id, status_name from study_status";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                statusList.put (rs.getString (1), rs.getString (2));
            }
        }
        Vector v = new Vector ();
        {
            r.clear ();
            r.add ("sta.student_id", student_id);
            r.add ("sta.session_id", r.unquote ("ses.session_id"));
            r.add ("sta.batch_id", r.unquote ("ses2.session_id"));
            r.add ("sc.student_id", r.unquote ("sta.student_id"));
            r.add ("sta.session_id");
            r.add ("sta.batch_id");
            r.add ("sta.repeat_no");
            r.add ("sta.status");
            r.add ("ses.session_name");
            r.add ("ses2.session_name as batch_session");
            r.add ("sc.period_root_id as period_scheme");
            sql = r.getSQLSelect ("student_course sc, student_status sta, sessions ses, sessions ses2", "ses.start_date");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                String period_scheme = rs.getString ("period_scheme");
                String session_id = rs.getString ("session_id");
                String session_name = rs.getString ("session_name");
                String batch_id = rs.getString ("batch_id");
                Hashtable h = new Hashtable ();
                h.put ("period_scheme", period_scheme);
                h.put ("session_id", session_id);
                h.put ("session_name", session_name);
                h.put ("batch_id", batch_id);
                h.put ("repeat_no", new Integer (rs.getInt ("repeat_no")));
                v.addElement (h);
            }
        }
        for (int i = 0; i < v.size (); i ++) {
            Hashtable h = (Hashtable) v.elementAt (i);
            String period_scheme = (String) h.get ("period_scheme");
            String batch_id = (String) h.get ("batch_id");
            String session_id = (String) h.get ("session_id");
            sql = "select i.period_id " + "from intake_batch i " + "where i.period_root_id = '" + period_scheme + "' " + "and i.intake_session = '" + batch_id + "' " + "and i.session_id = '" + session_id + "' ";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                String period_id = rs.getString (1);
                h.put ("period_id", period_id);
                createPeriodName (h);
            }
        }
        boolean canSetRepeat = true;
        for (int i = v.size () - 1; i > - 1; i --) {
            Hashtable h = (Hashtable) v.elementAt (i);
            int repeat_no = ((Integer) h.get ("repeat_no")).intValue ();
            h.put ("canSetRepeat", new Boolean (canSetRepeat));
            if (repeat_no > 0) {
                canSetRepeat = false;
            }
        }
        return v;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=364=-----==

public Boolean executeUpdateTransaction (DatabaseQuery [] aDatabaseQueries) {
    Integer iPos = 0;
    PreparedStatement [] aQueries = this.getPreparedStatements (aDatabaseQueries);
    Connection oConnection = this.getConnection ();
    Boolean bAutoCommit = true;
    if (aQueries.length == 0) {
        return true;
    }
    if (oConnection == null) {
        return false;
    }
    try {
        bAutoCommit = oConnection.getAutoCommit ();
        oConnection.setAutoCommit (false);
        for (iPos = 0; iPos < aQueries.length; iPos ++) {
            aQueries [iPos].executeUpdate ();
            aQueries [iPos].close ();
        }
        if (bAutoCommit) {
            oConnection.commit ();
            oConnection.setAutoCommit (true);
        }
    } catch (SQLException oException) {
        if (this.reloadConnection ()) return this.executeUpdateTransaction (aDatabaseQueries);
        else {
            try {
                oConnection.rollback ();
            } catch (SQLException oRollbackException) {
                throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, Strings.ROLLBACK, oRollbackException);
            }
            throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, this.getQueries (aDatabaseQueries).toString (), oException);
        }
    } finally {
        try {
            oConnection.setAutoCommit (bAutoCommit);
        } catch (SQLException oException) {
            throw new SystemException (ErrorCode.CLOSE_QUERY, null, oException);
        }
    }
    return true;
}


public void onServiceStartedEvent (ServiceStartedEvent event, ActivityContextInterface aci) {
    tracer.info ("JDBC Example started.");
    JdbcActivity jdbcActivity = jdbcRA.createActivity ();
    tracer.info ("Created JDBC RA activity, using RA's SBB Interface.");
    ActivityContextInterface jdbcACI = jdbcACIF.getActivityContextInterface (jdbcActivity);
    jdbcACI.attach (contextExt.getSbbLocalObject ());
    tracer.info ("Retrieved the ACI related to the JDBC RA activity, and attached the sbb entity.");
    SimpleJdbcTask task = new SimpleJdbcTask () {
        @Override
        public Object executeSimple (JdbcTaskContext context) {
            SleeTransaction tx = null;
            try {
                tx = context.getSleeTransactionManager ().beginSleeTransaction ();
                Connection connection = context.getConnection ();
                Statement statement = connection.createStatement ();
                tracer.info ("Created statement to create table, executing query...");
                statement.execute ("CREATE TABLE TestTable (Name VARCHAR(30));");
                PreparedStatement preparedStatement = connection.prepareStatement ("INSERT INTO TestTable VALUES(?)");
                preparedStatement.setString (1, "Mobicents");
                tracer.info ("Created prepared statement for data insert, executing...");
                preparedStatement.execute ();
                preparedStatement = connection.prepareStatement ("SELECT ? From TestTable;");
                preparedStatement.setString (1, "Name");
                tracer.info ("Created prepared statement for data query, executing...");
                preparedStatement.execute ();
                ResultSet resultSet = preparedStatement.getResultSet ();
                resultSet.next ();
                tracer.info ("Data query first result: " + resultSet.getString (1));
                Statement anotherStatement = connection.createStatement ();
                tracer.info ("Created statement to drop table, executing update...");
                anotherStatement.executeUpdate ("DROP TABLE TestTable;");
                tx.commit ();
                tx = null;
                return true;
            } catch (Exception e) {
                tracer.severe ("failed to create table", e);
                if (tx != null) {
                    try {
                        tx.rollback ();
                    } catch (Exception f) {
                        tracer.severe ("failed to rollback tx", f);
                    }
                }
                return false;
            }
        }
    }
    ;
    jdbcActivity.execute (task);
}


-----Function Pair=365=-----==

private void insertDescriptions (Connection con, AIDADocument item) throws SQLException {
    String [] langs = item.getAvailableLanguages ();
    if ((langs == null) || (langs.length < 1)) {
        return;
    }
    try {
        PreparedStatement ps = con.prepareStatement (DESC_INSERT);
        for (int i = 0; i < langs.length; i ++) {
            ps.clearParameters ();
            ps.setLong (1, item.getId ());
            ps.setString (2, langs [i]);
            ps.setString (3, item.getDesc (langs [i]));
            ps.setString (4, item.getTitle (langs [i]));
            ps.executeUpdate ();
        }
        ps.close ();
    } catch (SQLException sqlEx) {
        throw sqlEx;
    }
    return;
}


public List < DatabaseItem > getDatabases (String type) {
    List < DatabaseItem > db = null;
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + DATABASE_ITEM_TABLE + " o  where o.type =:type");
        query.setString ("type", type);
        db = query.list ();
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return db;
}


-----Function Pair=366=-----==

private static byte [] getDocumentBLOB (Connection con, String sID, String sVer) throws SQLException {
    byte [] retData = null;
    PreparedStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocInfo");
    try {
        ps = con.prepareStatement (sSql);
        ps.setString (1, sID);
        ps.setString (2, sVer);
        OracleResultSet rSet = (OracleResultSet) ps.executeQuery ();
        if (rSet.next ()) {
            BLOB blobDoc = (BLOB) rSet.getBlob ("BOBJDATA");
            retData = blobDoc.getBytes (1, (int) blobDoc.length ());
        }
        rSet.close ();
    } finally {
        if (ps != null) ps.close ();
    }
    return retData;
}


protected Context start (PTask pt, String w, SyrupConnection con) throws Exception {
    PreparedStatement s = null;
    ResultSet result = null;
    try {
        s = con.prepareStatementFromCache (sqlImpl ().sqlStatements ().checkIsExecutableTaskStatement ());
        s.setString (1, pt.key ());
        result = s.executeQuery ();
        if (result.next ()) {
            java.util.Date dd = new java.util.Date ();
            PreparedStatement s2 = null;
            s2 = con.prepareStatementFromCache (sqlImpl ().sqlStatements ().updateWorkerStatement ());
            s2.setString (1, w);
            s2.setString (2, pt.key ());
            s2.executeUpdate ();
            sqlImpl ().loggingFunctions ().log (pt.key (), LogEntry.STARTED, con);
            Context c = sqlImpl ().queryFunctions ().readContext (pt, con);
            con.commit ();
            return c;
        }
    } finally {
        con.rollback ();
        sqlImpl ().genericFunctions ().close (result);
    }
    return null;
}


-----Function Pair=367=-----==

public static Any getDocVer (Connection con, Any values, Any retValue) throws SQLException {
    HashMap v = (HashMap) values.extract_Value ();
    String sID = (String) v.get ("ID");
    boolean bCard = (Boolean) v.get ("ISCARD");
    PreparedStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocVer");
    if (bCard) sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocCardVer");
    try {
        ps = con.prepareStatement (sSql);
        ps.setString (1, sID);
        ResultSet rSet = ps.executeQuery ();
        ArrayList < HashMap > arRet = new ArrayList < HashMap > ();
        while (rSet.next ()) {
            HashMap val = new HashMap ();
            val.put ("VER", rSet.getString ("IOBJVER"));
            arRet.add (val);
        }
        rSet.close ();
        retValue.insert_Value (arRet.toArray (new HashMap [arRet.size ()]));
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


public void testBigDecimal1 () throws Exception {
    Statement stmt = con.createStatement ();
    ResultSet rs = stmt.executeQuery ("SELECT @@MAX_PRECISION");
    assertTrue (rs.next ());
    int maxPrecision = rs.getInt (1);
    rs.close ();
    BigDecimal maxval = new BigDecimal ("1E+" + maxPrecision);
    maxval = maxval.subtract (new BigDecimal (1));
    if (maxPrecision > 28) {
        stmt.execute ("create table #testBigDecimal1 (id int primary key, data01 decimal(38,0), data02 decimal(38,12) null, data03 money)");
    }
    else {
        stmt.execute ("create table #testBigDecimal1 (id int primary key, data01 decimal(28,0), data02 decimal(28,12) null, data03 money)");
    }
    PreparedStatement pstmt = con.prepareStatement ("insert into #testBigDecimal1 (id, data01, data02, data03) values (?,?,?,?)");
    pstmt.setInt (1, 1);
    try {
        pstmt.setBigDecimal (2, maxval.add (new BigDecimal (1)));
        assertTrue (false);
    } catch (SQLException e) {
    }
    pstmt.setBigDecimal (2, maxval);
    pstmt.setBigDecimal (3, new BigDecimal (1.0 / 3.0));
    pstmt.setBigDecimal (4, new BigDecimal ("12345.56789"));
    assertTrue (pstmt.executeUpdate () == 1);
    pstmt.close ();
    rs = stmt.executeQuery ("SELECT * FROM #testBigDecimal1");
    assertTrue (rs.next ());
    assertEquals (maxval, rs.getBigDecimal (2));
    assertEquals (new BigDecimal ("0.333333333333"), rs.getBigDecimal (3));
    assertEquals (new BigDecimal ("12345.5679"), rs.getBigDecimal (4));
    rs.close ();
    maxval = maxval.negate ();
    Statement stmt2 = con.createStatement (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    rs = stmt2.executeQuery ("SELECT * FROM #testBigDecimal1");
    SQLWarning warn = stmt.getWarnings ();
    while (warn != null) {
        System.out.println (warn.getMessage ());
        warn = warn.getNextWarning ();
    }
    assertTrue (rs.next ());
    rs.updateBigDecimal ("data01", maxval);
    rs.updateNull ("data02");
    rs.updateObject ("data03", new BigDecimal ("-12345.56789"), 2);
    rs.updateRow ();
    rs.close ();
    stmt2.close ();
    rs = stmt.executeQuery ("SELECT * FROM #testBigDecimal1");
    assertTrue (rs.next ());
    assertEquals (maxval, rs.getBigDecimal (2));
    assertEquals (null, rs.getBigDecimal (3));
    assertEquals (new BigDecimal ("-12345.5700"), rs.getBigDecimal (4));
    rs.close ();
    stmt.close ();
}


-----Function Pair=368=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoScoreQuestion coScoreQuestion) {
    String sUserName = null;
    try {
        sUserName = coScoreQuestion.getMaUser ().getUserName ();
        log.error ("Eliminando la calificaci�n del estudiante: " + sUserName);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_SCORE_QUESTION);
        query.setParameter (1, coScoreQuestion.getCoQuestion ().getQuestionId ());
        query.setParameter (2, coScoreQuestion.getMaUser ().getUserId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coScoreQuestion);
        Object [] arrayParam = {sUserName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreQuestion.delete.success"), arrayParam));
        log.info ("Eliminando la calificaci�n para el estudiante: " + sUserName);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la calificaci�n: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coScoreQuestion.getMaUser ().getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreQuestion.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


public static AddressFilterData loadFromDB () {
    Session session = DB.createSession ();
    synchronized (session) {
        Transaction tx = session.beginTransaction ();
        AddressFilterData data;
        try {
            Criteria criteria = session.createCriteria (AddressFilterData.class);
            data = (AddressFilterData) criteria.uniqueResult ();
            if (data == null) {
                data = new AddressFilterData ();
                session.save (data);
            }
            tx.commit ();
            data.setSession (session);
            return data;
        } catch (HibernateException e) {
            log.warn ("Exception in loadFromDB: ", e);
            tx.rollback ();
            throw (e);
        }
    }
}


-----Function Pair=369=-----==

public static Any getDocAttr (Connection con, Any values, Any retValue) throws SQLException {
    HashMap val = (HashMap) values.extract_Value ();
    String sID = (String) val.get ("ID");
    String sVer = (String) val.get ("VER");
    PreparedStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocCard");
    try {
        ps = con.prepareStatement (sSql);
        ps.setString (1, sID);
        ps.setString (2, sVer);
        OracleResultSet rSet = (OracleResultSet) ps.executeQuery ();
        while (rSet.next ()) {
            HashMap rv = new HashMap ();
            rv.put ("TYPENAME", rSet.getString ("CTYPNAME"));
            rv.put ("NAME", rSet.getString ("COBJNAME"));
            rv.put ("NUM", rSet.getString ("COBJNUM"));
            rv.put ("TYPEID", rSet.getString ("IDOCTID"));
            fireteam.orb.server.processors.types.AttributeList arAttrs = (fireteam.orb.server.processors.types.AttributeList) rSet.getORAData ("ATTRS", new fireteam.orb.server.processors.types.AttributeList ());
            fireteam.orb.server.processors.types.Attribute attrs [] = arAttrs.getArray ();
            FTSigns arSign = (FTSigns) rSet.getORAData ("SIGNS", new FTSigns ());
            FTSign signs [] = arSign.getArray ();
            ArrayList < HashMap > arAtr = new ArrayList < HashMap > ();
            for (fireteam.orb.server.processors.types.Attribute atr : attrs) {
                HashMap hm = new HashMap ();
                hm.put ("NAME", atr.getName ());
                hm.put ("VALUE", atr.getValue ());
                arAtr.add (hm);
            }
            rv.put ("ATTR", arAtr.toArray (new HashMap [arAtr.size ()]));
            arAtr.clear ();
            for (FTSign sign : signs) {
                HashMap hm = new HashMap ();
                hm.put ("LOGNAME", sign.getLogName ());
                hm.put ("NAME", sign.getUsrName ());
                hm.put ("DUTY", sign.getUsrDuty ());
                hm.put ("DATE", sign.getDateCreate ());
                arAtr.add (hm);
            }
            rv.put ("SIGNS", arAtr.toArray (new HashMap [arAtr.size ()]));
            retValue.insert_Value (rv);
        }
        rSet.close ();
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


private void savechoice (Hashtable h) throws Exception {
    String applicant_id = getParam ("applicant_id");
    String choice1 = getParam ("choice1");
    String choice2 = getParam ("choice2");
    String choice3 = getParam ("choice3");
    h.put ("choice1", choice1);
    h.put ("choice2", choice2);
    h.put ("choice3", choice3);
    if ("".equals (applicant_id)) return;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("applicant_id");
            r.add ("applicant_id", applicant_id);
            sql = r.getSQLSelect ("adm_applicant_choice");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        {
            r.clear ();
            r.add ("choice1", choice1);
            r.add ("choice2", choice2);
            r.add ("choice3", choice3);
            if (! found) {
                r.add ("applicant_id", applicant_id);
                sql = r.getSQLInsert ("adm_applicant_choice");
            }
            else {
                r.update ("applicant_id", applicant_id);
                sql = r.getSQLUpdate ("adm_applicant_choice");
            }
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=370=-----==

public void testSavepoint4 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #savepoint4 (data int)");
    stmt.close ();
    con.setAutoCommit (false);
    for (int i = 0; i < 3; i ++) {
        PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #savepoint4 (data) VALUES (?)");
        pstmt.setInt (1, 1);
        assertTrue (pstmt.executeUpdate () == 1);
        Savepoint savepoint = con.setSavepoint ();
        assertNotNull (savepoint);
        assertTrue (savepoint.getSavepointId () == 1);
        try {
            savepoint.getSavepointName ();
            assertTrue (false);
        } catch (SQLException e) {
        }
        pstmt.setInt (1, 2);
        assertTrue (pstmt.executeUpdate () == 1);
        pstmt.close ();
        pstmt = con.prepareStatement ("SELECT SUM(data) FROM #savepoint4");
        ResultSet rs = pstmt.executeQuery ();
        assertTrue (rs.next ());
        assertTrue (rs.getInt (1) == 3);
        assertTrue (! rs.next ());
        pstmt.close ();
        rs.close ();
        con.rollback (savepoint);
        pstmt = con.prepareStatement ("SELECT SUM(data) FROM #savepoint4");
        rs = pstmt.executeQuery ();
        assertTrue (rs.next ());
        assertTrue (rs.getInt (1) == 1);
        assertTrue (! rs.next ());
        pstmt.close ();
        rs.close ();
        con.rollback ();
    }
    con.setAutoCommit (true);
}


public RestServiceResult create (RestServiceResult serviceResult, ToNews toNews) {
    ToNewsDAO toNewsDAO = new ToNewsDAO ();
    try {
        toNews.setNewsId (getSequence ("sq_to_news"));
        EntityManagerHelper.beginTransaction ();
        toNewsDAO.save (toNews);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toNews);
        log.info ("El anuncio" + toNews.getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toNews.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel anuncio: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=371=-----==

public Boolean execHapusPembayaran (Integer NoBukti, Date Dibayar) {
    Double Nilai;
    String Jenis;
    Boolean r = false;
    Jenis = String.valueOf (pembayaranTable.getValueAt (pembayaranTable.getSelectedRow (), 2));
    Nilai = Double.valueOf (String.valueOf (pembayaranTable.getValueAt (pembayaranTable.getSelectedRow (), 3)));
    if (JOptionPane.showConfirmDialog (this, "Hapus pembayaran " + Jenis + " sejumlah " + floatDisplay.format (Nilai) + "?", "Konfirmasi", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
        try {
            pembayaranEntity.getTransaction ().begin ();
            pembayaranQuery = pembayaranEntity.createNativeQuery ("DELETE FROM pembayaran WHERE nobukti = #nobukti AND dibayar = #dibayar").setParameter ("nobukti", NoBukti).setParameter ("dibayar", Dibayar);
            pembayaranQuery.executeUpdate ();
            pembayaranEntity.getTransaction ().commit ();
            r = true;
        } catch (Exception ex) {
            pembayaranEntity.getTransaction ().rollback ();
            ex.printStackTrace ();
            Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
    return r;
}


public static String getAccountNumber (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.accountNumber from Account R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        String anum = (String) q.uniqueResult ();
        s.getTransaction ().commit ();
        return anum;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=372=-----==

public GroupType findByStudentsGroup (Integer idStudentsGroup) throws DBConnectionException, SelectException {
    GroupType grpType = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (GroupTypeDAO.TABLE_NAME + " grpt"));
    tablesFrom.add (new SQLWord (StudentsGroupDAO.TABLE_NAME + " stugrp"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("stugrp.STUDENT_GROUP_ID", idStudentsGroup);
    critWhere.addCriterion ("grpt.GROUP_TYPE_ID", new SQLWord ("stugrp.GROUP_TYPE_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                grpType = new GroupType ();
                grpType.setId (result.getInt ("GROUP_TYPE_ID"));
                grpType.setLabel (result.getString ("GROUP_TYPE_LABEL"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return grpType;
}


public String [] getTimeToExpirationLock (String uuid) throws DatabaseException {
    PreparedStatement selectSt = null;
    String timeToExpirationLock = null;
    try {
        selectSt = getConnection ().prepareStatement (SELECT_TIME_TO_EXPIRATION_LOCK);
        selectSt.setString (1, uuid);
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            timeToExpirationLock = rs.getString ("timeToExpLock");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    String [] parsedExpTime = new String [3];
    if (timeToExpirationLock.contains (" day")) {
        String [] splitedByDays = timeToExpirationLock.split (timeToExpirationLock.contains (" days ") ? " days " : " day ");
        parsedExpTime [0] = splitedByDays [0];
        parsedExpTime [1] = splitedByDays [1];
    }
    else {
        parsedExpTime [0] = "0";
        parsedExpTime [1] = timeToExpirationLock;
    }
    String [] splitedByColon = parsedExpTime [1].split (":");
    parsedExpTime [1] = splitedByColon [0];
    parsedExpTime [2] = splitedByColon [1];
    return parsedExpTime;
}


-----Function Pair=373=-----==

public RestServiceResult listMChoiceForExercise1 (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises1);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        List < CoMultipleChoiceE1 > list = new ArrayList < CoMultipleChoiceE1 > (coExercises1.getCoMultipleChoiceE1s ());
        if (list.size () == 0) {
            Object [] arrayParam = {coExercises1.getExerciseName ()};
            serviceResult.setError (true);
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE1.notFound"), arrayParam));
        }
        else {
            Object [] arrayParam = {list.size (), coExercises1.getExerciseName ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.listMultipleChoiceForExerciseE1.success"), arrayParam));
            serviceResult.setObjResult (list);
            serviceResult.setNumResult (list.size ());
        }
    }
    return serviceResult;
}


private void oraclePrepUpdateNullClob (JDBCDataObject baseObject, String fieldName, DBConnection theConnection) throws DataException {
    try {
        String whereClause = JDBCUtil.getInstance ().buildWhereClause (baseObject, false);
        FastStringBuffer prepStatement = FastStringBuffer.getInstance ();
        String theSQL = null;
        try {
            prepStatement.append ("UPDATE ");
            prepStatement.append (baseObject.getJDBCMetaData ().getTargetTable ());
            prepStatement.append (" SET ");
            prepStatement.append (fieldName);
            prepStatement.append (" = null ");
            prepStatement.append (whereClause);
            theSQL = prepStatement.toString ();
        } finally {
            prepStatement.release ();
            prepStatement = null;
        }
        theConnection.createPreparedStatement (theSQL);
        finalizeUpdate (theConnection);
    } catch (DBException ex) {
        throw new DataException ("Error prepping CLOB update", ex);
    }
}


-----Function Pair=374=-----==

void verDatLin (int ejeNume, int empCodi, int numDesp, int numGru, boolean agrupa) throws SQLException, java.text.ParseException {
    if (agrupa) {
        if (opAgrLin.isSelected () || nav.pulsado == navegador.EDIT) {
            s = " select f.pro_codi as pro_codi,sum(f.def_numpie) as def_numpie, " + " sum(f.def_kilos) as def_kilos ,sum(f.def_prcost*f.def_kilos) as def_prcost " + " from v_despfin f where " + " f.def_kilos <> 0 " + " and eje_nume = " + ejeNume + " AND emp_codi = " + empCodi + (numGru > 100 ? " and def_numdes = " + numGru : " AND deo_codi = " + numDesp) + " group by pro_codi " + " order by pro_codi ";
        }
        else {
            s = " select f.pro_codi as pro_codi,f.def_numpie as def_numpie, " + " f.def_kilos as def_kilos ,f.def_prcost*f.def_kilos as def_prcost " + " from v_despfin f where " + " f.def_kilos <> 0 " + " and eje_nume = " + ejeNume + " AND emp_codi = " + empCodi + (numGru > 100 ? " and def_numdes = " + numGru : " AND deo_codi = " + numDesp) + " order by pro_codi ";
        }
    }
    else {
        if (opAgrLin.isSelected () || nav.pulsado == navegador.EDIT) {
            s = " select f.pro_codi as pro_codi,sum(f.def_numpie) as def_numpie, " + " sum(f.def_kilos) as def_kilos ,sum(f.def_prcost*f.def_kilos) as def_prcost " + " from v_despfin f where " + " f.def_kilos <> 0 " + " and eje_nume = " + ejeNume + " AND emp_codi = " + empCodi + " AND deo_codi = " + numDesp + " group by pro_codi " + " order by pro_codi ";
        }
        else {
            s = " select f.pro_codi as pro_codi,f.def_numpie, " + "  def_kilos ,f.def_prcost*f.def_kilos as def_prcost " + " from v_despfin f where " + " f.def_kilos <> 0 " + " and eje_nume = " + ejeNume + " AND emp_codi = " + empCodi + " AND deo_codi = " + numDesp + " order by pro_codi ";
        }
    }
    verDatLi1 (s);
}


public String checarSitrevEstagio1234 (final Vector < Vector < Object > > vexped, Vector < Vector < Object > > vatend) {
    String result = (String) EstagioCheck.EPE.getValue ();
    for (Vector < Object > row : vexped) {
        result = (String) row.elementAt (EColExped.SITREVEXPED.ordinal ());
        if (EstagioCheck.EPE.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.EPE.getValue ();
        }
        else if (EstagioCheck.E1O.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E1O.getValue ();
        }
        else if (EstagioCheck.E2O.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E2O.getValue ();
        }
        else if (EstagioCheck.E1I.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E1I.getValue ();
            break;
        }
        else if (EstagioCheck.E2I.getValueTab ().equals (result)) {
            result = (String) EstagioCheck.E2I.getValue ();
            break;
        }
    }
    if (result.substring (2).equals ("O")) {
        for (Vector < Object > row : vatend) {
            result = (String) row.elementAt (EColAtend.SITREVATENDO.ordinal ());
            if (EstagioCheck.EPE.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.EPE.getValue ();
            }
            else if (EstagioCheck.E3O.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E3O.getValue ();
            }
            else if (EstagioCheck.E3I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E3I.getValue ();
                break;
            }
            else if (EstagioCheck.E4O.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E4O.getValue ();
            }
            else if (EstagioCheck.E4I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E4I.getValue ();
                break;
            }
            else if (EstagioCheck.E5I.getValueTab ().equals (result)) {
                result = (String) EstagioCheck.E5I.getValue ();
                break;
            }
        }
    }
    return result;
}


-----Function Pair=375=-----==

private boolean existsIndex (EboContext ctx, String schemaName, String indexName) throws SQLException {
    Connection cn = null;
    ResultSet rslt = null;
    PreparedStatement pstm = null;
    try {
        cn = ctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("select count(*) from USER_INDEXES where INDEX_NAME=? and TABLE_OWNER = ?");
        pstm.setString (1, indexName.toUpperCase ());
        pstm.setString (2, schemaName.toUpperCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            if (rslt.getInt (1) > 0) {
                return true;
            }
        }
        return false;
    } catch (SQLException e) {
        throw (e);
    } finally {
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
}


private AttributesImpl createColumnBinding (AttributesImpl atts, X_AD_Column m_Column) {
    String sql = null;
    String name = null;
    atts.clear ();
    if (m_Column.getAD_Column_ID () > 0) {
        sql = "SELECT ColumnName FROM AD_Column WHERE AD_Column_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Column_ID ());
        atts.addAttribute ("", "", "ADColumnNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADColumnNameID", "CDATA", "");
    if (m_Column.getAD_Process_ID () > 0) {
        sql = "SELECT Name FROM AD_Process WHERE AD_Process_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Process_ID ());
        atts.addAttribute ("", "", "ADProcessNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADProcessNameID", "CDATA", "");
    if (m_Column.getAD_Element_ID () > 0) {
        sql = "SELECT Name FROM AD_Element WHERE AD_Element_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Element_ID ());
        atts.addAttribute ("", "", "ADElementNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADElementNameID", "CDATA", "");
    if (m_Column.getAD_Reference_ID () > 0) {
        sql = "SELECT Name FROM AD_Reference WHERE AD_Reference_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Reference_ID ());
        atts.addAttribute ("", "", "ADReferenceNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADReferenceNameID", "CDATA", "");
    if (m_Column.getAD_Reference_Value_ID () > 0) {
        sql = "SELECT Name FROM AD_Reference WHERE AD_Reference_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Reference_Value_ID ());
        atts.addAttribute ("", "", "ADReferenceNameValueID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADReferenceNameValueID", "CDATA", "");
    if (m_Column.getAD_Table_ID () > 0) {
        sql = "SELECT TableName FROM AD_Table WHERE AD_Table_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Table_ID ());
        atts.addAttribute ("", "", "ADTableNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADTableNameID", "CDATA", "");
    if (m_Column.getAD_Val_Rule_ID () > 0) {
        sql = "SELECT Name FROM AD_Val_Rule WHERE AD_Val_Rule_ID=?";
        name = DB.getSQLValueString (null, sql, m_Column.getAD_Val_Rule_ID ());
        atts.addAttribute ("", "", "ADValRuleNameID", "CDATA", name);
    }
    else atts.addAttribute ("", "", "ADValRuleNameID", "CDATA", "");
    atts.addAttribute ("", "", "Callout", "CDATA", (m_Column.getCallout () != null ? m_Column.getCallout () : ""));
    atts.addAttribute ("", "", "ColumnSQL", "CDATA", (m_Column.getColumnSQL () != null ? m_Column.getColumnSQL () : ""));
    atts.addAttribute ("", "", "ColumnName", "CDATA", (m_Column.getColumnName () != null ? m_Column.getColumnName () : ""));
    atts.addAttribute ("", "", "DefaultValue", "CDATA", (m_Column.getDefaultValue () != null ? m_Column.getDefaultValue () : ""));
    atts.addAttribute ("", "", "Description", "CDATA", (m_Column.getDescription () != null ? m_Column.getDescription () : ""));
    atts.addAttribute ("", "", "EntityType", "CDATA", (m_Column.getEntityType () != null ? m_Column.getEntityType () : ""));
    atts.addAttribute ("", "", "FieldLength", "CDATA", (m_Column.getFieldLength () > 0 ? "" + m_Column.getFieldLength () : "0"));
    atts.addAttribute ("", "", "Help", "CDATA", (m_Column.getHelp () != null ? m_Column.getHelp () : ""));
    atts.addAttribute ("", "", "isAlwaysUpdateable", "CDATA", (m_Column.isAlwaysUpdateable () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isIdentifier", "CDATA", (m_Column.isIdentifier () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isKey", "CDATA", (m_Column.isKey () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isMandatory", "CDATA", (m_Column.isMandatory () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isParent", "CDATA", (m_Column.isParent () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isSelectionColumn", "CDATA", (m_Column.isSelectionColumn () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isActive", "CDATA", (m_Column.isActive () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isTranslated", "CDATA", (m_Column.isTranslated () == true ? "true" : "false"));
    atts.addAttribute ("", "", "isUpdateable", "CDATA", (m_Column.isUpdateable () == true ? "true" : "false"));
    atts.addAttribute ("", "", "Name", "CDATA", (m_Column.getName () != null ? m_Column.getName () : ""));
    atts.addAttribute ("", "", "getIsSyncDatabase", "CDATA", "Y");
    atts.addAttribute ("", "", "ReadOnlyLogic", "CDATA", (m_Column.getReadOnlyLogic () != null ? m_Column.getReadOnlyLogic () : ""));
    atts.addAttribute ("", "", "SeqNo", "CDATA", (m_Column.getSeqNo () > 0 ? "" + m_Column.getSeqNo () : "0"));
    atts.addAttribute ("", "", "VFormat", "CDATA", (m_Column.getVFormat () != null ? m_Column.getVFormat () : ""));
    atts.addAttribute ("", "", "ValueMax", "CDATA", (m_Column.getValueMax () != null ? m_Column.getValueMax () : ""));
    atts.addAttribute ("", "", "ValueMin", "CDATA", (m_Column.getValueMin () != null ? m_Column.getValueMin () : ""));
    atts.addAttribute ("", "", "Version", "CDATA", (m_Column.getVersion () != null ? "" + m_Column.getVersion () : "0.0"));
    atts.addAttribute ("", "", "InfoFactoryClass", "CDATA", (m_Column.getInfoFactoryClass () != null ? m_Column.getInfoFactoryClass () : ""));
    return atts;
}


-----Function Pair=376=-----==

public static String getFieldName (Class < ? extends Record > c) throws RecordException {
    String tableName = "";
    tableName = c.getSimpleName ();
    char name [] = tableName.toCharArray ();
    tableName = "";
    int i = 0;
    for (Character ch : name) {
        if (i > 0 && (int) ch >= 65 && (int) ch <= 90) {
            tableName += "_" + Character.toLowerCase (ch);
        }
        else {
            tableName += Character.toLowerCase (ch);
        }
        ++ i;
    }
    return tableName;
}


public static void setStageFileSize (int fileID, Long fileSize) throws Exception {
    log.debug ("Setting the Stage File Size");
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Stage stageFile = (Stage) session.load (Stage.class, fileID);
    stageFile.setFilesize (fileSize);
    try {
        session.update (stageFile);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception ("Error Getting Setting the Stage File Size: " + e.getCause ().getMessage ());
    }
    return;
}


-----Function Pair=377=-----==

public RestServiceResult changePassword (RestServiceResult serviceResult, Long nUserId, String sOldPassword, String sNewPassword) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    if (maUser == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("user.search.notFound"));
    }
    else {
        if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_ADMIN)) {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("security.accessDenied"));
        }
        else if (maUser.getPassword ().trim ().equals (sOldPassword.trim ())) {
            maUser.setPassword (sNewPassword);
            update (new RestServiceResult (), maUser);
            serviceResult.setMessage (bundle.getString ("user.changePassword.success"));
        }
        else {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("user.changePassword.errorOldPassword"));
        }
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, ToGloss maGloss) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.DELETE_TO_GLOSS);
        query.setParameter (1, maGloss.getGlossId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maGloss);
        Object [] arrayParam = {maGloss.getGlossId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("gloss.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el texto individual: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maGloss.getGlossId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("gloss.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=378=-----==

public Paragrafo procurarParagrafoId (final Integer id) throws HibernateException, Exception {
    Session session = Hibernate.getSessionFactory ().getCurrentSession ();
    try {
        session.beginTransaction ();
        Paragrafo returnParagrafo = (Paragrafo) session.createQuery ("from Paragrafo where codParagrafo = " + id);
        session.getTransaction ().commit ();
        return returnParagrafo;
    } catch (HibernateException e) {
        if (session != null) {
            session.getTransaction ().rollback ();
        }
        throw new HibernateException ("HIBERNATE Erro no Procurar Por ID Paragrafo: ", e);
    } catch (Exception e) {
        throw new Exception ("GERAL Erro no Procurar Por ID Paragrafo: ", e);
    }
}


public void update (Department obj) throws UpdateException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria newCrit = new Criteria ();
    newCrit.addCriterion ("DEPARTMENT_NAME", obj.getName ());
    newCrit.addCriterion ("DEPARTMENT_DESCRIPTION", obj.getDescription ());
    newCrit.addCriterion ("DEPARTMENT_ACRONYM", obj.getAcronym ());
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("DEPARTMENT_ID", obj.getId ());
    try {
        stmt.executeUpdate (new UpdateQuery (DepartmentDAO.TABLE_NAME, newCrit, critWhere).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new UpdateException (TABLE_NAME + " Update exception", e);
    }
}


-----Function Pair=379=-----==

public static void close (Connection connection, Statement statement, ResultSet rs, boolean throwExcepton) throws IllegalStateException {
    try {
        try {
            if (rs != null) {
                rs.close ();
            }
        } finally {
            try {
                if (statement != null) {
                    statement.close ();
                }
            } finally {
                if (connection != null) {
                    connection.close ();
                }
            }
        }
    } catch (Throwable e) {
        String msg = "Can't close a SQL object";
        if (throwExcepton) {
            throw new IllegalStateException (msg, e);
        }
        else {
            LOGGER.log (Level.SEVERE, msg, e);
        }
    }
}


public List < Usergroups > queryAllSystemUserGroup () {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction ts = null;
    try {
        ts = session.beginTransaction ();
        Query query = session.createQuery ("from Usergroups ug where ug.type=:type");
        query.setString ("type", "system");
        List < Usergroups > userGroupList = query.list ();
        ts.commit ();
        return userGroupList;
    } catch (HibernateException e) {
        if (ts != null) {
            ts.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=380=-----==

public static void init (ResourceBundle hibernateBundle) {
    try {
        AnnotationConfiguration cfg = new AnnotationConfiguration ();
        Enumeration < String > en = hibernateBundle.getKeys ();
        while (en.hasMoreElements ()) {
            String key = en.nextElement ();
            cfg.setProperty (key, hibernateBundle.getString (key));
        }
        cfg = cfg.addPackage ("com.elibera.gateway.entity").addAnnotatedClass (SessionLog.class).addAnnotatedClass (ServerEntry.class).addAnnotatedClass (QueryLog.class).addAnnotatedClass (BlockedUser.class).addAnnotatedClass (Werbung.class).addAnnotatedClass (UserData.class);
        if (RedirectServer.extension != null) {
            cfg = RedirectServer.extension.initHibernateEntities (cfg);
        }
        sessionFactory = cfg.buildSessionFactory ();
    } catch (Throwable ex) {
        throw new ExceptionInInitializerError (ex);
    }
}


public static PedidoSituacao selectPedidoSituacaoCorrenteByPedido (int codigo) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    PedidoSituacao objPS = null;
    if (c == null) {
        return null;
    }
    try {
        String sql = "SELECT distinct id_pedido, id_situacao, id_funcionario, em, observacao, " + "DATE_FORMAT(em, '%d/%m/%Y %H:%i:%S') as em_formatada " + "FROM pedido_situacao " + "where id_pedido = ? " + "order by em desc";
        pst = c.prepareStatement (sql);
        pst.setInt (1, codigo);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objPS = new PedidoSituacao ();
            objPS.setFuncionario (FuncionarioDAO.selectByID (rs.getString ("id_funcionario")));
            objPS.setObservacao (rs.getString ("observacao"));
            objPS.setSituacao (SituacaoDAO.selectByID (rs.getInt ("id_situacao")));
            objPS.setDataSituacao (rs.getDate ("em"));
            objPS.setDataSituacaoFormatada (rs.getString ("em_formatada"));
        }
    } catch (SQLException e) {
        System.out.println ("[PedidoSituacaoDAO.selectPedidoSituacaoCorrenteByPedido] Erro ao atualizar -> " + e.getMessage ());
        objPS = null;
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objPS;
}


-----Function Pair=381=-----==

private void academic_save (HttpSession session) throws Exception {
    Hashtable info = new Hashtable ();
    info.put ("applicant_id", getParam ("applicant_id"));
    Vector examInfo = (Vector) session.getAttribute ("examInfo");
    for (int i = 0; i < examInfo.size (); i ++) {
        Hashtable exam = (Hashtable) examInfo.elementAt (i);
        String exam_id = (String) exam.get ("id");
        Vector subjects = (Vector) exam.get ("subjects");
        for (int k = 0; k < subjects.size (); k ++) {
            Hashtable subject = (Hashtable) subjects.elementAt (k);
            String subject_id = (String) subject.get ("id");
            info.put (subject_id, getParam (subject_id));
        }
    }
    ExamResultData.save (examInfo, info);
}


public static void querywithfetchplan (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        OpenJPAQuery openjpaQuery = OpenJPAPersistence.cast (query);
        FetchPlan openjpaFetchplan = (FetchPlan) openjpaQuery.getFetchPlan ();
        openjpaFetchplan.addField ("oopex.openjpa1.jpax.relationships.model.Person.friends");
        openjpaFetchplan.setMaxFetchDepth (3);
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getFriends ()) {
                System.out.println ("\twith friend: " + person1);
                for (Person person2 : person1.getFriends ()) {
                    System.out.println ("\t\twith friend: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=382=-----==

public boolean deleteSubscriptionByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Subscriptions as s where s.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public int delete (BusinessObject o) throws DAOException {
    int delete = 0;
    Project project = (Project) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("DELETE_PROJECT"));
        pst.setInt (1, project.getId ());
        delete = pst.executeUpdate ();
        if (delete <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (delete > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return delete;
}


-----Function Pair=383=-----==

public static Vector getSubjectList (String studentId, String periodId, String programCode) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("ss.subject_id");
        r.add ("fs.subject_code");
        r.add ("fs.subject_name");
        r.add ("fs.credit_hrs");
        r.add ("ss.register_id", "active");
        r.add ("ss.student_id", studentId);
        r.add ("ss.period_id", periodId);
        r.add ("ss.program_code", programCode);
        r.add ("ss.subject_id", r.unquote ("fs.subject_id"));
        sql = r.getSQLSelect ("student_subject ss, faculty_subject fs");
        System.out.println ("program=" + programCode);
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            Subject s = new Subject ();
            s.setId (rs.getString ("subject_id"));
            s.setCode (rs.getString ("subject_code"));
            s.setName (rs.getString ("subject_name"));
            s.setCreditHours (rs.getInt ("credit_hrs"));
            v.addElement (s);
        }
        return v;
    } finally {
        if (db != null) db.close ();
    }
}


private Hashtable getCourseSelected () throws Exception {
    String applicant_id = getParam ("applicant_id");
    if ("".equals (applicant_id)) throw new Exception ("Missing applicant_id..");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("choice1");
        r.add ("choice2");
        r.add ("choice3");
        r.add ("applicant_id", applicant_id);
        sql = r.getSQLSelect ("adm_applicant_choice");
        ResultSet rs = stmt.executeQuery (sql);
        Hashtable h = new Hashtable ();
        if (rs.next ()) {
            h.put ("choice1", rs.getString ("choice1"));
            h.put ("choice2", rs.getString ("choice2"));
            h.put ("choice3", rs.getString ("choice3"));
        }
        return h;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=384=-----==

public static ArrayList < CelulaFinanceira > selectByOrgao (int codigo) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    CelulaFinanceira objCF = null;
    ArrayList < CelulaFinanceira > al = new ArrayList < CelulaFinanceira > ();
    if (c == null) {
        return null;
    }
    try {
        String sql = "select * from celula_financeira where id_orgao = ?";
        pst = c.prepareStatement (sql);
        pst.setInt (1, codigo);
        rs = pst.executeQuery ();
        while (rs.next ()) {
            objCF = new CelulaFinanceira ();
            objCF.setCodigo (rs.getInt ("id_celula_financeira"));
            objCF.setDescricao (rs.getString ("descricao"));
            objCF.setOrgao (OrgaoDAO.selectByID (rs.getString ("id_orgao")));
            objCF.setNaturezaDespesa (NaturezaDespesaDAO.selectByID (rs.getString ("id_natureza_despesa")));
            objCF.setProgramaTrabalho (ProgramaTrabalhoDAO.selectByID (rs.getString ("id_programa_trabalho")));
            objCF.setUnidadeOrcamentaria (UnidadeOrcamentariaDAO.selectByID (rs.getString ("id_unidade_orcamentaria")));
            objCF.setFonteRecursos (FonteRecursosDAO.selectByID (rs.getString ("id_fonte_recursos")));
            objCF.setGestao (GestaoDAO.selectByID (rs.getString ("id_gestao")));
            objCF.setValorProvisionado (rs.getDouble ("valor_provisionado"));
            objCF.setGastoPrevisto (rs.getDouble ("gasto_previsto"));
            objCF.setGastoReal (rs.getDouble ("gasto_real"));
            objCF.setSaldoPrevisto (rs.getDouble ("saldo_previsto"));
            objCF.setSaldoReal (rs.getDouble ("saldo_real"));
            al.add (objCF);
            objCF = null;
        }
    } catch (SQLException e) {
        System.out.println ("[CelulaFinanceiraDAO.selectByID] Erro ao atualizar -> " + e.getMessage ());
        al = null;
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return al;
}


public static Order GetMostRecentOrder (String c_uname, Vector order_lines) {
    Connection con = null;
    try {
        order_lines.removeAllElements ();
        int order_id;
        Order order;
        con = getConnection ();
        {
            PreparedStatement get_most_recent_order_id = con.prepareStatement ("SELECT o_id " + "FROM customer, orders " + "WHERE customer.c_id = orders.o_c_id " + "AND c_uname = ? " + "ORDER BY o_date, orders.o_id DESC " + "LIMIT 0,1");
            get_most_recent_order_id.setString (1, c_uname);
            ResultSet rs = get_most_recent_order_id.executeQuery ();
            if (rs.next ()) {
                order_id = rs.getInt ("o_id");
            }
            else {
                rs.close ();
                get_most_recent_order_id.close ();
                con.commit ();
                returnConnection (con);
                return null;
            }
            rs.close ();
            get_most_recent_order_id.close ();
        }
        {
            PreparedStatement get_order = con.prepareStatement ("SELECT orders.*, customer.*, " + "  cc_xacts.cx_type, " + "  ship.addr_street1 AS ship_addr_street1, " + "  ship.addr_street2 AS ship_addr_street2, " + "  ship.addr_state AS ship_addr_state, " + "  ship.addr_zip AS ship_addr_zip, " + "  ship_co.co_name AS ship_co_name, " + "  bill.addr_street1 AS bill_addr_street1, " + "  bill.addr_street2 AS bill_addr_street2, " + "  bill.addr_state AS bill_addr_state, " + "  bill.addr_zip AS bill_addr_zip, " + "  bill_co.co_name AS bill_co_name " + "FROM customer, orders, cc_xacts," + "  address AS ship, " + "  country AS ship_co, " + "  address AS bill,  " + "  country AS bill_co " + "WHERE orders.o_id = ? " + "  AND cx_o_id = orders.o_id " + "  AND customer.c_id = orders.o_c_id " + "  AND orders.o_bill_addr_id = bill.addr_id " + "  AND bill.addr_co_id = bill_co.co_id " + "  AND orders.o_ship_addr_id = ship.addr_id " + "  AND ship.addr_co_id = ship_co.co_id " + "  AND orders.o_c_id = customer.c_id");
            get_order.setInt (1, order_id);
            ResultSet rs2 = get_order.executeQuery ();
            if (! rs2.next ()) {
                con.commit ();
                rs2.close ();
                returnConnection (con);
                return null;
            }
            order = new Order (rs2);
            rs2.close ();
            get_order.close ();
        }
        {
            PreparedStatement get_order_lines = con.prepareStatement ("SELECT * " + "FROM order_line, item " + "WHERE ol_o_id = ? " + "AND ol_i_id = i_id");
            get_order_lines.setInt (1, order_id);
            ResultSet rs3 = get_order_lines.executeQuery ();
            while (rs3.next ()) {
                order_lines.addElement (new OrderLine (rs3));
            }
            rs3.close ();
            get_order_lines.close ();
        }
        con.commit ();
        returnConnection (con);
        return order;
    } catch (java.lang.Exception ex) {
        try {
            con.rollback ();
            ex.printStackTrace ();
        } catch (Exception se) {
            System.err.println ("Transaction rollback failed.");
        }
    }
    return null;
}


-----Function Pair=385=-----==

private void itemLeftAndRight (JXTable ordinaryTable, JXTable sourceTable) {
    if (sourceTable.getSelectedRow () != - 1) {
        int row = sourceTable.getSelectedRow ();
        DefaultTableModel cModel = (DefaultTableModel) container.getColumnTable ().getModel ();
        DefaultTableModel cdModel = (DefaultTableModel) container.getColumnDisplayTable ().getModel ();
        DefaultTableModel cosModel = (DefaultTableModel) container.getColumnOrderSourceTable ().getModel ();
        DefaultTableModel coModel = (DefaultTableModel) container.getColumnOrderTable ().getModel ();
        DefaultTableModel caModel = (DefaultTableModel) container.getColumnAllTable ().getModel ();
        if ((sourceTable == container.getColumnTable ()) && (ordinaryTable == container.getColumnDisplayTable ())) {
            Column column = (Column) cModel.getValueAt (row, 0);
            Vector rowData = new Vector ();
            rowData.add (column);
            if (column.isCountble ()) rowData.add (new Boolean (false));
            else rowData.add (null);
            if (column.isSumble ()) rowData.add (new Boolean (false));
            else rowData.add (null);
            cdModel.addRow (rowData);
            rowData = new Vector ();
            rowData.add (column);
            cosModel.addRow (rowData);
            cModel.removeRow (row);
        }
        else if ((sourceTable == container.getColumnDisplayTable ()) && (ordinaryTable == container.getColumnTable ())) {
            Column column = (Column) cdModel.getValueAt (row, 0);
            Vector rowData = new Vector ();
            rowData.add (column);
            cModel.addRow (rowData);
            int tempRow = findRow (column, container.getColumnOrderSourceTable ());
            if (tempRow != - 1) cosModel.removeRow (tempRow);
            tempRow = findRow (column, container.getColumnOrderTable ());
            if (tempRow != - 1) coModel.removeRow (tempRow);
            cdModel.removeRow (row);
        }
        else if ((sourceTable == container.getColumnOrderSourceTable ()) && (ordinaryTable == container.getColumnOrderTable ())) {
            Column column = (Column) cosModel.getValueAt (row, 0);
            Vector rowData = new Vector ();
            rowData.add (column);
            rowData.add (new Boolean (false));
            coModel.addRow (rowData);
            cosModel.removeRow (row);
        }
        else if ((sourceTable == container.getColumnOrderTable ()) && (ordinaryTable == container.getColumnOrderSourceTable ())) {
            Column column = (Column) coModel.getValueAt (row, 0);
            Vector rowData = new Vector ();
            rowData.add (column);
            cosModel.addRow (rowData);
            coModel.removeRow (row);
        }
    }
    container.updateDisplayColumnTable ();
}


public void testPreparedStatementAddBatch1 () throws Exception {
    int count = 50;
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #psbatch1 (f_int INT)");
    int sum = 0;
    con.setAutoCommit (false);
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #psbatch1 (f_int) VALUES (?)");
    for (int i = 0; i < count; i ++) {
        pstmt.setInt (1, i);
        pstmt.addBatch ();
        sum += i;
    }
    int [] results = pstmt.executeBatch ();
    assertEquals (results.length, count);
    for (int i = 0; i < count; i ++) {
        assertEquals (results [i], 1);
    }
    pstmt.close ();
    con.commit ();
    con.setAutoCommit (true);
    ResultSet rs = stmt.executeQuery ("SELECT SUM(f_int) FROM #psbatch1");
    assertTrue (rs.next ());
    System.out.println (rs.getInt (1));
    assertEquals (rs.getInt (1), sum);
    rs.close ();
    stmt.close ();
}


-----Function Pair=386=-----==

public RestServiceResult delete (RestServiceResult serviceResult, ToExercise1Group toExercise1Group) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_EXERCITE1_GROUP);
        query.setParameter (1, toExercise1Group.getExerciseGroupId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise1Group);
        Object [] arrayParam = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el ejercicio grupal s1: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


protected synchronized AbstractBaseObject delete (AbstractBaseObject obj) throws ApplicationException {
    PreparedStatement preStat = null;
    StringBuffer sqlStat = new StringBuffer ();
    DmsRelationalWord tmpDmsRelationalWord = (DmsRelationalWord) ((DmsRelationalWord) obj).clone ();
    synchronized (dbConn) {
        try {
            int updateCnt = 0;
            sqlStat.append ("DELETE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD ");
            sqlStat.append ("WHERE  ID=? AND UPDATE_COUNT=? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            setPrepareStatement (preStat, 1, tmpDmsRelationalWord.getID ());
            setPrepareStatement (preStat, 2, tmpDmsRelationalWord.getUpdateCount ());
            updateCnt = preStat.executeUpdate ();
            if (updateCnt == 0) {
                throw new ApplicationException (ErrorConstant.DB_CONCURRENT_ERROR);
            }
            else {
                return (tmpDmsRelationalWord);
            }
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_DELETE_ERROR, e);
        } finally {
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


-----Function Pair=387=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public List getPortfolio (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Portfolio R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=388=-----==

public void updateProduct (Product product) throws PersistenceException {
    logger.info ("Updating product...");
    if (product == null) {
        String error = "Product is null.";
        logger.error (error);
        throw new IllegalArgumentException (error);
    }
    EntityManager em = getEntityManager ();
    try {
        em.getTransaction ().begin ();
        em.merge (product);
        em.getTransaction ().commit ();
    } catch (Exception ex) {
        String error = "Error updating product: " + ex.getMessage ();
        logger.error (error);
        em.getTransaction ().rollback ();
        throw new PersistenceException (ex);
    } finally {
        em.close ();
    }
    logger.info ("Product updated successfully.");
}


public void setPilot (PilotData pilotData) throws UsernameNotValidException {
    try {
        if (pilotData.username.trim ().equals ("") || pilotData.password.trim ().equals ("")) throw new UsernameNotValidException (1, "Username or password missing");
        PreparedStatement psta;
        if (pilotData.id == 0) {
            psta = jdbc.prepareStatement ("INSERT INTO pilot " + "(name, address1, address2, zip, city, state, country, birthdate, " + "pft_theory, pft, medical, passenger, instructor, loc_language, " + "loc_country, loc_variant, username, password, id) " + "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
            pilotData.id = Sequence.nextVal ("pilot_id", jdbc);
        }
        else {
            psta = jdbc.prepareStatement ("UPDATE pilot SET " + "name = ?, address1 = ?, address2 = ?, " + "zip = ?, city = ?, state = ?, country = ?, birthdate = ?, pft_theory = ?," + "pft = ?, medical = ?, passenger = ?, instructor = ?, loc_language = ?, " + "loc_country = ?, loc_variant = ?, username = ?, password = ? " + "WHERE id = ?");
        }
        psta.setString (1, pilotData.name);
        psta.setString (2, pilotData.address1);
        psta.setString (3, pilotData.address2);
        psta.setString (4, pilotData.zip);
        psta.setString (5, pilotData.city);
        psta.setString (6, pilotData.state);
        psta.setString (7, pilotData.country);
        if (pilotData.birthdate != null) psta.setLong (8, pilotData.birthdate.getTime ());
        else psta.setNull (8, java.sql.Types.INTEGER);
        if (pilotData.pft_theory != null) psta.setLong (9, pilotData.pft_theory.getTime ());
        else psta.setNull (9, java.sql.Types.INTEGER);
        if (pilotData.pft != null) psta.setLong (10, pilotData.pft.getTime ());
        else psta.setNull (10, java.sql.Types.INTEGER);
        if (pilotData.medical != null) psta.setLong (11, pilotData.medical.getTime ());
        else psta.setNull (11, java.sql.Types.INTEGER);
        if (pilotData.passenger) psta.setString (12, "Y");
        else psta.setString (12, "N");
        if (pilotData.instructor) psta.setString (13, "Y");
        else psta.setString (13, "N");
        psta.setString (14, pilotData.loc_language);
        psta.setString (15, pilotData.loc_country);
        psta.setString (16, pilotData.loc_variant);
        psta.setString (17, pilotData.username);
        psta.setString (18, pilotData.password);
        psta.setInt (19, pilotData.id);
        psta.executeUpdate ();
        jdbc.commit ();
    } catch (SQLException sql) {
        jdbc.rollback ();
        sql.printStackTrace ();
        throw new UsernameNotValidException (2, "Username allready exist");
    }
}


-----Function Pair=389=-----==

public BitstreamInfo findByBitstreamId (int id) {
    Connection conn = null;
    BitstreamInfo info = null;
    PreparedStatement prepStmt = null;
    try {
        conn = DatabaseManager.getConnection ();
        prepStmt = conn.prepareStatement (FIND_BY_BITSTREAM_ID);
        prepStmt.setInt (1, id);
        ResultSet rs = prepStmt.executeQuery ();
        if (rs.next ()) {
            info = new BitstreamInfo (rs.getBoolean ("deleted"), rs.getInt ("store_number"), rs.getInt ("size_bytes"), rs.getString ("short_description"), rs.getInt ("bitstream_id"), rs.getString ("user_format_description"), rs.getString ("internal_id"), rs.getString ("source"), rs.getString ("checksum_algorithm"), rs.getString ("checksum"), rs.getString ("name"), rs.getTimestamp ("last_process_end_date"), rs.getBoolean ("to_be_processed"), new Date ());
        }
    } catch (SQLException e) {
        LOG.warn ("Bitstream metadata could not be retrieved. " + e.getMessage (), e);
    } finally {
        cleanup (prepStmt, conn);
    }
    return info;
}


public List getChangeLog (String target, String nodeId, String app, String operation) {
    Session session = this.hibernateManager.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        String query = "from ChangeLogEntry entry where entry.target=? AND entry.nodeId=? AND entry.operation=? AND entry.app=?";
        List changeLog = session.createQuery (query).setString (0, target).setString (1, nodeId).setString (2, operation).setString (3, app).list ();
        tx.commit ();
        if (changeLog == null) {
            changeLog = new ArrayList ();
        }
        return changeLog;
    } catch (Exception e) {
        logger.error (this, e);
        if (tx != null) {
            tx.rollback ();
        }
        throw new SyncException (e);
    }
}


-----Function Pair=390=-----==

public boolean deleteComment (String codigoComentario) {
    Connection conexion = null;
    PreparedStatement delete = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        delete = conexion.prepareStatement ("DELETE FROM " + nameBD + ".Comentarios WHERE CodigoComentario=?");
        delete.setString (1, codigoComentario);
        int filasAfectadas = delete.executeUpdate ();
        if (filasAfectadas == 1) {
            exito = true;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error borrando comentario", ex);
    } finally {
        cerrarConexionYStatement (conexion, delete);
    }
    return exito;
}


public void testIsSomething () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T where T.firstName IS something").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
        fail ("Expected exception");
    } catch (RuntimeException ex) {
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=391=-----==

public String execute () {
    homePage = getHomePage ();
    selectedCourse = homePage.getSelectedCourse ();
    sqlError = false;
    foundDupDocument = false;
    DataSource dbcp = (DataSource) servletContext.getAttribute ("dbpool");
    int pollid = addPollToDB (dbcp);
    addPollToInstance (pollid);
    if (! homePage.isAdmin () || ! isValidInput ()) {
        validate ();
        return INPUT;
    }
    if (! sqlError) {
    }
    else {
        validate ();
        return INPUT;
    }
    return SUCCESS;
}


public Boolean isFirstTime () {
    Boolean result = true;
    if (isDbConnected ()) {
        Connection con = getJDBCConnection ();
        ResultSet rs;
        try {
            String [] schemeType = {"TABLE"};
            rs = con.getMetaData ().getTables (catalog, null, null, schemeType);
            rs.last ();
            if (rs.getRow () >= 1) {
                result = false;
            }
        } catch (SQLException ex) {
            ex.printStackTrace ();
            Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
    else {
        result = false;
    }
    return result;
}


-----Function Pair=392=-----==

protected synchronized List getList () throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    List result = new ArrayList ();
    synchronized (dbConn) {
        try {
            sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD A ");
            sqlStat.append ("WHERE  A.RECORD_STATUS = ? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            this.setPrepareStatement (preStat, 1, GlobalConstant.RECORD_STATUS_ACTIVE);
            rs = preStat.executeQuery ();
            while (rs.next ()) {
                DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
                tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
                tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
                tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
                tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
                tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
                tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
                tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
                tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
                tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
                tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
                tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
                tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
                result.add (tmpDmsRelationalWord);
            }
            return (result);
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
        } finally {
            try {
                rs.close ();
            } catch (Exception ignore) {
            } finally {
                rs = null;
            }
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


public Site GetSite (NpsContext ctxt, String siteid) {
    if (sites != null && sites.containsKey (siteid)) return (Site) sites.get (siteid);
    if (sites_owners == null || ! sites_owners.containsKey (siteid)) return null;
    if (sites_myunit == null || ! sites_myunit.containsKey (siteid)) return null;
    try {
        Site site = ctxt.GetSite (siteid);
        if (site != null) {
            if (sites == null) sites = new Hashtable ();
            sites.put (siteid, site);
        }
        return site;
    } catch (Exception e) {
        nps.util.DefaultLog.error_noexception (e);
    }
    return null;
}


-----Function Pair=393=-----==

public static void writePostgresqlDAOBaseImplFile (String path, String packageName, Table table) {
    String packagePath = packageName.replace ('.', '/');
    String filePath;
    if (path == null) {
        filePath = packagePath + "/jdbc/";
    }
    else {
        filePath = path + '/' + packagePath + "/jdbc/";
    }
    String curPath = "";
    File tFile = new File (filePath + table.getJavaName () + "DaoImplBase.java");
    BufferedWriter bw = null;
    try {
        new File (filePath).mkdirs ();
        tFile.createNewFile ();
        bw = new BufferedWriter (new FileWriter (filePath + table.getJavaName () + "DaoImplBase.java"));
        bw.write (getPostgresqlDAOImplBaseFile (packageName, table));
        bw.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            bw.close ();
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
}


public void createThreads () throws Exception {
    setPaused (true);
    int index = 0;
    for (int m = 0; m < methods.length; m ++) {
        for (int u = 0; u < config.urls.length; u ++) {
            Runnable r = makeRunnable (methods [m], config.urls [u], this);
            Thread t = new Thread (r);
            t.setName (methods [m] + ":" + config.urls [u]);
            threads [index ++] = t;
        }
    }
    for (int i = 0; i < threads.length; i ++) {
        threads [i].start ();
    }
}


-----Function Pair=394=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


public int getTotalFechas (int idDivision) {
    int dato = 0;
    try {
        String sql = "SELECT numFechas FROM divisionxTorneo " + " WHERE idDivisionxTorneo = " + idDivision;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            dato = populateTotalFechas (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return dato;
}


-----Function Pair=395=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void update (String [] power) {
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        String sql = "";
        conn.setAutoCommit (false);
        sql = "update roleinfo set role_name = ?,show_order=?,role_desc=? where role_id = ?";
        conn.prepare (sql);
        conn.setString (1, getRoleName ());
        conn.setInt (2, getShowOrder ());
        conn.setString (3, getRoleDesc ());
        conn.setString (4, getId ());
        conn.executeUpdate ();
        sql = "delete from rolepower where role_id = ?";
        conn.prepare (sql);
        conn.setString (1, getId ());
        conn.executeUpdate ();
        if (power != null && power.length > 0) {
            for (int i = 0; i < power.length; i ++) {
                sql = "insert into rolepower (role_id,power_id) values (" + "?,?)";
                conn.prepare (sql);
                conn.setString (1, getId ());
                conn.setString (2, power [i]);
                conn.executeUpdate ();
            }
        }
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception subEx) {
            subEx.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=396=-----==

public static NotaFiscal selectByID (int codigo) {
    Connection c = DBConnection.getConnection ();
    if (c == null) {
        return null;
    }
    String sql = "SELECT id_nota_fiscal, id_fornecedor, " + "data_emissao, data_cadastro, numero, truncate(total,2) as valor, " + "DATE_FORMAT(data_emissao, '%d/%m/%Y %H:%i:%S') as data_emissao_formatada, " + "DATE_FORMAT(data_cadastro, '%d/%m/%Y %H:%i:%S') as data_cadastro_formatada " + "FROM nota_fiscal " + "WHERE id_nota_fiscal = ?";
    PreparedStatement pst = null;
    ResultSet rs = null;
    NotaFiscal objNF = null;
    try {
        pst = c.prepareStatement (sql);
        pst.setInt (1, codigo);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objNF = new NotaFiscal ();
            objNF.setCodigo (rs.getInt ("id_nota_fiscal"));
            objNF.setDataCadastro (rs.getDate ("data_cadastro"));
            objNF.setDataCadastroFormatada (rs.getString ("data_cadastro_formatada"));
            objNF.setDataEmissao (rs.getDate ("data_emissao"));
            objNF.setDataEmissaoFormatada (rs.getString ("data_emissao_formatada"));
            objNF.setValor (rs.getDouble ("valor"));
            objNF.setFornecedor (FornecedorDAO.selectByID (rs.getString ("id_fornecedor")));
            objNF.setItemNotaFiscal (ItemNotaFiscalDAO.selectByNotaFiscal (rs.getInt ("id_nota_fiscal")));
            objNF.setNumero (rs.getString ("numero"));
        }
    } catch (Exception e) {
        System.out.println ("[NotaFiscalDAO.selectByID]" + e.getMessage ());
        objNF = null;
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objNF;
}


private Integer getInt (String sequence) throws NoSuchSequenceException {
    Connection conn = null;
    PreparedStatement read = null;
    PreparedStatement write = null;
    boolean success = false;
    try {
        conn = ds.getConnection ();
        conn.setTransactionIsolation (conn.TRANSACTION_REPEATABLE_READ);
        conn.setAutoCommit (false);
        read = conn.prepareStatement (SELECT_SQL);
        read.setString (1, sequence);
        ResultSet readRs = read.executeQuery ();
        if (! readRs.next ()) {
            throw new NoSuchSequenceException ();
        }
        int currentSequenceId = readRs.getInt (1);
        int currentSequenceValue = readRs.getInt (2);
        Integer currentSequenceValueInteger = new Integer (currentSequenceValue);
        write = conn.prepareStatement (UPDATE_SQL);
        write.setInt (1, currentSequenceValue + 1);
        write.setInt (2, currentSequenceId);
        int rowsAffected = write.executeUpdate ();
        if (rowsAffected == 1) {
            success = true;
            return currentSequenceValueInteger;
        }
        else {
            logger.error ("Something strange has happened.  The row count was not 1, but was " + rowsAffected);
            return currentSequenceValueInteger;
        }
    } catch (SQLException sqle) {
        logger.error ("Table based id generation failed : ");
        logger.error (sqle.getMessage ());
        return new Integer (0);
    } finally {
        if (read != null) {
            try {
                read.close ();
            } catch (Exception e) {
            }
        }
        if (write != null) {
            try {
                write.close ();
            } catch (Exception e) {
            }
        }
        if (conn != null) {
            try {
                if (success) {
                    conn.commit ();
                }
                else {
                    conn.rollback ();
                }
                conn.close ();
            } catch (Exception e) {
            }
        }
    }
}


-----Function Pair=397=-----==

public void testCursorResultSetConcurrency0003 () throws Exception {
    Statement stmt0 = con.createStatement ();
    stmt0.execute ("create table #SAfe0003(id int primary key, val varchar(20) null)");
    stmt0.execute ("insert into #SAfe0003 values (1, 'Line 1') " + "insert into #SAfe0003 values (2, 'Line 2')");
    while (stmt0.getMoreResults () || stmt0.getUpdateCount () != - 1);
    final Object o1 = new Object (), o2 = new Object ();
    int threadCount = 25;
    Thread threads [] = new Thread [threadCount];
    started = done = 0;
    failed = false;
    for (int i = 0; i < threadCount; i ++) {
        threads [i] = new Thread () {
            public void run () {
                ResultSet rs;
                Statement stmt = null;
                try {
                    stmt = con.createStatement (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
                    rs = stmt.executeQuery ("SELECT * FROM #SAfe0003");
                    assertEquals (null, rs.getWarnings ());
                    assertEquals (null, stmt.getWarnings ());
                    synchronized (o2) {
                        synchronized (o1) {
                            started ++;
                            o1.notify ();
                        }
                        try {
                            o2.wait ();
                        } catch (InterruptedException e) {
                        }
                    }
                    assertNotNull ("executeQuery should not return null", rs);
                    assertTrue (rs.next ());
                    assertTrue (rs.next ());
                    assertTrue (! rs.next ());
                    assertTrue (rs.previous ());
                    assertTrue (rs.previous ());
                    assertTrue (! rs.previous ());
                } catch (SQLException e) {
                    e.printStackTrace ();
                    synchronized (o1) {
                        failed = true;
                    }
                    fail ("An SQL Exception occured: " + e);
                } finally {
                    if (stmt != null) {
                        try {
                            stmt.close ();
                        } catch (SQLException e) {
                        }
                    }
                    synchronized (o1) {
                        done ++;
                        o1.notify ();
                    }
                }
            }
        }
        ;
        threads [i].start ();
    }
    while (true) {
        synchronized (o1) {
            if (started == threadCount) {
                break;
            }
            o1.wait ();
        }
    }
    synchronized (o2) {
        o2.notifyAll ();
    }
    boolean passed = true;
    for (int i = 0; i < threadCount; i ++) {
        stmt0 = con.createStatement ();
        ResultSet rs = stmt0.executeQuery ("SELECT 1234");
        passed &= rs.next ();
        passed &= ! rs.next ();
        stmt0.close ();
    }
    while (true) {
        synchronized (o1) {
            if (done == threadCount) {
                break;
            }
            o1.wait ();
        }
    }
    for (int i = 0; i < threadCount; i ++) {
        threads [i].join ();
    }
    stmt0.close ();
    assertTrue (passed);
    assertTrue (! failed);
}


public void testSocketConcurrency2 () {
    final Connection con = this.con;
    final int threadCount = 10, loopCount = 10;
    final Vector errors = new Vector ();
    StringBuffer valueBuffer = new StringBuffer (4000);
    while (valueBuffer.length () < 4000) {
        valueBuffer.append ("0123456789");
    }
    final String value = valueBuffer.toString ();
    Thread heavyThreads [] = new Thread [threadCount], lightThreads [] = new Thread [threadCount];
    for (int i = 0; i < threadCount; i ++) {
        heavyThreads [i] = new Thread () {
            public void run () {
                try {
                    PreparedStatement pstmt = con.prepareStatement ("SELECT ? AS value1, ? AS value2");
                    pstmt.setString (1, value);
                    pstmt.setString (2, value);
                    for (int i = 0; i < loopCount; i ++) {
                        pstmt.execute ();
                    }
                    pstmt.close ();
                } catch (SQLException ex) {
                    ex.printStackTrace ();
                    errors.add (ex);
                }
            }
        }
        ;
    }
    for (int i = 0; i < threadCount; i ++) {
        lightThreads [i] = new Thread () {
            public void run () {
                try {
                    sleep (100);
                } catch (InterruptedException ex) {
                }
                try {
                    Statement stmt = con.createStatement ();
                    for (int i = 0; i < loopCount; i ++) {
                        stmt.execute ("SELECT 1");
                    }
                    stmt.close ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                    errors.add (ex);
                }
            }
        }
        ;
    }
    for (int i = 0; i < threadCount; i ++) {
        heavyThreads [i].start ();
        lightThreads [i].start ();
    }
    for (int i = 0; i < threadCount; i ++) {
        try {
            heavyThreads [i].join ();
        } catch (InterruptedException ex) {
        }
        try {
            lightThreads [i].join ();
        } catch (InterruptedException ex) {
        }
    }
    assertEquals (0, errors.size ());
}


-----Function Pair=398=-----==

public String getpname (String pid) {
    String message = "";
    Connection conn = null;
    PreparedStatement pm = null;
    ResultSet rs = null;
    try {
        conn = Pool.getConnection ();
        pm = conn.prepareStatement ("select inname from addwuliao where pid=?");
        pm.setString (1, pid);
        rs = pm.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                message = rs.getString ("inname");
            }
        }
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } catch (Exception e) {
        e.printStackTrace ();
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } finally {
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    }
    return message;
}


public void doPreparedStatementExecute (Connection conn, String id) throws SQLException {
    try {
        int key = getNextKey ();
        String bValue = "doPreparedStatementExecute:" + id + ":" + testId;
        PreparedStatement s1;
        if (key >= MAX_KEY_VALUE) {
            key = key % MAX_KEY_VALUE;
            s1 = conn.prepareStatement ("delete from many_threads where a = ?");
            s1.setInt (1, key);
            s1.execute ();
            s1.close ();
        }
        s1 = conn.prepareStatement ("insert into many_threads values (?, ?, 0)");
        s1.setInt (1, key);
        s1.setString (2, bValue);
        assertEquals (1, execute (s1, false));
        s1.close ();
        s1 = conn.prepareStatement ("select a from many_threads where a = ?");
        s1.setInt (1, key);
        assertEquals (key, execute (s1, true));
        s1.close ();
        s1 = conn.prepareStatement ("update many_threads set value = a * a, b = b || ? where a = ?");
        s1.setString (1, "&" + bValue);
        s1.setInt (2, key + 1);
        execute (s1, false);
        s1.close ();
        if (! conn.getAutoCommit ()) {
            conn.commit ();
        }
    } catch (SQLException e) {
        if (! conn.getAutoCommit ()) {
            try {
                conn.rollback ();
            } catch (SQLException e2) {
            }
        }
    }
}


-----Function Pair=399=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public HashSet < ClassRoom > findAllClassRoom () throws DBConnectionException, SelectException {
    HashSet < ClassRoom > classroomSet = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME).toString ());
        if (result != null) {
            classroomSet = new HashSet < ClassRoom > ();
            while (result.next ()) {
                ClassRoom classroom = new ClassRoom ();
                classroom.setId (result.getInt ("CLASSROOM_ID"));
                classroom.setName (result.getString ("CLASSROOM_NAME"));
                classroom.setCapacity (result.getInt ("CLASSROOM_CAPACITY"));
                classroomSet.add (classroom);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return classroomSet;
}


-----Function Pair=400=-----==

public void testDatetimeRounding3 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 992);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 993);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr3 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr3 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr3");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public static int deleteContract (String likePatten) {
    Connection conn = null;
    PreparedStatement psmt = null;
    StringBuffer SQL = new StringBuffer (200);
    int deleted = 0;
    SQL.append (" DELETE FROM JHF_ALIVE_CONTRACT ").append (" WHERE   ORDER_ID LIKE  ? ");
    try {
        conn = JdbcConnectionPool.mainConnection ();
        conn.setAutoCommit (false);
        conn.setReadOnly (false);
        psmt = conn.prepareStatement (SQL.toString ());
        psmt.setString (1, "%" + likePatten + "%");
        deleted = psmt.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        if (null != conn) {
            try {
                conn.rollback ();
            } catch (SQLException e1) {
                System.out.println (" error when roll back !");
            }
        }
    } finally {
        try {
            if (null != psmt) {
                psmt.close ();
                psmt = null;
            }
            if (null != conn) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            System.out.println (" error  when psmt close or conn close .");
        }
    }
    return deleted;
}


