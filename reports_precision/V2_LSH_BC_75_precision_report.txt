Found 5/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public void init (IEditorSite site, IEditorInput input) throws PartInitException {
    try {
        if (input instanceof ContractModelInput) {
            modelManager = new ContractModelManager ((ContractModelInput) input);
            Contract = (ContractImpl) create ();
        }
        else if (input instanceof IFileEditorInput) {
            IFile file = ((IFileEditorInput) input).getFile ();
            ContractModelInput lModelInput = new FileContractModelInput (file);
            modelManager = new ContractModelManager (lModelInput);
            Contract = (ContractImpl) create ();
        }
        if (null == getContract () || Contract == null) {
            throw new PartInitException ("");
        }
    } catch (CoreException e) {
        throw new PartInitException (e.getStatus ());
    } catch (ClassCastException e) {
        throw e;
    } catch (Exception ex) {
        if (modelManager != null) {
            modelManager.handleError (ex);
        }
    }
    super.init (site, input);
    getDelegatingCommandStack ().addCommandStackListener (getDelegatingCommandStackListener ());
    getSite ().getWorkbenchWindow ().getSelectionService ().addSelectionListener (getSelectionListener ());
    createActions ();
}


public Object convertFromOriginal (Object original) {
    Element modelElement = findElement ((EditPart) original);
    if (modelElement.allowGlobalSelection ()) {
        if (modelElement instanceof Node) {
            Node nodeElement = (Node) modelElement;
            if (nodeElement.getLevel () == 0) {
                return null;
            }
            else {
                if (modelElement instanceof ChildPattern) {
                    return modelElement;
                }
                else {
                    Xelement xElement = nodeElement.getXelement ();
                    return (xElement != null) ? Util.getElementWrapper (xElement) : null;
                }
            }
        }
        else {
            return modelElement;
        }
    }
    else {
        return FORBID_SELECTION;
    }
}


-----Function Pair=2=-----==

protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    Diagram model = createInitialModel ();
    attachModelToResource (model, modelResource);
    org.eclipse.gmf.runtime.notation.Diagram diagram = ViewService.createDiagram (model, DiagramEditPart.MODEL_ID, CtbDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (com.hofstetter.diplthesis.ctb.ctb.diagram.part.CtbDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (com.hofstetter.diplthesis.ctb.ctb.diagram.part.CtbDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        CtbDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


public void setInput (IEditorInput input) {
    super.setInput (input);
    fDiagramModel = ((DiagramEditorInput) input).getDiagramModel ();
    fDiagramModel.getArchimateModel ().eAdapters ().add (eCoreAdapter);
    DefaultEditDomain domain = new DefaultEditDomain (this) {
        private CommandStack stack;
        @Override
        public CommandStack getCommandStack () {
            if (stack == null) {
                stack = (CommandStack) fDiagramModel.getAdapter (CommandStack.class);
            }
            return stack;
        }
    }
    ;
    setEditDomain (domain);
    setPartName (input.getName ());
    Preferences.STORE.addPropertyChangeListener (appPreferencesListener);
}


-----Function Pair=3=-----==

protected PaletteRoot getPaletteRoot () {
    PaletteRoot root = new PaletteRoot ();
    PaletteGroup manipGroup = new PaletteGroup ("Manipulate elements");
    root.add (manipGroup);
    PanningSelectionToolEntry selectionToolEntry = new PanningSelectionToolEntry ();
    manipGroup.add (selectionToolEntry);
    MarqueeToolEntry marqueeToolEntry = new MarqueeToolEntry ();
    manipGroup.add (marqueeToolEntry);
    PanningToolEntry panningToolEntry = new PanningToolEntry ();
    manipGroup.add (panningToolEntry);
    PaletteSeparator sep2 = new PaletteSeparator ();
    root.add (sep2);
    PaletteGroup instGroup = new PaletteGroup ("Create elements");
    root.add (instGroup);
    instGroup.add (createPolylineToolEntry ());
    instGroup.add (createRectangleToolEntry ());
    instGroup.add (createEllipseToolEntry ());
    root.setDefaultEntry (selectionToolEntry);
    return root;
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof SiseorAbstractNavigatorItem) {
        return;
    }
    SiseorAbstractNavigatorItem abstractNavigatorItem = (SiseorAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof SiseorNavigatorItem) {
        navigatorView = ((SiseorNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof SiseorNavigatorGroup) {
        SiseorNavigatorGroup navigatorGroup = (SiseorNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof SiseorNavigatorItem) {
            navigatorView = ((SiseorNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=4=-----==

public void resourceChanged (final IResourceChangeEvent event) {
    if (event.getType () == IResourceChangeEvent.POST_CHANGE) {
        final IEditorInput input = getEditorInput ();
        IMarkerDelta [] deltas = event.findMarkerDeltas (IMarker.PROBLEM, true);
        if (deltas.length > 0) {
            return;
        }
        if (input instanceof IFileEditorInput) {
            Display.getDefault ().asyncExec (new Runnable () {
                public void run () {
                    IFile file = ((IFileEditorInput) input).getFile ();
                    if (! file.exists ()) {
                        IWorkbenchPage page = PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getActivePage ();
                        page.closeEditor (VisualDBEditor.this, false);
                    }
                    else {
                        if (! getPartName ().equals (file.getName ())) {
                            setPartName (file.getName ());
                        }
                        if (needViewerRefreshFlag) {
                            refreshGraphicalViewer ();
                        }
                        else {
                            needViewerRefreshFlag = true;
                        }
                    }
                }
            }
            );
        }
    }
}


public void afficherService () {
    System.out.println ("Nom : " + service.getLabel ());
    System.out.println ("Des : " + service.getDescription ());
    System.out.println ("Pla : " + service.getPlatform ());
    System.out.println ("Loc : " + service.getLocation ());
    System.out.println ("Err : " + service.getErrors ());
    List < ServiceInput > list = service.getInputs ();
    Iterator < ServiceInput > i = list.iterator ();
    System.out.println ("Inp : " + service.getInputs ());
    while (i.hasNext ()) {
        ServiceInput courant = i.next ();
        System.out.println (courant.getName ());
        System.out.println (courant.getDescription ());
        System.out.println (courant.getMIMEType ());
        System.out.println (courant.getOption ());
        System.out.println (courant.getDefaultValue ());
    }
    if (service.getFileByFileInputIndex () != - 1) {
        System.out.println ("FbF Inp : " + service.getInputs ().get (service.getFileByFileInputIndex ()).getName ());
    }
    else {
        System.out.println ("FbF Inp : Pas d√©fini");
    }
    System.out.println ("Out : " + service.getOutputs ());
}


-----Function Pair=5=-----==

public Object getAdapter (Class type) {
    if (type == org.eclipse.gef.ui.stackview.CommandStackInspectorPage.class) {
        return new CommandStackInspectorPage (getCommandStack ());
    }
    if (type == org.eclipse.ui.views.contentoutline.IContentOutlinePage.class) {
        return outlinePage = new OutlinePage (new TreeViewer ());
    }
    if (type == IContentOverviewPage.class) {
        return new OverviewPage (new TreeViewer ());
    }
    if (type == org.eclipse.gef.editparts.ZoomManager.class) {
        return ((ScalableFreeformRootEditPart) getGraphicalViewer ().getRootEditPart ()).getZoomManager ();
    }
    else {
        return super.getAdapter (type);
    }
}


private void initialize (Composite parent) {
    GridLayout gridLayout = new GridLayout ();
    gridLayout.numColumns = 3;
    gridLayout.verticalSpacing = 15;
    createKeywordCombo (parent);
    createReplaceCombo (parent);
    GridData gridData = new GridData ();
    gridData.horizontalAlignment = GridData.FILL;
    gridData.horizontalSpan = 3;
    gridData.grabExcessHorizontalSpace = true;
    this.tabFolder = new TabFolder (parent, SWT.NONE);
    this.tabFolder.setLayoutData (gridData);
    createRegionGroup (this.tabFolder);
    createResultGroup (this.tabFolder);
    parent.setLayout (gridLayout);
    this.selectAllCheckBox (true);
}


-----Function Pair=6=-----==

private PaletteEntry findEntry (EditPart editPart, final String label) {
    final PaletteEntry [] entryWrapper = new PaletteEntry [1];
    new VisitableImpl < EditPart > () {
        public Collection < EditPart > getChildren (EditPart editPart) {
            return editPart.getChildren ();
        }
    }
    .accept (editPart, new Visitor < EditPart > () {
        public Result visit (EditPart editPart) {
            PaletteEntry entry = (PaletteEntry) editPart.getModel ();
            if (entry != null && label.equals (entry.getLabel ())) {
                entryWrapper [0] = entry;
                return Result.stop;
            }
            return Result.ok;
        }
    }
    );
    return entryWrapper [0];
}


public void partActivated (IWorkbenchPart part) {
    if (part != LogicEditor.this) return;
    if (! ((IFileEditorInput) getEditorInput ()).getFile ().exists ()) {
        Shell shell = getSite ().getShell ();
        String title = LogicMessages.GraphicalEditor_FILE_DELETED_TITLE_UI;
        String message = LogicMessages.GraphicalEditor_FILE_DELETED_WITHOUT_SAVE_INFO;
        String [] buttons = {LogicMessages.GraphicalEditor_SAVE_BUTTON_UI, LogicMessages.GraphicalEditor_CLOSE_BUTTON_UI};
        MessageDialog dialog = new MessageDialog (shell, title, null, message, MessageDialog.QUESTION, buttons, 0);
        if (dialog.open () == 0) {
            if (! performSaveAs ()) partActivated (part);
        }
        else {
            closeEditor (false);
        }
    }
}


-----Function Pair=7=-----==

protected void initializeGraphicalViewer () {
    super.initializeGraphicalViewer ();
    EditPartViewer viewer = getGraphicalViewer ();
    Object objDoc = getEditorInput ().getAdapter (Document.class);
    if (objDoc != null) {
        document = (Document) objDoc;
    }
    PaletteBuilder.populatePalette (document.getTemplate (), getPaletteRoot ());
    viewer.setContents (getDiagram ());
    viewer.addDropTargetListener (createTransferDropTargetListener (getGraphicalViewer ()));
    paletteOperator = new PaletteOperator (csdePaletteViewerProvider.getViewer (), PaletteBuilder.getDrawers ());
    viewer.addSelectionChangedListener (paletteOperator);
    log.debug ("Palette visible: " + getPaletteRoot ().isVisible ());
    getGraphicalControl ().addMouseListener (new MouseAdapter () {
        public void mouseUp (MouseEvent e) {
            if (clickPoint == null) clickPoint = new Point (e.x, e.y);
            else {
                clickPoint.x = e.x;
                clickPoint.y = e.y;
            }
        }
    }
    );
}


public ArrayList < Component > getAllComponents () {
    ArrayList < Component > list = new ArrayList < Component > ();
    log.debug ("num components : " + this.getComponentCount ());
    for (int i = 0; i < this.getComponentCount (); i ++) {
        Component comp = this.getComponent (i);
        if (comp instanceof JPanel) {
            log.debug ("JPanel inside!");
            list.addAll (getAllComponentsOfPanel ((JPanel) comp));
        }
        else if (comp instanceof VGraphics) {
            list.add ((VGraphics) comp);
        }
        else if (comp instanceof Component) {
            list.add (comp);
        }
    }
    log.debug ("final list : ");
    for (Component vdeb : list) {
        log.debug (vdeb);
    }
    return list;
}


-----Function Pair=8=-----==

protected static void tridag (double [] a, double [] b, double [] c, double [] r, double [] u, int n) throws JuggleExceptionInternal {
    int j;
    double bet;
    double [] gam = new double [n];
    if (b [0] == 0.0) throw new JuggleExceptionInternal ("Error 1 in TRIDAG");
    bet = b [0];
    u [0] = r [0] / bet;
    for (j = 1; j < n; j ++) {
        gam [j] = c [j - 1] / bet;
        bet = b [j] - a [j - 1] * gam [j];
        if (bet == 0.0) throw new JuggleExceptionInternal ("Error 2 in TRIDAG");
        u [j] = (r [j] - a [j - 1] * u [j - 1]) / bet;
    }
    for (j = (n - 1); j > 0; j --) u [j - 1] -= gam [j] * u [j];
}


void createItem (final CoolItem item, int index) {
    int count = items.length;
    if (! (0 <= index && index <= count)) error (SWT.ERROR_INVALID_RANGE);
    int id = 0;
    id = items.length;
    if ((item.style & SWT.DROP_DOWN) != 0) {
    }
    int lastIndex = getLastIndexOfRow (index - 1);
    boolean fixLast = index == lastIndex + 1;
    if (fixLast) {
    }
    if (index == 0 && count > 0) {
        getItem (0).setWrap (false);
    }
    Element el = document.createElement ("DIV");
    el.className = "cool-item-default";
    if (index == count) {
        handle.appendChild (el);
    }
    else {
        handle.insertBefore (el, items [index].handle);
    }
    item.handle = el;
    el = document.createElement ("DIV");
    el.className = "cool-item-handler";
    item.handle.appendChild (el);
    if ((item.style & SWT.DROP_DOWN) != 0) {
        el = document.createElement ("DIV");
        el.className = "cool-item-more";
        item.handle.appendChild (el);
        item.moreHandle = el;
        el = document.createElement ("SPAN");
        el.appendChild (document.createTextNode (">"));
        item.moreHandle.appendChild (el);
        el = document.createElement ("SPAN");
        el.appendChild (document.createTextNode (">"));
        el.className = "cool-item-more-arrow";
        item.moreHandle.appendChild (el);
        item.configure ();
    }
    item.configureDND (el);
    el = document.createElement ("DIV");
    el.className = "cool-item-content";
    item.handle.appendChild (el);
    item.contentHandle = el;
    if (fixLast) {
        resizeToPreferredWidth (lastIndex);
    }
    item.wrap = false;
    items [item.id = id] = item;
    int length = originalItems.length;
    CoolItem [] newOriginals = new CoolItem [length + 1];
    System.arraycopy (originalItems, 0, newOriginals, 0, index);
    System.arraycopy (originalItems, index, newOriginals, index + 1, length - index);
    newOriginals [index] = item;
    originalItems = newOriginals;
}


-----Function Pair=9=-----==

public void cmdProc (Interp interp, TclObject argv []) throws TclException {
    try {
        CommandLine cl = parseCommandLine (argv);
        if (cl.hasOption ("help")) {
            new HelpFormatter ().printHelp ("jmx_connect ", "======================================================================", this.opts, "======================================================================", true);
            System.out.println ("jmx_connect establishes a connection to a JMX server.");
            return;
        }
        this.connect (cl);
    } catch (ParseException e) {
        throw new TclException (interp, e.getMessage (), 1);
    } catch (RuntimeException e) {
        logger.error ("Runtime Exception", e);
        throw new TclException (interp, "Runtime exception.", 1);
    }
}


public void doPrintClassCommand (String command, String [] args) {
    if (args.length == 0) return;
    try {
        int addr = parseHex32 (args [0]);
        jdp_console.writeOutput (user.bmap.addressToClassString (addr));
    } catch (NumberFormatException e) {
        try {
            jdp_console.writeOutput (args [0] + " = " + user.bmap.staticToString (args [0]));
        } catch (BmapNotFoundException e1) {
            jdp_console.writeOutput (e1.getMessage ());
        }
    } catch (memoryException e1) {
        jdp_console.writeOutput (args [0] + " is not a valid object address");
    }
}


-----Function Pair=10=-----==

private void makeObject () {
    ObjectInfo profile = (ObjectInfo) objects.elementAt (objChoice.getSelectedIndex ());
    Curve path;
    CoordinateSystem pathCoords;
    if (pathBox.getState ()) {
        ObjectInfo info = (ObjectInfo) paths.elementAt (pathChoice.getSelectedIndex ());
        path = (Curve) info.object;
        pathCoords = info.coords;
    }
    else {
        Vec3 dir = new Vec3 ();
        if (xBox.getState ()) dir.x = distField.getValue ();
        else if (yBox.getState ()) dir.y = distField.getValue ();
        else if (zBox.getState ()) dir.z = distField.getValue ();
        else dir.set (xField.getValue (), yField.getValue (), zField.getValue ());
        Vec3 v [] = new Vec3 [(int) segField.getValue () + 1];
        float smooth [] = new float [v.length];
        for (int i = 0; i < v.length; i ++) {
            v [i] = new Vec3 (dir);
            v [i].scale (i / segField.getValue ());
            smooth [i] = 1.0f;
        }
        path = new Curve (v, smooth, Mesh.INTERPOLATING, false);
        pathCoords = new CoordinateSystem (new Vec3 (), Vec3.vz (), Vec3.vy ());
    }
    Object3D obj;
    if (profile.object == path) obj = null;
    else if (profile.object instanceof TriangleMesh) obj = extrudeMesh ((TriangleMesh) profile.object, path, profile.coords, pathCoords, angleField.getValue () * Math.PI / 180.0, orientBox.getState ());
    else if (profile.object instanceof Curve) obj = extrudeCurve ((Curve) profile.object, path, profile.coords, pathCoords, angleField.getValue () * Math.PI / 180.0, orientBox.getState ());
    else obj = extrudeMesh (profile.object.convertToTriangleMesh (tolField.getValue ()), path, profile.coords, pathCoords, angleField.getValue () * Math.PI / 180.0, orientBox.getState ());
    Texture tex = window.getScene ().getDefaultTexture ();
    obj.setTexture (tex, tex.getDefaultMapping ());
    preview.setObject (obj);
    preview.repaint ();
}


void normalizeMethod (JCMethodDecl md, List < JCStatement > initCode) {
    if (md.name == names.init && TreeInfo.isInitialConstructor (md)) {
        List < JCStatement > stats = md.body.stats;
        ListBuffer < JCStatement > newstats = new ListBuffer < JCStatement > ();
        if (stats.nonEmpty ()) {
            while (TreeInfo.isSyntheticInit (stats.head)) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
            newstats.append (stats.head);
            stats = stats.tail;
            while (stats.nonEmpty () && TreeInfo.isSyntheticInit (stats.head)) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
            newstats.appendList (initCode);
            while (stats.nonEmpty ()) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
        }
        md.body.stats = newstats.toList ();
        if (md.body.endpos == Position.NOPOS) md.body.endpos = TreeInfo.endPos (md.body.stats.last ());
    }
}


-----Function Pair=11=-----==

public Obj (File file) throws EOFException, IOException, ParseException {
    this ();
    this.readMesh (file);
    String fpath [] = file.getPath ().split (File.separator);
    String fname [] = fpath [fpath.length - 1].split ("\\.");
    switch (fname.length) {
        case 0 :
            {
                throw new ParseException ("Filename parse error: " + file.getPath (), 0);
            }
        case 1 :
        case 2 :
            {
                this._name = fname [0];
                break;
            }
        default :
            {
                this._name = fname [0];
                for (int i = 1; i < fname.length - 1; i ++) this._name += "_" + fname [i];
                break;
            }
    }
}


static void init (Hashtable table) {
    if (_rgbtxt == null) return;
    StringBuffer foo = new StringBuffer ();
    for (int i = 0; i < _rgbtxt.length; i ++) {
        foo.append (_rgbtxt [i]);
    }
    rgbtxt = foo.toString ();
    _rgbtxt = null;
    foo = null;
    try {
        InputStream is = new ByteArrayInputStream (RGBTXT.rgbtxt.getBytes ());
        BufferedReader br = new BufferedReader (new InputStreamReader (is));
        StreamTokenizer st = new StreamTokenizer (br);
        st.ordinaryChar ('!');
        String token = null;
        char c;
        int r, g, b;
        byte [] buf = new byte [1024];
        while (st.nextToken () != st.TT_EOF) {
            if (st.ttype == '!') {
                while ((c = (char) br.read ()) != '\n');
                continue;
            }
            if (st.ttype == st.TT_NUMBER) {
                r = (int) st.nval;
                st.nextToken ();
                g = (int) st.nval;
                st.nextToken ();
                b = (int) st.nval;
                int i = 0;
                while ((c = (char) br.read ()) != '\n') {
                    if (c == '\t') continue;
                    if (c == ' ') continue;
                    if ('A' <= c && c <= 'Z') {
                        c = (char) ('a' + c - 'A');
                    }
                    buf [i] = (byte) c;
                    i ++;
                }
                table.put (new String (buf, 0, i), new Color (r, g, b));
                continue;
            }
        }
        st = null;
        buf = null;
    } catch (Exception e) {
    }
}


-----Function Pair=12=-----==

public static void main (String [] args) {
    final BranchOfSimulativeTest main = new BranchOfSimulativeTest ();
    main.setVisible (true);
    bindMouseEvents (main);
    new Thread () {
        @Override
        public void run () {
            try {
                Thread.sleep (1000);
            } catch (Exception e) {
            }
            main.startTest ();
        }
    }
    .start ();
}


void TryInitThroughDatahub () {
    if (! gotDatahubInit) {
        String programMode = getParameter ("programMode");
        if (programMode == null) {
            gotDatahubInit = true;
        }
        else {
            try {
                Applet dataHub = getAppletContext ().getApplet ("datahub");
                if (dataHub != null) {
                    net.sf.yacas.DatahubApplet cons = (net.sf.yacas.DatahubApplet) dataHub;
                    cons.setProgramMode (programMode);
                    String programContentsToLoad = "[" + cons.getProgram () + "];";
                    gotDatahubInit = true;
                    InvokeCalculationSilent (programContentsToLoad);
                }
            } catch (Exception e) {
            }
        }
    }
}


-----Function Pair=13=-----==

private void bruteForceSort (int values []) {
    PerfMonTimer timerOuter = PerfMonTimer.start ("SortingTest.bruteForceSort");
    try {
        int len = values.length;
        for (int i = len; i > 1; i --) {
            int v = values [len - 1];
            int insertionPoint = 0;
            for (insertionPoint = 0; insertionPoint < values.length - i; insertionPoint ++) {
                if (v <= values [insertionPoint]) {
                    break;
                }
            }
            int numToMove = len - insertionPoint - 1;
            System.arraycopy (values, insertionPoint, values, insertionPoint + 1, numToMove);
            values [insertionPoint] = v;
        }
    } finally {
        PerfMonTimer.stop (timerOuter);
    }
}


private short remapLocaleMap (int fontIndex, int styleIndex, short scriptID, short fontID) {
    String scriptName = getString (table_scriptIDs [scriptID]);
    String value = (String) localeMap.get (scriptName);
    if (value == null) {
        String fontName = fontNames [fontIndex];
        String styleName = styleNames [styleIndex];
        value = (String) localeMap.get (fontName + "." + styleName + "." + scriptName);
    }
    if (value == null) {
        return fontID;
    }
    for (int i = 0; i < table_componentFontNameIDs.length; i ++) {
        String name = getString (table_componentFontNameIDs [i]);
        if (value.equalsIgnoreCase (name)) {
            fontID = (short) i;
            break;
        }
    }
    return fontID;
}


-----Function Pair=14=-----==

private static synchronized void installExtraLookAndFeels () {
    if (extraLnFsInstalled) return;
    extraLnFsInstalled = true;
    int extraLooksCount = Integer.parseInt (Jin.getInstance ().getAppProperty ("lf.extra.count", "0"));
    for (int i = 0; i < extraLooksCount; i ++) {
        String name = Jin.getInstance ().getAppProperty ("lf.extra." + i + ".name", null);
        String className = Jin.getInstance ().getAppProperty ("lf.extra." + i + ".class", null);
        String minRequiredJavaVer = Jin.getInstance ().getAppProperty ("lf.extra." + i + ".minRequiredJava", "0");
        if (PlatformUtils.isJavaBetterThan (minRequiredJavaVer)) {
            try {
                Class.forName (className);
                UIManager.installLookAndFeel (name, className);
            } catch (ClassNotFoundException e) {
            }
        }
    }
}


public void commit () throws PIMException {
    synchronized (i2) {
        if (owner == null) throw new PIMException ("The item does not belong to a list.");
        owner.checkListClosed ();
        owner.checkListMode (PIM.READ_ONLY);
        if (isModified ()) {
            updateRevisionDate ();
            int length = 0;
            boolean next = indexInStringArray (- 1, - 1);
            if (! next) length = i2.int2;
            byte [] [] stringbytes = new byte [length] [];
            for (int i = 0; i < length; i ++) {
                if (stringvalues [i] != null) stringbytes [i] = stringvalues [i].getBytes ();
                else stringbytes [i] = null;
            }
            if (getListType () == PIM.EVENT_LIST) ((EventImpl) this).loadRepeatRule ();
            rechandle = commitN (owner.listType, owner.handle, rechandle, stringids, stringbytes, byteids, bytevalues, longvalues, categories, Integer.parseInt (categories [0]));
            modified = false;
        }
        valuesFromOS = true;
        clearArrays ();
    }
}


-----Function Pair=15=-----==

private static void f (int i, byte [] key, byte [] a, byte [] x) {
    byte [] e = new byte [64];
    byte [] ikey = new byte [64];
    byte [] y = new byte [64];
    System.arraycopy (a, 0, e, 0, e.length);
    transpose (e, EP, 48);
    for (int j = rots [i]; j > 0; j --) {
        rotate (key);
    }
    System.arraycopy (key, 0, ikey, 0, ikey.length);
    transpose (ikey, KeyTr2, 48);
    for (int j = 0; j < 48; j ++) {
        y [j] = (byte) (e [j] ^ ikey [j]);
    }
    for (int j = 0; j < 8; j ++) {
        int k = j + 1;
        int r = 32 * y [6 * k - 6] + 8 * y [6 * k - 5] + 4 * y [6 * k - 4] + 2 * y [6 * k - 3] + y [6 * k - 2] + 16 * y [6 * k - 1];
        int xb = s_boxes [j] [r];
        x [4 * k - 4] = (byte) ((xb>> 3) & 1);
        x [4 * k - 3] = (byte) ((xb>> 2) & 1);
        x [4 * k - 2] = (byte) ((xb>> 1) & 1);
        x [4 * k - 1] = (byte) (xb & 1);
    }
    transpose (x, ptr, 32);
}


private static double [] comp_iratio (BsplineKnotVector knotData, int j, double param, double p_tol) {
    double [] t = new double [2];
    double kf, kb;
    kf = knotData.knotValueAt (j + knotData.degree ());
    kb = knotData.knotValueAt (j);
    double kdiff = kf - kb;
    if (kdiff < p_tol) {
        t [0] = 0.5;
        t [1] = 0.5;
        return t;
    }
    t [0] = (kf - param) / kdiff;
    t [1] = 1.0 - t [0];
    return t;
}


-----Function Pair=16=-----==

void compress () {
    int position, newPosition;
    byte [] data = new byte [3];
    int hash;
    for (int i = 0; i < HASH; i ++) {
        hashtable [i] = new Link ();
    }
    for (int i = 0; i < WINDOW; i ++) {
        window [i] = new Link ();
    }
    nextWindow = 0;
    Link firstPosition;
    Match match;
    int deferredPosition = - 1;
    Match deferredMatch = null;
    writeBits (0x01, 1);
    writeBits (0x01, 2);
    outputLiteral (in [0]);
    position = 1;
    while (position < inLength) {
        if (inLength - position < MIN_LENGTH) {
            outputLiteral (in [position]);
            position = position + 1;
            continue;
        }
        data [0] = in [position];
        data [1] = in [position + 1];
        data [2] = in [position + 2];
        hash = hash (data);
        firstPosition = hashtable [hash];
        match = findLongestMatch (position, firstPosition);
        updateHashtable (position, position + 1);
        if (match != null) {
            if (deferredMatch != null) {
                if (match.length > deferredMatch.length + 1) {
                    outputLiteral (in [deferredPosition]);
                    deferredPosition = position;
                    deferredMatch = match;
                    position = position + 1;
                }
                else {
                    outputMatch (deferredMatch.length, deferredMatch.distance);
                    newPosition = deferredPosition + deferredMatch.length;
                    deferredPosition = - 1;
                    deferredMatch = null;
                    updateHashtable (position + 1, newPosition);
                    position = newPosition;
                }
            }
            else {
                deferredPosition = position;
                deferredMatch = match;
                position = position + 1;
            }
        }
        else {
            if (deferredMatch != null) {
                outputMatch (deferredMatch.length, deferredMatch.distance);
                newPosition = deferredPosition + deferredMatch.length;
                deferredPosition = - 1;
                deferredMatch = null;
                updateHashtable (position + 1, newPosition);
                position = newPosition;
            }
            else {
                outputLiteral (in [position]);
                position = position + 1;
            }
        }
    }
    writeBits (0, 7);
    alignToByte ();
}


public static void QuickSortASC (float [] [] M, int inicio, int fim, int [] index) {
    int i, j, k;
    float [] aux = new float [M [0].length];
    float [] pivo = new float [index.length];
    for (i = 0; i < index.length; i ++) {
        pivo [i] = M [inicio] [index [i]];
    }
    i = inicio;
    j = fim;
    while (i < j) {
        while (M [i] [index [1]] <= pivo [1] && i < fim) {
            if (M [i] [index [1]] == pivo [1]) {
                if (M [i] [index [0]] <= pivo [0]) {
                    i ++;
                }
                else {
                    break;
                }
            }
            else {
                i ++;
            }
        }
        while (M [j] [index [1]] >= pivo [1] && j > inicio) {
            if (M [j] [index [1]] == pivo [1]) {
                if (M [j] [index [0]] >= pivo [0]) {
                    j --;
                }
                else {
                    break;
                }
            }
            else {
                j --;
            }
        }
        if (i < j) {
            for (k = 0; k < M [0].length; k ++) {
                aux [k] = M [i] [k];
            }
            for (k = 0; k < M [0].length; k ++) {
                M [i] [k] = M [j] [k];
            }
            for (k = 0; k < M [0].length; k ++) {
                M [j] [k] = aux [k];
            }
        }
    }
    if (inicio != j) {
        for (k = 0; k < M [0].length; k ++) {
            aux [k] = M [inicio] [k];
        }
        for (k = 0; k < M [0].length; k ++) {
            M [inicio] [k] = M [j] [k];
        }
        for (k = 0; k < M [0].length; k ++) {
            M [j] [k] = aux [k];
        }
    }
    if (inicio < j - 1) {
        QuickSortASC (M, inicio, j - 1, index);
    }
    if (fim > j + 1) {
        QuickSortASC (M, j + 1, fim, index);
    }
}


-----Function Pair=17=-----==

private int decodeBlackCodeWord () throws PdfException {
    int current, entry, bits, isT, twoBits, code = - 1;
    int runLength = 0;
    boolean isWhite = false;
    while (! isWhite) {
        current = nextLesserThan8Bits (4);
        entry = initBlack [current];
        isT = entry & 0x0001;
        bits = (entry>>> 1) & 0x000f;
        code = (entry>>> 5) & 0x07ff;
        if (code == 100) {
            current = nextNBits (9);
            entry = black [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x000f;
            code = (entry>>> 5) & 0x07ff;
            if (bits == 12) {
                updatePointer (5);
                current = nextLesserThan8Bits (4);
                entry = additionalMakeup [current];
                bits = (entry>>> 1) & 0x07;
                code = (entry>>> 4) & 0x0fff;
                runLength += code;
                updatePointer (4 - bits);
            }
            else if (bits == 15) throw new PdfException (("TIFFFaxDecoder2"));
            else {
                runLength += code;
                updatePointer (9 - bits);
                if (isT == 0) isWhite = true;
            }
        }
        else if (code == 200) {
            current = nextLesserThan8Bits (2);
            entry = twoBitBlack [current];
            code = (entry>>> 5) & 0x07ff;
            runLength += code;
            bits = (entry>>> 1) & 0x0f;
            updatePointer (2 - bits);
            isWhite = true;
        }
        else {
            runLength += code;
            updatePointer (4 - bits);
            isWhite = true;
        }
    }
    return runLength;
}


ImageData (Object data, boolean isByRef) {
    this.data = data;
    dataIsByRef = isByRef;
    dataWidth = ((ImageData) data).dataWidth;
    dataHeight = ((ImageData) data).dataHeight;
    if (data == null) {
        imageDataType = ImageDataType.TYPE_NULL;
        length = 0;
    }
    else if (data instanceof byte []) {
        imageDataType = ImageDataType.TYPE_BYTE_ARRAY;
        length = ((byte []) data).length;
    }
    else if (data instanceof int []) {
        imageDataType = ImageDataType.TYPE_INT_ARRAY;
        length = ((int []) data).length;
    }
    else if (data instanceof ByteBuffer) {
        imageDataType = ImageDataType.TYPE_BYTE_BUFFER;
        length = ((ByteBuffer) data).limit ();
    }
    else if (data instanceof IntBuffer) {
        imageDataType = ImageDataType.TYPE_INT_BUFFER;
        length = ((IntBuffer) data).limit ();
    }
    else {
        assert false;
    }
}


-----Function Pair=18=-----==

void filterRow (byte [] row, byte [] previousRow, int filterType) {
    int byteOffset = headerChunk.getFilterByteOffset ();
    switch (filterType) {
        case PngIhdrChunk.FILTER_NONE :
            break;
        case PngIhdrChunk.FILTER_SUB :
            for (int i = byteOffset; i < row.length; i ++) {
                int current = row [i] & 0xFF;
                int left = row [i - byteOffset] & 0xFF;
                row [i] = (byte) ((current + left) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_UP :
            for (int i = 0; i < row.length; i ++) {
                int current = row [i] & 0xFF;
                int above = previousRow [i] & 0xFF;
                row [i] = (byte) ((current + above) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_AVERAGE :
            for (int i = 0; i < row.length; i ++) {
                int left = (i < byteOffset) ? 0 : row [i - byteOffset] & 0xFF;
                int above = previousRow [i] & 0xFF;
                int current = row [i] & 0xFF;
                row [i] = (byte) ((current + ((left + above) / 2)) & 0xFF);
            }
            break;
        case PngIhdrChunk.FILTER_PAETH :
            for (int i = 0; i < row.length; i ++) {
                int left = (i < byteOffset) ? 0 : row [i - byteOffset] & 0xFF;
                int aboveLeft = (i < byteOffset) ? 0 : previousRow [i - byteOffset] & 0xFF;
                int above = previousRow [i] & 0xFF;
                int a = Math.abs (above - aboveLeft);
                int b = Math.abs (left - aboveLeft);
                int c = Math.abs (left - aboveLeft + above - aboveLeft);
                int preductor = 0;
                if (a <= b && a <= c) {
                    preductor = left;
                }
                else if (b <= c) {
                    preductor = above;
                }
                else {
                    preductor = aboveLeft;
                }
                int currentValue = row [i] & 0xFF;
                row [i] = (byte) ((currentValue + preductor) & 0xFF);
            }
            break;
    }
}


private void getDirection (final Node node, final OctTree octTree, final double [] dir) {
    for (int d = 0; d < nrDims; d ++) dir [d] = 0.0;
    double dir2 = addRepulsionDir (node, octTree, dir);
    dir2 += addAttractionDir (node, dir);
    dir2 += addGravitationDir (node, dir);
    if (dir2 != 0.0) {
        for (int d = 0; d < nrDims; d ++) dir [d] /= dir2;
        double scale = 1.0;
        for (int d = 0; d < nrDims; d ++) {
            double width = octTree.maxPos [d] - octTree.minPos [d];
            if (width > 0.0) scale = Math.min (scale, Math.abs (width / 16 / dir [d]));
        }
        for (int d = 0; d < nrDims; d ++) dir [d] *= scale;
    }
    else {
        for (int d = 0; d < nrDims; d ++) dir [d] = 0.0;
    }
}


-----Function Pair=19=-----==

public void mouseClicked (MouseEvent me) {
    int caretPosition = newQuery.getCaretPosition ();
    String query = newQuery.getText ();
    String queryMiddle;
    if (type != null && feature != null) {
        queryMiddle = "{" + type + "." + feature + "==\"" + text + "\"}";
        for (int row = 0; row < numShortcuts; row ++) {
            if (shortcuts [row] [ANNOTATION_TYPE].equals (type) && shortcuts [row] [FEATURE].equals (feature)) {
                queryMiddle = "{" + shortcuts [row] [SHORTCUT] + "==\"" + text + "\"}";
                break;
            }
        }
    }
    else {
        queryMiddle = text;
    }
    if (position == LEFT) {
        newQuery.setText (queryMiddle + query);
    }
    else if (position == RIGHT) {
        newQuery.setText (query + queryMiddle);
    }
    else {
        String queryLeft = (newQuery.getSelectionStart () == newQuery.getSelectionEnd ()) ? query.substring (0, caretPosition) : query.substring (0, newQuery.getSelectionStart ());
        String queryRight = (newQuery.getSelectionStart () == newQuery.getSelectionEnd ()) ? query.substring (caretPosition, query.length ()) : query.substring (newQuery.getSelectionEnd (), query.length ());
        newQuery.setText (queryLeft + queryMiddle + queryRight);
    }
}


public void onChange (Widget arg0) {
    switch (scope.getSelectedIndex ()) {
        case FilterData.LEVEL :
            setLevel ();
            break;
        case FilterData.URI :
            setNormal ();
            break;
        case FilterData.LOGGER :
            setNormal ();
            break;
        case FilterData.CLASS :
            setNormal ();
            break;
        case FilterData.METHOD :
            setNormal ();
            break;
        case FilterData.MESSAGE :
            setNormal ();
            break;
        case FilterData.ACK :
            setAck ();
            break;
    }
}


-----Function Pair=20=-----==

private void sort (Object [] src, Object [] dest, int low, int high, int off) {
    int length = high - low;
    if (length < 10) {
        for (int i = low; i < high; i ++) for (int j = i; j > low && ((Comparable) dest [j - 1]).compareTo (dest [j]) > 0; j --) {
            swap (dest, j, j - 1);
        }
        return;
    }
    int destLow = low;
    int destHigh = high;
    low += off;
    high += off;
    int mid = (low + high)>> 1;
    sort (dest, src, low, mid, - off);
    sort (dest, src, mid, high, - off);
    if (((Comparable) src [mid - 1]).compareTo (src [mid]) <= 0) {
        System.arraycopy (src, low, dest, destLow, length);
        return;
    }
    for (int i = destLow, p = low, q = mid; i < destHigh; i ++) {
        if (q >= high || p < mid && ((Comparable) src [p]).compareTo (src [q]) <= 0) {
            dest [i] = src [p ++];
        }
        else {
            dest [i] = src [q ++];
        }
    }
}


public RecordStoreVariableLength [] split (int blockSize) {
    buildIndex ();
    RecordStoreVariableLength [] ret = new RecordStoreVariableLength [(size - 1) / blockSize + 1];
    int used = 0;
    int last = - 1;
    int j = 0;
    for (int i = 0; i < recordCount / INDEX_RECORD; i ++) {
        if (recIndex [i] - used > blockSize) {
            ret [j] = new RecordStoreVariableLength (recIndex [i] - used, maxLen, (i - last) * INDEX_RECORD);
            System.arraycopy (store, used, ret [j].store, 0, recIndex [i] - used);
            ret [j].size = recIndex [i] - used;
            used = recIndex [i];
            last = i;
            j += 1;
        }
    }
    if (used != size) {
        int l = size - used;
        ret [j] = new RecordStoreVariableLength (l, maxLen, recordCount - (last + 1) * INDEX_RECORD);
        System.arraycopy (store, used, ret [j].store, 0, l);
        ret [j].size = l;
    }
    return ret;
}


-----Function Pair=21=-----==

public void add (int index, double value) {
    if (values == null && value != 1.0) throw new IllegalArgumentException ("Trying to add non-1.0 value (" + dictionary.lookupObject (index) + "=" + value + ") to binary vector");
    assert (index >= 0);
    if (indices == null) {
        if (index >= values.length) {
            int newLength = index + 10;
            double [] newValues = new double [newLength];
            System.arraycopy (values, 0, newValues, 0, values.length);
            values = newValues;
            values [index] = value;
            assert (size <= index);
        }
        else {
            values [index] += value;
        }
        if (size <= index) size = index + 1;
    }
    else {
        if (size == indices.length) {
            int newLength;
            if (indices.length == 0) newLength = 4;
            else if (indices.length < 4) newLength = indices.length * 2;
            else if (indices.length < 100) newLength = (indices.length * 3) / 2;
            else newLength = indices.length + 150;
            if (values != null) {
                double [] newValues = new double [newLength];
                System.arraycopy (values, 0, newValues, 0, values.length);
                values = newValues;
            }
            int [] newIndices = new int [newLength];
            System.arraycopy (indices, 0, newIndices, 0, indices.length);
            indices = newIndices;
        }
        indices [size] = index;
        if (values != null) values [size] = value;
        size ++;
    }
}


public void run () {
    try {
        Socket.setSocketImplFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        ServerSocket.setSocketFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        DatagramSocket.setDatagramSocketImplFactory (new DatagramSocketImplFactory () {
            public DatagramSocketImpl createDatagramSocketImpl () {
                throw new VM_UnimplementedError ("Need to implement JikesRVMDatagramSocketImpl");
            }
        }
        );
    } catch (java.io.IOException e) {
        VM.sysWrite ("trouble setting socket impl factories");
    }
    VM_Controller.boot ();
    ClassLoader cl = VM_ClassLoader.getApplicationClassLoader ();
    setContextClassLoader (cl);
    VM_Class cls = null;
    try {
        VM_Atom mainAtom = VM_Atom.findOrCreateUnicodeAtom (args [0].replace ('.', '/'));
        VM_TypeReference mainClass = VM_TypeReference.findOrCreate (cl, mainAtom.descriptorFromClassName ());
        cls = mainClass.resolve ().asClass ();
        cls.resolve ();
        cls.instantiate ();
        cls.initialize ();
    } catch (ClassNotFoundException e) {
        VM.sysWrite (e + "\n");
        return;
    }
    mainMethod = cls.findMainMethod ();
    if (mainMethod == null) {
        VM.sysWrite (cls + " doesn't have a \"public static void main(String[])\" method to execute\n");
        return;
    }
    String [] mainArgs = new String [args.length - 1];
    for (int i = 0, n = mainArgs.length; i < n; ++ i) mainArgs [i] = args [i + 1];
    mainMethod.compile ();
    VM_Callbacks.notifyStartup ();
    VM.debugBreakpoint ();
    VM_Magic.invokeMain (mainArgs, mainMethod.getCurrentCompiledMethod ().getInstructions ());
}


-----Function Pair=22=-----==

private void reorderSequenceForLocale (String [] seq) {
    Object val = getReorderSequence ();
    if (val instanceof String) {
        for (int i = 0; i < seq.length; i ++) {
            if (seq [i].equals (val)) {
                shuffle (seq, i, 0);
                return;
            }
        }
    }
    else if (val instanceof String []) {
        String [] fontLangs = (String []) val;
        for (int l = 0; l < fontLangs.length; l ++) {
            for (int i = 0; i < seq.length; i ++) {
                if (seq [i].equals (fontLangs [l])) {
                    shuffle (seq, i, l);
                }
            }
        }
    }
}


public static String setHexStringMask (int [] arr, int minByteCount, int maxByteCount) {
    String str = "";
    int num = 0;
    int maxForThisByte = 0;
    if (arr != null) {
        arr = sort (arr);
        for (int i = 0; i < arr.length; i ++) {
            while ((arr [i] - (arr [i] % 8)) > maxForThisByte) {
                maxForThisByte += 8;
                str = ("." + Integer.toHexString (num | 0x100).substring (1)) + str;
                num = 0;
            }
            num = num | (1 << (arr [i] - (arr [i] - (arr [i] % 8))));
        }
        str = ("." + Integer.toHexString (num | 0x100).substring (1)) + str;
        str = str.substring (1);
    }
    if (minByteCount > 0) {
        minByteCount = ((minByteCount * 3) - 1);
        while (str.length () < minByteCount) {
            str = "00." + str;
        }
    }
    if (maxByteCount > 0 && maxByteCount >= minByteCount) {
        maxByteCount = (maxByteCount * 3);
        while (str.length () >= maxByteCount) {
            str = str.substring (3);
        }
    }
    if (str.endsWith (".")) {
        str = str.substring (0, str.length () - 1);
    }
    return str;
}


-----Function Pair=23=-----==

public static void callHets (byte [] snps) {
    int sizecount = 1;
    int segcount = 0;
    int hetstart = 0;
    int segstart = 0;
    byte prevbyte = - 1;
    int hetlimit = 11;
    int minsegments = 3;
    int numberOfSnps = snps.length;
    for (int s = 0; s < numberOfSnps; s ++) {
        byte thisbyte = snps [s];
        if (thisbyte != N) {
            if (thisbyte == prevbyte) {
                sizecount ++;
            }
            else {
                if (sizecount > hetlimit) {
                    if (segcount >= minsegments) {
                        for (int h = hetstart; h < segstart; h ++) {
                            if (snps [h] != N) snps [h] = H;
                        }
                    }
                    sizecount = 1;
                    segcount = 0;
                    hetstart = s;
                    segstart = s;
                    prevbyte = thisbyte;
                }
                else {
                    sizecount = 1;
                    segcount ++;
                    segstart = s;
                    prevbyte = thisbyte;
                }
            }
        }
    }
    if (sizecount > hetlimit) {
        if (segcount >= minsegments) {
            for (int h = hetstart; h < segstart; h ++) {
                if (snps [h] != N) snps [h] = H;
            }
        }
    }
    else {
        if (segcount >= minsegments - 1) {
            for (int h = hetstart; h < numberOfSnps; h ++) {
                if (snps [h] != N) snps [h] = H;
            }
        }
    }
}


public boolean usunNawiasyLiczby () {
    boolean answer = false;
    int intVal = 0;
    float intVal2 = 0;
    boolean intC = false;
    boolean intF = false;
    String line = makeLine ();
    podzielNaWszystkieNawiasy (line);
    for (int i = 0; i < inArt; i ++) {
        intC = false;
        intF = false;
        try {
            intVal = Integer.parseInt (art [i]);
            intF = true;
        } catch (NumberFormatException e) {
            intF = false;
        }
        if (! intF) {
            try {
                intVal2 = Float.parseFloat (art [i]);
                intC = true;
            } catch (NumberFormatException e) {
                intC = false;
            }
        }
        if ((intF) || (intC)) {
            try {
                if ((art [i - 1].equals ("(")) && (art [i + 1].equals (")"))) {
                    usunElement (i + 1);
                    usunElement (i - 1);
                }
            } catch (Exception e) {
            }
        }
    }
    return true;
}


-----Function Pair=24=-----==

public static void print (String str) {
    if (logging) {
        if (logFile != null || logFile.checkError ()) {
            logFile.println (Timer.getTime () + ": " + str);
        }
        else {
            stopLog ();
            print ("Logging failed.");
        }
    }
    if (flushToStd) System.out.println (AppDefinition.getApplicationShortName () + " [" + Timer.getTime () + "]: " + str);
    if (! intiated) {
        return;
    }
    if (numberOfLinesEntered < maxVisibleLines) numberOfLinesEntered ++;
    for (int i = 0; i < maxVisibleLines - 1; i ++) text [i] = text [i + 1];
    text [maxVisibleLines - 1] = str;
    if (consoleState == State.HIDDEN && consoleAutoOpen) openConsole ();
    if (consoleState != State.HIDDEN) {
        setTextArea ();
        vertices [7] = area.getActualHeight () + 5.0f;
        vertices [10] = area.getActualHeight () + 5.0f;
    }
}


private void getNextChangingElement (int a0, boolean isWhite, int [] ret) {
    int [] pce = this.prevChangingElems;
    int ces = this.changingElemSize;
    int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
    if (isWhite) {
        start &= ~ 0x1;
    }
    else {
        start |= 0x1;
    }
    int i = start;
    for (; i < ces; i += 2) {
        int temp = pce [i];
        if (temp > a0) {
            lastChangingElement = i;
            ret [0] = temp;
            break;
        }
    }
    if (i + 1 < ces) {
        ret [1] = pce [i + 1];
    }
}


-----Function Pair=25=-----==

private int [] [] decaleBlocs (int [] [] base) {
    if (base.length != 3) System.exit (1);
    for (int i = 0; i < 3; i ++) if (base [i].length != 3) System.exit (2);
    int [] [] sudoku = new int [9] [9];
    int [] gen = new int [9];
    for (int i = 0; i < 3; i ++) {
        for (int j = 0; j < 3; j ++) gen [3 * i + j] = base [i] [j];
    }
    for (int i = 0; i < 3; i ++) {
        for (int j = 0; j < 3; j ++) {
            for (int k = 0; k < 9; k ++) sudoku [3 * i + j] [k] = gen [k];
            decaleListe (gen);
        }
        decaleMiniListe (gen);
    }
    return sudoku;
}


public JDPServer (int initialPort) {
    port = initialPort;
    boolean socketOpened = false;
    while (! socketOpened) {
        try {
            serverSocket = new ServerSocket (port);
            System.out.println ("JDPServer running on port " + port);
            socketOpened = true;
        } catch (IOException e) {
            if (++ port > 65536) {
                System.err.println ("No available port");
                System.exit (1);
            }
        }
    }
}


-----Function Pair=26=-----==

private void sendData (RdpPacket_Localised data, int data_pdu_type) throws RdesktopException, IOException, CryptoException {
    CommunicationMonitor.lock (this);
    int length;
    data.setPosition (data.getHeader (RdpPacket.RDP_HEADER));
    length = data.getEnd () - data.getPosition ();
    data.setLittleEndian16 (length);
    data.setLittleEndian16 (RDP_PDU_DATA | 0x10);
    data.setLittleEndian16 (SecureLayer.getUserID () + 1001);
    data.setLittleEndian32 (this.rdp_shareid);
    data.set8 (0);
    data.set8 (1);
    data.setLittleEndian16 (length - 14);
    data.set8 (data_pdu_type);
    data.set8 (0);
    data.setLittleEndian16 (0);
    SecureLayer.send (data, Constants.encryption ? Secure.SEC_ENCRYPT : 0);
    CommunicationMonitor.unlock (this);
}


public void paint (Graphics _g) {
    super.paint (_g);
    _g.setColor (BCalqueGrilleReguliere.this.getForeground ());
    _g.setFont (BCalqueGrilleReguliere.this.getFont ());
    NumberFormat nf = NumberFormat.getInstance (Locale.FRENCH);
    nf.setMaximumFractionDigits (2);
    double iv = zmin_;
    double av = zmax_;
    if (! Double.isNaN (minVal_)) {
        iv = minVal_;
    }
    if (! Double.isNaN (maxVal_)) {
        av = maxVal_;
    }
    _g.drawString (nf.format (av) + getM (), 0, _g.getFontMetrics ().getHeight ());
    _g.drawString (nf.format ((iv + av) / 2) + getM (), 0, (this.getHeight () + _g.getFontMetrics ().getHeight ()) / 2);
    _g.drawString (nf.format (iv) + getM (), 0, this.getHeight ());
}


-----Function Pair=27=-----==

public void flagCompletedLines () {
    for (int y = 0; y < gridMaxHeight; y ++) {
        boolean linecleared = true;
        for (int x = 0; x < gridMaxWidth; x ++) {
            if (this.grid [x] [y] == - 1) {
                linecleared = false;
                break;
            }
        }
        if (linecleared) {
            this.clearedLines [y] = 1;
        }
        else {
            this.clearedLines [y] = 0;
        }
    }
}


public static byte cssFontVariant (String input, final boolean lowerCaseOnly) {
    if (input == null) {
        return - 1;
    }
    if (! lowerCaseOnly) {
        input = input.toLowerCase ();
    }
    if (input.equals (FontUtility.INPUT_NORMAL)) {
        return Font.FONT_VARIANT_NORMAL;
    }
    if (input.equals (FontUtility.INPUT_SMALL_CAPS)) {
        return Font.FONT_VARIANT_SMALL_CAPS;
    }
    return - 1;
}


-----Function Pair=28=-----==

private void paintCurves (Graphics g) {
    int i, j;
    String xName, yName, lName;
    String xvs, yvs;
    double x [] = new double [nPts];
    double y [] = new double [nPts];
    double xSorted [] = new double [nPts];
    double ySorted [] = new double [nPts];
    FontMetrics fm = g.getFontMetrics ();
    for (i = 0; i < nPts; i ++) {
        xName = "x" + i;
        yName = "y" + i;
        lName = "l" + i;
        Drawable xi = getDrawable (xName);
        Drawable yi = getDrawable (yName);
        Drawable li = getDrawable (lName);
        xSorted [i] = x [i] = 0.02 * (xi.getX () - xBase);
        ySorted [i] = y [i] = 0.02 * (xi.getY () - yi.getY ());
        g.setColor (curveColor [i % curveColor.length]);
        xvs = doubleFormat (x [i], 2);
        yvs = doubleFormat (y [i], 2);
        int wx = fm.stringWidth (xvs);
        int wy = fm.stringWidth (yvs);
        int h = fm.getHeight ();
        g.drawString (xvs, xi.getX () - wx / 2, xi.getY () + h);
        g.drawString (yvs, 2 + li.getX (), li.getY () + h / 2);
    }
    int ix, iy, ixLast, iyLast;
    double rx, ry, rxstep;
    if (doLagrange) {
        lagrange (x, y);
        if (showContrib) {
            for (i = 0; i < nPts; i ++) {
                g.setColor (curveColor [i % curveColor.length]);
                ixLast = - 1;
                iyLast = - 1;
                for (ix = 0; ix <= 500; ix += 5) {
                    rx = 0.02 * (ix - xBase);
                    ry = polyEval (rx, lagpoly, i, nPts - 1);
                    iy = yBase - (int) (ry * 50.0);
                    if (iy > 10000) iy = 10000;
                    if (iy < - 10000) iy = - 10000;
                    if (ixLast >= 0) {
                        g.drawLine (ixLast, iyLast, ix, iy);
                    }
                    ixLast = ix;
                    iyLast = iy;
                }
            }
        }
        g.setColor (Color.white);
        ixLast = - 1;
        iyLast = - 1;
        for (ix = 0; ix <= 500; ix += 5) {
            rx = 0.02 * (ix - xBase);
            ry = polyEval (rx, intpoly, nPts - 1);
            iy = yBase - (int) (ry * 50.0 + 0.5);
            if (iy > 2000) iy = 2000;
            if (iy < - 2000) iy = - 2000;
            if (ixLast >= 0) {
                g.drawLine (ixLast, iyLast, ix, iy);
            }
            ixLast = ix;
            iyLast = iy;
        }
    }
    if (doSpline) {
        double tmp;
        g.setColor (steelBlue);
        for (i = 0; i < nPts; i ++) {
            boolean noExch = true;
            for (j = 0; j < nPts - 1; j ++) {
                if (xSorted [j] > xSorted [j + 1]) {
                    tmp = xSorted [j + 1];
                    xSorted [j + 1] = xSorted [j];
                    xSorted [j] = tmp;
                    tmp = ySorted [j + 1];
                    ySorted [j + 1] = ySorted [j];
                    ySorted [j] = tmp;
                    noExch = false;
                }
            }
            if (noExch) break;
        }
        computeSplineSlopes (nPts - 1, xSorted, ySorted, slopes);
        int seg;
        ixLast = - 1;
        iyLast = - 1;
        int nDivs = 50;
        for (seg = 0; seg < nPts - 1; seg ++) {
            rxstep = (xSorted [seg + 1] - xSorted [seg]) / nDivs;
            for (i = 0; i < nDivs; i ++) {
                rx = xSorted [seg] + i * rxstep;
                ry = splineEval (rx, xSorted [seg], xSorted [seg + 1], ySorted [seg], ySorted [seg + 1], slopes [seg], slopes [seg + 1]);
                iy = yBase - (int) (ry * 50.0 + 0.5);
                ix = xBase + (int) (rx * 50.0 + 0.5);
                if (iy > 2000) iy = 2000;
                if (iy < - 2000) iy = - 2000;
                if (ixLast >= 0) {
                    g.drawLine (ixLast, iyLast, ix, iy);
                }
                ixLast = ix;
                iyLast = iy;
            }
        }
    }
}


public void doPrintCommand (String command, String [] args) {
    int addr, frame;
    String varname;
    if (args.length == 0) {
        jdp_console.writeOutput (user.bmap.localVariableToString (0, null));
        return;
    }
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            addr = parseHex32 (args [1]);
            String classname = args [0].substring (1, rparen);
            try {
                jdp_console.writeOutput (classname + " = " + user.bmap.classToString (classname, addr, false));
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
        return;
    }
    frame = CommandLine.localParseFrame (args [0]);
    varname = CommandLine.localParseName (args [0]);
    if (frame != - 1) {
        if (varname == null) {
            jdp_console.writeOutput (user.bmap.localVariableToString (frame, null));
        }
        else {
            if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (frame, varname));
            else jdp_console.writeOutput (user.bmap.localVariableToString (frame, varname));
        }
        return;
    }
    if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (0, varname));
    else jdp_console.writeOutput (user.bmap.localVariableToString (0, varname));
    return;
}


-----Function Pair=29=-----==

public void rotateCurrentBlockClockwise () {
    int currentorientation = this.currentBlock.orientation;
    this.currentBlock.rotateClockwise ();
    this.currentBlock.recalcBlockOrientation ();
    for (int i = 0; i < 4; i ++) {
        if (this.currentBlock.xPos + this.currentBlock.subblocks [i].xpos >= this.gridMaxWidth) {
            this.currentBlock.orientation = currentorientation;
            this.currentBlock.recalcBlockOrientation ();
            return;
        }
        if (this.currentBlock.yPos + this.currentBlock.subblocks [i].ypos >= this.gridMaxHeight) {
            this.currentBlock.orientation = currentorientation;
            this.currentBlock.recalcBlockOrientation ();
            return;
        }
        if (grid [this.currentBlock.subblocks [i].xpos + this.currentBlock.xPos] [this.currentBlock.subblocks [i].ypos + this.currentBlock.yPos] != - 1) {
            this.currentBlock.orientation = currentorientation;
            this.currentBlock.recalcBlockOrientation ();
            return;
        }
    }
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=30=-----==

public void paintToBitmap (Graphics g) {
    synchronized (this) {
        if (g instanceof Graphics2D) {
            Graphics2D g2d = null;
            g2d = (Graphics2D) g;
            g2d.addRenderingHints (new RenderingHints (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON));
            g2d.setStroke (new BasicStroke ((float) (2), BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
        }
        FontMetrics metrics = getFontMetrics (font);
        g.setColor (bkColor);
        int yfrom = 0;
        g.setFont (font);
        int inHeight = fontHeight;
        int yto = getHeight ();
        if (! outputDirty) yfrom += getHeight () - inHeight;
        if (! inputDirty) yto -= inHeight;
        g.clearRect (0, yfrom, getWidth (), yto);
        g.setColor (Color.black);
        int i;
        int y = getHeight () - inHeight - g.getFontMetrics ().getHeight ();
        int canvasHeight = getHeight () - fontHeight - 1;
        if (outputDirty) {
            y -= totalLinesHeight;
            if (canvasHeight < totalLinesHeight) {
                int th = calcThumbHeight ();
                double scale = (1.0 * thumbPos) / (canvasHeight - th - 4);
                y += (int) ((1 - scale) * (totalLinesHeight - canvasHeight));
            }
            g.setClip (0, 0, getWidth (), getHeight () - fontHeight - 1);
            for (i = 0; i < nrLines; i ++) {
                int index = (currentLine + i) % nrLines;
                if (lines [index] != null) {
                    if (y + lines [index].height (g) > 0) {
                        lines [index].draw (g, inset, y);
                    }
                    y += lines [index].height (g);
                }
            }
            g.setClip (0, 0, getWidth (), getHeight ());
            int w = getWidth ();
            if (canvasHeight < totalLinesHeight) {
                int thumbHeight = calcThumbHeight ();
                g.setColor (Color.white);
                g.fillRect (w - scrollWidth, 0, scrollWidth, canvasHeight);
                if (thumbMoused) g.setColor (new Color (192, 192, 240));
                else g.setColor (new Color (124, 124, 224));
                g.fillRect (w - scrollWidth + 2, thumbPos + 2, scrollWidth - 4, thumbHeight);
                g.setColor (Color.black);
                g.drawRect (w - scrollWidth, 0, scrollWidth, canvasHeight);
                g.drawRect (w - scrollWidth + 2, thumbPos + 2, scrollWidth - 4, thumbHeight);
            }
        }
        y = getHeight () - g.getFontMetrics ().getDescent ();
        outputDirty = false;
        if (focusGained && ! calculating) {
            if (inputDirty) {
                if (y + fontHeight > 0) {
                    int promptLength = metrics.stringWidth (inputPrompt);
                    g.setColor (Color.red);
                    g.setFont (font);
                    g.drawString (inputPrompt, inset, y);
                    g.drawString (inputLine, inset + promptLength, y);
                    int cursorLocation = promptLength;
                    for (i = 0; i < cursorPos; i ++) {
                        cursorLocation += metrics.charWidth (inputLine.charAt (i));
                    }
                    y += g.getFontMetrics ().getDescent ();
                    g.setColor (Color.blue);
                    g.drawLine (inset + cursorLocation, y - 2, inset + cursorLocation, y - fontHeight + 1);
                }
            }
        }
        else {
            String toPrint = "Click here to enter an expression";
            if (calculating) {
                toPrint = "Calculating...";
            }
            int promptLength = metrics.stringWidth (toPrint);
            g.setColor (Color.blue);
            g.setFont (font);
            g.drawString (toPrint, inset, y);
            y += g.getFontMetrics ().getDescent ();
        }
        inputDirty = false;
    }
}


public void focusLost (FocusEvent e) {
    try {
        String entered = m_diaValue.getText ();
        if ("".equals (entered)) return;
        float newvalue = Float.parseFloat (entered);
        float oldvalue = m_project.getModel ().getDiameter ();
        if (newvalue != oldvalue) {
            m_project.getModel ().setDiameter (newvalue);
            m_project.setModified ();
        }
    } catch (NumberFormatException nfe) {
    } finally {
        m_diaValue.setText (Float.toString (m_project.getModel ().getDiameter ()));
    }
}


-----Function Pair=31=-----==

public Block < ? > getTestBlockForCon (Constructor < T > pCon, Expression < ? > [] curPlans) {
    notNull (pCon);
    notNull (curPlans);
    final Class < T > testeeType = pCon.getDeclaringClass ();
    final Block < ? > b = new BlockImpl (testeeType, pCon, testBlockSpaces);
    final BlockStatement < ? > [] bs = new BlockStatement [curPlans.length + 1];
    final Variable < ? > [] ids = new Variable [curPlans.length];
    Class < ? > [] paramsTypes = pCon.getParameterTypes ();
    for (int i = 0; i < curPlans.length; i ++) {
        ids [i] = b.getNextID (paramsTypes [i]);
        bs [i] = new LocalVariableDeclarationStatement (ids [i], curPlans [i]);
    }
    ConstructorCall < T > conPlan = null;
    if (typeGraph.getWrapper (pCon.getDeclaringClass ()).isInnerClass ()) {
        Expression [] paramPlans = new Expression [curPlans.length - 1];
        for (int j = 0; j < paramPlans.length; j ++) {
            paramPlans [j] = ids [j + 1];
        }
        conPlan = new ConstructorCall < T > (testeeType, pCon, paramPlans, ids [0]);
    }
    else {
        conPlan = new ConstructorCall < T > (testeeType, pCon, ids);
    }
    bs [curPlans.length] = new ExpressionStatement < T > (conPlan);
    List < BlockStatement > blockStatements = new LinkedList < BlockStatement > ();
    for (BlockStatement blockStatement : bs) blockStatements.add (blockStatement);
    b.setBlockStmts (blockStatements);
    return b;
}


private void weightAndPlaceClasses () {
    int rows = getRows ();
    for (int curRow = _maxPackageRank; curRow < rows; curRow ++) {
        xPos = getHGap () / 2;
        BOTLObjectSourceDiagramNode [] rowObject = getObjectsInRow (curRow);
        for (int i = 0; i < rowObject.length; i ++) {
            if (curRow == _maxPackageRank) {
                int nDownlinks = rowObject [i].getDownlinks ().size ();
                rowObject [i].setWeight ((nDownlinks > 0) ? (1 / nDownlinks) : 2);
            }
            else {
                Vector uplinks = rowObject [i].getUplinks ();
                int nUplinks = uplinks.size ();
                if (nUplinks > 0) {
                    float average_col = 0;
                    for (int j = 0; j < uplinks.size (); j ++) {
                        average_col += ((BOTLObjectSourceDiagramNode) (uplinks.elementAt (j))).getColumn ();
                    }
                    average_col /= nUplinks;
                    rowObject [i].setWeight (average_col);
                }
                else {
                    rowObject [i].setWeight (1000);
                }
            }
        }
        int [] pos = new int [rowObject.length];
        for (int i = 0; i < pos.length; i ++) {
            pos [i] = i;
        }
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            for (int i = 0; i < pos.length - 1; i ++) {
                if (rowObject [pos [i]].getWeight () > rowObject [pos [i + 1]].getWeight ()) {
                    int temp = pos [i];
                    pos [i] = pos [i + 1];
                    pos [i + 1] = temp;
                    swapped = true;
                }
            }
        }
        for (int i = 0; i < pos.length; i ++) {
            rowObject [pos [i]].setColumn (i);
            if ((i > _vMax) && (rowObject [pos [i]].getUplinks ().size () == 0) && (rowObject [pos [i]].getDownlinks ().size () == 0)) {
                if (getColumns (rows - 1) > _vMax) {
                    rows ++;
                }
                rowObject [pos [i]].setRank (rows - 1);
            }
            else {
                rowObject [pos [i]].setLocation (new Point (xPos, yPos));
                xPos += rowObject [pos [i]].getSize ().getWidth () + getHGap ();
            }
        }
        yPos += getRowHeight (curRow) + getVGap ();
    }
}


-----Function Pair=32=-----==

private boolean getPsiP (int iv, int jv, int kv) {
    int i, j;
    double x, y;
    if (iv < nn || iv > (nx - nn + 1)) return (false);
    if (jv < nn || jv > (ny - nn + 1)) return (false);
    x = i2x (iv);
    y = j2y (jv);
    if ((i2x (iv) < 0) && (Math.abs (j2y (jv)) < ywindow)) return (false);
    for (j = - nn; j <= nn; j ++) {
        for (i = - nn; i <= nn; i ++) {
            if (Math.abs (vBx [nn] [j + nn] [i + nn]) > 1000000.0) return (false);
            if (Math.abs (vBy [nn] [j + nn] [i + nn]) > 1000000.0) return (false);
        }
    }
    psi [nn] [nn] = 0;
    for (j = nn - 1; j >= 0; j --) {
        psi [nn] [j] = psi [nn] [j + 1] + vBy [nn] [nn] [j] * xres;
    }
    for (j = nn + 1; j < 2 * nn + 1; j ++) {
        psi [nn] [j] = psi [nn] [j - 1] - vBy [nn] [nn] [j] * xres;
    }
    for (i = nn + 1; i < 2 * nn + 1; i ++) {
        for (j = 0; j < 2 * nn + 1; j ++) {
            psi [i] [j] = psi [i - 1] [j] + yres * vBx [nn] [i] [j];
        }
    }
    for (i = nn - 1; i >= 0; i --) {
        for (j = 0; j < 2 * nn + 1; j ++) {
            psi [i] [j] = psi [i + 1] [j] - yres * vBx [nn] [i] [j];
        }
    }
    return (true);
}


public void method31 () {
    boolean flag = true;
    while (flag) {
        flag = false;
        for (int i = 0; i < anInt772 - 1; i ++) if (anIntArray774 [i] < anIntArray774 [i + 1]) {
            int j = anIntArray774 [i];
            anIntArray774 [i] = anIntArray774 [i + 1];
            anIntArray774 [i + 1] = j;
            long l = aLongArray773 [i];
            aLongArray773 [i] = aLongArray773 [i + 1];
            aLongArray773 [i + 1] = l;
            flag = true;
        }
    }
}


-----Function Pair=33=-----==

public void actionPerformed (ActionEvent ae) {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            thisInstance.setEnabled (false);
            try {
                searcher.next (((Number) numberOfResultsSpinner.getValue ()).intValue ());
            } catch (Exception e) {
                e.printStackTrace ();
                thisInstance.setEnabled (true);
            }
            processFinished ();
            pageOfResults ++;
            titleResults.setText ("Results - Page " + pageOfResults);
            thisInstance.setEnabled (true);
        }
    }
    );
}


public int considerOffer2 (SOCTradeOffer offer, int receiverNum) {
    D.ebugPrintln ("***** CONSIDER OFFER 2 *****");
    int response = REJECT_OFFER;
    SOCPlayer receiverPlayerData = game.getPlayer (receiverNum);
    SOCResourceSet receiverResources = receiverPlayerData.getResources ();
    SOCResourceSet rsrcsOut = offer.getGetSet ();
    SOCResourceSet rsrcsIn = offer.getGiveSet ();
    if ((receiverResources.getAmount (SOCResourceConstants.UNKNOWN) == 0) && (! receiverResources.contains (rsrcsOut))) {
        return response;
    }
    int senderNum = offer.getFrom ();
    D.ebugPrintln ("senderNum = " + senderNum);
    D.ebugPrintln ("receiverNum = " + receiverNum);
    D.ebugPrintln ("rsrcs from receiver = " + rsrcsOut);
    D.ebugPrintln ("rsrcs to receiver = " + rsrcsIn);
    SOCPossiblePiece receiverTargetPiece = targetPieces [receiverNum];
    D.ebugPrintln ("targetPieces[" + receiverNum + "] = " + receiverTargetPiece);
    SOCPlayerTracker receiverPlayerTracker = (SOCPlayerTracker) playerTrackers.get (new Integer (receiverNum));
    if (receiverPlayerTracker == null) {
        return response;
    }
    SOCPlayerTracker senderPlayerTracker = (SOCPlayerTracker) playerTrackers.get (new Integer (senderNum));
    if (senderPlayerTracker == null) {
        return response;
    }
    SOCRobotDM simulator;
    if (receiverTargetPiece == null) {
        Stack receiverBuildingPlan = new Stack ();
        simulator = new SOCRobotDM (brain.getRobotParameters (), playerTrackers, receiverPlayerTracker, receiverPlayerData, receiverBuildingPlan);
        if (receiverNum == ourPlayerData.getPlayerNumber ()) {
            simulator.planStuff (strategyType);
        }
        else {
            simulator.planStuff (strategyType);
        }
        if (receiverBuildingPlan.empty ()) {
            return response;
        }
        receiverTargetPiece = (SOCPossiblePiece) receiverBuildingPlan.peek ();
        targetPieces [receiverNum] = receiverTargetPiece;
    }
    D.ebugPrintln ("receiverTargetPiece = " + receiverTargetPiece);
    SOCPossiblePiece senderTargetPiece = targetPieces [senderNum];
    D.ebugPrintln ("targetPieces[" + senderNum + "] = " + senderTargetPiece);
    SOCPlayer senderPlayerData = game.getPlayer (senderNum);
    if (senderTargetPiece == null) {
        Stack senderBuildingPlan = new Stack ();
        simulator = new SOCRobotDM (brain.getRobotParameters (), playerTrackers, senderPlayerTracker, senderPlayerData, senderBuildingPlan);
        if (senderNum == ourPlayerData.getPlayerNumber ()) {
            simulator.planStuff (strategyType);
        }
        else {
            simulator.planStuff (strategyType);
        }
        if (senderBuildingPlan.empty ()) {
            return response;
        }
        senderTargetPiece = (SOCPossiblePiece) senderBuildingPlan.peek ();
        targetPieces [senderNum] = senderTargetPiece;
    }
    D.ebugPrintln ("senderTargetPiece = " + senderTargetPiece);
    int senderWGETA = senderPlayerTracker.getWinGameETA ();
    if (senderWGETA > WIN_GAME_CUTOFF) {
        boolean inARace = false;
        if ((receiverTargetPiece.getType () == SOCPossiblePiece.SETTLEMENT) || (receiverTargetPiece.getType () == SOCPossiblePiece.ROAD)) {
            Enumeration threatsEnum = receiverTargetPiece.getThreats ().elements ();
            while (threatsEnum.hasMoreElements ()) {
                SOCPossiblePiece threat = (SOCPossiblePiece) threatsEnum.nextElement ();
                if ((threat.getType () == senderTargetPiece.getType ()) && (threat.getCoordinates () == senderTargetPiece.getCoordinates ())) {
                    inARace = true;
                    break;
                }
            }
            if (inARace) {
                D.ebugPrintln ("inARace == true (threat from sender)");
            }
            else if (receiverTargetPiece.getType () == SOCPossiblePiece.SETTLEMENT) {
                Enumeration conflictsEnum = ((SOCPossibleSettlement) receiverTargetPiece).getConflicts ().elements ();
                while (conflictsEnum.hasMoreElements ()) {
                    SOCPossibleSettlement conflict = (SOCPossibleSettlement) conflictsEnum.nextElement ();
                    if ((senderTargetPiece.getType () == SOCPossiblePiece.SETTLEMENT) && (conflict.getCoordinates () == senderTargetPiece.getCoordinates ())) {
                        inARace = true;
                        break;
                    }
                }
                if (inARace) {
                    D.ebugPrintln ("inARace == true (conflict with sender)");
                }
            }
        }
        if (! inARace) {
            SOCResourceSet targetResources = null;
            switch (receiverTargetPiece.getType ()) {
                case SOCPossiblePiece.CARD :
                    targetResources = SOCGame.CARD_SET;
                    break;
                case SOCPossiblePiece.ROAD :
                    targetResources = SOCGame.ROAD_SET;
                    break;
                case SOCPossiblePiece.SETTLEMENT :
                    targetResources = SOCGame.SETTLEMENT_SET;
                    break;
                case SOCPossiblePiece.CITY :
                    targetResources = SOCGame.CITY_SET;
                    break;
            }
            SOCBuildingSpeedEstimate estimate = new SOCBuildingSpeedEstimate (receiverPlayerData.getNumbers ());
            SOCTradeOffer receiverBatna = getOfferToBank (targetResources);
            D.ebugPrintln ("*** receiverBatna = " + receiverBatna);
            int batnaBuildingTime = getETAToTargetResources (receiverPlayerData, targetResources, SOCResourceSet.EMPTY_SET, SOCResourceSet.EMPTY_SET, estimate);
            D.ebugPrintln ("*** batnaBuildingTime = " + batnaBuildingTime);
            int offerBuildingTime = getETAToTargetResources (receiverPlayerData, targetResources, rsrcsOut, rsrcsIn, estimate);
            D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
            if (offerBuildingTime < batnaBuildingTime) {
                response = ACCEPT_OFFER;
            }
            else {
                response = COUNTER_OFFER;
            }
        }
    }
    return response;
}


-----Function Pair=34=-----==

public double [] getNumericDataAsDouble (int numericArrayIndex) {
    Object dataNumeric = dataSetNumericAndSpatial [numericArrayIndex + 1];
    double [] doubleData = null;
    if (dataNumeric instanceof double []) {
        doubleData = (double []) dataNumeric;
    }
    else if (dataNumeric instanceof int []) {
        int [] intData = (int []) dataNumeric;
        doubleData = new double [intData.length];
        for (int i = 0; i < intData.length; i ++) {
            if (intData [i] == Integer.MIN_VALUE) {
                doubleData [i] = Double.NaN;
            }
            else {
                doubleData [i] = intData [i];
            }
        }
    }
    else {
        throw new IllegalArgumentException ("Unable to parse values in column " + numericArrayIndex + " as a number");
    }
    return doubleData;
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=35=-----==

protected void computeCoefficients () throws ArithmeticException {
    int i, j, n;
    double c [], tc [], d, t;
    n = degree () + 1;
    coefficients = new double [n];
    for (i = 0; i < n; i ++) {
        coefficients [i] = 0.0;
    }
    c = new double [n + 1];
    c [0] = 1.0;
    for (i = 0; i < n; i ++) {
        for (j = i; j > 0; j --) {
            c [j] = c [j - 1] - c [j] * x [i];
        }
        c [0] *= (- x [i]);
        c [i + 1] = 1;
    }
    tc = new double [n];
    for (i = 0; i < n; i ++) {
        d = 1;
        for (j = 0; j < n; j ++) {
            if (i != j) {
                d *= (x [i] - x [j]);
            }
        }
        if (d == 0.0) {
            throw new ArithmeticException ("Identical abscissas cause division by zero.");
        }
        t = y [i] / d;
        tc [n - 1] = c [n];
        coefficients [n - 1] += t * tc [n - 1];
        for (j = n - 2; j >= 0; j --) {
            tc [j] = c [j + 1] + tc [j + 1] * x [i];
            coefficients [j] += t * tc [j];
        }
    }
    coefficientsComputed = true;
}


public static int atomPropertyInt (Atom atom, int tokWhat) {
    switch (tokWhat) {
        case Token.atomno :
            return atom.getAtomNumber ();
        case Token.atomid :
            return atom.atomID;
        case Token.atomindex :
            return atom.getIndex ();
        case Token.bondcount :
            return atom.getCovalentBondCount ();
        case Token.color :
            return atom.group.chain.model.modelSet.viewer.getColorArgbOrGray (atom.getColix ());
        case Token.element :
        case Token.elemno :
            return atom.getElementNumber ();
        case Token.elemisono :
            return atom.atomicAndIsotopeNumber;
        case Token.file :
            return atom.getModelFileIndex () + 1;
        case Token.formalcharge :
            return atom.getFormalCharge ();
        case Token.groupid :
            return atom.getGroupID ();
        case Token.groupindex :
            return atom.group.getGroupIndex ();
        case Token.model :
            return atom.getModelNumber ();
        case - Token.model :
            return atom.getModelFileNumber ();
        case Token.modelindex :
            return atom.modelIndex;
        case Token.molecule :
            return atom.getMoleculeNumber (true);
        case Token.occupancy :
            return atom.getOccupancy100 ();
        case Token.polymer :
            return atom.getGroup ().getBioPolymerIndexInModel () + 1;
        case Token.polymerlength :
            return atom.getPolymerLength ();
        case Token.radius :
            return atom.getRasMolRadius ();
        case Token.resno :
            return atom.getResno ();
        case Token.site :
            return atom.getAtomSite ();
        case Token.structure :
            return atom.getProteinStructureType ().getId ();
        case Token.substructure :
            return atom.getProteinStructureSubType ().getId ();
        case Token.strucno :
            return atom.getStrucNo ();
        case Token.valence :
            return atom.getValence ();
    }
    return 0;
}


-----Function Pair=36=-----==

public static Hashtable factoresCostoEfectivo (double interesMensual, int year, int month, int day, int plazoPago, int diaPago, int mesesGracia, int dobleJulio, int dobleDiciembre, ArrayList cuotaGracia) {
    ArrayList lista = null;
    BNDate bnFecha = new BNDate ();
    BCostoEfectivo dataIni = new BCostoEfectivo ();
    if (mesesGracia == 0) {
        lista = inicializaCostoEfectivo (year, month, day);
        dataIni = (BCostoEfectivo) lista.get (mesesGracia);
        bnFecha.setFecha (dataIni.getFecha ());
    }
    else {
        lista = Util.copyArray (cuotaGracia);
        dataIni = (BCostoEfectivo) lista.get (mesesGracia);
        bnFecha.setFecha (dataIni.getFecha ());
    }
    long periodoAcumulado = 0;
    double sumatoriaFactor = 0;
    for (int i = 1 + mesesGracia; i <= plazoPago + mesesGracia; i ++) {
        bnFecha = Util.obtenerPeriodoSiguiente (bnFecha.getFecha (), diaPago);
        boolean ejecutaJul = false;
        boolean ejecutaDic = false;
        if (dobleJulio == 1 && Util.cuotaDoble (bnFecha.getFecha (), BNDate.MES_JULIO)) {
            ejecutaJul = true;
        }
        if (dobleDiciembre == 1 && Util.cuotaDoble (bnFecha.getFecha (), BNDate.MES_DICIEMBRE)) {
            ejecutaDic = true;
        }
        periodoAcumulado += bnFecha.getPeriodo ();
        double factor = Util.redondeoDouble (calculoFactor (interesMensual, periodoAcumulado), Util.NUM_DIGITOS_DECIMAL_8);
        sumatoriaFactor = Util.redondeoDouble (sumatoriaFactor + factor, Util.NUM_DIGITOS_DECIMAL_8);
        lista = addElementArrayCostoEfectivo (i, bnFecha, periodoAcumulado, factor, lista);
    }
    double [] amortiz = new double [1];
    amortiz [0] = sumatoriaFactor;
    Hashtable info = new Hashtable ();
    info.put ("lista", lista);
    info.put ("amortiz", amortiz);
    return info;
}


Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


-----Function Pair=37=-----==

public void mouseMoved (MouseEvent event) {
    boolean newthumbMoused = false;
    int canvasHeight = getHeight () - fontHeight - 1;
    int w = getWidth ();
    if (canvasHeight < totalLinesHeight) {
        int x = event.getX ();
        int y = event.getY ();
        if (x > getWidth () - scrollWidth && y < canvasHeight) {
            newthumbMoused = true;
        }
    }
    if (thumbMoused != newthumbMoused) {
        thumbMoused = newthumbMoused;
        outputDirty = true;
        repaint ();
    }
}


public NamedPolicyEvaluator [] deleteEvals (NamedPolicyEvaluator [] orig_npe, NamedPolicyEvaluator [] policy_evaluator_list) {
    boolean present;
    int k, curr_length = orig_npe.length;
    for (int i = 0; i < policy_evaluator_list.length; i ++) {
        present = false;
        for (int j = 0; j < curr_length; i ++) {
            if (orig_npe [j].evaluator_name.equals (policy_evaluator_list [i].evaluator_name)) {
                for (k = j; k < curr_length - 1; k ++) {
                    orig_npe [k] = orig_npe [k + 1];
                }
                curr_length --;
                present = true;
            }
        }
        if (! present) {
            return null;
        }
    }
    NamedPolicyEvaluator [] npe = new NamedPolicyEvaluator [curr_length];
    for (int i = 0; i < curr_length; i ++) {
        npe [i] = orig_npe [i];
    }
    return npe;
}


-----Function Pair=38=-----==

public DoublePlane xGradient () {
    DoublePlane plane = new DoublePlane (getSize ());
    double [] src = doubleArray ();
    double [] dst = plane.doubleArray ();
    int w = getWidth ();
    int h = getHeight ();
    for (int y = 0; y < h; y ++) {
        int row = y * w;
        int end = row + w - 1;
        for (int x = row; x < end; x ++) {
            dst [x] = src [x + 1] - src [x];
        }
    }
    return plane;
}


protected void drawClassBackground (Graphics g) {
    if (classColors != null) {
        if (logger.isLoggable (Level.FINEST)) {
            logger.finest ("classer is not null");
        }
        for (int i = 0; i < classColors.length; i ++) {
            for (int j = 0; j < classColors [0].length; j ++) {
                g.setColor (classColors [i] [j]);
                g.fillRect (xBoundariesInt [i], yBoundariesInt [j + 1], xBoundariesInt [i + 1] - xBoundariesInt [i], yBoundariesInt [j] - yBoundariesInt [j + 1]);
            }
        }
    }
    g.setColor (Color.white);
    for (int element : xBoundariesInt) {
        g.drawLine (element, plotOriginY, element, plotEndY);
    }
    for (int element : yBoundariesInt) {
        g.drawLine (plotOriginX, element, plotEndX, element);
    }
}


-----Function Pair=39=-----==

public static String sOrdem (int ord) {
    switch (ord) {
        case MUITO_ALTO :
            return "COMPRA FORTE";
        case ALTO :
            return "COMPRA";
        case NEUTRO :
            return "NEUTRO";
        case BAIXO :
            return "VENDA";
        case MUITO_BAIXO :
            return "VENDA FORTE";
        default :
            return "ERRO";
    }
}


private boolean ramschAuswertung () {
    boolean gewonnen = false;
    ISpieler [] spieler = new ISpieler [3];
    spieler [0] = spieler1;
    spieler [1] = spieler2;
    spieler [2] = spieler3;
    int bock = 1;
    if (this.bock) {
        bock = 2;
    }
    spieler = sortiereSpielerRamsch (spieler);
    ArrayList < Spielkarte > skat = new ArrayList < Spielkarte > ();
    skat.add (this.skat [0]);
    skat.add (this.skat [1]);
    if (sechserskat) {
        skat.add (this.skat [2]);
    }
    int skataugen = werteAugen (skat);
    spieler = entscheideRamsch (spieler, skataugen, bock);
    for (int i = 0; i < spieler.length; i ++) {
        if (spieler [i].getName () == spieler1.getName ()) {
            spieler1.setSpiele (spieler [i].getSpiele ());
        }
        if (spieler [i].getName () == spieler2.getName ()) {
            spieler2.setSpiele (spieler [i].getSpiele ());
        }
        if (spieler [i].getName () == spieler3.getName ()) {
            spieler3.setSpiele (spieler [i].getSpiele ());
        }
    }
    int l = gibMenschlicherSpieler ().getSpiele ().size ();
    if (gibMenschlicherSpieler ().getSpiele ().get (l - 1) >= 0) {
        gewonnen = true;
    }
    return gewonnen;
}


-----Function Pair=40=-----==

public void load (String [] line) {
    this.line = line;
    MOVIEID = CommonUtils.objectToInteger (line [0]);
    LN = line [1];
    LB = line [2];
    CN = line [3];
    LT = line [4];
    OT = line [5];
    PC = line [6];
    YR = CommonUtils.objectToInteger (line [7]);
    CF = line [8];
    CA = line [9];
    GR = line [10];
    LA = line [11];
    SU = line [12];
    LE = CommonUtils.objectToInteger (line [13]);
    RD = line [14];
    ST = line [15];
    PR = line [16];
    QP = line [17];
    CC = line [18];
    PF = line [19];
    DF = line [20];
    SI = CommonUtils.objectToInteger (line [21]);
    MF = line [22];
    AR = line [23];
    AL = line [24];
    DS = line [25];
    SE = line [26];
    CO = line [27];
    VS = line [28];
    RC = line [29];
}


void genMethod (JCMethodDecl tree, Env < GenContext > env, boolean fatcode) {
    MethodSymbol meth = tree.sym;
    if (Code.width (types.erasure (env.enclMethod.sym.type).getParameterTypes ()) + (((tree.mods.flags & STATIC) == 0 || meth.isConstructor ()) ? 1 : 0) > ClassFile.MAX_PARAMETERS) {
        log.error (tree.pos (), "limit.parameters");
        nerrs ++;
    }
    else if (tree.body != null) {
        int startpcCrt = initCode (tree, env, fatcode);
        try {
            genStat (tree.body, env);
        } catch (CodeSizeOverflow e) {
            startpcCrt = initCode (tree, env, fatcode);
            genStat (tree.body, env);
        }
        if (code.state.stacksize != 0) {
            log.error (tree.body.pos (), "stack.sim.error", tree);
            throw new AssertionError ();
        }
        if (code.isAlive ()) {
            code.statBegin (TreeInfo.endPos (tree.body));
            if (env.enclMethod == null || env.enclMethod.sym.type.getReturnType ().tag == VOID) {
                code.emitop0 (return_);
            }
            else {
                int startpc = code.entryPoint ();
                CondItem c = items.makeCondItem (goto_);
                code.resolve (c.jumpTrue (), startpc);
            }
        }
        if (genCrt) code.crt.put (tree.body, CRT_BLOCK, startpcCrt, code.curPc ());
        code.endScopes (0);
        if (code.checkLimits (tree.pos (), log)) {
            nerrs ++;
            return;
        }
        if (! fatcode && code.fatcode) genMethod (tree, env, true);
        if (stackMap == StackMapFormat.JSR202) {
            code.lastFrame = null;
            code.frameBeforeLast = null;
        }
    }
}


-----Function Pair=41=-----==

private AudioData load (InputStream in, boolean readStream, boolean streamCache) throws IOException {
    if (readStream && streamCache) {
        oggStream = new CachedOggStream (in);
    }
    else {
        oggStream = new UncachedOggStream (in);
    }
    Collection < LogicalOggStream > streams = oggStream.getLogicalStreams ();
    loStream = streams.iterator ().next ();
    vorbisStream = new VorbisStream (loStream);
    streamHdr = vorbisStream.getIdentificationHeader ();
    if (! readStream) {
        AudioBuffer audioBuffer = new AudioBuffer ();
        audioBuffer.setupFormat (streamHdr.getChannels (), 16, streamHdr.getSampleRate ());
        audioBuffer.updateData (readToBuffer ());
        return audioBuffer;
    }
    else {
        AudioStream audioStream = new AudioStream ();
        audioStream.setupFormat (streamHdr.getChannels (), 16, streamHdr.getSampleRate ());
        float streamDuration = computeStreamDuration ();
        audioStream.updateData (readToStream (oggStream.isSeekable (), streamDuration), streamDuration);
        return audioStream;
    }
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=42=-----==

private int binarySearch (Comparable key) {
    if (keys == null) return - 1;
    int high = nKeys - 1;
    int low = 0;
    int cur;
    int cmp;
    while (low <= high) {
        cur = (low + high)>>> 1;
        Comparable obj = keys [cur];
        if (obj != null) {
            cmp = obj.compareTo (key);
            if (cmp > 0) {
                high = cur - 1;
            }
            else if (cmp < 0) {
                low = cur + 1;
            }
            else {
                return cur;
            }
        }
        else {
            return cur;
        }
    }
    return (- 1 * (low + 1));
}


private void findNextPair () {
    besti = 0;
    bestj = 1;
    double dmin = getDist (0, 1);
    for (int i = 0; i < numClusters - 1; i ++) {
        for (int j = i + 1; j < numClusters; j ++) {
            if (getDist (i, j) < dmin) {
                dmin = getDist (i, j);
                besti = i;
                bestj = j;
            }
        }
    }
    abi = alias [besti];
    abj = alias [bestj];
}


-----Function Pair=43=-----==

void populateRFCOMMAttributes (long handle, int channel, UUID uuid, String name, boolean obex) {
    this.populateAttributeValue (BluetoothConsts.ServiceRecordHandle, new DataElement (DataElement.U_INT_4, handle));
    DataElement serviceClassIDList = new DataElement (DataElement.DATSEQ);
    serviceClassIDList.addElement (new DataElement (DataElement.UUID, uuid));
    if (! obex) {
        serviceClassIDList.addElement (new DataElement (DataElement.UUID, BluetoothConsts.SERIAL_PORT_UUID));
    }
    this.populateAttributeValue (BluetoothConsts.ServiceClassIDList, serviceClassIDList);
    DataElement protocolDescriptorList = new DataElement (DataElement.DATSEQ);
    DataElement L2CAPDescriptor = new DataElement (DataElement.DATSEQ);
    L2CAPDescriptor.addElement (new DataElement (DataElement.UUID, BluetoothConsts.L2CAP_PROTOCOL_UUID));
    protocolDescriptorList.addElement (L2CAPDescriptor);
    DataElement RFCOMMDescriptor = new DataElement (DataElement.DATSEQ);
    RFCOMMDescriptor.addElement (new DataElement (DataElement.UUID, BluetoothConsts.RFCOMM_PROTOCOL_UUID));
    RFCOMMDescriptor.addElement (new DataElement (DataElement.U_INT_1, channel));
    protocolDescriptorList.addElement (RFCOMMDescriptor);
    if (obex) {
        DataElement OBEXDescriptor = new DataElement (DataElement.DATSEQ);
        OBEXDescriptor.addElement (new DataElement (DataElement.UUID, BluetoothConsts.OBEX_PROTOCOL_UUID));
        protocolDescriptorList.addElement (OBEXDescriptor);
    }
    this.populateAttributeValue (BluetoothConsts.ProtocolDescriptorList, protocolDescriptorList);
    if (name != null) {
        this.populateAttributeValue (BluetoothConsts.AttributeIDServiceName, new DataElement (DataElement.STRING, name));
    }
}


public void put (int index, Scriptable start, Object value) {
    if (start == this && ! isSealed () && dense != null && 0 <= index && (denseOnly || ! isGetterOrSetter (null, index, true))) {
        if (index < dense.length) {
            dense [index] = value;
            if (this.length <= index) this.length = (long) index + 1;
            return;
        }
        else if (denseOnly && index < dense.length * GROW_FACTOR && ensureCapacity (index + 1)) {
            dense [index] = value;
            this.length = (long) index + 1;
            return;
        }
        else {
            denseOnly = false;
        }
    }
    super.put (index, start, value);
    if (start == this) {
        if (this.length <= index) {
            this.length = (long) index + 1;
        }
    }
}


-----Function Pair=44=-----==

protected void buildWSDLMetadataSectionElement (Collection < Element > coll) {
    if (serviceClass != null) {
        List < WSDLInfo > webServices = serviceClass.getWebServices ();
        for (Iterator < WSDLInfo > it = webServices.iterator (); it.hasNext ();) {
            WSDLInfo wsdlInfo = it.next ();
            if (! wsdlInfo.getLocations ().isEmpty ()) {
                for (int i = 0; i < wsdlInfo.getLocations ().size (); i ++) {
                    String strLocation = wsdlInfo.getLocations ().get (i);
                    if (strLocation.length () == 0) continue;
                    Element metaElt = new Element (MetadataConstants.METADATASECTION_LOCALNAME, MetadataConstants.METADATAEXCHANGE_PREFIX, MetadataConstants.METADATAEXCHANGE_NAMESPACE);
                    metaElt.setAttribute (MetadataConstants.DIALECT_ATTNAME, MetadataConstants.WSDL_DIALECT);
                    Element tmpElt = null;
                    tmpElt = new Element (MetadataConstants.LOCATION_LOCALNAME, MetadataConstants.METADATAEXCHANGE_PREFIX, MetadataConstants.METADATAEXCHANGE_NAMESPACE);
                    tmpElt.addContent (strLocation);
                    metaElt.addContent (tmpElt);
                    coll.add (metaElt);
                }
            }
        }
    }
}


Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


-----Function Pair=45=-----==

static int beautify (int uik, double [] knots, int [] knotMultiplicities) {
    double kval = knots [0] - 1.0;
    double p_tol = ConditionOfOperation.getCondition ().getToleranceForParameter ();
    int j = 0;
    for (int i = 0; i < uik; i ++) {
        if (Math.abs (kval - knots [i]) > p_tol) {
            kval = knots [j] = knots [i];
            knotMultiplicities [j] = knotMultiplicities [i];
            j ++;
        }
        else {
            knotMultiplicities [j - 1] += knotMultiplicities [i];
        }
    }
    return j;
}


String parseOptItem () {
    String opt;
    int b, j;
    b = ind = s.skipBlank (ss, ind, sslen);
    if (ind < sslen && ss.buf [ind] == '"') {
        ind ++;
        while (ind < sslen && ss.buf [ind] != '"') ind ++;
        opt = ss.substring (b + 1, ind);
        ind ++;
    }
    else {
        while (ind < sslen && ! Character.isWhitespace (ss.buf [ind])) ind ++;
        opt = ss.substring (b, ind);
    }
    while ((j = opt.indexOf ("${dq}")) != - 1) {
        opt = opt.substring (0, j) + "\"" + opt.substring (j + 5);
    }
    return (opt);
}


-----Function Pair=46=-----==

public void handleEvent (Event e) {
    try {
        if (listEps == null || listEps.isDisposed ()) return;
        TableItem [] items = listEps.getSelection ();
        if (items.length == 1) {
            TableItem item = items [0];
            String nameToDie = item.getText (0);
            String episode = item.getText (1);
            item.dispose ();
            deleteFromList (nameToDie, episode);
        }
    } catch (Exception e1) {
        e1.printStackTrace ();
    }
}


protected void addNode (GraphNodeModel node, int layer) {
    if (node.getName () == null) node.setName (getNextNodeName ());
    addGraphicObject (node, layer);
    GraphPortModel ports [] = node.getPorts ();
    for (int i = 0; i < ports.length; i ++) addPort (ports [i]);
    GraphNodeModelListener listener = new DefaultGraphNodeModelListener () {
        public void portsRemoved (GraphEvent event) {
            Object ports [] = event.getObjects ();
            for (int i = 0; i < ports.length; i ++) {
                GraphPortModel port = (GraphPortModel) ports [i];
                removePort (port);
                repaint (port.getBBox ());
            }
        } public void portsInserted (GraphEvent event) {
            Object ports [] = event.getObjects ();
            for (int i = 0; i < ports.length; i ++) {
                GraphPortModel port = (GraphPortModel) ports [i];
                addPort (port);
                repaint (port.getBBox ());
            }
        }
    }
    ;
    node.addGraphNodeModelListener (listener);
    nodeListeners.put (node, listener);
}


-----Function Pair=47=-----==

public static void openConsole () {
    switch (consoleState) {
        case HIDDEN :
            consoleState = State.SHOWN;
            setTextArea ();
            timepassed = timeout;
            vertices [7] = area.getActualHeight () + 5.0f;
            vertices [10] = area.getActualHeight () + 5.0f;
            setVertexBuffer ();
            break;
        case SHOWN :
            consoleState = State.OPEN;
            setTextArea ();
            timepassed = timeout;
            vertices [7] = area.getActualHeight () + 5.0f;
            vertices [10] = area.getActualHeight () + 5.0f;
            setVertexBuffer ();
            break;
        case OPEN :
            timepassed = timeout;
            break;
    }
}


public void constructNetwork () {
    double layerError, firstLayerErr;
    iLayer = new InputLayer ();
    double sqerr;
    int i = 0;
    layerErr.reset ();
    myRandom.generateLearningAndTestingSet ((int) (group * (c.getVectorsInTestingSet () / 100.0)));
    maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
    actualLayer = i;
    layerError = firstLayerErr = Double.MAX_VALUE;
    GraphCanvas.getInstance ().setLayerConstruction (true);
    if (c.isJustTwo ()) {
        layer [i] = new Layer (i, iLayer, 2);
    }
    else {
        layer [i] = new Layer (i, iLayer, i + 2);
    }
    while ((sqerr = layer [i].teachLayer (iLayer)) < layerError) {
        if (i == 0) {
            firstLayerErr = sqerr;
        }
        if (i > 1) {
            if (((layerError - sqerr) * 30.0) < (firstLayerErr - layerError)) {
                if (! c.isBuildWhileDec ()) {
                    actualLayer = ++ i;
                    layerError = sqerr;
                    layerErr.add (sqerr);
                    break;
                }
            }
        }
        actualLayer = ++ i;
        layerError = sqerr;
        layerErr.add (sqerr);
        if (i > NetworkConfiguration.MAX_LAYERS - 2) {
            break;
        }
        maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
        if (c.isJustTwo ()) {
            layer [i] = new Layer (i, layer [i - 1], 2);
        }
        else {
            layer [i] = new Layer (i, layer [i - 1], i + 2);
        }
    }
    layerErr.add (sqerr);
    lastLayer = i - 1;
    ivector = oattr = null;
    crit = null;
    GraphCanvas.getInstance ().setLayerConstruction (false);
}


-----Function Pair=48=-----==

public static void linearPrediction (float [] data, int dataOff, int dataLen, float [] coeffBuf, int coeffNum, float [] future, int futOff, int futLen) {
    int i, j, k;
    float sum;
    float [] reg = new float [coeffNum];
    for (j = 0, k = dataOff + dataLen; j < coeffNum;) {
        reg [j ++] = data [-- k];
    }
    for (j = futOff, i = futOff + futLen; j < i; j ++) {
        sum = 0.0f;
        for (k = 0; k < coeffNum; k ++) {
            sum += coeffBuf [k] * reg [k];
        }
        System.arraycopy (reg, 0, reg, 1, coeffNum - 1);
        reg [0] = sum;
        future [j] = sum;
    }
}


void addNewProjectOptions (String projectName, String changeDirectories, String classPath, String sourcePath) {
    add (new Option (optInputFile, changeDirectories));
    add (new Option (optPruneDirs, "CVS" + s.classPathSeparator + "backup"));
    add (new Option (optXrefsFile, s.tagFilesDirectory + projectName));
    add (new Option (optXrefNum, "" + 10));
    add (new Option (optClassPath, classPath));
    add (new Option (optSourcePath, sourcePath));
    add (new Option (optJavaVersion, "1.3"));
    add (new Option (optCSuffixes, "c" + s.classPathSeparator + "C"));
    add (new Option (optJavaSuffixes, "java"));
    add (new Option (optJdkClassPath, s.jdkClassPath));
    String jdkhome = new File (s.javaHome).getParent ();
    if (jdkhome != null) {
        add (new Option (optJavaDocPath, jdkhome + "/docs/api"));
    }
}


-----Function Pair=49=-----==

public static float PID (Sequence s1, Sequence s2) {
    int res = 0;
    int len;
    if (s1.getSequence ().length () > s2.getSequence ().length ()) {
        len = s1.getSequence ().length ();
    }
    else {
        len = s2.getSequence ().length ();
    }
    int bad = 0;
    for (int i = 0; i < len; i ++) {
        String str1 = "";
        String str2 = "";
        if (i < s1.getSequence ().length ()) {
            str1 = s1.getSequence ().substring (i, i + 1);
        }
        else {
            str1 = ".";
        }
        if (i < s2.getSequence ().length ()) {
            str2 = s2.getSequence ().substring (i, i + 1);
        }
        else {
            str2 = ".";
        }
        if (! (str1.equals (".") || str1.equals ("-") || str1.equals (" ")) && ! (str2.equals (".") || str2.equals ("-") || str2.equals (" "))) {
            if (! str1.equals (str2)) {
                bad ++;
            }
        }
    }
    return (float) 100 * (len - bad) / len;
}


public void constructNetwork () {
    double layerError, firstLayerErr;
    iLayer = new InputLayer ();
    double sqerr;
    int i = 0;
    layerErr.reset ();
    myRandom.generateLearningAndTestingSet ((int) (group * (c.getVectorsInTestingSet () / 100.0)));
    maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
    actualLayer = i;
    layerError = firstLayerErr = Double.MAX_VALUE;
    GraphCanvas.getInstance ().setLayerConstruction (true);
    if (c.isJustTwo ()) {
        layer [i] = new Layer (i, iLayer, 2);
    }
    else {
        layer [i] = new Layer (i, iLayer, i + 2);
    }
    while ((sqerr = layer [i].teachLayer (iLayer)) < layerError) {
        if (i == 0) {
            firstLayerErr = sqerr;
        }
        if (i > 1) {
            if (((layerError - sqerr) * 30.0) < (firstLayerErr - layerError)) {
                if (! c.isBuildWhileDec ()) {
                    actualLayer = ++ i;
                    layerError = sqerr;
                    layerErr.add (sqerr);
                    break;
                }
            }
        }
        actualLayer = ++ i;
        layerError = sqerr;
        layerErr.add (sqerr);
        if (i > NetworkConfiguration.MAX_LAYERS - 2) {
            break;
        }
        maxNeuronsInLayer = c.getLayerInitialNeuronsNumber (i);
        if (c.isJustTwo ()) {
            layer [i] = new Layer (i, layer [i - 1], 2);
        }
        else {
            layer [i] = new Layer (i, layer [i - 1], i + 2);
        }
    }
    layerErr.add (sqerr);
    lastLayer = i - 1;
    ivector = oattr = null;
    crit = null;
    GraphCanvas.getInstance ().setLayerConstruction (false);
}


-----Function Pair=50=-----==

protected void output (PrintWriter writer, int indent, int index) {
    StringBuffer buf = new StringBuffer ();
    for (int i = 0; i < indent; i ++) {
        buf.append ("\t");
    }
    String indent_tab = new String (buf);
    writer.println (indent_tab + keyWords [index] [0] + degree);
    writer.println (indent_tab + keyWords [index] [1] + nControlPoints);
    writer.println (indent_tab + keyWords [index] [2] + knotSpec);
    if (knotSpec == KnotType.UNSPECIFIED) {
        writer.print (indent_tab + keyWords [index] [3]);
        int i = 0;
        while (true) {
            writer.print (knotMultiplicities [i ++]);
            for (int j = 0; j < 20 && i < knotMultiplicities.length; j ++, i ++) {
                writer.print (" " + knotMultiplicities [i]);
            }
            writer.println ();
            if (i < knotMultiplicities.length) {
                writer.print (indent_tab + "\t\t");
            }
            else {
                break;
            }
        }
        writer.print (indent_tab + keyWords [index] [4]);
        i = 0;
        while (true) {
            writer.print (knots [i ++]);
            for (int j = 0; j < 3 && i < knots.length; j ++, i ++) {
                writer.print (" " + knots [i]);
            }
            writer.println ();
            if (i < knots.length) {
                writer.print (indent_tab + "\t\t");
            }
            else {
                break;
            }
        }
    }
    writer.println (indent_tab + keyWords [index] [5] + periodic);
}


private static final void dHeapSort (double key [], double trail []) {
    int nkey = key.length;
    int last_parent_pos = (nkey - 2) / 2;
    int last_parent_index = last_parent_pos;
    double tkey, ttrail;
    if (nkey <= 1) return;
    for (int i = last_parent_index; i >= 0; i --) dremake_heap (key, trail, i, nkey - 1);
    tkey = key [0];
    key [0] = key [nkey - 1];
    key [nkey - 1] = tkey;
    ttrail = trail [0];
    trail [0] = trail [nkey - 1];
    trail [nkey - 1] = ttrail;
    for (int i = nkey - 2; i > 0; i --) {
        dremake_heap (key, trail, 0, i);
        tkey = key [0];
        key [0] = key [i];
        key [i] = tkey;
        ttrail = trail [0];
        trail [0] = trail [i];
        trail [i] = ttrail;
    }
}


-----Function Pair=51=-----==

public static int decomposeConvex (Polygon p, Polygon [] results, int maxPolys) {
    if (p.nVertices < 3) return 0;
    Triangle [] triangulated = new Triangle [p.nVertices - 2];
    for (int i = 0; i < triangulated.length; ++ i) {
        triangulated [i] = new Triangle ();
    }
    int nTri;
    if (p.isCCW ()) {
        Polygon tempP = new Polygon ();
        tempP.set (p);
        reversePolygon (tempP.x, tempP.y, tempP.nVertices);
        nTri = triangulatePolygon (tempP.x, tempP.y, tempP.nVertices, triangulated);
    }
    else {
        nTri = triangulatePolygon (p.x, p.y, p.nVertices, triangulated);
    }
    if (nTri < 1) {
        return - 1;
    }
    int nPolys = polygonizeTriangles (triangulated, nTri, results, maxPolys);
    return nPolys;
}


public static byte [] encryptionDES (byte [] source, byte [] keyByte) throws DESCryptionException {
    if (source.length % 8 != 0) throw new DESCryptionException ("source length is not multiple of 8 bytes");
    if (keyByte.length != 8) throw new DESCryptionException ("key length is not 8 bytes");
    int [] temp = new int [64];
    int [] data = TypeConversion.byte2hexInt (source);
    data = changeIP (data);
    int [] [] left = new int [17] [32];
    int [] [] right = new int [17] [32];
    for (int j = 0; j < 32; j ++) {
        left [0] [j] = data [j];
        right [0] [j] = data [j + 32];
    }
    int [] key = TypeConversion.byte2hexInt (keyByte);
    int [] [] subKey = setKey (key);
    for (int i = 1; i < 17; i ++) {
        key = subKey [i - 1];
        left [i] = right [i - 1];
        int [] fTemp = f (right [i - 1], key);
        right [i] = diffOr (left [i - 1], fTemp);
    }
    for (int i = 0; i < 32; i ++) {
        temp [i] = right [16] [i];
        temp [32 + i] = left [16] [i];
    }
    temp = changeInverseIP (temp);
    return TypeConversion.hexInt2byte (temp);
}


-----Function Pair=52=-----==

void process (byte c) {
    if (c > 27) normal (c);
    else switch (c) {
        case 0 :
            break;
        case 7 :
            break;
        case 8 :
            xloc --;
            if (xloc < 0) {
                yloc --;
                xloc = columns - 1;
                if (yloc < 0) yloc = 0;
            }
            break;
        case 9 :
            int n = (8 - xloc % 8);
            for (int j = 0; j < n; j ++) normal ((byte) 32);
            break;
        case 10 :
            yloc ++;
            xloc = 0;
            scrValid ();
            lineRedraw [yloc] = true;
            break;
        case 11 :
            break;
        case 12 :
            break;
        case 13 :
            break;
        default :
            normal (c);
    }
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=53=-----==

private void generateJnlpFile (File jnlpFile) throws IOException {
    PrintWriter out = new PrintWriter (new BufferedWriter (new OutputStreamWriter (new FileOutputStream (jnlpFile), "UTF-8")));
    out.println ("<?xml version=\"1.0\" encoding=\"utf-8\"?>");
    out.println ("<jnlp spec=\"1.0\"");
    out.println ("      codebase=\"" + jarCodebase_ + "\"");
    out.println ("      href=\"" + instClassName_ + ".jnlp\">");
    out.println ("  <information>");
    if (appVersion_ != null) out.println ("    <title>" + appName_ + " " + appVersion_ + " Installer</title>");
    else out.println ("    <title>" + appName_ + " " + " Installer</title>");
    out.println ("    <vendor>" + jarVendor_ + "</vendor>");
    out.println ("    <homepage href=\"" + jarHomepage_ + "\"/>");
    if (appVersion_ != null) out.println ("    <description>Installer for " + appName_ + " " + appVersion_ + "</description>");
    else out.println ("    <description>Installer for " + appName_ + "</description>");
    out.println ("    <offline/>");
    out.println ("  </information>");
    out.println ("  <resources>");
    out.println ("    <j2se version=\"1.3 1.2\"/>");
    out.println ("    <jar href=\"" + instClassName_ + ".jar\"/>");
    out.println ("    <property name=\"DEBUG\" value=\"yes\"/>");
    out.println ("  </resources>");
    out.println ("  <security>");
    out.println ("    <all-permissions/>");
    out.println ("  </security>");
    out.println ("  <application-desc main-class=\"" + instClassName_ + "\"/>");
    out.println ("</jnlp>");
    out.close ();
}


public String [] bufferSorting (String buffer [], String str) {
    ExecutionTimer t = new ExecutionTimer ();
    t.start ();
    String [] splitStr = buffer [0].split ("\t");
    split = new String [splitStr.length];
    strValue = new String [buffer.length - 1];
    intValue = new int [buffer.length - 1];
    split = buffer [0].split ("\t");
    for (int i = 0; i < split.length; i ++) {
        if (split [i].toLowerCase ().equals (str.toLowerCase ())) {
            index = i;
        }
    }
    for (int i = 1; i < buffer.length; i ++) {
        split = buffer [i].split ("\t");
        strValue [i - 1] = split [index];
    }
    for (int i = 0; i < buffer.length - 1; i ++) {
        {
        }
        {
            strValue [i] = strValue [i];
        }
    }
    if (intValue [0] != 0) {
        sortIds (intValue);
        String intStr [] = new String [intValue.length];
        for (int j = 0; j < buffer.length - 1; j ++) {
            Integer i = new Integer (intValue [j]);
            intStr [j] = i.toString ();
        }
        t.end ();
        TimerRecordFile timerFile = new TimerRecordFile ("sort", "BufferSorting", "bufferSorting", t.duration ());
        return intStr;
    }
    else {
        sortStrings (strValue, strValue.length);
        t.end ();
        TimerRecordFile timerFile = new TimerRecordFile ("sort", "BufferSorting", "bufferSorting", t.duration ());
        return strValue;
    }
}


-----Function Pair=54=-----==

public void collectInternalCommand () {
    Database localDb = this.getFatherPanel ().getLocalDb ();
    try {
        String query = "SELECT ID_SH2, IMAGE_NAME_SH2, ID_SH1, IMAGE_NAME_SH1, LINE_NUMBER, LINK_ACTION " + "FROM LINK_SHAPES " + "WHERE ID_SH1=" + getElemId () + " AND IMAGE_NAME_SH1='" + getImgName () + "' AND " + "IMAGE_NAME_SH1=IMAGE_NAME_SH2 ORDER BY LINE_NUMBER";
        Statement sp = localDb.createStatement ();
        ResultSet rp = sp.executeQuery (query);
        Text command = Text.EMPTY;
        while (rp.next ()) {
            command = Text.valueOf (rp.getString ("LINK_ACTION"));
            Text token [] = ParserUtils.split (command, " ");
            if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ASSIGNVALUETO"))) {
                variablesHashTable.put (token [1], new Integer (rp.getInt ("ID_SH2")));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ASSIGNVALUE"))) {
                this.setAssignExpression (token [1]);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("FASTASSIGN"))) {
                this.setFastAssignExpression (token [1]);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ABSDIFF"))) {
                Text [] expr = new Text [token.length - 1];
                System.arraycopy (token, 1, expr, 0, expr.length);
                setAbsDiffExpression (expr);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ASSIGNCOLORTO"))) {
                colorVariablesHashTable.put (token [1], new Integer (rp.getInt ("ID_SH2")));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("CHANGEFONTCOLORIF"))) {
                for (int i = 1; i < token.length - 2; i ++) {
                    setFontColorExpression (0, getFontColorExpression () [0].concat (BLANK).concat (token [i]));
                }
                setFontColorExpression (1, getFontColorExpression () [1].concat (BLANK).concat (token [token.length - 2]));
                setFontColorExpression (2, getFontColorExpression () [2].concat (BLANK).concat (token [token.length - 1]));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("CHANGECOLORSIF"))) {
                for (int i = 1; i < token.length - 2; i ++) {
                    setColorExpression (0, getColorExpression () [0].concat (BLANK).concat (token [i]));
                }
                setColorExpression (1, getColorExpression () [1].concat (BLANK).concat (token [token.length - 2]));
                setColorExpression (2, getColorExpression () [2].concat (BLANK).concat (token [token.length - 1]));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ORCHECKCOLORS"))) {
                Text [] colExpr = new Text [token.length];
                colExpr [0] = OR;
                int j = 1;
                for (int i = 0; i < token.length - 1; i ++) {
                    if (! token [i + 1].contentEquals (Text.EMPTY)) {
                        colExpr [j] = token [i + 1];
                        j ++;
                    }
                }
                Text [] res = new Text [j];
                setFastCheckColorExpression (res);
                System.arraycopy (colExpr, 0, res, 0, res.length);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ANDCHECKCOLORS"))) {
                Text [] colExpr = new Text [token.length];
                colExpr [0] = AND;
                int j = 1;
                for (int i = 0; i < token.length - 1; i ++) {
                    if (! token [i + 1].contentEquals (Text.EMPTY)) {
                        colExpr [j] = token [i + 1];
                        j ++;
                    }
                }
                Text [] res = new Text [j];
                setFastCheckColorExpression (res);
                System.arraycopy (colExpr, 0, res, 0, res.length);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ORCHECKFONTCOLORS"))) {
                Text [] colExpr = new Text [token.length];
                colExpr [0] = OR;
                int j = 1;
                for (int i = 0; i < token.length - 1; i ++) {
                    if (! token [i + 1].contentEquals (Text.EMPTY)) {
                        colExpr [j] = token [i + 1];
                        j ++;
                    }
                }
                Text [] res = new Text [j];
                setFastCheckFontColorExpression (res);
                System.arraycopy (colExpr, 0, res, 0, res.length);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("ANDCHECKFONTCOLORS"))) {
                Text [] colExpr = new Text [token.length];
                colExpr [0] = AND;
                int j = 1;
                for (int i = 0; i < token.length - 1; i ++) {
                    if (! token [i + 1].contentEquals (Text.EMPTY)) {
                        colExpr [j] = token [i + 1];
                        j ++;
                    }
                }
                Text [] res = new Text [j];
                setFastCheckFontColorExpression (res);
                System.arraycopy (colExpr, 0, res, 0, res.length);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("VISIBLEIF"))) {
                Text visExpr = Text.EMPTY;
                for (int i = 1; i < token.length; i ++) {
                    visExpr = visExpr.concat (token [i]);
                }
                setVisualizationExpression (visExpr);
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("CHANGEBORDERCOLORIF"))) {
                for (int i = 1; i < token.length - 2; i ++) {
                    setBorderColorExpression (0, getBorderColorExpression () [0].concat (BLANK).concat (token [i]));
                }
                setBorderColorExpression (1, getBorderColorExpression () [1].concat (BLANK).concat (token [token.length - 2]));
                setBorderColorExpression (2, getBorderColorExpression () [2].concat (BLANK).concat (token [token.length - 1]));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("CHANGEFILLCOLORIF"))) {
                for (int i = 1; i < token.length - 2; i ++) {
                    setFillColorExpression (0, getFillColorExpression () [0].concat (BLANK).concat (token [i]));
                }
                setFillColorExpression (1, getFillColorExpression () [1].concat (BLANK).concat (token [token.length - 2]));
                setFillColorExpression (2, getFillColorExpression () [2].concat (BLANK).concat (token [token.length - 1]));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("CHANGEVALUEIF"))) {
                for (int i = 1; i < token.length - 2; i ++) {
                    setChangeValueExpression (0, getFillColorExpression () [0].concat (BLANK).concat (token [i]));
                }
                setChangeValueExpression (1, getFillColorExpression () [1].concat (BLANK).concat (token [token.length - 2]));
                setChangeValueExpression (2, getFillColorExpression () [2].concat (BLANK).concat (token [token.length - 1]));
            }
            else if (token [0].toUpperCase ().contentEquals (Text.valueOf ("EXECUTE"))) {
                enableThreadCreation = true;
                String path = command.toString ().substring (token [0].length () + 1, command.length ());
                if (path.startsWith ("%CURDIR/")) {
                    path = getFatherPanel ().getCurDir () + "/" + path.replaceAll ("%CURDIR/", "");
                }
                else if (path.startsWith ("%CURDIR\\")) {
                    path = getFatherPanel ().getCurDir () + path.replaceAll ("%CURDIR", "");
                }
                path = path.replaceAll ("//", "\\");
                byte buff [] = new byte [2048];
                try {
                    InputStream fileIn = new FileInputStream (path);
                    int i = fileIn.read (buff);
                    associatedScript = new String (buff);
                } catch (FileNotFoundException e) {
                    e.printStackTrace ();
                } catch (IOException e) {
                    e.printStackTrace ();
                }
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


private static final void dremake_heap (double key [], double trail [], int parent_index, int last_index) {
    int last_parent_pos = (last_index - 1) / 2;
    int last_parent_index = last_parent_pos;
    int l_child, r_child, max_child_index;
    int parent_temp = parent_index;
    double tkey, ttrail;
    while (parent_temp <= last_parent_index) {
        l_child = parent_temp * 2 + 1;
        if (l_child == last_index) max_child_index = l_child;
        else {
            r_child = l_child + 1;
            max_child_index = key [l_child] > key [r_child] ? l_child : r_child;
        }
        if (key [max_child_index] > key [parent_temp]) {
            tkey = key [max_child_index];
            key [max_child_index] = key [parent_temp];
            key [parent_temp] = tkey;
            ttrail = trail [max_child_index];
            trail [max_child_index] = trail [parent_temp];
            trail [parent_temp] = ttrail;
            parent_temp = max_child_index;
        }
        else break;
    }
}


-----Function Pair=55=-----==

void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


public static Object financialReceived (Object [] args, XelContext ctx) {
    double investment = CommonFns.toNumber (args [2]).doubleValue ();
    double discount = CommonFns.toNumber (args [3]).doubleValue ();
    if (investment <= 0 || discount <= 0) {
        throw new SSErrorXelException (SSError.NUM);
    }
    else {
        Date settle = UtilFns.stringToDate (args [0].toString ());
        Date maturi = UtilFns.stringToDate (args [1].toString ());
        int basis = 0;
        if (args.length == 5) {
            basis = basis (CommonFns.toNumber (args [4]).intValue ());
        }
        int dim = UtilFns.dsm (settle, maturi, basis);
        double B = UtilFns.basisToDouble (basis, settle, maturi, dim);
        double received = investment / (1 - (discount * (dim / B)));
        return new Double (received);
    }
}


-----Function Pair=56=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


protected double [] [] getBeta (int [] ob) {
    int l = ob.length;
    int stateCount = stProb.length;
    double [] tmp = new double [stateCount];
    double [] [] beta = new double [l] [stateCount];
    for (int i = 0; i < stateCount; i ++) {
        beta [l - 1] [i] = 0;
    }
    for (int t = l - 2; t >= 0; t --) {
        for (int i = 0; i < stateCount; i ++) {
            for (int j = 0; j < stateCount; j ++) {
                tmp [j] = transProb [i] [j] + obProb [j] [ob [t + 1]] + beta [t + 1] [j];
            }
            beta [t] [i] = logSumExp (tmp, 0, tmp.length);
        }
    }
    return beta;
}


-----Function Pair=57=-----==

String parseOptItem () {
    String opt;
    int b, j;
    b = ind = s.skipBlank (ss, ind, sslen);
    if (ind < sslen && ss.buf [ind] == '"') {
        ind ++;
        while (ind < sslen && ss.buf [ind] != '"') ind ++;
        opt = ss.substring (b + 1, ind);
        ind ++;
    }
    else {
        while (ind < sslen && ! Character.isWhitespace (ss.buf [ind])) ind ++;
        opt = ss.substring (b, ind);
    }
    while ((j = opt.indexOf ("${dq}")) != - 1) {
        opt = opt.substring (0, j) + "\"" + opt.substring (j + 5);
    }
    return (opt);
}


public Double2M min2 (Spolecne.D3 F, double x, double y, double uhel, double krok, double phodn, double mez) {
    double hodn, t;
    for (int k = 1; k <= 6; k ++) {
        do {
            if (Math.abs (mez - uhel) < krok) {
                uhel = mez;
                break;
            }
            hodn = F.f (x, y, uhel);
            t = phodn;
            if (hodn < phodn) {
                phodn = hodn;
                uhel = uhel + krok;
            }
        }
        while (hodn <= t);
        phodn = F.f (x, y, uhel);
        krok = - krok / 10;
        uhel = uhel + krok;
    }
    return new Double2M (phodn, uhel - krok);
}


-----Function Pair=58=-----==

public void cardPut (long moveToken) throws MauMauTableException {
    guardToken (moveToken);
    LOGGER.info (getName () + ".cardPut(" + moveToken + ") - bound to " + getMovingPlayer () + " (" + getMovingPlayer ().usedToken (moveToken) + ')');
    move.setSealed ();
    if (move.acceptedCard ()) {
        LOGGER.info (getName () + ".cardPut(" + moveToken + ") - accepted " + move.cardPutDown + " on move #" + move.getMoveNumber ());
        notifyAll (new CardPutDown (moveControl.getMovingPlayer ().getName (), move.cardPutDown));
        if (move.indicatedFinish != null) notifyAll (move.indicatedFinish);
        if ((move.required != null) && move.required.getAnnouncersName ().equalsIgnoreCase (getMovingPlayer ().getName ())) notifyAll (move.required);
        if (getRuleRequireMau () && moveControl.getMovingPlayer ().hasJustOneMoreCard () && ! move.announcedMau ()) {
            sendCardsFromTalonToMovingPlayer (MAU_MAU_PENALTY_CARDS_COUNT_FOR_MISSED_MAU);
            notifyAll (new PenaltyCardsSent (moveControl.getMovingPlayer ().getName (), MAU_MAU_PENALTY_CARDS_COUNT_FOR_MISSED_MAU, "\"Mau!\" not announced"));
        }
        if (moveControl.getMovingPlayer ().hasNoMoreCard () && ! move.announcedMauMau ()) {
            sendCardsFromTalonToMovingPlayer (MAU_MAU_PENALTY_CARDS_COUNT_FOR_MISSED_MAUMAU);
            notifyAll (new PenaltyCardsSent (moveControl.getMovingPlayer ().getName (), MAU_MAU_PENALTY_CARDS_COUNT_FOR_MISSED_MAUMAU, "\"Mau Mau!\" not announced"));
        }
        if (! move.cardAcceptedIsJack ()) move.dismissRequirement ();
    }
    else {
        LOGGER.info (getName () + ".cardPut(" + moveToken + ") - intermit accepted on move #" + move.getMoveNumber ());
        notifyAll (new CardIntermitted (moveControl.getMovingPlayer ().getName (), move.parent.cardPutDown));
        int penaltyCardsCount = MAU_MAU_PENALTY_CARDS_COUNT_FOR_INTERMITTING_NORMAL_SERVING;
        MauMauTableMessage m = new PenaltyCardsSent (moveControl.getMovingPlayer ().getName (), penaltyCardsCount, "Intermitting " + move.parent.cardPutDown);
        if (move.getPenalty () > 0) {
            penaltyCardsCount = move.getPenalty ();
            m = new PenaltyCardsSent (moveControl.getMovingPlayer ().getName (), penaltyCardsCount, "Intermitting " + move.parent.cardPutDown);
        }
        else if (move.parent.skips && ! getRuleSkippingEightPenalizesIntermittingPlayer ()) penaltyCardsCount = 0;
        move.cardPutDown = move.parent.cardPutDown;
        move.dismissSkipping ();
        move.dismissPenalty ();
        if (penaltyCardsCount > 0) {
            sendCardsFromTalonToMovingPlayer (penaltyCardsCount);
            notifyAll (m);
        }
    }
}


private void addToConsensus () {
    int totNrPeaks = consensus.getSpectrum ().getMzs ().length;
    ArrayList < Integer > ids = new ArrayList < Integer > ();
    for (JPLExpPeakList spectrum : cluster) {
        totNrPeaks += spectrum.getNbPeak ();
        ids.add ((int) spectrum.getId ());
    }
    double [] masses = new double [totNrPeaks];
    double [] intensities = new double [totNrPeaks];
    int [] nrOfOccurences = new int [totNrPeaks];
    int pos = 0;
    double [] mz = consensus.getSpectrum ().getMzs ();
    double [] h = consensus.getSpectrum ().getIntensities ();
    System.arraycopy (mz, 0, masses, pos, mz.length);
    System.arraycopy (h, 0, intensities, pos, h.length);
    System.arraycopy (consensus.getNrOfOccurences (), 0, nrOfOccurences, pos, mz.length);
    pos += consensus.getSpectrum ().getNbPeak ();
    for (JPLExpPeakList spectrum : cluster) {
        mz = spectrum.getMzs ();
        h = spectrum.getIntensities ();
        System.arraycopy (mz, 0, masses, pos, mz.length);
        System.arraycopy (h, 0, intensities, pos, h.length);
        for (int i = pos; i < pos + mz.length; i ++) nrOfOccurences [i] = 1;
        pos += spectrum.getNbPeak ();
    }
    int [] idx = SimpleTypeArray.sortIndexesUp (masses);
    masses = SimpleTypeArray.mapping (masses, idx);
    intensities = SimpleTypeArray.mapping (intensities, idx);
    nrOfOccurences = SimpleTypeArray.mapping (nrOfOccurences, idx);
    JPLPeakGrouper grouper = new JPLPeakGrouper ();
    grouper.setMzMaxDiff (mzAlignError);
    grouper.setNrOfOccurences (nrOfOccurences);
    JPLExpPeakList sp = cluster.get (0);
    if (sp instanceof JPLFragmentationSpectrum) {
        JPLFragmentationSpectrum expPeakList = new JPLFragmentationSpectrum (masses, intensities);
        expPeakList = (JPLFragmentationSpectrum) grouper.process (expPeakList);
        double parentMz = 0.0;
        double parentH = 0.0;
        int cnt = cluster.size ();
        for (JPLExpPeakList entry : cluster) {
            JPLFragmentationSpectrum spectrum = (JPLFragmentationSpectrum) entry;
            parentMz += spectrum.getPrecursor ().getMz ();
            parentH += spectrum.getPrecursor ().getMz ();
        }
        JPLExpMSPeakLC precursor = new JPLExpMSPeakLC (parentMz / cnt, parentH / cnt);
        expPeakList.setPrecursor (precursor);
        consensus = new JPLConsensusSpectrum (expPeakList, grouper.getNrOfOccurences (), ids);
    }
    else if (sp instanceof JPLExpPeakList) {
        JPLExpPeakList expPeakList = new JPLExpPeakList (masses, intensities);
        expPeakList = (JPLExpPeakList) grouper.process (expPeakList);
        consensus = new JPLConsensusSpectrum (expPeakList, grouper.getNrOfOccurences (), ids);
    }
}


-----Function Pair=59=-----==

public boolean lessThan (final Dfp x) {
    if (field.getRadixDigits () != x.field.getRadixDigits ()) {
        field.setIEEEFlagsBits (DfpField.FLAG_INVALID);
        final Dfp result = newInstance (getZero ());
        result.nans = QNAN;
        dotrap (DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, result);
        return false;
    }
    if (isNaN () || x.isNaN ()) {
        field.setIEEEFlagsBits (DfpField.FLAG_INVALID);
        dotrap (DfpField.FLAG_INVALID, LESS_THAN_TRAP, x, newInstance (getZero ()));
        return false;
    }
    return compare (this, x) < 0;
}


int AddDrive (int _drive, String physicalPath, ShortRef subUnit) {
    subUnit.value = 0;
    if (GetNumDrives () + 1 >= MSCDEX_MAX_DRIVES) return 4;
    if (GetNumDrives () != 0) {
        if (dinfo [0].drive - 1 != _drive && dinfo [numDrives - 1].drive + 1 != _drive) return 1;
    }
    int result = 0;
    switch (Dos_cdrom.CDROM_GetMountType (physicalPath, forceCD)) {
        case 0x00 :
            {
                if (Log.level <= LogSeverities.LOG_ERROR) Log.log (LogTypes.LOG_MISC, LogSeverities.LOG_ERROR, "MSCDEX: Mounting physical cdrom not supported: " + physicalPath);
            }
            break;
        case 0x01 :
            if (Log.level <= LogSeverities.LOG_NORMAL) Log.log (LogTypes.LOG_MISC, LogSeverities.LOG_NORMAL, "MSCDEX: Mounting iso file as cdrom: " + physicalPath);
            cdrom [numDrives] = new CDROM_Interface_Image ((short) numDrives);
            break;
        case 0x02 :
            cdrom [numDrives] = new CDROM_Interface_Fake ();
            if (Log.level <= LogSeverities.LOG_NORMAL) Log.log (LogTypes.LOG_MISC, LogSeverities.LOG_NORMAL, "MSCDEX: Mounting directory as cdrom: " + physicalPath);
            if (Log.level <= LogSeverities.LOG_NORMAL) Log.log (LogTypes.LOG_MISC, LogSeverities.LOG_NORMAL, "MSCDEX: You wont have full MSCDEX support !");
            result = 5;
            break;
        default :
            return 6;
    }
    if (! cdrom [numDrives].SetDevice (physicalPath, forceCD)) {
        return 3;
    }
    if (rootDriverHeaderSeg == 0) {
        int driverSize = DOS_DeviceHeader.size + 10;
        int seg = Dos_tables.DOS_GetMemory ((driverSize + 15) / 16);
        DOS_DeviceHeader devHeader = new DOS_DeviceHeader (Memory.PhysMake (seg, 0));
        devHeader.SetNextDeviceHeader (0xFFFFFFFF);
        devHeader.SetAttribute (0xc800);
        devHeader.SetDriveLetter (_drive + 1);
        devHeader.SetNumSubUnits ((short) 1);
        devHeader.SetName ("MSCD001 ");
        long start = Dos.dos_infoblock.GetDeviceChain () & 0xFFFFFFFFl;
        int segm = (int) (start>> 16);
        int offm = (int) (start & 0xFFFF);
        while (start != 0xFFFFFFFFl) {
            segm = (int) (start>>> 16);
            offm = (int) (start & 0xFFFF);
            start = Memory.real_readd (segm, offm) & 0xFFFFFFFFl;
        }
        Memory.real_writed (segm, offm, seg << 16);
        int off = DOS_DeviceHeader.size;
        int call_strategy = Callback.CALLBACK_Allocate ();
        Callback.CallBack_Handlers [call_strategy] = MSCDEX_Strategy_Handler;
        Memory.real_writeb (seg, off + 0, (short) 0xFE);
        Memory.real_writeb (seg, off + 1, (short) 0x38);
        Memory.real_writew (seg, off + 2, call_strategy);
        Memory.real_writeb (seg, off + 4, (short) 0xCB);
        devHeader.SetStrategy (off);
        off += 5;
        int call_interrupt = Callback.CALLBACK_Allocate ();
        Callback.CallBack_Handlers [call_interrupt] = MSCDEX_Interrupt_Handler;
        Memory.real_writeb (seg, off + 0, (short) 0xFE);
        Memory.real_writeb (seg, off + 1, (short) 0x38);
        Memory.real_writew (seg, off + 2, call_interrupt);
        Memory.real_writeb (seg, off + 4, (short) 0xCB);
        devHeader.SetInterrupt (off);
        rootDriverHeaderSeg = seg;
    }
    else if (GetNumDrives () == 0) {
        DOS_DeviceHeader devHeader = new DOS_DeviceHeader (Memory.PhysMake (rootDriverHeaderSeg, 0));
        int off = DOS_DeviceHeader.size;
        devHeader.SetDriveLetter (_drive + 1);
        devHeader.SetStrategy (off);
        devHeader.SetInterrupt (off + 5);
    }
    DOS_DeviceHeader devHeader = new DOS_DeviceHeader (Memory.PhysMake (rootDriverHeaderSeg, 0));
    devHeader.SetNumSubUnits ((short) (devHeader.GetNumSubUnits () + 1));
    if (dinfo [0].drive - 1 == _drive) {
        Dos_cdrom.CDROM_Interface _cdrom = cdrom [numDrives];
        CDROM_Interface_Image _cdimg = CDROM_Interface_Image.images [numDrives];
        for (int i = GetNumDrives (); i > 0; i --) {
            dinfo [i] = dinfo [i - 1];
            cdrom [i] = cdrom [i - 1];
            CDROM_Interface_Image.images [i] = CDROM_Interface_Image.images [i - 1];
        }
        cdrom [0] = _cdrom;
        CDROM_Interface_Image.images [0] = _cdimg;
        dinfo [0].drive = (short) _drive;
        dinfo [0].physDrive = (short) physicalPath.toUpperCase ().charAt (0);
        subUnit.value = 0;
    }
    else {
        dinfo [numDrives].drive = (short) _drive;
        dinfo [numDrives].physDrive = (short) physicalPath.toUpperCase ().charAt (0);
        subUnit.value = (short) numDrives;
    }
    numDrives ++;
    for (int chan = 0; chan < 4; chan ++) {
        dinfo [subUnit.value].audioCtrl.out [chan] = chan;
        dinfo [subUnit.value].audioCtrl.vol [chan] = 0xff;
    }
    StopAudio (subUnit.value);
    return result;
}


-----Function Pair=60=-----==

void resetColors () {
    if ((colors == null) || (colors.length == 0)) {
        return;
    }
    final Control [] children = colorContainer.getChildren ();
    final int length = gradientDatas == null ? 0 : gradientDatas.length;
    if (colors.length != children.length - length) {
        return;
    }
    final IProxyColor [] colors2 = new ProxyColor [colors.length];
    for (int i = 0; i < colors.length; i ++) {
        final int index = colors [i].getIndex ();
        if ((index < children.length) && (index > - 1)) {
            colors2 [index] = colors [i];
        }
        else {
            System.err.println ("resetColors()");
        }
    }
    colors = colors2;
    updateColors ();
}


public void mousePressed (MouseEvent arg0) {
    Object source = arg0.getSource ();
    if (source == imageRegion) {
        checkMove = 0;
        xStart = arg0.getX ();
        yStart = arg0.getY ();
        drag = true;
        dx = dy = 0;
        xdiff = 0;
        ydiff = 0;
        imageRegion.repaint ();
    }
    else if (source == slider1 || source == slider2) {
        drag = true;
    }
}


-----Function Pair=61=-----==

private File compile (String javafile) throws IOException {
    File classFile = null;
    Process p = null;
    try {
        p = Runtime.getRuntime ().exec (new String [] {getJavaBinPath () + File.separator + JAVAC, javafile});
        p.waitFor ();
    } catch (Exception rte) {
        throw new IOException ("Runtime exception: check if you have installed the JDK and run java from the JDK\n" + "Exception message: " + rte.getMessage ());
    }
    printCmdOutput (p, "javac");
    if (p.exitValue () != 0) throw new RuntimeException ("  abnormal exit");
    classFile = new File (javafile.substring (0, javafile.lastIndexOf ('.')) + ".class");
    System.out.println ("  " + classFile + " " + classFile.exists ());
    return classFile;
}


void processForeachRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variable in FOREACH");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in FOREACH");
    String file_name = pst.nextToken ();
    String select = null;
    String start = null;
    String end = null;
    boolean inRange = false;
    if (pst.hasMoreTokens ()) {
        select = pst.nextToken ();
        if (! pst.hasMoreTokens ()) throw new IOException ("Missing field value in FOREACH");
        String fval = pst.nextToken ();
        int dotdot = fval.indexOf ("..");
        if (dotdot != - 1 && dotdot == fval.lastIndexOf ("..")) {
            start = fval.substring (0, dotdot);
            end = fval.substring (dotdot + 2);
        }
        else {
            start = fval;
        }
    }
    if (DEBUG) System.out.println ("doing foreach with varname " + var_name + " on data file :" + file_name);
    if (DEBUG && select != null) {
        System.out.print ("   selecting records with " + select);
        if (end == null) System.out.println (" equal to \"" + start + "\"");
        else System.out.println (" between \"" + start + "\" and \"" + end + "\"");
    }
    BufferedReader data;
    try {
        data = new BufferedReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        data = new BufferedReader (new FileReader (inDir + file_name));
    }
    Vector fields_v = new Vector ();
    Vector fpl_v = new Vector ();
    for (String inLine = getNextLine (data); (inLine != null && inLine.length () != 0); inLine = getNextLine (data)) {
        StringTokenizer st = new StringTokenizer (inLine);
        fpl_v.addElement (new Integer (st.countTokens ()));
        while (st.hasMoreTokens ()) {
            String tok = st.nextToken ();
            if (DEBUG) System.out.println ("read field " + fields_v.size () + " :" + tok);
            fields_v.addElement (tok);
        }
    }
    fields_v.addElement (indexField);
    int [] fieldsPerLine = new int [fpl_v.size ()];
    for (int i = 0; i < fieldsPerLine.length; i ++) fieldsPerLine [i] = ((Integer) fpl_v.elementAt (i)).intValue ();
    String [] fields = new String [fields_v.size ()];
    for (int i = 0; i < fields.length; i ++) fields [i] = (String) fields_v.elementAt (i);
    dataFileLoop : for (int curField = 0;; curField ++) {
        int i = 0;
        String [] fieldData = new String [fields.length];
        for (int j = 0; j < fieldsPerLine.length; j ++) {
            String line = getNextLine (data);
            if (line == null) break dataFileLoop;
            if (fieldsPerLine [j] == 1) {
                if (DEBUG) System.out.println ("read field " + fields [i] + " :" + line);
                fieldData [i ++] = line;
            }
            else {
                if (DEBUG) System.out.println ("reading " + fieldsPerLine [j] + " fields");
                StringTokenizer st = new StringTokenizer (line);
                try {
                    for (int k = 0; k < fieldsPerLine [j]; k ++) {
                        String tok = st.nextToken ();
                        if (DEBUG) System.out.println ("read field " + fields [i] + ": " + tok);
                        fieldData [i ++] = tok;
                    }
                } catch (NoSuchElementException x) {
                    throw new IOException ("Missing field " + fields [i]);
                }
            }
        }
        if (fieldsPerLine.length != 1) getNextLine (data);
        fieldData [i ++] = Integer.toString (curField);
        if (select != null) {
            for (int j = 0; j < fields.length; j ++) {
                if (DEBUG) System.out.println ("checking if select is field " + fields [j]);
                if (select.equals (fields [j])) {
                    String value = fieldData [j];
                    if (value.equals (start)) inRange = true;
                    else if (end == null) inRange = false;
                    else if (value.equals (end)) end = null;
                    if (DEBUG) System.out.println ("record in range; including");
                    break;
                }
            }
            if (! inRange) break dataFileLoop;
        }
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name, fields, fieldData);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name, fields, fieldData);
                processTemplateRegion (newRegion);
            }
        }
    }
    data.close ();
}


-----Function Pair=62=-----==

private void compileBootImage (String args []) {
    String bi_args [] = new String [args.length - 1];
    String bi_name = args [args.length - 1];
    Class pub_cl;
    Object pub_obj;
    java.lang.reflect.Method pub_methods [];
    jdp_console.writeOutput ("Compiling Boot Image for " + bi_name + " . . . ");
    for (int i = 0; i < bi_args.length; i ++) {
        bi_args [i] = args [i + 1];
    }
    try {
        pub_cl = Class.forName (args [0]);
        pub_obj = pub_cl.newInstance ();
        pub_methods = pub_cl.getMethods ();
        for (int n = 0; n < pub_methods.length; n ++) {
            if (pub_methods [n].getName ().equals ("main")) {
                Object invoke_args [] = {bi_args};
                pub_methods [n].invoke (pub_obj, invoke_args);
                return;
            }
        }
    } catch (ClassNotFoundException e) {
        jdp_console.writeOutput ("cannot compile, publicizing class loader not found: " + args [0]);
        System.exit (1);
    } catch (InstantiationException e1) {
        jdp_console.writeOutput ("cannot compile, problem instantiating class");
        System.exit (1);
    } catch (IllegalAccessException e2) {
        jdp_console.writeOutput ("cannot compile, illegal access to class");
        System.exit (1);
    } catch (InvocationTargetException e3) {
        jdp_console.writeOutput ("cannot compile, Invocation Target Exception:");
        jdp_console.writeOutput (e3.getMessage ());
        System.exit (1);
    }
}


public void bayesianAveraging () {
    double weights [] = new double [numModels];
    double maxweight = Double.NEGATIVE_INFINITY;
    for (int i = 0; i < numModels; i ++) {
        weights [i] = models [i].getLogLikelihood ();
        if (weights [i] > maxweight) {
            maxweight = weights [i];
        }
    }
    double weightTotal = 0.0;
    for (int i = 0; i < numModels; ++ i) {
        weights [i] = Math.exp (weights [i] - maxweight);
        weightTotal += weights [i];
    }
    if (weightTotal <= 0.0) {
        System.out.println ("Error: zero total weight for all models");
        System.exit (1);
    }
    for (int i = 0; i < numModels; ++ i) {
        if (weights [i] <= 0.0) continue;
        ensemble.addModel (models [i], allSets, weights [i]);
        if (report) {
            ensemble.report (models [i].getName () + " " + weights [i], allSets);
        }
    }
    updateBestModel ();
}


-----Function Pair=63=-----==

public void doSetPreference (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    if (args.length == 0) {
        ret.append ("Current preferences: \n");
        ret.append ("  integer = " + integerPreference + "\n");
        ret.append ("  stack = " + stackPreference + "\n");
        ret.append ("  fpr = " + fprPreference + "\n");
        jdp_console.writeOutput (ret.toString ());
    }
    else if (args [0].equals ("int")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) integerPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) integerPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("stack")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) stackPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) stackPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("fpr")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) fprPreference = 'x';
        else if (args [1].equals ("float") || args [1].equals ("f")) fprPreference = 'f';
        else printHelp (command);
        return;
    }
    else {
        printHelp (command);
    }
}


void load (byte [] data) {
    ByteArrayInputStream bis = new ByteArrayInputStream (data);
    try {
        checkSum = read16 (bis);
        length = read16 (bis);
        transControl = (short) bis.read ();
        pType = (short) bis.read ();
        dest.network = read32 (bis);
        bis.read (dest.addr.byNode.node);
        dest.socket = read16 (bis);
        src.network = read32 (bis);
        bis.read (src.addr.byNode.node);
        src.socket = read16 (bis);
    } catch (Exception e) {
    }
}


-----Function Pair=64=-----==

public static void main (String [] args) {
    MorphTarget_binarysearch mt = new MorphTarget_binarysearch ();
    Accumulator [] accs = new Accumulator [] {new ScalarAccumulator (), new ScalarAccumulator (), new Tuple3Accumulator (), new Tuple3Accumulator (), new ScalarAccumulator (), new Tuple3Accumulator ()};
    ((ScalarAccumulator) accs [0]).setValue (1);
    ((ScalarAccumulator) accs [1]).setValue (2);
    ((Tuple3Accumulator) accs [2]).setValue (3, 4, 5);
    ((Tuple3Accumulator) accs [3]).setValue (6, 7, 8);
    ((ScalarAccumulator) accs [4]).setValue (9);
    ((Tuple3Accumulator) accs [5]).setValue (10, 11, 12);
    Random rnd = new Random ();
    for (int k = 0; k < 2; k ++) {
        for (int i = 0; i < accs.length; i ++) {
            mt.addAccumulator (accs [i]);
            mt.dump ();
            System.out.println ();
        }
    }
    ((Tuple3Accumulator) accs [5]).setValue (- 20, - 22, - 24);
    mt.addAccumulator (accs [5]);
    mt.dump ();
    mt.removeAccumulator (4);
    mt.dump ();
}


private static void pingAck (IPaddress retAddr) {
    IPXHeader regHeader = new IPXHeader ();
    regHeader.checkSum = (short) 0xFFFF;
    regHeader.dest.network = 0;
    regHeader.dest.addr.setHost (retAddr.host);
    regHeader.dest.addr.setPort (retAddr.port);
    regHeader.dest.socket = 2;
    regHeader.src.network = 0;
    System.arraycopy (localIpxAddr.netnode, 0, regHeader.src.addr.byNode.node, 0, regHeader.src.addr.byNode.node.length);
    regHeader.src.socket = 2;
    regHeader.transControl = 0;
    regHeader.pType = 0x0;
    byte [] buf = regHeader.toByteArray ();
    try {
        DatagramPacket packet = new DatagramPacket (buf, buf.length, ipxServConnIp, udpPort);
        ipxClientSocket.send (packet);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=65=-----==

public void startApp (String mainClassName, String mainArgs []) {
    try {
        File path = new File ("./");
        sun.misc.CDCAppClassLoader loader = new CDCAppClassLoader (new URL [] {path.toURL ()}, null);
        Class [] args1 = {new String [0].getClass ()};
        Object [] args2 = {mainArgs};
        Class mainClass = loader.loadClass (mainClassName);
        Method mainMethod = mainClass.getMethod ("main", args1);
        mainMethod.invoke (null, args2);
    } catch (InvocationTargetException i) {
        i.printStackTrace ();
    } catch (Throwable e) {
        e.printStackTrace ();
    }
}


public static int [] bubbleSort2 (int [] source) {
    if (null != source && source.length > 0) {
        boolean flag = false;
        while (! flag) {
            for (int i = 0; i < source.length - 1; i ++) {
                if (source [i] > source [i + 1]) {
                    int temp = source [i];
                    source [i] = source [i + 1];
                    source [i + 1] = temp;
                    break;
                }
                else if (i == source.length - 2) {
                    flag = true;
                }
            }
        }
    }
    return source;
}


-----Function Pair=66=-----==

void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=67=-----==

public List getSelection () {
    Selectable selectionAry [] = getGraphicPanel ().getSelectionModel ().getSelection ();
    ArrayList selection = new ArrayList ();
    for (int i = 0; i < selectionAry.length; i ++) {
        Selectable s = selectionAry [i];
        if (s instanceof GraphPortModel) {
            if (! (((GraphPortModel) s).getNode ().isSelected () || ((GraphPortModel) s).getNode ().getGraph ().isSelected ()) && myGraphicObjects.contains (s)) selection.add (s);
        }
        else if (s instanceof GraphModel) {
            if (myGraphicObjects.contains (s)) selection.add (s);
        }
        else if (s instanceof GraphNodeModel) {
            if (! ((GraphNodeModel) s).getGraph ().isSelected () && myGraphicObjects.contains (s)) selection.add (s);
        }
    }
    for (int i = 0; i < selectionAry.length; i ++) {
        Selectable s = selectionAry [i];
        if (s instanceof GraphEdgeModel) {
            GraphEdgeModel edge = (GraphEdgeModel) s;
            if ((edge.getGraph () == null || ! edge.getGraph ().isSelected ()) && myGraphicObjects.contains (s)) selection.add (s);
        }
    }
    return selection;
}


public RobotList < Float > sort_incr_Float (RobotList < Float > list, String field) {
    int length = list.size ();
    Index_value [] distri = new Index_value [length];
    for (int i = 0; i < length; i ++) {
        distri [i] = new Index_value (i, list.get (i));
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (distri [i].value > distri [i + 1].value) {
                Index_value a = distri [i];
                distri [i] = distri [i + 1];
                distri [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Float > sol = new RobotList < Float > (Float.class);
    for (int i = 0; i < length; i ++) {
        sol.addLast (new Float (distri [i].value));
    }
    return sol;
}


-----Function Pair=68=-----==

void processParams (int format, int width, int height, int depth) {
    if (width < 1) throw new IllegalArgumentException (J3dI18N.getString ("ImageComponentRetained0"));
    if (height < 1) throw new IllegalArgumentException (J3dI18N.getString ("ImageComponentRetained1"));
    if (depth < 1) throw new IllegalArgumentException (J3dI18N.getString ("ImageComponentRetained2"));
    switch (format) {
        case ImageComponent.FORMAT_RGB :
        case ImageComponent.FORMAT_RGB4 :
        case ImageComponent.FORMAT_RGB5 :
        case ImageComponent.FORMAT_R3_G3_B2 :
            numberOfComponents = 3;
            break;
        case ImageComponent.FORMAT_RGBA :
        case ImageComponent.FORMAT_RGB5_A1 :
        case ImageComponent.FORMAT_RGBA4 :
            numberOfComponents = 4;
            break;
        case ImageComponent.FORMAT_LUM4_ALPHA4 :
        case ImageComponent.FORMAT_LUM8_ALPHA8 :
            numberOfComponents = 2;
            break;
        case ImageComponent.FORMAT_CHANNEL8 :
            numberOfComponents = 1;
            break;
        default :
            throw new IllegalArgumentException (J3dI18N.getString ("ImageComponentRetained3"));
    }
    this.setFormat (format);
    this.width = width;
    this.height = height;
    this.depth = depth;
    refImage = new Object [depth];
}


public RobotList < Location > sort_incr_Location (RobotList < Location > list, String field) {
    int length = list.size ();
    Index_value [] enemy_dist = new Index_value [length];
    Location cur_loc = this.getLocation ();
    for (int i = 0; i < length; i ++) {
        enemy_dist [i] = new Index_value (i, distance (cur_loc, list.get (i)));
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (enemy_dist [i].value > enemy_dist [i + 1].value) {
                Index_value a = enemy_dist [i];
                enemy_dist [i] = enemy_dist [i + 1];
                enemy_dist [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Location > new_location_list = new RobotList < Location > (Location.class);
    for (int i = 0; i < length; i ++) {
        new_location_list.addLast (list.get (enemy_dist [i].index));
    }
    return new_location_list;
}


-----Function Pair=69=-----==

public void gameLoop () {
    if (this.moveBlockDown ()) {
        this.clearCompleteLines ();
        if (this.newLevel != this.level) {
            level = newLevel;
        }
    }
    else {
        for (int i = 0; i < 4; i ++) {
            if (this.grid [this.nextBlock.subblocks [0].xpos + this.nextBlock.xPos] [this.currentBlock.subblocks [0].ypos + this.nextBlock.yPos] != - 1) {
                this.setStatus (STATUS_GAME_OVER);
                return;
            }
        }
        this.currentBlock = this.nextBlock;
        Block bl = new Block ();
        this.nextBlock = bl;
    }
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=70=-----==

void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


public static void sendControllerData (int channel, int type, int value, int refNumIndex) {
    if (value < 0 || value > 127) {
        try {
            Exception e = new Exception ("ctrl value must be from 0-127");
            e.fillInStackTrace ();
            throw e;
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    int event = Midi.NewEv (Midi.typeCtrlChange);
    if (event != 0) {
        setPortChan (channel, event);
        Midi.SetField (event, 0, type);
        Midi.SetField (event, 1, value);
        Midi.SendIm (msrefnums [refNumIndex], event);
    }
    freeCount ++;
    freeCount = freeCount % 400;
}


-----Function Pair=71=-----==

public void gaussFit () {
    System.out.print ("Fitting Gaussian \n");
    double upperAmp = 4 * max;
    double upperSigma = 4 * rms;
    double upperCenter = 4 * xav;
    ArrayList variables = new ArrayList ();
    variables.add (new Variable ("amp", max, 0, upperAmp));
    variables.add (new Variable ("sigma", rms, 0, upperSigma));
    variables.add (new Variable ("center", xav, 0, upperCenter));
    ArrayList objectives = new ArrayList ();
    objectives.add (new TargetObjective ("diff", 0.0));
    Evaluator1 evaluator = new Evaluator1 (objectives, variables);
    Problem problem = new Problem (objectives, variables, evaluator);
    problem.addHint (new InitialDelta (0.05));
    double solvetime = 2;
    Stopper maxSolutionStopper = SolveStopperFactory.minMaxTimeSatisfactionStopper (1, solvetime, 0.999);
    Solver solver = new Solver (new RandomShrinkSearch (), maxSolutionStopper);
    solver.solve (problem);
    System.out.println ("score is " + solver.getScoreBoard ());
    Trial best = solver.getScoreBoard ().getBestSolution ();
    calcError (variables, best);
    Iterator itr = variables.iterator ();
    while (itr.hasNext ()) {
        Variable variable = (Variable) itr.next ();
        double value = best.getTrialPoint ().getValue (variable);
        String name = variable.getName ();
        if (name.equalsIgnoreCase ("amp")) amp = value;
        if (name.equalsIgnoreCase ("sigma")) sigma = value;
        if (name.equalsIgnoreCase ("center")) center = value;
    }
    if (! table2) {
        result [0].setValue (center + phi0);
        result [1].setValue (sigma);
        result [2].setValue (amp);
    }
}


public JDPServer (int initialPort) {
    port = initialPort;
    boolean socketOpened = false;
    while (! socketOpened) {
        try {
            serverSocket = new ServerSocket (port);
            System.out.println ("JDPServer running on port " + port);
            socketOpened = true;
        } catch (IOException e) {
            if (++ port > 65536) {
                System.err.println ("No available port");
                System.exit (1);
            }
        }
    }
}


-----Function Pair=72=-----==

public void save (String filePath) {
    ObjectOutputStream out = null;
    try {
        File file = new File (filePath);
        out = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (file)));
        out.writeObject (this);
        out.flush ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    } finally {
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
}


public static void main (String [] args) {
    int [] a = new int [1000000];
    for (int i = 0; i < a.length; i ++) {
        a [i] = i;
    }
    long start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findBinary (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
    start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findLinear (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
}


-----Function Pair=73=-----==

public void setCoef (int coef) {
    super.setCoef (coef);
    xn = new double [coefficients];
    gn = new double [coefficients];
    hn = new double [coefficients] [coefficients];
    na = new double [coef + 1];
    besta = new double [coef + 1];
    f = new double [coef + 1];
    g = new double [coef + 1];
    aa = new double [coef + 1] [coef + 1];
    udiag = new double [coef + 1];
    info = new int [coef + 1];
    typsiz = new double [coef + 1];
    MyRandom rnd = GlobalRandom.getInstance ();
    for (int i = 0; i < coef + 1; i ++) na [i] = rnd.getSmallDouble ();
    for (int i = 1; i <= coef; i ++) {
        typsiz [i] = 1.0;
    }
    double [] x = new double [coef + 1];
    double [] g = new double [coef + 1];
    double [] [] h = new double [coef + 1] [coef + 1];
    if (! unit.gradient (x, g)) {
        iagflg [1] = 0;
    }
    else {
        iagflg [1] = 1;
    }
    if (forceHessian && unit.hessian (x, h)) {
        iexp [1] = 0;
        iahflg [1] = 1;
        System.out.println ("analytic hessian enabled");
    }
    else {
        iexp [1] = 1;
        iahflg [1] = 0;
    }
}


public void removeReference (int index) {
    int count = this.getReferenceCount ();
    if (index >= count) {
        return;
    }
    adjustReferenceCount (this, this.references [index], - 1, null);
    if (count > 1) {
        RAMObject [] newReferences = new RAMObject [count - 1];
        this.removeItem (this.references, newReferences, index);
        this.references = newReferences;
    }
    else {
        this.references = null;
    }
    this.changed (ChangeInfo.REFERENCE);
}


-----Function Pair=74=-----==

public static void main (String args []) {
    try {
        Array arr = new Array ();
        arr.addValue (00);
        arr.addValue (99);
        arr.addValue (33);
        arr.addValue (55);
        arr.addValue (74);
        arr.addValue (12);
        arr.addValue (78);
        arr.addValue (39);
        arr.addValue (81);
        arr.addValue (22);
        arr.addValue (43);
        System.out.println (arr.getString ());
        int index = - 1;
        try {
            index = arr.findValue (22);
        } catch (InvalidValueException e) {
            throw new ProgrammingErrorException ("Arrray did not find" + " a value I inserted");
        }
        System.out.println ("Found 22 at index " + Integer.toString (index) + ".");
        try {
            index = arr.findValue (11);
        } catch (InvalidValueException e) {
            System.out.println ("Could not find 11 in array.");
        }
        try {
            System.out.println ("Deleting 81 & 39.");
            arr.deleteValue (81);
            arr.deleteValue (39);
        } catch (InvalidValueException e) {
            throw new ProgrammingErrorException ("Arrray did not find" + " a value I inserted");
        }
        System.out.println (arr.getString ());
    } catch (ProgrammingErrorException e) {
        System.out.println (e.getMessage ());
    } catch (OutOfMemoryException e) {
        System.out.println (e.getMessage ());
    }
}


private void processStartBattleMessage (final Message message) {
    MessageWindow mw = new MessageWindow ("       " + GameLanguage.getString ("battle.starting") + "       ");
    mw.setTitle (GameLanguage.getString ("windowMessage.information"));
    mw.getCloseButton ().setVisible (false);
    mw.pack ();
    display.addWidget (mw);
    StaticLayout.center (mw, display);
    new Thread (new Runnable () {
        public void run () {
            try {
                GameTaskQueueManager.getManager ().render (new Callable < Object > () {
                    public Object call () throws Exception {
                        StartGameArguments gameArgs = new StartGameArguments ();
                        String imgHeightMap = ((StartBattle) message).getTerrainHeightmapImage ();
                        if (imgHeightMap != null) {
                            gameArgs.setTerrainHeightMapImage (imgHeightMap);
                        }
                        gameArgs.setLocalPlayer (localPlayer);
                        for (Player player : players.values ()) {
                            gameArgs.addPlayer (player);
                        }
                        TankCoders.getGameInstance ().changeToInGameState (gameArgs);
                        return null;
                    }
                }
                ).get ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
    ).start ();
}


-----Function Pair=75=-----==

void initProcess () {
    wrap = false;
    parseState = groundtable;
    param = new int [10];
    for (int i = 0; i < 10; i ++) {
        param [i] = DEFAULT;
    }
    tabStop = new int [100];
    for (int i = 0; i < columns / 8; i ++) {
        tabStop [i] = i * 8;
    }
    for (int i = columns / 8; i < 100; i ++) {
        tabStop [i] = maxInt;
    }
    endScroll = lines;
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=76=-----==

public void shutdownThreads () {
    if (threadsRunning) {
        logger.debug ("Stopping Reporting Thread.....");
        com.commander4j.util.JWait.milliSec (100);
        reportingThread.allDone = true;
        try {
            while (reportingThread.isAlive ()) {
                reportingThread.allDone = true;
                com.commander4j.util.JWait.milliSec (100);
            }
        } catch (Exception ex1) {
        }
        com.commander4j.util.JWait.milliSec (5000);
        logger.debug ("Reporting Thread Stopped.");
        com.commander4j.util.JWait.milliSec (100);
        threadsRunning = false;
        logger.debug ("Stopping Inbound Interface Thread.....");
        com.commander4j.util.JWait.milliSec (100);
        inboundThread.allDone = true;
        try {
            while (inboundThread.isAlive ()) {
                inboundThread.allDone = true;
                com.commander4j.util.JWait.milliSec (100);
            }
        } catch (Exception ex) {
        }
        logger.debug ("Inbound Interface Thread Stopped.");
        logger.debug ("Stopping Outbound Interface Thread.....");
        com.commander4j.util.JWait.milliSec (100);
        outboundThread.allDone = true;
        try {
            while (outboundThread.isAlive ()) {
                outboundThread.allDone = true;
                com.commander4j.util.JWait.milliSec (100);
            }
        } catch (Exception ex1) {
        }
        logger.debug ("Outbound Interface Thread Stopped.");
        logger.debug ("Stopping File Collection Thread.....");
        com.commander4j.util.JWait.milliSec (100);
        fileCollectThread.allDone = true;
        try {
            while (fileCollectThread.isAlive ()) {
                fileCollectThread.allDone = true;
                com.commander4j.util.JWait.milliSec (100);
            }
        } catch (Exception ex2) {
        }
        logger.debug ("File Collection Thread Stopped.");
    }
}


public void testNotSuccesfulSecureCall () throws Exception {
    JRMPAdaptor adaptor = new JRMPAdaptor ();
    JRMPConnector connector = new JRMPConnector ();
    try {
        HashMap map = new HashMap ();
        String user = "simon";
        char [] password = user.toCharArray ();
        map.put (user, password);
        String anotherUser = "another";
        map.put (anotherUser, password);
        adaptor.setAuthenticator (new UserPasswordAdaptorAuthenticator (map));
        String jndiName = "jrmp";
        adaptor.setJNDIName (jndiName);
        adaptor.setMBeanServer (m_server);
        adaptor.start ();
        connector.connect (jndiName, null);
        RemoteMBeanServer server = connector.getRemoteMBeanServer ();
        UserPasswordAuthRequest request = new UserPasswordAuthRequest (anotherUser, password);
        UserPasswordAuthReply reply = (UserPasswordAuthReply) connector.login (request);
        UserPasswordInvocationContext context = new UserPasswordInvocationContext (reply);
        connector.setInvocationContext (context);
        try {
            String id = (String) server.getAttribute (new ObjectName ("JMImplementation:type=MBeanServerDelegate"), "MBeanServerId");
            fail ("User has not the right permissions");
        } catch (SecurityException x) {
        } finally {
            connector.logout (context);
        }
    } finally {
        connector.close ();
        adaptor.stop ();
    }
}


-----Function Pair=77=-----==

private synchronized void createFTPConnection () throws FTPBrowseException {
    ftpClient = new FTPClient ();
    try {
        InetAddress inetAddress = InetAddress.getByName (url.getHost ());
        if (url.getPort () == - 1) {
            ftpClient.connect (inetAddress);
        }
        else {
            ftpClient.connect (inetAddress, url.getPort ());
        }
        if (! FTPReply.isPositiveCompletion (ftpClient.getReplyCode ())) {
            throw new FTPBrowseException (ftpClient.getReplyString ());
        }
        if (null != passwordAuthentication) {
            ftpClient.login (passwordAuthentication.getUserName (), new StringBuffer ().append (passwordAuthentication.getPassword ()).toString ());
        }
        if (url.getPath ().length () > 0) {
            ftpClient.changeWorkingDirectory (url.getPath ());
        }
        homeDirectory = ftpClient.printWorkingDirectory ();
    } catch (UnknownHostException e) {
        throw new FTPBrowseException (e.getMessage ());
    } catch (SocketException e) {
        throw new FTPBrowseException (e.getMessage ());
    } catch (FTPBrowseException e) {
        throw e;
    } catch (IOException e) {
        throw new FTPBrowseException (e.getMessage ());
    }
}


public boolean copyItems (SparseBooleanArray cis, CommanderAdapter to, boolean move) {
    String err_msg = null;
    try {
        LsItem [] subItems = bitsToItems (cis);
        if (subItems == null) {
            notify (s (R.string.copy_err), Commander.OPERATION_FAILED);
            return false;
        }
        if (! checkReadyness ()) return false;
        File dest = null;
        int rec_h = 0;
        if (to instanceof FSAdapter) {
            dest = new File (to.toString ());
            if (! dest.exists ()) dest.mkdirs ();
            if (! dest.isDirectory ()) throw new RuntimeException (s (R.string.dest_exist));
        }
        else {
            dest = new File (createTempDir ());
            rec_h = setRecipient (to);
        }
        notify (Commander.OPERATION_STARTED);
        worker = new CopyFromEngine (workerHandler, subItems, dest, move, rec_h);
        worker.start ();
        return true;
    } catch (Exception e) {
        err_msg = "Exception: " + e.getMessage ();
    }
    notify (err_msg, Commander.OPERATION_FAILED);
    return false;
}


-----Function Pair=78=-----==

private synchronized void createFTPConnection () throws RemoteClientException {
    ftpClient = new FTPClient ();
    try {
        URL url = fileset.getHostURL ();
        PasswordAuthentication passwordAuthentication = fileset.getPasswordAuthentication ();
        if (null == passwordAuthentication) {
            passwordAuthentication = anonPassAuth;
        }
        InetAddress inetAddress = InetAddress.getByName (url.getHost ());
        if (url.getPort () == - 1) {
            ftpClient.connect (inetAddress);
        }
        else {
            ftpClient.connect (inetAddress, url.getPort ());
        }
        if (! FTPReply.isPositiveCompletion (ftpClient.getReplyCode ())) {
            throw new FTPBrowseException (ftpClient.getReplyString ());
        }
        ftpClient.login (passwordAuthentication.getUserName (), new StringBuffer ().append (passwordAuthentication.getPassword ()).toString ());
        if (url.getPath ().length () > 0) {
            ftpClient.changeWorkingDirectory (url.getPath ());
        }
    } catch (UnknownHostException e) {
        throw new RemoteClientException ("Host not found.", e);
    } catch (SocketException e) {
        throw new RemoteClientException ("Socket cannot be opened.", e);
    } catch (IOException e) {
        throw new RemoteClientException ("Socket cannot be opened.", e);
    }
}


public boolean uploadFile (File source, String destination) throws IOException {
    FileInputStream in = null;
    try {
        if (ftpClient == null || ! ftpClient.isConnected ()) {
            throw new IOException ("The current instance of the " + "FTP client is either closed or was never opened. Connection " + "to the FTP server is requried before calling any FTP commands.");
        }
        if (fileTransferMode == null) {
            setFileTransferMode (DEFAULT_FILE_TRANSFER_MODE);
        }
        in = new FileInputStream (source);
        ftpClient.storeFile (destination, in);
        int reply = ftpClient.getReplyCode ();
        return (FTPReply.isPositiveCompletion (reply));
    } catch (Exception ex) {
        throw new IOException (ex.getMessage ());
    } finally {
        Streams.close (in);
    }
}


-----Function Pair=79=-----==

private void createContactWidget () {
    Connection connection = new Connection ("jabber.org");
    ContactList contactList = connection.getContactList ();
    if (connection.connect ()) {
        if (connection.login ("safroe", "fa234sdk", null)) {
            Roster roster = connection.getXmppConnection ().getRoster ();
            ArrayList < String > groupList = contactList.getGroupList ();
            QTreeWidget treeWidget = new QTreeWidget (this);
            treeWidget.setColumnCount (1);
            treeWidget.setHeaderLabel ("Kontakte");
            for (int i = 0; i < groupList.size (); i ++) {
                QTreeWidgetItem groupItem = new QTreeWidgetItem ();
                String groupName = groupList.get (i);
                groupItem.setText (0, groupName);
                RosterGroup group = roster.getGroup (groupName);
                Iterator < RosterEntry > entries = group.getEntries ().iterator ();
                while (entries.hasNext ()) {
                    RosterEntry entry = entries.next ();
                    QTreeWidgetItem entryItem = new QTreeWidgetItem (groupItem);
                    entryItem.setText (0, entry.getName ());
                }
                treeWidget.addTopLevelItem (groupItem);
            }
            treeWidget.expandAll ();
            treeWidget.addAction (null);
            treeWidget.clicked.connect (this, "newChat()");
            setCentralWidget (treeWidget);
        }
    }
}


public ArrayList < String > getFileToArr (String filePath) {
    BufferedReader bufReader;
    ArrayList < String > arr = new ArrayList < String > ();
    try {
        bufReader = new BufferedReader (new InputStreamReader (new FileInputStream (cn.imgdpu.util.FileUrlConv.UrlConvIo (filePath))));
        String str;
        while ((str = bufReader.readLine ()) != null) {
            arr.add (str);
        }
        bufReader.close ();
    } catch (IOException e) {
        cn.imgdpu.util.CatException.getMethod ().catException (e, "IOÂºÇÂ∏∏");
    }
    return arr;
}


-----Function Pair=80=-----==

public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


protected void sendMessagesFromNode (SgsTestNode node, final DummyClient client, final int numMessages, final int offset) throws Exception {
    System.err.println ("sending messages to client [" + client.name + "]");
    TransactionScheduler transactionScheduler = node.getSystemRegistry ().getComponent (TransactionScheduler.class);
    for (int i = 0; i < numMessages; i ++) {
        final int x = i + offset;
        transactionScheduler.runTask (new TestAbstractKernelRunnable () {
            public void run () {
                ClientSession session = (ClientSession) AppContext.getDataManager ().getBinding (client.name);
                ByteBuffer buf = ByteBuffer.allocate (4);
                buf.putInt (x).flip ();
                session.send (buf, Delivery.RELIABLE);
            }
        }
        , taskOwner);
    }
}


-----Function Pair=81=-----==

public static boolean isMonitorAvailable (String host) {
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") called");
    if (! TraceFileMonitor.isMonitoringOn ()) {
        return true;
    }
    String port = "";
    try {
        port = TFPropertyLoader.getInstance ().getPortWithColon ((String) host);
    } catch (Exception ex) {
        System.out.println ("MiscUtil.isMonitorAvailable(" + host + ") - Exception: " + ex.getMessage ());
        ex.printStackTrace ();
        return false;
    }
    System.out.println ("port = " + port);
    if (! MiscUtils.isHostAlive (host, port.substring (1))) {
        return false;
    }
    long timeout = 1000;
    final String hostF = "monp://" + host + port;
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") - host with port:" + hostF);
    TimeoutExecutor te = new TimeoutExecutor ();
    Function f = new Function () {
        public Object execute () {
            MonitorConsumer mc = null;
            try {
                mc = new MonitorConsumer (hostF);
                mc.close ();
                mc = null;
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): OK");
            } catch (Exception ex) {
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): Exception - " + ex.getMessage ());
                mc = null;
                return TimeoutExecutor.RESULT_AT_TIMEOUT;
            }
            System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): true");
            mc = null;
            return new Boolean (true);
        }
    }
    ;
    Object result = null;
    try {
        result = te.executeFunctionWithTimeout (f, timeout);
    } catch (FunctionTimeoutException ftex) {
        System.out.println ("MiscUtils.isMonitorAbailable() - ftex:" + ftex.getMessage ());
        ftex.printStackTrace ();
        return false;
    }
    if (result != TimeoutExecutor.RESULT_AT_TIMEOUT) {
        return true;
    }
    return false;
}


public void performAction () {
    Date date = ArchivePrefs.getDate ();
    String path = ArchivePrefs.getPath ();
    boolean doneProjectsOnly = ArchivePrefs.isDoneProjectsOnly ();
    Frame frame = WindowManager.getDefault ().getMainWindow ();
    ArchiveDialog dialog = new ArchiveDialog (frame, true, date, path, doneProjectsOnly);
    dialog.setVisible (true);
    if (! dialog.archive) {
        LOG.fine ("User did not select archive");
        return;
    }
    StatusDisplayer.getDefault ().setStatusText (NbBundle.getMessage (ArchiveAction.class, "archiving"));
    archiveDate = DateUtils.getEnd (dialog.getArchiveDate ());
    String archivePath = dialog.getArchivePath ();
    doneProjectsOnly = dialog.isDoneProjectsOnly ();
    DataStore datastore = (DataStore) DataStoreLookup.instance ().lookup (DataStore.class);
    if (datastore == null) {
        LOG.severe ("Data store could not be obtained.");
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    File dataFile = new File (datastore.getPath ());
    if (! dataFile.isFile ()) {
        LOG.severe ("Data file path error.");
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    File archiveFolder = (archivePath == null || archivePath.equals ("")) ? dataFile.getParentFile () : new File (archivePath);
    if (! archiveFolder.isDirectory ()) {
        LOG.severe ("Archive directory error.");
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    String filename = UtilsFile.removeExtension (dataFile.getName ());
    String extension = UtilsFile.getExtension (dataFile.getName ());
    Date currentDate = Calendar.getInstance ().getTime ();
    String currentDateStamp = DATESTAMP.format (currentDate);
    String currentTimeStamp = TIMESTAMP.format (currentDate);
    File backupFile = new File (archiveFolder, filename + "-" + currentDateStamp + "-" + currentTimeStamp + ".backup." + extension);
    try {
        UtilsFile.copyFile (dataFile, backupFile);
    } catch (Exception ex) {
        LOG.severe ("Error creating archive backup of datafile. " + ex.getMessage ());
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    String archiveDateStamp = DATESTAMP.format (archiveDate);
    File archiveFile = new File (archiveFolder, filename + "-" + archiveDateStamp + "-" + currentTimeStamp + ".archive." + extension);
    try {
        UtilsFile.copyFile (dataFile, archiveFile);
    } catch (Exception ex) {
        LOG.severe ("Error creating archive copy of datafile. " + ex.getMessage ());
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    archiveSingleActions = new Vector < Action > ();
    archiveActions = new Vector < Action > ();
    archiveProjects = new Vector < Project > ();
    Data archiveData = null;
    try {
        archiveData = XStreamWrapper.instance ().load (archiveFile);
    } catch (Exception ex) {
        LOG.severe ("Error loading data from archive file. " + ex.getMessage ());
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    for (Action action : archiveData.getRootActions ().getChildren (Action.class)) {
        if (action.isDone () && action.getDoneDate ().before (archiveDate)) {
            archiveSingleActions.add (action);
        }
        else {
            LOG.fine ("Removing from archive - action: " + action.getDescription ());
            action.removeFromParent ();
        }
    }
    if (doneProjectsOnly) {
        for (Project project : archiveData.getRootProjects ().getChildren (Project.class)) {
            if (project.isDone () && project.getDoneDate ().before (archiveDate)) {
                archiveProjects.add (project);
            }
            else {
                LOG.fine ("Removing from archive - project: " + project.getDescription ());
                project.removeFromParent ();
            }
        }
    }
    else {
        for (Project project : archiveData.getRootProjects ().getChildren (Project.class)) {
            keepArchived (project);
        }
    }
    Manager < Thought > archiveThoughtManager = archiveData.getThoughtManager ();
    for (Thought thought : archiveThoughtManager.list ()) {
        if (! thought.isProcessed ()) {
            archiveThoughtManager.remove (thought);
        }
    }
    for (Iterator < Project > i = archiveData.getRootFutures ().iterator (Project.class); i.hasNext ();) {
        i.next ().removeFromParent ();
    }
    for (Iterator < Project > i = archiveData.getRootTemplates ().iterator (Project.class); i.hasNext ();) {
        i.next ().removeFromParent ();
    }
    archiveData.getFutureManager ().removeAll ();
    archiveData.getInformationManager ().removeAll ();
    RecurrenceRemover.removeAll (archiveData);
    try {
        XStreamWrapper.instance ().store (archiveData, archiveFile);
    } catch (Exception ex) {
        LOG.severe ("Error storing archive. " + ex.getMessage ());
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    Data data = (Data) DataLookup.instance ().lookup (Data.class);
    if (data == null) {
        LOG.severe ("Data could not be obtained.");
        StatusDisplayer.getDefault ().setStatusText ("");
        return;
    }
    Project singleActions = data.getRootActions ();
    for (Action a : archiveSingleActions) {
        LOG.fine ("Removing from data - single action: " + a.getDescription ());
        singleActions.remove (a);
    }
    Map < Integer, Project > dataProjectsMap = createProjectsMap (data);
    for (Action archiveAction : archiveActions) {
        LOG.fine ("Removing from data file - archived action: " + archiveAction.getDescription ());
        Project dataParent = dataProjectsMap.get (archiveAction.getParent ().getID ());
        if (dataParent != null) {
            if (! dataParent.remove (archiveAction)) {
                LOG.severe ("Archived action could not be removed from data file.");
            }
        }
        else {
            LOG.severe ("Could not find parent project in data file for archived action.");
        }
    }
    for (Project archiveProject : archiveProjects) {
        LOG.fine ("Removing from data file - archived project: " + archiveProject.getDescription ());
        Project dataParent = dataProjectsMap.get (archiveProject.getParent ().getID ());
        if (dataParent != null) {
            if (! dataParent.remove (archiveProject)) {
                LOG.severe ("Archived project could not be removed from data file.");
            }
        }
        else {
            LOG.severe ("Could not find parent project in data file for archived project.");
        }
    }
    saveData (datastore);
    ArchivePrefs.setDate (archiveDate);
    ArchivePrefs.setPath (archivePath);
    ArchivePrefs.setDoneProjectsOnly (doneProjectsOnly);
    StatusDisplayer.getDefault ().setStatusText ("");
    String t = Constants.TITLE + " " + NbBundle.getMessage (getClass (), "CTL_ArchiveAction");
    String COMPLETED = NbBundle.getMessage (getClass (), "archive.completed");
    String ARCHIVE_DATE = NbBundle.getMessage (getClass (), "archive.date");
    String BACKUP_FILE = NbBundle.getMessage (getClass (), "backup.file");
    String ARCHIVE_FILE = NbBundle.getMessage (getClass (), "archive.file");
    String SINGLE_ACTIONS = NbBundle.getMessage (getClass (), "single.actions");
    String PROJECTS = NbBundle.getMessage (getClass (), "projects");
    String PROJECT_ACTIONS = NbBundle.getMessage (getClass (), "project.actions");
    String m = COMPLETED + ". \n\n" + ARCHIVE_DATE + ": " + archiveDate + "\n\n" + BACKUP_FILE + ": " + backupFile.getPath () + "\n" + ARCHIVE_FILE + ": " + archiveFile.getPath () + "\n\n";
    JOptionPane.showMessageDialog (frame, m, t, JOptionPane.INFORMATION_MESSAGE);
}


-----Function Pair=82=-----==

private void upLoad (DocumentCBF doc, String [] items, String uploadType) throws Exception {
    CesGlobals cesGlobals = new CesGlobals ();
    String uploadPath;
    cesGlobals.setConfigFile ("platform.xml");
    uploadPath = cesGlobals.getCesXmlProperty ("platform.datadir");
    uploadPath = new File (uploadPath).getPath ();
    if (uploadPath.endsWith ("\\")) {
        uploadPath = uploadPath.substring (0, uploadPath.length () - 1);
    }
    uploadPath = uploadPath + "/infoplat/workflow/docs/" + Function.getNYofDate (doc.getCreateDate ()) + "/res/";
    if (! new File (uploadPath).isDirectory ()) {
        new File (uploadPath).mkdirs ();
    }
    try {
        String orgFileName = "", newFileName = "";
        long fileSize;
        File ff, f;
        MD5 strMD5 = new MD5 ();
        for (int i = 0; i < items.length; i ++) {
            ff = new File (items [i]);
            if (ff.isFile ()) {
                orgFileName = ff.getName ();
                fileSize = ff.length ();
                if (fileSize != 0 && orgFileName != null) {
                    newFileName = "t" + strMD5.getMD5ofStr (orgFileName + fileSize + (new Random ()).nextInt ()) + "." + orgFileName.substring (orgFileName.lastIndexOf (".") + 1);
                    FileOperation.copy (items [i], uploadPath + newFileName);
                    f = new File (uploadPath + newFileName);
                    String breviaryImageFileName = "min" + f.getName ();
                    if (DocResource.PICTURE_TYPE.equals (uploadType)) {
                        ConfigInfo ci = ConfigInfo.getInstance ();
                        ImgHandle imgHandle = new ImgHandle ();
                        try {
                            imgHandle.zoom (f.getPath (), f.getParent () + File.separator + breviaryImageFileName, ci.getImageMinHeight (), ci.getImageMinWidth ());
                        } catch (Exception ex1) {
                            breviaryImageFileName = "";
                        }
                    }
                    DocResource dr = null;
                    if (DocResource.AFFIX_TYPE.equals (uploadType)) {
                        dr = new DocAffix ();
                    }
                    else if (DocResource.PICTURE_TYPE.equals (uploadType)) {
                        dr = new DocPicture ();
                    }
                    dr.setId ((int) IdGenerator.getInstance ().getId (IdGenerator.GEN_ID_IP_DOC_RES));
                    dr.setAutoPlay (false);
                    dr.setCreateDate (Function.getSysTime ());
                    dr.setCreater (1);
                    dr.setDocId (doc.getId ());
                    dr.setFileExt (newFileName.substring (newFileName.lastIndexOf (".") + 1));
                    dr.setFileSize (Function.byteToKB (fileSize));
                    dr.setOrderNo (Integer.parseInt (new ces.platform.infoplat.ui.common.defaultvalue.OrderNo ().getDefaultValue ()));
                    dr.setOriginalFile (orgFileName);
                    dr.setType (uploadType);
                    dr.setUri (newFileName);
                    dr.add ();
                    if (DocResource.PICTURE_TYPE.equals (uploadType) && ! breviaryImageFileName.equals ("")) {
                        dr.setId ((int) IdGenerator.getInstance ().getId (IdGenerator.GEN_ID_IP_DOC_RES));
                        dr.setCreateDate (Function.getSysTime ());
                        dr.setFileSize (Function.byteToKB (fileSize));
                        dr.setOrderNo (Integer.parseInt (new ces.platform.infoplat.ui.common.defaultvalue.OrderNo ().getDefaultValue ()));
                        dr.setOriginalFile ("(ÔøΩÔøΩÔøΩÔøΩÕº)" + orgFileName);
                        dr.setUri (breviaryImageFileName);
                        dr.add ();
                    }
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
}


protected void removeFiles (File d, String [] files, String [] dirs) {
    if (files.length > 0) {
        log ("Deleting " + files.length + " files from " + d.getAbsolutePath (), quiet ? Project.MSG_VERBOSE : verbosity);
        for (int j = 0; j < files.length; j ++) {
            File f = new File (d, files [j]);
            log ("Deleting " + f.getAbsolutePath (), quiet ? Project.MSG_VERBOSE : verbosity);
            if (! delete (f)) {
                handle ("Unable to delete file " + f.getAbsolutePath ());
            }
        }
    }
    if (dirs.length > 0 && includeEmpty) {
        int dirCount = 0;
        for (int j = dirs.length - 1; j >= 0; j --) {
            File currDir = new File (d, dirs [j]);
            String [] dirFiles = currDir.list ();
            if (dirFiles == null || dirFiles.length == 0) {
                log ("Deleting " + currDir.getAbsolutePath (), quiet ? Project.MSG_VERBOSE : verbosity);
                if (! delete (currDir)) {
                    handle ("Unable to delete directory " + currDir.getAbsolutePath ());
                }
                else {
                    dirCount ++;
                }
            }
        }
        if (dirCount > 0) {
            log ("Deleted " + dirCount + " director" + (dirCount == 1 ? "y" : "ies") + " form " + d.getAbsolutePath (), quiet ? Project.MSG_VERBOSE : verbosity);
        }
    }
}


-----Function Pair=83=-----==

public static Object copy (final Object orig) {
    Object obj = null;
    try {
        final CoreTooling.FastByteArrayOutputStream fbos = new CoreTooling.FastByteArrayOutputStream ();
        final ObjectOutputStream out = new ObjectOutputStream (fbos);
        out.writeObject (orig);
        out.flush ();
        out.close ();
        final ObjectInputStream in = new ObjectInputStream (fbos.getInputStream ());
        obj = in.readObject ();
    } catch (final IOException e) {
        e.printStackTrace ();
    } catch (final ClassNotFoundException cnfe) {
        cnfe.printStackTrace ();
    }
    return obj;
}


public void load (Document doc, Element ele) throws IOException {
    XMLUtil.checkType (projects_document, ele, this);
    map_files = new FileResourceVector ();
    map_id_vec = new Vector ();
    translate_name_vec = new Vector ();
    for (int i = 0; i < ele.getElementsByTagName ("Map").getLength (); i ++) {
        Element map_element = (Element) ele.getElementsByTagName ("Map").item (i);
        FileResource resource = new FileResource (projects_document, map_element, configuration.getLanguageCode ());
        resource.setHome (map_element.getAttribute ("home"));
        if (resource.getHome () == null || resource.getHome ().length () == 0) {
            resource.setHome (maps_resource.getHome ());
        }
        map_files.addElement (resource);
        if (resource.getExtentCode () != null && ! resource.getExtentCode ().equals ("")) {
            map_id_vec.addElement (resource.getExtentCode ());
        }
        else {
            map_id_vec.addElement (map_element.getAttribute ("name"));
        }
        try {
            Element label_element = XMLUtil.getChild (doc, map_element, "Label");
            String default_name = resource.getName ();
            if (label_element != null) {
                translate_name = new Translate (default_name, label_element);
            }
            else {
                translate_name = new Translate (default_name);
                translate_name.addLabel (configuration.getDefaultLanguageCode (), default_name);
            }
            translate_name_vec.addElement (translate_name);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    try {
        selected_map_index = Integer.parseInt (ele.getAttribute ("selected_map_index"));
    } catch (Exception e) {
        System.out.println ("MapContext.load(doc, ele) selected_map_index not found!");
        selected_map_index = - 1;
    }
    modified = false;
}


-----Function Pair=84=-----==

private void listRelativeFolderPaths (String rootPath) {
    File rootFolder = new File (rootPath);
    if (rootFolder.exists () == false) return;
    if (rootFolder.isDirectory () == false) return;
    List < File > subFolders = listSubFolders (rootPath);
    if (subFolders == null) return;
    for (int i = 0; i < subFolders.size (); i ++) {
        File subFolder = subFolders.get (i);
        List < File > tempSubFolders = listSubFolders (subFolder);
        if (tempSubFolders != null) subFolders.addAll (tempSubFolders);
        String relPath = getRelativePath (subFolder.getAbsolutePath (), rootPath);
        Folders.add (relPath);
    }
    subFolders = null;
    Collections.sort (Folders);
}


public DiffStatus getDiffStatus (String path) {
    String workDir = new File (configuration.getWorkCopyDir ()).getPath ();
    File filePath = new File (configuration.getWorkCopyDir () + path);
    DiffStatus ds = new DiffStatus ();
    try {
        ISVNStatus [] status = svnClient.getStatus (filePath, true, false);
        for (ISVNStatus state : status) {
            if (SVNStatusKind.UNVERSIONED == state.getTextStatus ()) {
                addFile (ds, state.getFile (), workDir);
            }
            else if (SVNStatusKind.DELETED == state.getTextStatus () || SVNStatusKind.MISSING == state.getTextStatus ()) {
                Element e = ds.new Element (state.getFile ().getPath ().replace (workDir, "").replaceAll ("\\\\", "/"), Actions.DELETE);
                ds.addElement (e);
            }
            else if (SVNStatusKind.MODIFIED == state.getTextStatus ()) {
                Element e = ds.new Element (state.getFile ().getPath ().replace (workDir, "").replaceAll ("\\\\", "/"), Actions.MODIFY);
                ds.addElement (e);
            }
        }
    } catch (SVNClientException e) {
        logger.error ("The SVNClientException!", e);
    }
    return ds;
}


-----Function Pair=85=-----==

public static String readResource (String resourcePath, Class classpath) {
    int c;
    InputStream is = classpath.getResourceAsStream (resourcePath);
    StringBuffer buf = new StringBuffer ();
    if (null != is) {
        try {
            while ((c = is.read ()) != - 1) {
                buf.append ((char) c);
            }
        } catch (IOException e) {
            logger.severe ("Unable to load resource path (" + resourcePath + "): " + e.getMessage ());
        } finally {
            if (null != is) {
                try {
                    is.close ();
                } catch (IOException e) {
                    logger.warning ("Unable to properly close the resource path (" + resourcePath + "): " + e.getMessage ());
                }
            }
        }
    }
    else {
        logger.severe ("Unable to locate resource at path " + resourcePath);
    }
    return buf.toString ();
}


public File createScript (String command, String dirName, Map < String, String > envVars) throws ExecutorException {
    File dir = new File (dirName);
    File commandFile = null;
    boolean isScript = false;
    if (dirName == null) {
        dirName = ".";
    }
    else if (! dirName.equals (".") && ! dir.isDirectory ()) {
        throw new ExecutorException (command, new FileNotFoundException (dir.getAbsolutePath ()));
    }
    try {
        commandFile = new File (dir, command);
        if (commandFile.exists () && commandFile.canRead ()) {
            FileInputStream commandFIS = new FileInputStream (commandFile);
            DataInputStream commandDIS = new DataInputStream (commandFIS);
            if (commandDIS.readChar () == '#' && commandDIS.readChar () == '!') {
                isScript = true;
            }
            commandFIS.close ();
            commandDIS.close ();
        }
    } catch (FileNotFoundException e) {
        throw new ExecutorException (command, new FileNotFoundException (commandFile.getAbsolutePath ()));
    } catch (IOException e) {
        throw new ExecutorException (command, e);
    }
    File temp;
    BufferedWriter writerTemp;
    String exportCommand = "export ";
    try {
        temp = TempFileManager.createTempFile ("broker", ".tmp", dir);
        writerTemp = new BufferedWriter (new FileWriter (temp));
        if (envVars != null) {
            if (! envVars.isEmpty ()) {
                for (String key : envVars.keySet ()) {
                    writerTemp.write (key + "=\'" + envVars.get (key) + "\'");
                    writerTemp.newLine ();
                    exportCommand = exportCommand + " " + key;
                }
            }
        }
        writerTemp.write ("PATH=$PATH:$PLAYPEN:$STORAGE:.");
        writerTemp.newLine ();
        exportCommand = exportCommand + " PATH";
        writerTemp.write (exportCommand);
        writerTemp.newLine ();
        if (isScript) {
            writerTemp.write ("sh ");
        }
        writerTemp.write (command);
        writerTemp.newLine ();
        writerTemp.flush ();
        writerTemp.close ();
        return temp;
    } catch (IOException ioe) {
        throw new ExecutorException (ioe);
    }
}


-----Function Pair=86=-----==

public String parseRequest (HttpServletRequest request, SSOSubject authenticated) throws FileUploadException {
    try {
        RequestContext ctx = new ServletRequestContext (request);
        FileItemIterator iter = fileUpload.getItemIterator (ctx);
        String filenames = "";
        String [] overrideFilenames = request.getParameterValues ("overrideFilenames");
        String overrideFilename;
        int i = 0;
        while (iter.hasNext ()) {
            FileItemStream item = iter.next ();
            LOG.finest ("The filename from the browser is: " + item.getName ());
            if (overrideFilenames == null || overrideFilenames.length >= i || overrideFilenames [i] == null) {
                overrideFilename = item.getName ();
            }
            else {
                overrideFilename = overrideFilenames [i];
            }
            ++ i;
            LOG.finest ("Using filename: " + overrideFilename);
            if (overrideFilename.trim ().length () > 0) {
                FileItem fileItem = fileFactory.createItem (item.getFieldName (), item.getContentType (), item.isFormField (), overrideFilename, authenticated.getScreenName ());
                LOG.finest ("Writing to file: " + ((GEDCOMFileItem) fileItem).getFullPath ());
                try {
                    Streams.copy (item.openStream (), fileItem.getOutputStream (), true);
                } catch (IOException e) {
                    throw new IOException ("Processing of " + FileUploadBase.MULTIPART_FORM_DATA + " request failed. " + e.getMessage ());
                }
                if (fileItem.getSize () <= 0) {
                    fileItem.delete ();
                }
                else {
                    if (fileItem instanceof FileItemHeadersSupport) {
                        final FileItemHeaders fih = item.getHeaders ();
                        ((FileItemHeadersSupport) fileItem).setHeaders (fih);
                    }
                    filenames += fileItem.getName () + ", ";
                }
            }
        }
        return (filenames.length () > 0 ? filenames.substring (0, filenames.length () - 2) : filenames);
    } catch (IOException e) {
        throw new FileUploadException (e.getMessage (), e);
    }
}


public static final Collection < Map.Entry < File, File > > dirSync (final PrintStream out, final Collection < Map.Entry < File, File > > org, final File srcFolder, final File dstFolder) throws IOException {
    if ((null == srcFolder) || (null == dstFolder)) return org;
    if ((! srcFolder.exists ()) || (! srcFolder.isDirectory ())) return org;
    final String [] srcFiles = srcFolder.list ();
    if ((null == srcFiles) || (srcFiles.length <= 0)) return org;
    if (! dstFolder.exists ()) {
        if (! dstFolder.mkdirs ()) throw new IOException ("Cannot create destination folder=" + dstFolder);
        out.println ("Created " + dstFolder);
    }
    else if (! dstFolder.isDirectory ()) throw new IOException ("Destination is not a folder: " + dstFolder);
    Collection < Map.Entry < File, File > > ret = org;
    for (final String sName : srcFiles) {
        final File sFile = new File (srcFolder, sName), dFile = new File (dstFolder, sName);
        if (sFile.isDirectory ()) {
            ret = dirSync (out, ret, sFile, dFile);
            continue;
        }
        if (sFile.length () <= 0L) {
            out.println ("Skip empty file " + sFile);
            if (dFile.exists ()) {
                if (dFile.delete ()) out.println ("\tDeleted " + dFile);
                else System.err.println ("Failed to delete " + dFile);
            }
            continue;
        }
        if (dFile.exists ()) {
            final long sMod = sFile.lastModified (), dMod = dFile.lastModified (), mDiff = sMod - dMod;
            if (mDiff <= TimeUnits.MINUTE.getMilisecondValue ()) {
                if (mDiff != 0L) {
                    final String sDate = DTF.format (new Date (sMod)), dDate = DTF.format (new Date (dMod));
                    out.println ("\tSkip more recent file " + dFile + " (" + sDate + " vs. " + dDate + ")");
                }
                continue;
            }
            final long sLen = sFile.length (), dLen = dFile.length ();
            if (sLen == dLen) {
                out.println ("\tSkip equal size file " + dFile);
                continue;
            }
        }
        else out.println ("\tCopy new file " + dFile);
        out.print ("Copy " + sFile + " => " + dFile);
        final long cpyStart = System.currentTimeMillis (), cpyLen = IOCopier.copyFile (sFile, dFile), cpyEnd = System.currentTimeMillis (), cpyDuration = cpyEnd - cpyStart;
        if (cpyLen < 0L) throw new StreamCorruptedException ("Error (" + cpyLen + ") after " + cpyDuration + " msrc. while copying " + sFile + " to " + dFile);
        out.println (" - " + cpyLen + " bytes in " + cpyDuration + " msrc.");
        if (null == ret) ret = new LinkedList < Map.Entry < File, File > > ();
        ret.add (new MapEntryImpl < File, File > (sFile, dFile));
    }
    final String [] dstFiles = dstFolder.list ();
    if ((null == dstFiles) || (dstFiles.length <= 0)) return ret;
    final Collection < String > srcSet = new HashSet < String > (Arrays.asList (srcFiles));
    for (final String d : dstFiles) {
        if (srcSet.contains (d)) continue;
        final File dFile = new File (dstFolder, d);
        if (dFile.delete ()) out.println ("\tDeleted " + dFile);
        else System.err.println ("Failed to delete " + dFile);
    }
    return ret;
}


-----Function Pair=87=-----==

public void mouseClicked (final MouseEvent e) {
    int index = fileList.locationToIndex (e.getPoint ());
    fileList.setSelectedIndex (index);
    setControls (true);
    try {
        selected = (DFSFileInfo) fileList.getSelectedValue ();
        if (e.getClickCount () == 2) {
            if (selected.isDirectory ()) {
                open (new DFSFile ("JFS", selected.getPath ()));
            }
            else {
                FileDownloadTask task = new FileDownloadTask (explorer, current, selected, MAX_RW_LENGTH);
                task.start ();
            }
        }
    } catch (DFSException ex) {
        logger.debug (ex);
    }
}


private void getContents (final DFSFile curr) {
    try {
        DFSFileInfo [] fileInfoArray = curr.listFilesInfo ();
        if (fileInfoArray != null) {
            List currentContents = Arrays.asList (fileInfoArray);
            ArrayList directories = new ArrayList (currentContents.size ());
            ArrayList files = new ArrayList (currentContents.size ());
            for (int i = 0; i < currentContents.size (); i ++) {
                DFSFileInfo transfer = (DFSFileInfo) currentContents.get (i);
                if (transfer.isDirectory ()) {
                    directories.add (transfer);
                }
                else {
                    files.add (transfer);
                }
            }
            names = new ArrayList (directories);
            for (int i = 0; i < files.size (); i ++) {
                names.add (files.get (i));
            }
        }
        else {
            logger.error ("Unexpected error while listing files");
            checkDssAvailable ();
        }
    } catch (DFSException ex) {
        logger.debug (ex);
        checkDssAvailable ();
    }
}


-----Function Pair=88=-----==

public static void initConfigDB (File db) {
    if (conn != null) return;
    logger.info ("Starting ConfigDB in " + framework + " mode.");
    try {
        Class.forName (driver).newInstance ();
        logger.fine ("Loaded the appropriate driver.");
        String path = null;
        path = db.getCanonicalPath ();
        path = path.replaceAll ("/jar:", "jar:");
        conn = DriverManager.getConnection (protocol + path + ";create=true", props);
        conn.setAutoCommit (false);
        Statement s = conn.createStatement ();
        ResultSet rs = s.executeQuery ("SELECT * FROM SYS.SYSTABLES WHERE TABLETYPE='T'");
        if (! rs.next ()) {
            logger.warning ("No user tables found, creating development schema and data.");
            createTables ();
            insertTempData ();
        }
        else {
            rs = s.executeQuery ("SELECT INTEGER (Value) as version FROM MetaData WHERE Name='DBVERSION'");
            rs.next ();
            if (rs.getInt (1) != currentDBVersion) {
                logger.severe ("This configDB version (" + rs.getInt (1) + ") is not equal to software version " + currentDBVersion + ".  \n" + "You probably need to delete your existing DB (" + db.getPath () + ") and allow a new one to be generated.");
            }
        }
        s.close ();
    } catch (Exception e) {
        logger.log (Level.WARNING, "Error connecting ConfigDB: ", e);
        e.printStackTrace ();
    }
}


public void startReading () {
    StringBuilder sb = new StringBuilder ();
    sb.append (" Started DiskReaderTasks for the following partions [ ");
    int idx = 0;
    if (logger.isLoggable (Level.FINEST)) {
        logger.log (Level.FINEST, " partitionsMap is: " + partitionsMap);
    }
    for (Iterator < Map.Entry < Integer, LinkedList < FileSession > > > it = partitionsMap.entrySet ().iterator (); it.hasNext ();) {
        Map.Entry < Integer, LinkedList < FileSession > > entry = it.next ();
        final int partitionID = entry.getKey ();
        LinkedList < FileSession > files = entry.getValue ();
        int realReadersCount = (readersCount < files.size ()) ? readersCount : files.size ();
        ArrayList < DiskReaderTask > readersTasks = new ArrayList < DiskReaderTask > (realReadersCount);
        ArrayList < LinkedList < FileSession > > fileSessionsReaders = new ArrayList < LinkedList < FileSession > > (realReadersCount);
        if (logger.isLoggable (Level.FINE)) {
            logger.log (Level.FINE, " realReadersCount = " + realReadersCount + " for partitionID: " + partitionID);
        }
        if (realReadersCount > 1) {
            FileSession [] filesArray = files.toArray (new FileSession [files.size ()]);
            Arrays.sort (filesArray, new Comparator < FileSession > () {
                public int compare (FileSession fileSession1, FileSession fileSession2) {
                    if (fileSession1.file.equals (fileSession2.file)) {
                        return fileSession1.sessionID.compareTo (fileSession2.sessionID);
                    }
                    if (fileSession1.sessionSize < fileSession2.sessionSize) {
                        return - 1;
                    }
                    return 1;
                }
            }
            );
            if (logger.isLoggable (Level.FINER)) {
                logger.log (Level.FINER, "Sorted FileSession-s array: " + Arrays.toString (filesArray));
            }
            int ci = 0;
            for (FileSession fs : filesArray) {
                LinkedList < FileSession > fsessions = (ci >= fileSessionsReaders.size ()) ? null : fileSessionsReaders.get (ci);
                if (fsessions == null) {
                    fsessions = new LinkedList < FileSession > ();
                    fileSessionsReaders.add (fsessions);
                }
                fsessions.add (fs);
                if (logger.isLoggable (Level.FINEST)) {
                    logger.log (Level.FINEST, " Added FileSession: " + fs + " for DiskReaderTask idx =  " + ci);
                }
                ci = (ci + 1) % realReadersCount;
            }
        }
        else {
            fileSessionsReaders.add (files);
        }
        execService = Utils.getStandardExecService ("DiskReaderTask for " + toString (), partitionsMap.size (), partitionsMap.size () * realReadersCount + 5, Thread.NORM_PRIORITY);
        for (int i = 0; i < realReadersCount; i ++) {
            final DiskReaderTask drTask = new DiskReaderTask (partitionID, idx ++, fileSessionsReaders.get (i), this);
            readersTasks.add (drTask);
            execService.submit (drTask);
        }
        if (logger.isLoggable (Level.FINER)) {
            logger.log (Level.FINER, " ReadersTasks for partitionID: " + partitionID + ": " + readersTasks);
        }
        readersMap.put (partitionID, readersTasks);
        sb.append (partitionID).append (" ");
    }
    sb.append ("] for FDTSession: ").append (sessionID);
    logger.log (Level.INFO, sb.toString ());
}


-----Function Pair=89=-----==

public boolean equals (Object obj) {
    if (obj == null) {
        return false;
    }
    if (getClass () != obj.getClass ()) {
        return false;
    }
    final ReportSAXParser.Style other = (ReportSAXParser.Style) obj;
    if (this.iBorder != other.iBorder) {
        return false;
    }
    if (this.iFontSize != other.iFontSize) {
        return false;
    }
    if (this.iWrap != other.iWrap) {
        return false;
    }
    if (this.sFont == null || ! this.sFont.equals (other.sFont)) {
        return false;
    }
    if (this.color != other.color) {
        return false;
    }
    if (this.dataFormat != other.dataFormat) {
        return false;
    }
    return true;
}


public static IRegion getValueRegion (int offset, int length, String value, IDocument document, RGB reginRGB) throws BadLocationException {
    XMLTagScanner scanner = getXMLTagScanner ();
    IToken token = null;
    scanner.setRange (document, offset, length);
    while ((token = scanner.nextToken ()) != Token.EOF) {
        if (token.getData () instanceof TextAttribute) {
            TextAttribute text = (TextAttribute) token.getData ();
            int tokenOffset = scanner.getTokenOffset ();
            int tokenLength = scanner.getTokenLength ();
            if (text.getForeground ().getRGB ().equals (reginRGB) && value.equals (document.get (tokenOffset + 1, tokenLength - 2))) {
                return new Region (tokenOffset, tokenLength);
            }
        }
    }
    return null;
}


-----Function Pair=90=-----==

public boolean isYear (final String year) {
    boolean check = false;
    if (isExactLength (year, 4) && org.apache.commons.lang.StringUtils.isNumeric (year)) {
        final Pattern pat = Pattern.compile ("13[0-9]{2}|14[0-9]{2}|15[0-9]{2}|16[0-9]{2}|17[0-9]{2}|18[0-9]{2}|19[0-9]{2}|20[0-9]{2}|21[0-9]{2}");
        final Matcher match = pat.matcher (year);
        try {
            if (match.find ()) {
                check = true;
            }
        } catch (final Exception e) {
            LOG.error ("isYear(String year): " + year + "\040" + e.toString ());
        }
    }
    return check;
}


private void syncWithTable () {
    removeAnonymizationHighlights ();
    Iterator < String > iterator;
    String word;
    int rowCount = tableToAddWords.getRowCount ();
    Set keySet = regexs.keySet ();
    for (int row = 0; row < rowCount; row ++) {
        word = (String) tableToAddWords.getValueAt (row, 0);
        if (word != null) {
            iterator = keySet.iterator ();
            while (iterator.hasNext ()) {
                highlightWordToBeAnonymized (iterator.next ().replace ("%t", word));
            }
        }
    }
}


-----Function Pair=91=-----==

public void writeProperties (String file, Properties props) throws Exception {
    BufferedOutputStream out = null;
    try {
        out = new BufferedOutputStream (new FileOutputStream (file));
        props.store (out, "Properties file generated by Smart-Tail. ");
        out.close ();
        out = null;
    } catch (Exception e) {
        logger.log (Level.WARNING, "Failed to write properties to file: " + file, e);
        throw e;
    } finally {
        if (out != null) {
            try {
                out.close ();
            } catch (Exception e1) {
            }
        }
    }
}


private void updateFeaturesBox () {
    List < String > features = new ArrayList < String > ();
    Set < String > featuresToAdd = populatedAnnotationTypesAndFeatures.get ((String) annotTypesBox.getSelectedItem ());
    if (featuresToAdd != null) {
        features.addAll (featuresToAdd);
    }
    Collections.sort (features);
    featuresBox.setActionCommand ("not a user input");
    featuresBox.removeAllItems ();
    for (String aFeat : features) {
        featuresBox.addItem (aFeat);
    }
    featuresBox.updateUI ();
    featuresBox.setActionCommand ("");
}


-----Function Pair=92=-----==

private void initNoteScreen () {
    mNoteEditor.setTextAppearance (this, TextAppearanceResources.getTexAppearanceResource (mFontSizeId));
    if (mWorkingNote.getCheckListMode () == TextNote.MODE_CHECK_LIST) {
        switchToListMode (mWorkingNote.getContent ());
    }
    else {
        mNoteEditor.setText (getHighlightQueryResult (mWorkingNote.getContent (), mUserQuery));
        mNoteEditor.setSelection (mNoteEditor.getText ().length ());
    }
    for (Integer id : sBgSelectorSelectionMap.keySet ()) {
        findViewById (sBgSelectorSelectionMap.get (id)).setVisibility (View.GONE);
    }
    mHeadViewPanel.setBackgroundResource (mWorkingNote.getTitleBgResId ());
    mNoteEditorPanel.setBackgroundResource (mWorkingNote.getBgColorResId ());
    mNoteHeaderHolder.tvModified.setText (DateUtils.formatDateTime (this, mWorkingNote.getModifiedDate (), DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_NUMERIC_DATE | DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_SHOW_YEAR));
    showAlertHeader ();
}


public boolean matchStrings () {
    Matcher matcher = pattern.matcher (str);
    if (matcher.matches ()) {
        if (uriTemplateVariables != null) {
            for (int i = 1; i <= matcher.groupCount (); i ++) {
                String name = this.variableNames.get (i - 1);
                String value = matcher.group (i);
                uriTemplateVariables.put (name, value);
            }
        }
        return true;
    }
    else {
        return false;
    }
}


-----Function Pair=93=-----==

public static String [] extractToArray (String a_src, String a_findPattern, boolean a_returnGroup0) {
    Pattern l_pattern = Pattern.compile (a_findPattern);
    Matcher l_matcher = l_pattern.matcher (a_src);
    int l_groupCount = l_matcher.groupCount ();
    int l_indexStart;
    if (a_returnGroup0) {
        l_indexStart = 0;
    }
    else {
        l_indexStart = 1;
    }
    Collection retour = new ArrayList ();
    while (l_matcher.find ()) {
        for (int i = l_indexStart; i < l_groupCount + 1; i ++) {
            retour.add (l_matcher.group (i));
        }
    }
    return (String []) retour.toArray (new String [retour.size ()]);
}


protected DataConnections getDataConnections (Element dataConnectionsElem) {
    if (dataConnectionsElem != null && dataConnectionsElem.getName ().equals ("DataConnections")) {
        List content = dataConnectionsElem.getChildren ();
        int size = content.size ();
        if (size > 0) {
            Hashtable < String, Connection > hashTable = new Hashtable < String, Connection > (size);
            Iterator iterator = content.iterator ();
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Connection connection = getConnection (currentElement);
                hashTable.put (connection.getSource () + connection.getDestination (), connection);
            }
            DataConnections dataConnections = new DataConnections (hashTable);
            return dataConnections;
        }
        else {
            System.err.println ("Invalid child element size in getDataConnections()");
            if (this.console != null) {
                console.setText ("Invalid child element size in getDataConnections()");
            }
            return null;
        }
    }
    else {
        System.err.println ("Invalid element input in getDataConnections()");
        if (this.console != null) {
            console.setText ("Invalid element input in getDataConnections()");
        }
        return null;
    }
}


-----Function Pair=94=-----==

private boolean tell () {
    if (editMessage.subType.equalsIgnoreCase ("tell") || editMessage.subType.equalsIgnoreCase ("t") || editMessage.subType.equalsIgnoreCase ("pm") || editMessage.subType.equalsIgnoreCase ("msg") || editMessage.subType.equalsIgnoreCase ("message") || editMessage.subType.equalsIgnoreCase ("whisper") || editMessage.subType.equalsIgnoreCase ("w") || editMessage.subType.equalsIgnoreCase ("send")) {
        if (editMessage.targetName.isEmpty ()) {
            editMessage.type = "chat";
            editMessage.subType = "systemMessage";
            editMessage.text = "No name was entered in the tell command.";
        }
        else {
            editMessage.subType = "tell";
            editMessage.type = "chat";
            editMessage.text = editMessage.message.substring (editMessage.endOfWord2);
            doMath ();
            editMessage.text = format + editMessage.text + "</span>";
        }
        return true;
    }
    return false;
}


private String doGetRegexForSimpleDateFormat (String format) throws CoreException {
    try {
        new SimpleDateFormat (format);
    } catch (Exception e) {
        throw new CoreException (new Status (IStatus.ERROR, PatternDialectPlugin.PLUGIN_ID, Messages.RegexUtils_error_invalidDateFormat));
    }
    ReplacementContext ctx = new ReplacementContext ();
    ctx.setBits (new BitSet (format.length ()));
    ctx.setBuffer (new StringBuffer (format));
    unquote (ctx);
    replace (ctx, "G+", "[ADBC]{2}");
    replace (ctx, "[y]{3,}", "\\d{4}");
    replace (ctx, "[y]{2}", "\\d{2}");
    replace (ctx, "y", "\\d{4}");
    replace (ctx, "[M]{3,}", "[a-zA-Z]*");
    replace (ctx, "[M]{2}", "\\d{2}");
    replace (ctx, "M", "\\d{1,2}");
    replace (ctx, "w+", "\\d{1,2}");
    replace (ctx, "W+", "\\d");
    replace (ctx, "D+", "\\d{1,3}");
    replace (ctx, "d+", "\\d{1,2}");
    replace (ctx, "F+", "\\d");
    replace (ctx, "E+", "[a-zA-Z]*");
    replace (ctx, "a+", "[AMPM]{2}");
    replace (ctx, "H+", "\\d{1,2}");
    replace (ctx, "k+", "\\d{1,2}");
    replace (ctx, "K+", "\\d{1,2}");
    replace (ctx, "h+", "\\d{1,2}");
    replace (ctx, "m+", "\\d{1,2}");
    replace (ctx, "s+", "\\d{1,2}");
    replace (ctx, "S+", "\\d{1,3}");
    replace (ctx, "z+", "[a-zA-Z-+:0-9]*");
    replace (ctx, "Z+", "[-+]\\d{4}");
    return ctx.getBuffer ().toString ();
}


-----Function Pair=95=-----==

protected FBVarDeclaration getVarDeclaration (Element varDeclarationElem) {
    if (varDeclarationElem != null) {
        String Name = varDeclarationElem.getAttributeValue ("Name");
        String Type = varDeclarationElem.getAttributeValue ("Type");
        String ArraySize = varDeclarationElem.getAttributeValue ("ArraySize");
        String InitialValue = varDeclarationElem.getAttributeValue ("InitialValue");
        String Comment = varDeclarationElem.getAttributeValue ("Comment");
        FBVarDeclaration varDeclaration = new FBVarDeclaration (Name, Type, ArraySize, InitialValue, Comment);
        return varDeclaration;
    }
    else {
        System.err.println ("Invalid element input in getVarDeclaration()");
        if (this.console != null) {
            console.setText ("Invalid element input in getVarDeclaration()");
        }
        return null;
    }
}


public static List < ALEipUser > getUsersFromSelectQuery (SelectQuery < TurbineUser > query) {
    List < ALEipUser > list = new ArrayList < ALEipUser > ();
    try {
        List < TurbineUser > ulist = query.orderAscending (TurbineUser.EIP_MUSER_POSITION_PROPERTY + "." + EipMUserPosition.POSITION_PROPERTY).fetchList ();
        for (TurbineUser record : ulist) {
            ALEipUser user = new ALEipUser ();
            user.initField ();
            user.setUserId (record.getUserId ().intValue ());
            user.setName (record.getLoginName ());
            user.setAliasName (record.getFirstName (), record.getLastName ());
            list.add (user);
        }
    } catch (Throwable t) {
        logger.error ("[ALEipUtils]", t);
    }
    return list;
}


-----Function Pair=96=-----==

public void mul (IMatrix b, IMatrix result) {
    if ((b == null) || (columns != b.rows)) return;
    if ((result.rows != rows) || (result.columns != b.columns)) result.reshape (rows, b.columns);
    int i, j, k;
    double realsum, imagsum;
    for (i = 0; i < rows; i ++) for (k = 0; k < b.columns; k ++) {
        realsum = 0;
        imagsum = 0;
        for (j = 0; j < columns; j ++) {
            realsum += realmatrix [i] [j] * b.realmatrix [j] [k] - imagmatrix [i] [j] * b.imagmatrix [j] [k];
            imagsum += realmatrix [i] [j] * b.imagmatrix [j] [k] + imagmatrix [i] [j] * b.realmatrix [j] [k];
        }
        result.realmatrix [i] [k] = realsum;
        result.imagmatrix [i] [k] = imagsum;
    }
}


public void paint (Graphics pGraphics) {
    Color lForegroundColor;
    int lX, lY;
    lForegroundColor = pGraphics.getColor ();
    for (lX = 0; lX < aColors.length; lX += 1) {
        for (lY = 0; lY < aColors.length; lY += 1) {
            if (aSelection [lX] [lY]) {
                pGraphics.setColor (lForegroundColor);
                pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING, BORDER_WIDTH + lY * CELL_SPACING, SELECTION_CELL_SIZE, SELECTION_CELL_SIZE);
                pGraphics.setColor (getBackground ());
                pGraphics.drawRect (BORDER_WIDTH + lX * CELL_SPACING + OUTER_CELL_OFFSET - 1, BORDER_WIDTH + lY * CELL_SPACING + OUTER_CELL_OFFSET - 1, OUTER_CELL_SIZE + 1, OUTER_CELL_SIZE + 1);
            }
            pGraphics.setColor (aColors [lX]);
            pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING + OUTER_CELL_OFFSET, BORDER_WIDTH + lY * CELL_SPACING + OUTER_CELL_OFFSET, OUTER_CELL_SIZE, OUTER_CELL_SIZE);
            pGraphics.setColor (aColors [lY]);
            pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING + INNER_CELL_OFFSET, BORDER_WIDTH + lY * CELL_SPACING + INNER_CELL_OFFSET, INNER_CELL_SIZE, INNER_CELL_SIZE);
        }
    }
}


-----Function Pair=97=-----==

public Matrix inverse () {
    if (m.length != m [0].length) {
        throw new MatrixException ("inverse of a non-square Matrix: " + m.length + "x" + m [0].length);
    }
    double d = det ();
    if (d == 0) {
        throw new MatrixException ("inverse of a singular Matrix: " + m.length + "x" + m [0].length);
    }
    Matrix matrix = new Matrix ();
    matrix.m = new double [m.length] [m.length];
    if (m.length == 1) {
        matrix.m [0] [0] = 1 / m [0] [0];
        return matrix;
    }
    else {
        for (int i = 0; i < m.length; i ++) {
            for (int j = 0; j < m [0].length; j ++) {
                matrix.m [i] [j] = cofactor (j, i);
            }
        }
        return matrix.multiply (1 / d);
    }
}


public AlignmentResultVisualizerSammonsPlotView (MainWindow _mainWin) {
    mainWin = _mainWin;
    statBar = mainWin.getStatusBar ();
    getContentPane ().setLayout (new BorderLayout ());
    bottomPnl = new PlotXAxis ();
    bottomPnl.setMinimumSize (new Dimension (getWidth (), 25));
    bottomPnl.setPreferredSize (new Dimension (getWidth (), 25));
    bottomPnl.setBackground (Color.white);
    getContentPane ().add (bottomPnl, java.awt.BorderLayout.SOUTH);
    leftPnl = new PlotYAxis ();
    leftPnl.setMinimumSize (new Dimension (100, getHeight ()));
    leftPnl.setPreferredSize (new Dimension (100, getHeight ()));
    leftPnl.setBackground (Color.white);
    getContentPane ().add (leftPnl, java.awt.BorderLayout.WEST);
    plotArea = new PlotArea (this);
    plotArea.setBackground (Color.white);
    getContentPane ().add (plotArea, java.awt.BorderLayout.CENTER);
    setResizable (true);
    setIconifiable (true);
    addInternalFrameListener (this);
}


-----Function Pair=98=-----==

public float [] [] createDistanceMatrix (float [] [] data) {
    int n = data.length;
    int m = data [0].length;
    float [] [] results = new float [m] [];
    for (int i = 0; i < m; i ++) {
        results [i] = new float [i + 1];
        for (int j = 0; j < i; j ++) {
            double score = 0;
            for (int k = 0; k < n; k ++) {
                double diff = data [k] [i] - data [k] [j];
                score += diff * diff;
            }
            results [i] [j] = (float) Math.sqrt (score);
        }
    }
    return results;
}


private Instances setOutputFormatOriginal () throws Exception {
    FastVector attributes = new FastVector ();
    for (int i = 0; i < m_numAttribs; i ++) {
        String att = m_trainInstances.attribute (i).name ();
        attributes.addElement (new Attribute (att));
    }
    if (m_hasClass) {
        attributes.addElement (m_trainHeader.classAttribute ().copy ());
    }
    Instances outputFormat = new Instances (m_trainHeader.relationName () + "->PC->original space", attributes, 0);
    if (m_hasClass) {
        outputFormat.setClassIndex (outputFormat.numAttributes () - 1);
    }
    return outputFormat;
}


-----Function Pair=99=-----==

public static double satVapPres (double t) {
    double coef [] = {6.1104546, 0.4442351, 1.4302099e-2, 2.6454708e-4, 3.0357098e-6, 2.0972268e-8, 6.0487594e-11, - 1.469687e-13};
    double escold [] = {0.648554685769663908E-01, 0.378319512256073479E-01, 0.222444934288790197E-01, 0.131828928424683120E-01, 0.787402077141244848E-02, 0.473973049488473318E-02, 0.287512035504357928E-02, 0.175743037675810294E-02, 0.108241739518850975E-02, 0.671708939185605941E-03, 0.419964702632039404E-03, 0.264524363863469876E-03, 0.167847963736813220E-03, 0.107285397631620379E-03, 0.690742634496135612E-04, 0.447940489768084267E-04, 0.292570419563937303E-04, 0.192452912634994161E-04, 0.127491372410747951E-04, 0.850507010275505138E-05, 0.571340025334971129E-05, 0.386465029673876238E-05, 0.263210971965005286E-05, 0.180491072930570428E-05, 0.124607850555816049E-05, 0.866070571346870824E-06, 0.605982217668895538E-06, 0.426821197943242768E-06, 0.302616508514379476E-06, 0.215963854234913987E-06, 0.155128954578336869E-06};
    double temp = t - 273.16;
    double retval;
    if (temp != temp) {
        retval = Double.NaN;
    }
    else if (temp > - 50.) {
        retval = (coef [0] + temp * (coef [1] + temp * (coef [2] + temp * (coef [3] + temp * (coef [4] + temp * (coef [5] + temp * (coef [6] + temp * coef [7])))))));
    }
    else {
        double tt = (- temp - 50.) / 5.;
        int inx = (int) tt;
        if (inx < escold.length) {
            retval = escold [inx] + (tt % 1.) * (escold [inx + 1] - escold [inx]);
        }
        else {
            retval = 1e-7;
        }
    }
    return retval;
}


public Matrice remplacement (final Matrice _m, final int _i0, final int _j0) {
    final int ni = _m.ni ();
    final int nj = _m.nj ();
    final Matrice r = new Matrice (ni, nj);
    for (int i = 0; i < ni; i ++) {
        for (int j = 0; j < nj; j ++) {
            r.a_ [i] [j] = a_ [i] [j];
        }
    }
    for (int i = _i0; i < _i0 + ni; i ++) {
        for (int j = _j0; j < _j0 + nj; j ++) {
            r.a_ [i] [j] = _m.a_ [i] [j];
        }
    }
    return r;
}


-----Function Pair=100=-----==

public Matrix times (Matrix B) {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


public ZMatrix product (ZMatrix m) {
    if (! productPossible (m)) {
        throw new ArithmeticException ("Unmatched matrix dimensions.");
    }
    ZMatrix product = new ZMatrix (rows, m.columns);
    for (int r = 0; r < rows; r ++) {
        for (int c = 0; c < m.columns; c ++) {
            int sum = 0;
            for (int i = 0; i < columns; i ++) {
                sum += coefficients [r] [i] * m.coefficients [i] [c];
            }
            product.coefficients [r] [c] = sum;
        }
    }
    return product;
}


-----Function Pair=101=-----==

public static void unzip1 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    if (! outputdir.exists ()) {
        outputdir.mkdirs ();
    }
    ArchiveInputStream zis = new ZipArchiveInputStream (new FileInputStream (zipfile));
    ArchiveEntry ae = zis.getNextEntry ();
    while (ae != null) {
        File newFile = new File (outputdir + File.separator + ae.getName ());
        if (! newFile.getParentFile ().exists ()) newFile.getParentFile ().mkdirs ();
        if (ae.isDirectory ()) {
            if (! newFile.exists ()) newFile.mkdir ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = zis.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
        }
        ae = zis.getNextEntry ();
    }
    zis.close ();
}


public CovarianceMatrix (short [] [] vectors) {
    int vectorLength = vectors [0].length;
    dimension = vectors.length;
    smallMatrix = new double [dimension] [dimension];
    for (int rowIndex = 0; rowIndex < smallMatrix.length; rowIndex ++) {
        for (int colIndex = 0; colIndex < rowIndex + 1; colIndex ++) {
            smallMatrix [rowIndex] [colIndex] = 0;
            for (int i = 0; i < vectorLength; i ++) {
                smallMatrix [rowIndex] [colIndex] += vectors [rowIndex] [i] * vectors [colIndex] [i];
            }
            smallMatrix [colIndex] [rowIndex] = smallMatrix [rowIndex] [colIndex];
        }
    }
    this.tridiagonalize ();
    this.performQLalgorithm ();
    ArrayList < EigenValueAndVector > tempList = new ArrayList < EigenValueAndVector > (dimension);
    for (int i = 0; i < dimension; i ++) {
        double [] eigenVector = new double [vectorLength];
        double length = 0;
        for (int j = 0; j < vectorLength; j ++) {
            double value = 0;
            for (int k = 0; k < vectors.length; k ++) {
                value += (vectors [k] [j]) * (smallMatrix [k] [i]);
            }
            eigenVector [j] = value;
            length += value * value;
        }
        length = Math.sqrt (length);
        for (int j = 0; j < eigenVector.length; j ++) {
            eigenVector [j] /= length;
        }
        EigenValueAndVector evv = new EigenValueAndVector ();
        evv.eigenVector = eigenVector;
        evv.eigenValue = eig [i];
        tempList.add (evv);
    }
    Collections.sort (tempList);
    eigenValueAndVectors = new EigenValueAndVector [dimension];
    tempList.toArray (eigenValueAndVectors);
}


-----Function Pair=102=-----==

public double [] [] getDataByDouble () {
    double [] [] fReturn = null;
    if (! isValid ()) return fReturn;
    int nRows;
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) nRows = 2;
    else nRows = sData.length;
    int nCols = sData [0].length;
    fReturn = new double [nRows] [nCols];
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) {
        for (int j = 0; j < nCols; j ++) {
            fReturn [0] [j] = j + 1;
            try {
                fReturn [0] [j] = Double.parseDouble ((sData [0] [j] == null) ? "0" : sData [0] [j]);
            } catch (NumberFormatException ex) {
                fReturn [0] [j] = 0.0;
            }
        }
    }
    else for (int i = 0; i < nRows; i ++) for (int j = 0; j < nCols; j ++) {
        try {
            fReturn [i] [j] = Double.parseDouble ((sData [i] [j] == null) ? "0" : sData [i] [j]);
        } catch (NumberFormatException ex) {
            fReturn [i] [j] = 0.0;
        }
    }
    return fReturn;
}


public void RunTests () {
    System.out.println ("---------\n---------");
    for (int i = 0; i < centerofgravity_origin.length; i ++) {
        System.out.println ("CoG Originsystem: " + centerofgravity_origin [i]);
    }
    System.out.println ("---------\n---------");
    for (int i = 0; i < centerofgravity_target.length; i ++) {
        System.out.println ("CoG Targetsystem: " + centerofgravity_target [i]);
    }
    System.out.println ("---------\n---------");
    for (int i = 0; i < eigenvalues [0] [1].length; i ++) {
        for (int j = 0; j < eigenvalues [0] [1].length; j ++) {
            System.out.println ("Eigenvektoren: " + eigenvalues [0] [i] [j]);
        }
    }
    System.out.println ("---------\n---------");
    for (int i = 0; i < eigenvalues [1] [1].length; i ++) {
        for (int j = 0; j < eigenvalues [1] [1].length; j ++) {
            System.out.println ("Eigenwerte: " + eigenvalues [1] [i] [j]);
        }
    }
    System.out.println ("---------\n---------");
    for (int ii = 0; ii < rotationmatrix.length; ii ++) {
        for (int iii = 0; iii < rotationmatrix.length; iii ++) {
            System.out.println ("3x3 RotMatrix: " + rotationmatrix [ii] [iii] + " " + "Zeile " + ii + " Spalte " + iii);
        }
    }
    System.out.println ("---------\n---------");
    System.out.println ("Scalefactor: " + scalefactor);
    System.out.println ("---------\n---------");
    for (int i = 0; i < transformvals.length; i ++) {
        System.out.println ("|Transformation|: " + transformvals [i] [0]);
    }
    System.out.println ("---------\n---------");
    System.out.println ("RotationMatrix3f: \n" + array2RotationMatrix3f ());
    System.out.println ("---------\n---------");
    System.out.println ("TranslationVector3f: " + array2TranslationVecMatrix3f ());
    System.out.println ("---------\n---------");
    System.out.println ("AxisAngles: " + MatrixtoAxisAngle (rotationmatrix));
    System.out.println ("---------\n---------");
}


-----Function Pair=103=-----==

public static void main (String [] args) {
    int [] myBestEleminationVector;
    int curPos = 0;
    int StartPosA, StartPosB;
    FileReader myFileReader;
    int myChar = 0;
    String myJobLine = "";
    try {
        myFileReader = new FileReader ("job2.txt");
        while ((myChar = myFileReader.read ()) != - 1) {
            myJobLine += String.valueOf ((char) myChar);
        }
        myFileReader.close ();
    } catch (IOException e) {
        System.out.println ("Fehler beim Lesen der Datei");
    }
    System.out.println ("myJobLine: " + myJobLine);
    myJobLine.trim ();
    StartPosA = 0;
    StartPosB = myJobLine.indexOf (" ");
    while (curPos < myJobLine.length ()) {
        System.out.println ("StartPosA:" + StartPosA);
        System.out.println ("StartPosB:" + StartPosB);
        for (int i = 0; i < 5; i ++) {
            GenTD meinGenTD = new GenTD ("graphs/" + myJobLine.substring (StartPosA, StartPosB));
            meinGenTD.setIterations ();
            for (int Iterations = 0; Iterations < meinGenTD.getIterations (); Iterations ++) {
                meinGenTD.Mutate ();
                meinGenTD.Recombine ();
                meinGenTD.Select ();
            }
            try {
                DataOutputStream out = new DataOutputStream (new BufferedOutputStream (new FileOutputStream ("out.txt", true)));
                out.writeUTF (i + " " + myJobLine.substring (StartPosA, StartPosB) + " " + meinGenTD.getMinTreeWidth () + "\n");
                out.close ();
            } catch (IOException e) {
                System.err.println (e.toString ());
            }
        }
        StartPosA = StartPosB + 1;
        StartPosB = myJobLine.indexOf (" ", StartPosA + 1);
        if (StartPosB == - 1) {
            StartPosB = myJobLine.length () - 1;
            System.out.println ("StartPosA:" + StartPosA);
            System.out.println ("StartPosB:" + StartPosB);
            for (int i = 0; i < 5; i ++) {
                GenTD meinGenTD = new GenTD ("graphs/" + myJobLine.substring (StartPosA, StartPosB));
                meinGenTD.setIterations ();
                for (int Iterations = 0; Iterations < meinGenTD.getIterations (); Iterations ++) {
                    meinGenTD.Mutate ();
                    meinGenTD.Recombine ();
                    meinGenTD.Select ();
                }
                try {
                    DataOutputStream out = new DataOutputStream (new BufferedOutputStream (new FileOutputStream ("out.txt", true)));
                    out.writeUTF (i + " " + myJobLine.substring (StartPosA, StartPosB) + " " + meinGenTD.getMinTreeWidth () + "\n");
                    out.close ();
                } catch (IOException e) {
                    System.err.println (e.toString ());
                }
            }
            break;
        }
    }
}


public RealSquareMatrix getInverse () throws EuclidRuntimeException {
    double [] [] inv = new double [rows] [rows];
    double [] [] temp = getMatrix ();
    double det = this.determinant ();
    if (det == 0) {
        throw new EuclidRuntimeException ("Cannot invert matrix: determinant=0");
    }
    double detr = 1 / det;
    if (this.rows == 1) {
        inv [0] [0] = detr;
    }
    else if (this.rows == 2) {
        inv [0] [0] = detr * temp [1] [1];
        inv [1] [0] = 0 - (detr * temp [0] [1]);
        inv [0] [1] = 0 - (detr * temp [1] [0]);
        inv [1] [1] = detr * temp [0] [0];
    }
    else if (this.rows == 3) {
        inv [0] [0] = detr * (temp [1] [1] * temp [2] [2] - temp [1] [2] * temp [2] [1]);
        inv [0] [1] = detr * (temp [0] [2] * temp [2] [1] - temp [0] [1] * temp [2] [2]);
        inv [0] [2] = detr * (temp [0] [1] * temp [1] [2] - temp [0] [2] * temp [1] [1]);
        inv [1] [0] = detr * (temp [1] [2] * temp [2] [0] - temp [1] [0] * temp [2] [2]);
        inv [1] [1] = detr * (temp [0] [0] * temp [2] [2] - temp [0] [2] * temp [2] [0]);
        inv [1] [2] = detr * (temp [0] [2] * temp [1] [0] - temp [0] [0] * temp [1] [2]);
        inv [2] [0] = detr * (temp [1] [0] * temp [2] [1] - temp [1] [1] * temp [2] [0]);
        inv [2] [1] = detr * (temp [0] [1] * temp [2] [0] - temp [0] [0] * temp [2] [1]);
        inv [2] [2] = detr * (temp [0] [0] * temp [1] [1] - temp [0] [1] * temp [1] [0]);
    }
    else {
        throw new EuclidRuntimeException ("Inverse of larger than 3x3 matricies: NYI");
    }
    RealSquareMatrix imat = new RealSquareMatrix (inv);
    return imat;
}


-----Function Pair=104=-----==

Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


public static byte readLineByte () {
    String inputString = null;
    byte number = - 123;
    boolean done = false;
    while (! done) {
        try {
            inputString = readLine ();
            inputString = inputString.trim ();
            number = Byte.parseByte (inputString);
            done = true;
        } catch (NumberFormatException e) {
            System.out.println ("Your input number is not correct.");
            System.out.println ("Your input number must be a");
            System.out.println ("whole number in the range");
            System.out.println ("-128 to 127, written as");
            System.out.println ("an ordinary numeral, such as 42.");
            System.out.println ("Minus signs are OK," + "but do not use a plus sign.");
            System.out.println ("Please try again.");
            System.out.println ("Enter a whole number:");
        }
    }
    return number;
}


-----Function Pair=105=-----==

public static void main (String [] args) {
    Spidey parser = null;
    SpideyCC.targets target = SpideyCC.targets.UNDEFINED;
    boolean cleaning = false;
    try {
        List < String > fileNames = new LinkedList < String > ();
        for (int i = 0; i < args.length; i ++) {
            if (args [i].equals ("-contiki")) {
                target = targets.CONTIKI;
            }
            else if (args [i].equals ("-tinyos")) {
                target = targets.TINYOS;
            }
            else if (args [i].equals ("-clean")) {
                cleaning = true;
            }
            else {
                fileNames.add (args [i]);
            }
        }
        if (target == SpideyCC.targets.UNDEFINED || fileNames.size () == 0) {
            printUsageAndExit ();
        }
        if (SPIDEYCC_ROOT.equals ("null/")) {
            printEnvVariableSettings ();
        }
        if (cleaning) {
            System.out.println ("Cleaning up attribute and value identifiers...");
            new File (ATTR_DUMP).delete ();
            new File (VALUES_DUMP).delete ();
            new File (IDS_DUMP).delete ();
        }
        boolean first = true;
        for (String fileName : fileNames) {
            System.out.print ("SpideyCC: Parsing " + fileName + "...");
            if (first) {
                first = false;
                parser = new Spidey (new FileReader (fileName));
            }
            else {
                Spidey.ReInit (new FileReader (fileName));
            }
            parser.startParsing ();
            System.out.println ("done!");
        }
        if (new File (ATTR_DUMP).exists () && new File (VALUES_DUMP).exists () && new File (IDS_DUMP).exists ()) {
            ObjectInputStream objReader = new ObjectInputStream (new FileInputStream (ATTR_DUMP));
            attributes = (HashSet < Attribute >) objReader.readObject ();
            objReader.close ();
            objReader = new ObjectInputStream (new FileInputStream (VALUES_DUMP));
            values = (HashSet < Value >) objReader.readObject ();
            objReader.close ();
            Value.nextSpideyValueId = values.size () + 1;
            Attribute.nextSpideyAttrId = attributes.size () + 1;
            objReader = new ObjectInputStream (new FileInputStream (IDS_DUMP));
            NghInstance.nextSpideyNghId = objReader.readInt ();
            NghTemplate.maxPredicates = objReader.readInt ();
            NodeInstance.maxLocalAttr = objReader.readInt ();
            objReader.close ();
        }
        else if (new File (ATTR_DUMP).exists () || new File (VALUES_DUMP).exists () || new File (IDS_DUMP).exists ()) {
            printDumpFileCleanAndExit ();
        }
        else {
            System.out.println ("Starting with fresh attribute and value identifiers!");
            attributes = new HashSet < Attribute > ();
            values = new HashSet < Value > ();
        }
        for (NodeTemplate templ : Spidey.nodesTemplate.values ()) {
            for (NodeAttribute nodeAttr : templ.getAttributes ()) {
                attributes.add (new Attribute (nodeAttr.getName ()));
            }
        }
        for (NodeInstance nodeInstance : Spidey.nodesData.values ()) {
            for (NodeAttributeBinding attrBinding : nodeInstance.getBindings ()) {
                Attribute attr = lookUpAttribute (attrBinding.getNodeAttribute ().getName ());
                values.add (new Value (attr, attrBinding.getValue ()));
            }
        }
        for (NghInstance nghInstance : Spidey.nghInstances.values ()) {
            for (NghPredicate nghPredicate : nghInstance.getTemplate ().getPredicates ()) {
                attributes.add (new Attribute (nghPredicate.getAttributeName ()));
                Attribute attr = lookUpAttribute (nghPredicate.getAttributeName ());
                if (! nghPredicate.isParameter ()) {
                    values.add (new Value (attr, nghPredicate.getValue ()));
                }
                else {
                    values.add (new Value (attr, nghInstance.getActualValue (nghPredicate.getValue ())));
                }
            }
        }
        String s = null;
        BufferedReader reader = new BufferedReader (new FileReader (SPIDEY_TYPES_TEMPLATE));
        BufferedWriter writer = new BufferedWriter (new FileWriter (SPIDEY_TYPES));
        while ((s = reader.readLine ()) != null) {
            s = s.concat ("\n");
            if (s.indexOf (COMPILER_TAG) != - 1) {
                writer.write (generateCompilerTag ());
            }
            else if (s.indexOf (DEFINITIONS) != - 1) {
                writeAttributeNames (writer);
                writer.write ("\n");
                writeAttributeValues (writer);
                writer.write ("\n");
                writeNghNames (writer);
            }
            else {
                writer.write (s);
            }
        }
        writer.flush ();
        writer.close ();
        if (target == targets.CONTIKI) {
            generateContikiTarget ();
        }
        else if (target == targets.TINYOS) {
            generateTinyOSTarget ();
        }
        System.out.println ("Don't forget to set \n" + "\t MAX_NGH_PREDICATES = " + NghTemplate.maxPredicates + "\n" + "\t LOCAL_ATTRIBUTES = " + NodeInstance.maxLocalAttr);
        ObjectOutputStream objWriter = new ObjectOutputStream (new FileOutputStream (ATTR_DUMP));
        objWriter.writeObject (attributes);
        objWriter.flush ();
        objWriter.close ();
        objWriter = new ObjectOutputStream (new FileOutputStream (VALUES_DUMP));
        objWriter.writeObject (values);
        objWriter.flush ();
        objWriter.close ();
        objWriter = new ObjectOutputStream (new FileOutputStream (IDS_DUMP));
        objWriter.writeInt (NghInstance.nextSpideyNghId);
        objWriter.writeInt (NghTemplate.maxPredicates);
        objWriter.writeInt (NodeInstance.maxLocalAttr);
        objWriter.flush ();
        objWriter.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
}


public static void exportToCSV (File csvFile, String tableName, boolean hasColumnNames) throws SQLException, IOException {
    final DBManager mgr = new DBManager ("SAMPLE");
    final ResultSet res = mgr.query ("select * from " + tableName);
    final FileWriter writer = new FileWriter (csvFile);
    final ResultSetMetaData rsmd = res.getMetaData ();
    int columns = rsmd.getColumnCount ();
    if (hasColumnNames) {
        for (int i = 1; i <= columns; i ++) {
            writer.append (rsmd.getColumnName (i));
            if (i < columns) writer.append (",");
        }
        writer.append ("\n");
    }
    while (res.next ()) {
        for (int i = 1; i <= columns; i ++) {
            writer.append (res.getString (i));
            if (i < columns) writer.append (",");
        }
        writer.append ("\n");
    }
    writer.close ();
}


-----Function Pair=106=-----==

public static void playSound2 (File file) throws UnsupportedAudioFileException, IOException, LineUnavailableException {
    AudioInputStream inputStream = AudioSystem.getAudioInputStream (file);
    AudioFormat audioFormat = inputStream.getFormat ();
    DataLine.Info info = new DataLine.Info (SourceDataLine.class, audioFormat);
    SourceDataLine sourceLine = (SourceDataLine) AudioSystem.getLine (info);
    sourceLine.open (audioFormat);
    sourceLine.start ();
    int nbytes = 0;
    byte [] data = new byte [1024];
    while (nbytes != - 1) {
        nbytes = inputStream.read (data, 0, data.length);
        sourceLine.write (data, 0, data.length);
    }
    sourceLine.drain ();
    sourceLine.close ();
}


public static void copyFile (File source, File destination) throws IOException {
    if ((destination.getParentFile () != null) && (! destination.getParentFile ().exists ())) {
        destination.getParentFile ().mkdirs ();
    }
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream (source);
        fos = new FileOutputStream (destination);
        byte [] buffer = new byte [1024 * 4];
        int n = 0;
        while ((n = fis.read (buffer)) != - 1) {
            fos.write (buffer, 0, n);
        }
    } finally {
        closeStream (fis);
        closeStream (fos);
    }
}


-----Function Pair=107=-----==

private byte [] remTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    tasks.remove (name);
    store.saveTaskList (null);
    return out.getBytes ();
}


private byte [] setServerProperty (HTTPurl urlData) throws Exception {
    String out = "";
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String [] parameter = urlData.getParameterList ();
    for (int x = 0; x < parameter.length; x ++) {
        if (! parameter [x].equals ("action") && ! parameter [x].equals ("sessionID")) {
            String value = urlData.getParameter (parameter [x]);
            if (value != null) {
                store.setServerProperty (parameter [x], value);
            }
        }
    }
    return out.getBytes ();
}


-----Function Pair=108=-----==

public void testParseAndCheck () {
    start (true);
    try {
        java.io.File f = new java.io.File ("testfiles/testNoErrors/A.java");
        org.jmlspecs.openjml.API m = new org.jmlspecs.openjml.API ();
        m.setOption ("-noPurityCheck");
        m.parseAndCheck (f);
        check ("", "");
    } catch (Exception e) {
        check ("", "");
        System.out.println (e);
        e.printStackTrace (System.out);
        assertTrue (false);
    }
}


private void createRemoteDirectory (File root, FTPClient ftp, String path) throws IOException {
    File [] files = root.listFiles ();
    for (int x = 0; x < files.length; x ++) {
        File f = files [x];
        if (f.isDirectory ()) {
            ftp.mkd (f.getName ());
            ftp.changeWorkingDirectory (f.getName ());
            path += "/" + f.getName ();
            createRemoteDirectory (f, ftp, path);
        }
        else {
            ftp.changeWorkingDirectory (path);
            FileInputStream is = new FileInputStream (f);
            ftp.storeFile (f.getName (), is);
            is.close ();
        }
    }
}


-----Function Pair=109=-----==

public void run () {
    InputDialog dlg;
    if (! this.fMoreFiles) {
        dlg = new InputDialog (Scytha.getWindow ().getShell (), this.fDlgTitel, fInputFiles.get (0).getAbsolutePath () + "\n" + Messages.getString ("RenameAction.to") + " " + this.fDestDirName + File.separator, fInputFiles.get (0).getName (), null);
    }
    else {
        dlg = new InputDialog (Scytha.getWindow ().getShell (), Messages.getString ("RenameAction.rename"), Messages.getString ("RenameAction.to") + " " + this.fDestDirName + File.separator, "*.*", null);
    }
    dlg.open ();
    if (dlg.getReturnCode () == 0) {
        try {
            if (this.fMoreFiles) {
                ArrayList < IFile > dirs = new ArrayList < IFile > ();
                ArrayList < IFile > files = new ArrayList < IFile > ();
                Util.readSubDirsAndFiles (fInputFiles, dirs, files, true);
                String sourceDir = Scytha.getWindow ().getSelectedFilePanel ().getActiveDirectoryName ();
                for (Iterator iter = files.iterator (); iter.hasNext ();) {
                    IFile fileToRename = (IFile) iter.next ();
                    LocalFile newFile = new LocalFile (this.fDestDirName + File.separator + fileToRename.getAbsolutePath ().substring (sourceDir.length ()));
                    renameFile (newFile, fileToRename);
                    if (fAnswerRenamingProblem == 3 || fAnswerExistsFile == 4) {
                        return;
                    }
                }
                for (IFile file : fInputFiles) {
                    if (file.isDirectory ()) {
                        deleteEmptyDirectoryEntries (file.getAbsolutePath ());
                        file.delete ();
                    }
                }
            }
            else {
                LocalFile newFile = new LocalFile (this.fDestDirName + File.separator + dlg.getValue ());
                if (renameFile (newFile, fInputFiles.get (0))) {
                    Scytha.getWindow ().refreshPanels ();
                    Scytha.getWindow ().getSelectedFilePanel ().setSelectedItem (newFile);
                }
                else {
                    MessageSystem.showErrorMessage (Messages.getString ("RenameAction.could.not.be.renamed", new Object [] {fInputFiles.get (0)}));
                }
            }
        } catch (ScythaException e) {
            MessageSystem.logException ("", getClass ().getName (), "run", null, e);
            MessageSystem.showErrorMessage (e.getLocalizedMessage ());
        }
    }
}


private byte [] remTunerFromList (HTTPurl urlData) throws Exception {
    int tunerIndex = - 1;
    try {
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount ()) {
                devList.remDevice (tunerIndex);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=110=-----==

public static int obtainLabels (int numkk, char [] chs, String [] labels) {
    int num = 0;
    char [] chsSim11 = new char [3 * numkk + 1];
    for (int id = 0; id < numkk; ++ id) {
        if (Character.isLetterOrDigit (chs [id]) || isDelim (chs [id])) {
            chsSim11 [num ++] = chs [id];
        }
        else {
            chsSim11 [num ++] = ConstantParameters.REPLACEMENT_BLANK;
            chsSim11 [num ++] = chs [id];
            chsSim11 [num ++] = ConstantParameters.REPLACEMENT_BLANK;
        }
    }
    char [] chsSim = new char [3 * numkk + 1];
    boolean [] isDelA = new boolean [3 * numkk + 1];
    int num11 = 0;
    boolean isD = false;
    for (int id = 0; id < num; ++ id) {
        if (chsSim11 [id] == ConstantParameters.REPLACEMENT_BLANK) {
            if (! isD) {
                isD = true;
                chsSim [num11] = chsSim11 [id];
                isDelA [num11] = true;
                ++ num11;
            }
        }
        else {
            isD = false;
            chsSim [num11] = chsSim11 [id];
            isDelA [num11] = false;
            ++ num11;
        }
    }
    isDelA [num11 ++] = true;
    int wS = 0;
    int lenW = 0;
    num = 0;
    for (int id = 0; id < num11; ++ id) {
        if (isDelA [id]) {
            lenW = id - wS;
            if (lenW == 1) {
                labels [num] = ConstantParameters.LABEL_S;
                chs [num] = chsSim [id - 1];
                ++ num;
                wS = id + 1;
            }
            else if (lenW > 1) {
                labels [num] = ConstantParameters.LABEL_L;
                chs [num] = chsSim [id - lenW];
                for (int i = 1; i < lenW - 1; ++ i) {
                    labels [num + i] = ConstantParameters.LABEL_M;
                    chs [num + i] = chsSim [id - lenW + i];
                }
                labels [num + lenW - 1] = ConstantParameters.LABEL_R;
                chs [num + lenW - 1] = chsSim [id - 1];
                num += lenW;
                wS = id + 1;
            }
        }
    }
    return num;
}


void statDir (MaildirTuple dir) throws MessagingException {
    long timestamp = dir.dir.lastModified ();
    if (timestamp == dir.timestamp) {
        return;
    }
    File [] files = dir.dir.listFiles (filter);
    int mlen = files.length;
    dir.messages = new MaildirMessage [mlen];
    for (int i = 0; i < mlen; i ++) {
        File file = files [i];
        String uniq = file.getName ();
        String info = null;
        int ci = uniq.indexOf (':');
        if (ci != - 1) {
            info = uniq.substring (ci + 1);
            uniq = uniq.substring (0, ci);
        }
        dir.messages [i] = new MaildirMessage (this, file, uniq, info, i + 1);
    }
    dir.timestamp = timestamp;
}


-----Function Pair=111=-----==

public static boolean renameFile (final File fromFile, final File toFile) {
    File toFile2 = toFile;
    if (fromFile.renameTo (toFile)) {
        return true;
    }
    if (! fromFile.exists ()) {
        return false;
    }
    if (! fromFile.canRead ()) {
        return false;
    }
    if (toFile.isDirectory ()) {
        toFile2 = new File (toFile, fromFile.getName ());
    }
    if (toFile2.exists ()) {
        return false;
    }
    String parent = toFile2.getParent ();
    if (parent == null) parent = System.getProperty ("user.dir");
    File dir = new File (parent);
    if (! dir.exists ()) {
        return false;
    }
    if (! dir.canWrite ()) {
        return false;
    }
    try {
        copyFile (fromFile, toFile2);
    } catch (UncheckedIOException e) {
        if (toFile2.exists ()) toFile2.delete ();
        return false;
    }
    fromFile.delete ();
    return true;
}


private static boolean tryNowThatItsLater () {
    List files;
    synchronized (deleteFileQueue) {
        files = new ArrayList (deleteFileQueue);
        deleteFileQueue.clear ();
    }
    List retry = new ArrayList ();
    for (Iterator i = files.iterator (); i.hasNext ();) {
        File file = (File) i.next ();
        tryToDelete (file);
        if (file.exists ()) retry.add (file);
    }
    synchronized (deleteFileQueue) {
        if (triesRemaining > 0) triesRemaining -= 1;
        if (triesRemaining <= 0 || retry.size () == 0) triesRemaining = 0;
        else deleteFileQueue.addAll (retry);
        return (triesRemaining <= 0);
    }
}


-----Function Pair=112=-----==

int old_javah (List < String > options, File outDir, File bootclasspath, String className) throws IOException, InterruptedException {
    List < String > cmd = new ArrayList < String > ();
    cmd.add (old_javah_cmd.getPath ());
    cmd.addAll (options);
    cmd.add ("-d");
    cmd.add (outDir.getPath ());
    cmd.add ("-bootclasspath");
    cmd.add (bootclasspath.getPath ());
    cmd.add (className);
    System.err.println ("old_javah: " + cmd);
    ProcessBuilder pb = new ProcessBuilder (cmd);
    pb.redirectErrorStream (true);
    Process p = pb.start ();
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    String line;
    StringBuilder sb = new StringBuilder ();
    while ((line = in.readLine ()) != null) {
        sb.append (line);
        sb.append ("\n");
    }
    System.err.println ("old javah out: " + sb.toString ());
    return p.waitFor ();
}


public static String decodeUnicode (String content) {
    Matcher matcher = pattern.matcher (content);
    StringBuffer sb = null;
    boolean isMatches = false;
    while (matcher.find ()) {
        if (! isMatches) {
            sb = new StringBuffer ();
            isMatches = true;
        }
        char c = (char) Integer.parseInt (matcher.group (1), 16);
        matcher.appendReplacement (sb, String.valueOf (c));
    }
    if (isMatches) {
        matcher.appendTail (sb);
        content = sb.toString ();
    }
    return content;
}


-----Function Pair=113=-----==

private DropTarget createTableDropTarget (final Table table) {
    DropTarget dropTarget = new DropTarget (table, DND.DROP_MOVE | DND.DROP_COPY);
    dropTarget.setTransfer (new Transfer [] {FileTransfer.getInstance ()});
    dropTarget.addDropListener (new DropTargetAdapter () {
        public void dragEnter (DropTargetEvent event) {
            isDropping = true;
        } public void dragLeave (DropTargetEvent event) {
            isDropping = false;
            handleDeferredRefresh ();
        } public void dragOver (DropTargetEvent event) {
            dropTargetValidate (event, getTargetFile (event));
            event.feedback |= DND.FEEDBACK_EXPAND | DND.FEEDBACK_SCROLL;
        } public void drop (DropTargetEvent event) {
            File targetFile = getTargetFile (event);
            if (dropTargetValidate (event, targetFile)) dropTargetHandleDrop (event, targetFile);
        } private File getTargetFile (DropTargetEvent event) {
            TableItem item = table.getItem (table.toControl (new Point (event.x, event.y)));
            File targetFile = null;
            if (item == null) {
                if (event.detail == DND.DROP_COPY) {
                    targetFile = (File) table.getData (TABLEDATA_DIR);
                }
            }
            else {
                targetFile = (File) item.getData (TABLEITEMDATA_FILE);
            }
            return targetFile;
        }
    }
    );
    return dropTarget;
}


void writeIndex (Collection < Example > examples) throws IOException {
    Map < String, Set < Example > > index = new TreeMap < String, Set < Example > > ();
    Set < String > initials = new HashSet < String > ();
    for (Example e : examples) {
        for (String k : e.getDeclaredKeys ()) {
            Set < Example > s = index.get (k);
            if (s == null) index.put (k, s = new TreeSet < Example > ());
            s.add (e);
        }
        initials.add (e.getName ().substring (0, 1).toUpperCase ());
    }
    if (INDEX_HEADER != null) {
        html.startTag (INDEX_HEADER);
        html.write ("Index");
        html.endTag (INDEX_HEADER);
    }
    html.startTag (HTMLWriter.P);
    html.writeLine ("Examples: ");
    for (char initial = 'A'; initial <= 'Z'; initial ++) {
        String s = String.valueOf (initial);
        if (initials.contains (s)) {
            html.writeLink ("#" + s, s);
        }
        else {
            html.write (s);
        }
        html.newLine ();
    }
    html.endTag (HTMLWriter.P);
    html.startTag (HTMLWriter.TABLE);
    html.writeAttr (HTMLWriter.CLASS, "index");
    html.newLine ();
    int row = 0;
    for (Map.Entry < String, Set < Example > > entry : index.entrySet ()) {
        html.startTag (HTMLWriter.TR);
        html.writeAttr (HTMLWriter.CLASS, (row ++ % 2 == 0 ? "even" : "odd"));
        html.startTag (HTMLWriter.TD);
        html.writeAttr ("valign", "top");
        html.write (entry.getKey ());
        html.endTag (HTMLWriter.TD);
        html.newLine ();
        html.startTag (HTMLWriter.TD);
        html.writeAttr (HTMLWriter.ALIGN, "top");
        String sep = "";
        for (Example e : entry.getValue ()) {
            html.write (sep);
            html.writeLink ('#' + e.getName (), e.getName ());
            sep = ", ";
        }
        html.endTag (HTMLWriter.TD);
        html.endTag (HTMLWriter.TR);
        html.newLine ();
    }
    html.endTag (HTMLWriter.TABLE);
}


-----Function Pair=114=-----==

private static char [] readChars (File file) {
    CharArrayWriter caw = new CharArrayWriter ();
    try {
        Reader fr = new FileReader (file);
        Reader in = new BufferedReader (fr);
        int count;
        char [] buf = new char [16384];
        while ((count = in.read (buf)) != - 1) {
            if (count > 0) caw.write (buf, 0, count);
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return caw.toCharArray ();
}


private int overlapDepth (ScheduleItem item) {
    Calendar cal = Calendar.getInstance ();
    ScheduleItem [] items = store.getScheduleArray ();
    HashMap < String, Channel > channels = store.getChannels ();
    Channel schChan = channels.get (item.getChannel ());
    String muxString = schChan.getFrequency () + "-" + schChan.getBandWidth ();
    Vector < ScheduleItem > operlapItems = new Vector < ScheduleItem > ();
    for (int x = 0; x < items.length; x ++) {
        if (items [x].toString ().equals (item.toString ()) == false) {
            if (item.isOverlapping (items [x])) {
                operlapItems.add (items [x]);
            }
        }
    }
    cal.setTime (item.getStart ());
    int duration = item.getDuration ();
    int maxCount = 0;
    for (int x = 0; x < duration; x ++) {
        HashMap < String, Integer > muxCountMap = new HashMap < String, Integer > ();
        muxCountMap.put (muxString, new Integer (1));
        for (int y = 0; y < operlapItems.size (); y ++) {
            ScheduleItem checkItem = (ScheduleItem) operlapItems.get (y);
            long slice = cal.getTime ().getTime ();
            if (slice > checkItem.getStart ().getTime () && slice < checkItem.getStop ().getTime ()) {
                Channel chackChan = channels.get (checkItem.getChannel ());
                String checkMuxString = chackChan.getFrequency () + "-" + chackChan.getBandWidth ();
                Integer muxCount = muxCountMap.get (checkMuxString);
                if (muxCount == null) {
                    muxCountMap.put (checkMuxString, new Integer (1));
                }
                else {
                    muxCountMap.put (checkMuxString, new Integer (muxCount.intValue () + 1));
                }
            }
        }
        String [] muxTotal = muxCountMap.keySet ().toArray (new String [0]);
        if (maxCount < muxTotal.length) maxCount = muxTotal.length;
        cal.add (Calendar.MINUTE, 1);
    }
    return maxCount;
}


-----Function Pair=115=-----==

public boolean addPage (File f) {
    if (f == null) {
        return false;
    }
    else if (f.isDirectory ()) {
        File [] images = f.listFiles ();
        for (int i = 0; i < images.length; i ++) {
            if (images [i].isFile ()) addPage (images [i]);
        }
    }
    else if (f.isFile ()) {
        if (f.getName ().toLowerCase ().endsWith (".pdf")) {
            int pdfPages;
            org.icepdf.core.pobjects.Document doc = new org.icepdf.core.pobjects.Document ();
            try {
                doc.setFile (f.getCanonicalPath ());
                pdfPages = doc.getNumberOfPages ();
            } catch (Exception e) {
                pdfPages = 0;
                JOptionPane.showMessageDialog (null, e.toString (), "PDF Error", JOptionPane.WARNING_MESSAGE);
            }
            doc.dispose ();
            if (pdfPages > 0) {
                String pageRange = JOptionPane.showInputDialog (f.getName () + "\nPage range?", "1-" + pdfPages);
                String [] pages = pageRange.split ("-");
                Integer p1 = Integer.decode (pages [0]);
                Integer p2 = Integer.decode (pages [1]);
                for (int p = p1; p <= p2; p ++) {
                    pageOrder.add (new MusicPageSVG (this, f, p - 1));
                }
            }
        }
        else {
            pageOrder.add (new MusicPageSVG (this, f, null));
        }
    }
    setDirty (true);
    notifyListeners ();
    return true;
}


private void processSheet (Sheet sh, FileWriter out) throws Exception {
    int rows = sh.getRows ();
    int cols = sh.getColumns ();
    Cell [] lineparts = new Cell [cols];
    String line = "";
    double number;
    for (int i = 0; i < rows; i ++) {
        lineparts = sh.getRow (i);
        line = lineparts [0].getContents ();
        for (int j = 1; j < lineparts.length; j ++) {
            if (lineparts [j].getType () == CellType.NUMBER) {
                number = ((NumberCell) lineparts [j]).getValue ();
                if (number == (int) number) {
                    line += ";" + (int) number;
                }
                else {
                    line += ";" + number;
                }
            }
            else {
                line += ";" + lineparts [j].getContents ();
            }
        }
        line += "\n";
        out.write (line);
    }
}


-----Function Pair=116=-----==

public ImageBorderWizard () {
    initComponents ();
    arcHeight.setModel (new SpinnerNumberModel (10, 1, 50, 1));
    arcWidth.setModel (new SpinnerNumberModel (10, 1, 50, 1));
    com.codename1.ui.Button btn = new com.codename1.ui.Button ();
    int bgColor = btn.getStyle ().getBgColor ();
    int fgColor = btn.getStyle ().getFgColor ();
    colorA.setText (Integer.toHexString (bgColor));
    colorB.setText (Integer.toHexString (new Color (bgColor).darker ().darker ().getRGB () & 0xffffff));
    colorC.setText (Integer.toHexString (fgColor));
    colorD.setText (Integer.toHexString (new Color (fgColor).brighter ().brighter ().getRGB () & 0xffffff));
    bindColorIconToButton (pickColorA, colorA);
    bindColorIconToButton (pickColorB, colorB);
    bindColorIconToButton (pickColorC, colorC);
    bindColorIconToButton (pickColorD, colorD);
    height.setModel (new SpinnerNumberModel (40, 20, 400, 1));
    opacity.setModel (new SpinnerNumberModel (255, 0, 255, 1));
    thickness.setModel (new SpinnerNumberModel (1, 1, 30, 1));
    width.setModel (new SpinnerNumberModel (150, 20, 400, 1));
    trackTextFieldChanges (colorA);
    trackTextFieldChanges (colorB);
    trackTextFieldChanges (colorC);
    trackTextFieldChanges (colorD);
    updateBorderImage ();
}


private byte [] showAddForm (HTTPurl urlData) throws Exception {
    int day = - 1;
    int month = - 1;
    int year = - 1;
    try {
        day = Integer.parseInt (urlData.getParameter ("day"));
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    ScheduleItem item = null;
    String id = urlData.getParameter ("id");
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
    }
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "itemdetails.html");
    if (item != null) template.replaceAll ("$duration", new Integer (item.getDuration ()).toString ());
    else template.replaceAll ("$duration", "1");
    if (item != null) template.replaceAll ("$name", item.getName ());
    else template.replaceAll ("$name", "");
    Calendar cal = Calendar.getInstance ();
    if (item != null) cal.setTime (item.getStart ());
    template.replaceAll ("$hour", store.intToStr (cal.get (Calendar.HOUR_OF_DAY)));
    template.replaceAll ("$min", store.intToStr (cal.get (Calendar.MINUTE)));
    template.replaceAll ("$channels", getChannelList (item));
    template.replaceAll ("$item_type", getTypeList (item));
    template.replaceAll ("$item_captype", getCapTypeList (item));
    String fields = "";
    fields += "<input type='hidden' name='day' value='" + day + "'>\n";
    fields += "<input type='hidden' name='month' value='" + month + "'>\n";
    fields += "<input type='hidden' name='year' value='" + year + "'>\n";
    if (item != null) {
        fields += "<input name='id' type='hidden' id='id' value='" + id + "'>\n";
    }
    template.replaceAll ("$fields", fields);
    if (item != null && item.isAutoDeletable ()) template.replaceAll ("$adtrue", "checked");
    else template.replaceAll ("$adtrue", "");
    template.replaceAll ("$pattern", getNamePatternList (item));
    if (item == null) {
        String defKeepFor = store.getProperty ("AutoDel.KeepFor");
        if (defKeepFor == null) defKeepFor = "30";
        template.replaceAll ("$keepfor", defKeepFor);
    }
    else {
        template.replaceAll ("$keepfor", new Integer (item.getKeepFor ()).toString ());
    }
    template.replaceAll ("$tasks", getTaskList (item));
    template.replaceAll ("$CapturePaths", getCapturePathList (item));
    return template.getPageBytes ();
}


-----Function Pair=117=-----==

public void testProxyConfig () throws Exception {
    final String defaultProxyHost = "defaultProxyHost";
    final int defaultProxyPort = 777;
    final WebClient webClient = new WebClient (getBrowserVersion (), defaultProxyHost, defaultProxyPort);
    final String html = "<html><head><title>Hello World</title></head><body></body></html>";
    final MockWebConnection webConnection = new MockWebConnection ();
    webConnection.setResponse (URL_FIRST, html);
    webClient.setWebConnection (webConnection);
    webClient.getPage (URL_FIRST);
    assertEquals (defaultProxyHost, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (defaultProxyPort, webConnection.getLastWebRequest ().getProxyPort ());
    final String defaultProxyHost2 = "defaultProxyHost2";
    final int defaultProxyPort2 = 532;
    webClient.getProxyConfig ().setProxyHost (defaultProxyHost2);
    webClient.getProxyConfig ().setProxyPort (defaultProxyPort2);
    webClient.getPage (URL_FIRST);
    assertEquals (defaultProxyHost2, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (defaultProxyPort2, webConnection.getLastWebRequest ().getProxyPort ());
    final String customProxyHost = "customProxyHost";
    final int customProxyPort = 1000;
    final WebRequest request = new WebRequest (URL_FIRST);
    request.setProxyHost (customProxyHost);
    request.setProxyPort (customProxyPort);
    webClient.getPage (request);
    assertEquals (customProxyHost, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (customProxyPort, webConnection.getLastWebRequest ().getProxyPort ());
    webClient.getProxyConfig ().addHostsToProxyBypass (URL_FIRST.getHost ());
    webClient.getPage (URL_FIRST);
    assertEquals (null, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (0, webConnection.getLastWebRequest ().getProxyPort ());
    webClient.getPage (request);
    assertEquals (customProxyHost, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (customProxyPort, webConnection.getLastWebRequest ().getProxyPort ());
    webClient.getProxyConfig ().removeHostsFromProxyBypass (URL_FIRST.getHost ());
    webClient.getPage (URL_FIRST);
    assertEquals (defaultProxyHost2, webConnection.getLastWebRequest ().getProxyHost ());
    assertEquals (defaultProxyPort2, webConnection.getLastWebRequest ().getProxyPort ());
    webClient.closeAllWindows ();
}


private String getTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = 0;
    if (item != null) type = item.getType ();
    typeList.append ("<label><input name='type' type='radio' value='0' ");
    if (type == ScheduleItem.ONCE) typeList.append ("checked");
    typeList.append (">Once</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='1' ");
    if (type == ScheduleItem.DAILY) typeList.append ("checked");
    typeList.append (">Daily</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='2' ");
    if (type == ScheduleItem.WEEKLY) typeList.append ("checked");
    typeList.append (">Weekly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='3' ");
    if (type == ScheduleItem.MONTHLY) typeList.append ("checked");
    typeList.append (">Monthly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='4' ");
    if (type == ScheduleItem.WEEKDAY) typeList.append ("checked");
    typeList.append (">Week Day</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='5' ");
    if (type == ScheduleItem.EPG) typeList.append ("checked");
    typeList.append (">EPG</label><br>\n");
    return typeList.toString ();
}


-----Function Pair=118=-----==

public void transformFile (File f, File targetDir) throws Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream ();
    FileInputStream fis = new FileInputStream (f);
    try {
        int c = 0;
        while (c != - 1) {
            c = fis.read ();
            if (c != - 1) {
                bos.write ((byte) c);
            }
        }
        bos.flush ();
    } finally {
        fis.close ();
    }
    File target = new File (targetDir, f.getName ());
    FileOutputStream fos = new FileOutputStream (target);
    try {
        byte [] transd = transformer.transformClass (bos.toByteArray ());
        fos.write (transd);
        fos.flush ();
    } finally {
        fos.close ();
    }
}


String getPolicy () {
    StringBuffer content = new StringBuffer ();
    try {
        FileInputStream fin = new FileInputStream ("/system/certs/policysigned1.txt");
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        int ch;
        while ((ch = fin.read ()) != - 1) {
            baos.write (ch);
        }
        fin.close ();
        content.append (new String (baos.toByteArray ()));
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    Log.i ("---EARL---", "length: " + content.length ());
    return content.toString ();
}


-----Function Pair=119=-----==

private byte [] remTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    tasks.remove (name);
    store.saveTaskList (null);
    return out.getBytes ();
}


private int getSchTblData (ScheduleItem [] itemsArray, StringBuffer content, boolean showOverlapStatus) throws Exception {
    Calendar dateFormater = Calendar.getInstance ();
    String rowHi = "class='rowHi'";
    String rowLo = "class='rowLow'";
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        dateFormater.setTime (item.getStart ());
        String type = "";
        if (item.getType () == ScheduleItem.ONCE) type = "Once";
        else if (item.getType () == ScheduleItem.DAILY) type = "Daily";
        else if (item.getType () == ScheduleItem.WEEKLY) type = "Weekly";
        else if (item.getType () == ScheduleItem.MONTHLY) type = "Monthly";
        else if (item.getType () == ScheduleItem.WEEKDAY) type = "Week Day";
        else if (item.getType () == ScheduleItem.EPG) type = "EPG";
        else type = "?" + item.getType () + "?";
        content.append ("<tr ");
        if (x % 2 == 0) content.append (rowHi + " >");
        else content.append (rowLo + " >");
        content.append ("<td class='itemdata'>");
        Vector < String > warnings = item.getWarnings ();
        if (warnings.size () > 0) {
            String waringText = "";
            for (int warnIndex = 0; warnIndex < warnings.size (); warnIndex ++) {
                waringText += " - " + warnings.get (warnIndex) + "\\n";
            }
            content.append ("<img alt='Warning' title='This Schedule has Warnings' onClick=\"warningBox('" + waringText + "', '" + item.toString () + "');\" " + "src='/images/exclaim24.png' border='0' width='22' height='24' style='cursor: pointer; cursor: hand;''> ");
        }
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (showOverlapStatus) {
            int depth = overlapDepth (item);
            if (depth > devList.getDeviceCount ()) content.append ("<img alt='To many overlapping items (" + depth + ")' title='To many overlapping items (" + depth + ")' " + "src='/images/exclaim24.png' border='0' width='22' height='24'> ");
            else content.append ("<img alt='(" + depth + ")' title='(" + depth + ")' " + "src='/images/tick.png' border='0' alt='Ok' width='24' height='24'> ");
        }
        content.append ("<a href='/servlet/ScheduleDataRes?action=07&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
        content.append ("<img src='/images/log.png' border='0' alt='Schedule Log' width='24' height='24'></a> ");
        Calendar viewDate = Calendar.getInstance ();
        viewDate.setTime (dateFormater.getTime ());
        if (viewDate.get (Calendar.HOUR_OF_DAY) <= 6) viewDate.add (Calendar.DATE, - 1);
        String egpUrl = "/servlet/EpgDataRes?action=12&year=" + viewDate.get (Calendar.YEAR) + "&month=" + (viewDate.get (Calendar.MONTH) + 1) + "&day=" + viewDate.get (Calendar.DATE) + "&scrollto=" + viewDate.get (Calendar.HOUR_OF_DAY);
        content.append ("<a href='" + egpUrl + "'>");
        content.append ("<img src='/images/epglink.png' border='0' alt='EPG Link' width='24' height='24'></a>\n");
        content.append ("</td>\n");
        content.append ("<td class='itemdata'>" + item.getName () + "</td>\n");
        int hour = dateFormater.get (Calendar.HOUR);
        if (hour == 0) hour = 12;
        String timeString = store.intToStr (hour) + ":" + store.intToStr (dateFormater.get (Calendar.MINUTE)) + " " + store.ampm.get (new Integer (dateFormater.get (Calendar.AM_PM)));
        content.append ("<td class='itemdata'><b>" + timeString + "</b></td>\n");
        String dateString = store.dayName.get (new Integer (dateFormater.get (Calendar.DAY_OF_WEEK))) + ", " + dateFormater.get (Calendar.DATE) + " " + store.monthNameShort.get (new Integer (dateFormater.get (Calendar.MONTH)));
        content.append ("<td class='itemdata'>" + dateString + "</td>\n");
        content.append ("<td class='itemdata'>" + item.getDuration () + "min</td>\n");
        content.append ("<td class='itemdata'>");
        content.append (item.getChannel ());
        content.append ("</td>\n");
        content.append ("<td class='itemdata'>" + type + "</td>\n");
        content.append ("<td class='itemdata'>" + item.getStatus () + "</td>\n");
        content.append ("<td class='itemdata'>");
        if (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.ERROR) {
            content.append ("<a onClick='return confirmAction(\"Delete\");' href='/servlet/ScheduleDataRes?action=04&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/delete.png' border='0' alt='Delete' width='24' height='24'></a>\n");
            if (item.getType () != ScheduleItem.EPG) {
                Calendar cal = Calendar.getInstance ();
                cal.setTime (item.getStart ());
                content.append (" <a href='/servlet/ScheduleDataRes?action=01&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "&month=" + cal.get (Calendar.MONTH) + "&year=" + cal.get (Calendar.YEAR) + "'>");
                content.append ("<img src='/images/edit.png' border='0' alt='Edit' width='24' height='24'></a>\n");
                content.append ("<a href='/servlet/ScheduleDataRes?action=05&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
                content.append ("<img src='/images/+5.png' border='0' alt='Add Time' width='24' height='24'></a>\n");
            }
            if (item.getType () == ScheduleItem.DAILY || item.getType () == ScheduleItem.WEEKLY || item.getType () == ScheduleItem.MONTHLY || item.getType () == ScheduleItem.WEEKDAY) {
                content.append ("<a href='/servlet/ScheduleDataRes?action=06&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
                content.append ("<img src='/images/skip.png' border='0' alt='Skip' width='24' height='24'></a>\n");
            }
        }
        if (item.getState () == ScheduleItem.RUNNING) {
            content.append ("<a onClick='return confirmAction(\"Stop\");' href='/servlet/ScheduleDataRes?action=09&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/stop.png' border='0' alt='Stop' width='24' height='24'></a>\n");
            content.append ("<a href='/servlet/ScheduleDataRes?action=05&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/+5.png' border='0' alt='Add Time' width='24' height='24'></a>\n");
        }
        content.append ("</td>\n");
        content.append ("</tr>\n");
    }
    return 0;
}


-----Function Pair=120=-----==

public void testMarshal () throws JiBXException, SAXException, IOException {
    GetDomainResponse o = GetDomainResponseFactory.create ();
    IBindingFactory bfact = BindingDirectory.getFactory (GetDomainResponse.class);
    IMarshallingContext marshallingContext = bfact.createMarshallingContext ();
    Writer outConsole = new BufferedWriter (new OutputStreamWriter (System.out));
    marshallingContext.setOutput (outConsole);
    marshallingContext.setIndent (3);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
    Writer out = new BufferedWriter (new OutputStreamWriter (outputStream));
    marshallingContext.setIndent (3);
    marshallingContext.setOutput (out);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    InputSource marshallingResult = new InputSource (new ByteArrayInputStream (outputStream.toByteArray ()));
    FileInputStream fis = new FileInputStream (new File ("src/test/resources/csw202-discovery/GetDomainResponseTestData.xml"));
    InputSource expectedResult = new InputSource (fis);
    DifferenceListener differenceListener = new IgnoreTextAndAttributeValuesDifferenceListener ();
    Diff diff = new Diff (expectedResult, marshallingResult);
    diff.overrideDifferenceListener (differenceListener);
    assertTrue ("Marshalled GetDomainResponse matches expected XML " + diff, diff.similar ());
}


public static byte [] getBytesFromFile (File file) {
    byte [] ret = null;
    FileInputStream fileInputStream = null;
    ByteArrayOutputStream byteArrayOutputStream = null;
    try {
        if (file == null) {
            return ret;
        }
        fileInputStream = new FileInputStream (file);
        byteArrayOutputStream = new ByteArrayOutputStream (1024);
        byte [] tmpByte = new byte [1024];
        int n = - 1;
        while ((n = fileInputStream.read (tmpByte)) != - 1) {
            byteArrayOutputStream.write (tmpByte, 0, n);
        }
        ret = byteArrayOutputStream.toByteArray ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (fileInputStream != null) {
                fileInputStream.close ();
            }
            if (byteArrayOutputStream != null) {
                byteArrayOutputStream.close ();
            }
        } catch (Exception e) {
        }
    }
    return ret;
}


-----Function Pair=121=-----==

public static void CreateDBTables () {
    String CreateStringAccount = "create table account (name varchar(50) primary key, description varchar(250))";
    String CreateStringCategory = "create table category (name varchar(50) primary key, description varchar(250), budget float)";
    String CreateStringLedger = "create table ledger (id INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1),rec integer, tdate date, payee  varchar(50), description varchar(250), account varchar(50), category varchar(50), amount float)";
    Statement s;
    try {
        s = conn.createStatement ();
        if (! DBUtils.ChkTableAccount (conn)) {
            System.out.println (" . . . . creating table account");
            s.execute (CreateStringAccount);
        }
        if (! DBUtils.ChkTableCategory (conn)) {
            System.out.println (" . . . . creating table category");
            s.execute (CreateStringCategory);
        }
        if (! DBUtils.ChkTableLedger (conn)) {
            System.out.println (" . . . . creating table ledger");
            s.execute (CreateStringLedger);
        }
        s.close ();
    } catch (Throwable e) {
        System.out.println (" . . . exception thrown:");
        errorPrint (e);
    }
}


public static void BubbleSortInt1 (int [] num) {
    boolean flag = true;
    int temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=122=-----==

protected ArrayList < TopKElement > reduceArrayListDuplicates (ArrayList < TopKElement > al) {
    TopKElement last = null;
    int lastIndex = - 1;
    for (int i = 0; i < al.size (); i ++) {
        TopKElement el = al.get (i);
        if (last != null && el.name.equals (last.name)) {
            if (el.rating < last.rating) {
                al.remove (i);
                i --;
                continue;
            }
            else {
                al.remove (lastIndex);
                i = lastIndex - 1;
                continue;
            }
        }
        last = el;
        lastIndex = i;
    }
    return al;
}


void buildMenus (final tabbedTableItem item) {
    JMenuBar menuBar = new JMenuBar ();
    ResourceBundle rb = ResourceBundle.getBundle ("apps.AppsBundle");
    JMenu fileMenu = new JMenu (rb.getString ("MenuFile"));
    menuBar.add (fileMenu);
    JMenuItem newItem = new JMenuItem ("New Window");
    fileMenu.add (newItem);
    newItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            actionList.openNewTableWindow (list.getSelectedIndex ());
        }
    }
    );
    fileMenu.add (new jmri.configurexml.SaveMenu ());
    JMenuItem printItem = new JMenuItem (rb.getString ("PrintTable"));
    fileMenu.add (printItem);
    printItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            try {
                MessageFormat footerFormat = new MessageFormat (getTitle () + " page {0,number}");
                if (item.getStandardTableModel ()) item.getDataTable ().print (JTable.PrintMode.FIT_WIDTH, null, footerFormat);
                else item.getAAClass ().print (JTable.PrintMode.FIT_WIDTH, null, footerFormat);
            } catch (java.awt.print.PrinterException e1) {
                log.warn ("error printing: " + e1, e1);
            } catch (NullPointerException ex) {
                log.error ("Trying to print returned a NPE error");
            }
        }
    }
    );
    JMenu viewMenu = new JMenu ("View");
    menuBar.add (viewMenu);
    for (int i = 0; i < tabbedTableItemListArray.size (); i ++) {
        final tabbedTableItemList itemList = tabbedTableItemListArray.get (i);
        JMenuItem viewItem = new JMenuItem (itemList.getItemString ());
        viewMenu.add (viewItem);
        viewItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                gotoListItem (itemList.getClassAsString ());
            }
        }
        );
    }
    this.setJMenuBar (menuBar);
    try {
        item.getAAClass ().setMenuBar (this);
        this.addHelpMenu (item.getAAClass ().helpTarget (), true);
    } catch (Exception ex) {
        log.error ("Error when trying to set menu bar for " + item.getClassAsString () + "\n" + ex);
    }
    this.validate ();
}


-----Function Pair=123=-----==

public Entity createEntity (String type, String instname) throws Exception {
    Entity ent = null;
    try {
        Class entclass = findEntityClass (type);
        Constructor < String > ctor = entclass.getConstructor (String.class);
        Object obj = ctor.newInstance (instname);
        if (obj instanceof Entity) {
            ((BaseEntity) obj).setInstanceName (instname);
            ent = (Entity) obj;
        }
        else {
            throw new Exception ("requested entity " + type + " is not compatible to BaseEntity.");
        }
    } catch (ClassNotFoundException e) {
        throw new Exception ("could not create entity " + type + ".\n  reason: " + e);
    } catch (Exception e) {
        throw new Exception ("could not create entity " + type + ".\n  reason: " + e);
    }
    return ent;
}


public TransactionManager getTransactionManager (ClassLoaderResolver clr) {
    if (locator != null) {
        TransactionManager tm = getTransactionManagerForLocator (clr, locator);
        if (tm != null) {
            return tm;
        }
    }
    else {
        for (int i = 0; i < locators.length; i ++) {
            TransactionManager tm = getTransactionManagerForLocator (clr, locators [i]);
            if (tm != null) {
                return tm;
            }
        }
    }
    return null;
}


-----Function Pair=124=-----==

public boolean equals (Object o) {
    if (o == this) {
        return true;
    }
    else if (o instanceof Version) {
        Version other = (Version) o;
        if (snapshot != other.snapshot) {
            return false;
        }
        for (int i = 0; i < parts.length; i ++) {
            Integer thisPart = parts [i];
            Integer otherPart = other.parts [i];
            if (thisPart == null ? otherPart != null : ! thisPart.equals (otherPart)) {
                return false;
            }
        }
        return true;
    }
    else {
        return false;
    }
}


public void testSize () throws Throwable {
    for (int threadID = 0; threadID < NTHREAD; threadID ++) {
        for (int j = 0; j < NELEMENT; j ++) {
            String key = "test Thread-" + threadID + "_" + j;
            boolean res = setStr.add (key);
            assertTrue (res);
        }
    }
    assertEquals (setStr.size (), NTHREAD * NELEMENT);
    Thread [] threads = new Thread [NTHREAD];
    for (int threadID = 0; threadID < NTHREAD; threadID ++) {
        threads [threadID] = new Thread ("Thread-" + threadID) {
            public void run () {
                assertEquals (setStr.size (), NTHREAD * NELEMENT);
            }
        }
        ;
    }
    runner.runThreads (threads, "testSize");
}


-----Function Pair=125=-----==

private static Object createObject (String className, EntityManager manager) {
    Constructor entityManagerConstructor = null;
    Object object = null;
    try {
        Class [] entityManagerArgaClass = new Class [] {EntityManager.class};
        Object [] inArgs = new Object [] {manager};
        Class classDefinition = Class.forName (className);
        entityManagerConstructor = classDefinition.getConstructor (entityManagerArgaClass);
        log.trace ("Constructor: " + entityManagerConstructor.toString ());
        object = entityManagerConstructor.newInstance (inArgs);
        log.trace ("Object: " + object.toString ());
    } catch (Exception e) {
        log.error (e);
    }
    return object;
}


static byte [] createByteArrayFromC (VM_Address stringAddress) {
    int word;
    int length = 0;
    VM_Address addr = stringAddress;
    while (true) {
        word = VM_Magic.getMemoryWord (addr);
        int byte0 = ((word>> 24) & 0xFF);
        int byte1 = ((word>> 16) & 0xFF);
        int byte2 = ((word>> 8) & 0xFF);
        int byte3 = (word & 0xFF);
        if (byte0 == 0) break;
        length ++;
        if (byte1 == 0) break;
        length ++;
        if (byte2 == 0) break;
        length ++;
        if (byte3 == 0) break;
        length ++;
        addr = addr.add (4);
    }
    byte [] contents = new byte [length];
    VM_Memory.memcopy (VM_Magic.objectAsAddress (contents), stringAddress, length);
    return contents;
}


-----Function Pair=126=-----==

protected Option getOption (String name, boolean defined) throws ArgsParserException {
    Option opt;
    if (name == null) {
        throw new NullPointerException ("name");
    }
    opt = (Option) options_.get (name);
    if (opt == null) {
        Iterator i;
        List list;
        list = new ArrayList (8);
        for (i = options_.values ().iterator (); i.hasNext ();) {
            opt = (Option) i.next ();
            if (opt.name_.startsWith (name)) {
                list.add (opt);
            }
        }
        if (list.size () != 1) {
            throw new UnknownOptionException (name);
        }
        opt = (Option) list.get (0);
    }
    if (defined && ! opt.defined_) {
        throw new UndefinedOptionException (name);
    }
    return opt;
}


private static TclObject getFieldInfoList (Interp interp, Class c, boolean statOpt, boolean typeOpt) throws TclException {
    Field [] fieldArray = FieldSig.getAccessibleFields (c);
    TclObject resultListObj = TclList.newInstance ();
    TclObject elementObj, sigObj, pairObj;
    Class declClass;
    for (int f = 0; f < fieldArray.length; ++ f) {
        boolean isStatic = ((fieldArray [f].getModifiers () & Modifier.STATIC) > 0);
        if (isStatic == statOpt) {
            sigObj = TclList.newInstance ();
            String fieldName = fieldArray [f].getName ();
            elementObj = TclString.newInstance (fieldName);
            TclList.append (interp, sigObj, elementObj);
            declClass = fieldArray [f].getDeclaringClass ();
            if (! declClass.equals (c)) {
                for (int i = 0; i < fieldArray.length; ++ i) {
                    if (i == f) {
                        continue;
                    }
                    if (! fieldName.equals (fieldArray [i].getName ())) {
                        continue;
                    }
                    Class tmpClass = fieldArray [i].getDeclaringClass ();
                    if (declClass.isAssignableFrom (tmpClass)) {
                        elementObj = TclString.newInstance (getNameFromClass (declClass));
                        TclList.append (interp, sigObj, elementObj);
                        break;
                    }
                }
            }
            if (typeOpt) {
                pairObj = TclList.newInstance ();
                elementObj = TclString.newInstance (getNameFromClass (fieldArray [f].getType ()));
                TclList.append (interp, pairObj, elementObj);
                TclList.append (interp, pairObj, sigObj);
                TclList.append (interp, resultListObj, pairObj);
            }
            else {
                TclList.append (interp, resultListObj, sigObj);
            }
        }
    }
    return resultListObj;
}


-----Function Pair=127=-----==

public boolean exportTrl () {
    if (! p_info.isTranslated ()) {
        log.info ("No existe traduccion.");
        return true;
    }
    String [] lang = es.indeos.transform.Convert.getLanguages ();
    if (lang == null) {
        log.log (Level.SEVERE, "No se han encontrado paises para los que generar la traduccion.");
        return false;
    }
    for (int x = 0; x < lang.length; x ++) {
        String AD_Language = lang [x];
        log.info ("Exportando traduccion: " + AD_Language);
        poAd.setTrlMap (new HashMap ());
        Map trlMap = poAd.getTrlMap ();
        for (int i = 0; i < p_info.getColumnCount (); i ++) {
            if (p_info.isColumnTranslated (i)) {
                String col = p_info.getColumnName (i);
                String trl = poAd.pa_get_Translation (col, AD_Language);
                if (trl != null) {
                    TrlConvert trlconv = new TrlConvert (AD_Language, col, trl);
                    trlMap.put (col, trlconv);
                    log.info ("Campo: " + col + " - Traduccion: " + trl);
                }
            }
        }
    }
    return true;
}


private void runMobSim () {
    if (this.config.simulation ().getExternalExe () == null) {
        final String JDEQ_SIM = "JDEQSim";
        if (this.config.getModule (JDEQ_SIM) != null) {
            JDEQSimulation sim = new JDEQSimulation (this.scenarioData, this.events);
            sim.run ();
        }
        else {
            Simulation simulation = this.getMobsimFactory ().createMobsim (this.getScenario (), this.getEvents ());
            if (simulation instanceof IOSimulation) {
                ((IOSimulation) simulation).setControlerIO (this.getControlerIO ());
                ((IOSimulation) simulation).setIterationNumber (this.getIterationNumber ());
            }
            if (simulation instanceof ObservableSimulation) {
                for (SimulationListener l : this.getQueueSimulationListener ()) {
                    ((ObservableSimulation) simulation).addQueueSimulationListeners (l);
                }
            }
            simulation.run ();
        }
    }
    else {
        ExternalMobsim sim = new ExternalMobsim (this.scenarioData, this.events);
        sim.setControlerIO (this.controlerIO);
        sim.setIterationNumber (this.getIterationNumber ());
        sim.run ();
    }
}


-----Function Pair=128=-----==

private boolean saveTrl (TrlConvert trl, String trx) {
    String keycolumn = po.get_TableName () + "_ID";
    String column = trl.getColumn ();
    String AD_Language = trl.getAD_Language ();
    String translation = trl.getTrl ();
    int ID = poAd.getImp_ID ();
    log.info ("Importando traduccion: " + column + " - " + AD_Language);
    StringBuffer sql = new StringBuffer ();
    sql.append ("update ").append (po.get_TableName ()).append ("_Trl ");
    sql.append ("set ").append (column).append ("=? ");
    sql.append ("where ").append (keycolumn).append ("=? ");
    sql.append (" and ad_language=?");
    try {
        PreparedStatement pstmt = DB.prepareStatement (sql.toString (), trx);
        pstmt.setString (1, translation);
        pstmt.setInt (2, ID);
        pstmt.setString (3, AD_Language);
        pstmt.executeUpdate ();
        pstmt.close ();
        pstmt = null;
        return true;
    } catch (Exception e) {
        log.log (Level.SEVERE, "Error importando la traduccion de: " + column + " - " + e.toString ());
        return false;
    }
}


protected Gene newGeneInternal () {
    try {
        CompositeGene compositeGene = new CompositeGene (getConfiguration ());
        compositeGene.setConstraintChecker (getConstraintChecker ());
        Gene gene;
        int geneSize = m_genes.size ();
        for (int i = 0; i < geneSize; i ++) {
            gene = (Gene) m_genes.get (i);
            compositeGene.addGene (gene.newGene (), false);
        }
        return compositeGene;
    } catch (InvalidConfigurationException iex) {
        throw new IllegalStateException (iex.getMessage ());
    }
}


-----Function Pair=129=-----==

public void initialize () throws LifecycleException {
    StaticServiceHolder.sipStandardService = this;
    try {
        sipApplicationDispatcher = (SipApplicationDispatcher) Class.forName (sipApplicationDispatcherClassName).newInstance ();
    } catch (InstantiationException e) {
        throw new LifecycleException ("Impossible to load the Sip Application Dispatcher", e);
    } catch (IllegalAccessException e) {
        throw new LifecycleException ("Impossible to load the Sip Application Dispatcher", e);
    } catch (ClassNotFoundException e) {
        throw new LifecycleException ("Impossible to load the Sip Application Dispatcher", e);
    } catch (ClassCastException e) {
        throw new LifecycleException ("Sip Application Dispatcher defined does not implement " + SipApplicationDispatcher.class.getName (), e);
    }
    if (logger.isInfoEnabled ()) {
        logger.info ("Pretty encoding of headers enabled ? " + usePrettyEncoding);
    }
    if (sipPathName == null) {
        sipPathName = DEFAULT_SIP_PATH_NAME;
    }
    if (logger.isInfoEnabled ()) {
        logger.info ("Sip Stack path name : " + sipPathName);
    }
    sipApplicationDispatcher.setSipService (this);
    sipApplicationDispatcher.getSipFactory ().initialize (sipPathName, usePrettyEncoding);
    String catalinaBase = getCatalinaBase ();
    if (darConfigurationFileLocation != null) {
        if (! darConfigurationFileLocation.startsWith ("file:///")) {
            darConfigurationFileLocation = "file:///" + catalinaBase.replace (File.separatorChar, '/') + "/" + darConfigurationFileLocation;
        }
        System.setProperty ("javax.servlet.sip.dar", darConfigurationFileLocation);
    }
    super.initialize ();
    sipApplicationDispatcher.setDomain (this.getName ());
    if (baseTimerInterval < 1) {
        throw new LifecycleException ("It's forbidden to set the Base Timer Interval to a non positive value");
    }
    initSipStack ();
    sipApplicationDispatcher.setBaseTimerInterval (baseTimerInterval);
    sipApplicationDispatcher.setT2Interval (t2Interval);
    sipApplicationDispatcher.setT4Interval (t4Interval);
    sipApplicationDispatcher.setTimerDInterval (timerDInterval);
    sipApplicationDispatcher.setMemoryThreshold (getMemoryThreshold ());
    sipApplicationDispatcher.setBackToNormalMemoryThreshold (backToNormalMemoryThreshold);
    sipApplicationDispatcher.setCongestionControlCheckingInterval (getCongestionControlCheckingInterval ());
    sipApplicationDispatcher.setCongestionControlPolicyByName (getCongestionControlPolicy ());
    sipApplicationDispatcher.setQueueSize (getSipMessageQueueSize ());
    sipApplicationDispatcher.setBackToNormalQueueSize (backToNormalSipMessageQueueSize);
    sipApplicationDispatcher.setGatherStatistics (gatherStatistics);
    sipApplicationDispatcher.setConcurrencyControlMode (ConcurrencyControlMode.valueOf (getConcurrencyControlMode ()));
    sipApplicationDispatcher.setBypassRequestExecutor (bypassRequestExecutor);
    sipApplicationDispatcher.setBypassResponseExecutor (bypassResponseExecutor);
    sipApplicationDispatcher.setSipStack (sipStack);
    sipApplicationDispatcher.init ();
    synchronized (connectors) {
        for (Connector connector : connectors) {
            ProtocolHandler protocolHandler = connector.getProtocolHandler ();
            if (protocolHandler instanceof SipProtocolHandler) {
                connector.setPort (((SipProtocolHandler) protocolHandler).getPort ());
                ((SipProtocolHandler) protocolHandler).setSipStack (sipStack);
                ((SipProtocolHandler) protocolHandler).setAttribute (SipApplicationDispatcher.class.getSimpleName (), sipApplicationDispatcher);
                registerSipConnector (connector);
            }
        }
    }
}


private IModelInstanceObject copyForAtPreWithReflections () throws CopyForAtPreException {
    IModelInstanceObject result;
    Class < ? > adapteeClass;
    adapteeClass = this.myEObject.getClass ();
    try {
        EObject copiedAdaptedObject;
        Constructor < ? > emptyConstructor;
        emptyConstructor = adapteeClass.getConstructor (new Class [0]);
        copiedAdaptedObject = (EObject) emptyConstructor.newInstance (new Object [0]);
        while (adapteeClass != null) {
            for (Field field : adapteeClass.getDeclaredFields ()) {
                field.setAccessible (true);
                if (! (Modifier.isFinal (field.getModifiers ()) || Modifier.isStatic (field.getModifiers ()))) {
                    field.set (copiedAdaptedObject, field.get (this.myEObject));
                }
            }
            adapteeClass = adapteeClass.getSuperclass ();
        }
        result = new EcoreModelInstanceObject (copiedAdaptedObject, this.myAdaptedType, this.myType, this.getOriginalType (), this.myFactory);
    } catch (SecurityException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    } catch (NoSuchMethodException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    } catch (IllegalArgumentException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    } catch (InstantiationException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    } catch (IllegalAccessException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    } catch (InvocationTargetException e) {
        String msg;
        msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_CannotCopyForAtPre;
        msg = NLS.bind (msg, this.getName (), e.getMessage ());
        throw new CopyForAtPreException (msg, e);
    }
    return result;
}


-----Function Pair=130=-----==

private static boolean loadClasses () {
    switch (jvm) {
        case MRJ_2_0 :
            try {
                Class aeTargetClass = Class.forName ("com.apple.MacOS.AETarget");
                Class osUtilsClass = Class.forName ("com.apple.MacOS.OSUtils");
                Class appleEventClass = Class.forName ("com.apple.MacOS.AppleEvent");
                Class aeClass = Class.forName ("com.apple.MacOS.ae");
                aeDescClass = Class.forName ("com.apple.MacOS.AEDesc");
                aeTargetConstructor = aeTargetClass.getDeclaredConstructor (new Class [] {int.class});
                appleEventConstructor = appleEventClass.getDeclaredConstructor (new Class [] {int.class, int.class, aeTargetClass, int.class, int.class});
                aeDescConstructor = aeDescClass.getDeclaredConstructor (new Class [] {String.class});
                makeOSType = osUtilsClass.getDeclaredMethod ("makeOSType", new Class [] {String.class});
                putParameter = appleEventClass.getDeclaredMethod ("putParameter", new Class [] {int.class, aeDescClass});
                sendNoReply = appleEventClass.getDeclaredMethod ("sendNoReply", new Class [] {});
                Field keyDirectObjectField = aeClass.getDeclaredField ("keyDirectObject");
                keyDirectObject = (Integer) keyDirectObjectField.get (null);
                Field autoGenerateReturnIDField = appleEventClass.getDeclaredField ("kAutoGenerateReturnID");
                kAutoGenerateReturnID = (Integer) autoGenerateReturnIDField.get (null);
                Field anyTransactionIDField = appleEventClass.getDeclaredField ("kAnyTransactionID");
                kAnyTransactionID = (Integer) anyTransactionIDField.get (null);
            } catch (ClassNotFoundException cnfe) {
                errorMessage = cnfe.getMessage ();
                return false;
            } catch (NoSuchMethodException nsme) {
                errorMessage = nsme.getMessage ();
                return false;
            } catch (NoSuchFieldException nsfe) {
                errorMessage = nsfe.getMessage ();
                return false;
            } catch (IllegalAccessException iae) {
                errorMessage = iae.getMessage ();
                return false;
            }
            break;
        case MRJ_2_1 :
            try {
                mrjFileUtilsClass = Class.forName ("com.apple.mrj.MRJFileUtils");
                mrjOSTypeClass = Class.forName ("com.apple.mrj.MRJOSType");
                Field systemFolderField = mrjFileUtilsClass.getDeclaredField ("kSystemFolderType");
                kSystemFolderType = systemFolderField.get (null);
                findFolder = mrjFileUtilsClass.getDeclaredMethod ("findFolder", new Class [] {mrjOSTypeClass});
                getFileCreator = mrjFileUtilsClass.getDeclaredMethod ("getFileCreator", new Class [] {File.class});
                getFileType = mrjFileUtilsClass.getDeclaredMethod ("getFileType", new Class [] {File.class});
            } catch (ClassNotFoundException cnfe) {
                errorMessage = cnfe.getMessage ();
                return false;
            } catch (NoSuchFieldException nsfe) {
                errorMessage = nsfe.getMessage ();
                return false;
            } catch (NoSuchMethodException nsme) {
                errorMessage = nsme.getMessage ();
                return false;
            } catch (SecurityException se) {
                errorMessage = se.getMessage ();
                return false;
            } catch (IllegalAccessException iae) {
                errorMessage = iae.getMessage ();
                return false;
            }
            break;
        case MRJ_3_0 :
            try {
                Class linker = Class.forName ("com.apple.mrj.jdirect.Linker");
                Constructor constructor = linker.getConstructor (new Class [] {Class.class});
                linkage = constructor.newInstance (new Object [] {BrowserLauncher.class});
            } catch (ClassNotFoundException cnfe) {
                errorMessage = cnfe.getMessage ();
                return false;
            } catch (NoSuchMethodException nsme) {
                errorMessage = nsme.getMessage ();
                return false;
            } catch (InvocationTargetException ite) {
                errorMessage = ite.getMessage ();
                return false;
            } catch (InstantiationException ie) {
                errorMessage = ie.getMessage ();
                return false;
            } catch (IllegalAccessException iae) {
                errorMessage = iae.getMessage ();
                return false;
            }
            break;
        case MRJ_3_1 :
            try {
                mrjFileUtilsClass = Class.forName ("com.apple.mrj.MRJFileUtils");
                openURL = mrjFileUtilsClass.getDeclaredMethod ("openURL", new Class [] {String.class});
            } catch (ClassNotFoundException cnfe) {
                errorMessage = cnfe.getMessage ();
                return false;
            } catch (NoSuchMethodException nsme) {
                errorMessage = nsme.getMessage ();
                return false;
            }
            break;
        default :
            break;
    }
    return true;
}


public IModelInstanceElement getProperty (Property property) throws PropertyAccessException, PropertyNotFoundException {
    if (property == null) {
        throw new IllegalArgumentException ("Parameter 'property' must not be null.");
    }
    IModelInstanceElement result;
    if (this.myEObject == null) {
        result = this.myFactory.createModelInstanceElement (null, property.getType ());
    }
    else {
        EStructuralFeature sf = this.myEObject.eClass ().getEStructuralFeature (property.getName ());
        if (sf == null) {
            String msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_PropertyNotFoundInModelInstanceElement;
            msg = NLS.bind (msg, property, this.myEObject);
            throw new PropertyAccessException (msg);
        }
        Object adapteeResult = this.myEObject.eGet (sf);
        result = AbstractModelInstance.adaptInvocationResult (adapteeResult, property.getType (), this.myFactory);
    }
    return result;
}


-----Function Pair=131=-----==

private final BaseStorable loadBaseStorable (String className, IdealizeClassLoader loader) throws IdealizeConfigurationException {
    BaseStorable storable = null;
    try {
        storable = (BaseStorable) loader.loadClass (className).getConstructor ().newInstance ();
    } catch (IllegalArgumentException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (SecurityException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (InstantiationException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (IllegalAccessException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (InvocationTargetException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (NoSuchMethodException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    } catch (ClassNotFoundException e) {
        throw new IdealizeConfigurationException (this.getClass ().getCanonicalName () + ".loadBaseStorable: Could not load storable: " + className, e);
    }
    return storable;
}


private static void getcompletionname () throws TestException {
    Field f;
    Method m;
    String name;
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.x)");
        f = RJavaTools_Test.class.getField ("x");
        if (! "x".equals (RJavaTools.getCompletionName (f))) {
            throw new TestException ("getCompletionName(RJavaTools_Test.x) != 'x' ");
        }
        System.out.println (" == 'x' : ok ");
    } catch (NoSuchFieldException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.static_x)");
        f = RJavaTools_Test.class.getField ("static_x");
        if (! "static_x".equals (RJavaTools.getCompletionName (f))) {
            throw new TestException ("getCompletionName(RJavaTools_Test.static_x) != 'static_x' ");
        }
        System.out.println (" == 'static_x' : ok ");
    } catch (NoSuchFieldException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.getX() )");
        m = RJavaTools_Test.class.getMethod ("getX", (Class []) null);
        if (! "getX()".equals (RJavaTools.getCompletionName (m))) {
            System.err.println (RJavaTools.getCompletionName (m));
            throw new TestException ("getCompletionName(RJavaTools_Test.getX() ) != ''getX()' ");
        }
        System.out.println (" == 'getX()' : ok ");
    } catch (NoSuchMethodException e) {
        throw new TestException (e.getMessage ());
    }
    try {
        System.out.print ("    * getCompletionName(RJavaTools_Test.setX( Integer ) )");
        m = RJavaTools_Test.class.getMethod ("setX", new Class [] {Integer.class});
        if (! "setX(".equals (RJavaTools.getCompletionName (m))) {
            System.err.println (RJavaTools.getCompletionName (m));
            throw new TestException ("getCompletionName(RJavaTools_Test.setX(Integer) ) != 'setX(' ");
        }
        System.out.println (" == 'setX(' : ok ");
    } catch (NoSuchMethodException e) {
        throw new TestException (e.getMessage ());
    }
}


-----Function Pair=132=-----==

protected String append (String key, String value, String separator) {
    String oldValue = getProperty (key);
    String newValue;
    value = normalize (expandString (key, value));
    if (oldValue != null) {
        StringBuilder sb = new StringBuilder (oldValue);
        if (separator != null) {
            sb.append (separator);
        }
        sb.append (value);
        newValue = sb.toString ();
    }
    else {
        newValue = value;
    }
    super.put (key, newValue);
    notifyPropertyChangeListeners (key, oldValue, newValue);
    return oldValue;
}


private NamedObject getAlias (ParserXML.Attr [] addAttrTmp, String flag, Object parent) throws IOException {
    aliasNameMissing = false;
    ParserXML.Attr attr = addAttrTmp [0];
    String fieldName = null;
    String aliasName = null;
    if (flag.equals (XMLSerialize.ALIAS_TAG_TOKEN)) {
        if (! attr.isEnd) {
            do {
                if (attr.name.equals (XMLSerialize.NAME_TOKEN)) {
                    if (fieldName != null) throw new ParserXML.ExceptionXML ("just one name field");
                    fieldName = attr.value;
                }
                else if (attr.name.equals (XMLSerialize.ALIAS_ATTR_TOKEN)) {
                    if (aliasName != null) throw new ParserXML.ExceptionXML ("just one alias name");
                    aliasName = attr.value;
                }
                else throw new ParserXML.ExceptionXML ("unknown attribute: " + attr.name);
            }
            while (! (attr = p.readAttr ()).isEnd);
        }
        if (! attr.emptyTag) {
            ParserXML.Tag closeTag = p.readTag ();
            if (! closeTag.name.equals (XMLSerialize.ALIAS_TAG_TOKEN)) throw new ParserXML.ExceptionXML (XMLSerialize.ALIAS_TAG_TOKEN, closeTag.name);
        }
        Object me = aliasHash.get (aliasName);
        if (me == null) {
            throw new ParserXML.ExceptionXML ("alias target '" + aliasName + "' not found");
        }
        if (parent != null) {
            if (fieldName == null) aliasNameMissing = true;
            else {
                currentGetField.putObj (fieldName, me);
                Field f = getAllField (parent.getClass (), fieldName);
                setFinal (f, parent, me);
            }
        }
        return new NamedObject (fieldName, me, ! aliasNameMissing);
    }
    else return null;
}


-----Function Pair=133=-----==

protected boolean createNextMultivalProps () throws PropertyException {
    currentPropsIteration = (currentPropsIteration + 1) % propsRepeat;
    if (currentPropsIteration == 0) {
        if (multivalProps == null) {
            if (extProps instanceof MultivaluedProperties) {
                multivalProps = (MultivaluedProperties) extProps;
            }
            else {
                multivalProps = new MultivaluedProperties (extProps.getMap ());
            }
        }
        else {
            if (! multivalProps.setNextParameterValues ()) {
                return false;
            }
        }
    }
    multivalProps.updateParameterValues ();
    configureMaximumRunParameters ();
    return true;
}


private static ModelInstance loadBinaryCosmicSceneGraph (RRL rrl) {
    if (csgLoader == null) csgLoader = new CsgLoader ();
    URL url = Repository.get ().getResource (rrl);
    DataInputStream dis = null;
    try {
        dis = new DataInputStream (new BufferedInputStream (url.openStream (), bufferSize));
    } catch (IOException ex) {
        Logger.getLogger (CosmicLoader.class.getName ()).log (Level.SEVERE, null, ex);
    }
    String name = FileUtils.getFileNameWithoutExtension (rrl.getRelativePath ());
    ModelInstance result = new ModelInstance (name);
    result.addChild (csgLoader.loadMain (dis));
    PMeshMaterial mat = Repository.get ().getDefaultMaterial ();
    PNodeUtils.setMaterialOnGraph (mat, result, true, true);
    result.setExternalReference (rrl);
    return result;
}


-----Function Pair=134=-----==

static void marshalFaultResponse (Throwable throwable, MarshalServiceRuntimeDescription marshalDesc, OperationDescription operationDesc, Message message) {
    Throwable t = ClassUtils.getRootCause (throwable);
    if (log.isDebugEnabled ()) {
        log.debug ("Marshal Throwable =" + throwable.getClass ().getName ());
        log.debug ("  rootCause =" + t.getClass ().getName ());
        log.debug ("  exception=" + t.toString ());
        log.debug ("  stack=" + stackToString (t));
    }
    XMLFault xmlfault = null;
    try {
        FaultDescription fd = operationDesc.resolveFaultByExceptionName (t.getClass ().getCanonicalName ());
        if (fd != null) {
            if (log.isErrorEnabled ()) {
                log.debug ("Marshal as a Service Exception");
            }
            JAXBBlockContext context = new JAXBBlockContext (marshalDesc.getPackages ());
            Object faultBeanObject = null;
            FaultBeanDesc faultBeanDesc = marshalDesc.getFaultBeanDesc (fd);
            String faultInfo = fd.getFaultInfo ();
            if (faultInfo == null || faultInfo.length () == 0) {
                faultBeanObject = LegacyExceptionUtil.createFaultBean (t, fd, marshalDesc);
            }
            else {
                Method getFaultInfo = t.getClass ().getMethod ("getFaultInfo", null);
                faultBeanObject = getFaultInfo.invoke (t, null);
            }
            if (log.isErrorEnabled ()) {
                log.debug ("The faultBean type is" + faultBeanObject.getClass ().getName ());
            }
            if (faultBeanObject == t || (context.getConstructionType () != JAXBUtils.CONSTRUCTION_TYPE.BY_CONTEXT_PATH && isNotJAXBRootElement (faultBeanObject.getClass (), marshalDesc))) {
                context.setProcessType (faultBeanObject.getClass ());
            }
            QName faultBeanQName = new QName (faultBeanDesc.getFaultBeanNamespace (), faultBeanDesc.getFaultBeanLocalName ());
            if (! marshalDesc.getAnnotationDesc (faultBeanObject.getClass ()).hasXmlRootElement ()) {
                faultBeanObject = new JAXBElement (faultBeanQName, faultBeanObject.getClass (), faultBeanObject);
            }
            Block [] detailBlocks = new Block [1];
            detailBlocks [0] = factory.createFrom (faultBeanObject, context, faultBeanQName);
            if (log.isDebugEnabled ()) {
                log.debug ("Create the xmlFault for the Service Exception");
            }
            String text = t.getMessage ();
            if (text == null || text.length () == 0) {
                text = t.toString ();
            }
            xmlfault = new XMLFault (null, new XMLFaultReason (text), detailBlocks);
        }
        else {
            xmlfault = createXMLFaultFromSystemException (t);
        }
    } catch (Throwable e) {
        if (log.isDebugEnabled ()) {
            log.debug ("An exception (" + e + ") occurred while marshalling exception (" + t + ")");
        }
        WebServiceException wse = ExceptionFactory.makeWebServiceException (e);
        xmlfault = createXMLFaultFromSystemException (wse);
    }
    message.setXMLFault (xmlfault);
}


public void run () {
    Class target = Target.class;
    Method meth = null;
    Field field = null;
    boolean excep;
    try {
        meth = target.getMethod ("myMethod", new Class [] {int.class});
        if (meth.getDeclaringClass () != target) throw new RuntimeException ();
        printMethodInfo (meth);
        meth = target.getMethod ("myMethod", new Class [] {float.class});
        printMethodInfo (meth);
        meth = target.getMethod ("myNoargMethod", (Class []) null);
        printMethodInfo (meth);
        meth = target.getMethod ("myMethod", new Class [] {String [].class, float.class, char.class});
        printMethodInfo (meth);
        Target instance = new Target ();
        Object [] argList = new Object [] {new String [] {"hi there"}, new Float (3.1415926f), new Character ('Q')};
        System.out.println ("Before, float is " + ((Float) argList [1]).floatValue ());
        Integer boxval;
        boxval = (Integer) meth.invoke (instance, argList);
        System.out.println ("Result of invoke: " + boxval.intValue ());
        System.out.println ("Calling no-arg void-return method");
        meth = target.getMethod ("myNoargMethod", (Class []) null);
        meth.invoke (instance, (Object []) null);
        meth = target.getMethod ("throwingMethod", (Class []) null);
        try {
            meth.invoke (instance, (Object []) null);
            System.out.println ("GLITCH: didn't throw");
        } catch (InvocationTargetException ite) {
            System.out.println ("Invoke got expected exception:");
            System.out.println (ite.getClass ().getName ());
            System.out.println (ite.getCause ());
        } catch (Exception ex) {
            System.out.println ("GLITCH: invoke got wrong exception:");
            ex.printStackTrace ();
        }
        System.out.println ("");
        field = target.getField ("string1");
        if (field.getDeclaringClass () != target) throw new RuntimeException ();
        printFieldInfo (field);
        String strVal = (String) field.get (instance);
        System.out.println ("  string1 value is '" + strVal + "'");
        showStrings (instance);
        field.set (instance, new String ("a new string"));
        strVal = (String) field.get (instance);
        System.out.println ("  string1 value is now '" + strVal + "'");
        showStrings (instance);
        try {
            field.set (instance, new Object ());
            System.out.println ("WARNING: able to store Object into String");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected illegal obj store exc");
        }
        try {
            String four;
            field = target.getField ("string4");
            four = (String) field.get (instance);
            System.out.println ("WARNING: able to access string4: " + four);
        } catch (IllegalAccessException iae) {
            System.out.println ("  got expected access exc");
        } catch (NoSuchFieldException nsfe) {
            System.out.println ("  got the other expected access exc");
        }
        try {
            String three;
            field = target.getField ("string3");
            three = (String) field.get (this);
            System.out.println ("WARNING: able to get string3 in wrong obj: " + three);
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected arg exc");
        }
        String four;
        field = target.getDeclaredField ("string3");
        field.set (instance, null);
        long longVal;
        field = target.getField ("pubLong");
        longVal = field.getLong (instance);
        System.out.println ("pubLong initial value is " + Long.toHexString (longVal));
        field.setLong (instance, 0x9988776655443322L);
        longVal = field.getLong (instance);
        System.out.println ("pubLong new value is " + Long.toHexString (longVal));
        field = target.getField ("superInt");
        if (field.getDeclaringClass () == target) throw new RuntimeException ();
        printFieldInfo (field);
        int intVal = field.getInt (instance);
        System.out.println ("  superInt value is " + intVal);
        Integer boxedIntVal = (Integer) field.get (instance);
        System.out.println ("  superInt boxed is " + boxedIntVal);
        field.set (instance, new Integer (20202));
        intVal = field.getInt (instance);
        System.out.println ("  superInt value is now " + intVal);
        field.setShort (instance, (short) 30303);
        intVal = field.getInt (instance);
        System.out.println ("  superInt value (from short) is now " + intVal);
        field.setInt (instance, 40404);
        intVal = field.getInt (instance);
        System.out.println ("  superInt value is now " + intVal);
        try {
            field.set (instance, new Long (123));
            System.out.println ("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected long->int failure");
        }
        try {
            field.setLong (instance, 123);
            System.out.println ("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected long->int failure");
        }
        try {
            field.set (instance, new String ("abc"));
            System.out.println ("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected string->int failure");
        }
        try {
            field.getShort (instance);
            System.out.println ("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected int->short failure");
        }
        field = target.getField ("superClassInt");
        printFieldInfo (field);
        int superClassIntVal = field.getInt (instance);
        System.out.println ("  superClassInt value is " + superClassIntVal);
        field = target.getField ("staticDouble");
        printFieldInfo (field);
        double staticDoubleVal = field.getDouble (null);
        System.out.println ("  staticDoubleVal value is " + staticDoubleVal);
        try {
            field.getLong (instance);
            System.out.println ("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println ("  got expected double->long failure");
        }
        excep = false;
        try {
            field = target.getField ("aPrivateInt");
            printFieldInfo (field);
        } catch (NoSuchFieldException nsfe) {
            System.out.println ("as expected: aPrivateInt not found");
            excep = true;
        }
        if (! excep) System.out.println ("BUG: got aPrivateInt");
        field = target.getField ("constantString");
        printFieldInfo (field);
        String val = (String) field.get (instance);
        System.out.println ("  Constant test value is " + val);
        field = target.getField ("cantTouchThis");
        printFieldInfo (field);
        intVal = field.getInt (instance);
        System.out.println ("  cantTouchThis is " + intVal);
        try {
            field.setInt (instance, 99);
            System.out.println ("ERROR: set-final succeeded\n");
        } catch (IllegalAccessException iae) {
            System.out.println ("  got expected set-final failure\n");
        }
        intVal = field.getInt (instance);
        System.out.println ("  cantTouchThis is now " + intVal);
        Constructor < Target > cons;
        Target targ;
        Object [] args;
        cons = target.getConstructor (new Class [] {int.class, float.class});
        args = new Object [] {new Integer (7), new Float (3.3333)};
        System.out.println ("cons modifiers=" + cons.getModifiers ());
        targ = cons.newInstance (args);
        targ.myMethod (17);
    } catch (Exception ex) {
        System.out.println ("----- unexpected exception -----");
        ex.printStackTrace ();
    }
    System.out.println ("ReflectTest done!");
}


-----Function Pair=135=-----=1=

protected SystemConfiguration createAgentSystemConfiguration (ExtendedProperties < String, String > systemExtProps) throws AgSysLibException {
    SystemConfiguration systemConfiguration;
    String configurationClassName = extProps.getString ("system.configuration.class", null);
    if (configurationClassName == null) {
        systemConfiguration = createSystemConfiguration (systemExtProps);
    }
    else {
        try {
            Class < ? > configurationClass = Class.forName (configurationClassName);
            Constructor < ? > initializerCtor = configurationClass.getConstructor (AbstractInitializer.class, ExtendedProperties.class);
            systemConfiguration = (SystemConfiguration) initializerCtor.newInstance (this, systemExtProps);
        } catch (Exception e) {
            throw new AgSysLibException ("Cannot create tspSystemConfiguration.", e);
        }
    }
    systemConfiguration.initialize ();
    return systemConfiguration;
}


private void addTavernaMenu () {
    if (! Boolean.parseBoolean (Config.config.getProperty ("Taverna.Enable"))) {
        return;
    }
    String value = Config.language.getProperty ("Menu.Taverna");
    if (value == null) {
        throw new RuntimeException ("Key \"Menu.Taverna\" is missing from the language file");
    }
    JMenu tavernaMenu = new JMenu (value);
    this.add (tavernaMenu);
    tavernaMenu.setMnemonic ('v');
    Frame parentFrame = this.getParentFrame ();
    Class < TavernaApi > clazz;
    try {
        URLClassLoader ucl = OVTK2PluginLoader.getInstance ().ucl;
        Thread.currentThread ().setContextClassLoader (ucl);
        String classname = "net.sourceforge.ondex.taverna.TavernaWrapper";
        clazz = (Class < TavernaApi >) ucl.loadClass (classname);
    } catch (Exception e) {
        e.printStackTrace ();
        System.err.println ("No TavernaWrapper found. ");
        System.err.println (e.getMessage ());
        JMenuItem missing = makeMenuItem ("Menu.Taverna.Missing", "TavernaMissing");
        NoTavernaMenuAction helpListener = new NoTavernaMenuAction ();
        desktop.addActionListener (helpListener);
        tavernaMenu.add (missing);
        return;
    }
    try {
        Constructor < TavernaApi > constructor = clazz.getConstructor (parentFrame.getClass ());
        TavernaApi travernaApi = constructor.newInstance (parentFrame);
        travernaApi.attachMenu (tavernaMenu);
        travernaApi.setTavernaHome (Config.config.getProperty ("Taverna.TravenaHome"));
        travernaApi.setDataViewerHome (Config.config.getProperty ("Taverna.DataViewerHomer"));
        File dataDir = new File (net.sourceforge.ondex.config.Config.ondexDir);
        travernaApi.setRootDirectory (dataDir);
        Icon icon = new ImageIcon ("config/toolbarButtonGraphics/taverna/taverna.jpeg");
    } catch (Exception e) {
        ErrorDialog.show (e);
    }
}


-----Function Pair=136=-----==

public void actionPerformed (ActionEvent e) {
    String type = (String) typeCombo.getSelectedItem ();
    if (type.equals ("<Must Choose>")) {
        nameText.setEditable (false);
        channelCombo.setEnabled (false);
        backgroundCBox.setEnabled (false);
        scaleCombo.setEnabled (false);
        dTypeCombo.setEnabled (false);
    }
    else {
        nameText.setEditable (true);
        channelCombo.setEnabled (true);
        backgroundCBox.setEnabled (true);
        scaleCombo.setEnabled (true);
        dTypeCombo.setEnabled (true);
        if (type.equals ("PValue") || type.equals ("Error") || type.equals ("ExpectedValue")) {
            confIndText.setEditable (true);
        }
        else {
            confIndText.setEditable (false);
        }
    }
}


public static void bootstrap (String [] args) {
    System.out.println ("JRIBootstrap(" + args + ")");
    try {
        System.loadLibrary ("boot");
    } catch (Exception e) {
        fail ("Unable to load boot library!");
    }
    String rhome = findR (true);
    if (rhome == null) fail ("Unable to find R!");
    if (isWin32) {
        String path = getenv ("PATH");
        if (path == null || path.length () < 1) path = rhome + "\\bin";
        else path = rhome + "\\bin;" + path;
        setenv ("PATH", path);
    }
    setREnv ();
    System.out.println ("PATH=" + getenv ("PATH") + "\nR_LIBS=" + getenv ("R_LIBS"));
    if (! isMac && ! isWin32) {
        String stage = System.getProperty ("stage");
        if (stage == null || stage.length () < 1) {
            File jl = new File (u2w (System.getProperty ("java.home") + "/bin/java"));
            if (jl.exists ()) {
                try {
                    System.out.println (jl.toString () + " -cp " + System.getProperty ("java.class.path") + " -Xmx512m -Dstage=2 Boot");
                    Process p = Runtime.getRuntime ().exec (new String [] {jl.toString (), "-cp", System.getProperty ("java.class.path"), "-Xmx512m", "-Dstage=2", "Boot"});
                    System.out.println ("Started stage 2 (" + p + "), waiting for it to finish...");
                    System.exit (p.waitFor ());
                } catch (Exception re) {
                }
            }
        }
    }
    String needPkg = null;
    String rj = findPackage ("rJava");
    if (rj == null) {
        System.err.println ("**ERROR: rJava is not installed");
        if (needPkg == null) needPkg = "'rJava'";
        else needPkg += ",'rJava'";
    }
    String ipl = findPackage ("iplots");
    if (ipl == null) {
        System.err.println ("**ERROR: iplots is not installed");
        if (needPkg == null) needPkg = "'iplots'";
        else needPkg += ",'iplots'";
    }
    String jgr = findPackage ("JGR");
    if (jgr == null) {
        System.err.println ("**ERROR: JGR is not installed");
        if (needPkg == null) needPkg = "'JGR'";
        else needPkg += ",'JGR'";
    }
    if (needPkg != null) {
        if (! isWin32 && ! isMac) {
            System.err.println ("*** Please run the following in R as root to install missing packages:\n install.packages(c(" + needPkg + "),,'http://www.rforge.net/')");
            System.exit (4);
        }
        if (execR ("install.packages(c(" + needPkg + "),,c('http://www.rforge.net/','http://cran.r-project.org'))") != 0) {
            System.err.println ("*** ERROR: failed to install necessary packages");
            System.exit (4);
        }
        rj = findPackage ("rJava");
        ipl = findPackage ("iplots");
        jgr = findPackage ("JGR");
        if (rj == null || ipl == null || jgr == null) {
            System.err.println ("*** ERROR: failed to find installed packages");
            System.exit (5);
        }
    }
    Object o = bootRJavaLoader = createRJavaLoader (rhome, new String [] {"main"}, true);
    addClassPath (u2w (jgr + "/cont/JGR.jar"));
    addClassPath (u2w (ipl + "/cont/iplots.jar"));
    String mainClass = "org.rosuda.JGR.JGR";
    try {
        Method m = o.getClass ().getMethod ("bootClass", new Class [] {String.class, String.class, String [].class});
        m.invoke (o, new Object [] {mainClass, "main", args});
    } catch (Exception ie) {
        System.out.println ("cannot boot the final class: " + ie);
        ie.printStackTrace ();
    }
}


-----Function Pair=137=-----==

public RemoteFacade doWork (Properties classes, IdealizeClassLoader loader) throws IdealizeConfigurationException, IdealizeUnavailableResourceException, RemoteException {
    boolean useLogging = this.loadBoolean (classes, this.KEY_USE_LOGGING);
    if (useLogging) {
        String warnPath = classes.getProperty (this.KEY_LOG_WARN_PATH);
        String errorPath = classes.getProperty (this.KEY_LOG_ERROR_PATH);
        String fatalPath = classes.getProperty (this.KEY_LOG_FATAL_PATH);
        IdealizeLogger.init (useLogging, warnPath, errorPath, fatalPath);
    }
    else IdealizeLogger.init (useLogging, null, null, null);
    this.setTimeOutRmi ();
    CBBatchConstants.FIELD_SEPARATOR_FOR_NETWORK = classes.getProperty (this.KEY_NETWORK_SEPARATOR);
    CBBatchConstants.DATA_STORAGE_PATH = classes.getProperty (this.KEY_DATA_STORAGE_PATH);
    CBBatchConstants.ALLOW_REMOTE_COMPONENTS = Boolean.parseBoolean (classes.getProperty (this.KEY_ALLOW_REMOTE_COMPONENTS));
    CBBatchConstants.CB_CONFIGURATION_FILE = classes.getProperty (this.KEY_CB_CONFIGURATION_FILE);
    boolean allowedSeparator = false;
    for (int i = CBBatchConstants.ALLOWED_SEPARATORS.length; -- i >= 0;) if (CBBatchConstants.FIELD_SEPARATOR_FOR_NETWORK.equals (CBBatchConstants.ALLOWED_SEPARATORS [i])) {
        allowedSeparator = true;
        break;
    }
    if (! allowedSeparator) throw new IdealizeConfigurationException (this.canonicalName + ".instantiate(): network separator not allowed: " + CBBatchConstants.FIELD_SEPARATOR_FOR_NETWORK);
    CBBatchConstants.USING_META_RECOMMENDER = Boolean.getBoolean (classes.getProperty (this.KEY_USING_META_RECOMMENDER));
    CBBatchConstants.STATIC_RECOMMENDER = this.loadInteger (classes, this.canonicalName + ": invalid static recommender: ", this.KEY_STATIC_RECOMMENDER);
    IdealizeDataModel dataModel = null;
    BatchProcessor batchProcessor = null;
    IdealizeRecommender recommender = null;
    Controller controller = this.loadController (classes, loader);
    boolean cache = false;
    if (dataModel == null) {
        dataModel = DataModelFactory.createDataModel (Integer.parseInt (classes.getProperty (this.KEY_DATA_MODEL)), cache, CBBatchConstants.DATA_STORAGE_PATH);
    }
    try {
        recommender = (IdealizeCBAbstractRecommender) RecommenderFactory.getRecommenderBuilder (CBBatchConstants.STATIC_RECOMMENDER, dataModel);
    } catch (TasteException e) {
        try {
            throw new IdealizeCoreException (this.canonicalName + ".doWok(): could not create recommender: " + e.getMessage (), e);
        } catch (IdealizeCoreException e1) {
            e1.printStackTrace ();
        }
    }
    CBStorableRecommender data = new CBStorableRecommender ((IdealizeCBAbstractRecommender) recommender);
    Cache.getInstance ().setData (data, false);
    try {
        if (batchProcessor == null) {
            batchProcessor = this.loadBatchProcessor (classes, loader);
            controller.setBatchProcessor (batchProcessor);
            batchProcessor.process (true);
        }
        else batchProcessor.process (false);
    } catch (IdealizeInputException e) {
        throw new IdealizeConfigurationException (this.canonicalName + ".doWork: problems with input for batch processor: " + e.getMessage (), e);
    } catch (IdealizeCoreException e) {
        throw new IdealizeConfigurationException (this.canonicalName + ".doWork: problems while executing batch processing: " + e.getMessage (), e);
    } catch (RemoteException e) {
        throw new IdealizeConfigurationException (this.canonicalName + ".doWork: problems while executing batch processing: " + e.getMessage (), e);
    }
    InputInterpreter interpreter = this.loadInputInterpreter (classes, loader, CBBatchConstants.FIELD_SEPARATOR_FOR_NETWORK);
    RecommendationSerializer serializer = this.loadRecommendationSerializer (classes, loader);
    InputInterpreter feedbackInterpreter = this.loadFeedbackInterpreter (classes, loader, CBBatchConstants.FIELD_SEPARATOR_FOR_NETWORK);
    IdealizeRecommenderFacade facade = new IdealizeRecommenderFacade ();
    facade.setController (controller);
    facade.setInputInterpreter (interpreter);
    facade.setSerializer (serializer);
    facade.setFeedbackInputInterpreter (feedbackInterpreter);
    if (CBBatchConstants.ALLOW_REMOTE_COMPONENTS) this.registerRemoteFacade (facade);
    return facade;
}


public CommandBar createMenus () {
    JMenuItem mi;
    CommandBar menuBar = new CommandMenuBar ("Menu Bar");
    menuBar.setStretch (true);
    menuBar.getAccessibleContext ().setAccessibleName (getString ("MenuBar.accessible_description"));
    JideMenu fileMenu = (JideMenu) menuBar.add (new JideMenu (getString ("FileMenu.file_label")));
    fileMenu.setMnemonic (getMnemonic ("FileMenu.file_mnemonic"));
    fileMenu.getAccessibleContext ().setAccessibleDescription (getString ("FileMenu.accessible_description"));
    createMenuItem (fileMenu, "FileMenu.about_label", "FileMenu.about_mnemonic", "FileMenu.about_accessible_description", new AboutAction (this));
    fileMenu.addSeparator ();
    createMenuItem (fileMenu, "FileMenu.open_label", "FileMenu.open_mnemonic", "FileMenu.open_accessible_description", null);
    createMenuItem (fileMenu, "FileMenu.save_label", "FileMenu.save_mnemonic", "FileMenu.save_accessible_description", null);
    createMenuItem (fileMenu, "FileMenu.save_as_label", "FileMenu.save_as_mnemonic", "FileMenu.save_as_accessible_description", null);
    if (! isApplet ()) {
        fileMenu.addSeparator ();
        createMenuItem (fileMenu, "FileMenu.exit_label", "FileMenu.exit_mnemonic", "FileMenu.exit_accessible_description", new ExitAction (this));
    }
    if (numSSs == 0) {
        lafMenu = (JideMenu) menuBar.add (new JideMenu (getString ("LafMenu.laf_label")));
        lafMenu.setMnemonic (getMnemonic ("LafMenu.laf_mnemonic"));
        lafMenu.getAccessibleContext ().setAccessibleDescription (getString ("LafMenu.laf_accessible_description"));
        createLafMenuItem (lafMenu, "LafMenu.java_label", "LafMenu.java_mnemonic", "LafMenu.java_accessible_description", metal);
        createLafMenuItem (lafMenu, "LafMenu.mac_label", "LafMenu.mac_mnemonic", "LafMenu.mac_accessible_description", mac);
        createLafMenuItem (lafMenu, "LafMenu.motif_label", "LafMenu.motif_mnemonic", "LafMenu.motif_accessible_description", motif);
        UIManager.LookAndFeelInfo [] lafInfo = UIManager.getInstalledLookAndFeels ();
        for (int counter = 0; counter < lafInfo.length; counter ++) {
            if (lafInfo [counter].getName ().toLowerCase ().indexOf ("windows") != - 1) {
                mi = createLafMenuItem (lafMenu, "LafMenu.windows_label", "LafMenu.windows_mnemonic", "LafMenu.windows_accessible_description", windows);
                mi.setSelected (true);
            }
        }
        for (int counter = 0; counter < lafInfo.length; counter ++) {
            if (lafInfo [counter].getName ().toLowerCase ().indexOf ("gtk") != - 1) {
                createLafMenuItem (lafMenu, "LafMenu.gtk_label", "LafMenu.gtk_mnemonic", "LafMenu.gtk_accessible_description", gtk);
                break;
            }
        }
        themesMenu = (JideMenu) menuBar.add (new JideMenu (getString ("ThemesMenu.themes_label")));
        themesMenu.setMnemonic (getMnemonic ("ThemesMenu.themes_mnemonic"));
        themesMenu.getAccessibleContext ().setAccessibleDescription (getString ("ThemesMenu.themes_accessible_description"));
        audioMenu = (JideMenu) themesMenu.add (new JideMenu (getString ("AudioMenu.audio_label")));
        audioMenu.setMnemonic (getMnemonic ("AudioMenu.audio_mnemonic"));
        audioMenu.getAccessibleContext ().setAccessibleDescription (getString ("AudioMenu.audio_accessible_description"));
        createAudioMenuItem (audioMenu, "AudioMenu.on_label", "AudioMenu.on_mnemonic", "AudioMenu.on_accessible_description", new OnAudioAction (this));
        mi = createAudioMenuItem (audioMenu, "AudioMenu.default_label", "AudioMenu.default_mnemonic", "AudioMenu.default_accessible_description", new DefaultAudioAction (this));
        mi.setSelected (true);
        createAudioMenuItem (audioMenu, "AudioMenu.off_label", "AudioMenu.off_mnemonic", "AudioMenu.off_accessible_description", new OffAudioAction (this));
        createThemesMenuItem (themesMenu, "ThemesMenu.aqua_label", "ThemesMenu.aqua_mnemonic", "ThemesMenu.aqua_accessible_description", new AquaTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.charcoal_label", "ThemesMenu.charcoal_mnemonic", "ThemesMenu.charcoal_accessible_description", new CharcoalTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.contrast_label", "ThemesMenu.contrast_mnemonic", "ThemesMenu.contrast_accessible_description", new ContrastTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.emerald_label", "ThemesMenu.emerald_mnemonic", "ThemesMenu.emerald_accessible_description", new EmeraldTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.ruby_label", "ThemesMenu.ruby_mnemonic", "ThemesMenu.ruby_accessible_description", new RubyTheme ());
        toolTipMenu = (JideMenu) menuBar.add (new JideMenu (getString ("ToolTipMenu.tooltip_label")));
        toolTipMenu.setMnemonic (getMnemonic ("ToolTipMenu.tooltip_mnemonic"));
        toolTipMenu.getAccessibleContext ().setAccessibleDescription (getString ("ToolTipMenu.tooltip_accessible_description"));
        mi = createToolTipMenuItem (toolTipMenu, "ToolTipMenu.on_label", "ToolTipMenu.on_mnemonic", "ToolTipMenu.on_accessible_description", new ToolTipAction (this, true));
        mi.setSelected (true);
        createToolTipMenuItem (toolTipMenu, "ToolTipMenu.off_label", "ToolTipMenu.off_mnemonic", "ToolTipMenu.off_accessible_description", new ToolTipAction (this, false));
    }
    if (! isApplet ()) {
        GraphicsDevice [] screens = GraphicsEnvironment.getLocalGraphicsEnvironment ().getScreenDevices ();
        if (screens.length > 1) {
            JideMenu multiScreenMenu = (JideMenu) menuBar.add (new JideMenu (getString ("MultiMenu.multi_label")));
            multiScreenMenu.setMnemonic (getMnemonic ("MultiMenu.multi_mnemonic"));
            multiScreenMenu.getAccessibleContext ().setAccessibleDescription (getString ("MultiMenu.multi_accessible_description"));
            createMultiscreenMenuItem (multiScreenMenu, MultiScreenAction.ALL_SCREENS);
            for (int i = 0; i < screens.length; i ++) {
                createMultiscreenMenuItem (multiScreenMenu, i);
            }
        }
    }
    return menuBar;
}


-----Function Pair=138=-----==

private void updateComp (boolean resize) {
    if (swingComp != null) {
        swingComp.getComponent ().setFont (theFont);
        if (resize) {
            Dimension d = swingComp.getComponent ().getPreferredSize ();
            if (d.width < 8) d.width = 8;
            if (d.height < 8) d.height = 8;
            if ((summit [2].x - summit [0].x <= d.width) || (summit [6].y - summit [0].y <= d.height)) {
                double x = summit [0].x + d.width;
                double y = summit [0].y + d.height;
                summit [2].x = x;
                summit [4].x = x;
                summit [4].y = y;
                summit [6].y = y;
                centerSummit ();
                updateShape ();
            }
        }
    }
}


public void adjustColumnWidth (String columnName, int width) throws KExceptionClass {
    if (! tableLoaded) throw new KExceptionClass ("*** Method calling error **** \n" + "'setColumnWidth' method is called in wrong order !", null);
    TableColumn theColumn;
    try {
        theColumn = visualTable.getColumn (columnName);
        theColumn.setPreferredWidth (width);
    } catch (Exception error) {
        log.log (this, KMetaUtilsClass.getStackTrace (error));
        String message;
        message = "*** Colud not display table *** [";
        message += error.toString ();
        message += "]\n Column not found in display -> [" + columnName + "]";
        KMetaUtilsClass.showErrorMessageFromException (parentWindow, error);
    }
}


-----Function Pair=139=-----==

public static void deleteRecursively1 (Path dir) throws IOException {
    Files.walkFileTree (dir, new SimpleFileVisitor < Path > () {
        @Override
        public FileVisitResult visitFile (Path file, BasicFileAttributes attrs) throws IOException {
            Files.delete (file);
            return FileVisitResult.CONTINUE;
        }@Override
        public FileVisitResult visitFileFailed (Path file, IOException exc) throws IOException {
            Files.delete (file);
            return FileVisitResult.CONTINUE;
        }@Override
        public FileVisitResult postVisitDirectory (Path dir, IOException exc) throws IOException {
            if (exc == null) {
                Files.delete (dir);
                return FileVisitResult.CONTINUE;
            }
            else {
                throw exc;
            }
        }
    }
    );
}


public void invalidate () {
    try {
        if (this.invalidate == null) {
            this.invalidate = this.delegate.getClass ().getMethod ("invalidate", (Class []) null);
        }
        this.invalidate.invoke (this.delegate, (Object []) null);
    } catch (final Exception e) {
    }
    try {
        this.finalize ();
    } catch (final Throwable ignore) {
        if (ignore.getClass () == ThreadDeath.class) {
            throw (ThreadDeath) ignore;
        }
        Throwable cause = ignore.getCause ();
        while (cause != null) {
            if (cause.getClass () == ThreadDeath.class) {
                throw (ThreadDeath) cause;
            }
            cause = cause.getCause ();
        }
    }
}


-----Function Pair=140=-----==

public static void boot () {
    if (initialized) return;
    setNames ();
    for (int i = 0; i < JNIFunctions.length; i ++) {
        JNIFunctions [i] = new int [3] [];
        JNIFunctions [i] [TOC] = VM_Statics.getSlots ();
    }
    try {
        VM_Class cls = VM_Class.forName ("VM_JNIFunctions");
        VM_Method [] mths = cls.getDeclaredMethods ();
        for (int i = 0; i < mths.length; i ++) {
            String methodName = mths [i].getName ().toString ();
            int jniIndex = indexOf (methodName);
            if (jniIndex != - 1) {
                JNIFunctions [jniIndex] [IP] = mths [i].getMostRecentlyGeneratedInstructions ();
            }
        }
        int functionAddress = VM_Magic.objectAsAddress (JNIFunctions [NEWINTARRAY] [IP]);
        functionAddress = VM_Magic.objectAsAddress (JNIFunctions [NEWINTARRAY] [TOC]);
    } catch (VM_ResolutionException e) {
        throw new InternalError ("VM_JNIEnvironment fails to initialize, has the class been renamed\n");
    }
    initialized = true;
}


public void doMoveNodeUp (BaseNodehandler target) {
    BaseNodehandler child = target;
    if (child == null) {
        return;
    }
    BaseNodehandler parent = child.getParentNodehandler ();
    int index = parent.indexOfChild (child);
    if (index > 0) {
        removeNodehandler (child);
        insertNodehandler (parent, child, index - 1);
    }
    else {
        if (parent != root) {
            index = parent.getParentNodehandler ().indexOfChild (parent);
            BaseNodehandler prev = parent.getParentNodehandler ();
            removeNodehandler (child);
            insertNodehandler (prev, child, index);
        }
    }
}


-----Function Pair=141=-----==

public synchronized void disconnect () {
    System.out.println ("Disconnecting");
    if (vc != null) {
        double sec = (System.currentTimeMillis () - vc.statStartTime) / 1000.0;
        double rate = Math.round (vc.statNumUpdates / sec * 100) / 100.0;
        int nRealRects = vc.statNumPixelRects;
        int nPseudoRects = vc.statNumTotalRects - vc.statNumPixelRects;
        System.out.println ("Updates received: " + vc.statNumUpdates + " (" + nRealRects + " rectangles + " + nPseudoRects + " pseudo), " + rate + " updates/sec");
        int numRectsOther = nRealRects - vc.statNumRectsTight - vc.statNumRectsZRLE - vc.statNumRectsHextile - vc.statNumRectsRaw - vc.statNumRectsCopy;
        System.out.println ("Rectangles:" + " Tight=" + vc.statNumRectsTight + "(JPEG=" + vc.statNumRectsTightJPEG + ") ZRLE=" + vc.statNumRectsZRLE + " Hextile=" + vc.statNumRectsHextile + " Raw=" + vc.statNumRectsRaw + " CopyRect=" + vc.statNumRectsCopy + " other=" + numRectsOther);
        int raw = vc.statNumBytesDecoded;
        int compressed = vc.statNumBytesEncoded;
        if (compressed > 0) {
            double ratio = Math.round ((double) raw / compressed * 1000) / 1000.0;
            System.out.println ("Pixel data: " + vc.statNumBytesDecoded + " bytes, " + vc.statNumBytesEncoded + " compressed, ratio " + ratio);
        }
    }
    if (rfb != null && ! rfb.closed ()) rfb.close ();
    options.dispose ();
    clipboard.dispose ();
    if (rec != null) rec.dispose ();
    if (inAnApplet) {
        showMessage ("Disconnected");
    }
    else {
        System.exit (0);
    }
}


public void writePrettyMAGEML () {
    try {
        OutputFormat xmlFormat = new OutputFormat ("xml", "utf-8", true);
        xmlFormat.setLineWidth (60);
        xmlFormat.setLineSeparator ("\n");
        xmlFormat.setIndent (2);
        XMLSerializer xmlWriterDocHndler = new XMLSerializer (System.out, xmlFormat);
        SAXParserFactory factory = SAXParserFactory.newInstance ();
        SAXParser xmlWriterParser = factory.newSAXParser ();
        xmlWriterParser.getXMLReader ().setFeature ("http://xml.org/sax/features/namespaces", true);
        xmlWriterParser.getXMLReader ().setFeature ("http://xml.org/sax/features/namespace-prefixes", false);
        xmlWriterParser.getXMLReader ().setContentHandler (xmlWriterDocHndler);
        xmlWriterParser.getXMLReader ().parse (new InputSource (new FileReader ("./raw.xml")));
    } catch (java.lang.Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=142=-----==

protected void createExtensionDocumentMapping () {
    String staticMappings = ApplicationSetup.getProperty ("indexing.simplefilecollection.extensionsparsers", "txt:FileDocument,text:FileDocument,tex:FileDocument,bib:FileDocument," + "pdf:PDFDocument,html:HTMLDocument,htm:HTMLDocument,xhtml:HTMLDocument,xml:HTMLDocument," + "doc:MSWordDocument,ppt:MSPowerpointDocument,xls:MSExcelDocument");
    String defaultMapping = ApplicationSetup.getProperty ("indexing.simplefilecollection.defaultparser", "");
    if (staticMappings.length () > 0) {
        String [] mappings = staticMappings.split ("\\s*,\\s*");
        for (int i = 0; i < mappings.length; i ++) {
            if (mappings [i].indexOf (":") < 1) continue;
            String [] mapping = mappings [i].split (":");
            if (mapping.length == 2 && mapping [0].length () > 0 && mapping [1].length () > 0) {
                if (mapping [1].indexOf (".") == - 1) mapping [1] = NAMESPACE_DOCUMENTS + mapping [1];
                try {
                    Class d = Class.forName (mapping [1], false, this.getClass ().getClassLoader ());
                    extension_DocumentClass.put (mapping [0].toLowerCase (), d);
                } catch (Exception e) {
                    logger.warn ("Missing class " + mapping [1] + " for " + mapping [0].toLowerCase () + " files.", e);
                }
            }
        }
    }
    if (! defaultMapping.equals ("")) {
        if (defaultMapping.indexOf (".") == - 1) defaultMapping = NAMESPACE_DOCUMENTS + defaultMapping;
        try {
            Class d = Class.forName (defaultMapping, false, this.getClass ().getClassLoader ());
            extension_DocumentClass.put ("|DEFAULT|", d);
        } catch (Exception e) {
        }
    }
}


public static String getCacheDirectory () {
    String cacheDir;
    Object cdir = com.sun.media.util.Registry.get ("secure.cacheDir");
    if ((cdir != null) && (cdir instanceof String)) {
        cacheDir = (String) cdir;
        if (cacheDir.indexOf (fileSeparator) == - 1) {
            if (fileSeparator.equals ("/")) {
                cacheDir = "/tmp";
            }
            else if (fileSeparator.equals ("\\")) {
                cacheDir = "C:" + fileSeparator + "temp";
            }
            else {
                cacheDir = null;
            }
        }
        return cacheDir;
    }
    if (fileSeparator.equals ("/")) {
        cacheDir = "/tmp";
    }
    else if (fileSeparator.equals ("\\")) {
        cacheDir = "C:" + fileSeparator + "temp";
    }
    else {
        cacheDir = null;
    }
    return cacheDir;
}


-----Function Pair=143=-----==

private Object [] exec (Object [] commandLine) {
    Object [] result = new Object [2];
    result [0] = "No command specified";
    result [1] = "Execute";
    if (commandLine == null || commandLine.length < 1) return result;
    String command = (String) commandLine [0];
    result [1] = command;
    String whitelist;
    if (Files.exists ("Colander.whitelist") == false) {
        result [0] = "Execution of native commands is disabled";
        return result;
    }
    try {
        whitelist = Files.read ("Colander.whitelist", "UTF-8");
    } catch (IOException ex) {
        result [0] = "Error accessing whitelist: " + ex.toString ();
        return result;
    }
    boolean match = false;
    StringTokenizer st = new StringTokenizer (whitelist, "\n\r");
    String token;
    while (st.hasMoreTokens ()) {
        token = st.nextToken ();
        if (token.compareTo (command) == 0) {
            match = true;
            break;
        }
    }
    if (match == false) {
        result [0] = "The specified command is not allowed on this server";
        return result;
    }
    StringBuffer outputString = new StringBuffer ();
    try {
        Runtime runtime = Runtime.getRuntime ();
        Process p = runtime.exec (command);
        BufferedReader cmdError = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        BufferedReader cmdOutput = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        String sErr = cmdError.readLine ();
        String sOut = cmdOutput.readLine ();
        while (sErr != null || sOut != null) {
            if (sErr != null) {
                outputString.append (sErr + newline);
                sErr = cmdError.readLine ();
            }
            if (sOut != null) {
                outputString.append (sOut + newline);
                sOut = cmdOutput.readLine ();
            }
        }
        cmdError.close ();
        cmdOutput.close ();
    } catch (IOException ex) {
        outputString = new StringBuffer ("Execute error: " + ex.toString ());
    }
    result [0] = outputString;
    return result;
}


public List < Topic > searchAll (String searchTerm) {
    String query = "select $topic, $score from " + "topic-name($topic, $tn), value-like($tn, %searchTerm%, $score) " + "order by $score desc, $topic?";
    Map < String, String > params = new HashMap < String, String > ();
    params.put ("searchTerm", searchTerm);
    QueryMapper < Topic > qm = newQueryMapperNoWrap ();
    List < Topic > rows = qm.queryForList (query, params);
    Iterator < Topic > it = rows.iterator ();
    List < Topic > results = new ArrayList < Topic > (rows.size ());
    Collection < TopicIF > duplicateChecks = new HashSet < TopicIF > (rows.size ());
    while (it.hasNext ()) {
        TopicIF topic = (TopicIF) it.next ();
        if (duplicateChecks.contains (topic)) continue;
        results.add (new Topic (topic, this));
        duplicateChecks.add (topic);
    }
    return results;
}


-----Function Pair=144=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void actionPerformed (ActionEvent e) {
    setoutdir = outdirfile.getText ();
    Font fn = new Font (ReadfnConf.getFontName (), Font.PLAIN, ReadfnConf.getFontSize ());
    set_fontName = fontNamejb.getSelectedItem ().toString ();
    int fontSize = Integer.parseInt (fontSizejb.getSelectedItem ().toString ());
    set_fontSize = fontSize;
    MutableAttributeSet attr = new SimpleAttributeSet ();
    StyleConstants.setFontFamily (attr, set_fontName);
    StyleConstants.setFontSize (attr, set_fontSize);
    StyleConstants.setForeground (attr, cf);
    StyleConstants.setBackground (attr, cb);
    getDocument ().setCharacterAttributes (0, my_doc.getLength (), attr, false);
    textPaneView.grabFocus ();
    textPaneView.repaint ();
    try {
        FileOutputStream outfo = new FileOutputStream (font_file);
        DataOutputStream outst = new DataOutputStream (outfo);
        outst.writeUTF (" " + "\n" + "FontName:" + set_fontName + "\n" + "FontSize:" + set_fontSize + "\n" + "FontColor:" + cf.getRGB () + "\n" + "FontBgColor:" + cb.getRGB () + "\n" + "WorkingDir:" + setoutdir + "\n" + "OpenLinkWith:" + openLinkWith.getText () + "\n");
        outst.close ();
        outfo.close ();
        top.removeAllChildren ();
        top.removeFromParent ();
        myTreeModel.reload ();
        sourceDir = new File ("" + setoutdir);
        if (! sourceDir.exists ()) warnme ("Directory Not Found");
        else if (sourceDir != null || sourceDir.exists ()) {
            File [] roots = sourceDir.listFiles ();
            for (int k = 0; k < roots.length; k ++) {
                myTreeModel.insertNodeInto (new DefaultMutableTreeNode (new IconData (ICON_FILES, null, roots [k].getName ())), top, k);
            }
            myTree.expandRow (0);
            myTree.repaint ();
        }
        setCurrentFile (sourceDir);
    } catch (IOException ie) {
    }
    j.show ();
}


-----Function Pair=145=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public void processEvents () {
    try {
        Event e = new Event ("AppleScript");
        e.addField ("script", FieldType.STRING, FieldValueTypes.FORMAL, FieldValueTypes.FORMAL);
        e.addField ("Target", hostname);
        Event [] events = new Event [1];
        events [0] = e;
        eheap.registerForEvents (events, new EHListener ());
        while (true) {
            if (latest != null) {
                synchronized (eheap) {
                    if (verifyPermission (latest)) {
                        execute (latest.getPostValueString ("script"));
                    }
                    latest = null;
                }
            }
            else {
                Thread.sleep (100);
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=146=-----==

public double probeEnergy () throws RemoteException {
    float idle_energy1 = Float.parseFloat (idle_energy);
    double utiltopower_factor1 = Double.parseDouble (utiltopower_factor);
    double cpu_util = 10;
    String energy = "";
    double total_energy = 0;
    try {
        Process P = Runtime.getRuntime ().exec (linuxPath + "/you.sh");
        StringBuffer strBuf = new StringBuffer ();
        String strLine = "";
        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));
        while ((strLine = outCommand.readLine ()) != null) {
            energy = strLine;
        }
        P.waitFor ();
        cpu_util = Double.parseDouble (energy);
        total_energy = idle_energy1 + utiltopower_factor1 * cpu_util;
    } catch (Exception e) {
        total_energy = - 1;
        System.out.println (e.getMessage ());
        e.printStackTrace ();
    }
    return total_energy;
}


public void run () {
    System.out.println ("Test STARTED..");
    System.out.println ("Used machines: ");
    String [] machines = this.getMachines ();
    if (machines.length == 0) {
        System.out.println ("\nNo machine is available between nodes: n2-n27! ( Based upon 'linuxall')\n");
        return;
    }
    for (int i = 0; i < this.jobNumber; i ++) {
        String hostname = machines [i % machines.length];
        String rInt = "" + Math.round (Math.random () * 100000);
        StringBuffer rIndex = new StringBuffer ();
        for (int j = 0; j < rInt.length () - 5; j ++) {
            rIndex.append ("0");
        }
        rIndex.append (rInt);
        String jobID = "testJob-" + hostname + "-" + i + "_" + rIndex;
        int msgNumb = this.maxMessageForAJob;
        this.mappings.put (jobID, new Integer (msgNumb));
        this.startAppWithMonitoring (hostname, jobID, msgNumb);
    }
}


-----Function Pair=147=-----==

public void LZWDistance (JTextArea results) {
    int iNumSampleWorks = sampleWorks.size ();
    int iNumTestingWorks = testingWorks.size ();
    Document currSampleWork = null;
    Document currTestingWork = null;
    Vector LZWResults = new Vector ();
    for (int iCounter2 = 0; iCounter2 < iNumTestingWorks; iCounter2 ++) {
        currTestingWork = (Document) testingWorks.elementAt (iCounter2);
        for (int iCounter = 0; iCounter < iNumSampleWorks; iCounter ++) {
            currSampleWork = (Document) sampleWorks.elementAt (iCounter);
            String tempString = null;
            try {
                PrintWriter testingText = new PrintWriter (new BufferedWriter (new FileWriter ("testingText.txt")));
                for (int iCounter3 = 0; iCounter3 < currTestingWork.unsortedTop50.size (); iCounter3 ++) {
                    tempString = (String) currTestingWork.unsortedTop50.elementAt (iCounter3);
                    if (tempString.length () > 1) {
                        testingText.print (tempString + " ");
                    }
                    else {
                        testingText.print (tempString);
                    }
                }
                testingText.close ();
            } catch (Exception e) {
            }
            try {
                PrintWriter sampleText = new PrintWriter (new BufferedWriter (new FileWriter ("sampleText.txt")));
                for (int iCounter3 = 0; iCounter3 < currSampleWork.unsortedTop50.size (); iCounter3 ++) {
                    tempString = (String) currSampleWork.unsortedTop50.elementAt (iCounter3);
                    if (tempString.length () > 1) {
                        sampleText.print (tempString + " ");
                    }
                    else {
                        sampleText.print (tempString);
                    }
                }
                sampleText.close ();
            } catch (Exception e) {
            }
            try {
                PrintWriter output = new PrintWriter (new BufferedWriter (new FileWriter ("tempfile.txt")));
                Process p = Runtime.getRuntime ().exec ("cat testingText.txt sampleText.txt");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) output.print (s);
                    commandResult.close ();
                    output.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("gzip -v -9 tempfile.txt");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) System.out.println (s);
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("gzip -l tempfile.txt.gz");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) {
                        StringTokenizer line = new StringTokenizer (s);
                        while (line.hasMoreTokens ()) {
                            LZWResults.addElement (line.nextToken ());
                        }
                    }
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("rm tempfile.txt.gz");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) {
                        StringTokenizer line = new StringTokenizer (s);
                        while (line.hasMoreTokens ()) {
                            LZWResults.addElement (line.nextToken ());
                        }
                    }
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("rm tempfile.txt");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) {
                        StringTokenizer line = new StringTokenizer (s);
                        while (line.hasMoreTokens ()) {
                            LZWResults.addElement (line.nextToken ());
                        }
                    }
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("rm testingText.txt");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) {
                        StringTokenizer line = new StringTokenizer (s);
                        while (line.hasMoreTokens ()) {
                            LZWResults.addElement (line.nextToken ());
                        }
                    }
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            try {
                Process p = Runtime.getRuntime ().exec ("rm sampleText.txt");
                BufferedInputStream buffer = new BufferedInputStream (p.getInputStream ());
                DataInputStream commandResult = new DataInputStream (buffer);
                String s = null;
                try {
                    while ((s = commandResult.readLine ()) != null) {
                        StringTokenizer line = new StringTokenizer (s);
                        while (line.hasMoreTokens ()) {
                            LZWResults.addElement (line.nextToken ());
                        }
                    }
                    commandResult.close ();
                } catch (Exception e) {
                }
            } catch (Exception e) {
            }
            String stResult = (String) LZWResults.elementAt (6);
            String stTrimmedResult = stResult.substring (0, (stResult.length () - 1));
            double distance = 0.0;
            currSampleWork.dDistance = Double.valueOf (stTrimmedResult).doubleValue ();
            LZWResults.removeAllElements ();
        }
        double dHighestPercent = 0.0;
        String stMatchingAuthor = "";
        for (int iCounter4 = 0; iCounter4 < iNumSampleWorks; iCounter4 ++) {
            Double dTemp = new Double (displayDistance (iCounter4));
            if (dTemp.doubleValue () > dHighestPercent) {
                dHighestPercent = dTemp.doubleValue ();
                stMatchingAuthor = displayAuthor (iCounter4);
            }
        }
        results.append (stMatchingAuthor + "\n");
    }
}


public int FtpPush (String remoteHost, String user, String pw, int pid) throws RemoteException {
    try {
        String execParm = linuxPath + "/chk.sh 1 " + pid;
        System.out.println ("Stemp 66" + execParm);
        Process P = Runtime.getRuntime ().exec (execParm);
        P.waitFor ();
        System.out.println ("Stemp 67");
        String fle = "context." + pid;
        String fle1 = "" + pid;
        execParm = linuxPath + "/ftpautomated.sh " + remoteHost + " put  " + fle;
        P = Runtime.getRuntime ().exec (execParm);
        P.waitFor ();
        execParm = linuxPath + "/ftpautomated1.sh " + remoteHost + " put  " + fle1;
        P = Runtime.getRuntime ().exec (execParm);
        P.waitFor ();
        System.out.println ("Stemp 68" + execParm);
        System.out.println ("Stemp 69");
    } catch (Exception e) {
        System.out.println (e.getMessage ());
        e.printStackTrace ();
    }
    return 0;
}


-----Function Pair=148=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


private void subscribe () {
    MetricListener ml = this;
    try {
        this.initFile (jobId);
        MonitorConsumer mc = new MonitorConsumer (this.monitorURL);
        mc.addMetricListener (ml);
        mc.auth ();
        MonitorArg args [] = new MonitorArg [1];
        args [0] = new MonitorArg ("jobid", jobId);
        MonitorConsumer.CollectResult cr = (MonitorConsumer.CollectResult) mc.collect ("application.message", args);
        cr.waitResult ();
        MonitorConsumer.MetricInstance suscribeMetric = cr.getMetricInstance ();
        int mid = suscribeMetric.getMetricId ();
        this.metricId = mid;
        int channel = mc.getChannelId ();
        System.out.println ("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - mid:" + mid);
        MonitorConsumer.CommandResult sr = mc.subscribe (mid, channel);
        sr.waitResult ();
        int status = sr.getStatus ();
        if (status != 0) {
            System.out.println ("\n\tTestClient.subscribe(" + this.monitorURL + ", " + jobId + ") -Suscribe failed: " + sr.getStatusStr ());
            System.exit (1);
        }
        System.out.println ("\n\tTestClient.subscibe(" + this.monitorURL + ", " + jobId + ") - Subscribe SUCCESSFUL. Waiting for data...");
        while (true) {
            try {
                java.lang.Thread.sleep (1000);
            } catch (Exception e) {
            }
        }
    } catch (MonitorException mex) {
        System.out.println ("\n\tTestClient.subscribe(" + ml + "," + this.monitorURL + ", " + this.jobId + ") -- FAILED.");
        mex.printStackTrace ();
    }
}


-----Function Pair=149=-----==

private String getSystemInfo (HTTPurl urlData) {
    StringBuffer content = new StringBuffer ();
    content.append ("<table class='systemtable'>");
    content.append ("<tr><td colspan='2' class='systemheading'>System Info</td></tr>");
    content.append ("<tr><td class='systemkey'>Current Time</td><td class='systemdata'>" + dtf.format (new Date ()) + "</td></tr>\n");
    Runtime r = Runtime.getRuntime ();
    long total = r.totalMemory ();
    long free = r.freeMemory ();
    long freePercentage = (long) (((double) free / (double) total) * 100);
    content.append ("<tr><td class='systemkey'>Memory</td><td class='systemdata'>" + freePercentage + "% Free</td></tr>\n");
    DllWrapper capEng = new DllWrapper ();
    NumberFormat nf = NumberFormat.getNumberInstance ();
    content.append ("<tr><td class='systemkey'>Capture Paths</td><td class='systemdata' nowrap>");
    String [] paths = store.getCapturePaths ();
    for (int x = 0; x < paths.length; x ++) {
        String fullPath = new File (paths [x]).getAbsolutePath ();
        long freeSpace = new File (paths [x]).getFreeSpace ();
        content.append (fullPath);
        if (freeSpace == 0) {
            content.append (" (N/A)");
        }
        else {
            content.append (" (" + nf.format ((freeSpace / (1024 * 1024))) + " MB Free)");
        }
        if (x != paths.length - 1) content.append ("<br>");
    }
    content.append ("</td></tr>\n");
    content.append ("<tr><td class='systemkey'>Channels Loaded</td><td class='systemdata'>" + store.numberOfChannels ());
    content.append ("</td></tr>\n");
    File cap = new File (store.getProperty ("path.httproot"));
    String fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Httpd Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    cap = new File (store.getProperty ("path.data"));
    fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Data Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    content.append ("<tr><td class='systemkey'>HTTP Server Version</td><td class='systemdata'>" + store.getVersion () + "</td></tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    content.append ("<tr><td class='systemkey'>Number of Devices Selected</td><td class='systemdata'>" + devList.getDeviceCount () + "</td></tr>\n");
    content.append ("</table>");
    return content.toString ();
}


public void comrun (String code, String name) {
    displayWait ();
    String comres = compile (code, name, false);
    System.out.println (comres);
    if (! comres.equals ("")) {
        displayResult ("Code compilation", comres);
    }
    else {
        String output = "";
        try {
            Process p2 = Runtime.getRuntime ().exec ("java " + name);
            InputStream in = p2.getInputStream ();
            int c = 0;
            c = in.read ();
            while (c != - 1) {
                output = output + (char) c;
                c = in.read ();
            }
            in.close ();
            displayResult ("Code output", "Compilation sucessful\n\n" + output);
        } catch (Exception e) {
            System.out.println ("error");
        }
    }
}


-----Function Pair=150=-----==

public int Process2EnergyMain (int serverId) throws RemoteException {
    String res [] [];
    Statement st;
    String sql123;
    int ins;
    double energy;
    CommonService x11 = new CommonService ();
    Connection c11 = x11.initiateCon ();
    try {
        System.out.println ("Step 7");
        String sql = "select processId,requestId from os.LoadRequestResponse where " + " processFlag is NULL and serverNo=" + serverId;
        System.out.println (sql);
        try {
            res = x11.Serlist (sql);
        } catch (Exception e) {
            System.out.println ("***************** Step 7 Exception");
            return - 1;
        }
        System.out.println ("Step 8 " + res.length);
        for (int m = 0; m < res.length; m ++) {
            String url;
            if (serverId == 1) url = Server1url;
            else url = Server2url;
            integratorSNew remoteObject;
            remoteObject = (integratorSNew) Naming.lookup (url);
            energy = remoteObject.probeProcessEnergy (Integer.parseInt (res [m] [0]));
            System.out.println ("Step 9" + energy + "process:" + res [m] [0]);
            try {
                st = c11.createStatement ();
                sql123 = "insert into os.ProcessEnergy" + "(serverNo,requestId,processId,energy,processFlag,creationDt,creationTime)" + " values (" + serverId + "," + res [m] [1] + "," + res [m] [0] + "," + energy + ",'N',curdate(),curtime())";
                System.out.println ("process:" + sql123);
                ins = st.executeUpdate (sql123);
                st.close ();
            } catch (Exception e) {
                System.out.println (e.getMessage ());
                e.printStackTrace ();
                return - 1;
            }
        }
        return 0;
    } catch (java.net.MalformedURLException me) {
        System.out.println ("Malformed URL: " + me.toString ());
    } catch (RemoteException re) {
        System.out.println ("Remote exception: " + re.toString ());
    } catch (java.rmi.NotBoundException exc) {
        System.out.println ("NotBound: " + exc.toString ());
    }
    return 0;
}


public String execute (String command, String path) throws RemoteException, Exception {
    String [] cmd = command.split (" ");
    if (cmd.length == 0) throw new RemoteException ("No command given");
    String [] env = new String [] {};
    File workDir = null;
    if (path == null || new File (path).exists () == false) workDir = new File (AgentApi.getAPI ().getDirectory ());
    else workDir = new File (path);
    Process p = Runtime.getRuntime ().exec (cmd, env, workDir);
    StreamGobbler stdout = new StreamGobbler (p.getInputStream ());
    StreamGobbler stderr = new StreamGobbler (p.getErrorStream ());
    stdout.start ();
    stderr.start ();
    int exitVal = p.waitFor ();
    stdout.join (2000);
    stderr.join (2000);
    String result = stdout.sb.toString ();
    if (exitVal != 0) {
        result += "\n\nEXITCODE: " + exitVal + "\n";
    }
    if (stderr.sb.length () > 0) {
        result += "\n\nSTDERR:\n" + stderr.sb.toString ();
    }
    return result.toString ();
}


-----Function Pair=151=-----==

private byte [] showRunningActions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer buff = new StringBuffer (2048);
    buff.append ("HTTP/1.0 200 OK\n");
    buff.append ("Content-Type: text/html\n");
    buff.append ("Pragma: no-cache\n");
    buff.append ("Cache-Control: no-cache\n\n");
    buff.append ("<html>\n");
    buff.append ("<table align='center' border='1'>\n");
    buff.append ("<tr>\n");
    buff.append ("<td nowrap>Device Index</td>\n");
    buff.append ("<td nowrap>Device Name</td>\n");
    buff.append ("<td nowrap>HashKey</td>\n");
    buff.append ("<td nowrap>Share Name</td>\n");
    buff.append ("<td nowrap>Usage Count</td>\n");
    buff.append ("<td nowrap>Is Running</td>\n");
    buff.append ("<td nowrap>Exit Code</td>\n");
    buff.append ("<td nowrap>Needs Reastart</td>\n");
    buff.append ("</tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    StreamProducerProcess [] producers = devList.getProducers ();
    for (int index = 0; index < producers.length; index ++) {
        StreamProducerProcess producer = producers [index];
        buff.append ("<tr>\n");
        buff.append ("<td nowrap>" + producer.getDeviceIndex () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getCaptureDevice ().getName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getKey () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getMemoryShareName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getUsageCount () + "</td>\n");
        buff.append ("<td nowrap>" + producer.isProducerRunning () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getExitCode () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getNeedsRestart () + "</td>\n");
        buff.append ("</tr>\n");
    }
    buff.append ("</table>\n");
    buff.append ("<br><br><br>\n");
    buff.append ("</html>");
    buff.append ("\n");
    return buff.toString ().getBytes ();
}


protected String getTcpdumpData (String ndttraceFilename) {
    if (ndttraceFilename == null) {
        return "";
    }
    String [] cmdarray = new String [] {snaplogFrame.getTcptrace (), "-l", ndttraceFilename.startsWith ("/") ? ndttraceFilename : snaplogFrame.getSnaplogs ().endsWith ("/") ? snaplogFrame.getSnaplogs () + ndttraceFilename : snaplogFrame.getSnaplogs () + "/" + ndttraceFilename};
    Process tcptraceProcess;
    try {
        tcptraceProcess = Runtime.getRuntime ().exec (cmdarray);
    } catch (IOException e) {
        System.out.println (e);
        return null;
    }
    BufferedReader in = new BufferedReader (new InputStreamReader (tcptraceProcess.getInputStream ()));
    StringBuffer toReturn = new StringBuffer ();
    try {
        String line = in.readLine ();
        while (line != null) {
            toReturn.append (line + "\n");
            line = in.readLine ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    tcptraceProcess.destroy ();
    return toReturn.toString ();
}


-----Function Pair=152=-----==

public static String determineEncodingFor (File theFile, Long startposition, Long endposition) {
    if (startposition == null) {
        startposition = 0L;
    }
    if (endposition == null) {
        endposition = theFile.length ();
    }
    RandomAccessFile raf = null;
    try {
        raf = new RandomAccessFile (theFile, "r");
        raf.seek (startposition);
        int size = 400;
        if ((endposition - startposition) < 400) {
            size = (int) (endposition - startposition);
        }
        byte [] begin = new byte [size];
        raf.read (begin);
        raf.close ();
        if ((begin [0] == - 2) && (begin [1] == - 1)) {
            return "UTF-16";
        }
        int zerocount1 = 0;
        int zerocount2 = 0;
        int counter = 0;
        while (counter < begin.length) {
            if ((counter % 2) == 0) {
                if (begin [counter] == 0) {
                    zerocount1 = zerocount1 + 1;
                }
            }
            else {
                if (begin [counter] == 0) {
                    zerocount2 = zerocount2 + 1;
                }
            }
            counter = counter + 1;
        }
        int upthresh = begin.length / 2;
        upthresh = (int) (upthresh * 0.85f);
        int downthresh = begin.length / 2;
        downthresh = (int) (downthresh * 0.15f);
        if ((zerocount1 > upthresh) && (zerocount2 < downthresh)) {
            return "UTF-16BE";
        }
        if ((zerocount2 > upthresh) && (zerocount1 < downthresh)) {
            return "UTF-16LE";
        }
        String s = new String (begin).trim ();
        if (s.startsWith ("<?xml version")) {
            if (s.toLowerCase ().contains ("encoding=\"")) {
                int start = s.toLowerCase ().indexOf ("encoding=\"") + 10;
                String sub = s.substring (start);
                int stop = sub.indexOf ("\"");
                if (stop != - 1) {
                    stop = start + stop;
                }
                String encoding = s.substring (start, stop);
                return encoding;
            }
        }
        if (s.toLowerCase ().contains ("charset=")) {
            int start = s.toLowerCase ().indexOf ("charset=") + 8;
            String sub = s.substring (start);
            int stop = sub.indexOf ("\"");
            if (stop != - 1) {
                stop = start + stop;
            }
            String encoding = s.substring (start, stop);
            if (encoding.length () < 40) {
                return encoding;
            }
        }
        int negcount = 0;
        counter = 0;
        while (counter < begin.length) {
            if (begin [counter] < 0) {
                negcount = negcount + 1;
            }
            counter = counter + 1;
        }
        int thresh = (int) (begin.length * 0.10f);
        if (negcount <= thresh) {
            return "UTF-8";
        }
    } catch (Exception err) {
        if (raf != null) {
            try {
                raf.close ();
            } catch (Exception e) {
            }
            return KlangConstants.KLANG_TEXTENC_DIALOG_NONE;
        }
    }
    return KlangConstants.KLANG_TEXTENC_DIALOG_NONE;
}


public byte [] buildPacket (int padding, SecureRandom random) {
    byte [] packet = new byte [PACKET_SIZE + padding];
    byte [] buffer = m_buffer.getBytes ();
    if (random != null) {
        random.nextBytes (packet);
    }
    else {
        for (int i = 10 + buffer.length; i < packet.length; i ++) {
            packet [i] = 0;
        }
    }
    packet [0] = (byte) ((m_version>> 8) & 0xff);
    packet [1] = (byte) (m_version & 0xff);
    packet [2] = (byte) ((m_type>> 8) & 0xff);
    packet [3] = (byte) (m_type & 0xff);
    packet [4] = 0;
    packet [5] = 0;
    packet [6] = 0;
    packet [7] = 0;
    packet [8] = (byte) ((m_resultCode>> 8) & 0xff);
    packet [9] = (byte) (m_resultCode & 0xff);
    System.arraycopy (buffer, 0, packet, 10, buffer.length);
    if ((10 + buffer.length) < PACKET_SIZE - 1) {
        packet [10 + buffer.length] = 0;
    }
    packet [PACKET_SIZE - 1] = 0;
    CRC32 crc = new CRC32 ();
    crc.update (packet);
    long crc_l = crc.getValue ();
    packet [4] = (byte) ((crc_l>> 24) & 0xff);
    packet [5] = (byte) ((crc_l>> 16) & 0xff);
    packet [6] = (byte) ((crc_l>> 8) & 0xff);
    packet [7] = (byte) (crc_l & 0xff);
    return packet;
}


-----Function Pair=153=-----==

public static void copyFile (File source, File dest) throws IOException {
    if (dest.getPath ().equals (source.getPath ())) {
        throw new IOException (KlangConstants.ERROR_IN_OUT_IDENTICAL);
    }
    if (dest.exists ()) {
        dest.delete ();
    }
    dest.createNewFile ();
    FileInputStream fin = new FileInputStream (source);
    FileOutputStream fos = new FileOutputStream (dest);
    try {
        byte [] buffer = new byte [KlangConstants.BUFFER_SIZE];
        int len;
        while ((len = fin.read (buffer)) > 0) {
            fos.write (buffer, 0, len);
        }
        fin.close ();
        fos.close ();
    } catch (IOException err) {
        fin.close ();
        fos.close ();
        throw err;
    }
}


public static long getFileCRC32 (File f) throws IOException {
    if (f.exists () && f.isFile ()) {
        FileInputStream fis = new FileInputStream (f);
        CRC32 check = new CRC32 ();
        int b = fis.read ();
        while (b != - 1) {
            b = fis.read ();
            check.update (b);
        }
        fis.close ();
        return check.getValue ();
    }
    else {
        return 0;
    }
}


-----Function Pair=154=-----==

public ArrayList < String > unzipFileMyWay (String fileName, String outputDirectory) throws Exception {
    File zippedFileHandle = null;
    ZipFile zipFile = null;
    InputStream inputStream = null;
    FileOutputStream foutStream = null;
    ArrayList < String > returnFileNameArray = new ArrayList < String > ();
    try {
        zippedFileHandle = new File (fileName);
        if (! zippedFileHandle.exists ()) {
            throw new Exception ("File : " + fileName + " does not exist!");
        }
        if (! zippedFileHandle.isFile ()) {
            throw new Exception ("The fileName : " + fileName + " is not a normal file!");
        }
        if (! zippedFileHandle.canRead ()) {
            throw new Exception ("The fileName : " + fileName + " is not readable!");
        }
        zipFile = new ZipFile (zippedFileHandle);
        if (zipFile == null) {
            throw new Exception ("Failed to open zipped file : " + fileName + " for reading!");
        }
        int numEntries = zipFile.size ();
        if (numEntries <= 0) {
            throw new Exception ("No entries found in the zipped file : " + fileName);
        }
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            String name = e.nextElement ().toString ();
            ZipEntry zipEntry = zipFile.getEntry (name);
            String outputFilename = name;
            File outDir = new File (outputDirectory);
            outDir.mkdirs ();
            if (zipEntry.isDirectory ()) {
                continue;
            }
            inputStream = zipFile.getInputStream (zipEntry);
            outputFilename = outDir.getAbsolutePath () + fileSeparator + outputFilename;
            foutStream = new FileOutputStream (outputFilename);
            int fileSize = (int) zipEntry.getSize ();
            byte [] b = new byte [fileSize];
            int byteRead = 0;
            while (byteRead != - 1) {
                byteRead = inputStream.read (b, 0, fileSize - byteRead);
            }
            foutStream.write (b);
            foutStream.flush ();
            foutStream.close ();
            returnFileNameArray.add (outputFilename);
        }
        return returnFileNameArray;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (zipFile != null) {
            zipFile.close ();
        }
        if (inputStream != null) {
            inputStream.close ();
        }
        if (foutStream != null) {
            foutStream.close ();
        }
    }
}


private void addToJar (JarOutputStream out, InputStream in, String entryName, long length) throws IOException {
    byte [] buf = new byte [2048];
    ZipEntry entry = new ZipEntry (entryName);
    CRC32 crc = new CRC32 ();
    entry.setSize (length);
    entry.setCrc (crc.getValue ());
    out.putNextEntry (entry);
    int read = in.read (buf);
    while (read > 0) {
        crc.update (buf, 0, read);
        out.write (buf, 0, read);
        read = in.read (buf);
    }
    entry.setCrc (crc.getValue ());
    in.close ();
    out.closeEntry ();
}


-----Function Pair=155=-----==

public static < T extends Comparable < T > > void BubbleSortComparable2 (T [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j].compareTo (num [j + 1]) > 0) {
                T temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


private void appendItemDataInternal (final int dataStartBlock, byte [] appendData, final int dataSize) throws IOException {
    if (dataSize > 0) {
        final int dataStartBlocksIndex = this.validateDataStartBlock (dataStartBlock);
        if (this.readOnlyMode) throw new IOException ("Cannot update data in read only mode!");
        if (dataStartBlocksIndex < 0) throw new IOException ("Data start block " + dataStartBlock + " doesn't exist!");
        final int itemDataSize = this.itemDataSizes.get (dataStartBlocksIndex);
        final int newItemDataSize = itemDataSize + dataSize;
        final int lastBlockOffset = (itemDataSize > 0) ? (itemDataSize % this.allocationUnitSize) : 0;
        final int [] currentDataChain = this.getItemDataChain (dataStartBlocksIndex);
        final int numberOfNewBlocksRequired = this.calculateBlocksNeeded (newItemDataSize) - currentDataChain.length;
        final int lastBlockNumber = currentDataChain [currentDataChain.length - 1];
        int startBlockNextBlock = (currentDataChain.length > 1) ? currentDataChain [1] : NULL_LINK;
        int appendDataOffset = 0;
        if (this.useDataChecksum && (appendData == null)) appendData = new byte [dataSize];
        if ((appendData != null) && (lastBlockOffset > 0)) {
            final int lastBlockSpace = this.allocationUnitSize - lastBlockOffset;
            final int lastBlockAppendLength = (appendData.length > lastBlockSpace) ? lastBlockSpace : appendData.length;
            final int formattedLastBlockDataOffset = BLOCK_HEADER_SIZE + lastBlockOffset;
            if (this.useDataChecksum) {
                final byte [] formattedLastBlockData = blockFile.readBlock (lastBlockNumber);
                System.arraycopy (appendData, 0, formattedLastBlockData, formattedLastBlockDataOffset, lastBlockAppendLength);
                this.formatBlockDataChecksum (formattedLastBlockData, 0, lastBlockAppendLength);
                this.blockFile.writeBlock (lastBlockNumber, formattedLastBlockData, 0);
            }
            else {
                this.blockFile.writePartialBlock (lastBlockNumber, formattedLastBlockDataOffset, appendData, 0, lastBlockAppendLength);
            }
            appendDataOffset += lastBlockAppendLength;
        }
        if (numberOfNewBlocksRequired > 0) {
            final int [] appendDataChain = this.allocateDataChain (numberOfNewBlocksRequired);
            int [] newDataChain = new int [currentDataChain.length + appendDataChain.length];
            System.arraycopy (currentDataChain, 0, newDataChain, 0, currentDataChain.length);
            System.arraycopy (appendDataChain, 0, newDataChain, currentDataChain.length, appendDataChain.length);
            this.dataChainsArray.set (dataStartBlocksIndex, newDataChain);
            if (appendData != null) {
                final byte [] formattedBlockData = this.getFormattedBlocksBuffer (appendDataChain.length);
                for (int i = 0; i < appendDataChain.length; i ++) {
                    formatBlock (formattedBlockData, i * this.blockSize, appendData, appendDataOffset, false, (i < (appendDataChain.length - 1)) ? appendDataChain [i + 1] : NULL_LINK);
                    appendDataOffset += this.allocationUnitSize;
                }
                this.blockFile.writeBlocks (appendDataChain, formattedBlockData, 0);
            }
            else {
                final byte [] blockHeader = new byte [BLOCK_HEADER_SIZE];
                for (int i = 0; i < appendDataChain.length; i ++) {
                    this.formatBlockHeader (true, false, - 1, (i < (appendDataChain.length - 1)) ? appendDataChain [i + 1] : NULL_LINK, blockHeader, 0);
                    this.blockFile.writePartialBlock (appendDataChain [i], 0, blockHeader, 0, BLOCK_HEADER_SIZE);
                }
            }
            if (currentDataChain.length > 1) {
                final byte [] newLastBlockHeader = new byte [BLOCK_HEADER_SIZE];
                this.formatBlockHeader (true, false, - 1, appendDataChain [0], newLastBlockHeader, 0);
                this.blockFile.writePartialBlock (lastBlockNumber, 0, newLastBlockHeader, 0, BLOCK_HEADER_SIZE);
            }
            else {
                startBlockNextBlock = appendDataChain [0];
            }
        }
        final byte [] newStartBlockHeader = new byte [BLOCK_HEADER_SIZE];
        this.formatBlockHeader (true, true, newItemDataSize, startBlockNextBlock, newStartBlockHeader, 0);
        this.blockFile.writePartialBlock (currentDataChain [0], 0, newStartBlockHeader, 0, BLOCK_HEADER_SIZE);
        this.itemDataSizes.set (dataStartBlocksIndex, newItemDataSize);
    }
}


-----Function Pair=156=-----==

public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {
    this.applet = applet;
    if (applet == null) {
        frame = new JFrame (gc);
        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    }
    setLayout (new BorderLayout ());
    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));
    Action openAction = new AbstractAction ("Open File", new ImageIcon (getClass ().getResource ("/open.gif"))) {
        public void actionPerformed (ActionEvent e) {
            if (filechooser == null) {
                filechooser = new JFileChooser ();
                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
            }
            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                open (filechooser.getSelectedFile ());
            }
        }
    }
    ;
    JToolBar bar = new JToolBar ();
    bar.add (new ToolBarButton (openAction));
    add (bar, BorderLayout.NORTH);
    if (applet == null) {
        frame.setTitle ("Image Display - Control Panel");
        frame.getContentPane ().add (this, BorderLayout.CENTER);
        frame.pack ();
        frame.show ();
    }
}


private void initComponents () {
    java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle ("MainFrameBundle");
    BGMetric = new javax.swing.ButtonGroup ();
    BGTrans = new javax.swing.ButtonGroup ();
    TPMain = new javax.swing.JTabbedPane ();
    JPMain = new javax.swing.JPanel ();
    table = new JTable (tabelle);
    SPProgram = new javax.swing.JScrollPane (table);
    JPMainNorth = new javax.swing.JPanel ();
    JPMainNorthLeft = new javax.swing.JPanel ();
    JPMainNorthLeft1 = new javax.swing.JPanel ();
    JLProgName = new javax.swing.JLabel ();
    TFProgName = new javax.swing.JTextField ("pawn code", 20);
    JPMainNorthLeft2 = new javax.swing.JPanel ();
    JLMeasurement = new javax.swing.JLabel ();
    JRBInch = new javax.swing.JRadioButton ();
    JRBMetric = new javax.swing.JRadioButton ();
    JPMainNorthLeft3 = new javax.swing.JPanel ();
    JLDescription = new javax.swing.JLabel ();
    JPMainNorthLeft4 = new javax.swing.JPanel ();
    JLLine = new javax.swing.JLabel ();
    TFLine = new javax.swing.JTextField (4);
    JLCode = new javax.swing.JLabel ();
    TFCode = new javax.swing.JTextField (4);
    JPMainNorthLeft5 = new javax.swing.JPanel ();
    JLComment = new javax.swing.JLabel ();
    TFComment = new javax.swing.JTextField (20);
    JPMainNorthCenter = new javax.swing.JPanel ();
    JPMainNorthCenter1 = new javax.swing.JPanel ();
    CBGCode = new javax.swing.JComboBox ();
    JPMainNorthCenter2 = new javax.swing.JPanel ();
    CBMCode = new javax.swing.JComboBox ();
    JPMainNorthCenter3 = new javax.swing.JPanel ();
    JPMainNorthCenter31 = new javax.swing.JPanel ();
    JPMainNorthCenter311 = new javax.swing.JPanel ();
    JLX = new javax.swing.JLabel ();
    JPMainNorthCenter312 = new javax.swing.JPanel ();
    TFX = new javax.swing.JTextField (4);
    JPMainNorthCenter32 = new javax.swing.JPanel ();
    JPMainNorthCenter321 = new javax.swing.JPanel ();
    JLZ = new javax.swing.JLabel ();
    JPMainNorthCenter322 = new javax.swing.JPanel ();
    TFZ = new javax.swing.JTextField (4);
    JPMainNorthCenter4 = new javax.swing.JPanel ();
    JPMainNorthCenter41 = new javax.swing.JPanel ();
    JPMainNorthCenter411 = new javax.swing.JPanel ();
    JLF = new javax.swing.JLabel ();
    JPMainNorthCenter412 = new javax.swing.JPanel ();
    TFF = new javax.swing.JTextField (4);
    JPMainNorthCenter42 = new javax.swing.JPanel ();
    JPMainNorthCenter421 = new javax.swing.JPanel ();
    JLH = new javax.swing.JLabel ();
    JPMainNorthCenter422 = new javax.swing.JPanel ();
    TFH = new javax.swing.JTextField (4);
    JPMainNorthCenter5 = new javax.swing.JPanel ();
    JPMainNorthCenter51 = new javax.swing.JPanel ();
    JBAdd = new javax.swing.JButton ();
    JPMainNorthCenter52 = new javax.swing.JPanel ();
    JBDelete = new javax.swing.JButton ();
    JPMainNorthCenter6 = new javax.swing.JPanel ();
    JPMainNorthCenter61 = new javax.swing.JPanel ();
    JBInsert = new javax.swing.JButton ();
    JPMainNorthCenter62 = new javax.swing.JPanel ();
    JBUpdate = new javax.swing.JButton ();
    JPTrans = new javax.swing.JPanel ();
    JPTransCenter = new javax.swing.JPanel ();
    SPRxTx = new javax.swing.JScrollPane ();
    TARxTx = new javax.swing.JTextArea ();
    JPTransRight = new javax.swing.JPanel ();
    JPTransRight1 = new javax.swing.JPanel ();
    JPTransRight2 = new javax.swing.JPanel ();
    JPTransRight3 = new javax.swing.JPanel ();
    JPTransRight3a = new javax.swing.JPanel ();
    JRBEthernet = new javax.swing.JRadioButton ();
    JPTransRight3b = new javax.swing.JPanel ();
    JRBSerial = new javax.swing.JRadioButton ();
    JPTransRight4 = new javax.swing.JPanel ();
    CBXport = new javax.swing.JCheckBox ();
    JPTransRight5 = new javax.swing.JPanel ();
    JPTransRight6 = new javax.swing.JPanel ();
    JPTransRight7 = new javax.swing.JPanel ();
    JBTransmit = new javax.swing.JButton ();
    JPTransRight8 = new javax.swing.JPanel ();
    JBReceive = new javax.swing.JButton ();
    JPTransRight9 = new javax.swing.JPanel ();
    JBTransAbort = new javax.swing.JButton ();
    JPTransRight10 = new javax.swing.JPanel ();
    JPTransRight11 = new javax.swing.JPanel ();
    JPTransRight12 = new javax.swing.JPanel ();
    JPTransRight13 = new javax.swing.JPanel ();
    JPTransRight14 = new javax.swing.JPanel ();
    JPTransRight15 = new javax.swing.JPanel ();
    JPTransRight16 = new javax.swing.JPanel ();
    JPTransRight17 = new javax.swing.JPanel ();
    JPTransRight18 = new javax.swing.JPanel ();
    JPTransRight19 = new javax.swing.JPanel ();
    JPTransRight20 = new javax.swing.JPanel ();
    JPConf = new javax.swing.JPanel ();
    JPConf1 = new javax.swing.JPanel ();
    JPConf11 = new javax.swing.JPanel ();
    JPConf111 = new javax.swing.JPanel ();
    JLSerialInterface = new javax.swing.JLabel ();
    JPConf112 = new javax.swing.JPanel ();
    JCBSerialInterface = new javax.swing.JComboBox ();
    JPConf113 = new javax.swing.JPanel ();
    JLBaudRate = new javax.swing.JLabel ();
    JPConf114 = new javax.swing.JPanel ();
    JCBBaudRate = new javax.swing.JComboBox ();
    JPConf115 = new javax.swing.JPanel ();
    JLParity = new javax.swing.JLabel ();
    JPConf116 = new javax.swing.JPanel ();
    JCBParity = new javax.swing.JComboBox ();
    JPConf12 = new javax.swing.JPanel ();
    JPConf121 = new javax.swing.JPanel ();
    JLStopBits = new javax.swing.JLabel ();
    JPConf122 = new javax.swing.JPanel ();
    JCBStopBit = new javax.swing.JComboBox ();
    JPConf123 = new javax.swing.JPanel ();
    JLDataBits = new javax.swing.JLabel ();
    JPConf124 = new javax.swing.JPanel ();
    JCBDataBits = new javax.swing.JComboBox (this.dataBitValues);
    JPConf125 = new javax.swing.JPanel ();
    JLFlowControl = new javax.swing.JLabel ();
    JPConf126 = new javax.swing.JPanel ();
    JCBFlowControl = new javax.swing.JComboBox ();
    JPConf2 = new javax.swing.JPanel ();
    JPConf21 = new javax.swing.JPanel ();
    JLIPAddress = new javax.swing.JLabel ();
    TFIPAddress = new javax.swing.JTextField ("", 20);
    JLIPPort = new javax.swing.JLabel ();
    TFIPPort = new javax.swing.JTextField ("", 20);
    JPConf22 = new javax.swing.JPanel ();
    CBLanguage = new javax.swing.JCheckBox ();
    JCBLanguage = new javax.swing.JComboBox ();
    JPConf3 = new javax.swing.JPanel ();
    JPConf31 = new javax.swing.JPanel ();
    JPConf32 = new javax.swing.JPanel ();
    JPConf33 = new javax.swing.JPanel ();
    JPConf331 = new javax.swing.JPanel ();
    CBDebug = new javax.swing.JCheckBox ();
    JPConf332 = new javax.swing.JPanel ();
    JBDefaultSettings = new javax.swing.JButton ();
    JBConfSave = new javax.swing.JButton ();
    JBConfAbort = new javax.swing.JButton ();
    JPDebug = new javax.swing.JPanel ();
    SPDebug = new javax.swing.JScrollPane ();
    TADebug = new javax.swing.JTextArea ();
    MBMain = new javax.swing.JMenuBar ();
    JMFile = new javax.swing.JMenu ();
    MINew = new javax.swing.JMenuItem ();
    MIOpen = new javax.swing.JMenuItem ();
    MISave = new javax.swing.JMenuItem ();
    MISaveAs = new javax.swing.JMenuItem ();
    MIExit = new javax.swing.JMenuItem ();
    JMAbout = new javax.swing.JMenu ();
    JMIAbout = new javax.swing.JMenuItem ();
    BGMetric.add (JRBMetric);
    BGMetric.add (JRBInch);
    setDefaultCloseOperation (javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setMinimumSize (new java.awt.Dimension (800, 600));
    TPMain.setMaximumSize (new java.awt.Dimension (1920, 1200));
    TPMain.setMinimumSize (new java.awt.Dimension (780, 540));
    TPMain.setPreferredSize (new java.awt.Dimension (780, 540));
    JPMain.setLayout (new java.awt.BorderLayout ());
    table.getSelectionModel ().addListSelectionListener (this);
    SPProgram.setBorder (new javax.swing.border.SoftBevelBorder (javax.swing.border.BevelBorder.RAISED));
    JPMain.add (SPProgram, java.awt.BorderLayout.CENTER);
    JPMainNorth.setBorder (new javax.swing.border.SoftBevelBorder (javax.swing.border.BevelBorder.RAISED));
    JPMainNorth.setPreferredSize (new java.awt.Dimension (676, 230));
    JPMainNorth.setLayout (new java.awt.GridLayout (1, 3));
    JPMainNorthLeft.setBorder (javax.swing.BorderFactory.createTitledBorder (bundle.getString ("PROGRAM INFORMATION")));
    JPMainNorthLeft.setPreferredSize (new java.awt.Dimension (338, 100));
    JPMainNorthLeft.setLayout (new java.awt.GridLayout (5, 1));
    JPMainNorthLeft1.setMinimumSize (new java.awt.Dimension (230, 33));
    JPMainNorthLeft1.setPreferredSize (new java.awt.Dimension (230, 33));
    JPMainNorthLeft1.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLProgName.setText (bundle.getString ("TOPIC FOR THE PROGRAM"));
    JPMainNorthLeft1.add (JLProgName);
    TFProgName.setToolTipText (bundle.getString ("SET THE HEADLINE FOR THE CNC PROGRAM"));
    JPMainNorthLeft1.add (TFProgName);
    JPMainNorthLeft.add (JPMainNorthLeft1);
    JPMainNorthLeft2.setMinimumSize (new java.awt.Dimension (230, 33));
    JPMainNorthLeft2.setPreferredSize (new java.awt.Dimension (230, 33));
    JPMainNorthLeft2.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLMeasurement.setText (bundle.getString ("MEASUREMENT SYSTEM"));
    JLMeasurement.setToolTipText (bundle.getString ("THIS CHOICE IS ONLY AVAILABLE BEFORE ANY PROGRAM LINES WERE INSERTED"));
    JPMainNorthLeft2.add (JLMeasurement);
    JRBInch.setText (bundle.getString ("IMPERIAL"));
    JRBInch.setToolTipText (bundle.getString ("SET THE MEASUREMENT SYSTEM TO IMPERIAL"));
    JRBInch.addActionListener (this);
    JRBInch.setActionCommand ("imperial");
    JPMainNorthLeft2.add (JRBInch);
    JRBMetric.setText (bundle.getString ("METRIC"));
    JRBMetric.setToolTipText (bundle.getString ("SET THE MEASUREMENT SYSTEM TO METRIC"));
    JRBMetric.addActionListener (this);
    JRBMetric.setActionCommand ("metric");
    JPMainNorthLeft2.add (JRBMetric);
    JPMainNorthLeft.add (JPMainNorthLeft2);
    JPMainNorthLeft3.setPreferredSize (new java.awt.Dimension (338, 33));
    JPMainNorthLeft3.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLDescription.setText (bundle.getString ("DESCRIPTION"));
    JPMainNorthLeft3.add (JLDescription);
    JPMainNorthLeft.add (JPMainNorthLeft3);
    JPMainNorthLeft4.setPreferredSize (new java.awt.Dimension (338, 33));
    JPMainNorthLeft4.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLLine.setText (bundle.getString ("LINE"));
    JPMainNorthLeft4.add (JLLine);
    TFLine.setText ("");
    TFLine.setToolTipText (bundle.getString ("NUMBER OF THE CURRENT PROGRAM LINE"));
    TFLine.setEditable (false);
    JPMainNorthLeft4.add (TFLine);
    JLCode.setText (bundle.getString ("CODE"));
    JPMainNorthLeft4.add (JLCode);
    TFCode.setEditable (false);
    TFCode.setText ("");
    TFCode.setToolTipText (bundle.getString ("CURRENTLY CHOSEN MACHINE PROGRAM COMMAND"));
    JPMainNorthLeft4.add (TFCode);
    JPMainNorthLeft.add (JPMainNorthLeft4);
    JPMainNorthLeft5.setPreferredSize (new java.awt.Dimension (338, 33));
    JPMainNorthLeft5.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLComment.setText (bundle.getString ("COMMENT"));
    JPMainNorthLeft5.add (JLComment);
    TFComment.setText ("");
    TFComment.setToolTipText (bundle.getString ("ADD A LINE COMMENT"));
    TFComment.setMaximumSize (new java.awt.Dimension (20, 5));
    JPMainNorthLeft5.add (TFComment);
    JPMainNorthLeft.add (JPMainNorthLeft5);
    JPMainNorth.add (JPMainNorthLeft);
    JPMainNorthCenter.setBorder (javax.swing.BorderFactory.createTitledBorder (bundle.getString ("PROGRAM LINE ENTRY")));
    JPMainNorthCenter.setMinimumSize (new java.awt.Dimension (140, 140));
    JPMainNorthCenter.setPreferredSize (new java.awt.Dimension (338, 100));
    JPMainNorthCenter.setLayout (new java.awt.GridLayout (6, 1));
    JPMainNorthCenter1.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    CBGCode.setModel (new javax.swing.DefaultComboBoxModel (gCode));
    CBGCode.setToolTipText (bundle.getString ("LIST OF AVAILABLE MCOMMANDS"));
    CBGCode.setPreferredSize (new java.awt.Dimension (365, 20));
    CBGCode.setMaximumRowCount (30);
    CBGCode.addActionListener (this);
    CBGCode.setActionCommand ("gcclick");
    JPMainNorthCenter1.add (CBGCode);
    JPMainNorthCenter.add (JPMainNorthCenter1);
    JPMainNorthCenter2.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    CBMCode.setModel (new javax.swing.DefaultComboBoxModel (mCode));
    CBMCode.setToolTipText (bundle.getString ("LIST OF AVAILABLE GCOMMANDS"));
    CBMCode.setPreferredSize (new java.awt.Dimension (365, 20));
    CBMCode.setMaximumRowCount (30);
    CBMCode.addActionListener (this);
    CBMCode.setActionCommand ("mcclick");
    JPMainNorthCenter2.add (CBMCode);
    JPMainNorthCenter.add (JPMainNorthCenter2);
    JPMainNorthCenter3.setMinimumSize (new java.awt.Dimension (140, 65));
    JPMainNorthCenter3.setPreferredSize (new java.awt.Dimension (140, 65));
    JPMainNorthCenter3.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter31.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter311.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.RIGHT));
    JLX.setText ("X");
    JPMainNorthCenter311.add (JLX);
    JPMainNorthCenter31.add (JPMainNorthCenter311);
    JPMainNorthCenter312.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    TFX.setText ("");
    TFX.addFocusListener (this);
    JPMainNorthCenter312.add (TFX);
    TFX.getAccessibleContext ().setAccessibleName ("TFX");
    JPMainNorthCenter31.add (JPMainNorthCenter312);
    JPMainNorthCenter3.add (JPMainNorthCenter31);
    JPMainNorthCenter32.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter321.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.RIGHT));
    JLZ.setText ("Z");
    JPMainNorthCenter321.add (JLZ);
    JPMainNorthCenter32.add (JPMainNorthCenter321);
    JPMainNorthCenter322.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    TFZ.setText ("");
    TFZ.addFocusListener (this);
    JPMainNorthCenter322.add (TFZ);
    TFZ.getAccessibleContext ().setAccessibleName ("TFZ");
    JPMainNorthCenter32.add (JPMainNorthCenter322);
    JPMainNorthCenter3.add (JPMainNorthCenter32);
    JPMainNorthCenter.add (JPMainNorthCenter3);
    JPMainNorthCenter4.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter41.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter411.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.RIGHT));
    JLF.setText ("F");
    JPMainNorthCenter411.add (JLF);
    JPMainNorthCenter41.add (JPMainNorthCenter411);
    JPMainNorthCenter412.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    TFF.setText ("");
    TFF.addFocusListener (this);
    JPMainNorthCenter412.add (TFF);
    TFF.getAccessibleContext ().setAccessibleName ("TFF");
    JPMainNorthCenter41.add (JPMainNorthCenter412);
    JPMainNorthCenter4.add (JPMainNorthCenter41);
    JPMainNorthCenter42.setLayout (new java.awt.GridLayout (1, 2));
    JPMainNorthCenter421.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.RIGHT));
    JLH.setText ("H");
    JPMainNorthCenter421.add (JLH);
    JPMainNorthCenter42.add (JPMainNorthCenter421);
    JPMainNorthCenter422.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    TFH.setText ("");
    TFH.addFocusListener (this);
    JPMainNorthCenter422.add (TFH);
    TFH.getAccessibleContext ().setAccessibleName ("TFH");
    JPMainNorthCenter42.add (JPMainNorthCenter422);
    JPMainNorthCenter4.add (JPMainNorthCenter42);
    JPMainNorthCenter.add (JPMainNorthCenter4);
    JPMainNorthCenter5.setLayout (new java.awt.GridLayout (1, 2));
    JBAdd.setText (bundle.getString ("APPEND"));
    JBAdd.setToolTipText (bundle.getString ("ADD THIS LINE AFTER THE LAST LINE IN THE PROGRAM"));
    JBAdd.setMaximumSize (new java.awt.Dimension (130, 30));
    JBAdd.setMinimumSize (new java.awt.Dimension (50, 20));
    JBAdd.setPreferredSize (new java.awt.Dimension (130, 20));
    JBAdd.addActionListener (this);
    JBAdd.setActionCommand ("add");
    JBAdd.setEnabled (false);
    JPMainNorthCenter51.add (JBAdd);
    JPMainNorthCenter5.add (JPMainNorthCenter51);
    JBDelete.setText (bundle.getString ("DELETE"));
    JBDelete.setToolTipText (bundle.getString ("DELETE THE CURRENTLY SELECTED LINE"));
    JBDelete.setMaximumSize (new java.awt.Dimension (130, 30));
    JBDelete.setMinimumSize (new java.awt.Dimension (50, 20));
    JBDelete.setPreferredSize (new java.awt.Dimension (130, 20));
    JBDelete.addActionListener (this);
    JBDelete.setActionCommand ("delete");
    JBDelete.setEnabled (false);
    JPMainNorthCenter52.add (JBDelete);
    JPMainNorthCenter5.add (JPMainNorthCenter52);
    JPMainNorthCenter.add (JPMainNorthCenter5);
    JPMainNorthCenter6.setPreferredSize (new java.awt.Dimension (140, 45));
    JPMainNorthCenter6.setLayout (new java.awt.GridLayout (1, 2));
    JBInsert.setText (bundle.getString ("INSERT"));
    JBInsert.setToolTipText (bundle.getString ("INSERT THE LINE AT THE CURRENT POSITION"));
    JBInsert.setMaximumSize (new java.awt.Dimension (130, 30));
    JBInsert.setMinimumSize (new java.awt.Dimension (50, 20));
    JBInsert.setPreferredSize (new java.awt.Dimension (130, 20));
    JBInsert.addActionListener (this);
    JBInsert.setActionCommand ("insert");
    JBInsert.setEnabled (false);
    JPMainNorthCenter61.add (JBInsert);
    JPMainNorthCenter6.add (JPMainNorthCenter61);
    JBUpdate.setText (bundle.getString ("UPDATE"));
    JBUpdate.setToolTipText (bundle.getString ("CHANGE THE CURRENT LINE"));
    JBUpdate.setActionCommand ("update");
    JBUpdate.setMaximumSize (new java.awt.Dimension (130, 30));
    JBUpdate.setMinimumSize (new java.awt.Dimension (50, 20));
    JBUpdate.setPreferredSize (new java.awt.Dimension (130, 20));
    JBUpdate.addActionListener (this);
    JBUpdate.setEnabled (false);
    JPMainNorthCenter62.add (JBUpdate);
    JBUpdate.getAccessibleContext ().setAccessibleName ("");
    JPMainNorthCenter6.add (JPMainNorthCenter62);
    JPMainNorthCenter.add (JPMainNorthCenter6);
    JPMainNorth.add (JPMainNorthCenter);
    JPMain.add (JPMainNorth, java.awt.BorderLayout.PAGE_START);
    TPMain.addTab (bundle.getString ("MAIN WINDOW"), JPMain);
    JPTrans.setBorder (new javax.swing.border.SoftBevelBorder (javax.swing.border.BevelBorder.RAISED));
    JPTrans.setLayout (new java.awt.BorderLayout ());
    JPTransCenter.setLayout (new java.awt.BorderLayout ());
    TARxTx.setColumns (20);
    TARxTx.setRows (5);
    TARxTx.setEditable (false);
    SPRxTx.setViewportView (TARxTx);
    JPTransCenter.add (SPRxTx, java.awt.BorderLayout.CENTER);
    JPTrans.add (JPTransCenter, java.awt.BorderLayout.CENTER);
    JPTransRight.setLayout (new java.awt.GridLayout (10, 2));
    JPTransRight.add (JPTransRight1);
    JPTransRight.add (JPTransRight2);
    JPTransRight3.setPreferredSize (new java.awt.Dimension (182, 50));
    JPTransRight3.setLayout (new java.awt.GridLayout (2, 1));
    JRBEthernet.setText (bundle.getString ("ETHERNET"));
    JRBEthernet.setToolTipText (bundle.getString ("TRANSMIT RECEIVE OVER ETHERNET"));
    BGTrans.add (JRBEthernet);
    JRBEthernet.setActionCommand ("useeth");
    JRBEthernet.setSelected (true);
    javax.swing.GroupLayout JPTransRight3aLayout = new javax.swing.GroupLayout (JPTransRight3a);
    JPTransRight3a.setLayout (JPTransRight3aLayout);
    JPTransRight3aLayout.setHorizontalGroup (JPTransRight3aLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE).addGroup (JPTransRight3aLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (JPTransRight3aLayout.createSequentialGroup ().addGap (0, 50, Short.MAX_VALUE).addComponent (JRBEthernet, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE).addGap (0, 51, Short.MAX_VALUE))));
    JPTransRight3aLayout.setVerticalGroup (JPTransRight3aLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 56, Short.MAX_VALUE).addGroup (JPTransRight3aLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (JPTransRight3aLayout.createSequentialGroup ().addGap (0, 16, Short.MAX_VALUE).addComponent (JRBEthernet).addGap (0, 17, Short.MAX_VALUE))));
    JPTransRight3.add (JPTransRight3a);
    JRBSerial.setText (bundle.getString ("SERIAL"));
    JRBSerial.setToolTipText (bundle.getString ("TRANSMIT RECEIVE OVER SERIAL CONNECTION"));
    BGTrans.add (JRBSerial);
    JRBSerial.setActionCommand ("useserial");
    javax.swing.GroupLayout JPTransRight3bLayout = new javax.swing.GroupLayout (JPTransRight3b);
    JPTransRight3b.setLayout (JPTransRight3bLayout);
    JPTransRight3bLayout.setHorizontalGroup (JPTransRight3bLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE).addGroup (JPTransRight3bLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (JPTransRight3bLayout.createSequentialGroup ().addGap (0, 50, Short.MAX_VALUE).addComponent (JRBSerial, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE).addGap (0, 51, Short.MAX_VALUE))));
    JPTransRight3bLayout.setVerticalGroup (JPTransRight3bLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 56, Short.MAX_VALUE).addGroup (JPTransRight3bLayout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (JPTransRight3bLayout.createSequentialGroup ().addGap (0, 16, Short.MAX_VALUE).addComponent (JRBSerial).addGap (0, 17, Short.MAX_VALUE))));
    JPTransRight3.add (JPTransRight3b);
    JPTransRight.add (JPTransRight3);
    JPTransRight4.setPreferredSize (new java.awt.Dimension (182, 50));
    JPTransRight4.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    CBXport.setText (bundle.getString ("XPORT LINUX OS IN USE"));
    CBXport.setToolTipText (bundle.getString ("WHEN YOU ARE GOING TO USE A XPORT"));
    CBXport.setActionCommand ("setxport");
    CBXport.addActionListener (this);
    CBXport.setSelected (c.getUseXPort ());
    JPTransRight4.add (CBXport);
    JPTransRight.add (JPTransRight4);
    JPTransRight.add (JPTransRight5);
    JPTransRight.add (JPTransRight6);
    JBTransmit.setText (bundle.getString ("TRANSMIT"));
    JBTransmit.setActionCommand ("transmit");
    JBTransmit.addActionListener (this);
    JPTransRight7.add (JBTransmit);
    JPTransRight.add (JPTransRight7);
    JPTransRight8.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JBReceive.setText (bundle.getString ("RECEIVE"));
    JBReceive.setActionCommand ("receive");
    JBReceive.addActionListener (this);
    JPTransRight8.add (JBReceive);
    JPTransRight.add (JPTransRight8);
    JBTransAbort.setText (bundle.getString ("ABORT"));
    JBTransAbort.setToolTipText (bundle.getString ("ABORTS RECEIVING TRANSMITTING"));
    JBTransAbort.setActionCommand ("rxtxabort");
    JBTransAbort.addActionListener (this);
    JPTransRight9.add (JBTransAbort);
    JPTransRight.add (JPTransRight9);
    JPTransRight.add (JPTransRight10);
    javax.swing.GroupLayout JPTransRight11Layout = new javax.swing.GroupLayout (JPTransRight11);
    JPTransRight11.setLayout (JPTransRight11Layout);
    JPTransRight11Layout.setHorizontalGroup (JPTransRight11Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight11Layout.setVerticalGroup (JPTransRight11Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight11);
    javax.swing.GroupLayout JPTransRight12Layout = new javax.swing.GroupLayout (JPTransRight12);
    JPTransRight12.setLayout (JPTransRight12Layout);
    JPTransRight12Layout.setHorizontalGroup (JPTransRight12Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight12Layout.setVerticalGroup (JPTransRight12Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight12);
    javax.swing.GroupLayout JPTransRight13Layout = new javax.swing.GroupLayout (JPTransRight13);
    JPTransRight13.setLayout (JPTransRight13Layout);
    JPTransRight13Layout.setHorizontalGroup (JPTransRight13Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight13Layout.setVerticalGroup (JPTransRight13Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight13);
    javax.swing.GroupLayout JPTransRight14Layout = new javax.swing.GroupLayout (JPTransRight14);
    JPTransRight14.setLayout (JPTransRight14Layout);
    JPTransRight14Layout.setHorizontalGroup (JPTransRight14Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight14Layout.setVerticalGroup (JPTransRight14Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight14);
    javax.swing.GroupLayout JPTransRight15Layout = new javax.swing.GroupLayout (JPTransRight15);
    JPTransRight15.setLayout (JPTransRight15Layout);
    JPTransRight15Layout.setHorizontalGroup (JPTransRight15Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight15Layout.setVerticalGroup (JPTransRight15Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight15);
    javax.swing.GroupLayout JPTransRight16Layout = new javax.swing.GroupLayout (JPTransRight16);
    JPTransRight16.setLayout (JPTransRight16Layout);
    JPTransRight16Layout.setHorizontalGroup (JPTransRight16Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight16Layout.setVerticalGroup (JPTransRight16Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight16);
    javax.swing.GroupLayout JPTransRight17Layout = new javax.swing.GroupLayout (JPTransRight17);
    JPTransRight17.setLayout (JPTransRight17Layout);
    JPTransRight17Layout.setHorizontalGroup (JPTransRight17Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight17Layout.setVerticalGroup (JPTransRight17Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight17);
    javax.swing.GroupLayout JPTransRight18Layout = new javax.swing.GroupLayout (JPTransRight18);
    JPTransRight18.setLayout (JPTransRight18Layout);
    JPTransRight18Layout.setHorizontalGroup (JPTransRight18Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight18Layout.setVerticalGroup (JPTransRight18Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight18);
    javax.swing.GroupLayout JPTransRight19Layout = new javax.swing.GroupLayout (JPTransRight19);
    JPTransRight19.setLayout (JPTransRight19Layout);
    JPTransRight19Layout.setHorizontalGroup (JPTransRight19Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight19Layout.setVerticalGroup (JPTransRight19Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight19);
    javax.swing.GroupLayout JPTransRight20Layout = new javax.swing.GroupLayout (JPTransRight20);
    JPTransRight20.setLayout (JPTransRight20Layout);
    JPTransRight20Layout.setHorizontalGroup (JPTransRight20Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 201, Short.MAX_VALUE));
    JPTransRight20Layout.setVerticalGroup (JPTransRight20Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 112, Short.MAX_VALUE));
    JPTransRight.add (JPTransRight20);
    JPTrans.add (JPTransRight, java.awt.BorderLayout.LINE_END);
    TPMain.addTab (bundle.getString ("TRANSMIT RECEIVE"), JPTrans);
    JPConf.setBorder (new javax.swing.border.SoftBevelBorder (javax.swing.border.BevelBorder.RAISED));
    JPConf.setLayout (new java.awt.GridLayout (3, 1));
    JPConf1.setBorder (javax.swing.BorderFactory.createTitledBorder (bundle.getString ("SERIAL PORT SETTINGS")));
    JPConf1.setLayout (new java.awt.GridLayout (2, 0));
    JPConf11.setLayout (new java.awt.GridLayout (1, 6));
    JPConf111.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLSerialInterface.setText (bundle.getString ("SERIAL PORT"));
    JPConf111.add (JLSerialInterface);
    JPConf11.add (JPConf111);
    JPConf112.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JCBSerialInterface.setModel (new javax.swing.DefaultComboBoxModel (this.comPorts));
    JPConf112.add (JCBSerialInterface);
    JPConf11.add (JPConf112);
    JPConf113.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLBaudRate.setText (bundle.getString ("BAUD RATE"));
    JPConf113.add (JLBaudRate);
    JPConf11.add (JPConf113);
    JPConf114.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JCBBaudRate.setModel (new javax.swing.DefaultComboBoxModel (new String [] {"110", "300", "1200", "2400", "4800", "9600", "19200", "38400", "57600", "115200", "230400", "460800", "921600"}));
    JPConf114.add (JCBBaudRate);
    JPConf11.add (JPConf114);
    JPConf115.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLParity.setText (bundle.getString ("PARITY"));
    JPConf115.add (JLParity);
    JPConf11.add (JPConf115);
    JPConf116.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JCBParity.setModel (new javax.swing.DefaultComboBoxModel (parityText));
    JPConf116.add (JCBParity);
    JPConf11.add (JPConf116);
    JPConf1.add (JPConf11);
    JPConf12.setLayout (new java.awt.GridLayout (1, 6));
    JPConf121.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLStopBits.setText (bundle.getString ("STOP BITS"));
    JPConf121.add (JLStopBits);
    JPConf12.add (JPConf121);
    JPConf122.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JCBStopBit.setModel (new javax.swing.DefaultComboBoxModel (this.stopBitText));
    JPConf122.add (JCBStopBit);
    JPConf12.add (JPConf122);
    JPConf123.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLDataBits.setText (bundle.getString ("DATA BITS"));
    JPConf123.add (JLDataBits);
    JPConf12.add (JPConf123);
    JPConf124.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JPConf124.add (JCBDataBits);
    JPConf12.add (JPConf124);
    JPConf125.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLFlowControl.setText (bundle.getString ("FLOW CONTROL"));
    JPConf125.add (JLFlowControl);
    JPConf12.add (JPConf125);
    JPConf126.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JCBFlowControl.setModel (new javax.swing.DefaultComboBoxModel (this.flowControlText));
    JPConf126.add (JCBFlowControl);
    JPConf12.add (JPConf126);
    JPConf1.add (JPConf12);
    JPConf.add (JPConf1);
    JPConf2.setLayout (new java.awt.GridLayout (2, 0));
    JPConf21.setBorder (javax.swing.BorderFactory.createTitledBorder (bundle.getString ("NETWORK SETTINGS")));
    JPConf21.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    JLIPAddress.setText (bundle.getString ("REMOTE HOST IP ADDRESS"));
    JPConf21.add (JLIPAddress);
    TFIPAddress.setText (c.getIp ());
    TFIPAddress.setToolTipText (bundle.getString ("ENTER THE IP ADDRESS OF THE REMOTE HOST"));
    JPConf21.add (TFIPAddress);
    JLIPPort.setText (bundle.getString ("REMOTE LOCAL PORT"));
    JPConf21.add (JLIPPort);
    TFIPPort.setText ("" + c.getPort ());
    TFIPPort.setToolTipText (bundle.getString ("ENTER THE TCP-PORT USED (AT THIS HOST AND AT THE REMOTE HOST)"));
    JPConf21.add (TFIPPort);
    JPConf2.add (JPConf21);
    JPConf22.setBorder (javax.swing.BorderFactory.createTitledBorder (bundle.getString ("LANGUAGE SETTINGS")));
    JPConf22.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    CBLanguage.setText (bundle.getString ("USE SYSTEM DEFAULT"));
    CBLanguage.setToolTipText (bundle.getString ("TRY TO LET THE SOFTWARE CHOOSE THE LANGUAGE FOR YOU BASED ON YOUR SYSTEM SETTINGS"));
    CBLanguage.setActionCommand ("defaultlanguage");
    CBLanguage.addActionListener (this);
    JPConf22.add (CBLanguage);
    JCBLanguage.setModel (new javax.swing.DefaultComboBoxModel (new String [] {"Deutsch", "English", "Indonesia"}));
    JCBLanguage.setToolTipText (bundle.getString ("CHOOSE YOUR PREFERED LANGUAGE MANUALLY"));
    JPConf22.add (JCBLanguage);
    JPConf2.add (JPConf22);
    JPConf.add (JPConf2);
    JPConf3.setLayout (new java.awt.GridLayout (3, 0));
    javax.swing.GroupLayout JPConf31Layout = new javax.swing.GroupLayout (JPConf31);
    JPConf31.setLayout (JPConf31Layout);
    JPConf31Layout.setHorizontalGroup (JPConf31Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 1249, Short.MAX_VALUE));
    JPConf31Layout.setVerticalGroup (JPConf31Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 124, Short.MAX_VALUE));
    JPConf3.add (JPConf31);
    javax.swing.GroupLayout JPConf32Layout = new javax.swing.GroupLayout (JPConf32);
    JPConf32.setLayout (JPConf32Layout);
    JPConf32Layout.setHorizontalGroup (JPConf32Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 1249, Short.MAX_VALUE));
    JPConf32Layout.setVerticalGroup (JPConf32Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGap (0, 124, Short.MAX_VALUE));
    JPConf3.add (JPConf32);
    JPConf33.setLayout (new java.awt.BorderLayout ());
    JPConf331.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.LEFT));
    CBDebug.setText (bundle.getString ("SHOW THE DEBUG OUTPUT TAB"));
    CBDebug.setToolTipText (bundle.getString ("SHOWS AN ADDITONAL TAB WITH DEBUGGING INFORMATION"));
    CBDebug.setActionCommand ("usedebug");
    CBDebug.addActionListener (this);
    JPConf331.add (CBDebug);
    JPConf33.add (JPConf331, java.awt.BorderLayout.LINE_START);
    JPConf332.setLayout (new java.awt.FlowLayout (java.awt.FlowLayout.RIGHT));
    JBDefaultSettings.setText (bundle.getString ("RESTORE DEFAULT SETTINGS"));
    JBDefaultSettings.setToolTipText (bundle.getString ("SET THE CONFIGURATION BACK TO FACTURY DEFAULTS"));
    JBDefaultSettings.setActionCommand ("defaultsettings");
    JBDefaultSettings.addActionListener (this);
    JPConf332.add (JBDefaultSettings);
    JBConfSave.setText (bundle.getString ("APPLY SETTINGS"));
    JBConfSave.setToolTipText (bundle.getString ("APPLY AND SAVE THE CONFIGURATION"));
    JBConfSave.setActionCommand ("confsave");
    JBConfSave.addActionListener (this);
    JPConf332.add (JBConfSave);
    JBConfAbort.setText (bundle.getString ("ABORT"));
    JBConfAbort.setToolTipText (bundle.getString ("RESET THE CONFIGURATION TO THE LAST SAVED SETTINGS"));
    JBConfAbort.setActionCommand ("configabort");
    JBConfAbort.addActionListener (this);
    JPConf332.add (JBConfAbort);
    JPConf33.add (JPConf332, java.awt.BorderLayout.LINE_END);
    JPConf3.add (JPConf33);
    JPConf.add (JPConf3);
    TPMain.addTab (bundle.getString ("CONFIGURATION"), JPConf);
    JPDebug.setBorder (new javax.swing.border.SoftBevelBorder (javax.swing.border.BevelBorder.RAISED));
    JPDebug.setLayout (new java.awt.BorderLayout ());
    TADebug.setColumns (20);
    TADebug.setRows (5);
    SPDebug.setViewportView (TADebug);
    JPDebug.add (SPDebug, java.awt.BorderLayout.CENTER);
    TPMain.addTab (bundle.getString ("DEBUGGING OUTPUT"), JPDebug);
    getContentPane ().add (TPMain, java.awt.BorderLayout.CENTER);
    JMFile.setText (bundle.getString ("FILE"));
    JMFile.setActionCommand ("file");
    JMFile.addActionListener (this);
    MINew.setText (bundle.getString ("NEW FILE"));
    MINew.setToolTipText (bundle.getString ("CREATE A NEW FILE"));
    MINew.setActionCommand ("new");
    MINew.addActionListener (this);
    JMFile.add (MINew);
    MIOpen.setText (bundle.getString ("OPEN FILE"));
    MIOpen.setToolTipText (bundle.getString ("OPEN AN EXISTING FILE"));
    MIOpen.setActionCommand ("open");
    MIOpen.addActionListener (this);
    JMFile.add (MIOpen);
    MISave.setText (bundle.getString ("SAVE"));
    MISave.setToolTipText (bundle.getString ("SAVE CURRENT FILE"));
    MISave.setActionCommand ("save");
    MISave.addActionListener (this);
    JMFile.add (MISave);
    MISaveAs.setText (bundle.getString ("SAVE AS ..."));
    MISaveAs.setToolTipText (bundle.getString ("SAVE AS A NEW FILE"));
    MISaveAs.setActionCommand ("saveas");
    MISaveAs.addActionListener (this);
    JMFile.add (MISaveAs);
    MIExit.setText (bundle.getString ("EXIT"));
    MIExit.setToolTipText (bundle.getString ("EXIT THIS PROGRAM"));
    MIExit.setActionCommand ("exit");
    MIExit.addActionListener (this);
    JMFile.add (MIExit);
    MBMain.add (JMFile);
    JMAbout.setText (bundle.getString ("ABOUT"));
    JMAbout.setToolTipText (bundle.getString ("INFORMATION ABOUT THIS SOFTWARE"));
    JMAbout.setActionCommand ("aboutmenu");
    JMIAbout.setText (bundle.getString ("ABOUT THIS SOFTWARE"));
    JMIAbout.addActionListener (this);
    JMIAbout.setActionCommand ("about");
    JMAbout.add (JMIAbout);
    MBMain.add (JMAbout);
    setJMenuBar (MBMain);
    pack ();
}


-----Function Pair=157=-----==

public void setGMN (String str, boolean gmncode) {
    m_gmnscore.close ();
    int err = gmncode ? m_gmnscore.ParseString (str) : m_gmnscore.ParseFile (str);
    if (err != guido.guidoNoErr) {
        String msg = gmncode ? new String ("Error reading string:\n") + guido.GetErrorString (err) : new String ("Error opening ") + str + ":\n" + guido.GetErrorString (err);
        if (err == guido.guidoErrParse) {
            if (guido.xml2gmn () && ! gmncode) {
                System.out.println ("try xml 2 guido conversion:");
                String gmn = guido.xml2gmn (str);
                setGMN (gmn, true);
                return;
            }
            msg += " line " + guido.GetParseErrorLine ();
        }
        JOptionPane.showMessageDialog (this, msg);
        m_gmnscore = null;
    }
    else {
        err = m_gmnscore.AR2GR ();
        if (err != guido.guidoNoErr) {
            JOptionPane.showMessageDialog (this, "Error converting AR to GR " + str + ":\n" + guido.GetErrorString (err));
            m_gmnscore = null;
        }
        else {
            m_gmnscore.ResizePageToMusic ();
            repaint ();
        }
    }
}


private FredOutVal runNpopConfidenceInterval () {
    log.append ("Starting npop confidence interval: \n");
    narr.println ("Starting npop confidence interval: ");
    ArrayList bins = values.getBins ();
    int [] sequenceVals = values.getSeqVals ();
    File npopIn = new File ("npopIn.dat");
    File npopOut = new File ("npopOut.dat");
    String cmdNpop = "npopCI.exe";
    NpopConfidence npop = new NpopConfidence (hClimbResult, values, narr, log, npopIn, npopOut, cmdNpop, true);
    FredOutVal npopRes = npop.lowerBound ();
    log.append ("The result from npopCI lower bound: \n" + npopRes.toString () + "\n");
    narr.println ("The result from npopCI:");
    narr.println (npopRes.toString ());
    FredOutVal npopUpRes = npop.upperBound ();
    log.append ("The result from npopCI upper bound: \n" + npopUpRes.toString () + "\n");
    narr.println ("The result from npopCI upper bound:");
    narr.println (npopUpRes.toString ());
    npopConfidenceInterval = new int [2];
    npopConfidenceInterval [0] = npopRes.getNpop ();
    npopConfidenceInterval [1] = npopUpRes.getNpop ();
    return null;
}


-----Function Pair=158=-----==

public void getDefaultMachineCode () {
    debug += "\n=======================================" + "\ngetDefaultMachineCode()\n";
    gCode.add (new ProgramCode ("00", - 1999, 1999, - 12900, 12900, 0, 0, 0, 0, - 5999, 5999, - 32760, 32760, 0, 0, 0, 0, " ", " ", " ", " ", "G00", "X", "Z", " ", " ", true, true, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("RAPID TRAVERSE")));
    gCode.add (new ProgramCode ("01", - 1999, 1999, - 12900, 12900, 2, 199, 0, 0, - 5999, 5999, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G01", "X", "Z", "F", " ", true, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("LINEAR INTERPOLATION")));
    gCode.add (new ProgramCode ("02", - 1999, 1999, - 12900, 12900, 2, 199, 0, 0, - 5999, 5999, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G02", "X", "Z", "F", " ", true, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("CW CIRCULAR INTERPOLATION (2-D)")));
    gCode.add (new ProgramCode ("03", - 1999, 1999, - 12900, 12900, 2, 199, 0, 0, - 5999, 5999, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G03", "X", "Z", "F", " ", true, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("CCW CIRCULAR INTERPOLATION (2-D)")));
    gCode.add (new ProgramCode ("04", 0, 5999, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G04", "Time", " ", " ", " ", true, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("DWELL")));
    gCode.add (new ProgramCode ("21", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G21", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("EMPTY LINE")));
    gCode.add (new ProgramCode ("24", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G24", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("RADIUS PROGRAMMING")));
    gCode.add (new ProgramCode ("25", 0, 0, 0, 0, 0, 221, 0, 0, " ", " ", "L", " ", "G25", " ", " ", "Line", " ", false, false, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SUB-ROUTINE CALL-UP")));
    gCode.add (new ProgramCode ("27", 0, 0, 0, 0, 0, 221, 0, 0, " ", " ", "L", " ", "G27", " ", " ", "Line", " ", false, false, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("JUMP INSTRUCTION")));
    gCode.add (new ProgramCode ("33", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", "K", " ", "G33", " ", "Z", "K", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("THREADING WITH CONSTANT PITCH")));
    gCode.add (new ProgramCode ("64", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G64", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("FEED MOTORS CURRENTLESS")));
    gCode.add (new ProgramCode ("73", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G73", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("CHIP BREAKAGE CYCLE")));
    gCode.add (new ProgramCode ("78", - 1999, 1999, - 12900, 12900, 2, 199, 0, 999, - 5999, 5999, - 32760, 32760, 2, 499, 0, 999, " ", " ", "K", " ", "G78", "X", "Z", "K", "H", true, true, true, true, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("THREADING CYCLE")));
    gCode.add (new ProgramCode ("81", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G81", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("DRILLING CYCLE")));
    gCode.add (new ProgramCode ("82", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G82", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("DRILLING CYCLE WITH DWELL")));
    gCode.add (new ProgramCode ("83", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G83", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("DRILLING CYCLE, DEEP HOLE WITH WITHDRAWAL")));
    gCode.add (new ProgramCode ("84", - 1999, 1999, - 12900, 12900, 2, 199, 0, 999, - 5999, 5999, - 32760, 32760, 2, 499, 0, 999, " ", " ", " ", " ", "G84", "X", "Z", "F", "H", true, true, true, true, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("LONGITUDINAL TURNING")));
    gCode.add (new ProgramCode ("85", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G85", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("REAMING CYCLE")));
    gCode.add (new ProgramCode ("86", - 1999, 1999, - 12900, 12900, 2, 199, 10, 999, - 5999, 5999, - 32760, 32760, 2, 499, 10, 999, " ", " ", " ", " ", "G86", "X", "Z", "F", "H", true, true, true, true, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("GROOVING WITH DIVISION OF CUT (PARAMETER H)")));
    gCode.add (new ProgramCode ("88", - 1999, 1999, - 12900, 12900, 2, 199, 0, 999, - 5999, 5999, - 32760, 32760, 2, 499, 0, 999, " ", " ", " ", " ", "G88", "X", "Z", "F", "H", true, true, true, true, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("FACING WITH DIVISION OF CUT")));
    gCode.add (new ProgramCode ("89", 0, 0, - 12900, 12900, 2, 199, 0, 0, 0, 0, - 32760, 32760, 2, 499, 0, 0, " ", " ", " ", " ", "G89", " ", "Z", "F", " ", false, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("REAMING AND DRILLING WITH DWELL")));
    gCode.add (new ProgramCode ("90", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G90", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("ABSOLUTE MODE CANCELED ONLY BY G91")));
    gCode.add (new ProgramCode ("91", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G91", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("INCREMENTAL MODE CANCELED ONLY BY G90 OR G92")));
    gCode.add (new ProgramCode ("92", - 1999, 1999, - 12900, 12900, 0, 0, 0, 0, - 5999, 5999, - 32760, 32760, 0, 0, 0, 0, " ", " ", " ", " ", "G92", "X", "Z", " ", " ", true, true, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SET REGISTER (ZERO POINT OFFSET) ABSOLUTE MODE")));
    gCode.add (new ProgramCode ("94", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G94", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("FEED IN MM/MIN (OR IN/MIN)")));
    gCode.add (new ProgramCode ("95", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "G95", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("FEED IN MM/REV (OR IN/REV) ")));
    mCode.add (new ProgramCode ("M00", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M00", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("PROGRAMMED STOP (PAUSE)")));
    mCode.add (new ProgramCode ("M03", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M03", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SPINDLE ON, CW")));
    mCode.add (new ProgramCode ("M05", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M05", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SPINDLE OFF")));
    mCode.add (new ProgramCode ("M06", 0, 100, 0, 100, 0, 499, 0, 0, 0, 100, 0, 100, 0, 499, 0, 0, " ", " ", "T", " ", "M06", "X", "Z", "Tool", " ", true, true, true, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("TOOL LENGTH COMPENSATION")));
    mCode.add (new ProgramCode ("M08", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M08", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SWITCH EXIT X62 PIN 15 HIGH")));
    mCode.add (new ProgramCode ("M09", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M09", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SWITCH EXIT X62 PIN 15 LOW")));
    mCode.add (new ProgramCode ("M17", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M17", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("RETURN COMMAND TO THE MAIN PROGRAM")));
    mCode.add (new ProgramCode ("M22", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M22", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SWITCH EXIT X62 PIN 18 HIGH")));
    mCode.add (new ProgramCode ("M23", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M23", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SWITCH EXIT X62 PIN 18 LOW")));
    mCode.add (new ProgramCode ("M26", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M26", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("SWITCH EXIT X62 PIN 20")));
    mCode.add (new ProgramCode ("M30", 0, 0, 0, 0, 0, 0, 0, 0, " ", " ", " ", " ", "M30", " ", " ", " ", " ", false, false, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("END OF PROGRAM (MUST BE IN PROGRAM!!!)")));
    mCode.add (new ProgramCode ("M98", 0, 100, 0, 100, 0, 0, 0, 0, 0, 100, 0, 100, 0, 100, 0, 0, " ", " ", " ", " ", "M98", "X", "Z", " ", " ", true, true, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("AUTOMATIC COMPENSATION OF PLAY")));
    mCode.add (new ProgramCode ("M99", 0, 1999, 0, 12900, 0, 0, 0, 0, 0, 5999, 0, 5999, 0, 32760, 0, 0, "I", "K", " ", " ", "M99", "I", "K", " ", " ", true, true, false, false, java.util.ResourceBundle.getBundle ("MainFrameBundle").getString ("CIRCLE PARAMETER")));
}


private void renameFile () {
    boolean operationResult = false;
    boolean overallResult = true;
    int failCount = 0;
    String [] fileList = directory.list ();
    String Prefix = txtPrefix.getText ();
    String Rename = txtRename.getText ();
    String Suffix = txtSuffix.getText ();
    String digits = (String) cboSequence.getSelectedItem ();
    int StartingNum;
    String generatedSequence;
    File oldFile;
    if (cbxOutput.isSelected () && OUTPUT_ON == false) {
        buildOutput ();
        OUTPUT_ON = true;
    }
    for (int i = 0; i < fileList.length; i ++) {
        oldFile = new File (directory.getPath () + "/" + fileList [i]);
        String readability = fileList [i] + " - readable?: " + oldFile.canRead ();
        System.out.println (readability);
        if (OUTPUT_ON) txaOutput.append ("\n" + readability);
    }
    for (int i = 0; i < fileList.length; i ++) {
        oldFile = new File (directory.getPath () + "/" + fileList [i]);
        String fileExtension;
        if (cbxIgnoreExtension.isSelected () == true) {
            fileExtension = "";
        }
        else fileExtension = getFileExtension (fileList [i]);
        String fileName = getFileName (fileList [i]);
        String inputInfo = "The input filename->" + fileList [i] + "\nfile name->" + fileName + "\nextension->" + fileExtension;
        System.out.println (inputInfo);
        if (OUTPUT_ON) txaOutput.append ("\n" + inputInfo);
        if (digits.equals ("None") == true) {
            generatedSequence = "";
        }
        else {
            StartingNum = Integer.parseInt (txtSequence.getText ());
            generatedSequence = nameSequence (StartingNum + i, digits);
        }
        if (cbxRename.isSelected () == true) {
            fileName = Rename + generatedSequence;
        }
        else {
            fileName = fileName + generatedSequence;
        }
        String newFileName = Prefix + fileName + Suffix + fileExtension;
        String tentativeName = "new Filename will be ->" + newFileName + "\n";
        System.out.println (tentativeName);
        if (OUTPUT_ON) txaOutput.append ("\n" + tentativeName);
        if (cbxExperiment.isSelected () == false) {
            operationResult = oldFile.renameTo (new File (directory.getPath () + "/" + newFileName));
            String renameResult = "\t*Rename successfully?: " + operationResult + "\n\n";
            System.out.println (renameResult);
            if (operationResult == false) failCount ++;
            if (OUTPUT_ON) txaOutput.append ("\n" + renameResult);
            overallResult = (operationResult && overallResult);
        }
    }
    if (cbxExperiment.isSelected () == false) {
        System.out.println ("Overall Result: " + overallResult);
        System.out.println ("dir rename: " + directory.renameTo (new File ("test")));
        if (overallResult) JOptionPane.showMessageDialog (null, "All files renamed successfully!");
        else JOptionPane.showMessageDialog (null, "File renamed with " + failCount + " failure(s)");
    }
}


-----Function Pair=159=-----==

public void actionPerformed (ActionEvent e) {
    setoutdir = outdirfile.getText ();
    Font fn = new Font (ReadfnConf.getFontName (), Font.PLAIN, ReadfnConf.getFontSize ());
    set_fontName = fontNamejb.getSelectedItem ().toString ();
    int fontSize = Integer.parseInt (fontSizejb.getSelectedItem ().toString ());
    set_fontSize = fontSize;
    MutableAttributeSet attr = new SimpleAttributeSet ();
    StyleConstants.setFontFamily (attr, set_fontName);
    StyleConstants.setFontSize (attr, set_fontSize);
    StyleConstants.setForeground (attr, cf);
    StyleConstants.setBackground (attr, cb);
    getDocument ().setCharacterAttributes (0, my_doc.getLength (), attr, false);
    textPaneView.grabFocus ();
    textPaneView.repaint ();
    try {
        FileOutputStream outfo = new FileOutputStream (font_file);
        DataOutputStream outst = new DataOutputStream (outfo);
        outst.writeUTF (" " + "\n" + "FontName:" + set_fontName + "\n" + "FontSize:" + set_fontSize + "\n" + "FontColor:" + cf.getRGB () + "\n" + "FontBgColor:" + cb.getRGB () + "\n" + "WorkingDir:" + setoutdir + "\n" + "OpenLinkWith:" + openLinkWith.getText () + "\n");
        outst.close ();
        outfo.close ();
        top.removeAllChildren ();
        top.removeFromParent ();
        myTreeModel.reload ();
        sourceDir = new File ("" + setoutdir);
        if (! sourceDir.exists ()) warnme ("Directory Not Found");
        else if (sourceDir != null || sourceDir.exists ()) {
            File [] roots = sourceDir.listFiles ();
            for (int k = 0; k < roots.length; k ++) {
                myTreeModel.insertNodeInto (new DefaultMutableTreeNode (new IconData (ICON_FILES, null, roots [k].getName ())), top, k);
            }
            myTree.expandRow (0);
            myTree.repaint ();
        }
        setCurrentFile (sourceDir);
    } catch (IOException ie) {
    }
    j.show ();
}


private File getFile () {
    boolean cancelado = false;
    String path = System.getProperty ("user.dir");
    JFileChooser fileChooser = new JFileChooser (path);
    fileChooser.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    int result = fileChooser.showOpenDialog (this);
    if (result == JFileChooser.CANCEL_OPTION) {
        cancelado = true;
    }
    File fileName;
    fileName = fileChooser.getSelectedFile ();
    if (((fileName == null) || (fileName.getName ().equals (""))) && cancelado == false) {
        JOptionPane.showMessageDialog (this, "Invalid File Name", "Invalid File Name", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    return fileName;
}


-----Function Pair=160=-----==

public void actionPerformed (ActionEvent e) {
    if (ObjetList.getSelectedIndex () >= 0) {
        if (JOptionPane.showConfirmDialog (null, "Etes vous s√ªr de vouloir effacer cet objet?", "Effacer", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {
            paneunobjet.setVisible (false);
            for (int i = 0; i < parent.general.getMonstres ().size (); i ++) {
                for (int j = 0; j < parent.general.getMonstreByIndex (i).ObjectWin.size (); j ++) {
                    if (parent.general.getMonstreByIndex (i).ObjectWin.get (j) > ObjetList.getSelectedIndex ()) parent.general.getMonstreByIndex (i).ObjectWin.set (j, (short) (parent.general.getMonstreByIndex (i).ObjectWin.get (j) - 1));
                }
            }
            parent.general.getObjets ().remove (ObjetList.getSelectedIndex ());
            Objetmodel.remove (ObjetList.getSelectedIndex ());
            parent.monstres.StatsBaseChange ();
        }
    }
}


public void run () {
    if (running) {
        log.append ("Already running...\n");
    }
    else {
        running = true;
        FredOutVal result = runSigmaConfidenceInterval ();
        if (result != null) {
            if (userApproval (result)) {
                try {
                    readyForCI = false;
                    hClimbResult = hillClimbing (result);
                    readyForCI = true;
                } catch (IOException e) {
                    e.printStackTrace ();
                }
            }
        }
        running = false;
    }
}


-----Function Pair=161=-----==

private JPanel getJContentPane () {
    if (jContentPane == null) {
        exportLabel = new JLabel ();
        exportLabel.setBounds (new Rectangle (8, 45, 180, 16));
        exportLabel.setText ("Export project from source:");
        importLabel = new JLabel ();
        importLabel.setBounds (new Rectangle (8, 5, 180, 16));
        importLabel.setText ("Import project into source:");
        srcLabel = new JLabel ();
        srcLabel.setBounds (new Rectangle (8, 88, 300, 16));
        srcLabel.setText ("Source: " + srcFolder);
        srcLabel.setToolTipText (srcFolder);
        jContentPane = new JPanel ();
        jContentPane.setLayout (null);
        jContentPane.add (getImportTextField (), null);
        jContentPane.add (getExportTextField (), null);
        jContentPane.add (getBrowseImportButton (), null);
        jContentPane.add (getBrowseExportButton (), null);
        jContentPane.add (getBrowseSrcButton (), null);
        jContentPane.add (importLabel, null);
        jContentPane.add (exportLabel, null);
        jContentPane.add (srcLabel, null);
        jContentPane.add (getImportButton (), null);
        jContentPane.add (getExportButton (), null);
        jContentPane.add (getJScrollPane (), null);
        jContentPane.add (getCreateJar (), null);
        getProjectTree ();
    }
    return jContentPane;
}


public DiligentFrame () {
    super ("Diligent");
    setIconImage (ResourceManager.createImageIcon ("icons/closed.png").getImage ());
    prop = new Properties ();
    try {
        prop.load (new FileInputStream ("diligent.prop"));
    } catch (IOException e) {
        System.out.println ("Couldn't open .diligent.");
    }
    root = new DiligentNode ("root");
    treeModel = new DiligentTreeModel (root);
    if (prop.getProperty ("last", "").equals ("")) {
        setFilename ("");
    }
    else {
        open (prop.getProperty ("last"));
    }
    tree = new DiligentTree (treeModel);
    tree.addTreeExpansionListener (new TreeExpansionListener () {
        public void treeCollapsed (TreeExpansionEvent e) {
            DiligentNode node = (DiligentNode) e.getPath ().getLastPathComponent ();
            node.collapse ();
        } public void treeExpanded (TreeExpansionEvent e) {
            DiligentNode node = (DiligentNode) e.getPath ().getLastPathComponent ();
            node.expand ();
        }
    }
    );
    treeModel.addTreeModelListener (new TreeModelListener () {
        public void treeNodesChanged (TreeModelEvent e) {
            DiligentNode selected = (DiligentNode) tree.getLastSelectedPathComponent ();
            if (selected != null) selected.setName ((String) selected.getUserObject ());
            details.requery ();
            tree.requestFocusInWindow ();
        } public void treeNodesInserted (TreeModelEvent e) {
            DiligentNode selected = (DiligentNode) tree.getLastSelectedPathComponent ();
            if (selected != null) selected.dirty (true);
        } public void treeNodesRemoved (TreeModelEvent e) {
            DiligentNode selected = (DiligentNode) tree.getLastSelectedPathComponent ();
            if (selected != null) selected.dirty (true);
        } public void treeStructureChanged (TreeModelEvent e) {
            DiligentNode selected = (DiligentNode) tree.getLastSelectedPathComponent ();
            if (selected != null) selected.dirty (true);
        }
    }
    );
    final JPopupMenu popup = new JPopupMenu ();
    JMenu submenu = new JMenu ("Status");
    JMenuItem menuItem = new JMenuItem ("open", ResourceManager.createImageIcon ("icons/open.png"));
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                last.setStatus (DiligentNode.STATUS_OPEN);
            }
        }
    }
    );
    submenu.add (menuItem);
    menuItem = new JMenuItem ("accept", ResourceManager.createImageIcon ("icons/accepted.png"));
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                last.setStatus (DiligentNode.STATUS_ACCEPTED);
            }
        }
    }
    );
    submenu.add (menuItem);
    menuItem = new JMenuItem ("reject", ResourceManager.createImageIcon ("icons/rejected.png"));
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                last.setStatus (DiligentNode.STATUS_REJECTED);
            }
        }
    }
    );
    submenu.add (menuItem);
    menuItem = new JMenuItem ("close", ResourceManager.createImageIcon ("icons/closed.png"));
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                last.setStatus (DiligentNode.STATUS_CLOSED);
                details.requery ();
            }
        }
    }
    );
    submenu.add (menuItem);
    menuItem = new JMenuItem ("category");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                last.setStatus (DiligentNode.STATUS_CATEGORY);
            }
        }
    }
    );
    submenu.add (menuItem);
    popup.add (submenu);
    menuItem = new JMenuItem ("Add...");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DefaultTreeModel treeModel = (DefaultTreeModel) tree.getModel ();
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                treeModel.insertNodeInto (new DiligentNode ("new"), last, 0);
            }
        }
    }
    );
    popup.add (menuItem);
    menuItem = new JMenuItem ("Remove");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (tree.getSelectionPath () != null) {
                DefaultTreeModel treeModel = (DefaultTreeModel) tree.getModel ();
                DiligentNode last = (DiligentNode) tree.getLastSelectedPathComponent ();
                DiligentNode parent = (DiligentNode) last.getParent ();
                if (parent != null) treeModel.removeNodeFromParent (last);
            }
        }
    }
    );
    popup.add (menuItem);
    tree.addMouseListener (new MouseAdapter () {
        public void mousePressed (MouseEvent e) {
            if (e.getButton () == MouseEvent.BUTTON3) {
                tree.setSelectionRow (tree.getRowForLocation (e.getX (), e.getY ()));
                popup.show (e.getComponent (), e.getX (), e.getY ());
            }
        }
    }
    );
    details = new DiligentDetails (null);
    JSplitPane treeSplit = new JSplitPane (JSplitPane.HORIZONTAL_SPLIT, new JScrollPane (tree), new JScrollPane (details, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED));
    treeSplit.addAncestorListener (new AncestorListener () {
        public void ancestorAdded (AncestorEvent ae) {
        } public void ancestorMoved (AncestorEvent ae) {
        } public void ancestorRemoved (AncestorEvent ae) {
        }
    }
    );
    tableModel = new DiligentTableModel (treeModel);
    table = new DiligentTable (tableModel) {
        public void valueChanged (ListSelectionEvent e) {
            if (((DefaultListSelectionModel) e.getSource ()).isSelectionEmpty ()) return;
            final DiligentNode node = (DiligentNode) table.getValueAt (table.getSelectedRow (), 0);
            details.query (node);
            super.valueChanged (e);
        }
    }
    ;
    tree.addTreeSelectionListener (new TreeSelectionListener () {
        public void valueChanged (TreeSelectionEvent e) {
            final DiligentNode node = (DiligentNode) tree.getLastSelectedPathComponent ();
            details.query (node);
        }
    }
    );
    final JList filterList = new JList (DiligentFilter.filters);
    filterList.addListSelectionListener (new ListSelectionListener () {
        public void valueChanged (ListSelectionEvent e) {
            if (! e.getValueIsAdjusting ()) {
                root.setFilter (filterList.getSelectedIndex ());
                tableModel.fireTableDataChanged ();
                treeModel.nodeStructureChanged (root);
                Enumeration nodes = ((DiligentNode) treeModel.getRoot ()).breadthFirstEnumeration ();
                DiligentNode node;
                while (nodes.hasMoreElements ()) {
                    node = (DiligentNode) nodes.nextElement ();
                    if (node.isExpanded ()) {
                        DiligentNode parent = (DiligentNode) node.getParent ();
                        boolean expand = true;
                        while (parent != null && ! parent.isRoot () && expand) {
                            if (! parent.isExpanded ()) expand = false;
                            parent = (DiligentNode) parent.getParent ();
                        }
                        if (expand) tree.expandPath (new TreePath (node.getPath ()));
                    }
                }
            }
        }
    }
    );
    JTabbedPane tabbedPane = new JTabbedPane ();
    tabbedPane.addTab ("tree", new JScrollPane (tree));
    tabbedPane.addTab ("table", new JScrollPane (table));
    tabbedPane.addChangeListener (new ChangeListener () {
        public void stateChanged (ChangeEvent e) {
            tableModel.fireTableChanged (new TableModelEvent (tableModel));
        }
    }
    );
    JSplitPane filterSplit = new JSplitPane (JSplitPane.VERTICAL_SPLIT, filterList, tabbedPane);
    JSplitPane explorerSplit = new JSplitPane (JSplitPane.HORIZONTAL_SPLIT, filterSplit, details);
    getContentPane ().add (explorerSplit);
    JMenuBar menuBar = new JMenuBar ();
    setJMenuBar (menuBar);
    JMenu fileMenu = new JMenu ("File");
    menuBar.add (fileMenu);
    menuItem = new JMenuItem ("New");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (checkDirty ()) treeModel.setRoot (new DiligentNode ("root"));
            setFilename ("");
        }
    }
    );
    fileMenu.add (menuItem);
    menuItem = new JMenuItem ("Open...");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (checkDirty ()) open ();
        }
    }
    );
    fileMenu.add (menuItem);
    menuItem = new JMenuItem ("Save");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (prop.containsKey ("last")) save (prop.getProperty ("last"));
        }
    }
    );
    fileMenu.add (menuItem);
    menuItem = new JMenuItem ("Save As...");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            if (checkDirty ()) save ();
        }
    }
    );
    fileMenu.add (menuItem);
    JMenu menu = new JMenu ("Help");
    menuBar.add (menu);
    menuItem = new JMenuItem ("About...");
    menuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            JOptionPane.showMessageDialog (null, "$Revision: 4 $\n\n" + Constant.license);
        }
    }
    );
    menu.add (menuItem);
}


-----Function Pair=162=-----==

public static void gunzip (String gzsource, String filedest) throws FileNotFoundException, IOException {
    GZIPInputStream in = new GZIPInputStream (new FileInputStream (gzsource));
    try {
        BufferedInputStream bis = new BufferedInputStream (in);
        try {
            OutputStream out = new FileOutputStream (filedest);
            try {
                BufferedOutputStream bos = new BufferedOutputStream (out);
                try {
                    byte [] buf = new byte [BUFFER_SIZE];
                    int len;
                    while ((len = bis.read (buf, 0, BUFFER_SIZE)) != - 1) {
                        bos.write (buf, 0, len);
                    }
                    buf = null;
                } finally {
                    bos.close ();
                }
            } finally {
                out.close ();
            }
        } finally {
            bis.close ();
        }
    } finally {
        in.close ();
    }
}


public Boolean decompress (String sFilename, String sDestination) {
    logger.debug ("decompress(%s, %s)", sFilename, sDestination);
    BufferedOutputStream oDestination;
    FileInputStream oOrigin;
    ZipInputStream oInput = null;
    try {
        oDestination = null;
        oOrigin = new FileInputStream (new File (sFilename));
        oInput = new ZipInputStream (new BufferedInputStream (oOrigin));
        int iCount;
        byte aData [] = new byte [BUFFER_SIZE];
        ZipEntry oEntry;
        while ((oEntry = oInput.getNextEntry ()) != null) {
            if (oEntry.isDirectory ()) new File (sDestination + File.separator + oEntry.getName ()).mkdirs ();
            else {
                try {
                    String sDestDN = oLibraryFile.getDirname (sDestination + File.separator + oEntry.getName ());
                    String sDestFN = sDestination + File.separator + oEntry.getName ();
                    new File (sDestDN).mkdirs ();
                    FileOutputStream oOutput = new FileOutputStream (sDestFN);
                    oDestination = new BufferedOutputStream (oOutput, BUFFER_SIZE);
                    while ((iCount = oInput.read (aData, 0, BUFFER_SIZE)) != - 1) {
                        oDestination.write (aData, 0, iCount);
                    }
                    oDestination.flush ();
                } finally {
                    StreamHelper.close (oDestination);
                }
            }
        }
    } catch (Exception oException) {
        logger.error (oException.getMessage (), oException);
        return false;
    } finally {
        StreamHelper.close (oInput);
    }
    return true;
}


-----Function Pair=163=-----==

private FileWrapper getDir (FileWrapper parent, String dirName, boolean create) {
    FileWrapper result = null;
    if (dirName != null) {
        result = _fileWrapperFactory.create (parent, dirName);
    }
    else {
        result = parent;
    }
    if (! result.isDirectory ()) {
        if (result.exists ()) {
            s_log.error (dirName + " directory (" + result.getAbsolutePath () + ") doesn't appear to be a directory");
        }
        else {
            if (create) {
                result.mkdir ();
            }
        }
    }
    return result;
}


protected static void loadHistory (Element root) {
    try {
        int m = 0;
        Element hElement = (Element) root.getElementsByTagName ("History").item (0);
        if (hElement != null) {
            NodeList nList = hElement.getElementsByTagName ("Projects");
            for (int n = 0; n < nList.getLength (); n ++) {
                Element aElement = (Element) nList.item (n);
                NodeList aList = aElement.getElementsByTagName ("*");
                for (int x = 0; x < aList.getLength (); x ++) {
                    projectNames.addElement (aList.item (x).getFirstChild ().getNodeValue ());
                    m ++;
                    if (m == maxHistory) return;
                }
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=164=-----==

private void packFile (final File file, final ZipOutputStream out, final String name, final FileFilter filter) throws IOException {
    if (filter != null && ! filter.accept (file)) return;
    if (file.isDirectory ()) {
        final File [] list = file.listFiles ();
        if (list == null) return;
        for (final File element : list) if (name == null) packFile (element, out, file.getName (), filter);
        else packFile (element, out, name + "/" + file.getName (), filter);
    }
    else {
        ZipEntry entry = null;
        if (name == null) entry = new ZipEntry (file.getName ());
        else entry = new ZipEntry (name + "/" + file.getName ());
        try {
            out.putNextEntry (entry);
        } catch (final ZipException e) {
            throw new C4JRuntimeException (format ("Could not pack file ‚Äò%s‚Äô.", file.getPath ()), e);
        }
        InputStream fileIn = null;
        try {
            fileIn = new FileInputStream (file);
            use_filetools ().copyStream2Stream (fileIn, out);
        } finally {
            if (fileIn != null) fileIn.close ();
        }
        out.closeEntry ();
    }
}


void openZip (String path) {
    ZipInputStream in = null;
    ByteArrayOutputStream out;
    int nRois = 0;
    try {
        in = new ZipInputStream (new FileInputStream (path));
        byte [] buf = new byte [1024];
        int len;
        ZipEntry entry = in.getNextEntry ();
        while (entry != null) {
            String name = entry.getName ();
            if (name.endsWith (".roi")) {
                out = new ByteArrayOutputStream ();
                while ((len = in.read (buf)) > 0) out.write (buf, 0, len);
                out.close ();
                byte [] bytes = out.toByteArray ();
                RoiDecoder rd = new RoiDecoder (bytes, name);
                Roi roi = rd.getRoi ();
                if (roi != null) {
                    name = name.substring (0, name.length () - 4);
                    name = getUniqueName (name);
                    list.add (name);
                    rois.put (name, roi);
                    nRois ++;
                }
            }
            entry = in.getNextEntry ();
        }
        in.close ();
    } catch (IOException e) {
        error (e.toString ());
    }
    if (nRois == 0) error ("This ZIP archive does not appear to contain \".roi\" files");
    updateShowAll ();
}


-----Function Pair=165=-----==

private WebdavResource allocResource (WebdavResource resource, String uri, String login, String password, String filePath) {
    try {
        httpURL = uriToHttpURL (uri, login, password);
        if (resource == null) {
            UsernamePasswordCredentials cred = new UsernamePasswordCredentials (configuration.getConfigurationValue ("Proxy", "username"), configuration.getConfigurationValue ("Proxy", "password"));
            if (configuration.getConfigurationValue ("Proxy", "proxyUse").equals ("True")) {
                resource = new WebdavResource (httpURL, filePath, configuration.getConfigurationValue ("Proxy", "host"), new Integer (configuration.getConfigurationValue ("Proxy", "port")).intValue (), cred, true);
            }
            else resource = new WebdavResource (httpURL, filePath);
            resource.setDebug (debugLevel);
        }
        else {
            resource.close ();
            resource.setHttpURL (httpURL);
        }
    } catch (Exception ex) {
        handleException (ex);
        resource = null;
        httpURL = null;
    }
    return resource;
}


private static void addTargetFile (ZipOutputStream zos, File file) throws FileNotFoundException, ZipException, IOException {
    try {
        BufferedInputStream bis = new BufferedInputStream (new FileInputStream (file));
        String file_path = file.getPath ();
        if (file_path.startsWith (OctopusApplication.PATH_EXPORT_FOLDER)) {
            file_path = file_path.substring (OctopusApplication.PATH_EXPORT_FOLDER.length (), file_path.length ());
        }
        ZipEntry target = new ZipEntry (file_path);
        zos.putNextEntry (target);
        int c;
        while ((c = bis.read ()) != - 1) {
            zos.write ((byte) c);
        }
        bis.close ();
        zos.closeEntry ();
    } catch (FileNotFoundException e) {
        throw e;
    } catch (ZipException e) {
        throw e;
    } catch (IOException e) {
        throw e;
    }
}


-----Function Pair=166=-----==

public void exportMySelf (File f) {
    setQuality (true);
    BufferedImage exportImage = new BufferedImage (size [0], size [1], (f.getName ().endsWith ("jpg")) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = exportImage.createGraphics ();
    g.setRenderingHints (getRenderingHints ());
    drawMySelfHighQuality (g);
    Iterator it = ImageIO.getImageWriters (new ImageTypeSpecifier (exportImage), (f.getName ().endsWith ("jpg")) ? "jpg" : "png");
    if (! it.hasNext ()) {
        CDoxFrame.handleError (new Throwable (CDox.getLocalizer ().get ("nowriter")), false);
        setQuality (false);
        return;
    }
    ImageWriter iw = (ImageWriter) it.next ();
    try {
        ImageOutputStream ios = ImageIO.createImageOutputStream (f);
        iw.setOutput (ios);
        iw.write (exportImage);
        iw.dispose ();
        ios.flush ();
        ios.close ();
        System.gc ();
    } catch (IOException ioe) {
        setQuality (false);
        CDoxFrame.handleError (ioe, true);
    }
    setQuality (false);
}


public void closeEntry () throws IOException {
    if (curEntry == null) throw new ZipException ("No open entry");
    if (curMethod == DEFLATED) super.finish ();
    int csize = curMethod == DEFLATED ? def.getTotalOut () : size;
    if (curEntry.getSize () < 0) curEntry.setSize (size);
    else if (curEntry.getSize () != size) throw new ZipException ("size was " + size + ", but I expected " + curEntry.getSize ());
    if (curEntry.getCompressedSize () < 0) curEntry.setCompressedSize (csize);
    else if (curEntry.getCompressedSize () != csize) throw new ZipException ("compressed size was " + csize + ", but I expected " + curEntry.getSize ());
    if (curEntry.getCrc () < 0) curEntry.setCrc (crc.getValue ());
    else if (curEntry.getCrc () != crc.getValue ()) throw new ZipException ("crc was " + toHexString (crc.getValue ()) + ", but I expected " + toHexString (curEntry.getCrc ()));
    offset += csize;
    if (curMethod == DEFLATED && (curEntry.flags & 8) != 0) {
        writeLeInt (EXTSIG);
        writeLeInt ((int) curEntry.getCrc ());
        writeLeInt ((int) curEntry.getCompressedSize ());
        writeLeInt ((int) curEntry.getSize ());
        offset += EXTHDR;
    }
    entries.addElement (curEntry);
    curEntry = null;
}


-----Function Pair=167=-----==

protected void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType ("application/octet-stream");
    String reportIds = request.getParameter ("reportIds");
    String dashboardIds = request.getParameter ("dashboardIds");
    ArrayList < Object > xmlDatas = new ArrayList < Object > ();
    TreeMap < String, ReportCategory > categories = new TreeMap < String, ReportCategory > ();
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    ZipOutputStream zos = new ZipOutputStream (baos);
    TreeMap < String, Report > reports = new TreeMap < String, Report > ();
    if (reportIds != null) {
        for (StringTokenizer st = new StringTokenizer (reportIds, ","); st.hasMoreTokens ();) {
            Long reportId = Long.valueOf (st.nextToken ());
            Report report = getReportService ().findReportById (reportId);
            reports.put (report.getName (), report);
            if (! categories.containsKey (report.getCategory ().getName ())) {
                categories.put (report.getCategory ().getName (), report.getCategory ());
            }
        }
    }
    List < Dashboard > dashboards = new ArrayList < Dashboard > ();
    if (dashboardIds != null) {
        for (StringTokenizer st = new StringTokenizer (dashboardIds, ","); st.hasMoreTokens ();) {
            Long dashboardId = Long.valueOf (st.nextToken ());
            Dashboard dashboard = getReportService ().findDashboardById (dashboardId);
            dashboards.add (dashboard);
            if (! categories.containsKey (dashboard.getCategory ().getName ())) {
                categories.put (dashboard.getCategory ().getName (), dashboard.getCategory ());
            }
            for (DashboardColumn column : dashboard.getColumns ()) {
                for (DashboardReport dashboardReport : column.getDashboardReports ()) {
                    Report report = dashboardReport.getReport ();
                    if (! reports.containsKey (report.getName ())) {
                        reports.put (report.getName (), report);
                        if (! categories.containsKey (report.getCategory ().getName ())) {
                            categories.put (report.getCategory ().getName (), report.getCategory ());
                        }
                    }
                }
            }
        }
    }
    for (ReportCategory category : categories.values ()) {
        XmlReportCategory xmlCategory = new XmlReportCategory ();
        xmlCategory.setName (category.getName ());
        xmlDatas.add (xmlCategory);
    }
    for (Report report : reports.values ()) {
        XmlReport xmlReport = new XmlReport ();
        xmlReport.setName (report.getName ());
        xmlReport.setHidden (report.getHidden ());
        xmlReport.setReportCategoryName (report.getCategory ().getName ());
        String fileName = report.getName () + ".rptdesign";
        xmlReport.setReportContentPath (fileName);
        ZipEntry ze = new ZipEntry (fileName);
        zos.putNextEntry (ze);
        IOUtils.write (report.getReportContent (), zos);
        zos.closeEntry ();
        xmlReport.setReportingSystem (report.getReportingSystem ().getName ());
        List < XmlReportParam > xmlReportParams = new ArrayList < XmlReportParam > ();
        for (ReportParam param : report.getParams ()) {
            XmlReportParam xmlReportParam = new XmlReportParam ();
            xmlReportParam.setAsk (param.getAsk ());
            xmlReportParam.setChooser (param.getChooser ().getName ());
            xmlReportParam.setDefault (param.getDefault ());
            xmlReportParam.setName (param.getName ());
            xmlReportParam.setPrompt (param.getPrompt ());
            xmlReportParams.add (xmlReportParam);
        }
        xmlReport.setReportParams (xmlReportParams);
        xmlDatas.add (xmlReport);
    }
    for (Dashboard dashboard : dashboards) {
        XmlDashboard xmlDashboard = new XmlDashboard ();
        xmlDashboard.setName (dashboard.getName ());
        xmlDashboard.setHidden (dashboard.getHidden ());
        xmlDashboard.setReportCategoryName (dashboard.getCategory ().getName ());
        List < XmlDashboardColumn > xmlDashboardColumns = new ArrayList < XmlDashboardColumn > ();
        for (DashboardColumn dashboardColumn : dashboard.getColumns ()) {
            XmlDashboardColumn xmlDashboardColumn = new XmlDashboardColumn ();
            xmlDashboardColumn.setIndex (dashboardColumn.getIndex ());
            xmlDashboardColumn.setWidth (dashboardColumn.getWidth ());
            List < XmlDashboardReport > xmlDashboardReports = new ArrayList < XmlDashboardReport > ();
            for (DashboardReport dashboardReport : dashboardColumn.getDashboardReports ()) {
                XmlDashboardReport xmlDashboardReport = new XmlDashboardReport ();
                xmlDashboardReport.setHeight (dashboardReport.getHeight ());
                xmlDashboardReport.setReportName (dashboardReport.getReport ().getName ());
                xmlDashboardReport.setRowIndex (dashboardReport.getRowIndex ());
                xmlDashboardReport.setTitle (dashboardReport.getTitle ());
                List < XmlDashboardParamBinding > xmlDashboardParamBindings = new ArrayList < XmlDashboardParamBinding > ();
                for (DashboardParamBinding dashboardParamBinding : dashboardReport.getDashboardParamBindings ()) {
                    XmlDashboardParamBinding xmlDashboardParamBinding = new XmlDashboardParamBinding ();
                    xmlDashboardParamBinding.setDashboardParamName (dashboardParamBinding.getDashboardParam ().getName ());
                    xmlDashboardParamBinding.setReportParamName (dashboardParamBinding.getReportParam ().getName ());
                    xmlDashboardParamBindings.add (xmlDashboardParamBinding);
                }
                xmlDashboardReport.setDashboardParamBindings (xmlDashboardParamBindings);
                xmlDashboardReports.add (xmlDashboardReport);
            }
            xmlDashboardColumn.setDashboardReports (xmlDashboardReports);
            xmlDashboardColumns.add (xmlDashboardColumn);
        }
        xmlDashboard.setDashboardColumns (xmlDashboardColumns);
        List < XmlReportParam > xmlReportParams = new ArrayList < XmlReportParam > ();
        for (ReportParam param : dashboard.getParams ()) {
            XmlReportParam xmlReportParam = new XmlReportParam ();
            xmlReportParam.setAsk (param.getAsk ());
            xmlReportParam.setChooser (param.getChooser ().getName ());
            xmlReportParam.setDefault (param.getDefault ());
            xmlReportParam.setName (param.getName ());
            xmlReportParam.setPrompt (param.getPrompt ());
            xmlReportParams.add (xmlReportParam);
        }
        xmlDashboard.setReportParams (xmlReportParams);
        xmlDatas.add (xmlDashboard);
    }
    ZipEntry ze = new ZipEntry ("report-datas.xml");
    zos.putNextEntry (ze);
    XStream xstream = new XStream ();
    String xmlDatasAsString = xstream.toXML (xmlDatas);
    IOUtils.write (xmlDatasAsString.getBytes (), zos);
    zos.closeEntry ();
    zos.close ();
    byte [] zipContent = baos.toByteArray ();
    response.setContentLength (zipContent.length);
    response.setHeader ("Content-Disposition", "attachment; filename=\"appspy-export.zip\"");
    OutputStream os = response.getOutputStream ();
    org.apache.commons.io.IOUtils.write (zipContent, os);
    os.close ();
}


public static String read (File from) {
    try {
        BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (from)));
        StringWriter sw = new StringWriter ();
        String line = "";
        while ((line = br.readLine ()) != null) {
            sw.append (line).append ("\n");
        }
        br.close ();
        sw.close ();
        return sw.toString ();
    } catch (IOException e) {
        e.printStackTrace ();
        return null;
    }
}


-----Function Pair=168=-----==

public void compress (ZipOutputStream output, String prefix) throws IOException {
    Iterator < IVirtualArtifact > artifacts = this.getArtifacts ();
    while (artifacts.hasNext ()) {
        IVirtualArtifact artifact = artifacts.next ();
        String name = prefix + (artifact instanceof IVirtualFile ? artifact.getName () : artifact.getName () + "/");
        log.info ("Adding " + name + " to compressed archive");
        try {
            ZipEntry entry = new ZipEntry (name);
            output.putNextEntry (entry);
            if (artifact instanceof IVirtualFile) {
                IOUtil.transfer (((IVirtualFile) artifact).getInputStream (), output);
            }
            output.closeEntry ();
        } catch (ZipException e) {
            if (e.getMessage ().contains ("duplicate entry")) {
                log.warn ("Ignoring duplicate artifact: " + name);
            }
            else throw e;
        }
        if (artifact instanceof IVirtualDirectory) {
            ((IVirtualDirectory) artifact).compress (output, prefix + artifact.getName () + "/");
        }
    }
}


public Component getTreeCellRendererComponent (JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus) {
    DefaultTreeCellRenderer dtcr = new DefaultTreeCellRenderer ();
    Component c = dtcr.getTreeCellRendererComponent (tree, value, selected, expanded, leaf, row, hasFocus);
    if (((DefaultMutableTreeNode) value).getUserObject () instanceof String) return c;
    final Color selectedColor = (Color) ((DefaultMutableTreeNode) value).getUserObject ();
    ((JLabel) c).setText ("(" + selectedColor.getRed () + "," + selectedColor.getGreen () + "," + selectedColor.getBlue () + ")");
    ((JLabel) c).setHorizontalTextPosition (0);
    ((JLabel) c).setHorizontalAlignment (JLabel.LEFT);
    Icon ic = new Icon () {
        public int getIconHeight () {
            return 15;
        } public int getIconWidth () {
            return 90;
        } public void paintIcon (Component c, Graphics g, int x, int y) {
            g.setColor (selectedColor);
            g.fillRect (x, y, 200, 100);
        }
    }
    ((JLabel) c).setIcon (ic);
    return c;
}


-----Function Pair=169=-----==

public static File [] extractOnlyFiles (File directory) {
    File [] fileNames = directory.listFiles ();
    if (fileNames == null) return null;
    ArrayList < File > al = new ArrayList < File > ();
    Pattern pat = Pattern.compile ("^\\w+.*");
    Matcher mat;
    for (int i = 0; i < fileNames.length; i ++) {
        if (fileNames [i].isDirectory ()) continue;
        mat = pat.matcher (fileNames [i].getName ());
        if (mat.matches ()) al.add (fileNames [i]);
    }
    if (al.size () != 0) {
        File [] files = new File [al.size ()];
        al.toArray (files);
        Arrays.sort (files);
        return files;
    }
    else return null;
}


public void zip (String resourceName) {
    String [] filenames = new String [2];
    if (new File (ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.DATASET_EXTENSION_1).exists ()) filenames [0] = ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.DATASET_EXTENSION_1;
    else if (new File (ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.DATASET_EXTENSION_2).exists ()) filenames [0] = ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.DATASET_EXTENSION_2;
    if (new File (ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.METADATA_EXTENSION_1).exists ()) filenames [1] = ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.METADATA_EXTENSION_1;
    else if (new File (ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.METADATA_EXTENSION_2).exists ()) filenames [1] = ResourceSettings.UPLOAD_PATH + resourceName + ResourceSettings.METADATA_EXTENSION_2;
    byte [] buf = new byte [1024];
    try {
        String outFilename = ResourceSettings.DOWNLOAD_PATH + resourceName + ResourceSettings.ARCHIVE_EXTENSION_1;
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < filenames.length; i ++) {
            File tmpFile = new File (filenames [i]);
            FileInputStream in = new FileInputStream (tmpFile);
            out.putNextEntry (new ZipEntry (tmpFile.getName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
        System.out.println ("IO EXCEPTION: " + e.getMessage ());
    }
}


-----Function Pair=170=-----==

protected void writeLocalFileHeader (ZipEntry ze) throws IOException {
    offsets.put (ze, ZipLong.getBytes (written));
    writeOut (LFH_SIG);
    written += WORD;
    final int zipMethod = ze.getMethod ();
    if (zipMethod == DEFLATED && raf == null) {
        writeOut (ZipShort.getBytes (20));
        writeOut (ZipShort.getBytes (8));
    }
    else {
        writeOut (ZipShort.getBytes (10));
        writeOut (ZERO);
    }
    written += WORD;
    writeOut (ZipShort.getBytes (zipMethod));
    written += SHORT;
    writeOut (toDosTime (ze.getTime ()));
    written += WORD;
    localDataStart = written;
    if (zipMethod == DEFLATED || raf != null) {
        writeOut (LZERO);
        writeOut (LZERO);
        writeOut (LZERO);
    }
    else {
        writeOut (ZipLong.getBytes (ze.getCrc ()));
        writeOut (ZipLong.getBytes (ze.getSize ()));
        writeOut (ZipLong.getBytes (ze.getSize ()));
    }
    written += 12;
    byte [] name = getBytes (ze.getName ());
    writeOut (ZipShort.getBytes (name.length));
    written += SHORT;
    byte [] extra = ze.getLocalFileDataExtra ();
    writeOut (ZipShort.getBytes (extra.length));
    written += SHORT;
    writeOut (name);
    written += name.length;
    writeOut (extra);
    written += extra.length;
    dataStart = written;
}


public static BundleType getBundleType (File bundleFile) {
    if (bundleFile == null) return null;
    if (bundleFile.isDirectory ()) {
        if (new File (bundleFile, "plugin.xml").exists ()) return BundleType.Plugin;
        if (new File (bundleFile, "fragment.xml").exists ()) return BundleType.Fragment;
        File manifestFile = new File (bundleFile, JarFile.MANIFEST_NAME);
        if (! manifestFile.exists ()) return null;
        try {
            InputStream manifestStream = new FileInputStream (manifestFile);
            Manifest manifest = new Manifest (manifestStream);
            Attributes attributes = manifest.getMainAttributes ();
            if (attributes == null) {
                logger.error ("The given bundle doesn't have a main section in its MANIFEST.MF! " + "Hence, we cannot determine its bundle type => it will be skipped! bundle=" + bundleFile.getAbsolutePath ());
                return null;
            }
            String value = attributes.getValue ("Fragment-Host");
            if (value == null) return BundleType.Plugin;
            else return BundleType.Fragment;
        } catch (IOException e) {
            throw new RuntimeException ("Couldn't read the MANIFEST.MF!", e);
        }
    }
    else {
        if (! "jar".equalsIgnoreCase (IOUtil.getFileExtension (bundleFile.getName ()))) return null;
        JarFile jarFileToUpload;
        try {
            jarFileToUpload = new JarFile (bundleFile, false);
            ZipEntry entry = jarFileToUpload.getEntry ("fragment.xml");
            if (entry != null && ! entry.isDirectory ()) return BundleType.Fragment;
            entry = jarFileToUpload.getEntry ("plugin.xml");
            if (entry != null && ! entry.isDirectory ()) return BundleType.Plugin;
            Manifest manifest = jarFileToUpload.getManifest ();
            if (manifest == null) return null;
            Attributes attributes = manifest.getMainAttributes ();
            if (attributes == null) {
                logger.error ("The given bundle doesn't have a main section in its MANIFEST.MF! " + "Hence, we cannot determine its bundle type => it will be skipped! bundle=" + bundleFile.getAbsolutePath ());
                return null;
            }
            String value = attributes.getValue ("Fragment-Host");
            if (value == null) return BundleType.Plugin;
            else return BundleType.Fragment;
        } catch (IOException e) {
            logger.warn ("Couldn't read the jarFile for BundleType checking!", e);
        }
    }
    return null;
}


-----Function Pair=171=-----==

public static long unzipToDir (InputStream inzip, String basedirdest) throws IOException, SecurityException {
    long sum = 0;
    File base = new File (basedirdest);
    if (! base.exists ()) base.mkdirs ();
    try {
        CheckedInputStream checksum = new CheckedInputStream (inzip, new Adler32 ());
        try {
            BufferedInputStream bis = new BufferedInputStream (checksum);
            try {
                ZipInputStream zis = new ZipInputStream (bis);
                try {
                    ZipEntry entry;
                    File f;
                    int count;
                    byte [] buf = new byte [BUFFER_SIZE];
                    BufferedOutputStream bos;
                    FileOutputStream fos;
                    while ((entry = zis.getNextEntry ()) != null) {
                        f = new File (basedirdest, entry.getName ());
                        if (entry.isDirectory ()) f.mkdirs ();
                        else {
                            int l = entry.getName ().lastIndexOf ('/');
                            if (l != - 1) {
                                new File (basedirdest, entry.getName ().substring (0, l)).mkdirs ();
                            }
                            fos = new FileOutputStream (f);
                            try {
                                bos = new BufferedOutputStream (fos, BUFFER_SIZE);
                                try {
                                    while ((count = zis.read (buf, 0, BUFFER_SIZE)) != - 1) {
                                        bos.write (buf, 0, count);
                                    }
                                } finally {
                                    bos.close ();
                                }
                            } finally {
                                fos.close ();
                            }
                        }
                        if (entry.getTime () != - 1) {
                            f.setLastModified (entry.getTime ());
                        }
                    }
                } finally {
                    zis.close ();
                }
            } finally {
                bis.close ();
            }
        } finally {
            checksum.close ();
        }
        sum = checksum.getChecksum ().getValue ();
    } finally {
        inzip.close ();
    }
    return sum;
}


private List < Element > getListOfNodeToInsert (Element textToAppend, TreeMap < String, String > mapOldIdToNewId) {
    ArrayList < Element > listOfNodes = new ArrayList < Element > ();
    for (Iterator j = textToAppend.elementIterator (); j.hasNext ();) {
        Element curNodeToInsert = (Element) j.next ();
        if (isNodeParagraphOrTable (curNodeToInsert)) {
            Element copyNode = (Element) (curNodeToInsert.clone ());
            ArrayList < Element > listOfImages = new ArrayList < Element > ();
            Picture.getListReferenceForImages (copyNode, listOfImages);
            if (! listOfImages.isEmpty ()) {
                if (! Picture.addNewReferences (listOfImages, mapOldIdToNewId)) {
                    return null;
                }
            }
            listOfNodes.add (copyNode);
        }
        else {
            logger.debug ("node ignored for paragraph insertion:" + curNodeToInsert.getName () + " " + curNodeToInsert.getStringValue ());
        }
    }
    return listOfNodes;
}


-----Function Pair=172=-----==

public static HashMap < String, String > loadFileIntoHashMap (File file) {
    HashMap < String, String > names = new HashMap < String, String > (1000);
    try {
        BufferedReader in = IO.fetchBufferedReader (file);
        String line;
        String [] keyValue;
        while ((line = in.readLine ()) != null) {
            keyValue = line.split ("\\s+");
            if (keyValue.length != 2 || keyValue [0].startsWith ("#")) continue;
            names.put (keyValue [0].trim (), keyValue [1].trim ());
        }
    } catch (Exception e) {
        System.out.println ("Prob loadFileInttoHash()");
        e.printStackTrace ();
    }
    return names;
}


private long doChecksum (String fileName) {
    CheckedInputStream cis = null;
    try {
        cis = new CheckedInputStream (new FileInputStream (fileName), new CRC32 ());
    } catch (FileNotFoundException e) {
        System.err.println ("File not found.");
        System.exit (1);
    }
    byte [] buf = new byte [128];
    try {
        while (cis.read (buf) >= 0);
    } catch (IOException e) {
        throw new RuntimeException ("error while reading file", e);
    }
    long checksum = cis.getChecksum ().getValue ();
    return checksum;
}


-----Function Pair=173=-----==

public static LinkedHashSet loadFileIntoLinkedHashSet (File file) {
    LinkedHashSet names = new LinkedHashSet (10000);
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line;
        while ((line = in.readLine ()) != null) {
            line = line.trim ();
            if (line.length () == 0) continue;
            names.add (line);
        }
    } catch (Exception e) {
        System.out.println ("Prob loadFileIntoLinkedHashSet()");
        e.printStackTrace ();
    }
    return names;
}


public void verRecordatorioInterfaz (String h, String l, String a) {
    marco = new JFrame ("Ver un Recordatorio");
    marco.addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            marco.hide ();
            marco.dispose ();
        }
    }
    );
    horaL = new JLabel ("Hora:");
    lugarL = new JLabel ("Lugar:");
    actividadL = new JLabel ("Actividad:");
    horaT = new JTextField (5);
    horaT.setEditable (false);
    lugarT = new JTextField (10);
    lugarT.setEditable (false);
    actividadT = new JTextArea (10, 35);
    actividadT.setEditable (false);
    JPanel c1 = new JPanel (new GridLayout (2, 1));
    c1.add (horaL);
    c1.add (horaT);
    JPanel c2 = new JPanel (new GridLayout (2, 1));
    c2.add (lugarL);
    c2.add (lugarT);
    JPanel c3 = new JPanel (new BorderLayout (1, 1));
    c3.add (actividadL, BorderLayout.NORTH);
    c3.add (new JScrollPane (actividadT), BorderLayout.SOUTH);
    JPanel c4 = new JPanel (new BorderLayout (5, 5));
    c4.add (c1, BorderLayout.NORTH);
    c4.add (c2, BorderLayout.CENTER);
    c4.add (c3, BorderLayout.SOUTH);
    JPanel c5 = new JPanel (new FlowLayout (FlowLayout.CENTER));
    c5.add (c4);
    marco.getContentPane ().add (c5);
    horaT.setText (h);
    lugarT.setText (l);
    actividadT.setText (a);
    marco.setSize (300, 350);
    marco.show ();
}


-----Function Pair=174=-----==

public static String [] loadFile (File file) {
    ArrayList a = new ArrayList ();
    try {
        BufferedReader in = IO.fetchBufferedReader (file);
        String line;
        while ((line = in.readLine ()) != null) {
            line = line.trim ();
            a.add (line);
        }
    } catch (Exception e) {
        System.out.println ("Prob loadFileInto String[]");
        e.printStackTrace ();
    }
    String [] strings = new String [a.size ()];
    a.toArray (strings);
    return strings;
}


public static String getPagina (String strurl) {
    String resp = "";
    Authenticator.setDefault (new Autenticador ());
    try {
        URL url = new URL (strurl);
        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));
        String str;
        while ((str = in.readLine ()) != null) {
            resp += str;
        }
        in.close ();
    } catch (MalformedURLException e) {
        resp = e.toString ();
    } catch (IOException e) {
        resp = e.toString ();
    } catch (Exception e) {
        resp = e.toString ();
    }
    return resp;
}


-----Function Pair=175=-----==

public boolean existeArquivo (DadosSeriais dados, String dir) throws BasicException {
    if (dir == null) {
        dir = "";
    }
    dadosSeriais = dados;
    String idArquivo = dados.getIdColeta ().toString ();
    if (dados.getIdResumo () != null) {
        idArquivo += "_" + dados.getIdResumo ().toString ();
    }
    try {
        File file = new File (dir.trim (), "pdump." + idArquivo + ".data.xml.zip");
        return file.exists ();
    } catch (Exception e) {
        throw BasicException.errorHandling ("Erro ao verificar existencia de arquivo de dados", "msgErroVerificarExistenciaArquivoDadosXML", e, log);
    }
}


private void deleteFile (HttpServletRequest req, HttpServletResponse resp, String username, String password) {
    try {
        String files = req.getParameter (Constants.PARAM_FILES);
        if (null == files || "".equals (files)) {
            throw new ErrorCodeException (Constants.ERROR.BADPARAMS);
        }
        String [] filenames = files.split (Constants.SPLITTER.FILE);
        PrintWriter out;
        out = resp.getWriter ();
        String outstr = "";
        ArrayList < Utils.PairValue > resultList = new ArrayList < Utils.PairValue > ();
        for (String filename : filenames) {
            try {
                fs.deleteFile (username, password, filename);
                resultList.add (new Utils.PairValue (filename, Constants.STATUS_OK));
            } catch (Exception e) {
                e.printStackTrace ();
                Utils.log (this.getClass (), "Delete [" + filename + "] maybe failed.");
                resultList.add (new Utils.PairValue (filename, Constants.STATUS_ERROR));
            }
        }
        outstr = Utils.makeJsonArrayString (resultList);
        out.println (outstr);
        out.flush ();
    } catch (ErrorCodeException e) {
        e.printStackTrace ();
        error (req, resp, e.getErrorCode ());
    } catch (IOException e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.IOERROR);
    } catch (Exception e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.UNKNOWN);
    }
}


-----Function Pair=176=-----==

private byte [] getScheduleTable (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "schedulelist.html");
    String showOverlap = urlData.getParameter ("ShowOverlap");
    boolean showOverlapStatus = false;
    if ("1".equals (showOverlap)) {
        showOverlapStatus = true;
        String overlapIcon = "<a href='/servlet/ScheduleDataRes' class='noUnder'>" + "<img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'> " + "<span class='areaTitle'>Hide Overlaps</span></a>";
        template.replaceAll ("$OverlapIcon", overlapIcon);
    }
    else {
        showOverlapStatus = false;
        String overlapIcon = "<a href='/servlet/ScheduleDataRes?ShowOverlap=1' class='noUnder'>" + "<img border=0 src='/images/log.png' align='absmiddle' width='24' height='24'> " + "<span class='areaTitle'>Show Overlaps</span></a>";
        template.replaceAll ("$OverlapIcon", overlapIcon);
    }
    StringBuffer content = new StringBuffer ();
    ScheduleItem [] itemsArray = store.getScheduleArray ();
    ScheduleItem [] temp = filterItems (itemsArray, true);
    int totalItmes = 0;
    if (temp.length > 0) {
        totalItmes += temp.length;
        content.append ("<tr><td colspan='9' class='itemheading'>Past Schedules</td></tr>");
        getSchTblData (temp, content, showOverlapStatus);
        content.append ("<tr><td colspan='9'><br></td></tr>");
        template.replaceAll ("$PastSchedules", content.toString ());
    }
    else template.replaceAll ("$PastSchedules", "");
    temp = filterItems (itemsArray, false);
    content = new StringBuffer ();
    if (temp.length > 0) {
        totalItmes += temp.length;
        content.append ("<tr><td colspan='9' class='itemheading'>Pending Schedules</td></tr>");
        getSchTblData (temp, content, showOverlapStatus);
        template.replaceAll ("$PendingSchedules", content.toString ());
    }
    else template.replaceAll ("$PendingSchedules", "");
    if (totalItmes == 0) {
        content = new StringBuffer ();
        content.append ("<tr><td colspan='9' class='itemheading'>No Schedule Items</td></tr>");
        template.replaceAll ("$NoSchedules", content.toString ());
    }
    else template.replaceAll ("$NoSchedules", "");
    template.addCookie ("backURL", urlData.getReqString ());
    int autoDelSchedAction = Integer.parseInt (store.getProperty ("sch.autodel.action"));
    String autoAction = "";
    if (autoDelSchedAction == 0) {
        autoAction += "<option value='0' selected='selected'>Archive</option>\n";
        autoAction += "<option value='1'>Delete</option>";
    }
    else {
        autoAction += "<option value='0'>Archive</option>\n";
        autoAction += "<option value='1' selected='selected'>Delete</option>";
    }
    template.replaceAll ("$deleteAction", autoAction);
    String autoDel = store.getProperty ("sch.autodel.time");
    template.replaceAll ("$deleteAfter", autoDel);
    return template.getPageBytes ();
}


public String getResultString () {
    int totalRequests = moveRequests.size ();
    if (totalRequests == 0) {
        return ExportPage.this.getString ("export.message.exportNotStarted");
    }
    else {
        int [] total = calcTotal ();
        StringBuilder sb = new StringBuilder ();
        if (this.nrOfMoverequests == 0) {
            sb.append (totalRequests).append (" C-MOVE requests done in ").append (end - start).append (" ms!\n");
            start = 0;
        }
        else {
            sb.append (moveRequests.size ()).append (" of ").append (totalRequests).append (" C-MOVE requests pending!\n");
        }
        sb.append ("Instances completed:").append (total [0]).append (" warning:").append (total [1]).append (" failed:").append (total [2]).append (" remaining:").append (total [3]);
        if (! failedRequests.isEmpty ()) {
            sb.append ("\nFailed C-MOVE requests:\n");
            for (ExportResponseHandler h : failedRequests) {
                sb.append (h.id).append (": ").append (h.reqDescr).append ("\n");
            }
        }
        return sb.toString ();
    }
}


-----Function Pair=177=-----==

public OutputStream createNewOutputStream (String path, long lastModifiedTime) throws IOException {
    String fullPath = pathPrefix + path;
    if (seenEntries.contains (fullPath)) {
        return new NullOutputStream ();
    }
    seenEntries.add (fullPath);
    mkzipDirs (getParentPath (fullPath));
    ZipEntry zipEntry = new ZipEntry (fullPath);
    if (normalizeTimestamps) {
        zipEntry.setTime (0);
    }
    else if (lastModifiedTime >= 0) {
        zipEntry.setTime (lastModifiedTime);
    }
    jar.putNextEntry (zipEntry);
    return new OutputStreamOnJarEntry ();
}


private static OutputStream transferStream (InputStream input, int length, ExportController controller, OutputStream output, String targetName, int mode) throws IOException, CoreException {
    output = controller.getOutputStream (output, targetName, mode);
    int remaining = length;
    byte [] buffer;
    if (remaining > BUFFER_THRESHHOLD) {
        buffer = new byte [BUFFER_THRESHHOLD];
    }
    else {
        buffer = new byte [remaining];
    }
    while (remaining > 0) {
        int toRead = remaining > buffer.length ? buffer.length : remaining;
        int amount = input.read (buffer, 0, toRead);
        output.write (buffer, 0, amount);
        remaining -= amount;
    }
    input.close ();
    return output;
}


-----Function Pair=178=-----==

public static boolean zip (File [] filesToZip, File zipFile) {
    byte [] buf = new byte [2048];
    ZipOutputStream out = null;
    FileInputStream in = null;
    try {
        out = new ZipOutputStream (new FileOutputStream (zipFile));
        for (int i = 0; i < filesToZip.length; i ++) {
            in = new FileInputStream (filesToZip [i]);
            out.putNextEntry (new ZipEntry (filesToZip [i].getName ()));
            int len;
            while ((len = in.read (buf)) != - 1) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
        System.err.println ("Can't zip()");
        e.printStackTrace ();
        safeClose (out);
        safeClose (in);
        return false;
    }
    return true;
}


public static String getMillisDisplayable (long millis) {
    String result = null;
    final long second = 1000;
    final long minute = 60 * second;
    if (millis % minute == 0) {
        long minutes = millis / minute;
        if (minutes == 1) {
            result = minutes + " minute";
        }
        else {
            result = minutes + " minutes";
        }
    }
    else if (millis % second == 0) {
        long seconds = millis / second;
        if (seconds == 1) {
            result = seconds + " second";
        }
        else {
            result = seconds + " seconds";
        }
    }
    else {
        result = millis + " ms";
    }
    return result;
}


-----Function Pair=179=-----==

protected void initDirOffsetPosAndComment () throws IOException {
    this.dirOffsetPos = zipFile.length () - 6;
    final int dirOffset = raFile.readInt (this.dirOffsetPos - 16);
    if (dirOffset != ENDSIG) {
        byte [] endsig = ByteArrayHelper.toByteArray ((int) ZipConstants.ENDSIG);
        long endsigPos = raFile.lastPosOf (endsig);
        if (endsigPos == - 1) {
            throw new ZipException ("expected ENDSIC not found (marks the beginning of the central directory at end of the zip file)");
        }
        else {
            this.dirOffsetPos = endsigPos + 16;
            short commentLength = raFile.readShort (this.dirOffsetPos + 4);
            this.comment = new String (raFile.readByteArray (this.dirOffsetPos + 6, commentLength));
        }
    }
}


protected void addFile (File newEntry, String name) {
    if (newEntry.isDirectory ()) {
        return;
    }
    try {
        ZipEntry ze = new ZipEntry (name);
        mZos.putNextEntry (ze);
        FileInputStream fis = new FileInputStream (newEntry);
        byte fdata [] = new byte [512];
        int readCount = 0;
        while ((readCount = fis.read (fdata)) != - 1) {
            mZos.write (fdata, 0, readCount);
        }
        fis.close ();
        mZos.closeEntry ();
        mObserverCont.setNext (ze);
        mObserverCont.setCount (++ miCurrentCount);
    } catch (Exception ex) {
        mObserverCont.setError (ex.getMessage ());
    }
}


-----Function Pair=180=-----==

public static String getSpecSvg (String specfile, String spectype, String fieldstrength, int spectrumwidth, int spectrumheight, boolean useCSS) throws Exception {
    DOMImplementation domImpl = GenericDOMImplementation.getDOMImplementation ();
    Document document = domImpl.createDocument (null, "svg", null);
    SVGGraphics2D svgGenerator = new SVGGraphics2D (document);
    if (spectrumwidth == - 1) spectrumwidth = 300;
    if (spectrumheight == - 1) spectrumheight = 200;
    try {
        SpectrumModel model = new SpectrumModel ();
        model.setShowNavigationView (false);
        SpectrumNavigation sn = new SpectrumNavigation (spectype, fieldstrength, "", specfile, "", "", model, null, true);
        Dimension spectrumdim = new Dimension (spectrumwidth, spectrumheight);
        sn.setSize (spectrumdim);
        sn.setPreferredSize (spectrumdim);
        sn.setMinimumSize (spectrumdim);
        sn.setMaximumSize (spectrumdim);
        sn.printAll (svgGenerator);
    } catch (Exception ex) {
    }
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    Writer outwriter = new OutputStreamWriter (baos, "UTF-8");
    StringBuffer sb = new StringBuffer ();
    svgGenerator.stream (outwriter, useCSS);
    StringTokenizer tokenizer = new StringTokenizer (baos.toString (), "\n");
    while (tokenizer.hasMoreTokens ()) {
        String name = tokenizer.nextToken ();
        if (name.length () > 4 && name.substring (0, 5).equals ("<svg ")) {
            sb.append (name.substring (0, name.length () - 1)).append (" width=\"" + spectrumwidth + "\" height=\"" + spectrumheight + "\">");
        }
        else {
            sb.append (name);
        }
    }
    return (GeneralUtils.replace (sb.toString (), "clip-path=\"url(#clipPath1)\" ", " "));
}


private Collection < EdgeMappingDescriptor > loadMapping (InputStream in) throws IOException, ParseException, MalformedPathException {
    TreeSet < EdgeMappingDescriptor > ds = new TreeSet < EdgeMappingDescriptor > ();
    BufferedReader br = new BufferedReader (new InputStreamReader (in));
    String line = null;
    int lineCount = 0;
    while ((line = br.readLine ()) != null) {
        lineCount ++;
        String [] cols = line.split ("\t");
        if (cols.length == 2) {
            String name = cols [0].trim ();
            String path = cols [1].trim ();
            EdgeMappingDescriptor d = new EdgeMappingDescriptor (name, path);
            d.validate ();
            ds.add (d);
        }
        else if (line.trim ().equals ("")) {
        }
        else {
            throw new ParseException ("Invalid number of columns", lineCount);
        }
    }
    br.close ();
    return ds;
}


-----Function Pair=181=-----==

public void editSolverBinary (File [] binary, SolverBinaries solverBin) throws IOException, NoSuchAlgorithmException {
    if (binary.length == 0) {
        return;
    }
    Arrays.sort (binary);
    solverBin.setBinaryArchive (binary);
    FileInputStreamList is = new FileInputStreamList (binary);
    SequenceInputStream seq = new SequenceInputStream (is);
    String md5 = Util.calculateMD5 (seq);
    if (hasDuplicates (md5)) {
        if (JOptionPane.showConfirmDialog (gui, "There already exists a solver binary with the same " + "checksum. Do you want to add this binary anyway?", "Duplicate solver binary", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION) {
            return;
        }
    }
    solverBin.setMd5 (md5);
    Util.removeCommonPrefix (solverBin);
    new EDACCSolverBinaryDlg (EDACCApp.getApplication ().getMainFrame (), solverBin, this, EDACCSolverBinaryDlg.DialogMode.EDIT_MODE).setVisible (true);
    gui.showSolverBinariesDetails (currentSolver.getSolverBinaries ());
}


private int readCurrentTaskProgress () {
    File file = new File (FileManager.getCurrentDir () + "/temp/taskprogress.txt");
    int progress = 0;
    try {
        FileInputStream fstream = new FileInputStream (FileManager.getCurrentDir () + "/temp/taskprogress.txt");
        DataInputStream in = new DataInputStream (fstream);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String strLine;
        while ((strLine = br.readLine ()) != null) {
            progress = Integer.parseInt (strLine);
        }
        in.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return progress;
}


-----Function Pair=182=-----==

public void execute () throws MojoExecutionException, MojoFailureException {
    printLicenseInfo ();
    final File finalFile = new File (buildDirectory, finalFileName);
    final List < File > libFiles = getDependencyFiles (artifacts, false, true);
    Manifest manifest = null;
    try {
        manifest = createManifest (libFiles);
    } catch (IOException e) {
        logger.error (e);
    }
    JarOutputStream out = null;
    try {
        out = new JarOutputStream (new FileOutputStream (finalFile, false), manifest);
        if (this.onejarLicenseURL != null) {
            logger.info ("Adding one-jar-license.txt to archive.");
            final URLConnection con = onejarLicenseURL.openConnection ();
            final InputStream inStream = con.getInputStream ();
            addEntryToZip (out, new ZipEntry ("one-jar-license.txt"), inStream);
        }
        logger.info ("Adding MainJAR to archive at main/" + mainJarFilename);
        addFileToZip (out, "main/", new File (buildDirectory, mainJarFilename));
        logger.info ("Adding [" + libFiles.size () + "] libaries...");
        for (File lib : libFiles) {
            final String libName = lib.getName ();
            logger.info ("Add lib: " + libName);
            if (this.unpackJARs != null && this.unpackJARs.contains (libName) && libName.endsWith (".jar")) {
                final File file = lib.getAbsoluteFile ();
                final FileInputStream fileInStream = new FileInputStream (file);
                final JarInputStream jarInStream = new JarInputStream (fileInStream);
                try {
                    logger.info ("Unpack " + libName + " contents...");
                    ZipEntry entry = jarInStream.getNextEntry ();
                    while (entry != null) {
                        try {
                            addEntryToZip (out, entry, jarInStream);
                        } catch (Exception e) {
                            printDebug (e);
                        }
                        entry = jarInStream.getNextEntry ();
                    }
                } finally {
                    IOUtils.closeQuietly (jarInStream);
                }
                continue;
            }
            if (lib.isFile () && libName.endsWith (".jar")) {
                addFileToZip (out, "lib/", lib);
            }
            else {
                addFileToZip (out, "binlib/", lib);
            }
        }
    } catch (IOException e) {
        logger.error (e);
    } finally {
        IOUtils.closeQuietly (out);
    }
    final String format = this.project.getArtifact ().getType ();
    logger.info ("Adding file:" + finalFile.getAbsolutePath () + "\n       to the list of artifacts with format " + format);
    projectHelper.attachArtifact (this.project, format, "one-jar", finalFile);
}


public static boolean isZipFileContaining (File f, String expectedFile) {
    if (! f.isFile () || ! f.canRead ()) return false;
    boolean foundExpectedFile = false;
    InputStream in = null;
    try {
        in = new BufferedInputStream (new FileInputStream (f));
        if (isPdbk (f)) in = new XorInputStream (in, PDBK_XOR_BITS);
        ZipInputStream zipIn = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zipIn.getNextEntry ()) != null) if (e.getName ().equalsIgnoreCase (expectedFile)) foundExpectedFile = true;
    } catch (Exception e) {
    }
    FileUtils.safelyClose (in);
    return foundExpectedFile;
}


-----Function Pair=183=-----==

private static Serializable readFromStream (File f) throws PersistenceException {
    FileInputStream ois = null;
    try {
        ois = new FileInputStream (f);
        XStream xs = new XStream ();
        return (Serializable) xs.fromXML (ois);
    } catch (IOException e) {
        throw new PersistenceException ("Could not read object from " + f.getAbsolutePath () + ".", e);
    } finally {
        if (ois != null) {
            try {
                ois.close ();
            } catch (IOException e) {
            }
        }
    }
}


private void extractEntries (String [] entryNames, String [] fileNames, boolean overWrite) {
    try {
        ZipInputStream zin = new ZipInputStream (new FileInputStream (selfFile));
        ZipEntry entry;
        while ((entry = zin.getNextEntry ()) != null) {
            int index = getContainEntry (entry.getName (), entryNames);
            if ((index != - 1) && (overWrite || ! FileUtil.isFileExist (fileNames [index]))) {
                byte [] buf = new byte [4096];
                BufferedInputStream bin = new BufferedInputStream (zin);
                FileUtil.makeDirectory (fileNames [index]);
                BufferedOutputStream bout = new BufferedOutputStream (new FileOutputStream (fileNames [index]));
                while (bin.read (buf, 0, 1) != - 1) {
                    bout.write (buf, 0, 1);
                }
                bout.close ();
                bin.close ();
            }
            zin.closeEntry ();
        }
        zin.close ();
    } catch (IOException e) {
        logger.error (e.getLocalizedMessage ());
    }
}


-----Function Pair=184=-----==

private void unZip (File folderOut) throws Exception {
    BufferedOutputStream outputStream = null;
    BufferedInputStream inputStream = null;
    try {
        valid (folderOut);
        ZipEntry entry;
        ZipFile zipfile = new ZipFile (fzipIn);
        Enumeration < ? > e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            inputStream = new BufferedInputStream (zipfile.getInputStream (entry));
            int count;
            byte data [] = new byte [BUFFER];
            File fDes = new File (folderOut, entry.getName ());
            if (entry.getName ().endsWith ("/")) {
                if (! fDes.exists ()) {
                    if (! fDes.mkdirs ()) {
                        throw new IOException ("create folder failed" + fDes.getAbsolutePath ());
                    }
                }
            }
            else {
                FileOutputStream foutputStream = new FileOutputStream (fDes);
                outputStream = new BufferedOutputStream (foutputStream, BUFFER);
                while ((count = inputStream.read (data, 0, BUFFER)) != - 1) {
                    outputStream.write (data, 0, count);
                }
                outputStream.flush ();
                outputStream.close ();
                inputStream.close ();
            }
        }
    } catch (Exception e) {
        throw e;
    } finally {
        if (outputStream != null) {
            outputStream.close ();
        }
        if (inputStream != null) {
            inputStream.close ();
        }
    }
}


public void generateFormLetter (Connection con, Session session, int loginLibraryId, int formatId, String toId, int toLibraryId, String toType, String toEmailId, Timestamp referenceDate, String entryId, Hashtable parameters, String [] contentParameters, int indexOfReferenceNumber, int indexOfTable) {
    ADM_FORM_LETTER_MANAGER admflManager = new ADM_FORM_LETTER_MANAGER ();
    FORM_LETTER_FORMAT_KEY pkey = new FORM_LETTER_FORMAT_KEY ();
    FORM_LETTER_FORMAT_MANAGER flmanager = new FORM_LETTER_FORMAT_MANAGER ();
    PATRON_MANAGER patManager = new PATRON_MANAGER ();
    pkey.setFormat_id (new Integer (formatId));
    pkey.setLibrary_id (new Integer (loginLibraryId));
    FORM_LETTER_FORMAT flformat = flmanager.load (session, pkey);
    String format = flformat.getFormat ();
    String title = flformat.getTitle ();
    String formLetterNo = "";
    String prefix = flformat.getPrefix ();
    String maxno = flformat.getMax_no ().toString ();
    formLetterNo = prefix + maxno;
    setFormLetterNo (formLetterNo);
    flformat.setMax_no (new Integer (flformat.getMax_no ().intValue () + 1));
    String femailstatus = flformat.getEmail_status ();
    String fimstatus = flformat.getInstant_message_status ();
    String fprintstatus = flformat.getPrint_status ();
    String emailStatus = "";
    String imStatus = "";
    String printStatus = "";
    if (femailstatus.equals ("A")) {
        emailStatus = "B";
    }
    else {
        emailStatus = "C";
    }
    if (fimstatus.equals ("A")) {
        imStatus = "B";
    }
    else {
        imStatus = "C";
    }
    if (fprintstatus.equals ("A")) {
        printStatus = "B";
    }
    else {
        printStatus = "C";
    }
    String emailId = "";
    if (toType.equals ("A")) {
        PATRON_KEY patkey = new PATRON_KEY ();
        patkey.setPatron_id (toId);
        patkey.setLibrary_id (new Integer (toLibraryId));
        PATRON patron = patManager.load (session, patkey);
        emailId = patron.getEmail ();
    }
    else if (toType.equals ("B")) {
        ADM_CO_VENDOR_MANAGER venmanager = new ADM_CO_VENDOR_MANAGER ();
        ADM_CO_VENDOR_KEY venkey = new ADM_CO_VENDOR_KEY ();
        venkey.setVendor_id (new Integer (toId));
        venkey.setLibrary_id (new Integer (toLibraryId));
        ADM_CO_VENDOR vendor = (ADM_CO_VENDOR) venmanager.load (session, venkey);
        emailId = vendor.getEmail_id ();
    }
    else if (toType.equals ("E")) {
        CIR_CO_BINDER_MANAGER binManager = new CIR_CO_BINDER_MANAGER ();
        CIR_CO_BINDER_KEY bindkey = new CIR_CO_BINDER_KEY ();
        bindkey.setBinder_id (new Integer (toId));
        bindkey.setLibrary_id (new Integer (toLibraryId));
        CIR_CO_BINDER binder = (CIR_CO_BINDER) binManager.load (session, bindkey);
        emailId = binder.getEmail ();
    }
    else {
        emailId = toEmailId;
    }
    String content = "";
    if (indexOfReferenceNumber != - 1) {
        contentParameters [indexOfReferenceNumber] = formLetterNo;
    }
    String tableContent = "";
    if (indexOfTable != - 1) {
        String [] headervals = (String []) parameters.get ("HEADER");
        for (int i = 0; i < headervals.length; i ++) {
            if (i == 0) tableContent += headervals [i];
            else tableContent += "\t" + headervals [i];
        }
        tableContent += "\n";
        tableContent += "_________________________________________________________________\n";
        Vector vecdata = (Vector) parameters.get ("DATA");
        for (int i = 0; i < vecdata.size (); i ++) {
            String [] rowdata = (String []) vecdata.elementAt (i);
            for (int j = 0; j < rowdata.length; j ++) {
                if (i == 0) tableContent += rowdata [i];
                else tableContent += "\t" + rowdata [i];
            }
            tableContent += "\n";
        }
        contentParameters [indexOfTable] = tableContent;
    }
    content = java.text.MessageFormat.format (format, contentParameters);
    System.out.println ("Content is sdjhfjsdk: " + content);
    this.setTextContent (content);
    String htmlcontent = "";
    String pathOfOODoc = "";
    Hashtable objParamters = new Hashtable ();
    for (int i = 0; i < contentParameters.length; i ++) {
        objParamters.put (String.valueOf (i), tools.StringProcessor.getInstance ().verifyString (contentParameters [i]));
        if (i == indexOfTable) {
            objParamters.put (String.valueOf (i), parameters);
        }
    }
    htmlcontent = generateHTMLDocument (new Integer (formatId), new Integer (loginLibraryId), objParamters);
    pathOfOODoc = generateOODocument (new Integer (formatId), new Integer (loginLibraryId), objParamters);
    ADM_FORM_LETTER admFormLetter = new ADM_FORM_LETTER ();
    admFormLetter.setEmail_status (emailStatus);
    admFormLetter.setEntry_date (StaticValues.getInstance ().getReferenceDate ());
    admFormLetter.setEntry_id (StaticValues.getInstance ().getLoginPatronId ());
    admFormLetter.setEntry_library_id (new Integer (StaticValues.getInstance ().getLoginLibraryId ()));
    admFormLetter.setForm_letter_content (content);
    admFormLetter.setForm_letter_no (formLetterNo);
    admFormLetter.setForm_letter_title (title);
    admFormLetter.setFormat_id (new Integer (formatId));
    admFormLetter.setHtml_content (htmlcontent);
    admFormLetter.setInstant_message_status (imStatus);
    admFormLetter.setOo_path (pathOfOODoc);
    admFormLetter.setPrint_status (printStatus);
    admFormLetter.setRead_status ("B");
    admFormLetter.setTo_email_id (emailId);
    admFormLetter.setTo_execute_on_date (StaticValues.getInstance ().getReferenceDate ());
    admFormLetter.setTo_id (toId);
    admFormLetter.setTo_library_id (new Integer (toLibraryId));
    admFormLetter.setTo_type (toType);
    Integer maxid = admflManager.getMaxId (con);
    System.out.println ("Maximum Id is: " + maxid);
    ADM_FORM_LETTER_KEY admflpkey = new ADM_FORM_LETTER_KEY ();
    admflpkey.setForm_id (maxid);
    admflpkey.setLibrary_id (new Integer (loginLibraryId));
    admFormLetter.setPrimaryKey (admflpkey);
    admflManager.save (session, admFormLetter);
}


-----Function Pair=185=-----==

private void writeFile (InputStream zis, File file, int size) throws IOException {
    File parentFile = file.getParentFile ();
    if (! parentFile.exists ()) {
        parentFile.mkdirs ();
    }
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream (file);
        byte [] byteStream = new byte [(int) size];
        int buf = - 1;
        int rb = 0;
        while ((((int) size - rb) > 0)) {
            buf = zis.read (byteStream, rb, (int) size - rb);
            if (buf == - 1) {
                break;
            }
            rb += buf;
        }
        fos.write (byteStream);
    } catch (IOException e) {
        throw new IOException ("UNZIP_ERROR");
    } finally {
        if (fos != null) {
            fos.close ();
        }
    }
}


protected void addOneJarBoot (ZipOutputStream zOut) throws IOException {
    if (zOut == null) return;
    if (onejar != null) {
        includeZip (onejar, zOut);
    }
    else {
        String ONE_JAR_BOOT = "one-jar-boot.jar";
        InputStream is = OneJarTask.class.getResourceAsStream (ONE_JAR_BOOT);
        if (is == null) throw new IOException ("Unable to load default " + ONE_JAR_BOOT + ": consider using the <one-jar onejarboot=\"...\"> option.");
        JarInputStream jis = new JarInputStream (is);
        Manifest manifest = new Manifest ();
        java.util.jar.Manifest jmanifest = jis.getManifest ();
        java.util.jar.Attributes jattributes = jmanifest.getMainAttributes ();
        try {
            manifest.addConfiguredAttribute (new Attribute ("Created-By", "One-Jar 0.98 Ant taskdef"));
            manifest.addConfiguredAttribute (new Attribute (MAIN_CLASS, jattributes.getValue (MAIN_CLASS)));
            if (oneJarMainClass != null) {
                manifest.addConfiguredAttribute (new Attribute (Boot.ONE_JAR_MAIN_CLASS, oneJarMainClass));
            }
            super.addConfiguredManifest (manifest);
        } catch (ManifestException mx) {
            throw new BuildException (mx);
        }
        super.initZipOutputStream (zOut);
        ZipEntry entry = jis.getNextEntry ();
        while (entry != null) {
            if (entry.getName ().endsWith (CLASS) || entry.getName ().equals (".version") || entry.getName ().endsWith ("license.txt")) {
                log ("entry=" + entry.getName (), Project.MSG_DEBUG);
                zOut.putNextEntry (new org.apache.tools.zip.ZipEntry (entry));
                copy (jis, zOut, false);
            }
            entry = jis.getNextJarEntry ();
        }
    }
}


-----Function Pair=186=-----==

public String generateFormLetter (int loginLibraryId, int formatId, String toId, int toLibraryId, String toType, String toEmailId, Timestamp referenceDate, String entryId, Hashtable parameters, String [] contentParameters, int indexOfReferenceNumber, int indexOfTable) {
    ejb.objectmodel.administration.FORM_LETTER_FORMATKey key = new ejb.objectmodel.administration.FORM_LETTER_FORMATKey ();
    key.format_Id = new Integer (formatId);
    key.library_Id = new Integer (loginLibraryId);
    ejb.objectmodel.administration.LocalFORM_LETTER_FORMAT local = null;
    try {
        local = ((ejb.objectmodel.administration.LocalFORM_LETTER_FORMATHome) homeFactory.getHome ("FORM_LETTER_FORMAT")).findByPrimaryKey (key);
    } catch (Exception ex) {
        ex.printStackTrace (System.out);
    }
    String format = local.getFormat ();
    String title = local.getTitle ();
    String femailstatus = local.getEmail_Status ();
    String fimstatus = local.getInstant_Message_Status ();
    String fprintstatus = local.getPrint_Status ();
    String emailStatus = "";
    String imStatus = "";
    String printStatus = "";
    if (femailstatus.equals ("A")) {
        emailStatus = "B";
    }
    else {
        emailStatus = "C";
    }
    if (fimstatus.equals ("A")) {
        imStatus = "B";
    }
    else {
        imStatus = "C";
    }
    if (fprintstatus.equals ("A")) {
        printStatus = "B";
    }
    else {
        printStatus = "C";
    }
    String emailId = "";
    if (toType.equals ("A")) {
        ejb.objectmodel.administration.PatronKey patKey = new ejb.objectmodel.administration.PatronKey ();
        patKey.patron_Id = toId;
        patKey.library_Id = new Integer (toLibraryId);
        ejb.objectmodel.administration.LocalPatron localPat = null;
        try {
            localPat = ((ejb.objectmodel.administration.LocalPatronHome) homeFactory.getHome ("Patron")).findByPrimaryKey (patKey);
        } catch (Exception ex) {
            ex.printStackTrace (System.out);
        }
        emailId = localPat.getEmail ();
    }
    else if (toType.equals ("B")) {
        ejb.objectmodel.administration.ADM_CO_VENDORKey admVendorKey = new ejb.objectmodel.administration.ADM_CO_VENDORKey ();
        admVendorKey.vendor_Id = new Integer (toId);
        admVendorKey.library_Id = new Integer (toLibraryId);
        ejb.objectmodel.administration.LocalADM_CO_VENDOR localAdmVendor = null;
        try {
            localAdmVendor = ((ejb.objectmodel.administration.LocalADM_CO_VENDORHome) homeFactory.getHome ("ADM_CO_VENDOR")).findByPrimaryKey (admVendorKey);
        } catch (Exception ex) {
            ex.printStackTrace (System.out);
        }
        emailId = localAdmVendor.getEmail_Id ();
    }
    else if (toType.equals ("E")) {
        ejb.objectmodel.administration.CIR_CO_BINDERKey cirCoBinderKey = new ejb.objectmodel.administration.CIR_CO_BINDERKey ();
        cirCoBinderKey.binder_Id = new Integer (toId);
        cirCoBinderKey.library_Id = new Integer (toLibraryId);
        ejb.objectmodel.administration.LocalCIR_CO_BINDER localCirCoBinder = null;
        try {
            localCirCoBinder = ((ejb.objectmodel.administration.LocalCIR_CO_BINDERHome) homeFactory.getHome ("CIR_CO_BINDER")).findByPrimaryKey (cirCoBinderKey);
        } catch (Exception ex) {
            ex.printStackTrace (System.out);
        }
        emailId = localCirCoBinder.getEmail ();
    }
    else {
        emailId = toEmailId;
    }
    String content = "";
    if (indexOfReferenceNumber != - 1 && contentParameters [indexOfReferenceNumber].equals ("")) {
        String prefix = local.getPrefix ();
        String maxno = local.getMax_No ().toString ();
        formLetterNo = prefix + maxno;
        setFormLetterNo (formLetterNo);
        local.setMax_No (new Integer (local.getMax_No ().intValue () + 1));
        contentParameters [indexOfReferenceNumber] = formLetterNo;
    }
    String tableContent = "\n";
    if (indexOfTable != - 1) {
        Vector vecdata = (Vector) parameters.get ("DATA");
        String [] headervals = (String []) parameters.get ("HEADER");
        String [] data = new String [headervals.length + 1];
        for (int i = 0; i < vecdata.size (); i ++) {
            String [] rowdata = (String []) vecdata.elementAt (i);
            for (int j = 0; j < rowdata.length; j ++) {
                if (i == 0) data [j] = rowdata [j];
                else {
                    if (data [j] != null && rowdata [j] != null && data [j].length () < rowdata [j].length ()) data [j] = rowdata [j];
                    if (data [j] == null || data [j].toString ().trim ().equals ("")) data [j] = rowdata [j];
                }
            }
        }
        for (int i = 0; i < vecdata.size (); i ++) {
            String [] rowdata = (String []) vecdata.elementAt (i);
            for (int j = 0; j < rowdata.length; j ++) {
                String space = "";
                try {
                    if (data [j] != null && headervals [j].length () > data [j].length ()) {
                        for (int k = 1; k <= (headervals [j].length () - rowdata [j].length ()); k ++) space += " ";
                    }
                    else {
                        int len = 0;
                        if (rowdata [j] != null || ! rowdata [j].trim ().equals ("")) {
                            len = rowdata [j].length ();
                        }
                        if (data [j].length () > len) {
                            space = "";
                            for (int k = 1; k <= (data [j].length () - len); k ++) space += " ";
                        }
                    }
                } catch (Exception e) {
                    for (int k = 1; k <= headervals [j].length (); k ++) space += " ";
                    e.printStackTrace ();
                }
                tableContent += rowdata [j] + space + "\t";
            }
            tableContent += "\n";
        }
        String headerContent = "\n";
        for (int i = 0; i < headervals.length; i ++) {
            String spaces = "";
            if (data [i] != null && headervals [i] != null) {
                if (data [i].length () > headervals [i].length ()) {
                    for (int j = 1; j <= (data [i].length () - headervals [i].length ()); j ++) spaces += " ";
                }
                headerContent += headervals [i] + spaces + "\t";
            }
            else headerContent += headervals [i] + "\t";
        }
        headerContent += "\n";
        headerContent += "_________________________________________________________________________________________\n";
        tableContent = headerContent + tableContent;
        contentParameters [indexOfTable] = tableContent;
    }
    content = java.text.MessageFormat.format (format, contentParameters);
    this.setTextContent (content);
    String htmlcontent = "";
    String pathOfOODoc = "";
    Hashtable objParamters = new Hashtable ();
    for (int i = 0; i < contentParameters.length; i ++) {
        objParamters.put (String.valueOf (i), contentParameters [i]);
        if (i == indexOfTable) {
            objParamters.put (String.valueOf (i), parameters);
        }
    }
    htmlcontent = generateHTMLDocument (new Integer (formatId), new Integer (loginLibraryId), objParamters);
    pathOfOODoc = generateOODocument (new Integer (formatId), new Integer (loginLibraryId), objParamters);
    Integer maxid = new Integer (ejb.bprocess.util.Utility.getInstance ().getFormID (loginLibraryId));
    ejb.objectmodel.administration.LocalADM_FORM_LETTER localAdmFormLetter = null;
    try {
        localAdmFormLetter = ((ejb.objectmodel.administration.LocalADM_FORM_LETTERHome) homeFactory.getHome ("ADM_FORM_LETTER")).create (maxid, new Integer (loginLibraryId), formLetterNo, content, title, toId, new Integer (toLibraryId), toType, "A", printStatus, emailStatus, imStatus, Utility.getInstance ().getTimestamp (), emailId, entryId, new Integer (loginLibraryId), Utility.getInstance ().getTimestamp ());
        localAdmFormLetter.setPrint_Priority ("A");
        localAdmFormLetter.setPrint_Copies (new Integer (1));
        localAdmFormLetter.setGenerate_Type ("B");
        localAdmFormLetter.setDocument_Type ("B");
    } catch (Exception ex) {
        ex.printStackTrace (System.out);
    }
    localAdmFormLetter.setFormat_Id (new Integer (formatId));
    localAdmFormLetter.setHtml_Content (htmlcontent);
    localAdmFormLetter.setOo_path (pathOfOODoc);
    localAdmFormLetter.setRead_Status ("B");
    return maxid.toString ();
}


public void UpdateTemplate (NpsContext ctxt, String content) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        String sql = "update template set template=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "select template from Template where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            writer.write (content);
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
        Clear ();
        DeleteJavaFiles ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=187=-----==

public boolean [] [] labelConnectionsIn (Alphabet outputAlphabet, InstanceList trainingSet, String start) {
    int numLabels = outputAlphabet.size ();
    boolean [] [] connections = new boolean [numLabels] [numLabels];
    for (int i = 0; i < trainingSet.size (); i ++) {
        Instance instance = trainingSet.getInstance (i);
        FeatureSequence output = (FeatureSequence) instance.getTarget ();
        for (int j = 1; j < output.size (); j ++) {
            int sourceIndex = outputAlphabet.lookupIndex (output.get (j - 1));
            int destIndex = outputAlphabet.lookupIndex (output.get (j));
            assert (sourceIndex >= 0 && destIndex >= 0);
            connections [sourceIndex] [destIndex] = true;
        }
    }
    if (start != null) {
        int startIndex = outputAlphabet.lookupIndex (start);
        for (int j = 0; j < outputAlphabet.size (); j ++) {
            connections [startIndex] [j] = true;
        }
    }
    return connections;
}


public static void main (String [] args) {
    if (args.length < 1) {
        printUsageAndDie ();
    }
    File libsbmljFile = new File (args [0]);
    if (! libsbmljFile.exists ()) {
        printUsageAndDie ();
    }
    if (! libsbmljFile.canRead ()) {
        System.err.println ("Cannot read file " + args [0]);
        printUsageAndDie ();
    }
    Installer installer = new Installer ();
    System.out.println ("Copying file...");
    installer.copyFile (libsbmljFile, new File (".." + File.separator + "lib" + File.separator + LIBSBMLJ_FILENAME));
    System.out.println ("Registering file with ondex-mini's manifest...");
    installer.registerInManifest (LIBSBMLJ_FILENAME);
    System.out.println ("Installation successful!");
}


-----Function Pair=188=-----==

public void unZip (String unZipfileName, String extFolder) {
    FileOutputStream fileOut;
    File file;
    InputStream inputStream;
    try {
        this.zipFile = new ZipFile (unZipfileName);
        for (Enumeration entries = this.zipFile.getEntries (); entries.hasMoreElements ();) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            file = new File (extFolder + entry.getName ());
            if (entry.isDirectory ()) {
                file.mkdirs ();
            }
            else {
                File parent = file.getParentFile ();
                if (! parent.exists ()) {
                    parent.mkdirs ();
                }
                inputStream = zipFile.getInputStream (entry);
                fileOut = new FileOutputStream (file);
                while ((this.readedBytes = inputStream.read (this.buf)) > 0) {
                    fileOut.write (this.buf, 0, this.readedBytes);
                }
                fileOut.close ();
                inputStream.close ();
            }
        }
        this.zipFile.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


private static void replaceEntityMappings (File signserverearpath, File entityMappingXML) throws ZipException, IOException {
    ZipInputStream earFile = new ZipInputStream (new FileInputStream (signserverearpath));
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    ZipOutputStream tempZip = new ZipOutputStream (baos);
    ZipEntry next = earFile.getNextEntry ();
    while (next != null) {
        ByteArrayOutputStream content = new ByteArrayOutputStream ();
        byte [] data = new byte [30000];
        int numberread;
        while ((numberread = earFile.read (data)) != - 1) {
            content.write (data, 0, numberread);
        }
        if (next.getName ().equals ("signserver-ejb.jar")) {
            content = replaceEntityMappings (content, entityMappingXML);
            next = new ZipEntry ("signserver-ejb.jar");
        }
        tempZip.putNextEntry (next);
        tempZip.write (content.toByteArray ());
        next = earFile.getNextEntry ();
    }
    earFile.close ();
    tempZip.close ();
    FileOutputStream fos = new FileOutputStream (signserverearpath);
    fos.write (baos.toByteArray ());
    fos.close ();
}


-----Function Pair=189=-----==

private void importComponentDirect (HierarchyNode parent, Document doc) throws ApplicationException {
    try {
        Element component = doc.getRootElement ();
        if (component == null) throw new ApplicationException ("Bad Component tag");
        Attribute component_name = component.getAttribute ("name");
        if (component_name == null) throw new ApplicationException ("Bad Component tag");
        Element schematicElement = component.getChild ("Schematic");
        if (schematicElement == null) throw new ApplicationException ("No schematic tag inside component");
        XmlEngine.doChildComponents (this, parent, schematicElement.getChildren ("ChildComponent"), schematicElement.getChildren ("Connection"), schematicElement.getChildren ("Instantiation"), true);
        if (component.getChild ("LocalFaultData") == null) throw new ApplicationException ("No local fault data for component");
        XmlEngine.doLocalFaultData (parent, component.getChild ("LocalFaultData"));
    } catch (ApplicationException e) {
        throw e;
    } catch (Exception e) {
        throw new ApplicationException (e.getMessage ());
    }
}


public void setConfiguration (Configuration cfg) throws ConfigurationException {
    String suffix = cfg.get ("suffix", DEF_SUFFIX), prefix = cfg.get ("prefix");
    setSuffix (suffix);
    setPrefix (prefix);
    Integer formatObj = (Integer) COMPRESSION_FORMATS.get (cfg.get ("compression-format", "none").toLowerCase ());
    int compressionFormat = (formatObj == null) ? 0 : formatObj.intValue ();
    setCompressionFormat (compressionFormat);
    setCompressedSuffix (cfg.get ("compressed-suffix", DEF_COMPRESSED_SUFFIX [compressionFormat]));
    setCompressionBufferSize (cfg.getInt ("compression-buffer-size", DEF_BUFFER_SIZE));
    logName = prefix + suffix;
    maxSize = cfg.getLong ("maxsize", DEF_MAXSIZE);
    try {
        openLogFile ();
    } catch (IOException e) {
        throw new ConfigurationException ("error opening file: " + logName, e);
    }
    sleepTime = cfg.getInt ("window", DEF_WIN);
    if (sleepTime <= 0) sleepTime = DEF_WIN;
    sleepTime *= 1000;
    DateFormat fmt = new SimpleDateFormat (cfg.get ("date-format", DEF_DATE_FMT));
    setDateFmt (fmt);
    setLastDate (fmt.format (new Date ()));
    Date time;
    try {
        time = new SimpleDateFormat ("HH:mm:ss").parse (cfg.get ("first-rotate-time", "00:00:00"));
    } catch (ParseException ex) {
        throw new ConfigurationException ("Bad 'first-rotate-time' format " + "expected HH(0-23):mm:ss ", ex);
    }
    String strDate = cfg.get ("first-rotate-date", null);
    Calendar cal = Calendar.getInstance ();
    cal.set (Calendar.MILLISECOND, 0);
    Calendar calTemp = Calendar.getInstance ();
    calTemp.setTime (time);
    cal.set (Calendar.SECOND, calTemp.get (Calendar.SECOND));
    cal.set (Calendar.MINUTE, calTemp.get (Calendar.MINUTE));
    cal.set (Calendar.HOUR_OF_DAY, calTemp.get (Calendar.HOUR_OF_DAY));
    if (strDate != null) {
        Date date;
        try {
            date = new SimpleDateFormat ("yyyy-MM-dd").parse (strDate);
        } catch (ParseException ex) {
            throw new ConfigurationException ("Bad 'first-rotate-date' " + "format, expected (yyyy-MM-dd)", ex);
        }
        calTemp.setTime (date);
        cal.set (calTemp.get (Calendar.YEAR), calTemp.get (Calendar.MONTH), calTemp.get (Calendar.DATE));
    }
    calTemp.setTime (new Date ());
    if (cal.before (calTemp)) {
        long n = (calTemp.getTimeInMillis () - cal.getTimeInMillis ()) / sleepTime;
        cal.setTimeInMillis (cal.getTimeInMillis () + sleepTime * (n + 1));
    }
    DefaultTimer.getTimer ().scheduleAtFixedRate (rotate = new DailyRotate (), cal.getTime (), sleepTime);
}


-----Function Pair=190=-----==

public boolean loadImagesFromModelFile (File file) throws IOException {
    if (file == null || ! file.exists () || ! FACTORY.isArchiveFile (file)) {
        return false;
    }
    ZipFile zipFile = new ZipFile (file);
    for (Enumeration < ? extends ZipEntry > enm = zipFile.entries (); enm.hasMoreElements ();) {
        ZipEntry zipEntry = enm.nextElement ();
        String entryName = zipEntry.getName ();
        if (entryName.startsWith ("images/")) {
            if (! BYTE_ARRAY_STORAGE.hasEntry (entryName)) {
                InputStream in = zipFile.getInputStream (zipEntry);
                BYTE_ARRAY_STORAGE.addStreamEntry (entryName, in);
            }
            if (! fLoadedImagePaths.contains (entryName)) {
                fLoadedImagePaths.add (entryName);
            }
        }
    }
    zipFile.close ();
    return true;
}


private void addFile (File ontologyFile, ModelSource subModelMaker) {
    Model subModel = null;
    String fileName = ontologyFile.getAbsolutePath ();
    try {
        subModel = subModelMaker.createFreshModel ().read (new BufferedReader (new FileReader (ontologyFile)), null);
        logger.info ("Adding: \"" + fileName);
    } catch (FileNotFoundException e) {
        logger.error ("Ignoring \"" + fileName + "\"", e);
        return;
    } catch (Exception e) {
        logger.error ("Ignoring \"" + fileName + "\"", e);
        return;
    }
    String ontologyModelName = (String) subModel.getNsPrefixMap ().get ("");
    if (ontologyModelName == null) {
        logger.error ("No default namespace for \"" + fileName + "\". Ignoring it");
        return;
    }
    ontologyModelName = ontologyModelName.substring (0, ontologyModelName.length () - 1);
    logger.info ("Main Ontology: " + ontologyModelName);
    Model mainModel = SDBFactory.connectNamedModel (store, ontologyModelName);
    if (mainModel.size () > 0) {
        logger.warn ("Model \"" + ontologyModelName + "\" exists, updating it");
        mainModel.removeAll ();
        mainModel = SDBFactory.connectNamedModel (store, ontologyModelName);
    }
    else {
        logger.info ("Model \"" + ontologyModelName + "\" doesn't exist, creating it");
    }
    if (mainModel.supportsTransactions ()) {
        mainModel.begin ();
    }
    mainModel.add (subModel);
    if (mainModel.supportsTransactions ()) {
        mainModel.commit ();
    }
    mainModel.close ();
    logger.info ("DONE\n");
}


-----Function Pair=191=-----==

public Map < String, Serializable > getRecord (Serializable domain, Serializable table, Serializable key) throws Exception {
    String recordPath = createDataPath (domain, table, key);
    File record = new File (Commons.glue (recordPath, "/", key, ".zip"));
    if (! record.exists ()) {
        throw new StorageException ("Record not found, key=" + key);
    }
    LOG.debug ("path to record: " + record);
    ZipInputStream zip = new ZipInputStream (new FileInputStream (record));
    Map < String, Serializable > map = new HashMap < String, Serializable > ();
    ZipEntry entry = zip.getNextEntry ();
    while (entry != null) {
        ObjectInputStream is = new ObjectInputStream (zip);
        Object o = is.readObject ();
        map.put (entry.getName (), (Serializable) o);
        entry = zip.getNextEntry ();
    }
    zip.close ();
    return map;
}


private String testPattern (String pattern) {
    Calendar cal = Calendar.getInstance ();
    pattern = pattern.replaceAll ("%y", addZero (cal.get (Calendar.YEAR)));
    pattern = pattern.replaceAll ("%m", addZero ((cal.get (Calendar.MONTH) + 1)));
    pattern = pattern.replaceAll ("%d", addZero (cal.get (Calendar.DATE)));
    pattern = pattern.replaceAll ("%h", addZero (cal.get (Calendar.HOUR_OF_DAY)));
    pattern = pattern.replaceAll ("%M", addZero (cal.get (Calendar.MINUTE)));
    String dayOfWeek = "";
    try {
        dayOfWeek = (String) DataStore.getInstance ().dayName.get (new Integer (cal.get (Calendar.DAY_OF_WEEK)));
    } catch (Exception e) {
    }
    pattern = pattern.replaceAll ("%D", dayOfWeek);
    pattern = pattern.replaceAll ("%n", "My Program");
    pattern = pattern.replaceAll ("%N", "Program 01, Program 02, Program 30");
    pattern = pattern.replaceAll ("%s", "Sub Name");
    pattern = pattern.replaceAll ("%t", "Category");
    pattern = pattern.replaceAll ("%c", "Chan10");
    pattern = pattern.replaceAll ("(\\ )+", " ");
    return pattern.trim ();
}


-----Function Pair=192=-----==

public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {
    int k_blockSize = 1024;
    int byteCount;
    char [] buf = new char [k_blockSize];
    File ofp = new File (outFile);
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));
    zos.setMethod (ZipOutputStream.DEFLATED);
    OutputStreamWriter osw = new OutputStreamWriter (zos, "ISO-8859-1");
    BufferedWriter bw = new BufferedWriter (osw);
    ZipEntry zot = null;
    File ifp = new File (inFile);
    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));
    InputStreamReader isr = new InputStreamReader (zis, "ISO-8859-1");
    BufferedReader br = new BufferedReader (isr);
    ZipEntry zit = null;
    while ((zit = zis.getNextEntry ()) != null) {
        if (zit.getName ().equals ("content.xml")) {
            continue;
        }
        zot = new ZipEntry (zit.getName ());
        zos.putNextEntry (zot);
        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);
        bw.flush ();
        zos.closeEntry ();
    }
    zos.putNextEntry (new ZipEntry ("content.xml"));
    bw.flush ();
    osw = new OutputStreamWriter (zos, "UTF8");
    bw = new BufferedWriter (osw);
    return bw;
}


private void onLangLoad () {
    JFileChooser fc = new JFileChooser (".");
    LanguageFileFilter ff = new LanguageFileFilter ();
    fc.addChoosableFileFilter (ff);
    fc.setFileFilter (ff);
    int status = fc.showOpenDialog (this);
    if (status == JFileChooser.APPROVE_OPTION) {
        File f = fc.getSelectedFile ();
        this.switchLanguage (f);
    }
    if (findFrame != null) {
        findFrame.setTranslator (getTranslator ());
        findFrame.fireLanguageSwitched ();
    }
}


-----Function Pair=193=-----==

private byte [] calculateHash (InputStream jarIS, InputStream itIS, X509Certificate cert) throws CertificateEncodingException, IOException, NoSuchAlgorithmException {
    JarInputStream jis = new JarInputStream (jarIS);
    MessageDigest md = MessageDigest.getInstance (HASH_ALGORITHM);
    ZipEntry ze;
    int readed = 0;
    byte [] buffer = new byte [4096];
    byte [] finalDigest = new byte [HASH_ALGORITHM_LENGTH / 8];
    while ((readed = itIS.read (buffer)) >= 0) md.update (buffer, 0, readed);
    finalDigest = xor (finalDigest, md.digest ());
    md.update (cert.getEncoded ());
    finalDigest = xor (finalDigest, md.digest ());
    while ((ze = jis.getNextEntry ()) != null) {
        if ((! ze.isDirectory ()) && (! ze.getName ().endsWith (".scode"))) {
            md.reset ();
            while ((readed = jis.read (buffer)) >= 0) md.update (buffer, 0, readed);
            finalDigest = xor (finalDigest, md.digest ());
        }
    }
    return finalDigest;
}


private static void addFromResource (String resource, OutputStream out) {
    URL url = OpenOfficeDocumentCreator.class.getResource (resource);
    try {
        InputStream in = url.openStream ();
        byte [] buffer = new byte [256];
        synchronized (in) {
            synchronized (out) {
                while (true) {
                    int bytesRead = in.read (buffer);
                    if (bytesRead == - 1) break;
                    out.write (buffer, 0, bytesRead);
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=194=-----==

private void deleteSelected () {
    if (mySelectedGamePanel != null) {
        int zResult = JOptionPane.showConfirmDialog (this, "Are you sure you want to delete: " + mySelectedGamePanel.getGame ().getGameTitle () + "?", "Delete game?", JOptionPane.YES_NO_OPTION);
        if (zResult == JOptionPane.YES_OPTION) {
            JStellaGamePanel zDelPanel = mySelectedGamePanel;
            mySelectedGamePanel = null;
            PanelGames.remove (zDelPanel);
            PanelGames.validate ();
            File zGameFile = new File (getRepositoryDirectory (), zDelPanel.getGame ().getGameFilename ());
            if (zGameFile.getName ().toLowerCase ().endsWith ("j26")) {
                System.out.println ("Deleting file: " + zGameFile.getName ());
                if (zGameFile.exists () == true) zGameFile.delete ();
            }
        }
    }
}


public static ProjectContainer loadCompressedProject (File file) throws Exception {
    ProjectContainer project = null;
    InputStream inputStream = new FileInputStream (file);
    byte [] magic = new byte [4];
    inputStream.read (magic);
    inputStream.close ();
    if (magic [3] == (byte) 0x04 && magic [2] == (byte) 0x03 && magic [1] == (byte) 0x4b && magic [0] == (byte) 0x50) {
        FileInputStream fileinputStream = new FileInputStream (file);
        inputStream = fileinputStream;
        try {
            ZipInputStream zipi = new ZipInputStream (inputStream);
            zipi.getNextEntry ();
            inputStream = zipi;
            inputStream = new BufferedInputStream (inputStream);
            project = loadProject (inputStream);
            project.compression_level = 1;
        } finally {
            fileinputStream.close ();
        }
    }
    if (magic [0] == (byte) 0x4c && magic [1] == (byte) 0x5a && magic [2] == (byte) 0x4d && magic [3] == (byte) 0x61) {
        FileInputStream fileinputStream = new FileInputStream (file);
        inputStream = fileinputStream;
        try {
            inputStream.read (magic);
            InputStream inStream = inputStream;
            int propertiesSize = 5;
            byte [] properties = new byte [propertiesSize];
            if (inStream.read (properties, 0, propertiesSize) != propertiesSize) {
                throw new Exception ("input .lzma file is too short");
            }
            final SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder ();
            if (! decoder.SetDecoderProperties (properties)) {
                throw new Exception ("Incorrect stream properties");
            }
            long outSize = 0;
            for (int i = 0; i < 8; i ++) {
                int v = inStream.read ();
                if (v < 0) {
                    throw new Exception ("Can't read stream size");
                }
                outSize |= ((long) v) << (8 * i);
            }
            File tempfile = File.createTempFile ("lzma", "temp");
            FileOutputStream fos = new FileOutputStream (tempfile);
            try {
                try {
                    if (! decoder.Code (inStream, fos, outSize)) {
                        throw new Exception ("Can't decode stream");
                    }
                } finally {
                    fos.close ();
                }
                inputStream = new FileInputStream (tempfile);
                try {
                    project = loadProject (inputStream);
                    project.compression_level = 2;
                } finally {
                    inputStream.close ();
                }
            } finally {
                tempfile.delete ();
            }
        } finally {
            fileinputStream.close ();
        }
    }
    if (project == null) {
        FileInputStream fileinputStream = new FileInputStream (file);
        try {
            project = loadProject (fileinputStream);
        } finally {
            fileinputStream.close ();
        }
    }
    return project;
}


-----Function Pair=195=-----==

public static final void parseZipInfo (InputStream inIs, File inBaseDir) throws IOException {
    ZipInputStream zis = new ZipInputStream (inIs);
    ZipEntry nextEntry = null;
    while ((nextEntry = zis.getNextEntry ()) != null) {
        String nextEntryName = nextEntry.getName ();
        nextEntryName = nextEntryName.replace ('/', File.separatorChar);
        File nextEntryFile = new File (inBaseDir, nextEntryName);
        if (nextEntry.isDirectory ()) {
            createDir (nextEntryFile);
        }
        else {
            createDir (nextEntryFile.getParentFile ());
            FileOutputStream fos = new FileOutputStream (nextEntryFile);
            byte buffer [] = new byte [1024];
            int len = 0;
            while ((len = zis.read (buffer, 0, buffer.length)) != - 1) {
                fos.write (buffer, 0, len);
            }
            fos.flush ();
            fos.close ();
        }
        zis.closeEntry ();
    }
    zis.close ();
}


public void createKMZ () {
    String path = paths.get (1);
    String icons = paths.get (2);
    try {
        kml.marshal (new File (path + "\\" + "Paczka.kml"));
        System.out.println ("Utworzono pomy≈õlnie plik kml");
        File file = new File (path + "\\" + "Paczka.kml");
        BufferedReader reader = new BufferedReader (new FileReader (file));
        String line = "", oldtext = "";
        while ((line = reader.readLine ()) != null) {
            oldtext += line + "\n";
        }
        reader.close ();
        String newtext = oldtext.replaceAll ("xmlns:xal=\"urn:oasis:names:tc:ciq:xsdschema:xAL:2.0\"", "");
        FileWriter writer = new FileWriter (path + "\\" + "Paczka.kml");
        writer.write (newtext);
        writer.close ();
        File f = new File (path);
        boolean directory = f.isDirectory ();
        try {
            zipPackege (new String (path + "\\"), path + "\\" + "Paczka.kmz", icons);
            System.out.println ("finished OK");
        } catch (FileNotFoundException e) {
            e.printStackTrace ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    } catch (FileNotFoundException ex) {
        System.out.println ("WystƒÖpi≈Ç b≈ÇƒÖd podczas tworzenia pliku KMZ");
    } catch (IOException ex) {
    }
}


-----Function Pair=196=-----=1=

protected static void addFileToJar (JarOutputStream jStream, File inputFile, String logicalFilename, ArrayList addedfiles) throws Exception {
    FileInputStream iStream = null;
    try {
        if (! addedfiles.contains (logicalFilename)) {
            iStream = new FileInputStream (inputFile);
            ZipEntry zipEntry = new ZipEntry (logicalFilename.replace ('\\', '/'));
            jStream.putNextEntry (zipEntry);
            byte [] byteBuffer = new byte [2 * 1024];
            int count = 0;
            do {
                jStream.write (byteBuffer, 0, count);
                count = iStream.read (byteBuffer, 0, byteBuffer.length);
            }
            while (count != - 1);
            addedfiles.add (logicalFilename);
        }
    } catch (IOException ioe) {
        tools.util.LogMgr.err ("Filetil.addFileToJar " + ioe);
        ioe.printStackTrace ();
    } finally {
        if (iStream != null) {
            try {
                iStream.close ();
            } catch (IOException closeException) {
            }
        }
    }
}


private void zipdir (File base, String zipname) throws IOException {
    FilenameFilter ff = new ExporterFileNameFilter ();
    String [] files = base.list (ff);
    File zipfile = new File (base, zipname + ".zip");
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipfile));
    byte [] buf = new byte [10240];
    for (int i = 0; i < files.length; i ++) {
        File f = new File (base, files [i]);
        FileInputStream fis = new FileInputStream (f);
        zos.putNextEntry (new ZipEntry (f.getName ()));
        int len;
        while ((len = fis.read (buf)) > 0) zos.write (buf, 0, len);
        zos.closeEntry ();
        fis.close ();
        f.delete ();
    }
    zos.close ();
}


-----Function Pair=197=-----=1=

protected void truncate (File file) {
    LogLog.debug ("Compression of file: " + file.getAbsolutePath () + " started.");
    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {
        File backupRoot = new File (getBackupDir ());
        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {
            throw new AppenderInitializationError ("Can't create backup dir for backup storage");
        }
        SimpleDateFormat df;
        try {
            df = new SimpleDateFormat (getBackupDateFormat ());
        } catch (Exception e) {
            throw new AppenderInitializationError ("Invalid date formate for backup files: " + getBackupDateFormat (), e);
        }
        String date = df.format (new Date (file.lastModified ()));
        File zipFile = new File (backupRoot, file.getName () + "." + date + ".zip");
        ZipOutputStream zos = null;
        FileInputStream fis = null;
        try {
            zos = new ZipOutputStream (new FileOutputStream (zipFile));
            ZipEntry entry = new ZipEntry (file.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            entry.setCrc (FileUtils.checksumCRC32 (file));
            zos.putNextEntry (entry);
            fis = FileUtils.openInputStream (file);
            byte [] buffer = new byte [1024];
            int readed;
            while ((readed = fis.read (buffer)) != - 1) {
                zos.write (buffer, 0, readed);
            }
        } catch (Exception e) {
            throw new AppenderInitializationError ("Can't create zip file", e);
        } finally {
            if (zos != null) {
                try {
                    zos.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zip file", e);
                }
            }
            if (fis != null) {
                try {
                    fis.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zipped file", e);
                }
            }
        }
        if (! file.delete ()) {
            throw new AppenderInitializationError ("Can't delete old log file " + file.getAbsolutePath ());
        }
    }
}


public static String flushToCollector (AgentServer as, String IDVotazione) {
    VotazioneData v = (VotazioneData) as.af.votazioni.get (IDVotazione);
    if (Forwarder.enaChkTimeOnFlush) {
        int resultCheckTime = AgentFactory.checkTime (as.af.votazioni, IDVotazione);
        if (resultCheckTime != AgentFactory.C_TimeTooLate) {
            LOGGER.warn ("Votazione " + IDVotazione + " non ancora chiusa");
            return "NOTCLOSED";
        }
    }
    String collectorCertBase64 = null;
    String urlCollector = null;
    Iterator < Role4VotazioneData > ia = v.agents.iterator ();
    while (ia.hasNext ()) {
        Role4VotazioneData r = (Role4VotazioneData) ia.next ();
        if (r.role == Role4VotazioneData.C_COLLECTOR) {
            if (LOGGER.isDebugEnabled ()) LOGGER.debug ("FOUND:" + r.IDAgent + " " + r.role);
            AgentData ad = (AgentData) as.af.agents.get (r.IDAgent);
            collectorCertBase64 = ad.cert;
            urlCollector = ad.url;
            break;
        }
    }
    if (collectorCertBase64 == null) return "NOCERTFORCOLLECTOR";
    Certificate collectorCert = null;
    try {
        collectorCert = Crypto.loadCertBase64 (collectorCertBase64);
    } catch (Exception e) {
        LOGGER.error ("Unexpected exception", e);
        return "CERTCOLLECTORFAULT";
    }
    LOGGER.info ("Load Agents");
    Connection conn = null;
    boolean autoCommitPresent = true;
    String ANSWER = "FAILURE";
    try {
        Class.forName ("com.mysql.jdbc.Driver");
        String sconn = as.config.getSconn ();
        conn = DriverManager.getConnection (sconn);
        autoCommitPresent = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        String query = "" + " SELECT T1,signT1,envelope " + " FROM envelopes " + " WHERE IDVotazione=? AND flushed = 0 ";
        PreparedStatement pstmt = conn.prepareStatement (query);
        pstmt.setString (1, IDVotazione);
        ResultSet rs = pstmt.executeQuery ();
        String sT1;
        byte [] T1, signT1, envelopeEnc;
        ByteArrayOutputStream stream_out = new ByteArrayOutputStream ();
        ZipOutputStream zip_out = new ZipOutputStream (stream_out);
        zip_out.setLevel (Deflater.DEFAULT_COMPRESSION);
        ByteArrayOutputStream stream_singleVote = null;
        ZipOutputStream zipStream_singleVote = null;
        query = "" + " UPDATE envelopes SET flushed=1 " + " WHERE T1=?";
        PreparedStatement stmt_set_flushed = conn.prepareStatement (query);
        Vector < String > sentT1Buffer = new Vector ();
        int k = 0;
        while (rs.next ()) {
            sT1 = rs.getString ("T1");
            T1 = Base64.decodeBase64 (sT1.getBytes ("utf-8"));
            signT1 = Base64.decodeBase64 (rs.getString ("signT1").getBytes ("utf-8"));
            envelopeEnc = Base64.decodeBase64 (rs.getString ("envelope").getBytes ("utf-8"));
            stream_singleVote = new ByteArrayOutputStream ();
            zipStream_singleVote = new ZipOutputStream (stream_singleVote);
            zipStream_singleVote.setLevel (Deflater.NO_COMPRESSION);
            ZipEntry entry;
            entry = new ZipEntry ("T1");
            zipStream_singleVote.putNextEntry (entry);
            zipStream_singleVote.write (T1);
            zipStream_singleVote.closeEntry ();
            entry = new ZipEntry ("signT1");
            zipStream_singleVote.putNextEntry (entry);
            zipStream_singleVote.write (signT1);
            zipStream_singleVote.closeEntry ();
            entry = new ZipEntry ("envelope");
            zipStream_singleVote.putNextEntry (entry);
            zipStream_singleVote.write (envelopeEnc);
            zipStream_singleVote.closeEntry ();
            zipStream_singleVote.close ();
            entry = new ZipEntry ("vote_" + (k ++));
            zip_out.putNextEntry (entry);
            zip_out.write (stream_singleVote.toByteArray ());
            zip_out.closeEntry ();
            sentT1Buffer.add (sT1);
        }
        rs.close ();
        pstmt.close ();
        if (k == 0) {
            try {
                zip_out.close ();
            } finally {
                LOGGER.info ("There aren't item to be flushed");
                return "OK";
            }
        }
        else zip_out.close ();
        LOGGER.info ("Flushing");
        CollectorClient cc = new CollectorClient (urlCollector, collectorCert, as.af.aData.key);
        String response = cc.sendVote (IDVotazione, stream_out.toByteArray ());
        if (response.startsWith ("FAIL")) {
            LOGGER.error ("Problem flushing: " + response);
            ANSWER = "FAILURE";
        }
        else {
            List < String > T1_received;
            if (response.equals ("OK")) {
                T1_received = new ArrayList ();
            }
            else {
                LOGGER.error ("There are unflushed votes");
                T1_received = Arrays.asList (response.split ("\n"));
            }
            for (String tmpT1 : sentT1Buffer) {
                if (! T1_received.contains (tmpT1)) {
                    stmt_set_flushed.setString (1, tmpT1);
                    stmt_set_flushed.addBatch ();
                }
                else {
                    LOGGER.error ("Couldn't flush vote with T1: " + tmpT1);
                }
            }
            stmt_set_flushed.executeBatch ();
            conn.commit ();
            LOGGER.info ("Votes transferred to collector");
            ANSWER = "OK";
        }
    } catch (BatchUpdateException e) {
        try {
            conn.rollback ();
        } catch (Exception ex) {
        }
        LOGGER.error ("MySQL error", e);
        ANSWER = "MYSQLFAULT";
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (Exception ex) {
        }
        LOGGER.error ("MySQL error", e);
        ANSWER = "MYSQLFAULT";
    } catch (ClassNotFoundException e) {
        LOGGER.error ("Couldn't find jdbc driver", e);
        ANSWER = "FAILURE";
    } catch (IOException e) {
        LOGGER.error ("IO exception", e);
        ANSWER = "CANNOTCREATEPACKETFAULT";
    } finally {
        try {
            conn.setAutoCommit (autoCommitPresent);
            conn.close ();
        } catch (Exception ex) {
        }
    }
    return ANSWER;
}


-----Function Pair=198=-----==

public boolean clonarFichero (FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {
    System.out.println ("");
    boolean estado = false;
    try {
        FileOutputStream salida = new FileOutputStream (rutaFicheroDestino);
        FileChannel canalOrigen = rutaFicheroOrigen.getChannel ();
        FileChannel canalDestino = salida.getChannel ();
        canalOrigen.transferTo (0, canalOrigen.size (), canalDestino);
        rutaFicheroOrigen.close ();
        salida.close ();
        estado = true;
    } catch (IOException e) {
        System.out.println ("No se encontro el archivo");
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


public static < T extends Comparable < T > > void BubbleSortComparable2 (T [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j].compareTo (num [j + 1]) > 0) {
                T temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=199=-----==

private void parsePages (String topic, HashMap wiki, List levelsIn, String group, List sitemapLines, Vector visitedPages) {
    try {
        List result = new ArrayList ();
        List levels = new ArrayList (levelsIn.size ());
        for (int i = 0; i < levelsIn.size (); i ++) {
            if ((i + 1) < levelsIn.size ()) {
                if (SitemapServlet.MORE_TO_COME.equals ((String) levelsIn.get (i))) {
                    levels.add (SitemapServlet.HORIZ_LINE);
                }
                else if (SitemapServlet.LAST_IN_LIST.equals ((String) levelsIn.get (i))) {
                    levels.add (SitemapServlet.NOTHING);
                }
                else {
                    levels.add (levelsIn.get (i));
                }
            }
            else {
                levels.add (levelsIn.get (i));
            }
        }
        List l = (List) wiki.get (topic);
        if (l == null) {
            l = new ArrayList ();
        }
        for (Iterator listIterator = l.iterator (); listIterator.hasNext ();) {
            String link = (String) listIterator.next ();
            if (link.indexOf ('&') > - 1) {
                link = link.substring (0, link.indexOf ('&'));
            }
            if (link.length () > 3 && ! link.startsWith ("topic=") && ! link.startsWith ("action=") && ! visitedPages.contains (link) && ! PseudoTopicHandler.getInstance ().isPseudoTopic (link)) {
                result.add (link);
                visitedPages.add (link);
            }
        }
        SitemapLineBean slb = new SitemapLineBean ();
        slb.setTopic (topic);
        slb.setLevels (new ArrayList (levels));
        slb.setGroup (group);
        slb.setHasChildren (result.size () > 0);
        sitemapLines.add (slb);
        for (int i = 0; i < result.size (); i ++) {
            String link = (String) result.get (i);
            String newGroup = group + "_" + String.valueOf (i);
            boolean isLast = ((i + 1) == result.size ());
            if (isLast) {
                levels.add (SitemapServlet.LAST_IN_LIST);
            }
            else {
                levels.add (SitemapServlet.MORE_TO_COME);
            }
            parsePages (link, wiki, levels, newGroup, sitemapLines, visitedPages);
            levels.remove (levels.size () - 1);
        }
    } catch (Exception e) {
        logger.fatal ("Exception", e);
    }
}


public static byte [] zipBytes (byte [] bytes, String aName) throws IOException {
    ByteArrayOutputStream tempOStream = null;
    BufferedOutputStream tempBOStream = null;
    ZipOutputStream tempZStream = null;
    ZipEntry tempEntry = null;
    byte [] tempBytes = null;
    CRC32 tempCRC = null;
    tempOStream = new ByteArrayOutputStream (bytes.length);
    tempBOStream = new BufferedOutputStream (tempOStream);
    tempZStream = new ZipOutputStream (tempBOStream);
    tempCRC = new CRC32 ();
    tempCRC.update (bytes, 0, bytes.length);
    tempEntry = new ZipEntry (aName);
    tempEntry.setMethod (ZipEntry.STORED);
    tempEntry.setSize (bytes.length);
    tempEntry.setCrc (tempCRC.getValue ());
    tempZStream.putNextEntry (tempEntry);
    tempZStream.write (bytes, 0, bytes.length);
    tempZStream.flush ();
    tempBytes = tempOStream.toByteArray ();
    tempZStream.close ();
    return tempBytes;
}


-----Function Pair=200=-----==

private void writeZipFileLocales (ZipOutputStream zos, Locale [] locales, Locale [] referenceLocales) throws IOException {
    ZipEntry zipEntry = new ZipEntry (LOCALES_FILE_NAME);
    zos.putNextEntry (zipEntry);
    BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (zos));
    if (locales != null) {
        for (int i = 0; i < locales.length; i ++) {
            writeLocaleEntry (locales [i], writer, false);
        }
    }
    if (referenceLocales != null) {
        for (int i = 0; i < referenceLocales.length; i ++) {
            writeLocaleEntry (referenceLocales [i], writer, true);
        }
    }
    writer.flush ();
    zos.closeEntry ();
}


public static boolean existsWithRetry (String fileName, int retries, long timeBetweenRetries) {
    File file = new File (fileName);
    for (int i = 0; i < retries; i ++) {
        if (i > 0) {
            try {
                Thread.sleep (timeBetweenRetries);
            } catch (InterruptedException e) {
                log.log (Level.WARNING, "Problem sleeping between file exist checking", e);
            }
        }
        if (file.exists ()) {
            return true;
        }
    }
    return false;
}


-----Function Pair=201=-----==

private void saveButton_actionPerformed (ActionEvent e) {
    File theFile = getSaveFile ();
    if (theFile == null) {
        return;
    }
    DataSet ds = theDataTreePanel.getSelectedTasselDataSet ();
    try {
        FileWriter fw = new FileWriter (theFile);
        PrintWriter pw = new PrintWriter (fw);
        for (int i = 0; i < ds.getSize (); i ++) {
            if (ds.getData (i).getData () instanceof Alignment) {
                pw.println (ds.getData (i).getData ().toString ());
            }
            else if (ds.getData (i).getData () instanceof net.maizegenetics.pal.alignment.Phenotype) {
                PhenotypeUtils.saveAs ((net.maizegenetics.pal.alignment.Phenotype) ds.getData (i).getData (), pw);
            }
            else if (ds.getData (i).getData () instanceof net.maizegenetics.pal.report.TableReport) {
                pw.println (TableReportUtils.toDelimitedString ((net.maizegenetics.pal.report.TableReport) ds.getData (i).getData (), "\t"));
            }
            else {
                pw.println (ds.getData (i).getData ().toString ());
            }
            pw.println ("");
        }
        fw.flush ();
        fw.close ();
    } catch (Exception ee) {
        System.err.println ("saveButton_actionPerformed:" + ee);
    }
    this.statusBar.setText ("Datasets were saved to " + theFile.getName ());
}


public void closeEntry () throws IOException {
    def.finish ();
    while (! def.finished ()) deflate ();
    long uncompressed_size = def.getTotalIn ();
    long compressed_size = def.getTotalOut ();
    long ecrc = (crc.getValue ());
    bytes_written += compressed_size;
    if (outSeekable || current.getCrc () == - 1 || current.getCompressedSize () == - 1 || current.getSize () == - 1) {
        current.setCrc (ecrc);
        current.compressedSize = compressed_size;
        current.setSize (uncompressed_size);
    }
    else {
        if (current.getCrc () != ecrc || current.getCompressedSize () != compressed_size || current.getSize () != uncompressed_size) throw new ZipException ("zip entry field incorrect");
    }
    if (outSeekable) {
        long here = bytes_written;
        ((SeekableOutputStream) out).seek (currentStart + 14);
        put4 (ecrc);
        put4 (compressed_size);
        put4 (uncompressed_size);
        ((SeekableOutputStream) out).seek (here);
    }
    else bytes_written += current.writeExtHeader (out);
    crc.reset ();
    def.reset ();
    current.next = chain;
    chain = current;
    current = null;
}


-----Function Pair=202=-----==

private boolean saveLOBDataToFileSystem () {
    if ("".equals (m_attachmentPathRoot)) {
        log.severe ("no attachmentPath defined");
        return false;
    }
    if (m_items == null || m_items.size () == 0) {
        setBinaryData (null);
        return true;
    }
    final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
    try {
        final DocumentBuilder builder = factory.newDocumentBuilder ();
        final Document document = builder.newDocument ();
        final Element root = document.createElement ("attachments");
        document.appendChild (root);
        document.setXmlStandalone (true);
        for (int i = 0; i < m_items.size (); i ++) {
            log.fine (m_items.get (i).toString ());
            File entryFile = m_items.get (i).getFile ();
            final String path = entryFile.getAbsolutePath ();
            log.fine (path + " - " + m_attachmentPathRoot);
            if (! path.startsWith (m_attachmentPathRoot)) {
                log.fine ("move file: " + path);
                FileChannel in = null;
                FileChannel out = null;
                try {
                    final File destFolder = new File (m_attachmentPathRoot + File.separator + getAttachmentPathSnippet ());
                    if (! destFolder.exists ()) {
                        if (! destFolder.mkdirs ()) {
                            log.warning ("unable to create folder: " + destFolder.getPath ());
                        }
                    }
                    final File destFile = new File (m_attachmentPathRoot + File.separator + getAttachmentPathSnippet () + File.separator + entryFile.getName ());
                    in = new FileInputStream (entryFile).getChannel ();
                    out = new FileOutputStream (destFile).getChannel ();
                    in.transferTo (0, in.size (), out);
                    in.close ();
                    out.close ();
                    if (entryFile.exists ()) {
                        if (! entryFile.delete ()) {
                            entryFile.deleteOnExit ();
                        }
                    }
                    entryFile = destFile;
                } catch (IOException e) {
                    e.printStackTrace ();
                    log.severe ("unable to copy file " + entryFile.getAbsolutePath () + " to " + m_attachmentPathRoot + File.separator + getAttachmentPathSnippet () + File.separator + entryFile.getName ());
                } finally {
                    if (in != null && in.isOpen ()) {
                        in.close ();
                    }
                    if (out != null && out.isOpen ()) {
                        out.close ();
                    }
                }
            }
            final Element entry = document.createElement ("entry");
            entry.setAttribute ("name", getEntryName (i));
            String filePathToStore = entryFile.getAbsolutePath ();
            filePathToStore = filePathToStore.replaceFirst (m_attachmentPathRoot.replaceAll ("\\\\", "\\\\\\\\"), ATTACHMENT_FOLDER_PLACEHOLDER);
            log.fine (filePathToStore);
            entry.setAttribute ("file", filePathToStore);
            root.appendChild (entry);
        }
        final Source source = new DOMSource (document);
        final ByteArrayOutputStream bos = new ByteArrayOutputStream ();
        final Result result = new StreamResult (bos);
        final Transformer xformer = TransformerFactory.newInstance ().newTransformer ();
        xformer.transform (source, result);
        final byte [] xmlData = bos.toByteArray ();
        log.fine (bos.toString ());
        setBinaryData (xmlData);
        return true;
    } catch (Exception e) {
        log.log (Level.SEVERE, "saveLOBData", e);
    }
    setBinaryData (null);
    return false;
}


protected void exportToFile (String file) throws Exception {
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (file));
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        ContactFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "contacts.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        ContextFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "contexts.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        FolderFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "folders.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        GoalFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "goals.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        LocationFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "locations.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        NoteFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "notes.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    {
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        TaskFactory.getInstance ().encodeToXML (output);
        this.writeIntoZip (zos, "tasks.xml", new ByteArrayInputStream (output.toByteArray ()));
    }
    zos.close ();
}


-----Function Pair=203=-----==

private void buildExportZipFile (String parentDirectory, ZipOutputStream zipOutputStream, File [] files) {
    try {
        for (int i = 0; i < files.length; i ++) {
            if (files [i].isDirectory ()) {
                if (parentDirectory.equals ("")) {
                    ZipEntry newZipEntry = new ZipEntry (files [i].getName () + "/");
                    zipOutputStream.putNextEntry (newZipEntry);
                    zipOutputStream.closeEntry ();
                    zipOutputStream.flush ();
                    File [] subFiles = files [i].listFiles ();
                    buildExportZipFile (files [i].getName (), zipOutputStream, subFiles);
                }
                else {
                    ZipEntry newZipEntry = new ZipEntry (parentDirectory + System.getProperty ("file.separator") + files [i].getName () + "/");
                    zipOutputStream.putNextEntry (newZipEntry);
                    zipOutputStream.closeEntry ();
                    zipOutputStream.flush ();
                    File [] subFiles = files [i].listFiles ();
                    buildExportZipFile (parentDirectory + System.getProperty ("file.separator") + files [i].getName (), zipOutputStream, subFiles);
                }
            }
            else {
                ZipEntry newZipEntry;
                if (parentDirectory.equals ("")) {
                    newZipEntry = new ZipEntry (files [i].getName ());
                }
                else {
                    newZipEntry = new ZipEntry (parentDirectory + System.getProperty ("file.separator") + files [i].getName ());
                }
                zipOutputStream.putNextEntry (newZipEntry);
                InputStream is = new FileInputStream (files [i]);
                byte [] buf = new byte [4096];
                int len;
                while ((len = is.read (buf)) > 0) {
                    zipOutputStream.write (buf, 0, len);
                }
                is.close ();
                zipOutputStream.closeEntry ();
                zipOutputStream.flush ();
            }
        }
    } catch (Exception exp) {
        exp.printStackTrace ();
    }
}


public boolean requestNewTime (int time, TimePreference searchDirection) throws RemoteException {
    int lastTime = - 1;
    int foundTime = - 1;
    for (Integer timestep : this.timesteps.keySet ()) {
        if (searchDirection == TimePreference.EARLIER) {
            if (timestep >= time) {
                foundTime = lastTime;
                break;
            }
        }
        else {
            if (timestep >= time) {
                foundTime = timestep;
                break;
            }
        }
        lastTime = timestep;
    }
    if (foundTime == - 1) return false;
    this.nextTime = foundTime;
    this.actBuffer = null;
    return true;
}


-----Function Pair=204=-----==

private void setXMLExtents (ExtentManager extents) {
    int size = extents.size ();
    for (int i = 0; i < extents.size (); i ++) {
        Extent extent = extents.at (i);
        String extent_tree_path = fileresource.getFileDirectory () + File.separatorChar + fileresource.getFileName () + File.separatorChar + "extent_tree_" + i + ".xml";
        try {
            DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance ().newDocumentBuilder ();
            Document document = docBuilder.parse (new File (extent_tree_path));
            extent.setExtentXML (document);
        } catch (IOException e) {
        } catch (ParserConfigurationException e) {
            System.out.println ("PARSER CONFIG EXCEPTION: " + e.getMessage ());
        } catch (SAXException e) {
        }
    }
}


protected void readImage (String entryName, InputStream in, long entrySizeHint) throws IOException {
    if (entrySizeHint < 0) {
        logger.warn ("The entrySizeHint is negative for entry: " + entryName);
        entrySizeHint = 1024;
    }
    String [] imageInfo = this.entryName2ImageInfo.remove (entryName);
    if (imageInfo == null) {
        logger.warn ("There is no image registration in the manifest for entry: " + entryName);
        return;
    }
    String imageKey = imageInfo [2];
    if (imageKey2ImageDrawComponents == null) imageKey2ImageDrawComponents = getImageKey2ImageDrawComponent (root);
    Set < ImageDrawComponent > imageDCs = imageKey2ImageDrawComponents.get (imageKey);
    int size = imageDCs.size ();
    logger.debug (size + " imageDCs are found for imageKey " + imageKey);
    DataBuffer dataBuffer = null;
    if (size > 1) dataBuffer = new DataBuffer (entrySizeHint, in);
    for (ImageDrawComponent imageDC : imageDCs) {
        if (dataBuffer != null) {
            InputStream inputStream = dataBuffer.createInputStream ();
            try {
                imageDC.reloadImage (inputStream);
            } finally {
                inputStream.close ();
            }
        }
        else {
            imageDC.reloadImage (in);
        }
    }
}


-----Function Pair=205=-----=1=

private void zipFiles (Set < File > files, File zipFile) throws IOException {
    if (files.isEmpty ()) {
        log.warn ("No files to zip.");
    }
    else {
        try {
            BufferedInputStream origin = null;
            FileOutputStream dest = new FileOutputStream (zipFile);
            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
            byte data [] = new byte [BUFFER];
            for (File f : files) {
                log.debug ("Adding file " + f + " to archive");
                FileInputStream fi = new FileInputStream (f);
                origin = new BufferedInputStream (fi, BUFFER);
                ZipEntry entry = new ZipEntry (f.getName ());
                out.putNextEntry (entry);
                int count;
                while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                    out.write (data, 0, count);
                }
                origin.close ();
            }
            out.finish ();
            out.close ();
        } catch (IOException e) {
            log.error ("IOException while zipping files: " + files);
            throw e;
        }
    }
}


private static void recurseAndZip (File file, ZipOutputStream zos) throws IOException {
    if (file.isDirectory ()) {
        File [] files = file.listFiles ();
        if (files != null) {
            for (int i = 0; i < files.length; i ++) {
                File file1 = files [i];
                recurseAndZip (file1, zos);
            }
        }
    }
    else {
        byte [] buf = new byte [1024];
        int len;
        ZipEntry entry = new ZipEntry (file.getPath ());
        FileInputStream fis = new FileInputStream (file);
        BufferedInputStream bis = new BufferedInputStream (fis);
        zos.putNextEntry (entry);
        while ((len = bis.read (buf)) >= 0) {
            zos.write (buf, 0, len);
        }
        bis.close ();
        zos.closeEntry ();
    }
}


-----Function Pair=206=-----==

public GEnterprisePackage write (GEnterprisePackage pkg) throws Exception {
    String suffix = "_ims.xml";
    if (zipped) {
        suffix = "_ims.zip";
    }
    File f = null;
    if (appendUnique) {
        f = File.createTempFile (filename, suffix, new File (this.directory));
    }
    else {
        f = new File (this.directory + File.separator + filename + suffix);
    }
    if (zipped) {
        FileOutputStream bout = new FileOutputStream (f);
        ZipOutputStream zipout = new ZipOutputStream (bout);
        ZipEntry ze = new ZipEntry (filename + "_ims.xml");
        zipout.putNextEntry (ze);
        pkg.write (zipout);
        zipout.closeEntry ();
        zipout.close ();
    }
    else {
        FileOutputStream out = new FileOutputStream (f);
        pkg.write (out);
        out.close ();
    }
    return new GEnterprisePackage ();
}


private static void createJarFilesWith (ZipOutputStream out, List < String > filesFullPath) {
    byte [] data = new byte [COMPRESS_OUTPUTSTREAM_BUFFER_SIZE];
    BufferedInputStream origin = null;
    int counter = 0;
    for (Iterator < ? > i = filesFullPath.iterator (); i.hasNext ();) {
        String filename = (String) i.next ();
        try {
            addFileToJar (origin, out, data, filename);
            counter ++;
        } catch (FileNotFoundException e) {
            logger.error ("File '" + filename + "' couldn't be added to jar file because it doesn't exist file.", e);
        } catch (IOException e1) {
            logger.error ("File '" + filename + "' couldn't be added to jar file cause of an input/ouput error.", e1);
        }
    }
    try {
        out.close ();
        logger.debug ("Zip file was created and '" + counter + "' files was added succesfully.");
    } catch (IOException e) {
        logger.error ("Zip file couldn't be closed correctly cause by a input / output error.");
    }
}


-----Function Pair=207=-----==

public void itemStateChanged (ItemEvent e) {
    Object source = e.getSource ();
    if (source == showAllCheckbox) {
        if (firstTime) labelsCheckbox.setState (true);
        showAll (showAllCheckbox.getState () ? SHOW_ALL : SHOW_NONE);
        firstTime = false;
        return;
    }
    if (source == labelsCheckbox) {
        if (firstTime) showAllCheckbox.setState (true);
        boolean editState = labelsCheckbox.getState ();
        boolean showAllState = showAllCheckbox.getState ();
        if (! showAllState && ! editState) showAll (SHOW_NONE);
        else {
            showAll (editState ? LABELS : NO_LABELS);
            if (editState) showAllCheckbox.setState (true);
        }
        firstTime = false;
        return;
    }
    if (e.getStateChange () == ItemEvent.SELECTED && ! ignoreInterrupts) {
        int index = 0;
        try {
            index = Integer.parseInt (e.getItem ().toString ());
        } catch (NumberFormatException ex) {
        }
        if (index < 0) index = 0;
        if (! IJ.isMacintosh ()) {
            if (! IJ.shiftKeyDown ()) lastNonShiftClick = index;
            if (! IJ.shiftKeyDown () && ! IJ.controlKeyDown ()) {
                int [] indexes = list.getSelectedIndexes ();
                for (int i = 0; i < indexes.length; i ++) {
                    if (indexes [i] != index) list.deselect (indexes [i]);
                }
            }
            else if (IJ.shiftKeyDown () && lastNonShiftClick >= 0 && lastNonShiftClick < list.getItemCount ()) {
                int firstIndex = Math.min (index, lastNonShiftClick);
                int lastIndex = Math.max (index, lastNonShiftClick);
                int [] indexes = list.getSelectedIndexes ();
                for (int i = 0; i < indexes.length; i ++) if (indexes [i] < firstIndex || indexes [i] > lastIndex) list.deselect (indexes [i]);
                for (int i = firstIndex; i <= lastIndex; i ++) list.select (i);
            }
        }
        if (WindowManager.getCurrentImage () != null) {
            restore (getImage (), index, true);
            if (record ()) {
                if (Recorder.scriptMode ()) Recorder.recordCall ("rm.select(imp, " + index + ");");
                else Recorder.record ("roiManager", "Select", index);
            }
        }
    }
}


public String sample (ArrayList < QueryField > fields) {
    StringBuilder sb = new StringBuilder ();
    layerSampling (fields);
    int [] validFields = null;
    if (fields == null) {
        validFields = new int [data.size ()];
        for (int i = 0; i < data.size (); i ++) {
            validFields [i] = i;
        }
    }
    else {
        validFields = new int [fields.size ()];
        for (int i = 0; i < fields.size (); i ++) {
            validFields [i] = - 1;
            for (int j = 0; j < data.size (); j ++) {
                if (fields.get (i) != null && fields.get (i).getName () != null && data.get (j).getName ().equals (fields.get (i).getName ())) {
                    validFields [i] = j;
                    break;
                }
            }
        }
    }
    for (int i = 0; i < validFields.length; i ++) {
        if (i > 0) {
            sb.append (",");
        }
        if (validFields [i] >= 0) {
            sb.append (data.get (validFields [i]).getDisplayName ());
        }
        else {
            sb.append (fields.get (i).getDisplayName ());
        }
    }
    int recordCount = points.length / 2;
    for (int j = 0; j < recordCount; j ++) {
        sb.append ("\n");
        for (int i = 0; i < validFields.length; i ++) {
            if (i > 0) {
                sb.append (",");
            }
            if (validFields [i] >= 0 && data.get (validFields [i]).getAsString (j) != null) {
                sb.append ("\"");
                sb.append (String.valueOf (data.get (validFields [i]).getAsString (j)).replace ("\"", "\"\""));
                sb.append ("\"");
            }
            else {
                sb.append ("n/a");
            }
        }
    }
    return sb.toString ();
}


-----Function Pair=208=-----==

public void initialize (PlugInContext context) throws Exception {
    WorkbenchContext workbenchContext = context.getWorkbenchContext ();
    FeatureInstaller featureInstaller = new FeatureInstaller (workbenchContext);
    fileChooser = new JFileChooser ();
    fileChooser.setDialogTitle ("Save files from read-only sources");
    fileChooser.setDialogType (JFileChooser.SAVE_DIALOG);
    fileChooser.setMultiSelectionEnabled (false);
    GUIUtil.removeChoosableFileFilters (fileChooser);
    FileFilter fileFilter1 = GUIUtil.createFileFilter ("SHP Files", new String [] {"shp"});
    fileChooser.addChoosableFileFilter (fileFilter1);
    FileFilter fileFilter2 = GUIUtil.createFileFilter ("GML Files", new String [] {"gml"});
    fileChooser.addChoosableFileFilter (fileFilter2);
    FileFilter fileFilter3 = GUIUtil.createFileFilter ("JML Files", new String [] {"jml"});
    fileChooser.addChoosableFileFilter (fileFilter3);
    FileFilter fileFilter4 = GUIUtil.createFileFilter ("FME Files", new String [] {"fme"});
    fileChooser.addChoosableFileFilter (fileFilter4);
    FileFilter fileFilter5 = GUIUtil.createFileFilter ("WKT Files", new String [] {"wkt"});
    fileChooser.addChoosableFileFilter (fileFilter5);
    fileChooser.setFileFilter (fileFilter1);
    JPopupMenu layerNamePopupMenu = workbenchContext.getWorkbench ().getFrame ().getLayerNamePopupMenu ();
    featureInstaller.addPopupMenuItem (layerNamePopupMenu, this, "Save Selected Datasets", false, ICON, SaveDatasetsPlugIn.createEnableCheck (workbenchContext));
}


private List computeIcStored (IcTuple [] ic_local, IcTuple [] ic_relevant) {
    List result = new ArrayList (ic_relevant.length);
    List duplicates = new ArrayList (ic_relevant.length);
    Set isInResult = new HashSet (ic_relevant.length);
    if (ic_local != null) {
        for (int index = 0; index < ic_local.length; index ++) {
            if (isInResult.add (ic_local [index])) {
                result.add (ic_local [index]);
            }
        }
    }
    for (int index = 0; index < ic_relevant.length; index ++) {
        if (isInResult.add (ic_relevant [index])) {
            result.add (ic_relevant [index]);
        }
        else {
            duplicates.add (ic_relevant [index]);
        }
    }
    for (int index = 0; index < duplicates.size (); index ++) {
        IcTuple tuple = (IcTuple) duplicates.get (index);
        result.remove (tuple);
    }
    return result;
}


-----Function Pair=209=-----==

void dumpIndex (String rootjar, JarIndex index) throws IOException {
    File jarFile = new File (rootjar);
    Path jarPath = jarFile.toPath ();
    Path tmpPath = createTempFileInSameDirectoryAs (jarFile).toPath ();
    try {
        if (update (jarPath.newInputStream (), tmpPath.newOutputStream (), null, index)) {
            try {
                tmpPath.moveTo (jarPath, REPLACE_EXISTING);
            } catch (IOException e) {
                throw new IOException (getMsg ("error.write.file"), e);
            }
        }
    } finally {
        tmpPath.deleteIfExists ();
    }
}


public void run () {
    colorizer.PixelData [] [] pixels;
    colorizer.ColorMap colorTable = new colorizer.ColorMap ();
    colorizeProgressBar.setValue (10);
    for (int i = 0; i < colorMapImage.getWidth (null); i ++) for (int j = 0; j < colorMapImage.getHeight (null); j ++) {
        int Prgb = colorMapImage.getRGB (i, j);
        if (Prgb != - 1) {
            colorizer.ColorMapItem newcolormapitem = new colorizer.ColorMapItem ();
            newcolormapitem.setX ((short) i);
            newcolormapitem.setY ((short) j);
            Color selColor = new Color (Prgb);
            byte [] ycbcr = colorizer.ColorConverter.rgb2ycbcr ((short) selColor.getRed (), (short) selColor.getGreen (), (short) selColor.getBlue ());
            newcolormapitem.setColor (new PixelColor ((short) (ycbcr [1]), (short) (ycbcr [2])));
            colorTable.addItem (newcolormapitem);
        }
    }
    colorizeProgressBar.setValue (20);
    pixels = new colorizer.PixelData [im.width] [im.height];
    for (int i = 0; i < im.width; i ++) for (int j = 0; j < im.height; j ++) {
        pixels [i] [j] = new colorizer.PixelData ();
        byte [] ycbcr = colorizer.ColorConverter.rgb2ycbcr (im.imageData [0] [j] [i], im.imageData [0] [j] [i], im.imageData [0] [j] [i]);
        pixels [i] [j].setB ((short) (ycbcr [0]));
    }
    colorizer.Colorizer rizer = new colorizer.Colorizer ();
    Color [] [] todraw = rizer.run (pixels, colorTable);
    BufferedImage coloredImage = (BufferedImage) createImage (todraw.length, todraw [0].length);
    Graphics coloredg = coloredImage.getGraphics ();
    for (int i = 0; i < todraw.length; i ++) for (int j = 0; j < todraw [i].length; j ++) {
        coloredg.setColor (todraw [i] [j]);
        coloredg.drawLine (i, j, i, j);
    }
    coloredImage.flush ();
    coloredLabel.setIcon (new ImageIcon (coloredImage));
    coloredLabel.setAutoscrolls (true);
    coloredScrollPane.add (coloredLabel);
    coloredScrollPane.setViewportView (coloredLabel);
    try {
        BMPCodec scodec = new BMPCodec ();
        scodec.setImage (ImageCreator.convertImageToRGB24Image (coloredImage));
        scodec.setFile ("c:\\colored.jpg", CodecMode.SAVE);
        scodec.process ();
        scodec.close ();
    } catch (Exception x) {
        x.printStackTrace ();
    }
}


-----Function Pair=210=-----==

public static Object loadResource (String name) {
    ClassLoader cl = Thread.currentThread ().getContextClassLoader ();
    InputStream is;
    if (cl == null || (is = cl.getResourceAsStream (name)) == null) {
        is = ResourceLocator.class.getClassLoader ().getResourceAsStream (name);
        if (is == null) {
            throw new ConfigurationError ("Missing Resource: " + name);
        }
    }
    try {
        ObjectInputStream ois = new ObjectInputStream (is);
        return ois.readObject ();
    } catch (Exception e) {
        throw new ConfigurationError ("Failed to load Resource " + name, e);
    } finally {
        CloseUtils.safeClose (is);
    }
}


public Content importScormZip (String userId, String worldId, String contentType, DirectoryFolder targetFolder, String fileName, InputStream inputStream, File file) throws ScormFormatException, ErrorUnzippingZipEntryException {
    DraftContent content = null;
    try {
        content = new DraftContent ();
        content.setContentTypeId (ContentTypes.CHAPTERS);
        content.setAuthorId (userId);
        CMSData contentData = ContentTypes.createContentDataFor (ContentTypes.CHAPTERS);
        content.setContentData (contentData);
        content.setScormImported (true);
        content = saveAsDraftContent (content, worldId, targetFolder);
        DirectoryFolder resourcesFolder = content.getResourcesFolder ();
        ManagerRegistry.getDirectoryPersister ().addZipFile (resourcesFolder, file, null);
        Document document = parseDirectoryFile (resourcesFolder.getURLPath () + "/" + IMSMANIFEST_FILE_NAME);
        removeDirectoryItem (resourcesFolder.getURLPath () + "/" + IMSMANIFEST_FILE_NAME);
        Node contentNode = JCRUtil.getNodeById (content.getId (), content.getWorkspace ());
        removeCurrentManifestNode (contentNode);
        removePrefixes (document);
        addManifestToContentNode (document, contentNode);
        contentNode.save ();
        changeOrganizationItemReferences (content);
        convertStringLanguageValues (contentNode);
        contentNode.save ();
        JCRContentManager jcrContentManager = JCRManagerRegistry.getJcrContentManager ();
        jcrContentManager.removeFromCache (contentNode);
        Content contentById = jcrContentManager.getContentById (content.getId (), content.getWorkspace ());
        addLomIfNotPresent (worldId, contentById);
        jcrContentManager.removeFromCache (content.getScribeContentUrl ());
        JCRUtil.currentSession (targetFolder.getWorkspace ()).save ();
        return contentById;
    } catch (SAXException e) {
        log.error ("Error parsing manifest file.");
        throw new ScormFormatException (e);
    } catch (ErrorUnzippingZipEntryException ezipe) {
        ManagerRegistry.getContentManager ().deleteContent (content);
        log.error ("Error reading zip entry");
        throw ezipe;
    } catch (Exception e) {
        log.error ("SCORM content " + fileName + " could not be " + "imported correctly in world " + worldId + " by user " + userId, e);
        throw new CMSRuntimeException (e);
    }
}


-----Function Pair=211=-----==

public void actionPerformed (ActionEvent e) {
    try {
        int pos = editor.getCaretPosition ();
        Element root = editor.getDocument ().getDefaultRootElement ();
        int line = root.getElementIndex (pos);
        int lineStart = root.getElement (line).getStartOffset ();
        int lineEnd = root.getElement (line).getEndOffset ();
        String txt = editor.getDocument ().getText (lineStart, lineEnd - lineStart - 1);
        char [] chars = txt.toCharArray ();
        int offset = pos - lineStart;
        int i;
        for (i = 0; i < chars.length; i ++) {
            if (chars [i] != ' ' || i == offset) break;
        }
        StringBuffer sb = new StringBuffer ();
        sb.append ('\n');
        for (int j = 0; j < i; j ++) {
            sb.append (' ');
        }
        editor.getDocument ().insertString (pos, sb.toString (), null);
    } catch (BadLocationException ex) {
        ex.printStackTrace ();
    }
}


private LMenuItem getResDel () {
    if (resDel == null) {
        resDel = new LMenuItem ();
        resDel.setText ("Del");
        resDel.setCaptionTag ("cmdDel");
        resDel.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent e) {
                onDelete ();
            }
        }
        );
        addTranslatable (resDel);
    }
    return resDel;
}


-----Function Pair=212=-----==

private void zip (File folderToZip) throws Exception {
    BufferedInputStream origin = null;
    FileOutputStream dest = new FileOutputStream (zipOut);
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    byte data [] = new byte [BUFFER];
    List list = getListFiles (folderToZip, new ArrayList ());
    for (int i = 0; i < list.size (); i ++) {
        FileInputStream fi = new FileInputStream ((File) list.get (i));
        origin = new BufferedInputStream (fi, BUFFER);
        File f = (File) list.get (i);
        String entryName = f.getAbsolutePath ().substring (folderToZip.getAbsolutePath ().length () + 1);
        entryName = entryName.replaceAll ("\\\\", "/");
        ZipEntry entry = new ZipEntry (entryName);
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    out.close ();
}


private static void getEntry (String _dir, ZipFile _zipFile, ZipEntry _target) throws ZipException, IOException {
    String parentName = _dir;
    File objFile = new File (_dir + _target.getName ());
    if (_target.isDirectory ()) {
        objFile.getAbsoluteFile ().mkdirs ();
    }
    else {
        BufferedInputStream bis = new BufferedInputStream (_zipFile.getInputStream (_target));
        if ((parentName = objFile.getParent ()) != null) {
            File dir = new File (parentName);
            dir.getAbsoluteFile ().mkdirs ();
        }
        BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (objFile));
        int c;
        while ((c = bis.read ()) != EOF) {
            bos.write ((byte) c);
        }
        bos.close ();
    }
}


-----Function Pair=213=-----==

private void updateFile (BackUpInfoFile fileInfo, ZipOutputStream zos) {
    try {
        int bytesIn = 0;
        File file = new File (fileInfo.getPath () + fileInfo.getName () + "." + fileInfo.getType ());
        FileInputStream fis = new FileInputStream (file);
        ZipEntry anEntry = new ZipEntry (fileInfo.getId ());
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (BUFFER)) != - 1) {
            zos.write (BUFFER, 0, bytesIn);
        }
        fileInfo.setSize (file.length ());
        fis.close ();
    } catch (IOException e) {
        throw new BackupException (e.getMessage ());
    }
}


public void importFile () {
    ImportDialog id = new ImportDialog (cards.size ());
    if (id.showOpenDialog (null) == JFileChooser.APPROVE_OPTION) {
        String delimeter = id.getDelimeter ();
        String quote_char = id.getQuoteChar ();
        boolean before = id.isBeforeSelected ();
        try {
            char d = delimeter.equals ("Tab") ? 9 : delimeter.charAt (0);
            BufferedReader r = new BufferedReader (new FileReader (id.getSelectedFile ().getPath ()));
            String s;
            Vector v = new Vector ();
            while ((s = r.readLine ()) != null) {
                String left = null;
                String right = null;
                if (quote_char.equals ("None")) {
                    int i = s.indexOf (d);
                    if (i != - 1) {
                        left = s.substring (0, i);
                        right = s.substring (i + 1);
                    }
                    else left = s;
                }
                else {
                    int i = s.indexOf (quote_char);
                    if (i != - 1) {
                        int j = s.indexOf (quote_char, i + 1);
                        if (j != - 1) {
                            left = s.substring (i + 1, j);
                            i = s.indexOf (quote_char, j + 1);
                            if (i != - 1) {
                                j = s.indexOf (quote_char, i + 1);
                                if (j != - 1) right = s.substring (i + 1, j);
                            }
                        }
                    }
                }
                Card card = new Card (Side.TEXT, Side.TEXT);
                ((TextSide) card.left_side).setText (left);
                ((TextSide) card.right_side).setText (right);
                v.addElement (card);
            }
            Card [] c = new Card [v.size ()];
            for (int i = 0; i < v.size (); i ++) c [i] = (Card) v.elementAt (i);
            undo_manager.addEdit (new Import (c, current_card, before, default_sets));
            insertCards (c, current_card, before, default_sets);
            updateEditMenu ();
        } catch (IOException e) {
            System.out.println (e);
        }
    }
}


-----Function Pair=214=-----==

private void retrieveIntentData () {
    Intent i = getIntent ();
    String actionSendMultiple = Compatibility.getActionSendMultiple ();
    if (i.getAction () != null) {
        if (i.getAction ().equals (Intent.ACTION_SEND)) {
            Uri toSend = (Uri) i.getParcelableExtra (Intent.EXTRA_STREAM);
            Log.d (LOG_TAG, "Uri to send : " + toSend);
            mAdapter.addUri (toSend);
        }
        else if (actionSendMultiple != null && i.getAction ().equals (actionSendMultiple)) {
            ArrayList < Uri > toSend = i.getParcelableArrayListExtra (Intent.EXTRA_STREAM);
            Log.d (LOG_TAG, "Uri to send : " + toSend);
            mAdapter.addAllUris (toSend);
        }
    }
}


String replace (String line, String from, String to) {
    StringBuffer res = new StringBuffer (line.length ());
    String tmpstr;
    int ind = - 1, lastind = 0;
    while ((ind = line.indexOf (from, ind + 1)) != - 1) {
        if (lastind < ind) {
            tmpstr = line.substring (lastind, ind);
            res.append (tmpstr);
        }
        res.append (to);
        lastind = ind + from.length ();
        ind += from.length () - 1;
    }
    if (lastind == 0) return line;
    res.append (line.substring (lastind));
    return res.toString ();
}


-----Function Pair=215=-----==

public void paintMapTitle (Graphics g, int img_width) {
    if (getMap () == null) {
        return;
    }
    String title = null;
    Key key = new Key (getContext ().getKey ());
    key.set (Key.WILD, 0);
    title = getKeyTitle (key);
    FontMetrics font_metrics = Toolkit.getDefaultToolkit ().getFontMetrics (configuration.getMapLegendFont ());
    Dimension title_size = getTitleDimension (title);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setFont (configuration.getMapLegendFont ());
    g2d.setColor (Color.LIGHT_GRAY);
    g2d.fillRect (0, 0, img_width, title_size.height);
    int op = (img_width - title_size.width) / 2;
    g2d.translate (op, 0);
    g2d.setColor (Color.BLACK);
    g2d.drawString (title, 0, font_metrics.getAscent ());
    g2d.translate (0 - op, 0);
}


public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositions [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositions.length; i ++) {
            int currentStart = sortedPositions [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedPositions [0].position);
        if (useShort) {
            int bp = sortedPositions [0].position;
            for (int i = 1; i < sortedPositions.length; i ++) {
                int currentStart = sortedPositions [i].position;
                int diff = currentStart - bp - 32768;
                workingDOS.writeShort ((short) (diff));
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositions [0].position;
            for (int i = 1; i < sortedPositions.length; i ++) {
                int currentStart = sortedPositions [i].position;
                int diff = currentStart - bp;
                workingDOS.writeInt (diff);
                bp = currentStart;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


-----Function Pair=216=-----==

private static void downloadFile (URL url, File destFile) throws IOException {
    log.info ("downloading file: " + url);
    OutputStream out = null;
    InputStream in = null;
    try {
        in = url.openStream ();
        out = new FileOutputStream (destFile);
        byte [] buff = new byte [1024];
        for (int len = in.read (buff); len != - 1; len = in.read (buff)) {
            out.write (buff, 0, len);
        }
        log.info ("saved file: " + destFile);
    } finally {
        if (in != null) {
            in.close ();
        }
        if (out != null) {
            out.flush ();
            out.close ();
        }
    }
}


public static boolean removeDirectoryContents (File file) {
    boolean flag = false;
    if (file.isDirectory () && ! isRootDirectory (file)) {
        flag = true;
        String as [] = file.list ();
        for (int i = 0; i < as.length; i ++) {
            File file1 = new File (file, as [i]);
            if (! file1.isDirectory () && ! file1.delete ()) {
                flag = false;
            }
        }
        for (int j = 0; j < as.length; j ++) {
            if (! as [j].equals (".") && ! as [j].equals ("..")) {
                File file2 = new File (file, as [j]);
                if (file2.isDirectory () && ! removeDirectory (file2.getAbsolutePath ())) {
                    flag = false;
                }
            }
        }
        if (! file.delete ()) {
            flag = false;
        }
    }
    return flag;
}


-----Function Pair=217=-----==

public static Collection transformList (Collection toTransform, String...methodName) {
    List transformed = new LinkedList ();
    try {
        if (toTransform == null || toTransform.size () == 0) return toTransform;
        for (Object o : toTransform) {
            Object result = o;
            if (methodName == null) {
                result = o.toString ();
            }
            else {
                for (String theMethodName : methodName) {
                    Method method;
                    method = result.getClass ().getMethod (theMethodName);
                    result = method.invoke (result);
                }
            }
            transformed.add (result);
        }
        return transformed;
    } catch (Exception e) {
        return transformed;
    }
}


private String readDocXmlTemplate (String srcFileName) {
    String s = "";
    try {
        File file = new File (srcFileName);
        FileInputStream fis = new FileInputStream (file);
        InputStreamReader reader = new InputStreamReader (fis, "UTF-8");
        BufferedReader br = new BufferedReader (reader);
        String str = null;
        while ((str = br.readLine ()) != null) {
            s = s + str;
        }
        reader.close ();
        br.close ();
    } catch (FileNotFoundException e) {
        System.out.println ("Ê≤°ÊúâÊâæÂà∞Ê®°ÊùøÊñá‰ª∂ÔºÅ");
        e.printStackTrace ();
    } catch (UnsupportedEncodingException e) {
        System.out.println ("ËØªÂèñÊ®°ÊùøÔºö‰∏çÊîØÊåÅÁöÑÂ≠óÁ¨¶ÁºñÁ†ÅÔºÅ");
        e.printStackTrace ();
    } catch (IOException e) {
        System.out.println ("Ê®°ÊùøIOÈîôËØØÔºÅ");
        e.printStackTrace ();
    }
    return s;
}


-----Function Pair=218=-----==

public static ArrayList < File > listFilesIn (File dir) {
    ArrayList < File > result = new ArrayList < File > ();
    if (dir != null && dir.isDirectory ()) {
        String [] children = dir.list ();
        if (children != null) {
            for (String childName : children) {
                File child = new File (dir, childName);
                if (child.isDirectory ()) {
                    result.addAll (listFilesIn (child));
                }
                result.add (child);
            }
        }
    }
    return result;
}


private void buildJar (List < Foto > fotos, OutputStream stream) throws IOException {
    JarOutputStream jar = new JarOutputStream (stream);
    logger.info ("Zipping");
    HashMap < String, String > filenames = new HashMap < String, String > ();
    for (Foto foto : fotos) {
        logger.info ("Zipping " + foto.getTitle ());
        String title = foto.getTitle ();
        title = title.replaceAll ("\\\\", "|");
        title = title.replaceAll ("\\/", "|");
        title = title.replaceAll ("\\~", "-");
        for (; filenames.containsKey (title);) {
            title = title + "_";
        }
        filenames.put (title, "");
        title = title + ".jpg";
        jar.putNextEntry (new ZipEntry (title));
        jar.write (foto.getImgAsBytes ());
    }
    jar.close ();
    logger.info ("Zipping done");
}


-----Function Pair=219=-----==

public void addAgent (String role, String type, String aname) {
    Agent agent = new Agent ();
    try {
        agent.setROLE (Role.parse (role.toUpperCase ()));
    } catch (MetsException e) {
        agent.setROLE (Role.OTHER);
        agent.setOTHERROLE (role);
    }
    try {
        agent.setTYPE (Type.parse (type.toUpperCase ()));
    } catch (MetsException e) {
        agent.setTYPE (Type.OTHER);
        agent.setOTHERTYPE (type);
    }
    Name name = new Name ();
    name.getContent ().add (new PCData (aname));
    agent.getContent ().add (name);
    for (Object o : manifest.getContent ()) {
        if (o instanceof MetsHdr) {
            ((MetsHdr) o).getContent ().add (agent);
            break;
        }
    }
}


protected void addChildResources (String folderName) throws CmsImportExportException, IOException, SAXException {
    try {
        List subFolders = getCms ().getSubFolders (folderName, CmsResourceFilter.IGNORE_EXPIRATION);
        List subFiles = getCms ().getFilesInFolder (folderName, CmsResourceFilter.IGNORE_EXPIRATION);
        for (int i = 0; i < subFiles.size (); i ++) {
            CmsResource file = (CmsResource) subFiles.get (i);
            CmsResourceState state = file.getState ();
            long age = file.getDateLastModified () < file.getDateCreated () ? file.getDateCreated () : file.getDateLastModified ();
            if (getCms ().getRequestContext ().currentProject ().isOnlineProject () || (m_parameters.isIncludeUnchangedResources ()) || state.isNew () || state.isChanged ()) {
                if (! state.isDeleted () && ! CmsWorkplace.isTemporaryFile (file) && (age >= m_parameters.getContentAge ())) {
                    String export = getCms ().getSitePath (file);
                    if (checkExportResource (export)) {
                        if (isInExportableProject (file)) {
                            exportFile (getCms ().readFile (export, CmsResourceFilter.IGNORE_EXPIRATION));
                        }
                    }
                }
            }
            subFiles.set (i, null);
        }
        subFiles = null;
        for (int i = 0; i < subFolders.size (); i ++) {
            CmsResource folder = (CmsResource) subFolders.get (i);
            if (folder.getState () != CmsResource.STATE_DELETED) {
                String export = getCms ().getSitePath (folder);
                if (checkExportResource (export)) {
                    long age = folder.getDateLastModified () < folder.getDateCreated () ? folder.getDateCreated () : folder.getDateLastModified ();
                    if (age >= m_parameters.getContentAge ()) {
                        appendResourceToManifest (folder, false);
                    }
                    addChildResources (getCms ().getSitePath (folder));
                }
            }
            subFolders.set (i, null);
        }
    } catch (CmsImportExportException e) {
        throw e;
    } catch (CmsException e) {
        CmsMessageContainer message = Messages.get ().container (Messages.ERR_IMPORTEXPORT_ERROR_ADDING_CHILD_RESOURCES_1, folderName);
        if (LOG.isDebugEnabled ()) {
            LOG.debug (message.key (), e);
        }
        throw new CmsImportExportException (message, e);
    }
}


-----Function Pair=220=-----==

private void finishManifest (OutputStream out) throws MetsException, UnsupportedEncodingException {
    FileSec fileSec = new FileSec ();
    String primaryBitstreamFileID = null;
    List < Div > contentDivs = new ArrayList < Div > ();
    for (Map.Entry < String, List > e : bundles.entrySet ()) {
        List < String > bitstreams = (List < String >) e.getValue ();
        FileGrp fileGrp = new FileGrp ();
        fileGrp.setUSE (e.getKey ());
        for (String bitstream : bitstreams) {
            edu.harvard.hul.ois.mets.File file = new edu.harvard.hul.ois.mets.File ();
            String fileID = gensym ("bitstream");
            file.setID (fileID);
            if (primaryBitstream != null && primaryBitstream.equals (bitstream)) primaryBitstreamFileID = fileID;
            Div div = new Div ();
            div.setID (gensym ("div"));
            div.setTYPE ("DSpace Content Bitstream");
            Fptr fptr = new Fptr ();
            fptr.setFILEID (fileID);
            div.getContent ().add (fptr);
            contentDivs.add (div);
            file.setSIZE (zipFiles.get (bitstream).absPath.length ());
            FLocat flocat = new FLocat ();
            flocat.setLOCTYPE (Loctype.URL);
            flocat.setXlinkHref (zipFiles.get (bitstream).zipPath);
            String techID = gensym ("techMd_for_bitstream_");
            AmdSec fAmdSec = new AmdSec ();
            fAmdSec.setID (techID);
            TechMD techMd = new TechMD ();
            techMd.setID (gensym ("tech"));
            MdWrap mdWrap = new MdWrap ();
            setMdType (mdWrap, "PREMIS");
            mdWrap.getContent ().add (makeFilePREMIS (bitstream));
            techMd.getContent ().add (mdWrap);
            fAmdSec.getContent ().add (techMd);
            manifest.getContent ().add (fAmdSec);
            file.setADMID (techID);
            file.getContent ().add (flocat);
            fileGrp.getContent ().add (file);
        }
        fileSec.getContent ().add (fileGrp);
    }
    if (! fileSec.getContent ().isEmpty ()) manifest.getContent ().add (fileSec);
    StringBuffer dmdIDstr = new StringBuffer ();
    for (String dmdID : dmdIDs) dmdIDstr.append (" " + dmdID);
    StructMap structMap = new StructMap ();
    structMap.setID (gensym ("struct"));
    structMap.setTYPE ("LOGICAL");
    structMap.setLABEL ("DSpace");
    Div div0 = new Div ();
    div0.setID (gensym ("div"));
    div0.setTYPE ("DSpace Item");
    div0.setDMDID (dmdIDstr.substring (1));
    if (primaryBitstreamFileID != null) {
        Fptr fptr = new Fptr ();
        fptr.setFILEID (primaryBitstreamFileID);
        div0.getContent ().add (fptr);
    }
    div0.getContent ().addAll (contentDivs);
    structMap.getContent ().add (div0);
    manifest.getContent ().add (structMap);
    if (validate) manifest.validate (new MetsValidator ());
    manifest.write (new MetsWriter (out));
}


private File doWrite (File outputFile, boolean showProgress) {
    byte [] buffer = new byte [BUFFER_SIZE];
    int length;
    OutputStream out = null;
    InputStream in = null;
    ProgressMonitorDialog pmd = null;
    try {
        out = new FileOutputStream (outputFile);
        if (! checkFileDestinationSpace (outputFile, originalFile)) {
            throw new IOException ("The destination drive does not contain enough space.");
        }
        if (showProgress) {
            pmd = new ProgressMonitorDialog (new JFrame (), "Copying File...", true);
            pmd.setText ("Copying " + originalFile.getName ());
        }
        in = new BufferedInputStream (new FileInputStream (originalFile));
        long bufferCount = calcBufferCount ();
        long counter = 0;
        while ((length = in.read (buffer)) > 0) {
            counter ++;
            if (pmd != null) {
                pmd.setProgress (counter, bufferCount);
            }
            if (pmd != null && pmd.isCanceled ()) {
                out.close ();
                outputFile.delete ();
                break;
            }
            out.write (buffer, 0, length);
        }
        checkCopiedFile (outputFile);
        in.close ();
        out.close ();
    } catch (FileNotFoundException e) {
        log.log (Level.SEVERE, this.getClass ().getName (), e);
        return null;
    } catch (IOException e) {
        log.log (Level.SEVERE, this.getClass ().getName (), e);
        return null;
    } finally {
        try {
            if (in != null) {
                in.close ();
            }
            if (out != null) {
                out.close ();
            }
        } catch (IOException e) {
            log.log (Level.SEVERE, this.getClass ().getName (), e);
        }
    }
    return outputFile;
}


-----Function Pair=221=-----==

public void putNextEntry (ZipEntry entry) throws IOException {
    if (entries == null) throw new ZipException ("ZipOutputStream was finished");
    int method = entry.getMethod ();
    int flags = 0;
    if (method == - 1) method = defaultMethod;
    if (method == STORED) {
        if (entry.getCompressedSize () >= 0) {
            if (entry.getSize () < 0) entry.setSize (entry.getCompressedSize ());
            else if (entry.getSize () != entry.getCompressedSize ()) throw new ZipException ("Method STORED, but compressed size != size");
        }
        else entry.setCompressedSize (entry.getSize ());
        if (entry.getSize () < 0) throw new ZipException ("Method STORED, but size not set");
        if (entry.getCrc () < 0) throw new ZipException ("Method STORED, but crc not set");
    }
    else if (method == DEFLATED) {
        if (entry.getCompressedSize () < 0 || entry.getSize () < 0 || entry.getCrc () < 0) flags |= 8;
    }
    if (curEntry != null) closeEntry ();
    if (entry.getTime () < 0) entry.setTime (System.currentTimeMillis ());
    entry.flags = flags;
    entry.offset = offset;
    entry.setMethod (method);
    curMethod = method;
    writeLeInt (LOCSIG);
    writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
    writeLeShort (flags);
    writeLeShort (method);
    writeLeInt (entry.getDOSTime ());
    if ((flags & 8) == 0) {
        writeLeInt ((int) entry.getCrc ());
        writeLeInt ((int) entry.getCompressedSize ());
        writeLeInt ((int) entry.getSize ());
    }
    else {
        writeLeInt (0);
        writeLeInt (0);
        writeLeInt (0);
    }
    byte [] name;
    try {
        name = entry.getName ().getBytes ("UTF-8");
    } catch (UnsupportedEncodingException uee) {
        throw new Error (uee.toString ());
    }
    if (name.length > 0xffff) throw new ZipException ("Name too long.");
    byte [] extra = entry.getExtra ();
    if (extra == null) extra = new byte [0];
    writeLeShort (name.length);
    writeLeShort (extra.length);
    out.write (name);
    out.write (extra);
    offset += LOCHDR + name.length + extra.length;
    curEntry = entry;
    crc.reset ();
    if (method == DEFLATED) def.reset ();
    size = 0;
}


protected void writeFile (boolean isDirectory, InputStream inputFile, String filename, boolean verbose) throws IOException {
    if (writtenItems.contains (filename)) {
        if (verbose) {
            String msg = MessageFormat.format (Messages.getString ("Creator.Ignoring"), new Object [] {filename});
            System.err.println (msg);
        }
        return;
    }
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    CRC32 crc = new CRC32 ();
    long size;
    if (isDirectory) {
        size = 0;
    }
    else {
        size = copyFile (crc, inputFile, out);
    }
    ZipEntry entry = new ZipEntry (filename);
    entry.setCrc (crc.getValue ());
    entry.setSize (size);
    outputStream.putNextEntry (entry);
    out.writeTo (outputStream);
    outputStream.closeEntry ();
    writtenItems.add (filename);
    if (verbose) {
        long csize = entry.getCompressedSize ();
        long perc;
        if (size == 0) perc = 0;
        else perc = 100 - (100 * csize) / size;
        String msg = MessageFormat.format (Messages.getString ("Creator.Adding"), new Object [] {filename, Long.valueOf (size), Long.valueOf (entry.getSize ()), Long.valueOf (perc)});
        System.err.println (msg);
    }
}


-----Function Pair=222=-----==

private void addFileNameExtension (FileHolder fileHolder) {
    if (fileHolder.destFileName == null) return;
    String [] newDestFiles = new String [fileHolder.destFiles.length];
    for (int i = 0; i < fileHolder.destFiles.length; i ++) {
        String newFileName = fileHolder.destFiles [i].toLowerCase ();
        if (this.zapType.equals (XmultraConfig.TAR_GZIP_VALUE)) {
            if (newFileName.endsWith (TAR_GZIP_EXTENSION_1) || newFileName.endsWith (TAR_GZIP_EXTENSION_2) || newFileName.endsWith (TAR_GZIP_EXTENSION_3)) {
                newDestFiles [i] = fileHolder.destFiles [i];
                continue;
            }
        }
        if (newFileName.endsWith (this.fileNameExtension)) {
            newDestFiles [i] = fileHolder.destFiles [i];
        }
        else {
            newDestFiles [i] = fileHolder.destFiles [i] + this.fileNameExtension;
        }
    }
    fileHolder.destFiles = newDestFiles;
}


private static boolean addFileToZip (ZipOutputStream zipWriter, File zipArchive, File file, final byte [] readBuffer, String currentPath) throws IOException {
    if (zipArchive.getAbsoluteFile ().equals (file.getAbsoluteFile ())) {
        return true;
    }
    InputStream fileInputStream = null;
    try {
        if (! file.canRead ()) {
            return false;
        }
        fileInputStream = Channels.newInputStream (new FileInputStream (file).getChannel ());
        ZipEntry fileEntry = new ZipEntry (currentPath + file.getName ());
        zipWriter.putNextEntry (fileEntry);
        int readBytes;
        while ((readBytes = fileInputStream.read (readBuffer)) > 0) {
            zipWriter.write (readBuffer, 0, readBytes);
            zipWriter.flush ();
        }
        zipWriter.closeEntry ();
        zipWriter.flush ();
    } finally {
        if (fileInputStream != null) {
            fileInputStream.close ();
        }
    }
    return true;
}


-----Function Pair=223=-----==

public static void copyFile (File from, File to) {
    try {
        FileInputStream in = new FileInputStream (from);
        FileOutputStream out = new FileOutputStream (to);
        byte [] buffer = new byte [1024 * 16];
        int read = 0;
        while ((read = in.read (buffer)) >= 0) {
            out.write (buffer, 0, read);
        }
        in.close ();
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void saveDrivingLicense () {
    collectDrivingLicenseData ();
    JFileChooser fileChooser = new JFileChooser ();
    fileChooser.setFileFilter (net.sourceforge.scuba.util.Files.ZIP_FILE_FILTER);
    int choice = fileChooser.showSaveDialog (getContentPane ());
    switch (choice) {
        case JFileChooser.APPROVE_OPTION :
            try {
                File file = fileChooser.getSelectedFile ();
                FileOutputStream fileOut = new FileOutputStream (file);
                ZipOutputStream zipOut = new ZipOutputStream (fileOut);
                for (short fid : dl.getFileList ()) {
                    String eap = "";
                    if (fid == DrivingLicenseService.EF_DG2 && eapDG2.isEnabled () && eapDG2.isSelected ()) {
                        eap = "eap";
                    }
                    if (fid == DrivingLicenseService.EF_DG3 && eapDG3.isEnabled () && eapDG3.isSelected ()) {
                        eap = "eap";
                    }
                    String entryName = Hex.shortToHexString (fid) + eap + ".bin";
                    InputStream dg = dl.getInputStream (fid);
                    zipOut.putNextEntry (new ZipEntry (entryName));
                    int bytesRead;
                    byte [] dgBytes = new byte [1024];
                    while ((bytesRead = dg.read (dgBytes)) > 0) {
                        zipOut.write (dgBytes, 0, bytesRead);
                    }
                    zipOut.closeEntry ();
                }
                byte [] keySeed = dl.getKeySeed ();
                if (keySeed != null) {
                    String entryName = "keyseed.bin";
                    zipOut.putNextEntry (new ZipEntry (entryName));
                    zipOut.write (keySeed);
                    zipOut.closeEntry ();
                }
                PrivateKey aaPrivateKey = dl.getAAPrivateKey ();
                if (aaPrivateKey != null) {
                    String entryName = "aaprivatekey.der";
                    zipOut.putNextEntry (new ZipEntry (entryName));
                    zipOut.write (aaPrivateKey.getEncoded ());
                    zipOut.closeEntry ();
                }
                PrivateKey caPrivateKey = dl.getEAPPrivateKey ();
                if (caPrivateKey != null) {
                    String entryName = "caprivatekey.der";
                    zipOut.putNextEntry (new ZipEntry (entryName));
                    zipOut.write (caPrivateKey.getEncoded ());
                    zipOut.closeEntry ();
                }
                CVCertificate cvCert = dl.getCVCertificate ();
                if (cvCert != null) {
                    String entryName = "cacert.cvcert";
                    zipOut.putNextEntry (new ZipEntry (entryName));
                    zipOut.write (cvCert.getDEREncoded ());
                    zipOut.closeEntry ();
                }
                zipOut.finish ();
                zipOut.close ();
                fileOut.flush ();
                fileOut.close ();
                break;
            } catch (IOException fnfe) {
                fnfe.printStackTrace ();
            }
        default :
            break;
    }
}


-----Function Pair=224=-----==

public void Delete (NpsContext ctxt) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from job where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


public void run () {
    Logger log = Logger.getLogger ("it.unisa.dia.jzks.gui");
    Integer rParameter = (Integer) jSpinnerRParameter.getValue ();
    Integer qParameter = (Integer) jSpinnerQParameter.getValue ();
    Integer q_aryTree = (Integer) jSpinnerQAryTree.getValue ();
    String hashType = (String) jComboBoxHashAlgoType.getSelectedItem ();
    log.info ("START");
    try {
        comm = new CommitmentMerkleTree (rParameter.intValue (), qParameter.intValue (), q_aryTree.intValue (), hashType);
        if (! comm.populateTreeLeaves (hashTableData)) jLabelErrorData.setText ("Error during create the Merkle tree");
        else {
            log.info (String.valueOf (comm.getTree ().size ()));
            comm.commit ();
            log.info ("stop");
            jButtonSave.setEnabled (true);
            jButtonViewTreeGenerate.setEnabled (true);
            jLabelGenerateStatus.setText ("Process finished.");
        }
    } catch (NoSuchAlgorithmException e) {
        jLabelErrorParameterCommitment.setText ("Hashing algorith not valid");
    } catch (InvalidQParameterException e) {
        jLabelErrorParameterCommitment.setText ("Q-ary parameter not valid");
    } catch (InvalidECParameterException e) {
        jLabelErrorParameterCommitment.setText ("EC parameter not valid");
    } catch (SecurityParameterNotSatisfied e) {
        jLabelErrorParameterCommitment.setText ("The depth of the tree does not satisfy the security parameter. Must be {lambda >= |Digest|}");
    } catch (ParameterValueMismatch e) {
        jLabelErrorParameterCommitment.setText ("The Digest legth mismath with q paramter. Must be {|Digest| mod (log2 q) = 0 }");
    }
}


-----Function Pair=225=-----==

public static String findContainingJar (Class my_class) {
    ClassLoader loader = my_class.getClassLoader ();
    String class_file = my_class.getName ().replaceAll ("\\.", "/") + ".class";
    try {
        for (Enumeration itr = loader.getResources (class_file); itr.hasMoreElements ();) {
            URL url = (URL) itr.nextElement ();
            if ("jar".equals (url.getProtocol ())) {
                String toReturn = url.getPath ();
                if (toReturn.startsWith ("file:")) {
                    toReturn = toReturn.substring ("file:".length ());
                }
                toReturn = URLDecoder.decode (toReturn, "UTF-8");
                return toReturn.replaceAll ("!.*$", "");
            }
            else if ("bundleresource".equals (url.getProtocol ())) {
                return PluginConfiguration.findContainingJar (my_class);
            }
        }
    } catch (IOException e) {
        throw new RuntimeException (e);
    }
    return null;
}


public FileIndex (File file) throws IOException {
    this.file = file;
    if (file.isFile () && ! file.getName ().endsWith (".zip")) {
        System.out.println ("Converting " + file + " to zip format");
        InputStream in;
        String newFile = file.getAbsolutePath ();
        if (file.getName ().endsWith ("tar.gz")) {
            in = new GZIPInputStream (new FileInputStream (file));
            newFile = newFile.substring (0, newFile.length () - ".tar.gz".length ()) + ".zip";
        }
        else if (file.getName ().endsWith (".tar")) {
            in = new FileInputStream (file);
            newFile = newFile.substring (0, newFile.length () - ".tar".length ()) + ".zip";
        }
        else {
            throw new IOException ("file is not in a compatible tar or tar.gz format");
        }
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (newFile));
        out.setMethod (ZipOutputStream.DEFLATED);
        out.setLevel (Deflater.BEST_COMPRESSION);
        TarInputStream tarStream = new TarInputStream (in);
        tarStream.setBufferDebug (false);
        tarStream.setDebug (false);
        TarEntryEnumerator tarEnum = new TarEntryEnumerator (tarStream);
        byte [] buf = new byte [512];
        while (tarEnum.hasMoreElements ()) {
            TarEntry entry = (TarEntry) tarEnum.nextElement ();
            if (! entry.getName ().endsWith (".gif") && ! entry.getName ().endsWith (".png") && ! entry.getName ().endsWith (".html")) {
                ZipEntry zipEntry = new ZipEntry (entry.getName ());
                int len;
                out.putNextEntry (zipEntry);
                while ((len = tarStream.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
            }
        }
        in.close ();
        out.flush ();
        out.close ();
        System.out.println ("Done Converting " + file + " to zip format new file is at " + newFile);
        this.file = new File (newFile);
    }
}


-----Function Pair=226=-----==

public static String [] splitPaths (String pathString, char pathSeparator, boolean winDriveLetters) {
    boolean checkDriveLetters = (pathSeparator == ':') && winDriveLetters;
    ArrayList < String > list = new ArrayList < String > ();
    int idx = 0;
    while ((idx = pathString.indexOf (pathSeparator, idx)) >= 0) {
        String path = pathString.substring (0, idx);
        if (checkDriveLetters && ((path.length () == 1) && (pathString.charAt (idx + 1) == File.separatorChar))) {
            ++ idx;
            continue;
        }
        list.add (path);
        pathString = pathString.substring (idx + 1);
        idx = 0;
    }
    list.add (pathString);
    return list.toArray (new String [list.size ()]);
}


public static String gz2String (InputStream fis) {
    StringBuffer output = new StringBuffer ();
    GZIPInputStream gzip_in_stream;
    try {
        BufferedInputStream source = new BufferedInputStream (fis);
        gzip_in_stream = new GZIPInputStream (source);
        BufferedReader reader = FileEncoding.getReader (gzip_in_stream);
        String gutti;
        while ((gutti = reader.readLine ()) != null) {
            output.append (gutti + System.getProperty ("line.separator"));
        }
    } catch (IOException ex) {
        System.out.println ("IO Exception while unzipping data!");
        ex.printStackTrace ();
    }
    return output.toString ();
}


-----Function Pair=227=-----==

static void addFile (String path, File f, ZipOutputStream zos) throws IOException {
    ZipEntry ze = new ZipEntry (path + f.getName ());
    ze.setSize (f.length ());
    ze.setTime (f.lastModified ());
    zos.putNextEntry (ze);
    FileInputStream fis = null;
    try {
        fis = new FileInputStream (f);
        byte buf [] = new byte [1024];
        int read;
        while ((read = fis.read (buf)) >= 0) {
            zos.write (buf, 0, read);
        }
    } finally {
        if (fis != null) fis.close ();
    }
    zos.flush ();
    zos.closeEntry ();
}


private void loadProject () {
    JFileChooser fc = new JFileChooser ();
    int returnVal = fc.showOpenDialog (this);
    String path = "c:\\";
    String fileName = "TestSave";
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        path = fc.getSelectedFile ().getParent () + "\\";
        fileName = fc.getSelectedFile ().getName ();
        fileName = fileName.substring (0, fileName.lastIndexOf ("."));
    }
    else {
        return;
    }
    try {
        int BUFFER = 2048;
        String inFileName = path + fileName + ".zip";
        String destinationDirectory = path;
        File sourceZipFile = new File (inFileName);
        File unzipDestinationDirectory = new File (destinationDirectory);
        ZipFile zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
        Enumeration zipFileEntries = zipFile.entries ();
        while (zipFileEntries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) zipFileEntries.nextElement ();
            String currentEntry = entry.getName ();
            File destFile = new File (unzipDestinationDirectory, currentEntry);
            File destinationParent = destFile.getParentFile ();
            destinationParent.mkdirs ();
            if (! entry.isDirectory ()) {
                BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (entry));
                int currentByte;
                byte data [] = new byte [BUFFER];
                FileOutputStream fos = new FileOutputStream (destFile);
                BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
                while ((currentByte = is.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, currentByte);
                }
                dest.flush ();
                dest.close ();
                is.close ();
            }
        }
        zipFile.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    try {
        File originalFile = new File (path + fileName + "-original.jpg");
        File mapFile = new File (path + fileName + "-Map.jpg");
        File markedFile = new File (path + fileName + "-Marked.jpg");
        colorizationPanel.setColorMap (ImageIO.read (mapFile));
        workingFrame.setImage (ImageIO.read (originalFile));
        colorizationPanel.colorizeNextFrame (workingFrame);
        originalFile.delete ();
        mapFile.delete ();
        markedFile.delete ();
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=228=-----==

protected Zipper (OutputStream out, List < FileEntry > fileEntrys, String encoding) {
    Assert.notEmpty (fileEntrys);
    long begin = System.currentTimeMillis ();
    log.debug ("ÂºÄÂßãÂà∂‰ΩúÂéãÁº©ÂåÖ");
    try {
        try {
            zipOut = new ZipOutputStream (out);
            if (! StringUtils.isBlank (encoding)) {
                log.debug ("using encoding: {}", encoding);
                zipOut.setEncoding (encoding);
            }
            else {
                log.debug ("using default encoding");
            }
            for (FileEntry fe : fileEntrys) {
                zip (fe.getFile (), fe.getFilter (), fe.getZipEntry (), fe.getPrefix ());
            }
        } finally {
            zipOut.close ();
        }
    } catch (IOException e) {
        throw new RuntimeException ("Âà∂‰ΩúÂéãÁº©ÂåÖÊó∂ÔºåÂá∫Áé∞IOÂºÇÂ∏∏ÔºÅ", e);
    }
    long end = System.currentTimeMillis ();
    log.info ("Âà∂‰ΩúÂéãÁº©ÂåÖÊàêÂäü„ÄÇËÄóÊó∂Ôºö{}ms„ÄÇ", end - begin);
}


public void readQuad () {
    try {
        scanZIPFile ();
        ZipEntry quadEntry = zipFile.getEntry ("quad.bin");
        BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (quadEntry));
        try {
            this.quad = (OTFServerQuad) new ObjectInputStream (is).readObject ();
        } catch (ClassNotFoundException e) {
            e.printStackTrace ();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=229=-----==

public UploadProcessBundleDialog () {
    super ("community.upload_process_bundle", false);
    onlyStructureButton.addChangeListener (new ChangeListener () {
        @Override
        public void stateChanged (ChangeEvent e) {
            boolean on = ! onlyStructureButton.isSelected ();
            excludeAttributes.setEnabled (on);
            excludeFiles.setEnabled (on);
        }
    }
    );
    ButtonGroup exportTypeGroup = new ButtonGroup ();
    exportTypeGroup.add (includeParametersButton);
    exportTypeGroup.add (onlyStructureButton);
    includeParametersButton.setSelected (true);
    excludeFiles.setSelected (false);
    excludeAttributes.setSelected (false);
    JPanel main = new JPanel ();
    main.setLayout (new GridBagLayout ());
    GridBagConstraints c = new GridBagConstraints ();
    c.fill = GridBagConstraints.BOTH;
    c.anchor = GridBagConstraints.FIRST_LINE_START;
    c.weighty = c.weightx = 1;
    c.insets = new Insets (4, 4, 4, 4);
    c.ipadx = c.ipady = 4;
    c.gridwidth = GridBagConstraints.REMAINDER;
    main.add (includeParametersButton, c);
    c.insets = new Insets (0, 24, 0, 0);
    main.add (excludeFiles, c);
    main.add (excludeAttributes, c);
    c.insets = new Insets (4, 4, 4, 4);
    main.add (onlyStructureButton, c);
    main.add (excludeDescription, c);
    main.add (new JScrollPane (repositoryTree), c);
    layoutDefault (main, DEFAULT_SIZE, makeOkButton ("community.upload_process_bundle_now"), makeCancelButton ());
}


private void addDirectoryToZip (ZipOutputStream out, File dir, String path) throws IOException {
    byte [] buf = new byte [1024];
    File [] children = dir.listFiles ();
    for (File f : children) {
        if (f.isDirectory ()) {
            out.putNextEntry (new ZipEntry (path + f.getName () + '/'));
            out.closeEntry ();
            addDirectoryToZip (out, f, path + f.getName () + '/');
        }
        else {
            FileInputStream in = new FileInputStream (f);
            out.putNextEntry (new ZipEntry (path + f.getName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
            f.deleteOnExit ();
        }
    }
}


-----Function Pair=230=-----==

public byte [] encode () {
    byte [] result = null;
    try {
        ByteArrayOutputStream bao = new ByteArrayOutputStream ();
        ZipOutputStream zipOut = new ZipOutputStream (bao);
        zipOut.putNextEntry (new ZipEntry ("root-Job"));
        zipOut.setLevel (9);
        ObjectOutputStream oos = new ObjectOutputStream (zipOut);
        oos.writeObject (this);
        oos.flush ();
        bao.flush ();
        oos.close ();
        result = bao.toByteArray ();
    } catch (IOException ex) {
        logger.log (Level.WARNING, "Encoding job " + this + " failed.", ex);
    }
    return result;
}


public void MoveTo (NpsContext ctxt, String src_topid, TopicTree dest, String dest_topid) throws NpsException {
    if (site.GetId ().equals (dest.GetSiteId ())) {
        MoveTo (ctxt, src_topid, dest_topid);
        return;
    }
    try {
        Node node_src = null;
        Node node_dest = null;
        Topic topic_dest = null;
        if (dest_topid != null && dest_topid.length () > 0) {
            topic_dest = dest.GetTopic (dest_topid);
            if (topic_dest == null) throw new NpsException ("√ªÔøΩÔøΩÔøΩ“µÔøΩƒøÔøΩÔøΩÔøΩÔøΩƒøÔøΩÔøΩœ¢ÔøΩÔøΩ", ErrorHelper.SYS_NOTOPIC);
            node_dest = dest.GetNodeByTopic (topic_dest);
        }
        if (src_topid == null || src_topid.length () == 0) {
            Iterator node_src_list = tree.GetChilds ();
            while (node_src_list.hasNext ()) {
                node_src = (Node) node_src_list.next ();
                MoveTo (ctxt, node_src, dest, node_dest);
            }
            node_src_list = tree.GetChilds ();
            while (node_src_list.hasNext ()) {
                node_src = (Node) node_src_list.next ();
                tree.RemoveNode (node_src);
            }
        }
        else {
            Topic topic_src = GetTopic (src_topid);
            if (topic_src == null) throw new NpsException ("√ªÔøΩÔøΩÔøΩ“µÔøΩ“™ÔøΩ∆∂ÔøΩÔøΩÔøΩÔøΩÔøΩƒøÔøΩÔøΩœ¢ÔøΩÔøΩ", ErrorHelper.SYS_NOTOPIC);
            node_src = GetNodeByTopic (topic_src);
            MoveTo (ctxt, node_src, dest, node_dest);
            tree.RemoveNode (node_src);
        }
    } catch (NpsException e) {
        com.microfly.util.DefaultLog.error_noexception (e);
        site.ReloadTopicTree (ctxt);
        dest.site.ReloadTopicTree (ctxt);
        throw e;
    }
}


-----Function Pair=231=-----==

public List < RepositoryAttachment > readAttachments (IMemento parent) {
    List < RepositoryAttachment > attachments = new ArrayList < RepositoryAttachment > ();
    for (IMemento attachmentMemento : parent.getChildren (ELEMENT_ATTACHMENT)) {
        RepositoryAttachment attachment = new RepositoryAttachment (temporaryFactory);
        String isPatch = attachmentMemento.getString (ATTRIBUTE_IS_PATCH);
        String isObsolete = attachmentMemento.getString (ATTRIBUTE_IS_OBSOLETE);
        String taskId = attachmentMemento.getString (ATTRIBUTE_ID);
        String creator = attachmentMemento.getString (ATTRIBUTE_CREATOR);
        String repositoryKind = attachmentMemento.getString (ATTRIBUTE_REPOSITORY_KIND);
        String repositoryUrl = attachmentMemento.getString (ATTRIBUTE_REPOSITORY_URL);
        if (isPatch != null) {
            attachment.setPatch (Boolean.parseBoolean (isPatch));
        }
        if (isObsolete != null) {
            attachment.setObsolete (Boolean.parseBoolean (isObsolete));
        }
        if (creator != null) {
            attachment.setCreator (creator);
        }
        if (repositoryKind != null) {
            attachment.setRepositoryKind (repositoryKind);
        }
        if (repositoryUrl != null) {
            attachment.setRepositoryUrl (repositoryUrl);
        }
        if (taskId != null) {
            attachment.setTaskId (taskId);
        }
        IMemento attributesMemento = attachmentMemento.getChild (ELEMENT_ATTRIBUTES);
        if (attributesMemento != null) {
            List < RepositoryTaskAttribute > attributes = readAttributes (attributesMemento);
            for (RepositoryTaskAttribute repositoryTaskAttribute : attributes) {
                attachment.addAttribute (repositoryTaskAttribute.getId (), repositoryTaskAttribute);
            }
        }
        attachments.add (attachment);
    }
    return attachments;
}


private String getSystemInfo (HTTPurl urlData) {
    StringBuffer content = new StringBuffer ();
    content.append ("<table class='systemtable'>");
    content.append ("<tr><td colspan='2' class='systemheading'>System Info</td></tr>");
    content.append ("<tr><td class='systemkey'>Current Time</td><td class='systemdata'>" + dtf.format (new Date ()) + "</td></tr>\n");
    Runtime r = Runtime.getRuntime ();
    long total = r.totalMemory ();
    long free = r.freeMemory ();
    long freePercentage = (long) (((double) free / (double) total) * 100);
    content.append ("<tr><td class='systemkey'>Memory</td><td class='systemdata'>" + freePercentage + "% Free</td></tr>\n");
    DllWrapper capEng = new DllWrapper ();
    NumberFormat nf = NumberFormat.getNumberInstance ();
    content.append ("<tr><td class='systemkey'>Capture Paths</td><td class='systemdata' nowrap>");
    String [] paths = store.getCapturePaths ();
    for (int x = 0; x < paths.length; x ++) {
        String fullPath = new File (paths [x]).getAbsolutePath ();
        long freeSpace = capEng.getFreeSpace (fullPath);
        content.append (fullPath);
        if (freeSpace == 0) {
            content.append (" (N/A)");
        }
        else {
            content.append (" (" + nf.format ((freeSpace / (1024 * 1024))) + " MB Free)");
        }
        if (x != paths.length - 1) content.append ("<br>");
    }
    content.append ("</td></tr>\n");
    content.append ("<tr><td class='systemkey'>Channels Loaded</td><td class='systemdata'>" + store.numberOfChannels ());
    content.append ("</td></tr>\n");
    File cap = new File (store.getProperty ("path.httproot"));
    String fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Httpd Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    cap = new File (store.getProperty ("path.data"));
    fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Data Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    content.append ("<tr><td class='systemkey'>HTTP Server Version</td><td class='systemdata'>" + store.getVersion () + "</td></tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    content.append ("<tr><td class='systemkey'>Number of Devices Selected</td><td class='systemdata'>" + devList.getDeviceCount () + "</td></tr>\n");
    content.append ("</table>");
    return content.toString ();
}


-----Function Pair=232=-----==

public static void removeEmptyParagraphs (Node root) {
    NodeList pNodes = ((Element) root).getElementsByTagName ("text:p");
    for (int i = 0; i < pNodes.getLength (); i ++) {
        Node node = pNodes.item (i);
        if (node.getTextContent ().trim ().equals ("")) {
            if (! node.hasChildNodes ()) {
                node.getParentNode ().removeChild (node);
                i --;
            }
            else {
                boolean empty = true;
                for (int j = 0; j < node.getChildNodes ().getLength (); j ++) {
                    if (node.getChildNodes ().item (j).getNodeType () == node.ELEMENT_NODE) {
                        empty = false;
                    }
                }
                if (empty) {
                    node.getParentNode ().removeChild (node);
                    i --;
                }
            }
        }
    }
}


public Foto uploadFoto (FotoFeed feed, byte [] value, String title) throws IOException {
    EntityManager em = emf.createEntityManager ();
    em.getTransaction ().begin ();
    Foto neu = new Foto ();
    neu.setFeed (feed);
    File manual = File.createTempFile ("XXXX", "YYYY");
    FileOutputStream out = new FileOutputStream (manual);
    out.write (value);
    out.close ();
    BufferedImage img = ImageIO.read (manual);
    int x = img.getWidth ();
    int y = img.getHeight ();
    double dy = 90F / y;
    int xneu = (int) (x * dy);
    BufferedImage tp = new BufferedImage (xneu, 90, BufferedImage.TYPE_INT_RGB);
    Graphics2D canvas = tp.createGraphics ();
    canvas.setRenderingHint (RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    AffineTransform tx = new AffineTransform ();
    tx.scale (dy, dy);
    AffineTransformOp op = new AffineTransformOp (tx, AffineTransformOp.TYPE_BICUBIC);
    img = op.filter (img, null);
    canvas.drawImage (new ImageIcon (img).getImage (), 0, 0, null);
    canvas.dispose ();
    ByteArrayOutputStream resultArray = new ByteArrayOutputStream ();
    ImageIO.write (tp, "jpeg", resultArray);
    File tmp = File.createTempFile ("yyy", "xxx");
    out = new FileOutputStream (tmp);
    out.write (resultArray.toByteArray ());
    out.close ();
    neu.setThumbManual (tmp);
    neu.setImgManual (value);
    neu.setTitle (title);
    neu.setDate (new Date ());
    neu.setSeen (true);
    neu.calcThumbMd5 ();
    neu.setImgUrl (neu.getMd5Thumb ());
    em.persist (neu);
    em.getTransaction ().commit ();
    manual.delete ();
    return neu;
}


-----Function Pair=233=-----==

public LocalCompilation writeSuccessor (HashSet < String > obsolete, Collection < ItemData > newItems, int version) throws IOException {
    File path = getPath ();
    path.mkdirs ();
    File tempFile = new File (path, TEMP_FILE);
    ZipOutputStream zipOut = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (tempFile), BUFFER));
    try {
        if (obsolete != null) {
            writeExistings (obsolete, zipOut);
        }
        for (ItemData item : newItems) {
            if (item.isExisting ()) {
                zipOut.putNextEntry (item.createZipEntry ());
                zipOut.write (item.getBytes ());
                zipOut.closeEntry ();
            }
        }
    } finally {
        zipOut.close ();
    }
    File next = new File (getPath (), PREFIX + version);
    if (next.exists ()) {
        next.delete ();
    }
    tempFile.renameTo (next);
    return new LocalCompilation (next, getCompilationType ());
}


private long readInputFn (ByteBuffer pbuf, long minlen) throws IOException {
    if (in == null) return 0;
    long maxlen = pbuf.capacity () - pbuf.position ();
    assert (minlen <= maxlen);
    long numread = 0;
    int steps = 0;
    while (numread < minlen) {
        steps ++;
        int readlen = _buf.length;
        if (readlen > (maxlen - numread)) readlen = (int) (maxlen - numread);
        int nr = in.read (_buf, 0, readlen);
        if (nr <= 0) break;
        numread += nr;
        assert (numread <= maxlen);
        pbuf.put (_buf, 0, nr);
    }
    if (_verbose > 1) Utils.log.fine ("readInputFn(" + minlen + "," + maxlen + ") => " + numread + " steps=" + steps);
    if (maxlen > 100) {
        _estByteLimit = _byteCount + maxlen;
    }
    else {
        _estByteLimit = (_byteCount + numread) * 20;
    }
    _byteCount += numread;
    updateProgress ();
    return numread;
}


-----Function Pair=234=-----==

protected void zipDir (File dir, ZipOutputStream zOut, String vPath) throws IOException {
    if (addedDirs.get (vPath) != null) {
        return;
    }
    addedDirs.put (vPath, vPath);
    ZipEntry ze = new ZipEntry (vPath);
    if (dir != null && dir.exists ()) {
        ze.setTime (dir.lastModified ());
    }
    else {
        ze.setTime (System.currentTimeMillis ());
    }
    ze.setSize (0);
    ze.setMethod (ZipEntry.STORED);
    ze.setCrc (EMPTY_CRC);
    zOut.putNextEntry (ze);
}


public Reader getFileAsReader (String path) throws IOException {
    File explodedFile = getExplodedFile (path);
    if ((! file.exists () && ! tmpFile.exists () && ! explodedFile.exists ()) || removedFileSet.contains (path)) throw new FileNotFoundException (path);
    if (explodedFile.exists ()) return FileUtil.getFileAsReader (explodedFile);
    ZipEntry entry = new ZipEntry (path);
    ZipFile zipFile = getZipFile ();
    InputStream in = null;
    try {
        in = new BufferedInputStream (zipFile.getInputStream (entry));
        if (in != null) {
            if (log.isDebugEnabled ()) {
                String type;
                type = FileUtil.getContentType (in);
                if (type == null) type = FileUtil.getContentType (explodedFile);
                log.debug ("FileUtil.getContentType() returned " + (type != null ? type : "(null)"));
            }
            return new InputStreamReader (in);
        }
    } catch (Exception ex) {
    }
    throw new FileNotFoundException (path);
}


-----Function Pair=235=-----==

private void addTaskData (IMemento parent, RepositoryTaskData newTaskData) {
    parent.putString (ATTRIBUTE_ID, getCleanText (newTaskData.getId ()));
    parent.putString (ATTRIBUTE_TASK_KIND, getCleanText (newTaskData.getTaskKind ()));
    parent.putString (ATTRIBUTE_REPOSITORY_URL, getCleanText (newTaskData.getRepositoryUrl ()));
    parent.putString (ATTRIBUTE_REPOSITORY_KIND, getCleanText (newTaskData.getRepositoryKind ()));
    IMemento attributes = parent.createChild (ELEMENT_ATTRIBUTES);
    addAttributes (attributes, newTaskData.getAttributes ());
    IMemento operations = parent.createChild (ELEMENT_OPERATIONS);
    addOperations (operations, newTaskData.getOperations ());
    if (newTaskData.getSelectedOperation () != null) {
        addSelectedOperation (operations, newTaskData.getSelectedOperation ());
    }
    IMemento comments = parent.createChild (ELEMENT_COMMENTS);
    addComments (comments, newTaskData.getComments ());
    IMemento attachments = parent.createChild (ELEMENT_ATTACHMENTS);
    addAttachments (attachments, newTaskData.getAttachments ());
}


public void importConfig (ScopePathTO path, File exported) throws AdminFacadeException {
    try {
        ZipFile zip = new ZipFile (exported);
        Enumeration < ? extends ZipEntry > entries = zip.entries ();
        ICfgServiceFacade facade = delegate.getCfgServiceFacade ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = entries.nextElement ();
            if (ALL_CONFIGURATION_FILENAME.equals (entry.getName ())) {
                StringBuilder builder = new StringBuilder ();
                BufferedReader reader = null;
                try {
                    reader = new BufferedReader (new InputStreamReader (zip.getInputStream (entry)));
                    String line = null;
                    while ((line = reader.readLine ()) != null) {
                        builder.append (line);
                        builder.append (System.getProperty ("line.separator"));
                    }
                    reader.close ();
                } finally {
                    if (reader != null) {
                        reader.close ();
                    }
                }
                String allConfigValue = builder.toString ();
                facade.setAllConfigurations (TREE_NAME, path, allConfigValue);
            }
        }
    } catch (AdminToolException e) {
        throwWrappedException ("Could not export configuration", e);
    } catch (IOException e) {
        throwWrappedException ("Could not export configuration", new AdminToolException (ErrorCodeEnum.FILE_LOAD, null, e));
    }
}


-----Function Pair=236=-----==

private void UpdateCode (NpsContext ctxt) throws Exception {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        String sql = "update EVENT_TRIGGER set code=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "select code from EVENT_TRIGGER where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            writer.write (code);
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


public static ZipOutputStream createZip (File zipFile, String manifestText) throws ImportExportException {
    if (zipFile.isDirectory ()) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.MUST_BE_FILE, "File passed to createZip can not be a directory. " + zipFile.getPath ());
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    }
    JarOutputStream zos = null;
    try {
        zos = new JarOutputStream (new FileOutputStream (zipFile), getManifest (manifestText));
    } catch (FileNotFoundException e) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.ZIP_FILE_NOT_FOUND, "Zip file not found " + zipFile.getPath ());
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    } catch (IOException e) {
        ImportExportException ieo = new ImportExportException (ImportExportFault.FAILED_TO_ADD_MANIFEST, "Failed to add manifest", e);
        logger.throwing (ZipUtils.class.getName (), "createZip", ieo);
        throw ieo;
    }
    return zos;
}


-----Function Pair=237=-----==

private Vector < String > getData (String str) {
    Vector < String > results = new Vector < String > ();
    String [] raw = str.split ("\t");
    String s = "";
    for (int i = 0; i < raw.length; i ++) {
        s = raw [i].trim ();
        if (i == 0) {
            s = raw [i].substring (0, 6);
            results.add (s);
            s = raw [i].substring (6, 14);
            results.add (s);
        }
        else {
            results.add (s);
        }
    }
    return results;
}


public void deleteRecursiveExcludePattern (File file, String [] excludePattern) throws IOException {
    if (file.exists ()) {
        if (file.isDirectory ()) {
            File [] files = file.listFiles ();
            for (int i = 0, l = files.length; i < l; ++ i) deleteRecursiveExcludePattern (files [i], excludePattern);
        }
        boolean delete = true;
        for (int x = 0; x < excludePattern.length; x ++) {
            if (Pattern.matches (excludePattern [x], file.getName ())) {
                delete = false;
                break;
            }
        }
        if (delete) file.delete ();
    }
}


-----Function Pair=238=-----==

public PC loadNewPC (PC pc) {
    PC oldPC = (PC) objects.removeObject (PC.class);
    if (oldPC != null) {
        notifyPCDisposed ();
    }
    JInternalFrame [] frames = desktop.getAllFrames ();
    for (int i = 0; i < frames.length; i ++) {
        frames [i].dispose ();
    }
    runMenu.refresh ();
    objects.removeObject (Processor.class);
    objects.removeObject (PhysicalAddressSpace.class);
    objects.removeObject (LinearAddressSpace.class);
    objects.removeObject (VGACard.class);
    objects.removeObject (Keyboard.class);
    objects.removeObject (ProcessorAccess.class);
    objects.removeObject (CodeBlockRecord.class);
    for (int i = 0; i < 10; i ++) {
        System.gc ();
        try {
            Thread.sleep (100);
        } catch (Exception e) {
        }
    }
    setTitle ("JPC Debugger - Boot Device: " + ((DriveSet) pc.getComponent (DriveSet.class)).getBootDevice ());
    objects.addObject (pc);
    objects.addObject (pc.getProcessor ());
    objects.addObject (pc.getComponent (LinearAddressSpace.class));
    objects.addObject (pc.getComponent (PhysicalAddressSpace.class));
    objects.addObject (pc.getComponent (VGACard.class));
    objects.addObject (pc.getComponent (Keyboard.class));
    ProcessorAccess pca = new ProcessorAccess (pc.getProcessor ());
    codeBlocks = new CodeBlockRecord (pc);
    objects.addObject (pca);
    objects.addObject (codeBlocks);
    runMenu.refresh ();
    notifyPCCreated ();
    monitor.doClick ();
    return pc;
}


public static void main (String [] args) throws Exception {
    String languagesList = (args.length > 0) ? args [0] : "en";
    String dirName = (args.length > 1) ? args [1].replace ('\\', '/') : "";
    if (dirName.length () > 0 && ! dirName.endsWith ("/")) {
        dirName += '/';
    }
    String [] languages = languagesList.split (",");
    for (int i = 0; i < languages.length; i ++) {
        String language = languages [i];
        String filename = dirName + language + "wiktionary-latest-pages-articles.xml";
        File file = new File (filename);
        BookGenerator generator = (BookGenerator) Class.forName (BookGenerator.class.getName () + "_" + language).newInstance ();
        generator.start (file);
        generator.save (language);
        generator.createPackage (language);
    }
}


-----Function Pair=239=-----==

public static void packeAlleDrinkObjekte (String zipfile) {
    File f = new File (".");
    try {
        String entries [] = f.list (new DrnFilenameFilter ());
        byte [] buf = new byte [BLOCKSIZE];
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipfile));
        for (int i = 0; i < entries.length; ++ i) {
            File ff = new File (entries [i]);
            System.out.println ("adding " + ff);
            FileReader in = new FileReader (ff);
            out.putNextEntry (new ZipEntry (entries [i]));
            int len;
            while ((len = in.read ()) > 0) {
                out.write (len);
            }
            in.close ();
            in = null;
            FileUtil.deleteFile (ff);
        }
        out.close ();
        out = null;
    } catch (IOException e) {
        System.err.println (e.toString ());
    }
}


protected void writeInstallerResources () throws IOException {
    sendMsg ("Copying " + installerResourceURLMap.size () + " files into installer");
    for (String s : installerResourceURLMap.keySet ()) {
        String name = s;
        InputStream in = (installerResourceURLMap.get (name)).openStream ();
        org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry (name);
        long dateTime = FileUtil.getFileDateTime (installerResourceURLMap.get (name));
        if (dateTime != - 1) {
            newEntry.setTime (dateTime);
        }
        primaryJarStream.putNextEntry (newEntry);
        copyStream (in, primaryJarStream);
        primaryJarStream.closeEntry ();
        in.close ();
    }
}


-----Function Pair=240=-----==

public SpritePacker (File file) {
    if (file.exists ()) sprites = readZip (file);
    else sprites = null;
    try {
        if (! file.exists ()) if (file.createNewFile ()) file = file.getAbsoluteFile ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    File newSprites = new File (NEW_DIR);
    String [] spriteList = newSprites.list ();
    Sprite created = null;
    if (sprites == null) sprites = new TreeMap < Integer, Sprite > ();
    int count = 0;
    final int total = spriteList.length;
    for (int i = 0; i < total; i ++) {
        if (! spriteList [i].endsWith (".spr")) continue;
        try {
            created = Sprite.deserializeFrom (new File (NEW_DIR + spriteList [i]));
        } catch (Exception e) {
            e.printStackTrace ();
            System.exit (1);
        }
        int id = Integer.parseInt (spriteList [i].replaceAll (".spr", ""));
        for (Sprite sprite : getSprites ()) {
            try {
                if (sprite == null) {
                    System.out.println ("***** ERROR: NULL SPRITE. PAK CORRUPT? *****");
                    continue;
                }
                if (id == sprite.getID ()) {
                    System.out.println ("Found clashing IDs: " + id + ". Removing old sprite.");
                    sprites.remove (sprite);
                }
            } catch (ClassCastException cce) {
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        sprites.put (id, created);
        int intProg = (int) (((double) ++ count / (double) total) * 100D);
        if (intProg <= 0) intProg = 1;
        String progress = String.valueOf (intProg);
        if (intProg < 10) progress = "0" + progress + "%";
        else progress = progress + "%";
        if (intProg == 100) progress = "99% - packing";
        System.out.println ("\n\n == Progress: " + progress + " ==\n\n");
    }
    System.out.println ("Pak'ing a total of " + sprites.size () + " sprites into " + file.getName () + ".");
    writeZip (sprites, file);
    System.out.println ("\n\n == Progress: 100% - finished ==\n\n");
}


private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=241=-----==

public void removeFoto (Foto foto) {
    EntityManager em = emf.createEntityManager ();
    em.getTransaction ().begin ();
    Foto toRemove = (Foto) em.createQuery ("from Foto p where id = ?").setParameter (1, foto.getId ()).getSingleResult ();
    if (toRemove == null) {
        return;
    }
    if (! toRemove.isManual ()) {
        IgnoredFotos ing = new IgnoredFotos ();
        ing.setImgUrl (toRemove.getImgUrl ());
        ing.setMd5 (toRemove.getMd5Thumb ());
        em.persist (ing);
    }
    em.remove (toRemove);
    em.getTransaction ().commit ();
}


public boolean marshallRelationshipPart (PackageRelationshipCollection rels, URI relPartURI, ZipOutputStream zos) {
    if (logger.isDebugEnabled ()) {
        logger.debug ("writing relation:" + relPartURI);
    }
    Document xmlOutDoc = DocumentFactory.getInstance ().createDocument ();
    Namespace dfNs = Namespace.get ("", PackageRelationship.RELATIONSHIPS_NAMESPACE);
    Element root = xmlOutDoc.addElement (new QName (PackageRelationship.RELATIONSHIPS_TAG_NAME, dfNs));
    for (PackageRelationship rel : rels) {
        Element relElem = root.addElement (PackageRelationship.RELATIONSHIP_TAG_NAME);
        relElem.addAttribute (PackageRelationship.ID_ATTRIBUTE_NAME, rel.getId ());
        relElem.addAttribute (PackageRelationship.TYPE_ATTRIBUTE_NAME, rel.getRelationshipType ());
        String targetValue;
        URI uri = rel.getTargetUri ();
        if (rel.getTargetMode () == TargetMode.EXTERNAL) {
            targetValue = uri.getScheme () + "://" + uri.getPath ();
            relElem.addAttribute (PackageRelationship.TARGET_MODE_ATTRIBUTE_NAME, "External");
        }
        else {
            targetValue = uri.getPath ();
        }
        relElem.addAttribute (PackageRelationship.TARGET_ATTRIBUTE_NAME, targetValue);
    }
    xmlOutDoc.normalize ();
    ZipEntry ctEntry = new ZipEntry (relPartURI.getPath ());
    try {
        zos.putNextEntry (ctEntry);
        if (! Package.saveAsXmlInZip (xmlOutDoc, relPartURI.getPath (), zos)) {
            return false;
        }
        zos.closeEntry ();
    } catch (IOException e1) {
        logger.error ("cannot create file " + relPartURI, e1);
        return false;
    }
    return true;
}


-----Function Pair=242=-----==

public String toStr (String str, int radix) {
    char [] baseStrs = new char [94];
    for (int i = 0; i < baseStrs.length; i ++) {
        baseStrs [i] = (char) (i + 33);
    }
    String tempStr = "";
    if (baseStrs.length >= radix && radix > 1) {
        while (! str.equals ("") && new BigInteger (str, 10).compareTo (new BigInteger ("" + radix, 10)) == 1) {
            BigInteger bint = new BigInteger (str, 10);
            int temp = bint.mod (new BigInteger ("" + radix, 10)).intValue ();
            tempStr = baseStrs [temp] + tempStr;
            str = (bint.subtract (new BigInteger ("" + temp, 10))).divide (new BigInteger ("" + radix, 10)).toString ();
        }
        return tempStr;
    }
    else {
        return "";
    }
}


public static int getCountUsingUnixCall (String command) throws IOException, InterruptedException {
    String [] args = new String [3];
    args [0] = "sh";
    args [1] = "-c";
    args [2] = command;
    Process process = null;
    try {
        process = Runtime.getRuntime ().exec (args);
        process.waitFor ();
        if (process.exitValue () != 0) {
            throw new RuntimeException ("The command (" + command + ") encountered the following error:" + getOutput (process.getErrorStream ()));
        }
        else {
            String output = getOutput (process.getInputStream ());
            if (output == null || output.length () == 0) {
                throw new RuntimeException ("The command (" + command + ") produced no output");
            }
            else {
                return Integer.parseInt (output);
            }
        }
    } finally {
        if (null != process) {
            closeStream (process.getOutputStream ());
            closeStream (process.getInputStream ());
            closeStream (process.getErrorStream ());
            process.destroy ();
        }
    }
}


-----Function Pair=243=-----==

private String convertReferencePath (String attributeValue, int contentPathLength, String filePathFromConvert) {
    int index = attributeValue.indexOf (ASSOCIATED_FILES_PREFIX);
    if (index == - 1) return attributeValue;
    int lengthPrefix = ASSOCIATED_FILES_PREFIX.length () + index;
    String filePathToConvert = null;
    String contentPathPrefix = attributeValue.substring (lengthPrefix, index + contentPathLength - 1);
    try {
        UUID.fromString (contentPathPrefix);
        filePathToConvert = attributeValue.substring (index + ASSOCIATED_FILES_PREFIX.length () + 37);
        if (filePathFromConvert != null) {
            filePathToConvert = convertPathRelativeToFile (filePathToConvert, filePathFromConvert);
        }
    } catch (IllegalArgumentException iae) {
        log.debug ("Malformed rootFolder UUID: " + iae);
        return null;
    }
    return filePathToConvert;
}


private void writeNode (Node parent, Node node, String nodeName) throws IOException {
    if (node instanceof Group) {
        Enumeration < ? > enumeration = ((Group) node).getAllChildren ();
        while (enumeration.hasMoreElements ()) {
            writeNode (parent, (Node) enumeration.nextElement (), nodeName);
        }
    }
    else if (node instanceof Shape3D) {
        Shape3D shape = (Shape3D) node;
        Appearance appearance = shape.getAppearance ();
        Transform3D transformationToParent = getTransformationToParent (parent, node);
        String objectName = "";
        if (accept (nodeName)) {
            objectName = nodeName + "_";
        }
        String shapeName = null;
        if (shape.getUserData () instanceof String) {
            shapeName = (String) shape.getUserData ();
        }
        if (accept (shapeName)) {
            objectName += shapeName + "_";
        }
        objectName += String.valueOf (this.vertexOffset);
        this.out.write ("g " + objectName + "\n");
        TexCoordGeneration texCoordGeneration = null;
        if (this.mtlFileName != null) {
            if (appearance != null) {
                texCoordGeneration = appearance.getTexCoordGeneration ();
                ComparableAppearance comparableAppearance = new ComparableAppearance (appearance);
                String appearanceName = this.appearances.get (comparableAppearance);
                if (appearanceName == null) {
                    appearanceName = objectName;
                    this.appearances.put (comparableAppearance, appearanceName);
                }
                this.out.write ("usemtl " + appearanceName + "\n");
            }
        }
        for (int i = 0, n = shape.numGeometries (); i < n; i ++) {
            writeNodeGeometry (shape.getGeometry (i), transformationToParent, texCoordGeneration);
        }
    }
}


-----Function Pair=244=-----==

private String convertPathRelativeToFile (String filePathToConvert, String filePathFromConvert) {
    String dirFileTo = "";
    String dirFileFrom = "";
    String convertedRelativePath = "";
    int lastSlashTo = filePathToConvert.lastIndexOf ("/");
    int lastSlashFrom = filePathFromConvert.lastIndexOf ("/");
    String fileTo = (lastSlashTo == - 1) ? filePathToConvert : filePathToConvert.substring (lastSlashTo + 1, filePathToConvert.length ());
    if (lastSlashTo == - 1) lastSlashTo = 0;
    if (lastSlashFrom == - 1) lastSlashFrom = 0;
    String pathTo = filePathToConvert.substring (0, lastSlashTo);
    String pathFrom = filePathFromConvert.substring (0, lastSlashFrom);
    StringTokenizer stokTo = new StringTokenizer (pathTo, "/");
    StringTokenizer stokFrom = new StringTokenizer (pathFrom, "/");
    int totalFromTokens = stokFrom.countTokens ();
    for (int fromTokenCounter = 0; fromTokenCounter < totalFromTokens; fromTokenCounter ++) {
        dirFileFrom = stokFrom.nextToken ();
        if ((! convertedRelativePath.contains ("../")) && (stokTo.hasMoreTokens ())) dirFileTo = stokTo.nextToken ();
        else dirFileTo = "";
        if (! dirFileFrom.equals (dirFileTo) || (convertedRelativePath.contains ("../"))) {
            convertedRelativePath = convertedRelativePath.concat ("../");
        }
        else dirFileTo = "";
    }
    if (! dirFileTo.equals ("")) convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    while (stokTo.hasMoreTokens ()) {
        dirFileTo = stokTo.nextToken ();
        convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    }
    convertedRelativePath = convertedRelativePath.concat (fileTo);
    return convertedRelativePath;
}


private static < PV > Map < String, FieldProperty > convert (Map < String, PV > fieldMap) throws ExcelException {
    Map < String, FieldProperty > filedMap = new LinkedHashMap < String, FieldProperty > ();
    Set < Entry < String, PV > > enterSet = (fieldMap).entrySet ();
    Iterator < Entry < String, PV > > entryIte = enterSet.iterator ();
    Entry < String, PV > entry = null;
    FieldProperty filed = null;
    while (entryIte.hasNext ()) {
        filed = new FieldProperty ();
        entry = entryIte.next ();
        if (entry.getValue () == null) {
            filedMap.put (entry.getKey (), filed);
        }
        else if (entry.getValue () instanceof String) {
            filed.setProperty ((String) entry.getValue ());
            filedMap.put (entry.getKey (), filed);
        }
        else if (entry.getValue () instanceof FieldProperty) {
            filedMap.put (entry.getKey (), (FieldProperty) entry.getValue ());
        }
        else {
            throw new ExcelException ("fieldMapÔøΩÔøΩvalue÷ªÔøΩÔøΩŒ™" + String.class.getName () + "ÔøΩÔøΩ" + FieldProperty.class.getName () + "ÔøΩÔøΩÔøΩÔøΩ");
        }
    }
    return filedMap;
}


-----Function Pair=245=-----==

public static synchronized void copyFile (File source, File destination) throws BlogunityException {
    try {
        InputStream in = new FileInputStream (source);
        OutputStream out = new FileOutputStream (destination);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
    } catch (Throwable t) {
        throw new BlogunityException (I18NStatusFactory.createUnknown (t));
    }
}


private Vector getLines (String fileName) throws IOException {
    Vector res = new Vector ();
    if (fileName.endsWith (RES_EXTENSION)) {
        DataInputStream in = new DataInputStream (new FileInputStream (fileName));
        String line = null;
        while ((line = in.readLine ()) != null) {
            for (;;) {
                line = line.trim ();
                if (line.endsWith ("\\")) {
                    String line2 = in.readLine ();
                    if (line2 != null) line = line.substring (0, line.length () - 1) + line2;
                    else break;
                }
                else break;
            }
            res.addElement (fromEscape (line));
        }
    }
    else {
        RandomAccessFile in = new RandomAccessFile (fileName, "r");
        StringBuffer sb = new StringBuffer ();
        int factor1 = 1;
        int factor2 = 256;
        for (;;) {
            int i = in.readUnsignedByte () * factor1 + in.readUnsignedByte () * factor2;
            if (i == 0xFFFE) {
                factor1 = 256;
                factor2 = 1;
            }
            if (i != 0x0D && i != 0xFFFE && i != 0xFEFF && i != 0xFFFF) if (i != 0x0A) sb.append ((char) i);
            else {
                res.addElement (fromEscape (sb.toString ()));
                sb.setLength (0);
            }
        }
    }
    return res;
}


-----Function Pair=246=-----==

public byte [] getArrayBytes (File file) {
    int size = (int) file.length ();
    if (size > Integer.MAX_VALUE) {
        System.out.println ("File is to larger");
    }
    byte [] bytes = new byte [size];
    DataInputStream dis = null;
    try {
        dis = new DataInputStream (new FileInputStream (file));
    } catch (FileNotFoundException e1) {
        e1.printStackTrace ();
    }
    int read = 0;
    int numRead = 0;
    try {
        while (read < bytes.length && (numRead = dis.read (bytes, read, bytes.length - read)) >= 0) {
            read = read + numRead;
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    System.out.println ("File size: " + read);
    if (read < bytes.length) {
        System.out.println ("Could not completely read: " + file.getName ());
    }
    return bytes;
}


public String getPendingWeedoutMaterialForApproval (String xmlStr) {
    Element eleroot = newGenXMLGenerator.getRootElementFromXMLDocument (xmlStr);
    Element retRootEle = new Element ("Response");
    String libId = eleroot.getChildTextTrim ("LibraryId");
    Connection con = DBConnector.getInstance ().getDBConnection ();
    String retStr = "";
    try {
        Statement stat = con.createStatement ();
        String sql = "select accession_number,approving_authority_id,approving_authority_lib_id,reason from cir_weedout_material where library_id=" + libId + " and status='A'";
        ResultSet rs = stat.executeQuery (sql);
        while (rs.next ()) {
            Element recordEle = new Element ("Record");
            String accessNo = rs.getString (1);
            Element elex = new Element ("AccessionNumber");
            elex.setText (accessNo);
            recordEle.addContent (elex);
            String appId = rs.getString (2);
            String appLibId = rs.getString (3);
            String reason = rs.getString (4);
            elex = new Element ("Reason");
            elex.setText (reason);
            recordEle.addContent (elex);
            Hashtable htBib = utility.getCatalogueRecord (accessNo, Integer.parseInt (libId));
            elex = new Element ("Title");
            elex.setText (utility.getTestedString (htBib.get ("Title")));
            recordEle.addContent (elex);
            elex = new Element ("Author");
            elex.setText (utility.getTestedString (htBib.get ("Author")));
            recordEle.addContent (elex);
            elex = new Element ("VolumeDetails");
            elex.setText (utility.getTestedString (htBib.get ("VolumeDetails")));
            recordEle.addContent (elex);
            Hashtable htPat = utility.getPatronDetails (appId, new Integer (appLibId));
            elex = new Element ("PatronName");
            elex.setText (utility.getTestedString (htPat.get ("PatronName")));
            recordEle.addContent (elex);
            elex = new Element ("PatronId");
            elex.setText (appId);
            recordEle.addContent (elex);
            retRootEle.addContent (recordEle);
        }
        rs.close ();
        stat.close ();
        con.close ();
        Document retdoc = new Document (retRootEle);
        retStr = (new XMLOutputter ()).outputString (retdoc);
    } catch (Exception exp) {
        exp.printStackTrace ();
    }
    return retStr;
}


-----Function Pair=247=-----==

public static HashMap < Integer, ArrayList < String > > getCompetitionCategories () throws NoConnectionToDBException, SQLException {
    HashMap < Integer, ArrayList < String > > res = new HashMap < Integer, ArrayList < String > > ();
    String query = "SELECT Solver_idSolver, CompetitionCategory.name as name FROM CompetitionCategory LEFT JOIN Solver_has_CompetitionCategory " + "ON idCompetitionCategory = CompetitionCategory_idCompetitionCategory";
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
    ResultSet rs = ps.executeQuery ();
    while (rs.next ()) {
        String name = rs.getString ("name");
        Integer id = new Integer (rs.getInt ("Solver_idSolver"));
        if (! res.containsKey (id)) {
            ArrayList < String > lst = new ArrayList < String > ();
            lst.add (name);
            res.put (id, lst);
        }
        else {
            res.get (id).add (name);
        }
    }
    return res;
}


public static String backup () throws IOException {
    File directory = new File (Platform.getLocation ().append (".").toOSString ());
    File [] files = directory.listFiles (new XMLFileNameFilter ());
    if (files.length > 0) {
        File zipFile = new File (directory, "backup-" + System.currentTimeMillis () + ".zip");
        FileOutputStream fileout = new FileOutputStream (zipFile);
        ZipOutputStream zipout = new ZipOutputStream (fileout);
        for (File file : files) {
            addFileToZip (zipout, file);
        }
        zipout.close ();
        return zipFile.getAbsolutePath ();
    }
    return null;
}


-----Function Pair=248=-----==

public String toRadix (String str, int radix) {
    char [] baseStrs = new char [94];
    for (int i = 0; i < baseStrs.length; i ++) {
        baseStrs [i] = (char) (i + 33);
    }
    String tempStr = "";
    String strtemp = str;
    BigInteger b_str = new BigInteger (strtemp, 10);
    BigInteger b_radix = new BigInteger ("" + radix, 10);
    BigInteger b_temp = new BigInteger ("0", 10);
    if (baseStrs.length >= radix && radix > 1) {
        while (! strtemp.equals ("") && ! strtemp.equals ("0") && b_str.compareTo (b_radix) == 1) {
            b_str = new BigInteger (strtemp, 10);
            int temp = b_str.mod (b_radix).intValue ();
            tempStr = baseStrs [temp] + tempStr;
            b_temp = new BigInteger ("" + temp, 10);
            strtemp = (b_str.subtract (b_temp)).divide (b_radix).toString ();
        }
        return tempStr;
    }
    else {
        return "";
    }
}


public void Add2Ftp (Article art, File page) {
    if (article_ftp_hosts == null || article_ftp_hosts.isEmpty ()) return;
    if (art == null) return;
    for (Object obj : article_ftp_hosts) {
        FtpHost ftphost = (FtpHost) obj;
        FtpQueue ftp_queue = new FtpQueue (ftphost);
        ftp_queue = FtpScheduler.GetScheduler ().Add (ftp_queue);
        File local_file = page;
        String str_art_publish_dir = art_publish_dir.getAbsolutePath ();
        str_art_publish_dir = Utils.FixPath (str_art_publish_dir);
        String remote_file = local_file.getAbsolutePath ();
        remote_file = Utils.FixPath (remote_file);
        remote_file = remote_file.replaceFirst (str_art_publish_dir, ftphost.remotedir);
        remote_file = Utils.FixPath (remote_file);
        try {
            ftp_queue.AddTask (local_file, remote_file);
        } catch (NpsException e) {
            nps.util.DefaultLog.error_noexception (e);
            continue;
        }
    }
}


-----Function Pair=249=-----==

private void xmlSchreibenStart (String datei) throws Exception {
    File file = new File (datei);
    System.out.println ("Datei schreiben: " + file.getAbsolutePath ());
    outFactory = XMLOutputFactory.newInstance ();
    if (datei.endsWith (Konstanten.FORMAT_BZ2)) {
        bZip2CompressorOutputStream = new BZip2CompressorOutputStream (new FileOutputStream (file), 2);
        out = new OutputStreamWriter (bZip2CompressorOutputStream, Konstanten.KODIERUNG_UTF);
    }
    else if (datei.endsWith (Konstanten.FORMAT_ZIP)) {
        zipOutputStream = new ZipOutputStream (new FileOutputStream (file));
        ZipEntry entry = new ZipEntry (Konstanten.XML_DATEI_FILME);
        zipOutputStream.putNextEntry (entry);
        out = new OutputStreamWriter (zipOutputStream, Konstanten.KODIERUNG_UTF);
    }
    else {
        out = new OutputStreamWriter (new FileOutputStream (file), Konstanten.KODIERUNG_UTF);
    }
    writer = outFactory.createXMLStreamWriter (out);
    writer.writeStartDocument ("UTF-8", "1.0");
    writer.writeCharacters ("\n");
    writer.writeStartElement (Konstanten.XML_START);
    writer.writeCharacters ("\n");
}


private LToolButton getCmdToolsSave () {
    if (cmdToolsSave == null) {
        cmdToolsSave = new LToolButton ();
        cmdToolsSave.setPreferredSize (new java.awt.Dimension (32, 32));
        cmdToolsSave.setMinimumSize (new java.awt.Dimension (32, 32));
        cmdToolsSave.setContentAreaFilled (false);
        cmdToolsSave.setCaptionTag ("cmdToolsSave");
        cmdToolsSave.setBorderPainted (false);
        cmdToolsSave.setPreferredImageSize (new java.awt.Dimension (32, 32));
        cmdToolsSave.setMaximumSize (new java.awt.Dimension (32, 32));
        cmdToolsSave.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent e) {
                onSave ();
            }
        }
        );
    }
    return cmdToolsSave;
}


-----Function Pair=250=-----==

private static String toEscape (String s) {
    StringBuffer res = new StringBuffer ();
    for (int i = 0; i < s.length (); i ++) {
        char ch = s.charAt (i);
        int val = (int) ch;
        if (ch == '\r') continue;
        if (val >= 0 && val < 128 && ch != '\n' && ch != '\\') res.append (ch);
        else {
            res.append ("\\u");
            String hex = Integer.toHexString (val);
            for (int j = 0; j < 4 - hex.length (); j ++) res.append ("0");
            res.append (hex);
        }
    }
    return res.toString ();
}


public static void save (File file, Workspace workspace) {
    if (file != null) {
        try {
            FileOutputStream ostream = new FileOutputStream (file);
            try {
                WorkspaceSerializer serializer = new WorkspaceSerializer (workspace);
                serializer.serialize (ostream);
                workspace.setWorkspaceChanged (false);
            } finally {
                ostream.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=251=-----==

private static List < String > getFilesToZip (String dir2zip) {
    List < String > fileList = new ArrayList < String > ();
    File zipDir = new File (dir2zip);
    String [] dirList = zipDir.list ();
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (zipDir, dirList [i]);
        if (f.isDirectory ()) {
            String filePath = f.getPath ();
            List < String > subDirFileList = getFilesToZip (filePath);
            fileList.addAll (subDirFileList);
            continue;
        }
        fileList.add (f.getPath ());
    }
    return fileList;
}


public boolean find (String _searchStr, int start, boolean ignoreCase) {
    try {
        String searchStr = _searchStr;
        if (searchStr == null || searchStr.equals ("")) return false;
        RE regexp = null;
        try {
            regexp = new RE (searchStr, (ignoreCase == true ? RE.REG_ICASE : 0) | RE.REG_MULTILINE, RESyntax.RE_SYNTAX_PERL5);
        } catch (Exception ex) {
        }
        if (regexp == null) {
            getToolkit ().beep ();
            return false;
        }
        String text = getText (start, getLength () - start);
        REMatch match = regexp.getMatch (text);
        if (match != null) {
            this.select (start + match.getStartIndex (), start + match.getEndIndex ());
            return true;
        }
    } catch (Exception ex) {
        FuLog.error (ex);
    }
    return false;
}


-----Function Pair=252=-----==

private void pngStech (Distribution dist) throws MalformedURLException, InterruptedException {
    int i;
    BufferedImage bi0 = new BufferedImage (256, 256, BufferedImage.TYPE_4BYTE_ABGR);
    BufferedImage bi;
    Graphics2D g = (Graphics2D) bi0.getGraphics ();
    Tile [] tset = tile.highLevels ();
    try {
        bi = ImageIO.read (dist.get (tset [0]));
        g.drawImage (bi, new AffineTransform (0.5, 0, 0, 0.5, 0, 0), null);
        bi = ImageIO.read (dist.get (tset [1]));
        g.drawImage (bi, new AffineTransform (0.5, 0, 0, 0.5, 0, 128), null);
        bi = ImageIO.read (dist.get (tset [2]));
        g.drawImage (bi, new AffineTransform (0.5, 0, 0, 0.5, 128, 0), null);
        bi = ImageIO.read (dist.get (tset [3]));
        g.drawImage (bi, new AffineTransform (0.5, 0, 0, 0.5, 128, 128), null);
        g.dispose ();
        logger.log (Level.INFO, "Steched. Optimizing..");
        BufferedImage bi8 = new NeuQuantImageOp ().filter (bi0, null);
        OutputStream original = dist.addByOutputStream (tile);
        ImageIO.write (bi8, "PNG", original);
        logger.log (Level.INFO, "...done!");
    } catch (FileNotFoundException ex) {
        logger.log (Level.SEVERE, null, ex);
    } catch (IOException ex) {
    }
}


public void addOneFile (File file) {
    try {
        if (file == null || ! file.exists () || file.isDirectory ()) {
            return;
        }
        filesAdded ++;
        String s = file.getCanonicalPath ().substring (baseDirLength + 1).replace (File.separatorChar, '/');
        ZipEntry zipentry = new ZipEntry (s);
        zipentry.setTime (file.lastModified ());
        try {
            out.putNextEntry (zipentry);
        } catch (Exception exception1) {
            System.out.println (exception1);
        }
        FileInputStream fileinputstream = new FileInputStream (file);
        do {
            int i = fileinputstream.read (buffer, 0, buffer.length);
            if (i <= 0) {
                break;
            }
            out.write (buffer, 0, i);
        }
        while (true);
        fileinputstream.close ();
    } catch (Exception exception) {
        System.out.println ("Error in adding " + file + ":" + exception);
    }
}


-----Function Pair=253=-----==

protected void exportUsers (Element parent, CmsOrganizationalUnit orgunit) throws CmsImportExportException, SAXException {
    try {
        I_CmsReport report = getReport ();
        List allUsers = OpenCms.getOrgUnitManager ().getUsers (getCms (), orgunit.getName (), false);
        for (int i = 0, l = allUsers.size (); i < l; i ++) {
            CmsUser user = (CmsUser) allUsers.get (i);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_SUCCESSION_2, String.valueOf (i + 1), String.valueOf (l)), I_CmsReport.FORMAT_NOTE);
            report.print (Messages.get ().container (Messages.RPT_EXPORT_USER_0), I_CmsReport.FORMAT_NOTE);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_ARGUMENT_1, user.getName ()));
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
            exportUser (parent, user);
            report.println (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_OK_0), I_CmsReport.FORMAT_OK);
        }
    } catch (CmsImportExportException e) {
        throw e;
    } catch (CmsException e) {
        if (LOG.isDebugEnabled ()) {
            LOG.debug (e.getLocalizedMessage (), e);
        }
        throw new CmsImportExportException (e.getMessageContainer (), e);
    }
}


public void test_getJarFile () throws MalformedURLException, IOException {
    URL url = null;
    url = createContent ("lf.jar", "missing");
    JarURLConnection connection = null;
    connection = (JarURLConnection) url.openConnection ();
    try {
        connection.connect ();
        fail ("Did not throw exception on connect");
    } catch (IOException e) {
    }
    try {
        connection.getJarFile ();
        fail ("Did not throw exception after connect");
    } catch (IOException e) {
    }
    URL invURL = createContent ("InvalidJar.jar", "Test.class");
    JarURLConnection juConn = (JarURLConnection) invURL.openConnection ();
    try {
        juConn.getJarFile ();
        fail ("IOException was not thrown.");
    } catch (java.io.IOException io) {
    }
    File resources = Support_Resources.createTempFolder ();
    Support_Resources.copyFile (resources, null, "hyts_att.jar");
    File file = new File (resources.toString () + "/hyts_att.jar");
    URL fUrl1 = new URL ("jar:file:" + file.getPath () + "!/");
    JarURLConnection con1 = (JarURLConnection) fUrl1.openConnection ();
    ZipFile jf1 = con1.getJarFile ();
    JarURLConnection con2 = (JarURLConnection) fUrl1.openConnection ();
    ZipFile jf2 = con2.getJarFile ();
    assertTrue ("file: JarFiles not the same", jf1 == jf2);
    jf1.close ();
    assertTrue ("File should exist", file.exists ());
    fUrl1 = createContent ("lf.jar", "");
    con1 = (JarURLConnection) fUrl1.openConnection ();
    jf1 = con1.getJarFile ();
    con2 = (JarURLConnection) fUrl1.openConnection ();
    jf2 = con2.getJarFile ();
    assertTrue ("http: JarFiles not the same", jf1 == jf2);
    jf1.close ();
}


-----Function Pair=254=-----==

protected void exportUsers (Element parent, CmsOrganizationalUnit orgunit) throws CmsImportExportException, SAXException {
    try {
        I_CmsReport report = getReport ();
        List allUsers = OpenCms.getOrgUnitManager ().getUsers (getCms (), orgunit.getName (), false);
        for (int i = 0, l = allUsers.size (); i < l; i ++) {
            CmsUser user = (CmsUser) allUsers.get (i);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_SUCCESSION_2, String.valueOf (i + 1), String.valueOf (l)), I_CmsReport.FORMAT_NOTE);
            report.print (Messages.get ().container (Messages.RPT_EXPORT_USER_0), I_CmsReport.FORMAT_NOTE);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_ARGUMENT_1, user.getName ()));
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
            exportUser (parent, user);
            report.println (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_OK_0), I_CmsReport.FORMAT_OK);
        }
    } catch (CmsImportExportException e) {
        throw e;
    } catch (CmsException e) {
        if (LOG.isDebugEnabled ()) {
            LOG.debug (e.getLocalizedMessage (), e);
        }
        throw new CmsImportExportException (e.getMessageContainer (), e);
    }
}


public void run () throws Exception {
    File absJar = createJar (new File ("abs.jar").getAbsoluteFile (), "j.A");
    File relJar = createJar (new File ("rel.jar"), "j.R");
    File absDir = createDir (new File ("abs.dir").getAbsoluteFile (), "d.A");
    File relDir = createDir (new File ("rel.dir"), "d.R");
    File absTestFile = writeFile (new File ("AbsTest.java").getAbsoluteFile (), "class AbsTest { class Inner { } }");
    File relTestFile = writeFile (new File ("RelTest.java"), "class RelTest { class Inner { } }");
    File relTest2File = writeFile (new File ("p/RelTest2.java"), "package p; class RelTest2 { class Inner { } }");
    File mainFile = writeFile (new File ("Main.java"), "class Main { j.A ja; j.R jr; d.A da; d.R dr; }" + "");
    String sourcePath = createPath (absJar, relJar, absDir, relDir);
    File outDir = new File ("classes");
    outDir.mkdirs ();
    String [] args = {"-sourcepath", sourcePath, "-d", outDir.getPath (), absTestFile.getPath (), relTestFile.getPath (), relTest2File.getPath (), mainFile.getPath ()};
    System.err.println ("compile: " + Arrays.asList (args));
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javac.Main.compile (args, pw);
    pw.close ();
    if (rc != 0) {
        System.err.println (sw.toString ());
        throw new Exception ("unexpected exit from javac: " + rc);
    }
    Set < File > expect = getFiles (outDir, "d/A.class", "d/A$Inner.class", "d/R.class", "d/R$Inner.class", "j/A.class", "j/A$Inner.class", "j/R.class", "j/R$Inner.class", "AbsTest.class", "AbsTest$Inner.class", "RelTest.class", "RelTest$Inner.class", "p/RelTest2.class", "p/RelTest2$Inner.class", "Main.class");
    Set < File > found = findFiles (outDir);
    if (! found.equals (expect)) {
        if (found.containsAll (expect)) throw new Exception ("unexpected files found: " + diff (found, expect));
        else if (expect.containsAll (found)) throw new Exception ("expected files not found: " + diff (expect, found));
    }
    for (File f : found) verifySourceFileAttribute (f);
    if (errors > 0) throw new Exception (errors + " errors occurred");
}


-----Function Pair=255=-----==

private String divRubrics (String xmlString) {
    try {
        xmlString = xmlString.replaceAll ("[\\s][\\s+]", " ");
        xmlString = xmlString.replaceAll ("\\>[\\s+]\\<", "\\>\\<");
        ByteArrayInputStream fileStream = new ByteArrayInputStream (xmlString.getBytes ());
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
        factory.setNamespaceAware (true);
        DocumentBuilder builder = factory.newDocumentBuilder ();
        Document doc = builder.parse (fileStream);
        XPathFactory xpfactory = XPathFactory.newInstance ();
        XPath xpath = xpfactory.newXPath ();
        NamespaceContext nc = new NamespaceContext () {
            @Override
            public String getNamespaceURI (String prefix) {
                return ("http://www.imsglobal.org/xsd/imsqti_v2p1");
            }@Override
            public String getPrefix (String namespaceURI) {
                return "qti";
            }@Override
            public Iterator getPrefixes (String namespaceURI) {
                return null;
            }
        }
        ;
        xpath.setNamespaceContext (nc);
        XPathExpression expr = xpath.compile ("//qti:rubricBlock");
        Object result = expr.evaluate (doc, XPathConstants.NODESET);
        NodeList nodes = (NodeList) result;
        for (int i = 0; i < nodes.getLength (); i ++) {
            Node bigNode = nodes.item (i);
            NodeList drilling = bigNode.getChildNodes ();
            for (int x = 0; x < drilling.getLength (); x ++) {
                if (drilling.item (x).getNodeType () == Node.TEXT_NODE) {
                    Node toKill = drilling.item (x);
                    Node parent = toKill.getParentNode ();
                    Node newNode = doc.createElement ("div");
                    newNode.setTextContent (toKill.getTextContent ());
                    parent.removeChild (toKill);
                    parent.appendChild (newNode);
                }
            }
        }
        return nodeToString (doc);
    } catch (Exception e) {
        e.printStackTrace ();
        return null;
    }
}


public static void MakeZip (final OutputStream outs, final String [] filenames) {
    final byte [] buf = new byte [2048];
    try {
        final ZipOutputStream out = new ZipOutputStream (outs);
        out.setLevel (ZipOutputStream.STORED);
        for (int i = 0; i < filenames.length; i ++) {
            File file = new File (filenames [i]);
            if (file.canRead ()) {
                final FileInputStream in = new FileInputStream (file);
                try {
                    out.putNextEntry (new ZipEntry (file.getName ()));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                } catch (ZipException z) {
                    System.err.println ("EXPORT ERROR (Continuing):" + z.toString ());
                }
                in.close ();
            }
            else {
                System.out.println ("Skipping file during zip:" + filenames [i]);
            }
        }
        out.close ();
    } catch (IOException e) {
        System.err.println ("EXPORT FATAL ERROR:" + e.toString ());
        System.err.println (e);
    }
}


-----Function Pair=256=-----==

public void writeRepositoriesToXML (Collection < TaskRepository > repositories, File file) {
    ZipOutputStream outputStream = null;
    try {
        if (! file.exists ()) file.createNewFile ();
        outputStream = new ZipOutputStream (new FileOutputStream (file));
        ZipEntry zipEntry = new ZipEntry (TaskRepositoryManager.OLD_REPOSITORIES_FILE);
        outputStream.putNextEntry (zipEntry);
        outputStream.setMethod (ZipOutputStream.DEFLATED);
        writer.setOutputStream (outputStream);
        writer.writeRepositoriesToStream (repositories);
        outputStream.flush ();
        outputStream.closeEntry ();
        outputStream.close ();
    } catch (IOException e) {
        StatusHandler.fail (e, "Could not write: " + file.getAbsolutePath (), false);
    } finally {
        if (outputStream != null) {
            try {
                outputStream.close ();
            } catch (IOException e) {
                StatusHandler.fail (e, "Unable to terminate output stream to repositories file.", false);
            }
        }
    }
}


public void loadCachePackage (InputStream input, CachePackageListener listener) {
    try {
        byte [] transferBuffer = new byte [BUFFER_SIZE];
        ZipInputStream zis = new ZipInputStream (input);
        ZipEntry currentEntry = null;
        while ((currentEntry = zis.getNextEntry ()) != null) {
            readCacheItemEntry (zis, currentEntry, transferBuffer, listener);
            zis.closeEntry ();
        }
        input.close ();
    } catch (IOException ex) {
        logger.log (Level.SEVERE, "Failed to load cache package due to IOException: {0}", ex.getMessage ());
    } catch (ClassNotFoundException ex) {
        logger.log (Level.SEVERE, "Problem with binary file: {0}", ex.getMessage ());
    }
}


-----Function Pair=257=-----==

private void Save (NpsContext ctxt) throws NpsException {
    java.sql.PreparedStatement pstmt = null;
    try {
        String sql = "insert into fcktemplate(id,title,description,scope,html,creator,createdate) values(?,?,?,?,?,?,?)";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.setString (2, title);
        pstmt.setString (3, desc);
        pstmt.setInt (4, scope);
        pstmt.setString (5, html);
        pstmt.setString (6, creator);
        pstmt.setTimestamp (7, new java.sql.Timestamp (createdate.getTime ()));
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=258=-----==

public static < T extends Comparable < T > > void BubbleSortComparable2 (T [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j].compareTo (num [j + 1]) > 0) {
                T temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


private void saveGamedat (String fname, String savename) throws IOException {
    int numsavefiles = game.isBG () ? bgnumsavefiles : sinumsavefiles;
    String savefiles [] = game.isBG () ? bgsavefiles : sisavefiles;
    OutputStream out = EUtil.U7create (fname);
    byte namebytes [] = savename.getBytes ();
    int namelen = Math.min (namebytes.length, saveNameSize);
    byte namebuf [] = new byte [saveNameSize];
    System.arraycopy (namebytes, 0, namebuf, 0, namelen);
    out.write (namebuf);
    ZipOutputStream zout = new ZipOutputStream (out);
    System.out.println ("Saving to " + fname);
    byte buf [] = null;
    for (int i = 0; i < numsavefiles; ++ i) {
        if (! saveOneZip (zout, savefiles [i], buf)) return;
    }
    int mapcnt = maps.size ();
    for (int j = 0; j < mapcnt; ++ j) {
        GameMap map = maps.elementAt (j);
        if (map != null) {
            for (int schunk = 0; schunk < 12 * 12; schunk ++) {
                String iname = map.getSchunkFileName (EFile.U7IREG, schunk);
                if (EUtil.U7exists (iname) != null) {
                    if (! saveOneZip (zout, iname, buf)) return;
                }
            }
        }
    }
    zout.close ();
}


-----Function Pair=259=-----==

protected void validateArtifactMap () throws InvalidFormatException {
    if (! (artifactMap.get (MANIFEST_ENTRY) instanceof Properties)) throw new InvalidFormatException ("Missing the " + MANIFEST_ENTRY + "!");
    String versionString = getManifestProperty (VERSION_PROPERTY);
    if (versionString != null) {
        Version version;
        try {
            version = Version.parse (versionString);
        } catch (NumberFormatException e) {
            throw new InvalidFormatException ("Unable to parse model version!, e");
        }
        if (Version.currentVersion ().getMajor () != version.getMajor () || Version.currentVersion ().getMinor () != version.getMinor ()) {
            throw new InvalidFormatException ("Model version " + version + " is not supported by this (" + Version.currentVersion () + ") version of OpenNLP!");
        }
    }
    else {
        throw new InvalidFormatException ("Missing " + VERSION_PROPERTY + " property in " + MANIFEST_ENTRY + "!");
    }
    if (getManifestProperty (COMPONENT_NAME_PROPERTY) == null) throw new InvalidFormatException ("Missing " + COMPONENT_NAME_PROPERTY + " property in " + MANIFEST_ENTRY + "!");
    if (! getManifestProperty (COMPONENT_NAME_PROPERTY).equals (componentName)) throw new InvalidFormatException ("The " + componentName + " cannot load a model for the " + getManifestProperty (COMPONENT_NAME_PROPERTY) + "!");
    if (getManifestProperty (LANGUAGE_PROPERTY) == null) throw new InvalidFormatException ("Missing " + LANGUAGE_PROPERTY + " property in " + MANIFEST_ENTRY + "!");
}


private void cacheDirectories (String path, Component comp) {
    ArchivePath archive = new ArchivePath (path);
    String archiveProtocol = archive.protocol;
    String archivePath = archive.pathName;
    VFS vfs = VFSManager.getVFSForPath (archivePath);
    Object session = null;
    try {
        session = vfs.createVFSSession (archivePath, comp);
        if (session == null) return;
        boolean ignoreErrors = true;
        InputStream in = vfs._createInputStream (session, archivePath, ignoreErrors, comp);
        InputStream archiveIn = this.openArchiveStream (in);
        Hashtable directories = getDirectories (archiveIn, archiveProtocol, archivePath);
        IOUtilities.closeQuietly (archiveIn);
        if (directories == null) {
            return;
        }
        for (Enumeration e = directories.keys (); e.hasMoreElements ();) {
            String name = (String) e.nextElement ();
            Hashtable h = (Hashtable) directories.get (name);
            VFSFile [] list = new VFSFile [h.size ()];
            int idx1 = 0;
            for (Enumeration e1 = h.elements (); e1.hasMoreElements ();) {
                list [idx1 ++] = (VFSFile) e1.nextElement ();
            }
            ArchiveDirectoryCache.setCachedDirectory (name, list);
        }
    } catch (IOException ioe) {
        Log.log (Log.ERROR, this, ioe);
        try {
            vfs._endVFSSession (session, comp);
        } catch (IOException e) {
        }
    }
}


-----Function Pair=260=-----==

public Archive save (OutputStream dest) throws IOException {
    ZipOutputStream out;
    InputStream in;
    List < Node > content;
    List < Node > files;
    out = new ZipOutputStream (dest);
    out.putNextEntry (new ZipEntry ("/"));
    out.closeEntry ();
    if (manifest != null) {
        out.putNextEntry (new ZipEntry (MANIFEST));
        manifest.write (out);
        out.closeEntry ();
    }
    content = data.find ("**/*");
    files = new ArrayList < Node > ();
    for (Node node : content) {
        if (isManifest (node)) {
            throw new ArchiveException ("manifest file not allowed");
        }
        else if (node.isFile ()) {
            files.add (node);
        }
        else {
            out.putNextEntry (new ZipEntry (node.getPath () + "/"));
            out.closeEntry ();
        }
    }
    for (Node file : files) {
        in = file.createInputStream ();
        out.putNextEntry (new ZipEntry (file.getPath ()));
        file.getWorld ().getBuffer ().copy (in, out);
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    return this;
}


public static void writeZipBytesToFile (byte [] bytes, String aFileName) {
    try {
        logger.debug ("unzipping file: " + aFileName);
        if (bytes == null) {
            logger.debug ("null bytes");
        }
        File f = new File (aFileName);
        FileOutputStream ostr = new FileOutputStream (f);
        BufferedOutputStream bstr = new BufferedOutputStream (ostr);
        bstr.write (bytes, 0, bytes.length);
        bstr.close ();
    } catch (Exception e) {
        logger.error ("Unable to write zipped file from byte stream:" + e);
    }
}


-----Function Pair=261=-----==

public void dumpPackage (String device, GEnterprisePackage pkg) throws IOException, ConfigurationException {
    String ddir = this.dumpDirectory + File.separator + device + File.separator;
    File dumpdir = new File (ddir);
    if (! dumpdir.exists ()) dumpdir.mkdirs ();
    File dfile = File.createTempFile ("pkg-", ".zip", dumpdir);
    FileOutputStream out = new FileOutputStream (dfile);
    ZipOutputStream zipout = new ZipOutputStream (out);
    ZipEntry ze = new ZipEntry ("pkg-" + (int) System.currentTimeMillis () + ".xml");
    zipout.putNextEntry (ze);
    zipout.setLevel (7);
    pkg.getPackageFactory ().writePackage (pkg, zipout);
    zipout.closeEntry ();
    zipout.close ();
    out.close ();
}


public String getVendors (String xmlStr) {
    Element root = newGenXMLGenerator.getRootElementFromXMLDocument (xmlStr);
    Integer libID = new Integer (root.getChildText ("LibraryID"));
    Object [] obLocal = new Object [0];
    try {
        obLocal = ((LocalADM_CO_VENDORHome) HomeFactory.getInstance ().getHome ("ADM_CO_VENDOR")).findAll (libID).toArray ();
    } catch (FinderException ex) {
    }
    Vector vector1 = new Vector (1, 1);
    Vector vector2 = new Vector (1, 1);
    for (int i = 0; i < obLocal.length; i ++) {
        vector1.addElement (((LocalADM_CO_VENDOR) obLocal [i]).getVendor_Id ());
        vector2.addElement (((LocalADM_CO_VENDOR) obLocal [i]).getName ());
    }
    return newGenXMLGenerator.buildXMLDocument ("Vendor", new String [] {"ID", "Name"}, new Vector [] {vector1, vector2});
}


-----Function Pair=262=-----==

private void convertStringLanguageValues (Document document, String workspace) {
    NodeList stringNodes = document.getElementsByTagName (IMSConstants.STRING);
    for (int i = 0; i < stringNodes.getLength (); i ++) {
        Element stringElement = (Element) stringNodes.item (i);
        String originalLangValue = stringElement.getAttribute (JCRUtil.XML_LANG_PROPERTY);
        if (! StringUtils.isEmpty (originalLangValue)) {
            stringElement.removeAttribute (JCRUtil.XML_LANG_PROPERTY);
            stringElement.setAttribute (JCRUtil.XML_LANG_PROPERTY, originalLangValue.replaceAll ("_", "-"));
        }
        org.w3c.dom.Node description = stringElement.getFirstChild ();
        Source fieldHTML = new Source (description.getNodeValue ());
        if ((fieldHTML.getAllStartTags (HTMLElementName.IMG).size () > 0) || (fieldHTML.getAllStartTags (HTMLElementName.A).size () > 0) || (fieldHTML.getAllStartTags (HTMLElementName.IFRAME).size () > 0)) {
            String fieldHTMLConverted = convertToLocalUrls (fieldHTML.toString (), null, "", IMSMANIFEST_FILE_NAME, workspace, null);
            description.setNodeValue (fieldHTMLConverted);
        }
    }
}


public static MBeanServer findMBeanServer (String domainName) {
    MBeanServer result = null;
    Iterator < MBeanServer > itr = MBeanServerFactory.findMBeanServer (null).iterator ();
    while (itr.hasNext () && result == null) {
        MBeanServer server = itr.next ();
        if ((domainName == null) || domainName.equals (server.getDefaultDomain ())) {
            result = server;
        }
    }
    if (result == null && "jboss".equalsIgnoreCase (domainName)) {
        try {
            Class clazz = Class.forName ("org.jboss.mx.util.MBeanServerLocator", true, PerfMon.getClassLoader ());
            Method m = clazz.getMethod ("locateJBoss", new Class [] {});
            result = (MBeanServer) m.invoke (null, new Object [] {});
            logger.logDebug ("Found JBoss MBean Server via org.jboss.mx.util.MBeanServerLocator.locateJBoss()");
        } catch (Exception e) {
            logger.logDebug ("Unable to Find JBoss MBean Server via org.jboss.mx.util.MBeanServerLocator.locateJBoss()", e);
        }
    }
    return result;
}


-----Function Pair=263=-----==

private synchronized void fetchGeometrySetConfigFromCache () {
    final File _cacheFile = new File (GaiaEnvironment.getCacheFileName (geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable ()) + ".gsetconfig");
    System.out.println ("Searching " + _cacheFile.getName ());
    if (! (_cacheFile.exists ())) {
        System.out.println (_cacheFile.getName () + " not found!");
    }
    else {
        System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " configuration");
        try {
            FileInputStream inFile = new FileInputStream (_cacheFile);
            ObjectInputStream inObject = new ObjectInputStream (inFile);
            Object cachedObject = inObject.readObject ();
            if (cachedObject instanceof GeometrySetConfig) {
                geometrySetConfig = (GeometrySetConfig) cachedObject;
                if (parent != null) {
                    parent.repaint ();
                }
            }
            haveConfig = true;
            needsReload = false;
        } catch (ClassNotFoundException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (InvalidClassException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (FileNotFoundException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (IOException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        }
        System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " configuration done...");
    }
}


ImportCommunityResult doImportCommunityResult (String parentNodePath, ZipInputStream zis) throws IOException {
    ZipEntry entry;
    String propertiesString = "";
    ByteArrayOutputStream xmlStream = new ByteArrayOutputStream ();
    while ((entry = zis.getNextEntry ()) != null) {
        if (entry.getName ().equals ("xmlData")) {
            int byteCount;
            byte [] data = new byte [512];
            while ((byteCount = zis.read (data, 0, 512)) != - 1) {
                xmlStream.write (data, 0, byteCount);
            }
            xmlStream.close ();
        }
        else if (entry.getName ().equals ("properties")) {
            ByteArrayOutputStream targetStream = new ByteArrayOutputStream ();
            int byteCount;
            byte [] data = new byte [512];
            while ((byteCount = zis.read (data, 0, 512)) != - 1) {
                targetStream.write (data, 0, byteCount);
            }
            targetStream.close ();
            propertiesString = new String (targetStream.toByteArray ());
        }
    }
    try {
        JCRUtil.currentSession ().importXML (parentNodePath, new ByteArrayInputStream (xmlStream.toByteArray ()), ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW);
        JCRUtil.currentSession ().save ();
    } catch (RepositoryException e) {
        throw new GroupwareRuntimeException ("Error importing xml", e.getCause ());
    }
    return ImportCommunityResult.noError;
}


-----Function Pair=264=-----==

public static void zipDir (String dir2zip, ZipOutputStream zos, String topLevelDirectory, String topLevelPrefix) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (filePath, zos, topLevelDirectory, topLevelPrefix);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String filePath = f.getPath ();
            logger.debug ("filepath: " + filePath);
            int length = topLevelDirectory.length () + 1;
            String shortFilePath = topLevelPrefix + "/" + filePath.substring (length);
            logger.debug (shortFilePath);
            ZipEntry anEntry = new ZipEntry (shortFilePath);
            logger.debug (f.getPath ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
        logger.error ("unable to zip up directory: " + e);
    }
}


public boolean compressObject () {
    boolean returns = false;
    try {
        FileOutputStream fos = new FileOutputStream (getFileName () + ".zippedObject");
        GZIPOutputStream gz = new GZIPOutputStream (fos);
        ObjectOutputStream oos = new ObjectOutputStream (gz);
        oos.writeObject (matrix);
        oos.flush ();
        oos.close ();
        fos.close ();
        returns = true;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return returns;
}


-----Function Pair=265=-----==

public static TimeLoopGroundOverlay toTimeLoopGroundOverlay (KMLDocument doc) {
    GroundOverlay [] govs = doc.groundOverlays;
    ScreenOverlayLayer legend = null;
    if (govs == null || govs.length == 0) return null;
    final String cachePath = "Earth/" + Messages.forCachePath (doc.name) + "/";
    TimeLoopGroundOverlay aov = new TimeLoopGroundOverlay (doc.name);
    aov.setDescription (doc.description);
    if (doc.screenOverlays != null) {
        final ScreenOverlay so = getLegend (doc.screenOverlays);
        legend = (so.icon != null) ? new ScreenOverlayLayer (so.name, so.icon, so.position) : new ScreenOverlayLayer (so.name, so.iconPath, so.position);
        if (so.sizeX != null && so.sizeY != null && so.sizeX.equals ("0") && so.sizeY.equals ("0")) legend.setResizeBehavior (ScreenOverlayLayer.RESIZE_KEEP_FIXED_SIZE);
        aov.setLegend (legend);
    }
    logger.debug ("Loop overlay " + doc.name + " " + govs.length + " frames " + " Legend=" + legend);
    for (GroundOverlay go : govs) {
        final Sector sector = new Sector (Angle.fromDegrees (go.bbox.south), Angle.fromDegrees (go.bbox.north), Angle.fromDegrees (go.bbox.west), Angle.fromDegrees (go.bbox.east));
        final GroundOverlayLayer overlay = new GroundOverlayLayer (go.name, sector, go.icon, ParserUtils.getIconSuffix (go.icon.toString ()));
        overlay.setBaseCachePath (cachePath);
        aov.add (overlay);
    }
    return aov;
}


SXCParser () {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    dbf.setValidating (true);
    dbf.setIgnoringComments (true);
    dbf.setIgnoringElementContentWhitespace (true);
    DocumentBuilder db = null;
    try {
        db = dbf.newDocumentBuilder ();
        Document doc = null;
        InputStream istr = new ZipFile ("essai1.sxc").getInputStream (new ZipEntry ("content.xml"));
        doc = db.parse (istr, "file:///home/raph/DOM/SXC/nulldtd/office.dtd");
        FileWriter f1 = new FileWriter ("save.xml");
        new org.apache.soap.util.xml.DOM2Writer ().serializeAsXML (doc, f1);
        f1.close ();
        ZipOutputStream zostr = new ZipOutputStream (new FileOutputStream ("essai2.sxc"));
        zostr.putNextEntry (new ZipEntry ("content.xml"));
        OutputStreamWriter osw = new OutputStreamWriter (zostr);
        new org.apache.soap.util.xml.DOM2Writer ().serializeAsXML (doc, osw);
        osw.close ();
        DisplayNotes (doc);
    } catch (ParserConfigurationException pce) {
        System.err.println (pce);
        System.exit (1);
    } catch (org.xml.sax.SAXException se) {
        System.err.println (se.getMessage ());
        System.exit (1);
    } catch (IOException ioe) {
        System.err.println (ioe);
        System.exit (1);
    }
}


-----Function Pair=266=-----==

public static void unzip (File zipFile, File destDir) throws IOException {
    BufferedOutputStream dest = null;
    FileInputStream fis = new FileInputStream (zipFile);
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        if (log.isDebugEnabled ()) {
            log.debug ("Extracting: " + entry);
        }
        int count;
        byte [] data = new byte [BUFFER_SIZE];
        FileOutputStream fos = new FileOutputStream (destDir.getAbsolutePath () + "/" + entry.getName ());
        dest = new BufferedOutputStream (fos, BUFFER_SIZE);
        while ((count = zis.read (data, 0, BUFFER_SIZE)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
    zis.close ();
}


public String computeChecksumSHA256 (File file) {
    try {
        FileChannel chan = null;
        try {
            chan = (new FileInputStream (file)).getChannel ();
        } catch (Throwable e) {
            logger.log (Level.SEVERE, "Exception thrown 1", e);
            return null;
        }
        MessageDigest sha256 = MessageDigest.getInstance ("SHA256", "BC");
        byte [] temp = new byte [4 * 1024];
        ByteBuffer _temp = ByteBuffer.wrap (temp);
        try {
            while (true) {
                int pos = _temp.position ();
                int read = chan.read (_temp);
                if (read == - 1) break;
                sha256.update (temp, pos, read);
                if (_temp.remaining () == 0) _temp.position (0);
            }
            chan.close ();
        } catch (Throwable e) {
            logger.log (Level.SEVERE, "Exception thrown 2", e);
        }
        byte [] poop = sha256.digest ();
        StringBuilder sb = new StringBuilder ();
        for (int i = 0; i < poop.length; i ++) {
            sb.append (Integer.toString ((poop [i] & 0xff) + 0x100, 16).substring (1));
        }
        return sb.toString ().toUpperCase ();
    } catch (NoSuchAlgorithmException ex) {
        logger.log (Level.SEVERE, "Algorithm SHA256 not supported.", ex);
    } catch (NoSuchProviderException ex) {
        logger.log (Level.SEVERE, "Provider BC not supported.", ex);
    }
    return null;
}


-----Function Pair=267=-----==

public static void arrayTest () {
    int [] arr = {1, 2, 5};
    Integer [] objArr = ArrayUtils.toObject (arr);
    System.out.println (StringUtils.join (objArr, ", "));
    String [] arr1 = {"a1", "a2"};
    String [] arr2 = {"b1", "b2", "b3"};
    String [] arr3 = (String []) ArrayUtils.addAll (arr2, arr1);
    System.out.println (JSONArray.fromObject (arr3));
    String [] strs = {"a", "b", "c"};
    System.out.println (String.format ("%s, %s, %s, %s", ArrayUtils.add (strs, 2, "can i?")));
    System.out.println (JSONArray.fromObject (strs));
    arr = null;
    System.out.println ("null is empty? " + ArrayUtils.isEmpty (arr));
    arr = new int [0];
    System.out.println ("0 size is empty? " + ArrayUtils.isEmpty (arr));
}


private String replaceTemplateVariables (String inString) {
    if (inString == null || inString.indexOf ('%') < 0 || templateVariables == null) {
        return inString;
    }
    StringBuffer sb = new StringBuffer (inString);
    int firstMarker = sb.indexOf ("%");
    while (firstMarker >= 0) {
        int secondMarker = sb.indexOf ("%", firstMarker + 1);
        if (secondMarker > firstMarker) {
            String templateVariable = sb.substring (firstMarker + 1, secondMarker);
            System.out.println ("Have template variable of \"" + templateVariable + "\"");
            String replacement = (String) templateVariables.get (templateVariable);
            if (replacement != null) {
                sb.replace (firstMarker, secondMarker + 1, replacement);
            }
            firstMarker = sb.indexOf ("%", firstMarker + 1);
        }
        else {
            break;
        }
    }
    return sb.toString ();
}


-----Function Pair=268=-----==

private static void f (int i, byte [] key, byte [] a, byte [] x) {
    byte [] e = new byte [64];
    byte [] ikey = new byte [64];
    byte [] y = new byte [64];
    System.arraycopy (a, 0, e, 0, e.length);
    transpose (e, EP, 48);
    for (int j = rots [i]; j > 0; j --) {
        rotate (key);
    }
    System.arraycopy (key, 0, ikey, 0, ikey.length);
    transpose (ikey, KeyTr2, 48);
    for (int j = 0; j < 48; j ++) {
        y [j] = (byte) (e [j] ^ ikey [j]);
    }
    for (int j = 0; j < 8; j ++) {
        int k = j + 1;
        int r = 32 * y [6 * k - 6] + 8 * y [6 * k - 5] + 4 * y [6 * k - 4] + 2 * y [6 * k - 3] + y [6 * k - 2] + 16 * y [6 * k - 1];
        int xb = s_boxes [j] [r];
        x [4 * k - 4] = (byte) ((xb>> 3) & 1);
        x [4 * k - 3] = (byte) ((xb>> 2) & 1);
        x [4 * k - 2] = (byte) ((xb>> 1) & 1);
        x [4 * k - 1] = (byte) (xb & 1);
    }
    transpose (x, ptr, 32);
}


public static String getIdade (String nascimento, String data) {
    if (Util.isNull (nascimento) || nascimento.length () != 10) {
        return "";
    }
    if (Util.isNull (data)) {
        data = Util.getData ();
    }
    int anos, meses, dias;
    String Sanos, Smeses, Sdias;
    int dia = Integer.parseInt (nascimento.substring (0, 2));
    int mes = Integer.parseInt (nascimento.substring (3, 5));
    int ano = Integer.parseInt (nascimento.substring (6));
    GregorianCalendar dataRef = toDate (data);
    int diahoje = dataRef.get (Calendar.DATE);
    int meshoje = dataRef.get (Calendar.MONTH) + 1;
    int anohoje = dataRef.get (Calendar.YEAR);
    anos = anohoje - ano;
    if (meshoje < mes) {
        anos --;
        meses = 12 - (mes - meshoje);
        if (diahoje < dia) {
            meses --;
            dias = (getDias (meshoje - 1, anohoje) - dia) + diahoje;
        }
        else {
            dias = diahoje - dia;
        }
    }
    else if (meshoje == mes) {
        if (diahoje < dia) {
            anos --;
            meses = 11;
            dias = getDias (meshoje - 1, anohoje) - dia + diahoje;
        }
        else {
            meses = 0;
            dias = diahoje - dia;
        }
    }
    else {
        meses = meshoje - mes;
        if (diahoje < dia) {
            meses --;
            dias = getDias (meshoje - 1, meshoje) - dia + diahoje;
        }
        else {
            dias = diahoje - dia;
        }
    }
    if (anos == 0) {
        Sanos = "";
    }
    else {
        Sanos = anos + "a ";
    }
    if (meses == 0) {
        Smeses = "";
    }
    else {
        Smeses = meses + "m ";
    }
    if (dias == 0) {
        Sdias = "";
    }
    else {
        Sdias = dias + "d ";
    }
    return (Sanos + Smeses + Sdias);
}


-----Function Pair=269=-----==

public static String upperEnglish (String source) {
    if (source == null) return "";
    source = source.trim ();
    byte [] chars = source.getBytes ();
    StringBuffer sb = new StringBuffer (chars.length);
    byte [] chinese = new byte [2];
    int count = 0;
    int line = 0;
    int i = 0;
    for (; i < chars.length; i ++) {
        if (chars [i] < 0) {
            chinese [0] = chars [i];
            chinese [1] = chars [i + 1];
            sb.append (new String (chinese));
            i ++;
        }
        else {
            String tmpstr = (char) chars [i] + "";
            tmpstr = tmpstr.toUpperCase ();
            sb.append (tmpstr);
        }
    }
    return sb.toString ();
}


public static final String [] getJavaStackClasses (int pMaxArraySize) {
    Exception x = new Exception ();
    StringWriter sw = new StringWriter ();
    x.printStackTrace (new PrintWriter (sw));
    StringTokenizer st = new StringTokenizer (sw.toString (), "\n");
    ArrayList al = new ArrayList ();
    st.nextToken ();
    st.nextToken ();
    st.nextToken ();
    int p1;
    String call;
    while (al.size () < pMaxArraySize && st.hasMoreTokens ()) {
        call = st.nextToken ().trim ();
        st.nextToken ();
        p1 = call.indexOf (' ') + 1;
        call = call.substring (p1, call.indexOf ('(', p1));
        p1 = call.lastIndexOf ('.');
        al.add (call.substring (0, p1));
    }
    return (String []) al.toArray (new String [0]);
}


-----Function Pair=270=-----==

void upload () {
    try {
        Thread upload = new Thread () {
            public void run () {
                try {
                    int id = getID () - 1;
                    String file = id + ".dem";
                    String data = URLEncoder.encode ("file", "UTF-8") + "=" + URLEncoder.encode (file, "UTF-8");
                    data += "&" + URLEncoder.encode ("hash", "UTF-8") + "=" + URLEncoder.encode (getMD5Digest ("tf2invite" + file), "UTF-8");
                    URL url = new URL ("http://94.23.189.99/ftp.php");
                    final URLConnection conn = url.openConnection ();
                    conn.setDoOutput (true);
                    OutputStreamWriter wr = new OutputStreamWriter (conn.getOutputStream ());
                    wr.write (data);
                    wr.flush ();
                    String line;
                    BufferedReader rd = new BufferedReader (new InputStreamReader (conn.getInputStream ()));
                    while ((line = rd.readLine ()) != null) {
                        System.out.println (line);
                        if (line.startsWith ("demo=")) msg ("2The last gather demo has been uploaded successfully: " + line.split ("=") [1]);
                    }
                    rd.close ();
                    wr.close ();
                } catch (IOException e) {
                    e.printStackTrace ();
                }
            }
        }
        ;
        upload.start ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


protected SockIO createSocket (String host) {
    SockIO socket = null;
    hostDeadLock.lock ();
    try {
        if (failover && failback && hostDead.containsKey (host) && hostDeadDur.containsKey (host)) {
            Date store = hostDead.get (host);
            long expire = hostDeadDur.get (host).longValue ();
            if ((store.getTime () + expire) > System.currentTimeMillis ()) {
                return null;
            }
        }
    } finally {
        hostDeadLock.unlock ();
    }
    try {
        socket = new SockIO (this, host, this.socketTO, this.socketConnectTO, this.nagle);
        if (! socket.isConnected ()) {
            log.error ("++++ failed to get SockIO obj for: " + host + " -- new socket is not connected");
            deadPool.put (socket, ZERO);
            socket = null;
        }
    } catch (Exception ex) {
        log.error ("++++ failed to get SockIO obj for: " + host);
        log.error (ex.getMessage (), ex);
        socket = null;
    }
    hostDeadLock.lock ();
    try {
        if (socket == null) {
            Date now = new Date ();
            hostDead.put (host, now);
            long expire = (hostDeadDur.containsKey (host)) ? (((Long) hostDeadDur.get (host)).longValue () * 2) : 1000;
            if (expire > MAX_RETRY_DELAY) {
                expire = MAX_RETRY_DELAY;
            }
            hostDeadDur.put (host, new Long (expire));
            if (log.isDebugEnabled ()) log.debug ("++++ ignoring dead host: " + host + " for " + expire + " ms");
            clearHostFromPool (availPool, host);
        }
        else {
            if (log.isDebugEnabled ()) log.debug ("++++ created socket (" + socket.toString () + ") for host: " + host);
            if (hostDead.containsKey (host) || hostDeadDur.containsKey (host)) {
                hostDead.remove (host);
                hostDeadDur.remove (host);
            }
        }
    } finally {
        hostDeadLock.unlock ();
    }
    return socket;
}


-----Function Pair=271=-----==

protected void closePool (Map < String, Map < SockIO, Long > > pool) {
    for (Iterator < String > i = pool.keySet ().iterator (); i.hasNext ();) {
        String host = i.next ();
        Map < SockIO, Long > sockets = pool.get (host);
        for (Iterator < SockIO > j = sockets.keySet ().iterator (); j.hasNext ();) {
            SockIO socket = j.next ();
            try {
                socket.trueClose ();
            } catch (IOException ioe) {
                log.error ("++++ failed to trueClose socket: " + socket.toString () + " for host: " + host);
            }
            j.remove ();
            socket = null;
        }
    }
}


public SockIO getConnection (String host) {
    if (! this.initialized) {
        log.error ("attempting to get SockIO from uninitialized pool!");
        return null;
    }
    if (host == null) {
        return null;
    }
    synchronized (this) {
        if (availPool != null && ! availPool.isEmpty ()) {
            Map < SockIO, Long > aSockets = availPool.get (host);
            if (aSockets != null && ! aSockets.isEmpty ()) {
                for (Iterator < SockIO > i = aSockets.keySet ().iterator (); i.hasNext ();) {
                    SockIO socket = i.next ();
                    if (socket.isConnected ()) {
                        if (log.isDebugEnabled ()) log.debug ("++++ moving socket for host (" + host + ") to busy pool ... socket: " + socket);
                        i.remove ();
                        addSocketToPool (busyPool, host, socket);
                        return socket;
                    }
                    else {
                        deadPool.put (socket, ZERO);
                        i.remove ();
                    }
                }
            }
        }
    }
    SockIO socket = createSocket (host);
    if (socket != null) {
        synchronized (this) {
            addSocketToPool (busyPool, host, socket);
        }
    }
    return socket;
}


-----Function Pair=272=-----==

public OptionalFile (String descOption) {
    optBox = new JCheckBox (descOption);
    optBox.addActionListener (this);
    filepath = new JTextField (20);
    filepath.setEditable (false);
    butFile = new JButton ("...");
    butFile.setEnabled (false);
    butFile.addActionListener (this);
    Box layout = Box.createHorizontalBox ();
    layout.add (optBox);
    layout.add (Box.createHorizontalStrut (15));
    layout.add (filepath);
    layout.add (Box.createHorizontalStrut (15));
    layout.add (butFile);
    add (layout);
    isOpenFileDialog = false;
}


static File saveHashResult (String baseDir, Document doc, StringWriter sw) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidAlgorithmParameterException, InvalidKeyException {
    File outputFile = null;
    outputFile = new File (baseDir + File.separator + AppDigest.DIGEST_FILENAME);
    sw.append ("<hr>Saving hashresult to: " + outputFile.getAbsolutePath () + "<br>");
    if (outputFile.exists ()) {
        outputFile.delete ();
    }
    outputFile.createNewFile ();
    KeySpec keySpec = new PBEKeySpec (AppDigest.ENCRYPTION_KEY.toCharArray (), AppDigest.ENCRYPTION_SALT, AppDigest.ENCRYPTION_COUNT);
    SecretKey key = SecretKeyFactory.getInstance ("PBEWithMD5AndDES").generateSecret (keySpec);
    Cipher cipher = Cipher.getInstance (key.getAlgorithm ());
    AlgorithmParameterSpec paramSpec = new PBEParameterSpec (AppDigest.ENCRYPTION_SALT, AppDigest.ENCRYPTION_COUNT);
    cipher.init (Cipher.ENCRYPT_MODE, key, paramSpec);
    BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (outputFile));
    CipherOutputStream cos = new CipherOutputStream (bos, cipher);
    ObjectOutputStream oos = new ObjectOutputStream (cos);
    oos.writeObject (doc);
    oos.flush ();
    oos.close ();
    sw.append ("Hashresult successfully saved<br>");
    return outputFile;
}


-----Function Pair=273=-----==

public static BufferedImage drawPie (Rectangle area, PieValue [] slices, double [] valores) {
    BufferedImage bufferedImage = new BufferedImage (area.width, area.height, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2d = bufferedImage.createGraphics ();
    double total = 0.0D;
    double curValue = 0.0D;
    int startAngle = 0;
    double val_total = 0;
    for (int i = 0; i < slices.length; i ++) {
        total += slices [i].getValue ();
        val_total += valores [i];
    }
    g2d.setColor (Color.white);
    g2d.fillRect (area.x, area.y, area.width, area.height);
    int Angulo = 0;
    double AnguloReal = 0;
    for (int i = 0; i < slices.length; i ++) {
        startAngle = (int) (curValue * 360 / total);
        int arcAngle = (int) (slices [i].getValue () * 360 / total);
        if (i == slices.length - 1) {
            arcAngle = 360 - startAngle;
        }
        curValue += slices [i].getValue ();
        if (arcAngle != 0) {
            g2d.setColor (slices [i].getColor ());
            g2d.fillArc (area.x, area.y, area.width, area.height, startAngle, arcAngle);
            int style = Font.ROMAN_BASELINE;
            int size = 10;
            Font font = new Font ("Serif", style, size);
            g2d.setFont (font);
            g2d.setColor (Color.black);
            AnguloReal = arcAngle / 2 + Angulo;
            Angulo += arcAngle;
            double yy = area.width / 4 * Math.sin (Math.toRadians (AnguloReal));
            double xx = area.width / 4 * Math.cos (Math.toRadians (AnguloReal));
            g2d.drawString (DobleDec (String.valueOf (valores [i] * 100 / val_total)) + " %", area.width / 2 + Math.round (xx) - 20, area.height / 2 - Math.round (yy));
        }
    }
    g2d.dispose ();
    return bufferedImage;
}


public static String convertPressureState (String state) {
    int st = 0;
    try {
        Integer.parseInt (state);
    } catch (NumberFormatException ex) {
    }
    String ret = "";
    switch (st) {
        case 0 :
            ret = "‚Üí";
            break;
        case 1 :
            ret = "‚Üë";
            break;
        case 2 :
            ret = "‚Üì";
            break;
        default :
            ret = "‚Üí";
    }
    return ret;
}


-----Function Pair=274=-----==

public ActionForward createTournamentChangesLine (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    System.out.println ("IN THE CREATE: ");
    DynaValidatorForm objForm = (DynaValidatorForm) form;
    TournamentVO objFormVO = (TournamentVO) objForm.get ("objTournament");
    TournamentChangesVO objFormLineVO = (TournamentChangesVO) objForm.get ("objTournamentChanges");
    List tcList = (List) request.getSession ().getAttribute ("tournament_changes");
    if (tcList == null) {
        System.out.println ("NULL MILA");
        tcList = new ArrayList ();
    }
    tcList.add (objFormLineVO);
    objForm.set ("objTournament", objFormVO);
    objForm.set ("objTournamentChanges", new TournamentChangesVO ());
    request.getSession ().setAttribute ("tournament_changes", tcList);
    return mapping.findForward ("success");
}


public static String getDate (String date) throws Exception {
    String dateBefore = null;
    SimpleDateFormat sdf = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss");
    sdf.setTimeZone (TimeZone.getTimeZone ("GMT+8"));
    long l1 = sdf.parse (date).getTime ();
    long l2 = System.currentTimeMillis ();
    long l3 = (l2 - l1) / (1000 * 60);
    String currentDate = sdf.format (new Date (l2));
    if (l3 <= 0) {
        dateBefore = "1ÂàÜÈíüÂâç";
    }
    else if (l3 > 0 && l3 < 60) {
        dateBefore = l3 + "ÂàÜÈíüÂâç";
    }
    else if (l3 >= 60 && l3 < (60 * 24)) {
        l3 = l3 / 60;
        dateBefore = l3 + "Â∞èÊó∂Ââç";
    }
    else if (l3 >= (60 * 24) && l3 < (60 * 24 * 3)) {
        int ii = new Integer (currentDate.substring (8, 10)) - new Integer (date.substring (8, 10));
        if (ii == 1) {
            dateBefore = "Êò®Â§©";
        }
        else if (ii == 2) {
            dateBefore = "ÂâçÂ§©";
        }
        else {
            dateBefore = date.substring (0, 10);
        }
    }
    else {
        dateBefore = date.substring (0, 10);
    }
    return dateBefore;
}


-----Function Pair=275=-----==

private void transform (OPT_RegisterOperand rop) {
    OPT_Instruction inst = rop.instruction;
    switch (inst.getOpcode ()) {
        case CALL_opcode :
            OPT_RegisterOperand invokee = Call.getParam (inst, 0).asRegister ();
            if (invokee == rop) {
                OPT_MethodOperand mop = Call.getMethod (inst);
                if (mop.method.isSynchronized ()) {
                    mop.spMethod = context.findOrCreateSpecializedVersion (mop.method);
                    if (DEBUG) VM.sysWrite ("Identified call " + inst + " for unsynchronization\n");
                }
            }
            break;
        case MONITORENTER_opcode :
            if (DEBUG) {
                VM.sysWrite ("Removing " + inst);
            }
            if ((! options.NO_CACHE_FLUSH)) {
                inst.insertBefore (Empty.create (ISYNC));
            }
            OPT_DefUse.removeInstructionAndUpdateDU (inst);
            break;
        case MONITOREXIT_opcode :
            if (DEBUG) {
                VM.sysWrite ("Removing " + inst);
            }
            if ((! options.NO_CACHE_FLUSH)) {
                inst.insertAfter (Empty.create (SYNC));
            }
            OPT_DefUse.removeInstructionAndUpdateDU (inst);
            break;
        default :
            break;
    }
}


static Object [] packageParameterFromJValue (VM_Method targetMethod, int argAddress) {
    VM_Type [] argTypes = targetMethod.getParameterTypes ();
    int argCount = argTypes.length;
    Object [] argObjectArray = new Object [argCount];
    VM_JNIEnvironment env = VM_Thread.getCurrentThread ().getJNIEnv ();
    for (int i = 0, addr = argAddress; i < argCount; i ++, addr += 8) {
        int loword, hiword;
        loword = VM_Magic.getMemoryWord (addr);
        if (argTypes [i].isFloatType ()) {
            argObjectArray [i] = VM_Reflection.wrapFloat (Float.intBitsToFloat (loword));
        }
        else if (argTypes [i].isDoubleType ()) {
            hiword = VM_Magic.getMemoryWord (addr + 4);
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapDouble (Double.longBitsToDouble (doubleBits));
        }
        else if (argTypes [i].isLongType ()) {
            hiword = VM_Magic.getMemoryWord (addr + 4);
            long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapLong (longValue);
        }
        else if (argTypes [i].isBooleanType ()) {
            argObjectArray [i] = VM_Reflection.wrapBoolean (loword & 0x000000FF);
        }
        else if (argTypes [i].isByteType ()) {
            argObjectArray [i] = VM_Reflection.wrapByte ((byte) (loword & 0x000000FF));
        }
        else if (argTypes [i].isCharType ()) {
            argObjectArray [i] = VM_Reflection.wrapChar ((char) (loword & 0x0000FFFF));
        }
        else if (argTypes [i].isShortType ()) {
            argObjectArray [i] = VM_Reflection.wrapShort ((short) (loword & 0x0000FFFF));
        }
        else if (argTypes [i].isReferenceType ()) {
            argObjectArray [i] = env.getJNIRef (loword);
        }
        else if (argTypes [i].isIntType ()) {
            argObjectArray [i] = VM_Reflection.wrapInt (loword);
        }
        else {
            return null;
        }
    }
    return argObjectArray;
}


-----Function Pair=276=-----==

public static void main (String args []) {
    int N = Integer.parseInt (args [0]);
    System.out.println ("Running " + N + " times");
    String klass = args [1];
    String methodName = args [2];
    System.out.println ("Method: " + klass + "." + methodName);
    int appArgsLength = Math.max (args.length - 3, 0);
    String [] appArgs = new String [appArgsLength];
    System.arraycopy (args, 3, appArgs, 0, appArgs.length);
    Object [] argv = new Object [1];
    argv [0] = appArgs;
    try {
        Class invokee = Class.forName (klass);
        Method [] methods = invokee.getMethods ();
        Method m = null;
        for (int i = 0; i < methods.length; i ++) {
            if (methods [i].getName ().equals (methodName)) {
                m = methods [i];
                break;
            }
        }
        for (int i = 0; i < N; i ++) {
            System.out.println ("Run " + i + " ... ");
            VM_Callbacks.notifyAppRunStart ("Driver", i);
            long elapsedTime = - System.currentTimeMillis ();
            m.invoke (null, argv);
            elapsedTime += System.currentTimeMillis ();
            System.out.println ("ELAPSED TIME " + elapsedTime + " ms");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


-----Function Pair=277=-----==

public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (section, r);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (section, r2);
            }
            return removed;
        }
    }
    return removed;
}


private void showURLWithMethod (String url, String clazz, String method) {
    Class c = null;
    Object obj = null;
    try {
        c = Class.forName (clazz);
    } catch (Throwable e) {
        GUIUtilities.error (null, "infoviewer.error.classnotfound", new Object [] {clazz});
        return;
    }
    if (method == null || (method != null && method.length () == 0)) {
        Constructor constr = null;
        try {
            constr = c.getConstructor (new Class [] {URL.class});
            if (constr != null) obj = constr.newInstance (new Object [] {new URL (url)});
        } catch (Exception ex) {
            Log.log (Log.DEBUG, this, ex);
        }
        if (obj == null) {
            try {
                constr = c.getConstructor (new Class [] {String.class});
                if (constr != null) obj = constr.newInstance (new Object [] {url});
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (obj == null) {
            try {
                constr = c.getConstructor (new Class [0]);
                if (constr != null) obj = constr.newInstance (new Object [0]);
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (obj == null) {
            GUIUtilities.error (null, "infoviewer.error.classnotfound", new Object [] {clazz});
            return;
        }
    }
    else {
        Method meth = null;
        boolean ok = false;
        try {
            meth = c.getDeclaredMethod (method, new Class [] {URL.class});
            if (meth != null) {
                obj = meth.invoke (null, new Object [] {new URL (url)});
                ok = true;
            }
        } catch (Exception ex) {
            Log.log (Log.DEBUG, this, ex);
        }
        if (! ok) {
            try {
                meth = c.getDeclaredMethod (method, new Class [] {String.class});
                if (meth != null) {
                    obj = meth.invoke (null, new Object [] {url});
                    ok = true;
                }
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (! ok) {
            try {
                meth = c.getDeclaredMethod (method, new Class [0]);
                if (meth != null) {
                    obj = meth.invoke (null, new Object [0]);
                    ok = true;
                }
            } catch (Exception ex) {
                Log.log (Log.DEBUG, this, ex);
            }
        }
        if (! ok) {
            GUIUtilities.error (null, "infoviewer.error.methodnotfound", new Object [] {clazz, method});
            return;
        }
    }
    if (obj != null) {
        if (obj instanceof Window) {
            ((Window) obj).show ();
        }
        else if (obj instanceof JComponent) {
            JFrame f = new JFrame ("Infoviewer JWrapper");
            f.getContentPane ().add ((JComponent) obj);
            f.pack ();
            f.setVisible (true);
        }
        else if (obj instanceof Component) {
            Frame f = new Frame ("Infoviewer Wrapper");
            f.add ((Component) obj);
            f.pack ();
            f.setVisible (true);
        }
    }
}


-----Function Pair=278=-----==

public String invokeStringGetter (Class cls, String methodname) {
    try {
        Method mid = cls.getMethod (methodname, null);
        String id = (String) mid.invoke (null, null);
        return id;
    } catch (NoSuchMethodException e) {
        return null;
    } catch (InvocationTargetException e) {
        reportException (cls, e.getCause ());
        return null;
    } catch (Exception e) {
        reportException (cls, e);
        return null;
    }
}


public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


-----Function Pair=279=-----==

public static void main (String [] args) throws Exception {
    Class testClass = AllTests.class;
    ArrayList < Method > setups = new ArrayList < Method > ();
    ArrayList < Method > tearDowns = new ArrayList < Method > ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            if (method.getAnnotation (Before.class) != null) {
                setups.add (method);
            }
            if (method.getAnnotation (After.class) != null) {
                setups.add (method);
            }
        }
    }
    System.out.println ("Starting all tests.");
    Object instance = testClass.newInstance ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            Test testAnnotation = method.getAnnotation (Test.class);
            if (testAnnotation != null) {
                for (Method setup : setups) {
                    setup.invoke (instance, (Object []) null);
                }
                Class expectedException = testAnnotation.expected ();
                if (expectedException.getName ().equals ("org.junit.Test$None")) {
                    expectedException = null;
                }
                try {
                    method.invoke (instance, (Object []) null);
                } catch (Exception e) {
                    if (expectedException == null) {
                        System.out.println (testClass.getName () + "." + method.getName () + ": " + e.getCause ().getMessage ());
                        new BufferedReader (new InputStreamReader (System.in)).readLine ();
                    }
                    else {
                        if (! e.getCause ().getClass ().equals (testAnnotation.expected ())) {
                            System.out.println (testClass.getName () + "." + method.getName () + ": " + "Exception expected: " + testAnnotation.expected ().getName () + ", Exception thrown: " + e.getCause ().getMessage ());
                            new BufferedReader (new InputStreamReader (System.in)).readLine ();
                        }
                        expectedException = null;
                    }
                }
                if (expectedException != null) {
                    System.out.println (testClass.getName () + "." + method.getName () + ": " + "Expected exception not thrown: " + testAnnotation.expected ().getName ());
                    new BufferedReader (new InputStreamReader (System.in)).readLine ();
                }
                for (Method tearDown : tearDowns) {
                    tearDown.invoke (instance, (Object []) null);
                }
            }
        }
    }
    System.out.println ("Done with all tests.");
}


private void emitSingleton (String opcode, boolean [] [] testsPerformed, int level) {
    EmitterDescriptor ed = (EmitterDescriptor) emitters.iterator ().next ();
    int [] args = ed.getArgs ();
    int count = ed.getCount ();
    for (int i = 0; i < count; i ++) if (! testsPerformed [i] [args [i]]) emitVerify (i, args [i], level);
    int size = ed.getSize ();
    if (size != 0) {
        boolean needed = true;
        for (int i = 0; i < count; i ++) if (testsPerformed [i] [size]) needed = false;
        if (needed) emitVerify (0, size, level);
        if (size == Byte) for (int i = 0; i < count; i ++) if (args [i] == Register) if (currentOpcode.indexOf ("MOVZX") == - 1 && currentOpcode.indexOf ("MOVSX") == - 1) {
            emitTab (level);
            emit ("if (VM.VerifyAssertions && !(");
            emitArgs (i, Register);
            emit (" < 4)) VM._assert(false, inst.toString());\n");
        }
    }
    emitEmitCall (opcode, args, count, level, ed.getSize ());
}


-----Function Pair=280=-----==

public static void go (final String cmd) {
    System.out.println ("running a " + cmd);
    final String [] args = cmd.split ("[ ]");
    if (args [0].equalsIgnoreCase ("RobotServer")) {
        if (RobotServer > 0) {
            System.out.println ("Sorry only once!");
            return;
        }
        RobotServer ++;
    }
    Thread thread = new Thread (args [0]) {
        public void run () {
            try {
                Class clazz = Class.forName (args [0]);
                Class [] argsTypes = {String [].class};
                Object [] args0 = {args};
                Method method = clazz.getMethod ("main", argsTypes);
                method.invoke (clazz, args0);
            } catch (Exception e) {
                e.printStackTrace ();
                System.err.println (e);
                System.out.println ("coudn't run the " + cmd);
                runningPrograms --;
            }
        }
    }
    ;
    runningPrograms ++;
    thread.start ();
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken ());
        else if (keyword.equals ("cache")) cache = new Cache (st.nextToken ());
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


-----Function Pair=281=-----==

public static String getRSettings (String binR) {
    try {
        File fin = File.createTempFile ("rboot", ".R");
        File fout = File.createTempFile ("rboot", ".tmp");
        PrintStream p = new PrintStream (new FileOutputStream (fin));
        p.println ("cat(unlist(lapply(c('R_HOME','R_ARCH','R_DOC_DIR','R_INCLUDE_DIR','R_SHARE_DIR','LD_LIBRARY_PATH','DYLD_LIBRARY_PATH','R_UNZIPCMD','R_LATEXCMD','R_PAPERSIZE','R_PRINTCMD'),Sys.getenv)),sep='\n')");
        p.println ("cat(paste(.libPaths(),collapse=.Platform$path.sep),'\n',sep='')");
        p.close ();
        Process rp = Runtime.getRuntime ().exec (new String [] {"/bin/sh", "-c", binR + " --no-restore --no-save --slave < \"" + fin.getAbsolutePath () + "\" > \"" + fout.getAbsolutePath () + "\""});
        int i = rp.waitFor ();
        System.out.println ("getRSettings, i=" + i);
        BufferedReader r = new BufferedReader (new FileReader (fout));
        rs_home = r.readLine ();
        rs_arch = r.readLine ();
        rs_docdir = r.readLine ();
        rs_incdir = r.readLine ();
        rs_sharedir = r.readLine ();
        rs_ldp = r.readLine ();
        rs_dyldp = r.readLine ();
        rs_unzip = r.readLine ();
        rs_latex = r.readLine ();
        rs_paper = r.readLine ();
        rs_print = r.readLine ();
        rs_libs = r.readLine ();
        r.close ();
        if (! fin.delete ()) fin.deleteOnExit ();
        System.out.println (" - retrieved R settings, home: " + rs_home + " (arch=" + rs_arch + ", libs=" + rs_libs + ")");
    } catch (Exception e) {
        System.err.println ("Failed to get R settings: " + e);
    }
    return rs_home;
}


private void setInitialBreakPoint () {
    int status;
    status = user.mwait ();
    while (user.isIgnoredTrap (status)) {
        user.mcontinue (0);
        status = user.mwait ();
    }
    if (initial_bp != 0) {
        breakpoint bp = new breakpoint (0, 0, initial_bp);
        user.bpset.setBreakpoint (bp);
        user.mcontinue (0);
        status = user.mwait ();
        while (user.isIgnoredTrap (status)) {
            user.mcontinue (0);
            status = user.mwait ();
        }
        user.bpset.clearBreakpoint (bp);
        user.reg.cacheJTOC ();
        if (interpretMode) {
            mapVM.cachePointers ();
        }
        user.bmap.fillBootMethodTable ();
        if (! viewBoot) {
            goToMainMethod ();
        }
    }
}


-----Function Pair=282=-----==

public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken ());
        else if (keyword.equals ("cache")) cache = new Cache (st.nextToken ());
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


-----Function Pair=283=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=284=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


-----Function Pair=285=-----==

public boolean Test57 (String methodName) {
    UniqueSet world = this.createWorld ();
    Iterator iworld = world.iterator ();
    double periods = 0;
    int counter = 0;
    while (iworld.hasNext ()) {
        Country c = (Country) iworld.next ();
        try {
            periods += c.getAveragePeriodOfStudies (Country.PERSON);
            counter += c.countGraduates (Country.PERSON);
        } catch (AppException e) {
        }
    }
    return this.matchResultToDouble (methodName, (float) 6.0 / 7.0, periods / counter);
}


void setupIterator (VM_CompiledMethod compiledMethod, int instructionOffset, int fp) {
    currentMethod = compiledMethod.getMethod ();
    framePtr = fp;
    maps = ((VM_BaselineCompilerInfo) compiledMethod.getCompilerInfo ()).referenceMaps;
    mapId = maps.locateGCPoint (instructionOffset, currentMethod);
    mapOffset = 0;
    if (mapId < 0) {
        VM_ReferenceMaps.jsrLock.lock ();
        maps.setupJSRSubroutineMap (framePtr, mapId, compiledMethod);
    }
    if (VM.TraceStkMaps) {
        VM.sysWrite ("VM_BaselineGCMapIterator setupIterator mapId = ");
        VM.sysWrite (mapId);
        VM.sysWrite (".\n");
    }
    bridgeTarget = null;
    bridgeParameterTypes = null;
    bridgeParameterMappingRequired = false;
    bridgeRegistersLocationUpdated = false;
    bridgeParameterIndex = 0;
    bridgeRegisterIndex = 0;
    bridgeRegisterLocation = 0;
    if (currentMethod.getDeclaringClass ().isDynamicBridge ()) {
        fp = VM_Magic.getCallerFramePointer (fp);
        int ip = VM_Magic.getNextInstructionAddress (fp);
        int callingCompiledMethodId = VM_Magic.getCompiledMethodID (fp);
        VM_CompiledMethod callingCompiledMethod = VM_ClassLoader.getCompiledMethod (callingCompiledMethodId);
        VM_CompilerInfo callingCompilerInfo = callingCompiledMethod.getCompilerInfo ();
        int callingInstructionOffset = ip - VM_Magic.objectAsAddress (callingCompiledMethod.getInstructions ());
        callingCompilerInfo.getDynamicLink (dynamicLink, callingInstructionOffset);
        bridgeTarget = dynamicLink.methodRef ();
        bridgeParameterInitialIndex = dynamicLink.isInvokedWithImplicitThisParameter () ? - 1 : 0;
        bridgeParameterTypes = bridgeTarget.getParameterTypes ();
    }
    reset ();
}


-----Function Pair=286=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


-----Function Pair=287=-----==

private void saveSimulation () {
    String ext = "dat";
    String dext = "csv";
    JFileFilter filter = new JFileFilter ();
    filter.addType (ext);
    filter.setDescription ("Aurora simulation files (*." + ext + ")");
    JFileChooser fc = new JFileChooser ("Save Simulation");
    fc.setFileFilter (filter);
    fc.setCurrentDirectory (currentDir);
    if (fc.showSaveDialog (this) == JFileChooser.APPROVE_OPTION) {
        currentDir = fc.getCurrentDirectory ();
        File fp = fc.getSelectedFile ();
        if (fp.exists ()) {
            int res = JOptionPane.showConfirmDialog (this, "File '" + fp.getName () + "' exists. Overwrite?", "Confirmation", JOptionPane.YES_NO_OPTION);
            if (res == JOptionPane.NO_OPTION) return;
        }
        try {
            String fpath = fp.getAbsolutePath ();
            String dfpath = fp.getAbsolutePath ();
            if (! fp.getName ().endsWith (ext)) {
                fpath += "." + ext;
                dfpath += ".";
            }
            else {
                dfpath = dfpath.substring (0, dfpath.length () - 3);
            }
            dfpath += dext;
            if ((mySystem != null) && (mySystem.getMySettings () != null)) mySystem.getMySettings ().copyTmpDataFile (dfpath);
            ObjectOutputStream oos = new ObjectOutputStream (new FileOutputStream (fpath));
            mySystem.getMyStatus ().setSaved (true);
            oos.writeObject (mySystem);
            oos.close ();
            if ((mySystem != null) && (mySystem.getMySettings () != null)) mySystem.getMySettings ().establishDataOutput ();
        } catch (Exception e) {
            JOptionPane.showMessageDialog (this, e.getMessage (), e.getClass ().getSimpleName (), JOptionPane.ERROR_MESSAGE);
        }
    }
    return;
}


public void done () {
    try {
        dispose ();
        String str = get ();
        if (str == null || str.length () == 0) {
            JOptionPane.showMessageDialog (frame, tr ("Unable to retrieve version information.\nPlease check network connectivity"), tr ("Error"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        net.mjrz.fm.Version v = net.mjrz.fm.Version.getVersion ();
        if (v.isVersionGreater (str.toString ())) {
            String [] args = {str};
            String msg = form.format (args);
            int n = JOptionPane.showConfirmDialog (frame, msg + "\n" + tr ("Do you want to download the latest version?"), tr ("Message"), JOptionPane.YES_NO_OPTION);
            if (n == JOptionPane.YES_OPTION) {
                java.awt.Desktop d = Desktop.getDesktop ();
                if (Desktop.isDesktopSupported ()) {
                    d.browse (new URI (UIDefaults.PRODUCT_DOWNLOAD_URL));
                }
            }
        }
        else {
            JOptionPane.showMessageDialog (frame, tr ("No new updates are available"));
        }
    } catch (Exception e) {
        logger.error (MiscUtils.stackTrace2String (e));
    } finally {
        frame.hideSheet ();
    }
}


-----Function Pair=288=-----==

public void mouseClicked (MouseEvent evt) {
    if (evt.getClickCount () == 2) {
        TreePath tp = arborescence.getClosestPathForLocation (evt.getX (), evt.getY ());
        String path = tp.toString ();
        String name = path.substring (path.indexOf (',') + 2);
        if (name.contains (" (")) {
            name = name.substring (0, name.indexOf (" ("));
        }
        path = path.substring (path.indexOf (',') + 1, path.length ());
        path = path.replaceAll ("\\([^,]*,", "/");
        path = path.replaceAll (",", "/");
        path = path.replaceAll (" ", "");
        path = path.replaceAll ("\\]", "");
        Site site = siteListH.getList ().getSite (name);
        if (site != null) {
            path = site.getTarget () + "\\" + path;
        }
        try {
            File file = new File (path);
            if (file.isFile ()) {
                if (Desktop.isDesktopSupported ()) {
                    Desktop desktop = Desktop.getDesktop ();
                    if (desktop.isSupported (Desktop.Action.OPEN)) {
                        desktop.open (file);
                    }
                }
            }
        } catch (Exception rex) {
        }
    }
}


private void buildMainWindowBase () {
    setMinimumSize (new Dimension (WIDTH_MAIN_WINDOW, HEIGHT_MAIN_WINDOW));
    getModel ().setPathLatestUse (prefs.getPathLatestUse ());
    int x = prefs.getLocationOnScreenX ();
    int y = prefs.getLocationOnScreenY ();
    setLocation (x, y);
    int width = prefs.getWindowWidth ();
    int height = prefs.getWindowHeight ();
    setSize (width, height);
    setVisible (true);
    String versionNumber = Main.class.getPackage ().getImplementationVersion ();
    if (StringUtils.isEmpty (versionNumber)) {
        versionNumber = "Version: Source";
    }
    StringBuffer buf = new StringBuffer (resources.getString ("Window.Title"));
    buf.append (" - ");
    buf.append (versionNumber);
    setTitle (buf.toString ());
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    addWindowListener (new WindowCloseListsner ());
    ImageIcon imgLogoIcon = Util.createImageIcon (this.getClass (), resources.getString ("Common.Icon"), "Icon");
    setIconImage (imgLogoIcon.getImage ());
}


-----Function Pair=289=-----==

public JLabelURL (String u, String text, String color) {
    url = u;
    if (text == null) text = u;
    String col = "";
    if (color != null) {
        col = "color=#\"" + color + "\"";
    }
    String html = "<html><a " + col + " href=\"" + u + "\">" + text + "</a></html>";
    setText (html);
    addMouseListener (new MouseAdapter () {
        public void mouseClicked (MouseEvent e) {
            openURL (url);
        }
    }
    );
}


public boolean removeProject (Project prj) {
    boolean succes = false;
    String remoteFolder = prj.getStorage () + "/" + prj.getNodeText ();
    logger.info ("Will delete this folder: " + remoteFolder);
    try {
        rms.deleteFolder (credentials, remoteFolder);
        succes = true;
    } catch (NumberFormatException e) {
        logger.error (e.getMessage ());
    } catch (SocketException e) {
        logger.error (e.getMessage ());
    } catch (AccessDeniedException e) {
        logger.error (e.getMessage ());
    } catch (IOException e) {
        logger.error (e.getMessage ());
    } catch (UnsupportedRemoteStorageException e) {
        logger.error (e.getMessage ());
    }
    return succes;
}


-----Function Pair=290=-----==

public void imprimer () {
    if (Desktop.isDesktopSupported ()) {
        Desktop desktop = Desktop.getDesktop ();
        if (desktop.isSupported (Desktop.Action.PRINT)) {
            _frameMain._statusBar.isWork (true);
            _frameMain._statusBar.setStatusText (TEXT_IMPRESSION);
            String oldFile = null;
            if (_frameMain.file != null) oldFile = _frameMain.file.getPath ();
            _frameMain.file = new File (PATH_TMP_FILE);
            sauvegardeFichier ();
            try {
                desktop.print (_frameMain.file);
            } catch (IOException ex) {
                Logger.getLogger (MenuAction.class.getName ()).log (Level.SEVERE, null, ex);
            } finally {
                if (oldFile != null) _frameMain.file = new File (oldFile);
                else {
                    _frameMain.file.delete ();
                    _frameMain.file = null;
                }
            }
            _frameMain._statusBar.isWork (false);
        }
    }
}


void arrangeCheckBoxes (Map < JCheckBox, Class < ? extends Uploader > > map) {
    freeandacctPanel.removeAll ();
    acctonlyPanel.removeAll ();
    freeandacctPanel.setLayout (new GridLayout (0, 4));
    acctonlyPanel.setLayout (new GridLayout (0, 3));
    checkboxiteration : for (Map.Entry < JCheckBox, Class < ? extends Uploader > > entry : map.entrySet ()) {
        for (Class < ? > cl : entry.getValue ().getInterfaces ()) {
            if (cl.getName ().equals (UploaderAccountNecessary.class.getName ())) {
                acctonlyPanel.add (entry.getKey ());
                continue checkboxiteration;
            }
        }
        freeandacctPanel.add (entry.getKey ());
    }
}


-----Function Pair=291=-----==

public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=292=-----==

public synchronized void append (ArrayDataSet ds) {
    if (ds.rank () != this.rank) throw new IllegalArgumentException ("rank mismatch");
    if (ds.len1 != this.len1) throw new IllegalArgumentException ("len1 mismatch");
    if (ds.len2 != this.len2) throw new IllegalArgumentException ("len2 mismatch");
    if (ds.len3 != this.len3) throw new IllegalArgumentException ("len3 mismatch");
    if (this.getBack ().getClass () != ds.getBack ().getClass ()) throw new IllegalArgumentException ("backing type mismatch");
    int myLength = this.len0 * this.len1 * this.len2 * this.len3;
    int dsLength = ds.len0 * ds.len1 * ds.len2 * ds.len3;
    if (Array.getLength (this.getBack ()) < myLength + dsLength) {
        throw new IllegalArgumentException ("unable to append dataset, not enough room");
    }
    System.arraycopy (ds.getBack (), 0, this.getBack (), myLength, dsLength);
    Units u1 = SemanticOps.getUnits (this);
    Units u2 = SemanticOps.getUnits (ds);
    if (u1 != u2) {
        UnitsConverter uc = UnitsConverter.getConverter (u2, u1);
        Class backClass = this.getBack ().getClass ().getComponentType ();
        for (int i = myLength; i < myLength + dsLength; i ++) {
            Number nv = uc.convert (Array.getDouble (this.getBack (), i));
            if (backClass == double.class) {
                Array.set (this.getBack (), i, nv.doubleValue ());
            }
            else if (backClass == float.class) {
                Array.set (this.getBack (), i, nv.floatValue ());
            }
            else if (backClass == long.class) {
                Array.set (this.getBack (), i, nv.longValue ());
            }
            else if (backClass == int.class) {
                Array.set (this.getBack (), i, nv.intValue ());
            }
            else if (backClass == short.class) {
                Array.set (this.getBack (), i, nv.shortValue ());
            }
            else if (backClass == byte.class) {
                Array.set (this.getBack (), i, nv.byteValue ());
            }
            else {
                throw new IllegalArgumentException ("unsupported type: " + backClass);
            }
        }
    }
    this.len0 = this.len0 + ds.len0;
    properties.putAll (joinProperties (this, ds));
}


public static Object deepCopy (Object object) {
    Assertor.notNull (object);
    Object result = null;
    try {
        ByteArrayOutputStream bufOut = new ByteArrayOutputStream ();
        ObjectOutputStream objOut = new ObjectOutputStream (bufOut);
        objOut.writeObject (object);
        objOut.flush ();
        ObjectInputStream objIn = new ObjectInputStream (new ByteArrayInputStream (bufOut.toByteArray ()));
        result = objIn.readObject ();
        objIn.close ();
        objOut.close ();
        bufOut.close ();
    } catch (IOException e) {
        if (log.isFatalEnabled ()) {
            log.fatal ("Could not copy object [" + object + "]!!", e);
        }
    } catch (ClassNotFoundException e) {
        if (log.isFatalEnabled ()) {
            log.fatal ("Could not copy object [" + object + "]!!", e);
        }
    }
    return result;
}


-----Function Pair=293=-----==

public int addAllAbsent (Collection < ? extends E > c) {
    if (c.size () == 0) {
        return 0;
    }
    lock.lock ();
    try {
        E [] old = getData ();
        int size = old.length;
        E [] toAdd = newElementArray (c.size ());
        int i = 0;
        for (Iterator it = c.iterator (); it.hasNext ();) {
            E o = (E) it.next ();
            if (indexOf (o) < 0) {
                toAdd [i ++] = o;
            }
        }
        E [] data = newElementArray (size + i);
        System.arraycopy (old, 0, data, 0, size);
        System.arraycopy (toAdd, 0, data, size, i);
        setData (data);
        return i;
    } finally {
        lock.unlock ();
    }
}


public static boolean equals (Object [] objectArray1, Object [] objectArray2) {
    if (objectArray1 == null) {
        return objectArray2 == null;
    }
    else if (objectArray2 == null) {
        return false;
    }
    if (objectArray1.length != objectArray2.length) {
        return false;
    }
    for (int i = 0; i < objectArray1.length; i ++) {
        Object element1 = objectArray1 [i];
        Object element2 = objectArray2 [i];
        if (element1 == null) {
            if (element2 != null) {
                return false;
            }
        }
        else if (! element1.equals (element2)) {
            return false;
        }
    }
    return true;
}


-----Function Pair=294=-----==

public static < T > T [] insert (final Object array, final int index, final Object element) {
    if (array == null) {
        if (index != 0) {
            throw new IndexOutOfBoundsException ("Index: " + index + ", Length: 0");
        }
        Object joinedArray = Array.newInstance (element != null ? element.getClass () : Object.class, 1);
        Array.set (joinedArray, 0, element);
        return (T []) joinedArray;
    }
    int length = getLength (array);
    if (index > length || index < 0) {
        throw new IndexOutOfBoundsException ("Index: " + index + ", Length: " + length);
    }
    Object result = Array.newInstance (array.getClass ().getComponentType (), length + 1);
    System.arraycopy (array, 0, result, 0, index);
    Array.set (result, index, element);
    if (index < length) {
        System.arraycopy (array, index, result, index + 1, length - index);
    }
    return (T []) result;
}


public static int indexOfP (Object anArray, Object anElement) {
    if (anArray == null) return - 1;
    if (anArray instanceof Object []) {
        Object [] array2 = (Object []) anArray;
        for (int i = 0; i < array2.length; i ++) {
            if (equals (array2 [i], anElement)) return i;
        }
        return - 1;
    }
    else {
        int i, len;
        len = Array.getLength (anArray);
        for (i = 0; i < len; i ++) {
            if (equals (Array.get (anArray, i), anElement)) return i;
        }
        return - 1;
    }
}


-----Function Pair=295=-----==

synchronized void update (final HistoricData historicData) throws CardPriceException {
    PersistenceManager pm = PMF.get ().getPersistenceManager ();
    try {
        HistoricData current = pm.getObjectById (HistoricData.class, historicData.getId ());
        current.setRegularPrice (historicData.getRegularPrice ());
        current.setCard (historicData.getCard ());
        current.setCodedPrice (historicData.getCodedPrice ());
        current.setSampleDate (historicData.getSampleDate ());
        pm.makePersistent (current);
    } catch (Exception e) {
        String message = "Oeps something wrong";
        log.severe (message);
        throw new CardPriceException (message, e);
    } finally {
        pm.close ();
    }
}


public static void BubbleSortFloat1 (float [] num) {
    boolean flag = true;
    float temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=296=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=297=-----==

private void createShadowPicture (BufferedImage image) {
    int width = image.getWidth ();
    int height = image.getHeight ();
    int extra = 14;
    setSize (new Dimension (width + extra, height + extra));
    setLocationRelativeTo (null);
    Rectangle windowRect = getBounds ();
    splash = new BufferedImage (width + extra, height + extra, BufferedImage.TYPE_INT_ARGB);
    Graphics2D g2 = (Graphics2D) splash.getGraphics ();
    try {
        Robot robot = new Robot (getGraphicsConfiguration ().getDevice ());
        BufferedImage capture = robot.createScreenCapture (new Rectangle (windowRect.x, windowRect.y, windowRect.width + extra, windowRect.height + extra));
        g2.drawImage (capture, null, 0, 0);
    } catch (AWTException e) {
    }
    BufferedImage shadow = new BufferedImage (width + extra, height + extra, BufferedImage.TYPE_INT_ARGB);
    Graphics g = shadow.getGraphics ();
    g.setColor (new Color (0.0f, 0.0f, 0.0f, 0.3f));
    g.fillRoundRect (6, 6, width, height, 12, 12);
    g2.drawImage (shadow, getBlurOp (7), 0, 0);
    g2.drawImage (image, 0, 0, this);
}


public void paintComponent (Graphics g) {
    g.drawImage (this.image1, 0, 0, getWidth (), getHeight (), this.parent.getX (), this.parent.getY (), this.parent.getX () + getWidth (), this.parent.getY () + getHeight (), this);
    Graphics2D g2d = (Graphics2D) g;
    Insets vInsets = this.getInsets ();
    int w = this.getWidth () - (vInsets.left + vInsets.right);
    int h = this.getHeight () - (vInsets.top + vInsets.bottom);
    int x = vInsets.left;
    int y = vInsets.top;
    int arc = 16;
    Shape vButtonShape = new RoundRectangle2D.Double ((double) x, (double) y + 2, (double) w, (double) h - 2, (double) arc, (double) arc);
    Shape vOldClip = g.getClip ();
    Color shade = new Color (0x9e303030, true);
    g2d.setColor (shade);
    g2d.fillRoundRect (x + shadowSize, y + shadowSize, w - 4, h - 4, arc, arc);
    GradientPaint vPaint = new GradientPaint (x, y, this.popeyeMediumGreen, x + w / 2, y + h / 2, Color.WHITE);
    g2d.setPaint (vPaint);
    g2d.fillRoundRect (x, y, w - 4, h - 4, arc, arc);
    vPaint = new GradientPaint (x, y, Color.BLACK, x + w, y + h, popeyeDarkGreen);
    g2d.setPaint (vPaint);
    g2d.drawRoundRect (x, y, w - 4, h - 4, arc, arc);
    g2d.setClip (vOldClip);
    g2d.setColor (new Color (0x330000ff, true));
}


-----Function Pair=298=-----==

public static void main (String [] args) throws AWTException, IOException, InterruptedException {
    JFrame gui = new JFrame ();
    JPanel panel = new JPanel ();
    JButton button = new JButton ();
    button.setText ("print Screen");
    button.addActionListener (new PrintScreenActionListener ());
    panel.add (button);
    gui.add (panel);
    gui.setSize (150, 60);
    gui.setVisible (true);
    gui.setTitle ("yaha");
    while (gui.isVisible ()) {
        Thread.sleep (1000);
    }
    System.exit (0);
}


public Handler (Socket connection) {
    this.connection = connection;
    try {
        robot = new Robot ();
    } catch (Exception e) {
        System.err.println ("Error in creating Robot");
    }
    mouseHandler = new MouseHandler (robot);
    keyboardHandler = new KeyboardHandler (robot);
    processThread = new Thread (new Runnable () {
        public void run () {
            while (true) {
                processCommand ();
            }
        }
    }
    );
    processThread.start ();
}


-----Function Pair=299=-----==

boolean isDifferent (BufferedImage image) {
    boolean different = true;
    if (image != null) {
        different = false;
        Raster r = image.getData ();
        int [] pixelArray1 = r.getPixels (0, 0, r.getWidth (), r.getHeight (), (int []) null);
        if (lastPixelArrayReceived != null) {
            if (pixelArray1.length == lastPixelArrayReceived.length && lastWidth == r.getWidth () && lastHeight == r.getHeight ()) {
                for (int i = 0; i < pixelArray1.length; i ++) {
                    if (pixelArray1 [i] != lastPixelArrayReceived [i]) {
                        different = true;
                        break;
                    }
                }
            }
            else different = true;
        }
        else different = true;
        lastPixelArrayReceived = new int [pixelArray1.length];
        lastWidth = r.getWidth ();
        lastHeight = r.getHeight ();
        System.arraycopy (pixelArray1, 0, lastPixelArrayReceived, 0, pixelArray1.length);
    }
    return different;
}


private boolean initializeHighQualityScreenCapture (GraphicsDevice device) {
    reset ();
    try {
        if (screenCaptureRobot == null) {
            screenCaptureRobot = new Robot (device);
            screenCaptureRobot.setAutoDelay (0);
            screenCaptureRobot.setAutoWaitForIdle (false);
        }
        if (changedHighSettings ()) {
            refreshHighSettings ();
        }
        highQualityScreenCaptureInitialized = true;
        return true;
    } catch (Exception e) {
        highQualityScreenCaptureInitialized = false;
        return false;
    }
}


-----Function Pair=300=-----==

protected void paintComponent (Graphics g) {
    if (! m_bTempHide) {
        Rectangle oClip = g.getClipBounds ();
        if (m_oImageBuf != null) {
            g.drawImage (m_oImageBuf, oClip.x, oClip.y, oClip.x + oClip.width, oClip.y + oClip.height, oClip.x, oClip.y, oClip.x + oClip.width, oClip.y + oClip.height, null);
        }
        else {
            g.setColor (new Color (255, 255, 255, 160));
            g.fillRect (oClip.x, oClip.y, oClip.width, oClip.height);
        }
        Graphics2D g2 = (Graphics2D) g.create ();
        g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2.transform (m_oCenterAndScaleTransform);
        double maxY = 0.0;
        for (int i = 0; i < m_oBars.length; i ++) {
            g2.setColor (m_oColors [i + m_iColorOffset]);
            g2.fill (m_oBars [i]);
            Rectangle2D bounds = m_oBars [i].getBounds2D ();
            if (bounds.getMaxY () > maxY) maxY = bounds.getMaxY ();
        }
        if (text != null && text.length () > 0) {
            FontRenderContext context = g2.getFontRenderContext ();
            TextLayout layout = new TextLayout (text, new Font (getFont ().getName (), getFont ().getStyle (), 20), context);
            Rectangle2D bounds = layout.getBounds ();
            g2.setColor (getForeground ());
            layout.draw (g2, (float) - (bounds.getWidth () / 2), (float) (maxY + layout.getLeading () + 2 * layout.getAscent ()));
        }
    }
}


public JPanel JPanelSetting (final JFrame j) {
    final JPanel MyPanel = new JPanel ();
    MyPanel.setLayout (new BorderLayout ());
    MyPanel.setBorder (new TitledBorder (new EtchedBorder (), "Option"));
    JFileChooser filechooser;
    JPanel MyLabelPanel = new JPanel ();
    JLabel PathLabel = new JLabel (" MainPath : ");
    JLabel ForegroundLabel = new JLabel (" Foreground : ");
    JLabel BackgroundLabel = new JLabel (" Background : ");
    JLabel StrokeLabel = new JLabel (" StrokeSize: ");
    JPanel MyTextFieldPanel = new JPanel ();
    JPanel MyButtondPanel = new JPanel ();
    JButton FontColorButton;
    JButton FontBackgroundButton;
    JButton DirSelectButton;
    MyLabelPanel.setLayout (new GridLayout (4, 1, 5, 5));
    MyLabelPanel.add (PathLabel);
    MyLabelPanel.add (ForegroundLabel);
    MyLabelPanel.add (BackgroundLabel);
    MyLabelPanel.add (StrokeLabel);
    MyPanel.add ("West", MyLabelPanel);
    MyTextFieldPanel.setLayout (new GridLayout (4, 1, 5, 5));
    MyTextFieldPanel.add (PathTextfield);
    fontcanvas = new Canvas ();
    fontbgcanvas = new Canvas ();
    MyTextFieldPanel.add (fontcanvas);
    MyTextFieldPanel.add (fontbgcanvas);
    MyTextFieldPanel.add (StrokeTextfield);
    MyPanel.add ("Center", MyTextFieldPanel);
    JPanel ButtonPanel = new JPanel ();
    ButtonPanel.setLayout (new GridLayout (1, 4, 5, 5));
    MyButtondPanel.setLayout (new GridLayout (6, 1, 5, 5));
    DirSelectButton = new JButton ("..");
    DirSelectButton.addActionListener (this);
    FontColorButton = new JButton ("..");
    FontColorButton.addActionListener (this);
    FontBackgroundButton = new JButton ("..");
    FontBackgroundButton.addActionListener (this);
    JLabel jl1 = new JLabel ("");
    JLabel jl2 = new JLabel ("");
    JLabel jl3 = new JLabel ("");
    MyButtondPanel.add (DirSelectButton);
    MyButtondPanel.add (jl1);
    MyButtondPanel.add (FontColorButton);
    MyButtondPanel.add (jl2);
    MyButtondPanel.add (FontBackgroundButton);
    MyButtondPanel.add (jl3);
    MyPanel.add ("East", MyButtondPanel);
    JButton ApplyButton = new JButton ("Apply");
    ApplyButton.addActionListener (this);
    JButton DefaultButton = new JButton ("Default");
    DefaultButton.addActionListener (this);
    JButton ResetButton = new JButton ("Reset");
    ResetButton.addActionListener (this);
    JButton CloseButton = new JButton ("Close");
    CloseButton.addActionListener (this);
    ButtonPanel.add (ApplyButton);
    ButtonPanel.add (DefaultButton);
    ButtonPanel.add (ResetButton);
    ButtonPanel.add (CloseButton);
    MyPanel.add ("South", ButtonPanel);
    ApplyButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveSetting ();
            panel.setForeground (new Color (cf.getRGB ()));
            panel.setBackground (new Color (cb.getRGB ()));
            panel.setGhinStrokeSize (Integer.valueOf (StrokeTextfield.getText ()));
            panel.home = PathTextfield.getText ();
            controls.bgini = new Color (cb.getRGB ());
            controls.repaint ();
            panel.repaint ();
        }
    }
    );
    DefaultButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            loadSetting ();
        }
    }
    );
    ResetButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            PathTextfield.setText (".");
            fontcanvas.setBackground (Color.black);
            fontbgcanvas.setBackground (Color.white);
            StrokeTextfield.setText ("1");
            repaint ();
        }
    }
    );
    CloseButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            j.dispose ();
        }
    }
    );
    DirSelectButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            JFileChooser chooser = new JFileChooser (".");
            chooser.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
            File file = new File (".");
            if (chooser.showDialog (MyPanel, "Select") == JFileChooser.APPROVE_OPTION) {
                file = chooser.getSelectedFile ();
                String dir = file.getPath ();
                PathTextfield.setText (dir);
            }
        }
    }
    );
    FontColorButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            cf = JColorChooser.showDialog (((Component) null), "set Foreground Color", Color.blue);
            fontcanvas.setBackground (cf);
            if (cf == null) fontcanvas.setBackground (new Color (Integer.valueOf (ghinprops.getProperty ("Foreground"))));
        }
    }
    );
    FontBackgroundButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            cb = JColorChooser.showDialog (((Component) null), "set Background Color", Color.blue);
            fontbgcanvas.setBackground (cb);
            if (cb == null) fontbgcanvas.setBackground (new Color (Integer.valueOf (ghinprops.getProperty ("Background"))));
        }
    }
    );
    loadSetting ();
    return MyPanel;
}


-----Function Pair=301=-----==

protected boolean loadValuesFromKeystore (KeyStoreInfo keyStoreInfo) throws ConfigurationException {
    KeyStore.PrivateKeyEntry entry = null;
    try {
        if (Log.isLoggable (Log.FAC_KEYS, Level.INFO)) Log.info (Log.FAC_KEYS, "Loading key store {0} version {1} version component {2} millis {3}", keyStoreInfo.getKeyStoreURI (), keyStoreInfo.getVersion ().toString (), VersioningProfile.printAsVersionComponent (keyStoreInfo.getVersion ()), keyStoreInfo.getVersion ().getTime ());
        entry = (KeyStore.PrivateKeyEntry) keyStoreInfo.getKeyStore ().getEntry (_defaultAlias, new KeyStore.PasswordProtection (_password));
        if (null == entry) {
            Log.warning ("Cannot get default key entry: " + _defaultAlias);
            generateConfigurationException ("Cannot retrieve default user keystore entry.", null);
        }
        X509Certificate certificate = (X509Certificate) entry.getCertificate ();
        if (null == certificate) {
            Log.warning ("Cannot get certificate for default key entry: " + _defaultAlias);
            generateConfigurationException ("Cannot retrieve certificate for default user keystore entry.", null);
        }
        _defaultKeyID = new PublisherPublicKeyDigest (certificate.getPublicKey ());
        if (Log.isLoggable (Log.FAC_KEYS, Level.INFO)) Log.info (Log.FAC_KEYS, "Default key ID for user " + _userName + ": " + _defaultKeyID);
        _privateKeyCache.loadKeyStore (keyStoreInfo, _password, _publicKeyCache);
    } catch (Exception e) {
        generateConfigurationException ("Cannot retrieve default user keystore entry.", e);
    }
    return true;
}


public void run () {
    try {
        if (keygen.getAction () == KeygenPanel.CHANGE_PASSPHRASE) {
            monitor.setNote ("Changing passphrase");
            SshKeyGenerator.changePassphrase (inputFile, oldPassphrase, newPassphrase);
            monitor.setNote ("Complete");
            JOptionPane.showMessageDialog (Main.this, "Passphrase changed", "Passphrase changed", JOptionPane.INFORMATION_MESSAGE);
        }
        else if (keygen.getAction () == KeygenPanel.CONVERT_IETF_SECSH_TO_OPENSSH) {
            monitor.setNote ("Converting key file");
            writeString (outputFile, SshKeyGenerator.convertPublicKeyFile (inputFile, new OpenSSHPublicKeyFormat ()));
            monitor.setNote ("Complete");
            JOptionPane.showMessageDialog (Main.this, "Key converted", "Key converted", JOptionPane.INFORMATION_MESSAGE);
        }
        else if (keygen.getAction () == KeygenPanel.CONVERT_OPENSSH_TO_IETF_SECSH) {
            monitor.setNote ("Converting key file");
            writeString (outputFile, SshKeyGenerator.convertPublicKeyFile (inputFile, new SECSHPublicKeyFormat ()));
            monitor.setNote ("Complete");
            JOptionPane.showMessageDialog (Main.this, "Key converted", "Key converted", JOptionPane.INFORMATION_MESSAGE);
        }
        else {
            monitor.setNote ("Creating generator");
            SshKeyGenerator generator = new SshKeyGenerator ();
            monitor.setNote ("Generating");
            String username = System.getProperty ("user.name");
            generator.generateKeyPair (keygen.getType (), keygen.getBits (), outputFile.getAbsolutePath (), username, newPassphrase);
            monitor.setNote ("Complete");
            JOptionPane.showMessageDialog (Main.this, "Key generated to " + outputFile.getName (), "Complete", JOptionPane.INFORMATION_MESSAGE);
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog (Main.this, e.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
    } finally {
        monitor.close ();
    }
}


-----Function Pair=302=-----==

protected int align (int e) {
    int diff;
    int adiff;
    int lostdigit = 0;
    boolean inexact = false;
    diff = exp - e;
    adiff = diff;
    if (adiff < 0) adiff = - adiff;
    if (diff == 0) return 0;
    if (adiff > (DIGITS + 1)) {
        for (int i = DIGITS - 1; i >= 0; i --) mant [i] = 0;
        exp = e;
        ieeeFlags |= FLAG_INEXACT;
        dotrap (FLAG_INEXACT, "align", this, this);
        return 0;
    }
    for (int i = 0; i < adiff; i ++) {
        if (diff < 0) {
            if (lostdigit != 0) inexact = true;
            lostdigit = mant [0];
            shiftRight ();
        }
        else shiftLeft ();
    }
    if (inexact) {
        ieeeFlags |= FLAG_INEXACT;
        dotrap (FLAG_INEXACT, "align", this, this);
    }
    return lostdigit;
}


private static String [] split (String in, char splitchar) {
    int i;
    int len = in.length ();
    char [] str = new char [len + 1];
    in.getChars (0, len, str, 0);
    str [len ++] = splitchar;
    int wordstart = 0;
    Vector words = new Vector (3);
    for (i = 0; i < len; i ++) {
        if (str [i] == splitchar) {
            if (wordstart <= (i - 1)) {
                words.addElement (new String (str, wordstart, i - wordstart));
            }
            wordstart = i + 1;
        }
    }
    String [] ret = new String [words.size ()];
    words.copyInto (ret);
    return ret;
}


-----Function Pair=303=-----==

public void addGroupInstruction (int id, int groupId) throws FidoDatabaseException, InstructionNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            InstructionTable it = new InstructionTable ();
            if (it.contains (groupId) == false) throw new InstructionNotFoundException (groupId);
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            int max = getNextRank (stmt, id);
            String sql = "insert into InstructionGroups (InstructionId, Rank, GroupInstruction) " + "values (" + id + ", " + max + ", " + groupId + ")";
            stmt.executeUpdate (sql);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public List < Leilao > getLeiloes () throws SQLException {
    List < Leilao > leiloes = new ArrayList < Leilao > ();
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Leilao";
        ResultSet rs = stmt.executeQuery (sqlSelect);
        Leilao leilaoList = null;
        while (rs.next ()) {
            leilaoList = new Leilao ();
            leilaoList.setIdLeilao (rs.getInt ("idleilao"));
            leilaoList.setDataInicio (Utils.getDateFormat (rs.getString ("datainicio"), "yyyy-MM-dd"));
            leilaoList.setDataFim (Utils.getDateFormat (rs.getString ("datafim"), "yyyy-MM-dd"));
            leiloes.add (leilaoList);
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return leiloes;
}


-----Function Pair=304=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


public RestServiceResult update (RestServiceResult serviceResult, CoExercises2 coExercises2, String sDeliveryDate) {
    CoExercises2DAO coExercises2DAO = new CoExercises2DAO ();
    Long nExerciseId = coExercises2.getExerciseId ();
    try {
        EntityManagerHelper.beginTransaction ();
        coExercises2DAO.update (coExercises2);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coExercises2);
        Object [] args = {coExercises2.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises2.update.success"), args));
        this.addDeliveryDate (nExerciseId, sDeliveryDate);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio s2: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises2.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=305=-----==

public int writeInGuestBook (String user_uid, String theText, String nick) {
    int flag = 0;
    if (theText != null) {
        char c = 39;
        theText = StringUtil.replace (theText, (new Character (c)).toString (), "&#39;");
    }
    DBConnection con = null;
    try {
        con = DBServiceManager.allocateConnection ();
        if (theText != null) {
            char c = 39;
            theText = StringUtil.replace (theText, (new Character (c)).toString (), "&#39;");
        }
        StringBuffer query = new StringBuffer ();
        query.append ("INSERT INTO cafe_guestbook ");
        query.append ("(cafe_guestbook_to_fuid,cafe_guestbook_from_fuid,cafe_guestbook_from_nick,cafe_guestbook_date,cafe_guestbook_smile_id,cafe_guestbook_msg) ");
        query.append ("VALUES (" + owner_fuid + "," + user_uid + ",'" + nick + "',getdate(),0,'" + theText + "')");
        con.executeUpdate (query.toString ());
    } catch (SQLException e) {
        logError ("ERROR: writeInGuestBook(" + user_uid + "," + theText + "," + nick + ")", e);
        flag = 1;
    } finally {
        if (con != null) {
            con.release ();
        }
    }
    return flag;
}


private < T extends HibernateItem > List < T > transactionGetContentForContainer (String id, List < SortCriterion > sortList, SearchExp searchExp, GenericDAO < T, Long > dao) {
    logger.debug ("Transaction get content for container:{}, sort:{}, searchExp:{}", new Object [] {id, sortList, searchExp});
    List < T > result;
    Criteria criteria = dao.createCriteria ();
    if (id != null && id.length () > 0) {
        setCriteriaForDBID (id, criteria);
    }
    if (searchExp != null) {
        HibernateUtils.setCriteriaFromSearchExp (dao.getPersistentClass (), criteria, searchExp);
    }
    if (sortList != null) {
        HibernateUtils.addSortOrder (dao.getPersistentClass (), criteria, sortList);
    }
    result = criteria.list ();
    return result;
}


-----Function Pair=306=-----==

public static boolean doCreateOrUpdate (Object object) {
    try {
        session = currentSession ();
        beginTransaction ();
        session.saveOrUpdate (object);
        endTransaction ();
    } catch (ConstraintViolationException e) {
        rollbackTransaction ();
        return false;
    } catch (Exception e) {
        rollbackTransaction ();
        e.printStackTrace ();
        return false;
    } finally {
        closeHibernateSession ();
    }
    return true;
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT o FROM Order o");
        Collection < Order > collection = (Collection < Order >) query.getResultList ();
        for (Order order : collection) {
            System.out.println ("found: " + order);
            for (OrderItem item : order.getItems ()) {
                System.out.println ("  with item: " + item);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=307=-----==

private boolean actualizarBZSALIDA (Connection conn) throws SQLException, ClassNotFoundException, Exception {
    boolean generado = false;
    PreparedStatement ps = null;
    Date fechaSystem = new Date ();
    DateFormat aaaammdd = new SimpleDateFormat ("yyyyMMdd");
    DateFormat hhmmss = new SimpleDateFormat ("HHmmss");
    String entidad1Valor = "";
    int entidad2Valor = 0;
    String remitenteValor = "";
    if (hayVisadoRemitente) {
        if (entidad1.trim ().equals ("")) {
            remitenteValor = remitente;
            entidad1Valor = " ";
            entidad2Valor = 0;
        }
        else {
            remitenteValor = "";
            entidad1Valor = entidad1;
            entidad2Valor = entidad2;
        }
    }
    String actualizaBZSALIDA = "UPDATE BZSALIDA SET FZSFACTU=? " + ((hayVisadoExtracto && idiomaExtracto.equals ("1")) ? ", FZSCONEN=?" : "") + ((hayVisadoExtracto && ! idiomaExtracto.equals ("1")) ? ", FZSCONE2=?" : "") + ((hayVisadoRemitente) ? ", FZSREMIT=?, FZSCENTI=?, FZSNENTI=?" : "") + " WHERE FZSNUMEN=? AND FZSCAGCO=? AND FZSANOEN=?";
    try {
        ps = conn.prepareStatement (actualizaBZSALIDA);
        int contador = 1;
        ps.setInt (contador ++, Integer.parseInt (aaaammdd.format (fechaSystem)));
        if (hayVisadoExtracto) {
            ps.setString (contador ++, extracto);
        }
        if (hayVisadoRemitente) {
            ps.setString (contador ++, remitenteValor);
            ps.setString (contador ++, entidad1Valor);
            ps.setInt (contador ++, entidad2Valor);
        }
        ps.setInt (contador ++, numeroRegistro);
        ps.setInt (contador ++, oficina);
        ps.setInt (contador ++, anoSalida);
        int registrosAfectados = ps.executeUpdate ();
        ps.close ();
        generado = (registrosAfectados > 0) ? true : false;
        DateFormat sss = new SimpleDateFormat ("S");
        String ss = sss.format (fechaSystem);
        int fzahsis = Integer.parseInt (hhmmss.format (fechaSystem) + ss);
        String Stringsss = sss.format (fechaSystem);
        switch (Stringsss.length ()) {
            case (1) :
                Stringsss = "00" + Stringsss;
                break;
            case (2) :
                Stringsss = "0" + Stringsss;
                break;
        }
        int horamili = Integer.parseInt (hhmmss.format (fechaSystem) + Stringsss);
        int fzafsis = Integer.parseInt (aaaammdd.format (fechaSystem));
        logLopdBZSALIDA ("UPDATE", usuarioModificacion, fzafsis, horamili, numeroRegistro, anoSalida, oficina);
    } catch (Exception e) {
        generado = false;
        System.out.println ("Error: " + e.getMessage ());
        e.printStackTrace ();
        throw new Exception ("S'ha produ\357t un error actualizant BZSALIDA");
    }
    return generado;
}


public static NotaFiscal insert (NotaFiscal objNF) {
    final Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    int result;
    if (c == null) {
        return null;
    }
    if (objNF == null) {
        return null;
    }
    try {
        c.setAutoCommit (false);
        String sql = "";
        int idNotaFiscal;
        idNotaFiscal = NotaFiscalDAO.getLastCodigo ();
        if (idNotaFiscal < 1) {
            return null;
        }
        sql = "INSERT INTO nota_fiscal " + "(id_nota_fiscal, id_fornecedor, total, data_emissao, data_cadastro, numero) " + "VALUES(?, ?, TRUNCATE(?,2), STR_TO_DATE(?,'%d/%m/%Y'), now(), ?) ";
        pst = c.prepareStatement (sql);
        pst.setInt (1, idNotaFiscal);
        pst.setLong (2, objNF.getFornecedor ().getCodigo ());
        pst.setString (3, new DecimalFormat ("#0.00").format (objNF.getValor ()));
        pst.setString (4, objNF.getDataEmissaoFormatada ());
        pst.setString (5, objNF.getNumero ());
        result = pst.executeUpdate ();
        pst = null;
        if (result > 0) {
            Iterator < ItemNotaFiscal > itINF = (objNF.getItemNotaFiscal ()).iterator ();
            while ((itINF != null) && (itINF.hasNext ())) {
                ItemNotaFiscal objINF = (ItemNotaFiscal) itINF.next ();
                sql = "";
                sql = "INSERT INTO item_nota_fiscal " + "(id_nota_fiscal, id_produto, quantidade, subtotal) " + "VALUES(?, ?, ?, TRUNCATE(?,2))";
                pst = c.prepareStatement (sql);
                pst.setInt (1, idNotaFiscal);
                pst.setInt (2, objINF.getProduto ().getCodigo ());
                pst.setInt (3, objINF.getQuantidade ());
                pst.setString (4, new DecimalFormat ("#0.00").format (objINF.getSubtotal ()));
                result = pst.executeUpdate ();
            }
        }
        c.commit ();
        objNF.setCodigo (idNotaFiscal);
    } catch (final Exception e) {
        try {
            c.rollback ();
        } catch (final Exception e1) {
            System.out.println ("[NotaFiscalDAO.insert.rollback] Erro ao inserir -> " + e1.getMessage ());
        }
        System.out.println ("[NotaFiscalDAO.insert] Erro ao inserir -> " + e.getMessage ());
        objNF = null;
    } finally {
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objNF;
}


-----Function Pair=308=-----==

public void testPreparedStatement0008 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0008              " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0008 values (?, ?)");
    final int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pstmt.setInt (1, i);
        pstmt.setString (2, theString.substring (0, i));
        count += pstmt.executeUpdate ();
    }
    assertEquals (count, rowsToAdd);
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("select s, i from #t0008");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
        assertEquals (rs.getString (1).trim ().length (), rs.getInt (2));
    }
    assertTrue (count == rowsToAdd);
    stmt.close ();
    pstmt.close ();
}


public void test1899Date () throws Exception {
    Calendar originalValue = Calendar.getInstance ();
    originalValue.set (Calendar.MONTH, Calendar.DECEMBER);
    originalValue.set (Calendar.DAY_OF_MONTH, 31);
    originalValue.set (Calendar.YEAR, 1899);
    originalValue.set (Calendar.HOUR_OF_DAY, 23);
    originalValue.set (Calendar.MINUTE, 59);
    originalValue.set (Calendar.SECOND, 59);
    originalValue.set (Calendar.MILLISECOND, 990);
    PreparedStatement pstmt = con.prepareStatement ("select ?");
    pstmt.setTimestamp (1, new Timestamp (originalValue.getTime ().getTime ()));
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    final long expectedTime = originalValue.getTime ().getTime ();
    final long actualTime = getTimeInMs (rs);
    assertEquals (expectedTime, actualTime);
    assertFalse (rs.next ());
    rs.close ();
    pstmt.close ();
}


-----Function Pair=309=-----==

public ArrayList getAssignmentsByPeerviewer (String pvId, Vector statuses) throws Exception {
    if (userCurrentRole.equals ("Author")) throw new Exception ("Invalid action: get assignments");
    Assignment a;
    ArrayList as = new ArrayList ();
    String sql = "select event.*,usr.first_name from event,usr where event.ACTION_ID='assigned' ";
    int n = statuses.size ();
    if (n != 0) {
        sql += " AND (";
        for (int i = 0; i < n; i ++) {
            if (i > 0) sql += " OR ";
            sql += "event.reviewText='" + (String) statuses.get (i) + "'";
        }
        sql += " ) ";
    }
    if (userCurrentRole.equals ("Peer-viewer")) sql += " AND event.SUBJECTUSR_ID='" + userId + "'";
    else sql += " AND event.SUBJECTUSR_ID='" + pvId + "'";
    sql += " AND usr.USR_ID=event.SUBJECTUSR_ID";
    sql += " ORDER BY event.reviewText";
    PreparedStatement prepStmt = null;
    try {
        con = database.getConnection ();
        prepStmt = con.prepareStatement (sql);
        ResultSet es = prepStmt.executeQuery ();
        while (es.next ()) {
            a = new Assignment (es.getString ("EVENT_ID"), es.getString ("eventDate"), es.getString ("PROPOSAL_ID"), es.getString ("USR_ID"), es.getString ("USR_ID"), es.getString ("SUBJECTUSR_ID"), es.getString ("first_name"), es.getString ("publicComments"), es.getString ("reviewText"));
            as.add (a);
        }
        prepStmt.close ();
        con.close ();
        return as;
    } catch (Exception e) {
        if (! con.isClosed ()) {
            prepStmt.close ();
            con.close ();
        }
        throw new Exception ("At: Manager.getAssignmentsByPeerviewer" + "\n" + e.getMessage () + "\n" + sql);
    }
}


public static boolean tableExistsAndHaveQuery (EboContext p_eboctx, String tablename, String query) throws boRuntimeException {
    boolean ret = false;
    try {
        Connection cn = p_eboctx.getConnectionData ();
        PreparedStatement pstm = cn.prepareStatement ("SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE upper(TABLE_NAME)=? AND TABLE_SCHEMA=database()");
        pstm.setString (1, tablename);
        ResultSet rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            ret = true;
        }
        if (ret) {
            if ((query != null) && (query.length () > 0)) {
                PreparedStatement pstm2 = cn.prepareStatement ("SELECT COUNT(*) FROM " + tablename + " WHERE " + query);
                ResultSet rslt2 = pstm2.executeQuery ();
                while (rslt2.next ()) {
                    ret = rslt2.getLong (1) > 0;
                }
                rslt2.close ();
                pstm2.close ();
            }
        }
        rslt.close ();
        pstm.close ();
    } catch (Exception e) {
        throw new boRuntimeException ("dbmagf.tableExists", "BO-1304", e);
    } finally {
    }
    return ret;
}


-----Function Pair=310=-----==

public void assign () throws Exception {
    if (proposalIds.equals ("") || usrIds.equals ("")) throw new Exception ("No proposal or peer-viewer selected.");
    String [] pids = proposalIds.split (",");
    String [] uids = usrIds.split (",");
    int pnum = pids.length;
    int unum = uids.length;
    if (pnum == 0 || unum == 0) throw new Exception ("No proposal or peer-viewer selected.");
    int i, j;
    String pStr = "update proposal set current_status='assigned' where ";
    for (i = 0; i < pnum; i ++) {
        if (i > 0) pStr += " OR ";
        pStr += "PROPOSAL_ID=" + pids [i];
    }
    Calendar date = Calendar.getInstance ();
    int day = date.get (Calendar.DATE);
    int month = date.get (Calendar.MONTH);
    int year = date.get (Calendar.YEAR);
    String dt = String.valueOf (year) + "-" + String.valueOf (month + 1) + "-" + String.valueOf (day);
    PreparedStatement prepStmt = null;
    try {
        con = database.getConnection ();
        con.setAutoCommit (false);
        prepStmt = con.prepareStatement (pStr);
        prepStmt.executeUpdate ();
        pStr = "insert into event (summary,document1,document2,document3,publicComments,privateComments,ACTION_ID,eventDate,ROLE_ID,reviewText,USR_ID,PROPOSAL_ID,SUBJECTUSR_ID) values " + "('','','','','','','assigned','" + dt + "',2,'new'," + userId + ",?,?)";
        prepStmt = con.prepareStatement (pStr);
        for (i = 0; i < pnum; i ++) {
            for (j = 0; j < unum; j ++) {
                prepStmt.setString (1, pids [i]);
                prepStmt.setString (2, uids [j]);
                prepStmt.executeUpdate ();
            }
        }
        con.commit ();
    } catch (Exception e) {
        if (! con.isClosed ()) {
            con.rollback ();
            prepStmt.close ();
            con.close ();
        }
        throw e;
    }
    event_Form fr = new event_Form ();
    for (j = 0; j < unum; j ++) {
        fr.setUSR_ID (userId);
        fr.setSUBJECTUSR_ID (uids [j]);
        systemManager.handleEvent (SystemManager.EVENT_PROPOSAL_ASSIGNED, fr, null, null);
    }
}


public void doCallableStatementExecute (Connection conn, String id) throws SQLException {
    try {
        int key = getNextKey ();
        String bValue = "doCallableStatementExecute:" + id + ":" + testId;
        boolean eu = props.getProperty ("callablestatement.executeUpate", "true").equals ("true");
        CallableStatement s1;
        if (key >= MAX_KEY_VALUE) {
            key = key % MAX_KEY_VALUE;
            s1 = conn.prepareCall ("{call delete_many_threads(?)}");
            s1.setInt (1, key);
            execute (s1, ! eu);
            s1.close ();
        }
        s1 = conn.prepareCall ("{call insert_many_threads(?, ?)}");
        s1.setInt (1, key);
        s1.setString (2, bValue);
        execute (s1, ! eu);
        s1.close ();
        s1 = conn.prepareCall ("{call select_many_threads(?)}");
        s1.setInt (1, key);
        assertEquals (key, execute (s1, true));
        s1.close ();
        s1 = conn.prepareCall ("{call update_many_threads(?, ?)}");
        s1.setString (1, "&" + bValue);
        s1.setInt (2, key + 1);
        execute (s1, ! eu);
        s1.close ();
        if (! conn.getAutoCommit ()) {
            conn.commit ();
        }
    } catch (SQLException e) {
        if (! conn.getAutoCommit ()) {
            try {
                conn.rollback ();
            } catch (SQLException e2) {
            }
        }
    }
}


-----Function Pair=311=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoSingleTextCheckList3 coSingleTextCheckList) {
    CoSingleTextCheckList3DAO coSingleTextCheckListDAO = new CoSingleTextCheckList3DAO ();
    try {
        log.info ("Actualizando la tÔøΩcnica: " + coSingleTextCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        coSingleTextCheckListDAO.update (coSingleTextCheckList);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coSingleTextCheckList);
        Object [] arrayParam = {coSingleTextCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.update.success"), arrayParam));
        log.info ("Se actualizo la tÔøΩcnica con ÔøΩxito: " + coSingleTextCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la tÔøΩcnica: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


private void prepare () throws SQLException {
    String randomIdentifier = (Double.toString (Math.random ())).substring (2, 6);
    this.tempIncTableName = String.valueOf ("TEMP_INC_" + System.currentTimeMillis () + randomIdentifier);
    this.setUpTables (this.tempIncTableName);
    this.selectAllFromTempInc = this.dao.getStatement ("SUBSET_DB", "SELECT_FROM_TABLE");
    this.selectAllFromTempInc = this.dao.getStatement (this.selectAllFromTempInc, 1, this.tempIncTableName);
    this.tempExcTableName = String.valueOf ("TEMP_EXC_" + (System.currentTimeMillis () + 1) + randomIdentifier);
    this.setUpTables (this.tempExcTableName);
    this.selectAllFromTempExc = this.dao.getStatement ("SUBSET_DB", "SELECT_FROM_TABLE");
    this.selectAllFromTempExc = this.dao.getStatement (this.selectAllFromTempExc, 1, this.tempExcTableName);
    this.tempResTableName = String.valueOf ("TEMP_RES_" + (System.currentTimeMillis () + 1) + randomIdentifier);
    this.setUpTables (this.tempResTableName);
    tempIntersectTbl1 = "TEMP_DTS_SUBSET_INTERSECT1";
    setUpTables (tempIntersectTbl1);
    tempIntersectTbl2 = "TEMP_DTS_SUBSET_INTERSECT2";
    setUpTables (tempIntersectTbl2);
    tempMinusTbl1 = "TEMP_DTS_SUBSET_MINUS1";
    setUpTables (tempMinusTbl1);
    tempMinusTbl2 = "TEMP_DTS_SUBSET_MINUS2";
    setUpTables (tempMinusTbl2);
}


-----Function Pair=312=-----==

public boolean deleteThreads (Threads thread) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.delete (thread);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


private void doUpdateTaskX (HttpSession session) {
    Db db = null;
    Connection conn = null;
    String sql = "";
    String user = (String) session.getAttribute ("_portal_login");
    String id = getParam ("task_id");
    String task_description = getParam ("description");
    String year1 = getParam ("year1");
    String month1 = getParam ("month1");
    String day1 = getParam ("day1");
    String hour1 = getParam ("hour1");
    String minute1 = getParam ("minute1");
    String hour2 = getParam ("hour2");
    String minute2 = getParam ("minute2");
    int ispublic = ! "".equals (getParam ("public")) ? Integer.parseInt (getParam ("public")) : 1;
    String task_date = year1 + "-" + fmt (month1) + "-" + fmt (day1);
    String [] invitelist = request.getParameterValues ("invitelist");
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        SQLRenderer r = new SQLRenderer ();
        {
            sql = "UPDATE planner_task SET task_description = '" + task_description + "', " + "task_date = '" + task_date + " WHERE task_id = '" + id + "'";
            stmt.executeUpdate (sql);
        }
        {
            sql = "DELETE FROM planner_task_invite WHERE task_id = '" + id + "' ";
            stmt.executeUpdate (sql);
        }
        if (invitelist != null) {
            for (int i = 0; i < invitelist.length; i ++) {
                r = new SQLRenderer ();
                r.add ("task_id", id);
                r.add ("user_id", invitelist [i]);
                r.add ("inviter_id", user);
                r.add ("allow_edit", 0);
                sql = r.getSQLInsert ("planner_task_invite");
                stmt.executeUpdate (sql);
            }
        }
        conn.commit ();
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
    } catch (SQLException ex) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (SQLException rex) {
            }
        }
        System.out.println (ex.getMessage () + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=313=-----==

public boolean updateSubsetExpression (int subsetId, String user, String expr, DTSPermission permit) throws SQLException, PermissionException {
    int origTransLevel = Utilities.beginTransaction (this.conn);
    try {
        Subset item = getSubset (subsetId);
        DefaultMutableTreeNode node = SETreeNodeConstructor.getSETreeNode (expr);
        Dag dag = TreeDagTranslator.translateTreeToDag (node);
        long id = this.getSubsetGeneralDao ().insertSubsetExpression (this.conn, subsetId, expr);
        updateSubsetModInfo (subsetId, user, System.currentTimeMillis ());
        saveSubsetRefInfo (item, dag);
        this.conn.commit ();
        return (id > 0 ? true : false);
    } catch (Exception ex) {
        this.conn.rollback ();
        throw new SQLException (ex.getMessage ());
    } finally {
        Utilities.endTransaction (this.conn, origTransLevel);
    }
}


protected boolean isExist (Connection con) throws Exception {
    boolean returnValue = false;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT role_id FROM " + Common.ROLE_AUTHORITY_TABLE + " WHERE role_id = ? " + "AND authority_id = ?";
    try {
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.role.getRoleID ());
        ps.setInt (2, this.authority.getAuthorityID ());
        result = ps.executeQuery ();
        if (! result.next ()) {
            returnValue = false;
        }
        else {
            int nTemp = result.getInt (1);
            returnValue = true;
        }
    } catch (SQLException se) {
        throw new CesSystemException ("RoleAuthority.isExist(): SQLException: \n\t" + se);
    } finally {
        closeResultSet (result);
        closePreparedStatement (ps);
    }
    return returnValue;
}


-----Function Pair=314=-----==

public void insertUser (final List < NewUser > newUsers) {
    try {
        connection.setAutoCommit (false);
        final Map < String, PasswordAndSalt > pass = new HashMap < String, PasswordAndSalt > ();
        final Map < String, List < RealmWithEncryptedPass > > realmPass = new HashMap < String, List < RealmWithEncryptedPass > > ();
        final List < String > userDirs = new ArrayList < String > ();
        Iterator < NewUser > iter = newUsers.iterator ();
        NewUser user;
        Realm realm;
        String username;
        PasswordHasher ph;
        while (iter.hasNext ()) {
            user = iter.next ();
            username = user.username.toLowerCase (locale);
            ph = PasswordFactory.getInstance ().getPasswordHasher ();
            pass.put (user.username, new PasswordAndSalt (ph.hashPassword (user.password), ph.getSalt ()));
            realmPass.put (user.username, new ArrayList < RealmWithEncryptedPass > ());
            realmPass.get (user.username).add (new RealmWithEncryptedPass (cm.getRealm ("null"), PasswordFactory.getInstance ().getPasswordHasher ().hashRealmPassword (username, "", user.password)));
            if (user.realms != null) {
                for (String realmName : user.realms) {
                    realm = cm.getRealm (realmName);
                    realmPass.get (user.username).add (new RealmWithEncryptedPass (realm, PasswordFactory.getInstance ().getPasswordHasher ().hashRealmPassword (username, realm.getFullRealmName (), user.password)));
                }
                user.realms = null;
            }
        }
        new ProcessEnvelope ().executeNull (new ExecuteProcessAbstractImpl (connection, false, false, true, true) {
            @Override
            public void executeProcessReturnNull () throws SQLException {
                psImpl = connImpl.prepareStatement (sqlCommands.getProperty ("user.add"), Statement.RETURN_GENERATED_KEYS);
                Iterator < NewUser > iter = newUsers.iterator ();
                NewUser user;
                DomainDb domain = null;
                while (iter.hasNext ()) {
                    user = iter.next ();
                    psImpl.setString (1, user.username);
                    psImpl.setString (2, user.username.toLowerCase (locale));
                    if (domain == null || (domain.getDomainId () != user.domainId)) {
                        domain = (DomainDb) cmDB.getDomain (user.domainId);
                    }
                    userDirs.add (user.username + '@' + domain.getDomainName ());
                    psImpl.setInt (3, user.domainId);
                    psImpl.setString (4, pass.get (user.username).password);
                    psImpl.setString (5, pass.get (user.username).salt);
                    psImpl.executeUpdate ();
                    rsImpl = psImpl.getGeneratedKeys ();
                    if (rsImpl.next ()) {
                        user.userId = rsImpl.getInt (1);
                        rsImpl.close ();
                    }
                    else {
                        throw new SQLException ("Need to have a user id generated.");
                    }
                }
            }
        }
        );
        new ProcessEnvelope ().executeNull (new ExecuteProcessAbstractImpl (connection, false, false, true, true) {
            @Override
            public void executeProcessReturnNull () throws SQLException {
                psImpl = connImpl.prepareStatement (sqlCommands.getProperty ("realm.addUser"));
                Iterator < NewUser > iter = newUsers.iterator ();
                NewUser user;
                List < RealmWithEncryptedPass > list;
                RealmWithEncryptedPass rwep;
                RealmDb realm;
                while (iter.hasNext ()) {
                    user = iter.next ();
                    list = realmPass.get (user.username);
                    if (list != null) {
                        Iterator < RealmWithEncryptedPass > iter1 = list.iterator ();
                        while (iter1.hasNext ()) {
                            rwep = iter1.next ();
                            realm = (RealmDb) rwep.realm;
                            psImpl.setInt (1, realm.getRealmId ());
                            psImpl.setInt (2, user.userId);
                            psImpl.setInt (3, user.domainId);
                            psImpl.setString (4, rwep.password);
                            psImpl.executeUpdate ();
                        }
                    }
                }
            }
        }
        );
        connection.commit ();
        Iterator < String > iterator = userDirs.iterator ();
        while (iterator.hasNext ()) {
            cm.requestDirCreation (new File (cm.getUsersDirectory (), iterator.next ()).getPath ());
        }
        cm.createDirectories ();
    } catch (GeneralSecurityException e) {
        log.error (e);
        if (connection != null) {
            try {
                connection.rollback ();
            } catch (SQLException ex) {
            }
        }
        throw new RuntimeException ("Error updating Realms. Unable to continue Operation.");
    } catch (SQLException sqle) {
        log.error (sqle);
        if (connection != null) {
            try {
                connection.rollback ();
            } catch (SQLException ex) {
            }
        }
    } finally {
        if (connection != null) {
            try {
                connection.setAutoCommit (true);
            } catch (SQLException ex) {
            }
        }
    }
}


public void commit () throws DataServiceException {
    long commitStartTime = System.currentTimeMillis ();
    mConnection = openConnection ();
    if (System.currentTimeMillis () - commitStartTime > 50) Log.printWarning (this, "Long connection open time: " + (System.currentTimeMillis () - commitStartTime) + " ms");
    try {
        try {
            if (mConnectionInfo.containsKey ("catalog")) mConnection.setCatalog ((String) mConnectionInfo.get ("catalog"));
        } catch (SQLException e) {
        }
        mConnection.setAutoCommit (false);
        Enumeration dataOperations = this.getOperations ();
        while (dataOperations.hasMoreElements ()) {
            DataOperation operation = (DataOperation) dataOperations.nextElement ();
            switch (operation.getOperationType ()) {
                case DataOperation.LOAD :
                    executeLoad (mConnection, operation.getEntity (), operation.getQualifier ());
                    break;
                case DataOperation.QUERY :
                    executeQuery (mConnection, operation.getDataQuery (), operation.getEntitySelection ());
                    break;
                case DataOperation.STORE :
                    if (operation.getEntity ().isPersistent ()) executeUpdate (mConnection, operation.getEntity (), operation.getQualifier ());
                    else executeInsert (mConnection, operation.getEntity ());
                    break;
                case DataOperation.DELETE :
                    executeDelete (mConnection, operation.getEntity ());
                    break;
                case DataOperation.REFRESH :
                    executeLoad (mConnection, operation.getEntity (), operation.getQualifier ());
                    break;
            }
        }
        mConnection.commit ();
        Log.print (this, "Commit time: " + (System.currentTimeMillis () - commitStartTime) + " ms");
        dataOperations = this.getOperations ();
        while (dataOperations.hasMoreElements ()) {
            DataOperation operation = (DataOperation) dataOperations.nextElement ();
            switch (operation.getOperationType ()) {
                case DataOperation.DELETE :
                    operation.getEntity ().clearStatusFlag (IEntity.DIRTY | IEntity.EMPTY | IEntity.PERSISTENT);
                    break;
                case DataOperation.STORE :
                    operation.getEntity ().setStatusFlag (IEntity.PERSISTENT);
                    operation.getEntity ().clearStatusFlag (IEntity.DIRTY | IEntity.EMPTY);
                    break;
                case DataOperation.REFRESH :
                case DataOperation.LOAD :
                case DataOperation.QUERY :
                    break;
            }
        }
    } catch (Exception e) {
        String rollbackMsg;
        try {
            mConnection.rollback ();
            rollbackMsg = "rollback succesfull";
        } catch (SQLException eSQL) {
            rollbackMsg = "rollback failed";
        }
        if (e instanceof DataServiceException) throw new DataServiceException ("Transaction failed, " + rollbackMsg, e, ((DataServiceException) e).getDescription ());
        else throw new DataServiceException ("Transaction failed, " + rollbackMsg + ": " + e.getClass ().getName () + " - " + e.getMessage (), e);
    } finally {
        closeConnection (mConnection);
        mConnection = null;
    }
}


-----Function Pair=315=-----==

public static SDW forMetrics (Db db, String metricOrGroupNames []) throws Exception {
    Bundle bundle = new Bundle ();
    try {
        db.enter ();
        PreparedStatement ps = db.prepareStatement ("SELECT DISTINCT b.e_bundle_id, b.xml_decl_path, b.xml_text FROM sdw.e_bundle b WHERE (b.e_bundle_id IN (SELECT n.bundle_id FROM sdw.e_metric_name n WHERE n.metric_name = ANY(?))) OR (b.e_bundle_id IN (SELECT g.bundle_id FROM sdw.e_metric_group g WHERE g.metric_group_name = ANY(?)));");
        SqlArray ary = new SqlArray (metricOrGroupNames);
        ps.setObject (1, ary);
        ps.setObject (2, ary);
        ResultSet rs = db.executeQuery (ps);
        if (rs.next ()) {
            do {
                loadMetricsCfg (bundle, rs.getString (2), rs.getString (3));
            }
            while (rs.next ());
        }
        else {
            StringBuffer sb = new StringBuffer ();
            sb.append ("Could not find configuration for ");
            if (metricOrGroupNames == null || metricOrGroupNames.length == 0) {
                sb.append ("< undefined metrics >");
            }
            else {
                for (int i = 0; i < metricOrGroupNames.length; ++ i) {
                    if (i > 0) sb.append (", ");
                    sb.append (metricOrGroupNames [i]);
                }
            }
            throw new IllegalStateException (sb.toString ());
        }
        return new SDW (bundle);
    } finally {
        db.exit ();
    }
}


protected int computeCheckoutTotal (Context context, Statement s) throws DataStoreException, SQLException {
    Object customer = CustomerAuthenticator.getCustomer (context);
    int result = - 1;
    StringBuffer q = new StringBuffer ("select ( sum( BIDSTATE.Amount) + ");
    q.append (" sum ( BIDSTATE.QShipping) + sum( BIDSTATE.QInsure) + ");
    q.append (" sum( BIDSTATE.VAT)) as Total from BID, BIDSTATE ");
    q.append (" where  BIDSTATE.Bid = BID.Bid ");
    q.append (" and ( BIDSTATE.BidStatus = ").append (BidStatus.ENQUIRY);
    q.append (" or BIDSTATE.BidStatus = ").append (BidStatus.QUOTATION).append (") ");
    q.append (" and BID.Customer = ").append (customer);
    q.append (" and BIDSTATE.BidState =  ");
    q.append (" ( select max( BIDSTATE.BidState) ").append ("from BIDSTATE ");
    q.append (" where Bid = BID.Bid) ");
    System.err.println ("==> Computing checksum: " + q.toString ());
    ResultSet r = s.executeQuery (q.toString ());
    if (r.next ()) {
        result = r.getInt ("Total");
    }
    else {
        throw new DataFormatException ("Found nothing in your basket");
    }
    return result;
}


-----Function Pair=316=-----==

static final void executeUpdate (Collection < String > queries, DBConnector connector) throws IOException {
    Connection con = null;
    Statement st = null;
    try {
        con = connector.getDB ();
        con.setAutoCommit (false);
        st = con.createStatement ();
        for (String s : queries) st.executeUpdate (s);
        con.commit ();
    } catch (SQLException e) {
        try {
            con.rollback ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
        throw new IOException (e.getMessage ());
    } finally {
        if (st != null) {
            try {
                st.close ();
            } catch (SQLException ignore) {
            }
        }
        if (con != null) {
            try {
                con.close ();
            } catch (SQLException ignore) {
            }
        }
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=317=-----==

public HashSet < YearOfStudy > findByAcademicYearId (Integer academicYearID) throws SelectException, DBConnectionException {
    HashSet < YearOfStudy > yosSet = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (YearOfStudyDAO.TABLE_NAME + " yos"));
    tablesFrom.add (new SQLWord (HolidaysDAO.TABLE_NAME + " h"));
    tablesFrom.add (new SQLWord (AcademicYearDAO.TABLE_NAME + " ay"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("ay.ACADEMIC_YEAR_ID", academicYearID);
    critWhere.addCriterion ("h.ACADEMIC_YEAR_ID", new SQLWord ("ay.ACADEMIC_YEAR_ID"));
    critWhere.addCriterion ("h.YEAR_STUDY_ID", new SQLWord ("yos.YEAR_STUDY_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            yosSet = new HashSet < YearOfStudy > ();
            while (result.next ()) {
                YearOfStudy yos = new YearOfStudy ();
                yos = new YearOfStudy (result.getString ("YEAR_STUDY_NAME"));
                yos.setAcaYear (null);
                yos.setDescription (result.getString ("YEAR_STUDY_DESCRIPTION"));
                yos.setDurationSession (result.getFloat ("YEAR_STUDY_DURATION_SESSION"));
                yos.setGroupList (null);
                yos.setHolidays (null);
                yos.setId (result.getInt ("YEAR_STUDY_ID"));
                yos.setNbSessionPM (result.getInt ("YEAR_STUDY_NB_SESSIONPM"));
                yos.setNbSessionsAM (result.getInt ("YEAR_STUDY_NB_SESSIONAM"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return yosSet;
}


public List < FieldVO > findTableFields (String tableName) {
    List < FieldVO > fieldVOs = new ArrayList < FieldVO > ();
    String sql = "SHOW FIELDS FROM " + tableName;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        conn = session.connection ();
        pstmt = conn.prepareStatement (sql);
        rs = pstmt.executeQuery ();
        FieldVO fieldVO = null;
        while (rs.next ()) {
            fieldVO = new FieldVO ();
            fieldVO.setField (rs.getString ("Field"));
            fieldVO.setType (rs.getString ("Type"));
            fieldVO.setAllowNull (rs.getString ("Null"));
            fieldVO.setKey (rs.getString ("Key"));
            fieldVO.setDefaultValue (rs.getString ("Default"));
            fieldVO.setExtra (rs.getString ("Extra"));
            fieldVOs.add (fieldVO);
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    } finally {
        try {
            if (transaction != null) {
                transaction = null;
            }
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return fieldVOs;
}


-----Function Pair=318=-----==

private List execQuery (String queryString) {
    List result = null;
    Transaction tx = null;
    try {
        Session session = _factory.getCurrentSession ();
        tx = session.beginTransaction ();
        Query query = session.createQuery (queryString);
        if (query != null) result = query.list ();
    } catch (JDBCConnectionException jce) {
        _log.error ("Caught Exception: Couldn't connect to datasource - " + "starting with an empty dataset");
    } catch (HibernateException he) {
        _log.error ("Caught Exception: Error executing query: " + queryString, he);
        if (tx != null) tx.rollback ();
    }
    return result;
}


String getMetaValue (Connection conn, String id, int host, Integer prop, int type) throws SQLException {
    PreparedStatement stmt = null;
    try {
        stmt = conn.prepareStatement ("SELECT meta.value FROM meta " + "WHERE meta.host = ? " + "AND meta.type = ? " + "AND meta.id = ? " + "AND meta.prop " + (prop == null ? "IS NULL" : "= ?"));
        stmt.setInt (1, host);
        stmt.setInt (2, type);
        stmt.setString (3, id);
        if (prop != null) {
            stmt.setInt (4, prop);
        }
        ResultSet rs = stmt.executeQuery ();
        return rs.next () ? rs.getString (1) : null;
    } finally {
        StorageUtils.close (stmt);
    }
}


-----Function Pair=319=-----==

public Vector getChildType (String childId) throws Exception {
    Vector allOrg = new Vector ();
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = " SELECT child_organize_type FROM " + Common.ORGANIZE_TYPE_RELATION_TABLE + " WHERE '" + childId + "' in (select parent_organize_type from t_sys_organize_type_relation where child_organize_type != '" + OrganizeType.USER + "') ";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        while (result.next ()) {
            String [] Obj = new String [1];
            Obj [0] = (String) result.getObject (1);
            allOrg.addElement (Obj);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        close (dbo, ps, result);
    }
    return allOrg;
}


protected boolean isExist () throws Exception {
    boolean returnValue = false;
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT role_id FROM " + Common.ROLE_AUTHORITY_TABLE + " WHERE role_id = ? " + "AND authority_id = ?";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.role.getRoleID ());
        ps.setInt (2, this.authority.getAuthorityID ());
        result = ps.executeQuery ();
        if (! result.next ()) {
            returnValue = false;
        }
        else {
            int nTemp = result.getInt (1);
            returnValue = true;
        }
    } catch (SQLException se) {
        throw new CesSystemException ("RoleAuthority.isExist(): SQLException: \n\t" + se);
    } finally {
        close (dbo, ps, result);
    }
    return returnValue;
}


-----Function Pair=320=-----==

public SessionType store (SessionType obj) throws InsertException, DBConnectionException, XmlIOException {
    SessionType toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getName ());
    values.add (obj.getEquivTuto ());
    values.add (obj.getAcronym ());
    try {
        stmt.executeUpdate (new InsertQuery (TABLE_NAME, values).toString ());
        toReturn = findByAcronym (obj.getAcronym ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


public RestServiceResult create (RestServiceResult result, CoMatrixQuestion coMatrixQuestion) {
    CoMatrixQuestionDAO coMatrixQuestionDAO = new CoMatrixQuestionDAO ();
    try {
        coMatrixQuestion.setMatrixId (getSequence ("sq_co_matrix_question"));
        EntityManagerHelper.beginTransaction ();
        coMatrixQuestionDAO.save (coMatrixQuestion);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMatrixQuestion);
        Object [] args = {coMatrixQuestion.getCoQuestion ().getQuestionName ()};
        result.setMessage (MessageFormat.format (bundle.getString ("matrixQuestion.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar la matriz de preguntas: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


-----Function Pair=321=-----==

protected Object retrieveBean (String sql, Object bean) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("querying " + sql + "...");
    }
    Connection connection = null;
    try {
        connection = dataSource.getConnection ();
        Statement statement = connection.createStatement ();
        ResultSet rs = statement.executeQuery (sql);
        if (! rs.next ()) {
            LOG.warn ("No row returned, thus a empty bean is returned.");
            return bean;
        }
        else {
            ResultSetMetaData metadata = rs.getMetaData ();
            for (int i = 0; i < metadata.getColumnCount (); i ++) {
                String propertyName = metadata.getColumnLabel (i + 1);
                try {
                    BeanUtil.setProperty (bean, propertyName, rs.getObject (i + 1));
                } catch (Throwable e) {
                    LOG.warn ("Unable to  set property '" + propertyName + "' on bean " + bean + ": " + e);
                }
            }
            if (rs.next ()) {
                LOG.warn ("One row expected, but more than one row returned from sql: " + sql);
            }
            return bean;
        }
    } catch (SQLException e) {
        LOG.error ("Error while calling retrieve(): " + e, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


public RestServiceResult listCourseForUser (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    Set < CoCourse > set = new HashSet < CoCourse > ();
    List < CoCourse > listCourse = new ArrayList < CoCourse > ();
    if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_STUDENT)) {
        List < CoCourseUser > list = new ArrayList < CoCourseUser > (maUser.getCoCourseUsers ());
        for (CoCourseUser coCourseUser : list) {
            set.add (coCourseUser.getCoCourse ());
        }
    }
    else if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_TEACHER)) {
        set = maUser.getCoCoursesForUserId ();
    }
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("course.list.notFound"));
    }
    else {
        listCourse.addAll (set);
        Object [] array = {listCourse.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.list.success"), array));
    }
    serviceResult.setObjResult (listCourse);
    return serviceResult;
}


-----Function Pair=322=-----==

public boolean hasChildOrg () {
    boolean flag = false;
    OrganizeType orgType = new OrganizeType (this.organizeTypeID);
    try {
        Vector vChildType = orgType.getChildOrganizeType ();
        int nNum = vChildType.size ();
        if (nNum > 0) {
            for (int i = 0; i < nNum; i ++) {
                OrganizeType childType = (OrganizeType) vChildType.get (i);
                if (childType.getOrganizeTypeID ().equals (OrganizeType.USER)) {
                    continue;
                }
                else {
                    flag = true;
                    break;
                }
            }
        }
    } catch (Exception e) {
    }
    return flag;
}


public final void saveOrUpdateAll (final Collection < ? extends T > objects) throws CannotConnectToDatabaseException {
    if (objects != null && ! objects.isEmpty ()) {
        final Session s = this.currentSession ();
        Transaction tx = null;
        try {
            tx = s.beginTransaction ();
            for (T obj : objects) {
                s.saveOrUpdate (obj);
            }
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (HibernateException he) {
            tx.rollback ();
            LOGGER.error ("Failed to save or update entities - transaction was rolled back.", he);
            throw he;
        } finally {
            s.close ();
        }
    }
}


-----Function Pair=323=-----==

public Vector getSpecialOrg (String orgTypeID) throws Exception {
    Vector allOrg = new Vector ();
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_TABLE + " " + "WHERE organize_type_id='" + orgTypeID + "' " + "ORDER BY show_order";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        int i = 1;
        ValueAsc va = new ValueAsc (i);
        while (result.next ()) {
            i = 1;
            va.setStart (i);
            Organize oTemp = Organize.generateOrganize (result, va);
            allOrg.addElement (oTemp);
        }
        va = null;
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.getSpecialOrg(String orgTypeID): SQLException:  " + se);
    } finally {
        close (dbo, ps, result);
    }
    return allOrg;
}


public Onlinetime findOnlinetimeById (int onlinetimeId) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Onlinetime onlinetime = (Onlinetime) session.get (Onlinetime.class, onlinetimeId);
        tr.commit ();
        return onlinetime;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=324=-----==

public String updateAssociationType (Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException {
    String oldId = root.getAttribute (ID);
    String oldNamespaceId = root.getAttribute (NAMESPACE_ID);
    checkPermission (permit, oldNamespaceId);
    NodeList children = root.getChildNodes ();
    int len = children.getLength ();
    Node node = children.item (0);
    String name = getAttribute (node, NAME);
    String id = getAttribute (node, ID);
    String code = getAttribute (node, CODE);
    String namespaceId = getAttribute (node, NAMESPACE_ID);
    String connectType = getAttribute (node, CONNECT_TYPE);
    String purpose = getAttribute (node, PURPOSE);
    String inverseName = getAttribute (node, INVERSE_NAME);
    checkPermission (permit, namespaceId);
    assertUpdate (oldId.equals (id), "old Id: " + oldId + " should be same as new id: " + id);
    assertUpdate (oldNamespaceId.equals (namespaceId), "old namespaceId: " + oldNamespaceId + " should be same as new namespaceId: " + namespaceId);
    updateSt.setString (1, name);
    updateSt.setString (2, connectType);
    updateSt.setString (3, purpose);
    updateSt.setString (4, inverseName);
    updateSt.setInt (5, Integer.parseInt (oldId));
    updateSt.setInt (6, Integer.parseInt (oldNamespaceId));
    int result = updateSt.executeUpdate ();
    StringBuffer buff = new StringBuffer (200);
    appendDtd (buff, com.apelon.dts.dtd.common.DTD.ASSOCIATIONTYPE, "associationType");
    getAssociationType ("ID", id, namespaceId, buff);
    return buff.toString ();
}


public boolean updateBbcodes (Bbcodes b) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (b);
        session.flush ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
            tr = null;
        }
        he.printStackTrace ();
        return false;
    }
    return true;
}


-----Function Pair=325=-----==

public void movePrior (String [] showOrder, String [] orgID, String targetShowOrder, String targetOrgID) throws Exception {
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    int moveCount = showOrder.length;
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    String strQuery = "select show_order from " + Common.ORGANIZE_TABLE + " where show_order=" + showOrder [moveCount - 1] + " and organize_id= '" + orgID [moveCount - 1] + "'";
    try {
        con = dbo.getConnection ();
        con.setAutoCommit (false);
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        int maxOrderNo = 0;
        if (result.next ()) {
            maxOrderNo = result.getInt (1);
        }
        String [] sqls = new String [moveCount + 1];
        sqls [0] = "update " + Common.ORGANIZE_TABLE + " set show_order=" + maxOrderNo + " where show_order=" + targetShowOrder + " and organize_id= '" + targetOrgID + "'";
        for (int i = 0; i < showOrder.length; i ++) {
            sqls [i + 1] = "update " + Common.ORGANIZE_TABLE + " set show_order=show_order-1" + " where show_order=" + showOrder [i] + " and organize_id= '" + orgID [i] + "'";
        }
        for (int j = 0; j < sqls.length; j ++) {
            ps = con.prepareStatement (sqls [j]);
            int resultCount = ps.executeUpdate ();
            if (resultCount != 1) {
                throw new CesSystemException ("Organize.movePrior(): ERROR Inserting data " + "in T_SYS_ORGANIZE update !! resultCount = " + resultCount);
            }
        }
        con.commit ();
    } catch (SQLException se) {
        if (con != null) {
            con.rollback ();
        }
        throw new CesSystemException ("Organize.movePrior(): SQLException while mov organize order " + " :\n\t" + se);
    } finally {
        con.setAutoCommit (true);
        close (dbo, ps, result);
    }
}


public RestServiceResult search (RestServiceResult serviceResult, Long nTechnicalId) {
    CoTechnical coTechnical = new CoTechnicalDAO ().findById (nTechnicalId);
    if (coTechnical == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("technical.search.notFound"));
    }
    else {
        List < CoTechnical > list = new ArrayList < CoTechnical > ();
        EntityManagerHelper.refresh (coTechnical);
        list.add (coTechnical);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("technical.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=326=-----==

public boolean deleteValidating (Validating validate) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.delete (validate);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public List findByExample (Object instance, String order, String dir) throws Exception {
    try {
        Criteria criteria = getSession ().createCriteria (instance.getClass ().getName ());
        if (Constants.ORDER_ASC.equals (dir)) {
            criteria.addOrder (Order.asc (order));
        }
        else {
            criteria.addOrder (Order.desc (order));
        }
        Example example = Example.create (instance).excludeZeroes ().ignoreCase ().enableLike ();
        List results = criteria.add (example).list ();
        return results;
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=327=-----==

public WardListDocument getWardList (String hospitalNo) {
    ResultSet rsList = null;
    WardListDocument doc = null;
    try {
        helper = new DBHelper ();
        doc = WardListDocument.Factory.newInstance ();
        doc.addNewWardList ();
        PreparedStatement psList = helper.prepareStatement (SQL.getWardList ());
        psList.setString (1, hospitalNo);
        rsList = psList.executeQuery ();
        while (rsList.next ()) {
            Ward i = doc.getWardList ().addNewWard ();
            i.setWard (rsList.getString ("WARD"));
            i.setWardno (rsList.getString ("WARDNO"));
            i.setWardDescription (rsList.getString ("WARDDESCRIPTION"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsList != null) {
                rsList.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


private void store (Set < Post > posts, boolean delete) throws SQLException {
    if (null == posts || posts.isEmpty ()) return;
    String insertQuery = "insert into fs.post (id, forum, tid, qid, pid, question, posted_date, type, text, author, deleted, path) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    String updateQuery = "update fs.post set forum = ?, tid = ?, qid = ?, pid = ?, question = ?, posted_date = ?, type = ?, text = ?, author = ?, deleted = ?, path = ? where id = ?";
    ensureConnection ();
    PreparedStatement statement = null;
    Savepoint savepoint = null;
    String path = null;
    try {
        savepoint = m_connection.setSavepoint ();
        synchronized (posts) {
            for (Post post : posts) {
                path = null;
                boolean insert = ! hasInDatabase (post);
                if (insert) {
                    statement = m_connection.prepareStatement (insertQuery);
                    statement.setNull (1, Types.NUMERIC);
                    statement.setString (2, post.getQuestion ().getTopicArea ().getForum ().getIdentifier ());
                    statement.setString (3, post.getQuestion ().getTopicArea ().getIdentifier ());
                    statement.setString (4, post.getQuestion ().getIdentifier ());
                    statement.setString (5, post.getIdentifier ());
                    statement.setLong (6, post.getQuestion ().getDatabaseID ());
                    statement.setTimestamp (7, new Timestamp (post.getPostedDate ().getTime ()));
                    statement.setString (8, post.getType ().toString ());
                    int contentLength = 0;
                    if (null != post.getText ()) contentLength = post.getText ().toString ().length ();
                    if (contentLength < m_configuration.getThresholdByteSize ()) {
                        statement.setString (9, post.getText ().toString ());
                        statement.setBoolean (12, false);
                    }
                    else {
                        path = getPath (post);
                        statement.setString (9, path);
                        try {
                            IOUtils.writeIntoFile (new File (m_configuration.getRepository (), path), post.getText ().toString ());
                        } catch (IOException e) {
                            SQLException sqle = new SQLException ();
                            sqle.initCause (e);
                            throw sqle;
                        }
                        statement.setBoolean (12, true);
                    }
                    statement.setString (10, post.getAuthor ());
                    statement.setBoolean (11, delete);
                    int count = statement.executeUpdate ();
                    if (0 == count) throw new SQLException ("Nothing updated.");
                    ResultSet keys = statement.getGeneratedKeys ();
                    try {
                        if (keys.next ()) post.setDatabaseID (keys.getLong (1));
                        else throw new SQLException ("No key found.");
                    } finally {
                        try {
                            keys.close ();
                        } catch (SQLException _) {
                        }
                    }
                }
                else {
                    statement = m_connection.prepareStatement (updateQuery);
                    statement.setLong (12, post.getDatabaseID ());
                    statement.setString (1, post.getQuestion ().getTopicArea ().getForum ().getIdentifier ());
                    statement.setString (2, post.getQuestion ().getTopicArea ().getIdentifier ());
                    statement.setString (3, post.getQuestion ().getIdentifier ());
                    statement.setString (4, post.getIdentifier ());
                    statement.setLong (5, post.getQuestion ().getDatabaseID ());
                    statement.setTimestamp (6, new Timestamp (post.getPostedDate ().getTime ()));
                    statement.setString (7, post.getType ().toString ());
                    int contentLength = 0;
                    if (null != post.getText ()) contentLength = post.getText ().toString ().length ();
                    if (contentLength < m_configuration.getThresholdByteSize ()) {
                        String pathIfThere = getPath (post);
                        File file = new File (m_configuration.getRepository (), pathIfThere);
                        if (file.exists ()) delete (file);
                        statement.setString (8, post.getText ().toString ());
                        statement.setBoolean (11, false);
                    }
                    else {
                        path = getPath (post);
                        statement.setString (8, path);
                        File file = new File (m_configuration.getRepository (), path);
                        try {
                            IOUtils.writeIntoFile (file, post.getText ().toString ());
                        } catch (IOException e) {
                            SQLException sqle = new SQLException ();
                            sqle.initCause (e);
                            throw sqle;
                        }
                        statement.setBoolean (11, true);
                        post.setText (new DelayedLoadString (file));
                    }
                    statement.setString (9, post.getAuthor ());
                    statement.setBoolean (10, delete);
                    int count = statement.executeUpdate ();
                    if (0 == count) throw new SQLException ("Nothing updated.");
                }
                PreparedStatement statement1 = m_connection.prepareStatement ("show warnings");
                try {
                    ResultSet rs1 = statement1.executeQuery ();
                    if (rs1.next ()) {
                        try {
                            System.err.println (rs1.getString ("Message"));
                        } finally {
                            rs1.close ();
                        }
                    }
                } finally {
                    statement1.close ();
                }
                statement1 = m_connection.prepareStatement ("select * from fs.post where id = ?");
                try {
                    statement1.setLong (1, post.getDatabaseID ());
                    ResultSet rs1 = statement1.executeQuery ();
                    try {
                        if (! rs1.next ()) throw new SQLException ("Nothing updated.");
                    } finally {
                        rs1.close ();
                    }
                } finally {
                    statement1.close ();
                }
                LOG.info ("Post [ID=" + post.getIdentifier () + "] [Question=" + post.getQuestion ().getIdentifier () + "] [Database ID=" + post.getDatabaseID () + "] [Title=" + post.getQuestion ().getTitle () + "] has been updated.");
            }
        }
        m_connection.commit ();
    } catch (SQLException e) {
        m_connection.rollback (savepoint);
        delete (path);
        throw e;
    } finally {
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


-----Function Pair=328=-----==

public AiringOverride getOverride (int airingId) {
    ResultSet rs = null;
    try {
        overrideGetQry.setInt (1, airingId);
        rs = overrideGetQry.executeQuery ();
        if (rs.next ()) return new AiringOverride (airingId, rs.getString (1), rs.getString (2), rs.getBoolean (3));
        return null;
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
        return null;
    } finally {
        try {
            if (rs != null) rs.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person1 = new Person ();
        person1.setFirstName ("Jesse");
        person1.setLastName ("James");
        Person person2 = new Person ();
        person2.setFirstName ("Brian");
        person2.setLastName ("Fowley");
        Person person3 = new Person ();
        person3.setFirstName ("Anne");
        person3.setLastName ("Smith");
        person1.getFriends ().add (person2);
        person1.getFriends ().add (person3);
        entityManager.persist (person1);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=329=-----==

public AiringOverride getOverride (int airingId) {
    ResultSet rs = null;
    try {
        overrideGetQry.setInt (1, airingId);
        rs = overrideGetQry.executeQuery ();
        if (rs.next ()) return new AiringOverride (airingId, rs.getString (1), rs.getString (2), rs.getBoolean (3));
        return null;
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
        return null;
    } finally {
        try {
            if (rs != null) rs.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        person.setImage (new byte [] {0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, (byte) 0xff});
        person.setProfile (generateLongText ());
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=330=-----==

public boolean insertBuddys (Buddys buddy) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (buddy);
        tr.commit ();
        return true;
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
        }
        he.printStackTrace ();
    }
    return false;
}


public static Collection selectAll () {
    Connection c = DBConnection.getConnection ();
    if (c == null) {
        return null;
    }
    String sql = "select id_orgao, nome from orgao order by nome";
    Statement st = null;
    ResultSet rs = null;
    ArrayList < Orgao > al = new ArrayList < Orgao > ();
    Orgao objOrgao = null;
    try {
        st = c.createStatement ();
        rs = st.executeQuery (sql);
        while (rs.next ()) {
            objOrgao = new Orgao ();
            objOrgao.setCodigo (rs.getInt ("id_orgao"));
            objOrgao.setNome (rs.getString ("nome"));
            al.add (objOrgao);
        }
    } catch (SQLException e) {
        System.out.println (e.getMessage ());
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closeStatement (st);
        DBConnection.closeConnection (c);
    }
    return al;
}


-----Function Pair=331=-----==

public boolean insertWard (String wardDocument) {
    boolean ret = false;
    PreparedStatement psRollback = null;
    try {
        helper = new DBHelper ();
        WardDocument doc = WardDocument.Factory.parse (wardDocument);
        PreparedStatement psAdd = helper.prepareStatement (SQL.insertWard ());
        PreparedStatement psCommit = helper.prepareStatement (SQL.commit ());
        PreparedStatement psBegin = helper.prepareStatement (SQL.begin ());
        psRollback = helper.prepareStatement (SQL.rollback ());
        psAdd.setString (1, doc.getWard ().getWard ().getHospitalno ());
        psAdd.setString (2, MedisisKeyGenerator.generate ());
        psAdd.setString (3, doc.getWard ().getWard ().getWard ());
        psAdd.setString (4, doc.getWard ().getWard ().getWardDescription ());
        psBegin.executeUpdate ();
        psAdd.executeUpdate ();
        psCommit.executeUpdate ();
        ret = true;
    } catch (Exception e) {
        try {
            psRollback.executeUpdate ();
        } catch (Exception ee) {
            ee.printStackTrace ();
        }
        e.printStackTrace ();
    } finally {
        try {
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return ret;
}


public void actionPerformed (ActionEvent e) {
    if (e.getActionCommand ().equals (ConfirmPanel.A_CANCEL)) {
        dispose ();
        return;
    }
    String columnName = null;
    String from_Info = null;
    String to_Info = null;
    int from_ID = 0;
    int to_ID = 0;
    for (int i = 0; (i < m_columnName.length && from_ID == 0 && to_ID == 0); i ++) {
        Object value = m_from [i].getValue ();
        if (value != null) {
            if (value instanceof Integer) from_ID = ((Integer) value).intValue ();
            else continue;
            value = m_to [i].getValue ();
            if (value != null && value instanceof Integer) to_ID = ((Integer) value).intValue ();
            else from_ID = 0;
            if (from_ID != 0) {
                columnName = m_columnName [i];
                from_Info = m_from [i].getDisplay ();
                to_Info = m_to [i].getDisplay ();
            }
        }
    }
    if (from_ID == 0 || from_ID == to_ID) return;
    String msg = Msg.getMsg (Env.getCtx (), "MergeFrom") + " = " + from_Info + "\n" + Msg.getMsg (Env.getCtx (), "MergeTo") + " = " + to_Info;
    if (! ADialog.ask (m_WindowNo, this, "MergeQuestion", msg)) return;
    if (columnName.equals (AD_ORG_ID)) m_deleteTables = s_delete_Org;
    else if (columnName.equals (AD_USER_ID)) m_deleteTables = s_delete_User;
    else if (columnName.equals (C_BPARTNER_ID)) m_deleteTables = s_delete_BPartner;
    else if (columnName.equals (M_PRODUCT_ID)) m_deleteTables = s_delete_Product;
    setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
    confirmPanel.getOKButton ().setEnabled (false);
    boolean success = merge (columnName, from_ID, to_ID);
    postMerge (columnName, to_ID);
    confirmPanel.getOKButton ().setEnabled (true);
    setCursor (Cursor.getDefaultCursor ());
    if (success) {
        ADialog.info (m_WindowNo, this, "MergeSuccess", msg + " #" + m_totalCount);
    }
    else {
        ADialog.error (m_WindowNo, this, "MergeError", m_errorLog.toString ());
        return;
    }
    dispose ();
}


-----Function Pair=332=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoParagraphBaseKnowledge coParagraphBaseKnowledge) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_PARAGRAPH_BASE_KNOWLEDGE);
        query.setParameter (1, coParagraphBaseKnowledge.getKnowledgeId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coParagraphBaseKnowledge.getKnowledgeId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el Knowledge: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {coParagraphBaseKnowledge.getKnowledgeId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("paragraphBaseKnowledge.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


protected void execute (Context context) throws java.lang.Exception {
    Connection c = null;
    Statement s = null;
    Integer check = context.getValueAsInteger ("Total");
    System.err.println ("In BuyWidget.execute()");
    try {
        c = context.getConnection ();
        c.setAutoCommit (false);
        s = c.createStatement ();
        int total = computeCheckoutTotal (context, s);
        if (check == null) {
            throw new Exception ("Shouldn't: No total?");
        }
        if (check.intValue () != total) {
            throw new Exception ("Shouldn't: Basket changed? " + "total was " + total + "; checksum was " + check);
        }
        StringBuffer q = new StringBuffer ("select BIDSTATE.Bid, BIDSTATE.Amount, " + "BIDSTATE.QShipping, BIDSTATE.QInsure " + "from BID, BIDSTATE " + "where  BIDSTATE.Bid = BID.Bid " + "and ( BIDSTATE.BidStatus = 0 " + "or BIDSTATE.BidStatus = 15) " + "and BID.Customer = ");
        q.append (context.get ("customer"));
        q.append (" and bidstate.bidstate =  " + "( select max( bidstate.bidstate) " + "from bidstate " + "where bid = bid.bid) ");
        System.err.println (q.toString ());
        Contexts rows = new RSContexts (s.executeQuery (q.toString ()));
        Enumeration e = rows.elements ();
        while (e.hasMoreElements ()) {
            Context row = (Context) e.nextElement ();
            row.merge ((Map) context);
            row.put ("Username", context.get (ConnectionPool.DBUSERMAGICTOKEN));
            row.put ("BidStatus", BidStatus.OFFER);
            s.executeUpdate (bidStateInsert (row));
            s.execute (bidPrivateInsert (context, row));
        }
        c.commit ();
    } catch (Exception any) {
        c.rollback ();
        throw new DataStoreException ("Your card will not be debited: " + any.getMessage ());
    } finally {
        try {
            if (s != null) {
                s.close ();
            }
            if (c != null) {
                context.releaseConnection (c);
            }
        } catch (SQLException sex) {
        } catch (DataStoreException dse) {
        }
    }
    context.put (REDIRECTMAGICTOKEN, "account");
}


-----Function Pair=333=-----==

private void populatePreparedStatement2 (partida unaPartida) {
    try {
        ps.setInt (1, unaPartida.dameIdTorneo ());
        ps.setInt (2, unaPartida.dameIdJugadorNegras ());
        ps.setInt (3, unaPartida.dameIdJugadorBlancas ());
        Calendar p = unaPartida.dameFechaJuego ();
        if (p == null) ps.setDate (4, null);
        else {
            java.sql.Date dia = new java.sql.Date (unaPartida.dameFechaJuego ().getTimeInMillis ());
            ps.setDate (4, dia, unaPartida.dameFechaJuego ());
        }
        ps.setString (5, unaPartida.dameResultado ());
        ps.setString (6, unaPartida.dameNombreJugadorBlanco ());
        ps.setString (7, unaPartida.dameNombreJugadorNegro ());
        ps.setString (8, unaPartida.dameEloBlancas ());
        ps.setString (9, unaPartida.dameEloNegras ());
        ps.setInt (10, unaPartida.dameidApertura ());
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
}


private DataSource setUpDataSourse (ServletContext context) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
    String dbDriver = Utils.getFromConfig (context, "dbDriver", null);
    String url = Utils.getFromConfig (context, "dbConnString", null);
    String user = Utils.getFromConfig (context, "dbUser", null);
    String pass = Utils.getFromConfig (context, "dbPass", null);
    Class.forName (dbDriver).newInstance ();
    GenericObjectPool.Config config = new GenericObjectPool.Config ();
    config.timeBetweenEvictionRunsMillis = 60000;
    config.testWhileIdle = true;
    GenericObjectPool connectionPool = new GenericObjectPool (null, config);
    ConnectionFactory connectionFactory = new DriverManagerConnectionFactory (url, user, pass);
    boolean autoCommit = false;
    PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory (connectionFactory, connectionPool, new StackKeyedObjectPoolFactory (), DB.Pool.validationQuery, false, autoCommit);
    PoolingDataSource dataSource = new PoolingDataSource (connectionPool);
    return dataSource;
}


-----Function Pair=334=-----==

public AcademicYear findByName (String name) throws SelectException, DBConnectionException {
    AcademicYear acaY = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("ACADEMIC_YEAR_NAME", name);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                acaY = new AcademicYear ();
                acaY.setId (result.getInt ("ACEDEMIC_YEAR_ID"));
                acaY.setName (result.getString ("ACEDEMIC_YEAR_NAME"));
                acaY.setYos (null);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return acaY;
}


public void alterar (Disciplina t) throws Exception {
    PreparedStatement stmt = null;
    String sql = "UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?";
    try {
        stmt = conexao.prepareStatement (sql);
        stmt.setString (1, t.getNomeDisciplina ());
        stmt.setString (2, t.getCodDisciplina ());
        stmt.setInt (3, t.getIdDisciplina ());
        stmt.executeUpdate ();
        conexao.commit ();
        int id_disciplina = t.getIdDisciplina ();
        excluirTopico (t.getIdDisciplina ());
        for (Topico item : t.getTopicos ()) {
            criarTopico (item, id_disciplina);
        }
    } catch (SQLException e) {
        conexao.rollback ();
        throw e;
    }
}


-----Function Pair=335=-----==

public List < SysMboxViewer > getMyAllPagination (int offset, int limit, String sort, String order, String [] filters, Integer userId) throws Exception {
    try {
        String whereStatement = super.getWhereStatement (filters);
        if ("".equals (whereStatement)) {
            whereStatement += " where receiver.id=" + userId + " or sender.id=" + userId;
        }
        else {
            whereStatement += " and (receiver.id=" + userId + " or sender.id=" + userId + ")";
        }
        String queryString = "from " + SysMboxViewer.class.getName () + whereStatement + " order by " + sort + " " + order;
        Query queryObject = getSession ().createQuery (queryString);
        queryObject.setFirstResult (offset);
        queryObject.setMaxResults (limit);
        return queryObject.list ();
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
}


public static String getSql1 (final Connection con, final String querySql) {
    final StringBuffer finalSql = new StringBuffer ();
    DatabaseMetaData dmd = null;
    String dbName = null;
    try {
        dmd = con.getMetaData ();
        dbName = dmd.getDatabaseProductName ().toLowerCase ();
        if (dbName.equals ("oracle")) {
            finalSql.append (" SELECT * FROM (");
            finalSql.append (querySql);
            finalSql.append (" ) WHERE ROWNUM =1 ");
            return finalSql.toString ();
        }
    } catch (final SQLException e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=336=-----==

public boolean crear () {
    int result = 0;
    String sql = "insert into torneo" + "(nombreTorneo, ciudad, fechaInicio, fechaFinal, organizador, numeroDivisiones, terminado)" + "values (?, ?, ?, ?, ?, ?, ?)";
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        populatePreparedStatement (eltorneo);
        result = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (result > 0);
}


public Map < Integer, ProgramSymbol > readProgramSymbols () throws AdaptationException {
    Map < Integer, ProgramSymbol > programSymbols = new HashMap < Integer, ProgramSymbol > ();
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM ProgramSymbols";
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        while (resultSet.next ()) {
            ProgramSymbol programSymbol = getProgramSymbol (resultSet);
            programSymbols.put (programSymbol.getID (), programSymbol);
        }
    } catch (SQLException ex) {
        String msg = "SQLException in readProgramSymbols";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return programSymbols;
}


-----Function Pair=337=-----==

public static void createBox (MusicBoxBean mbox, int pos, boolean up) throws CapacityExceedException {
    Session ssn = getSession ();
    int order_value = 1;
    if (pos > 0) {
        MusicBoxBean friend = (MusicBoxBean) ssn.get (MusicBoxBean.class, new Integer (pos));
        order_value = friend.getSortOrder ();
    }
    mbox.setSortOrder (order_value - (up ? 1 : 0));
    try {
        beginTransaction ();
        ssn.save (mbox);
        List links = findNamedAll ("LIST_MUSICBOXES", mbox.getSite ().getId ());
        if (links.size () >= ConfigDAO.intValue (mbox.getSite ().getId (), "MAX_MUSICBOX_COUNT", MAX_MUSICBOX_COUNT)) throw new CapacityExceedException (links.size ());
        if (links.size () > 1) {
            for (int i = 0; i < links.size (); i ++) {
                Orderable lb = (Orderable) links.get (i);
                executeNamedUpdate ("UPDATE_MUSICBOX_ORDER", (i + 1), lb.getId ());
            }
        }
        commit ();
    } catch (HibernateException e) {
        rollback ();
        throw e;
    }
}


public boolean updatenum (int num, String pid) {
    boolean flag = false;
    Connection conn = null;
    PreparedStatement pm = null;
    try {
        conn = Pool.getConnection ();
        conn.setAutoCommit (false);
        pm = conn.prepareStatement ("update addwuliao set innum=? where pid=?");
        pm.setInt (1, num);
        pm.setString (2, pid);
        int a = pm.executeUpdate ();
        if (a == 0) {
            flag = false;
        }
        else {
            flag = true;
        }
        conn.commit ();
        Pool.close (pm);
        Pool.close (conn);
    } catch (Exception e) {
        e.printStackTrace ();
        flag = false;
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
        Pool.close (pm);
        Pool.close (conn);
    } finally {
        Pool.close (pm);
        Pool.close (conn);
    }
    return flag;
}


-----Function Pair=338=-----==

public boolean checkUserExistance (String userDocument) {
    DBHelper helper = null;
    boolean ret = false;
    ResultSet rsCheck = null;
    UserDocument doc = null;
    try {
        helper = new DBHelper ();
        doc = UserDocument.Factory.parse (userDocument);
        PreparedStatement psCheck = helper.prepareStatement (SQL.checkUserExistance ());
        psCheck.setString (1, doc.getUser ().getUsername ());
        rsCheck = psCheck.executeQuery ();
        rsCheck.next ();
        if (rsCheck.getInt (1) != 0) {
            ret = true;
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsCheck != null) {
                rsCheck.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return ret;
}


public void delete (GroupType obj) throws DeleteException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria critDel = new Criteria ();
    critDel.addCriterion ("GROUP_TYPE_ID", obj.getId ());
    try {
        stmt.executeUpdate (new DeleteQuery (GroupTypeDAO.TABLE_NAME, critDel).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new DeleteException (TABLE_NAME + " Deletion exception :", e);
    }
}


-----Function Pair=339=-----==

public void updateAttachment (List < Attachments > attachmentsList) {
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        for (int i = 0; i < attachmentsList.size (); i ++) {
            session.update (attachmentsList.get (i));
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    }
}


public static ExperimentResultHasProperty getById (int id) throws NoConnectionToDBException, SQLException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, ComputationMethodDoesNotExistException {
    ExperimentResultHasProperty res = cache.getCached (id);
    if (res != null) {
        return res;
    }
    else {
        PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT idExperimentResults, idProperty " + "FROM " + table + " WHERE idExperimentResult_has_Property=?");
        ps.setInt (1, id);
        ResultSet rs = ps.executeQuery ();
        if (! rs.next ()) {
            throw new ExpResultHasSolvPropertyNotInDBException ();
        }
        res = new ExperimentResultHasProperty ();
        res.setId (id);
        res.setExpResId (rs.getInt (1));
        res.setPropId (rs.getInt (2));
        ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT value " + "FROM " + valueTable + " WHERE idExperimentResult_has_Property=? " + "ORDER BY `order`");
        ps.setInt (1, id);
        rs = ps.executeQuery ();
        Vector < String > value = new Vector < String > ();
        while (rs.next ()) {
            value.add (rs.getString (1));
        }
        res.setValue (value);
        res.setSaved ();
        cache.cache (res);
        return res;
    }
}


-----Function Pair=340=-----==

public RestServiceResult create (RestServiceResult serviceResult, ToPublication toPublication) {
    ToPublicationDAO toPublicationDAO = new ToPublicationDAO ();
    try {
        toPublication.setPublicationId (getSequence ("sq_to_publication"));
        EntityManagerHelper.beginTransaction ();
        toPublicationDAO.save (toPublication);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toPublication);
        log.info ("La publicacion" + toPublication.getTitle () + " fue creada con ÔøΩxito...");
        Object [] arrayParam = {toPublication.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("publication.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel anuncio: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("publication.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


private Map preloadIdValueTable (PreparedStatement cntStm, PreparedStatement stm) throws SQLException {
    Map m = null;
    ResultSet rs = cntStm.executeQuery ();
    rs.next ();
    long recordCount = rs.getLong (1);
    closeResultSet (rs);
    if (recordCount < MAX_PRELOAD_CNT) {
        rs = stm.executeQuery ();
        if (true) {
            m = new HashMap ();
            String currentId = null;
            List l = null;
            while (rs.next ()) {
                String id = rs.getString (1);
                if (! id.equals (currentId)) {
                    l = new ArrayList ();
                    m.put (id, l);
                    currentId = id;
                }
                l.add (rs.getString (2));
            }
            closeResultSet (rs);
        }
    }
    return m;
}


-----Function Pair=341=-----==

private DFAgentDescription getDFD (String aidN, Map allLanguages, Map allOntologies, Map allProtocols) throws SQLException {
    DFAgentDescription dfd = null;
    AID id = null;
    ResultSet rs = null;
    ResultSet rsS = null;
    String descrId = null;
    try {
        PreparedStatements pss = getPreparedStatements ();
        pss.stm_selLease.setString (1, aidN);
        rs = pss.stm_selLease.executeQuery ();
        if (rs.next ()) {
            dfd = new DFAgentDescription ();
            id = getAID (aidN);
            dfd.setName (id);
            String sLease = rs.getString ("lease");
            descrId = rs.getString ("id");
            long lease = Long.parseLong (sLease);
            if (lease != - 1) {
                dfd.setLeaseTime (new Date (lease));
            }
        }
        else {
            return null;
        }
        closeResultSet (rs);
        loadProtocols (descrId, dfd, allProtocols);
        loadLanguages (descrId, dfd, allLanguages);
        loadOntologies (descrId, dfd, allOntologies);
        pss.stm_selServices.setString (1, descrId);
        rs = pss.stm_selServices.executeQuery ();
        while (rs.next ()) {
            ServiceDescription sd = new ServiceDescription ();
            String serviceId = rs.getString ("id");
            sd.setName (rs.getString ("sname"));
            sd.setType (rs.getString ("stype"));
            sd.setOwnership (rs.getString ("sownership"));
            pss.stm_selServiceProtocols.setString (1, serviceId);
            rsS = pss.stm_selServiceProtocols.executeQuery ();
            while (rsS.next ()) {
                sd.addProtocols (rsS.getString (PROTOCOL));
            }
            closeResultSet (rsS);
            pss.stm_selServiceLanguages.setString (1, serviceId);
            rsS = pss.stm_selServiceLanguages.executeQuery ();
            while (rsS.next ()) {
                sd.addOntologies (rsS.getString (ONTOLOGY));
            }
            closeResultSet (rsS);
            pss.stm_selServiceOntologies.setString (1, serviceId);
            rsS = pss.stm_selServiceOntologies.executeQuery ();
            while (rsS.next ()) {
                sd.addLanguages (rsS.getString (LANGUAGE));
            }
            closeResultSet (rsS);
            pss.stm_selServiceProperties.setString (1, serviceId);
            rsS = pss.stm_selServiceProperties.executeQuery ();
            while (rsS.next ()) {
                Property prop = new Property ();
                prop.setName (rsS.getString ("propkey"));
                String objStrVal = rsS.getString ("propval_obj");
                String strStrVal = rsS.getString ("propval_str");
                Object value = (objStrVal == null) ? strStrVal : deserializeObj (objStrVal);
                prop.setValue (value);
                sd.addProperties (prop);
            }
            dfd.addServices (sd);
        }
    } catch (SQLException sqle) {
        throw sqle;
    } catch (Exception e) {
        logger.log (Logger.SEVERE, "Unexpected error retrieving DFD for agent " + aidN, e);
        throw new SQLException ("Unexpected error retrieving DFD for agent " + aidN + ". " + e.getMessage ());
    } finally {
        closeResultSet (rs);
        closeResultSet (rsS);
    }
    return dfd;
}


public static String getGIFOutputPattern (String output_filepath, String category, int time_period, int diff_period, boolean average_image) {
    StringBuffer output_pattern = new StringBuffer (output_filepath);
    output_pattern.append (File.separator);
    output_pattern.append (category);
    if (diff_period != TIMESERIES_NONE) {
        if (diff_period == time_period) {
            if (average_image) {
                output_pattern.append ("_DA");
            }
            else {
                output_pattern.append ("_D");
            }
        }
        else {
            switch (diff_period) {
                case TIMESERIES_YEAR :
                    output_pattern.append ("_DY");
                    break;
                case TIMESERIES_MONTH :
                    output_pattern.append ("_DM");
                    break;
                case TIMESERIES_DEKAD :
                    if (average_image) {
                        output_pattern.append ("_DA");
                    }
                    else {
                        output_pattern.append ("_DK");
                    }
                    break;
                case TIMESERIES_BIMONTH :
                    output_pattern.append ("_DB");
                    break;
                case TIMESERIES_DAY :
                    output_pattern.append ("_DD");
                    break;
            }
        }
    }
    switch (time_period) {
        case TIMESERIES_YEAR :
            output_pattern.append ("_Y%yyyy%");
            break;
        case TIMESERIES_MONTH :
            output_pattern.append ("_M%yyyy%%MM%");
            break;
        case TIMESERIES_DEKAD :
            output_pattern.append ("_K%yyyy%%MM%%Dekad%");
            break;
        case TIMESERIES_BIMONTH :
            output_pattern.append ("_B%yyyy%%MM%%Bimonth%");
            break;
        case TIMESERIES_DAY :
            output_pattern.append ("_D%yyyy%%MM%%dd%");
            break;
    }
    output_pattern.append (".gif");
    Debug.println ("output_pattern.toString(): " + output_pattern.toString ());
    return output_pattern.toString ();
}


-----Function Pair=342=-----==

public void run () {
    nextScheduledRun = new GregorianCalendar ();
    nextScheduledRun.add (generalSettings.getPeriodUnit (), generalSettings.getCheckerPeriod ());
    setRunningState (RUNNING);
    while (getRunningState () == RUNNING) {
        boolean databaseConnected = false;
        while (! databaseConnected) {
            try {
                initDatabase (dprSettings);
                databaseConnected = true;
            } catch (SQLException sqlex) {
                logger.log (Level.SEVERE, "Could not connect to database. Will try again after 30 seconds.", sqlex);
                try {
                    Thread.sleep (30000);
                } catch (InterruptedException e) {
                }
            }
        }
        logger.finer ("Started checking run at " + new Date ());
        System.out.println ("Started checking run at " + new Date ());
        fireCheckerRunStartedEvent ();
        try {
            checkerResults = new CheckerResults ();
            checkerResults.setStartTime (new java.util.Date ());
            Map < String, AIPStatistics > mimeTypeRegister = new TreeMap < String, AIPStatistics > ();
            long tjAIPCount = 0, rjAIPCount = 0;
            StringBuilder totalTJAIPsQuery = new StringBuilder ();
            totalTJAIPsQuery.append ("select count(aip.aip_id) from archival_information_package aip, transfer_job tj ");
            totalTJAIPsQuery.append ("where aip.transfer_job_id = tj.transfer_job_id and tj.status = '");
            totalTJAIPsQuery.append (JobStatus.DR_PROCESSING_COMPLETE.getDescription ());
            totalTJAIPsQuery.append ("' and aip.deleted = 'FALSE'");
            PreparedStatement select = dbConnection.prepareStatement (totalTJAIPsQuery.toString ());
            select.setFetchSize (DEFAULT_FETCH_SIZE);
            ResultSet result = select.executeQuery ();
            if (result.next ()) {
                tjAIPCount = result.getLong (1);
            }
            StringBuilder totalRJAIPsQuery = new StringBuilder ();
            totalRJAIPsQuery.append ("select count(aip.aip_id) from archival_information_package aip, reprocessing_job rj ");
            totalRJAIPsQuery.append ("where aip.reprocessing_job_id = rj.id and rj.status = '");
            totalRJAIPsQuery.append (JobStatus.DR_REPROCESSING_COMPLETE.getDescription ());
            totalRJAIPsQuery.append ("' " + "and aip.deleted = 'FALSE'");
            select = dbConnection.prepareStatement (totalRJAIPsQuery.toString ());
            select.setFetchSize (DEFAULT_FETCH_SIZE);
            result = select.executeQuery ();
            if (result.next ()) {
                rjAIPCount = result.getLong (1);
            }
            checkerResults.setTotalAIPCount (tjAIPCount + rjAIPCount);
            System.out.println ("TJ Count: " + tjAIPCount + ", RJ Count: " + rjAIPCount);
            StringBuilder tjQuery = new StringBuilder ();
            tjQuery.append ("select distinct aip.output_resource_name, aip.checksum, aip.checksum_algorithm, aip.type, tj.full_job_number, aip_content.mimetype ");
            tjQuery.append ("from archival_information_package aip, transfer_job tj, aip_content ");
            tjQuery.append ("where aip.transfer_job_id = tj.transfer_job_id and tj.status = '");
            tjQuery.append (JobStatus.DR_PROCESSING_COMPLETE.getDescription ());
            tjQuery.append ("' and aip.top_content_id = aip_content.aip_content_id ");
            tjQuery.append ("and aip.deleted = 'FALSE'");
            select = dbConnection.prepareStatement (tjQuery.toString ());
            select.setFetchSize (DEFAULT_FETCH_SIZE);
            result = select.executeQuery ();
            AIPStatistics tjAIPStats = scanAIPs (result, checkerResults, mimeTypeRegister);
            StringBuilder rjQuery = new StringBuilder ();
            rjQuery.append ("select distinct aip.output_resource_name, aip.checksum, aip.checksum_algorithm, aip.type, rj.full_job_number, aip_content.mimetype ");
            rjQuery.append ("from archival_information_package aip, reprocessing_job rj, aip_content ");
            rjQuery.append ("where aip.reprocessing_job_id = rj.id and rj.status = '");
            rjQuery.append (JobStatus.DR_REPROCESSING_COMPLETE.getDescription ());
            rjQuery.append ("' and aip.top_content_id = aip_content.aip_content_id ");
            rjQuery.append ("and aip.deleted = 'FALSE'");
            select = dbConnection.prepareStatement (rjQuery.toString ());
            select.setFetchSize (DEFAULT_FETCH_SIZE);
            result = select.executeQuery ();
            AIPStatistics rjAIPStats = scanAIPs (result, checkerResults, mimeTypeRegister);
            select.close ();
            result.close ();
            recheckErrors ();
            if (getRunningState () == RUNNING) {
                writeStatsToDatabase (tjAIPStats.aipCount, rjAIPStats.aipCount, tjAIPStats.aipVolume, rjAIPStats.aipVolume, tjAIPStats.binaryAIPCount, mimeTypeRegister);
            }
            long aipsChecked = tjAIPStats.aipCount + rjAIPStats.aipCount;
            checkerResults.setEndTime (new java.util.Date ());
            fireCheckerRunFinishedEvent (checkerResults, aipsChecked);
            saveResults (checkerResults);
            logger.finer ("Finished checksum checking run. Checked " + aipsChecked + " AIPs. Found " + checkerResults.getTotalExceptions () + " errors.");
            System.out.println ("Finished checksum checking run. Checked " + aipsChecked + " AIPs. Found " + checkerResults.getTotalExceptions () + " errors.");
        } catch (SQLException e1) {
            logger.log (Level.SEVERE, "Database Exception", e1);
        } finally {
            currentAIPName = "";
        }
        if (getRunningState () == RUNNING) {
            setRunningState (SCHEDULED_PAUSE);
            logger.fine ("Checker is paused. Will resume at " + nextScheduledRun.getTime ());
            System.out.println ("Checker is paused. Will resume at " + nextScheduledRun.getTime ());
            while (getRunningState () == SCHEDULED_PAUSE || getRunningState () == PAUSED) {
                if (getRunningState () == SCHEDULED_PAUSE) {
                    Calendar currentTime = new GregorianCalendar ();
                    if (currentTime.before (nextScheduledRun)) {
                        try {
                            sleep (100);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                    else {
                        nextScheduledRun = new GregorianCalendar ();
                        nextScheduledRun.add (generalSettings.getPeriodUnit (), generalSettings.getCheckerPeriod ());
                        setRunningState (RUNNING);
                    }
                }
                else {
                    try {
                        sleep (100);
                    } catch (InterruptedException e) {
                        return;
                    }
                }
            }
        }
    }
    try {
        dbConnection.close ();
    } catch (SQLException e) {
        logger.warning ("Could not close database connection");
    }
}


private static void insertConfigFiles (Connection con, File pfad) throws IOException, SQLException {
    File [] list = pfad.listFiles ();
    for (File file : list) {
        if (file.isFile ()) {
            String fileName = file.getName ();
            if (fileName.endsWith (".xml")) {
                StringBuilder builder = new StringBuilder ();
                BufferedReader bf = new BufferedReader (new FileReader (file));
                String line = bf.readLine ();
                while (line != null) {
                    builder.append (line);
                    line = bf.readLine ();
                    if (line != null) {
                        builder.append ("\n");
                    }
                }
                bf.close ();
                String fileOhneXml = fileName.substring (0, fileName.length () - 4);
                PreparedStatement q1 = con.prepareStatement ("delete from xmlconfiguration where key=?");
                q1.setString (1, fileOhneXml);
                q1.executeUpdate ();
                q1.close ();
                PreparedStatement q2 = con.prepareStatement ("Insert INTO xmlconfiguration (key,config) values (?,?)");
                q2.setString (1, fileOhneXml);
                q2.setString (2, builder.toString ());
                q2.executeUpdate ();
                q2.close ();
                con.commit ();
            }
        }
    }
}


-----Function Pair=343=-----==

private boolean addBookmark0 (Bookmark bookmark, BookmarkFolder folder, PreparedStatement preparedStatement) throws SQLException {
    Object [] bindVariables = new Object [8];
    int [] types = new int [8];
    types [0] = Types.BOOLEAN;
    types [1] = Types.TIMESTAMP;
    types [2] = Types.TIMESTAMP;
    types [3] = Types.VARCHAR;
    types [4] = Types.VARCHAR;
    types [5] = Types.BIGINT;
    types [6] = Types.VARCHAR;
    types [7] = Types.VARCHAR;
    bindVariables [0] = Boolean.valueOf (bookmark.isFavorite ());
    Date time = bookmark.getCreationTime ();
    bindVariables [1] = new Timestamp (time == null ? System.currentTimeMillis () : time.getTime ());
    time = bookmark.getLastAccess ();
    bindVariables [2] = new Timestamp (time == null ? System.currentTimeMillis () : time.getTime ());
    bindVariables [3] = bookmark.getName ();
    bindVariables [4] = bookmark.getCommandText ();
    bindVariables [5] = new Long (bookmark.getUseCount ());
    bindVariables [6] = folder == null ? bookmark.getPath () : folder.getPath ();
    ColorLabel colorLabel = bookmark.getColorLabel ();
    bindVariables [7] = colorLabel == null ? null : colorLabel.name ();
    boolean doBatch = (preparedStatement != null);
    boolean hasError = true;
    embeddedConnection.setAutoCommit (false);
    PreparedStatement statement = null;
    try {
        if (preparedStatement == null) {
            statement = embeddedConnection.prepareStatement (BOOKMARK_INSERT);
        }
        else {
            statement = preparedStatement;
        }
        for (int i = 0; i < bindVariables.length; i ++) {
            if (bindVariables [i] == null) {
                statement.setNull (i + 1, types [i]);
            }
            else {
                statement.setObject (i + 1, bindVariables [i]);
            }
        }
        try {
            int affectedCount = statement.executeUpdate ();
            long identityValue = getInsertedPrimaryKey ();
            bookmark.setId (identityValue);
            addBindVariables (bookmark);
            hasError = false;
            return affectedCount == 1;
        } catch (SQLException exception) {
            if (CONSTRAINT_VIOLATION.equals (exception.getSQLState ())) {
                return false;
            }
            throw exception;
        }
    } finally {
        if (hasError) {
            embeddedConnection.rollback ();
        }
        else {
            embeddedConnection.commit ();
        }
        embeddedConnection.setAutoCommit (true);
        if (preparedStatement != null) {
            if (! doBatch) {
                try {
                    preparedStatement.close ();
                } catch (SQLException ignored) {
                }
            }
            else if (doBatch) {
                preparedStatement.clearParameters ();
                preparedStatement.clearWarnings ();
            }
        }
    }
}


public List < Proveedor > getProveedorespro () throws Exception {
    Session session = getSession ();
    Transaction trans = session.beginTransaction ();
    List < Proveedor > prov;
    List < Proveedor > pdto;
    prov = new ArrayList < Proveedor > ();
    List < Proveedor > pro;
    try {
        prov = new ArrayList < Proveedor > (((Query) session.createQuery ("select distinct prov.codproveedor from Producto as prov")).list ());
    } catch (Exception ex) {
        ex.printStackTrace ();
        trans.rollback ();
        throw ex;
    }
    trans.commit ();
    return prov;
}


-----Function Pair=344=-----==

public Integer deleteArray (String [] aids) {
    Integer deleteNumber = - 1;
    Transaction tr = null;
    try {
        Integer [] ids = new Integer [aids.length];
        for (int i = 0; i < aids.length; i ++) {
            ids [i] = Integer.valueOf (aids [i]);
        }
        String queryStr = "delete from Attachments as a where a.aid in (:ids)";
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery (queryStr);
        query.setParameterList ("ids", ids, new org.hibernate.type.IntegerType ());
        deleteNumber = query.executeUpdate ();
        session.flush ();
        tr.commit ();
    } catch (HibernateException he) {
        he.printStackTrace ();
        if (tr != null) tr.rollback ();
        tr = null;
    }
    return deleteNumber;
}


protected synchronized AbstractBaseObject delete (AbstractBaseObject obj) throws ApplicationException {
    PreparedStatement preStat = null;
    StringBuffer sqlStat = new StringBuffer ();
    DmsRelationalWord tmpDmsRelationalWord = (DmsRelationalWord) ((DmsRelationalWord) obj).clone ();
    synchronized (dbConn) {
        try {
            int updateCnt = 0;
            sqlStat.append ("DELETE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD ");
            sqlStat.append ("WHERE  ID=? AND UPDATE_COUNT=? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            setPrepareStatement (preStat, 1, tmpDmsRelationalWord.getID ());
            setPrepareStatement (preStat, 2, tmpDmsRelationalWord.getUpdateCount ());
            updateCnt = preStat.executeUpdate ();
            if (updateCnt == 0) {
                throw new ApplicationException (ErrorConstant.DB_CONCURRENT_ERROR);
            }
            else {
                return (tmpDmsRelationalWord);
            }
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_DELETE_ERROR, e);
        } finally {
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


-----Function Pair=345=-----==

public void cloneSequence (Long nSequenceOldId, Long nSequenceNewId, MaUser maUser) {
    try {
        CoSequence coSequence = new CoSequenceDAO ().findById (nSequenceOldId);
        EntityManagerHelper.refresh (coSequence);
        EntityManagerHelper.beginTransaction ();
        cloneUserHistory (nSequenceOldId, nSequenceNewId);
        EntityManagerHelper.commit ();
        Set < CoActivity > setActivity = coSequence.getCoActivities ();
        log.info ("NÔøΩmero de actividades a clonar: " + setActivity.size ());
        for (CoActivity coActivity : setActivity) {
            EntityManagerHelper.beginTransaction ();
            log.info ("Clonado actividad: " + coActivity.getActivityId ());
            Long nActivityNewId = getSequence ("sq_co_activity");
            Query query = EntityManagerHelper.createNativeQuery (Statements.CLONE_ACTIVITY_FOR_SEQUENCE.replaceAll (":CLONE", bundle.getString ("course.create.clone")));
            query.setParameter (1, nActivityNewId);
            query.setParameter (2, nSequenceNewId);
            query.setParameter (3, coActivity.getActivityId ());
            query.executeUpdate ();
            EntityManagerHelper.commit ();
            CoActivity coActivityNew = new CoActivityDAO ().findById (nActivityNewId);
            EntityManagerHelper.refresh (coActivityNew);
            if (coActivityNew != null) {
                EntityManagerHelper.beginTransaction ();
                DataManagerActivity.addUserHistory (new RestServiceResult (), maUser, coActivityNew);
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_ACTIVITY_MATERIAL);
                query.setParameter (1, nActivityNewId);
                query.setParameter (2, coActivity.getActivityId ());
                query.executeUpdate ();
                log.info ("Ok...");
                EntityManagerHelper.commit ();
                DataManagerActivity dataManagerActivity = new DataManagerActivity ();
                dataManagerActivity.setBundle (bundle);
                dataManagerActivity.cloneActivity (coActivity.getActivityId (), nActivityNewId);
            }
        }
        Set < CoTest > setTestClone = coSequence.getCoTests ();
        log.info ("NÔøΩmero de pruebas a clonar:_" + setTestClone.size ());
        for (CoTest coTest : setTestClone) {
            EntityManagerHelper.beginTransaction ();
            Long nTestNewId = getSequence ("sq_co_test");
            Query query = EntityManagerHelper.createNativeQuery (Statements.CLONE_TEST.replaceAll (":CLONE", bundle.getString ("course.create.clone")));
            query.setParameter (1, nTestNewId);
            query.setParameter (2, nSequenceNewId);
            query.setParameter (3, coTest.getTestId ());
            query.executeUpdate ();
            EntityManagerHelper.commit ();
            log.info ("Clonando prueba: " + coTest.getTestId ());
            DataManagerTest.addUserHistory (new RestServiceResult (), maUser, coTest);
            CoTest coTestNew = new CoTestDAO ().findById (new Long (nTestNewId));
            EntityManagerHelper.refresh (coTestNew);
            if (coTestNew != null) {
                EntityManagerHelper.beginTransaction ();
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_TEST_MATERIAL);
                query.setParameter (1, nTestNewId);
                query.setParameter (2, coTest.getTestId ());
                query.executeUpdate ();
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_QUESTION_WEIGHTED);
                query.setParameter (1, nTestNewId);
                query.setParameter (2, coTest.getTestId ());
                query.executeUpdate ();
                log.info ("Ok...");
                EntityManagerHelper.commit ();
                DataManagerTest dataManagerTest = new DataManagerTest ();
                dataManagerTest.setBundle (bundle);
                dataManagerTest.cloneTest (coTest.getTestId (), nTestNewId);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
    }
}


public boolean insertUserGroup (Usergroups userGroup) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.save (userGroup);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=346=-----==

public void cloneSequence (Long nSequenceOldId, Long nSequenceNewId, MaUser maUser) {
    try {
        CoSequence coSequence = new CoSequenceDAO ().findById (nSequenceOldId);
        EntityManagerHelper.refresh (coSequence);
        EntityManagerHelper.beginTransaction ();
        cloneUserHistory (nSequenceOldId, nSequenceNewId);
        EntityManagerHelper.commit ();
        Set < CoActivity > setActivity = coSequence.getCoActivities ();
        log.info ("NÔøΩmero de actividades a clonar: " + setActivity.size ());
        for (CoActivity coActivity : setActivity) {
            EntityManagerHelper.beginTransaction ();
            log.info ("Clonado actividad: " + coActivity.getActivityId ());
            Long nActivityNewId = getSequence ("sq_co_activity");
            Query query = EntityManagerHelper.createNativeQuery (Statements.CLONE_ACTIVITY_FOR_SEQUENCE.replaceAll (":CLONE", bundle.getString ("course.create.clone")));
            query.setParameter (1, nActivityNewId);
            query.setParameter (2, nSequenceNewId);
            query.setParameter (3, coActivity.getActivityId ());
            query.executeUpdate ();
            EntityManagerHelper.commit ();
            CoActivity coActivityNew = new CoActivityDAO ().findById (nActivityNewId);
            EntityManagerHelper.refresh (coActivityNew);
            if (coActivityNew != null) {
                EntityManagerHelper.beginTransaction ();
                DataManagerActivity.addUserHistory (new RestServiceResult (), maUser, coActivityNew);
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_ACTIVITY_MATERIAL);
                query.setParameter (1, nActivityNewId);
                query.setParameter (2, coActivity.getActivityId ());
                query.executeUpdate ();
                log.info ("Ok...");
                EntityManagerHelper.commit ();
                DataManagerActivity dataManagerActivity = new DataManagerActivity ();
                dataManagerActivity.setBundle (bundle);
                dataManagerActivity.cloneActivity (coActivity.getActivityId (), nActivityNewId);
            }
        }
        Set < CoTest > setTestClone = coSequence.getCoTests ();
        log.info ("NÔøΩmero de pruebas a clonar:_" + setTestClone.size ());
        for (CoTest coTest : setTestClone) {
            EntityManagerHelper.beginTransaction ();
            Long nTestNewId = getSequence ("sq_co_test");
            Query query = EntityManagerHelper.createNativeQuery (Statements.CLONE_TEST.replaceAll (":CLONE", bundle.getString ("course.create.clone")));
            query.setParameter (1, nTestNewId);
            query.setParameter (2, nSequenceNewId);
            query.setParameter (3, coTest.getTestId ());
            query.executeUpdate ();
            EntityManagerHelper.commit ();
            log.info ("Clonando prueba: " + coTest.getTestId ());
            DataManagerTest.addUserHistory (new RestServiceResult (), maUser, coTest);
            CoTest coTestNew = new CoTestDAO ().findById (new Long (nTestNewId));
            EntityManagerHelper.refresh (coTestNew);
            if (coTestNew != null) {
                EntityManagerHelper.beginTransaction ();
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_TEST_MATERIAL);
                query.setParameter (1, nTestNewId);
                query.setParameter (2, coTest.getTestId ());
                query.executeUpdate ();
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_QUESTION_WEIGHTED);
                query.setParameter (1, nTestNewId);
                query.setParameter (2, coTest.getTestId ());
                query.executeUpdate ();
                log.info ("Ok...");
                EntityManagerHelper.commit ();
                DataManagerTest dataManagerTest = new DataManagerTest ();
                dataManagerTest.setBundle (bundle);
                dataManagerTest.cloneTest (coTest.getTestId (), nTestNewId);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("PÔøΩrez");
            c.setApellido2 ("GÔøΩmez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=347=-----==

public RestServiceResult listMatrixExercises2ForExercises2 (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises2 coExercises2 = new CoExercises2DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises2);
    if (coExercises2 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixExercises2.search.notFound"));
    }
    else {
        List < CoMatrixExercises2 > list = new ArrayList < CoMatrixExercises2 > (coExercises2.getCoMatrixExercises2s ());
        Object [] arrayParam = {list.size (), coExercises2.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises2.listMatrixExercises2ForExercises2.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


public PortletName getPortletName (String portletName) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    DatabaseAdapter adapter = null;
    try {
        adapter = DatabaseAdapter.getInstance ();
        ps = adapter.prepareStatement ("select * from WM_PORTAL_PORTLET_NAME where TYPE=?");
        ps.setString (1, portletName);
        rs = ps.executeQuery ();
        PortletNameBean bean = null;
        if (rs.next ()) {
            WmPortalPortletNameItemType item = GetWmPortalPortletNameItem.fillBean (rs);
            bean = new PortletNameBean ();
            bean.setPortletId (item.getIdSiteCtxType ());
            bean.setPortletName (item.getType ());
            bean.setActive (false);
        }
        return bean;
    } catch (Exception e) {
        String es = "Error get getPortletName()";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (adapter, rs, ps);
        adapter = null;
        rs = null;
        ps = null;
    }
}


-----Function Pair=348=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void testTimestamps0048 () throws Exception {
    Connection cx = getConnection ();
    dropTable ("#t0048");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("create table #t0048              " + "(                               " + "  t1   datetime not null,       " + "  t2   datetime null,           " + "  t3   smalldatetime not null,  " + "  t4   smalldatetime null       " + ")");
    java.sql.Timestamp r1;
    java.sql.Timestamp r2;
    r1 = new java.sql.Timestamp (100, 0, 2, 19, 35, 01, 0 * 1000000);
    r2 = new java.sql.Timestamp (100, 0, 2, 19, 35, 0, 0);
    java.sql.PreparedStatement pstmt = cx.prepareStatement ("insert into #t0048 (t1, t2, t3, t4) values(?, ?, ?, ?)");
    pstmt.setTimestamp (1, r1);
    pstmt.setTimestamp (2, r1);
    pstmt.setTimestamp (3, r1);
    pstmt.setTimestamp (4, r1);
    int count = pstmt.executeUpdate ();
    assertTrue (count == 1);
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("select t1, t2, t3, t4 from #t0048");
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    java.sql.Timestamp t1 = rs.getTimestamp ("t1");
    java.sql.Timestamp t2 = rs.getTimestamp ("t2");
    java.sql.Timestamp t3 = rs.getTimestamp ("t3");
    java.sql.Timestamp t4 = rs.getTimestamp ("t4");
    assertEquals (r1, t1);
    assertEquals (r1, t2);
    assertEquals (r2, t3);
    assertEquals (r2, t4);
}


-----Function Pair=349=-----==

public boolean mailRead (int pmid) {
    boolean result = false;
    try {
        PreparedStatement pstmt = getCon ().prepareStatement ("update mail set stat=? where pmid = ? ");
        pstmt.setString (1, "read");
        pstmt.setInt (2, pmid);
        int num = pstmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return result;
}


public void executeInsert () {
    Session session = null;
    Transaction tx = null;
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        BasicUser user = (BasicUser) parameters.get (DataConnector.RECORD_PARAMETER);
        user.setIdString (user.getIdString ().toLowerCase ());
        user.setLastUpdate (new Date ());
        user.setLastUpdateBy (UserProfileManager.getUserId ());
        session.save (user);
        responseCode = 0;
        responseString = "Execution complete";
        tx.commit ();
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


-----Function Pair=350=-----==

public static List listPhotos (int album_id, int month_stamp, int date, int fromIdx, int count) {
    StringBuffer hql = new StringBuffer ("FROM PhotoOutlineBean AS p WHERE 1=1");
    if (album_id > 0) hql.append (" AND (p.album.id=:album OR p.album.parent.id=:album)");
    if (month_stamp > 190000 && month_stamp < 209912) {
        hql.append (" AND p.year=:year AND p.month=:month");
    }
    hql.append (" AND p.status<>:hidden_status AND p.album.type=:owner_album");
    if (date > 0) {
        hql.append (" AND p.date=:date");
    }
    hql.append (" AND p.site.status=:site_status ORDER BY p.id DESC");
    Session ssn = getSession ();
    try {
        Query q = ssn.createQuery (hql.toString ());
        if (album_id > 0) q.setInteger ("album", album_id);
        if (month_stamp > 190000 && month_stamp < 209912) {
            q.setInteger ("year", month_stamp / 100);
            q.setInteger ("month", month_stamp % 100);
        }
        q.setInteger ("hidden_status", PhotoBean.STATUS_PRIVATE);
        q.setInteger ("owner_album", AlbumBean.TYPE_PUBLIC);
        if (date > 0) {
            q.setInteger ("date", date);
        }
        q.setInteger ("site_status", SiteBean.STATUS_NORMAL);
        q.setFirstResult (fromIdx);
        q.setMaxResults (count);
        return q.list ();
    } finally {
        hql = null;
    }
}


public int addCliente (Cliente cli) throws errorConexionBD, errorSQL {
    System.out.println ("GestorCliente.addCliente()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        sql = "SELECT nif FROM persona WHERE nif='" + cli.getNif () + "'";
        System.out.println ("Ejecuando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            throw new errorSQL ("NIF duplicado en INSERT");
        }
        gd.begin ();
        sql = "INSERT INTO persona(nif, nombre, apellido1, apellido2, " + "direccion, poblacion,telefono, movil, email, fecha_baja)" + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setString (1, cli.getNif ());
        pstmt.setString (2, cli.getNombre ());
        pstmt.setString (3, cli.getApellido1 ());
        pstmt.setString (4, cli.getApellido2 ());
        pstmt.setString (5, cli.getDireccion ());
        pstmt.setString (6, cli.getPoblacion ());
        pstmt.setString (7, cli.getTelefono ());
        pstmt.setString (8, cli.getMovil ());
        pstmt.setString (9, cli.getEmail ());
        pstmt.setDate (10, (java.sql.Date) cli.getFechaBaja ());
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        pstmt.close ();
        rs.close ();
        sql = "INSERT INTO cliente (cod_cliente, tarjeta_credito, puntos)" + "VALUES (?,?,?) RETURNING cod_cliente";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, nuevoId);
        pstmt.setString (2, cli.getTarjetaCredito ());
        pstmt.setInt (3, 0);
        gd.commit ();
        System.out.println ("commit");
        rs = pstmt.executeQuery ();
        rs.close ();
        pstmt.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorCliente.addCliente()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=351=-----==

private static void shuffle (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        Person person1 = list.iterator ().next ();
        Person person2 = new Person ();
        person2.setFirstName ("William");
        person2.setLastName ("Bush");
        Address address = person1.getAddresses ().iterator ().next ();
        person1.getAddresses ().remove (address);
        person2.getAddresses ().add (address);
        session.save (person2);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("PÔøΩrez");
            c.setApellido2 ("GÔøΩmez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=352=-----==

private static void query (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            LOGGER.info ("Found: " + person);
            for (Address address : person.getAddresses ()) {
                LOGGER.info ("  with address: " + address);
            }
        }
    } finally {
        session.close ();
    }
}


public Settings findSettingByVariable (String variable) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Settings s where s.variable=?");
        query.setParameter (0, variable);
        List < Settings > settlist = query.list ();
        tr.commit ();
        if (settlist != null && settlist.size () == 1) {
            return settlist.get (0);
        }
        return null;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=353=-----==

private static void shuffle (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        Person person1 = collection.iterator ().next ();
        Person person2 = new Person ();
        person2.setFirstName ("William");
        person2.setLastName ("Bush");
        Address address = person1.getAddresses ().iterator ().next ();
        person1.getAddresses ().remove (address);
        entityManager.flush ();
        person2.getAddresses ().add (address);
        entityManager.persist (person2);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public Integer getAcDataCustomerCount (Integer customerId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (AcDataCustomer.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" data.id = '" + customerId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=354=-----==

public String giveRolebyUsername (String username) throws Exception {
    String role = null;
    Session session = null;
    Transaction tx = null;
    session = HibernateUtil.getSessionFactory ().openSession ();
    try {
        tx = session.beginTransaction ();
        String sql = "SELECT role_name FROM user_roles where user_name = ?";
        Query query = session.createSQLQuery (sql).setString (0, username);
        List ls = query.list ();
        for (Iterator iter = ls.iterator (); iter.hasNext ();) {
            role = (String) iter.next ();
        }
        tx.commit ();
        session.close ();
        return role;
    } catch (Exception e) {
        logger.error ("EXCEPTION While giveRolebyUsername", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
}


public String getStringValue (String sql) {
    String value = null;
    this.result = null;
    Connection conn = null;
    try {
        conn = ConnectUtil.getConnect ();
        PreparedStatement ps = conn.prepareStatement (sql);
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            value = rs.getString (1);
            break;
        }
        rs.close ();
        ps.close ();
    } catch (Exception e) {
        this.result = e.getMessage ();
    } finally {
        ConnectUtil.closeConn (conn);
    }
    return value;
}


-----Function Pair=355=-----==

public void updateUserForSuccesfulLogin (String username) throws Exception {
    Session session = null;
    Transaction tx = null;
    Users us = new Users ();
    try {
        setUp ();
        session = HibernateUtil.getSessionFactory ().openSession ();
        tx = session.beginTransaction ();
        List tmpUsers = this.session.createCriteria (Users.class).add (Restrictions.eq ("user_name", username)).list ();
        for (Iterator iter = tmpUsers.iterator (); iter.hasNext ();) {
            us = (Users) iter.next ();
            if (tmpUsers.size () == 1) {
                us.setLast_successful_login (((new Date ()).toString ()));
                session.update (us);
            }
            tx.commit ();
            session.close ();
        }
    } catch (Exception e) {
        logger.error ("EXCEPTION While update user", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
}


public boolean deleteReview (int sid, String revid) {
    DBConnection con = null;
    int rs = 0;
    boolean result = false;
    try {
        con = DBServiceManager.allocateConnection ();
        rs = con.executeUpdate ("DELETE FROM mdir_Site_Review WHERE di_review_id=" + revid);
        result = (rs != 0);
        Vector allReviews = getAllReviews (sid);
        float avg = 0;
        for (Enumeration e = allReviews.elements (); e.hasMoreElements ();) avg = avg + ((ObjectReview) e.nextElement ()).getRating ();
        avg = avg / allReviews.size ();
        if (allReviews.size () == 0) avg = 0;
        rs = con.executeUpdate ("UPDATE mdir_Site SET di_site_rating=" + avg + " WHERE di_site_id=" + sid);
    } catch (SQLException e) {
    } finally {
        if (con != null) {
            con.release ();
        }
    }
    result = result & (rs != 0);
    return result;
}


-----Function Pair=356=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public final boolean exists (Integer id) throws RecordException {
    Connection conn = ConnectionManager.getConnection ();
    LoggableStatement pStat = null;
    Class < ? extends RecordBase > actualClass = this.getClass ();
    String tableName = TableNameResolver.getTableName (actualClass);
    String sql = "select * from " + tableName + " where id = :id";
    StatementBuilder builder = new StatementBuilder (sql);
    builder.set ("id", id);
    try {
        pStat = builder.getPreparedStatement (conn);
        log.log (pStat.getQueryString ());
        ResultSet rs = pStat.executeQuery ();
        boolean exists = rs.next ();
        return exists;
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback");
        }
        throw new RecordException (e);
    } finally {
        try {
            if (pStat != null) {
                pStat.close ();
            }
            conn.commit ();
            conn.close ();
        } catch (SQLException e) {
            throw new RecordException ("Error closing connection");
        }
    }
}


-----Function Pair=357=-----==

public static void excluirCapitulo (final Connection con, final int cod) {
    try {
        con.setAutoCommit (false);
        Statement smt = con.createStatement ();
        ResultSet desc = smt.executeQuery ("SELECT codDescricao FROM capitulo WHERE " + "codCapitulo=" + cod);
        desc.next ();
        int codDesc = desc.getInt (1);
        smt.executeUpdate ("DELETE FROM capitulo WHERE codCapitulo=" + cod);
        smt.executeUpdate ("DELETE FROM descricao WHERE codDescricao=" + codDesc);
        con.commit ();
    } catch (SQLException e) {
        System.err.print (e.getMessage ());
    } finally {
        try {
            con.setAutoCommit (true);
        } catch (SQLException e2) {
            System.err.print (e2.getMessage ());
        }
    }
}


public String getName (String key, boolean openIdUsed) throws DatabaseException {
    PreparedStatement selectSt = null;
    String name = "unknown";
    try {
        if (openIdUsed) {
            selectSt = getConnection ().prepareStatement (SELECT_NAME_BY_OPENID);
            selectSt.setString (1, key);
        }
        else {
            selectSt = getConnection ().prepareStatement (SELECT_NAME_BY_ID);
            selectSt.setLong (1, Long.valueOf (key));
        }
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            name = rs.getString ("name") + " " + rs.getString ("surname");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    return name;
}


-----Function Pair=358=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nPostagId) {
    MaPostag maPostag = new MaPostagDAO ().findById (nPostagId);
    if (maPostag == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("postag.search.notFound"));
    }
    else {
        List < MaPostag > list = new ArrayList < MaPostag > ();
        EntityManagerHelper.refresh (maPostag);
        list.add (maPostag);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("postag.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=359=-----==

public void grabar () throws SQLException, ClassNotFoundException, Exception {
    Connection conn = null;
    try {
        conn = ToolsBD.getConn ();
        conn.setAutoCommit (false);
        cargar (conn);
        conn.commit ();
    } catch (Exception ex) {
        System.out.println (usuario + ": Excepci√≥: " + ex.getMessage ());
        ex.printStackTrace ();
        registroGrabado = false;
        errores.put ("", "Error inesperat, no s'ha desat l'ofici " + ": " + ex.getClass () + "->" + ex.getMessage ());
        try {
            if (conn != null) conn.rollback ();
        } catch (SQLException sqle) {
            throw new RemoteException (usuario + ": S'ha produ√Øt un error i no s'han pogut tornar enrere els canvis efectuats", sqle);
        }
        throw new RemoteException ("Error inesperat: No s'ha desat l'ofici", ex);
    } finally {
        ToolsBD.closeConn (conn, null, null);
    }
}


public void leer () {
    Connection conn = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    leidos = false;
    DateFormat yyyymmdd = new SimpleDateFormat ("yyyyMMdd");
    DateFormat ddmmyyyy = new SimpleDateFormat ("dd/MM/yyyy");
    java.util.Date fechaDocumento = null;
    try {
        conn = ToolsBD.getConn ();
        String sentenciaSql = "SELECT * FROM BZOFREM " + "WHERE REM_OFANY=? AND REM_OFOFI=? AND REM_OFNUM=?";
        ps = conn.prepareStatement (sentenciaSql);
        ps.setInt (1, Integer.parseInt (anoOficio));
        ps.setInt (2, Integer.parseInt (oficinaOficio));
        ps.setInt (3, Integer.parseInt (numeroOficio));
        rs = ps.executeQuery ();
        if (rs.next ()) {
            leidos = true;
            anoOficio = String.valueOf (rs.getInt ("REM_OFANY"));
            numeroOficio = String.valueOf (rs.getInt ("REM_OFNUM"));
            oficinaOficio = String.valueOf (rs.getInt ("REM_OFOFI"));
            String fechaO = String.valueOf (rs.getInt ("REM_OFFEC"));
            try {
                fechaDocumento = yyyymmdd.parse (fechaO);
                fechaOficio = (ddmmyyyy.format (fechaDocumento));
            } catch (Exception e) {
                fechaOficio = fechaO;
            }
            descripcion = rs.getString ("REM_CONT");
            anoSalida = String.valueOf (rs.getInt ("REM_SALANY"));
            numeroSalida = String.valueOf (rs.getInt ("REM_SALNUM"));
            oficinaSalida = String.valueOf (rs.getInt ("REM_SALOFI"));
            nulo = rs.getString ("REM_NULA");
            motivosNulo = rs.getString ("REM_NULMTD");
            usuarioNulo = rs.getString ("REM_NULUSU");
            String fechaN = String.valueOf (rs.getInt ("REM_NULFEC"));
            try {
                fechaDocumento = yyyymmdd.parse (fechaN);
                fechaNulo = (ddmmyyyy.format (fechaDocumento));
            } catch (Exception e) {
                fechaNulo = fechaN;
            }
            anoEntrada = String.valueOf (rs.getInt ("REM_ENTANY"));
            numeroEntrada = String.valueOf (rs.getInt ("REM_ENTNUM"));
            oficinaEntrada = String.valueOf (rs.getInt ("REM_ENTOFI"));
            descartadoEntrada = rs.getString ("REM_ENTDES");
            motivosDescarteEntrada = rs.getString ("REM_ENTMTD");
            usuarioEntrada = rs.getString ("REM_ENTUSU");
            String fechaE = String.valueOf (rs.getInt ("REM_ENTFEC"));
            try {
                fechaDocumento = yyyymmdd.parse (fechaE);
                fechaEntrada = (ddmmyyyy.format (fechaDocumento));
            } catch (Exception e) {
                fechaEntrada = fechaE;
            }
        }
    } catch (Exception e) {
        System.out.println ("ERROR: Leer: " + e.getMessage ());
        e.printStackTrace ();
    } finally {
        ToolsBD.closeConn (conn, ps, rs);
    }
}


-----Function Pair=360=-----==

public void deleteAcDataProject (Integer projectId, String [] userIds) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String delStr = null;
        for (int i = 0; i < userIds.length; i ++) {
            if (userIds [i] == null) {
                continue;
            }
            delStr = "delete from " + AcDataProject.class.getName () + " where data.id = '" + projectId + "' and viewer.id = '" + userIds [i] + "'";
            Query queryObject = getSession ().createQuery (delStr);
            queryObject.executeUpdate ();
        }
        tx.commit ();
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


protected long getLastRowIdInResultTable (long startId, int rows) throws SQLException {
    if (queryContext.getRunCount () % 50 != 0) {
        return startId < 0 ? rows : (startId + rows);
    }
    long lastRowId = Constants.DEFAULT_MONOTONIC_ID_VALUE;
    if (lastRowIdStmt == null) {
        lastRowIdStmt = connection.createStatement ();
    }
    ResultSet resultSet = null;
    try {
        resultSet = lastRowIdStmt.executeQuery (lastRowIdInResultTableSQL);
        while (resultSet.next ()) {
            lastRowId = resultSet.getLong (Constants.ID_COLUMN_POS + 1);
        }
    } finally {
        Helper.closeResultSet (resultSet);
    }
    return lastRowId;
}


-----Function Pair=361=-----==

private boolean existsIndex (EboContext ctx, String schemaName, String indexName) throws SQLException {
    Connection cn = null;
    ResultSet rslt = null;
    PreparedStatement pstm = null;
    try {
        cn = ctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("select count(*) from INFORMATION_SCHEMA.STATISTICS where INDEX_SCHEMA=database() and upper(INDEX_NAME)=? and upper(TABLE_NAME) = ?");
        pstm.setString (1, indexName.toUpperCase ());
        pstm.setString (2, schemaName.toUpperCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            if (rslt.getInt (1) > 0) {
                return true;
            }
        }
        return false;
    } catch (SQLException e) {
        throw (e);
    } finally {
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
}


public RestServiceResult search (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    if (maUser == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("user.search.notFound"));
    }
    else {
        List < MaUser > list = new ArrayList < MaUser > ();
        list.add (maUser);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=362=-----==

public static boolean update (String fullname, String username, String password, String login_alt) throws Exception {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean isExist = false;
        if (! login_alt.equals (username)) {
            {
                r.clear ();
                r.add ("user_login");
                r.add ("user_login", login_alt);
                sql = r.getSQLSelect ("users");
                ResultSet rs = stmt.executeQuery (sql);
                if (rs.next ()) isExist = true;
            }
        }
        if (! isExist) {
            r.clear ();
            r.add ("user_name", fullname);
            r.add ("user_password", mecca.util.PasswordService.encrypt (password));
            r.add ("user_login_alt", login_alt);
            r.update ("user_login", username);
            sql = r.getSQLUpdate ("users");
            int num = stmt.executeUpdate (sql);
            if (num > 0) return true;
            else return false;
        }
    } catch (SQLException ex) {
        Log.print (ex.getMessage () + "\n" + sql);
    } finally {
        if (db != null) db.close ();
    }
    return false;
}


private BrokerStorage () throws GridBrokerException {
    super ();
    try {
        logger.info ("Initialising Broker Storage...");
        Configuration cfg = new Configuration ();
        cfg.configure (Constants.BROKER_HIBERNATE_CONFIG);
        long start = System.currentTimeMillis ();
        sf = cfg.buildSessionFactory ();
        long end = System.currentTimeMillis ();
        logger.info ("Done: " + (end - start) + " ms.");
        cstore = new CredentialStorage ();
    } catch (Exception e) {
        e.printStackTrace ();
        throw new GridBrokerException ("Error creating storage instance.", e);
    }
}


-----Function Pair=363=-----==

protected void cleanMap () {
    synchronized (session) {
        Transaction tx = session.beginTransaction ();
        try {
            session.createQuery ("delete LearningFilterItem where length(searchString)>" + maxWordLength).setCacheable (false).executeUpdate ();
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in cleanMap: ", e);
            tx.rollback ();
        }
        List < Long > deleteList = new LinkedList < Long > ();
        tx = session.beginTransaction ();
        try {
            SQLQuery query = session.createSQLQuery ("select id FROM LEARNING_FILTER_ITEM");
            query.addScalar ("id", Hibernate.LONG).setCacheable (false);
            List < ? > list = query.list ();
            if (list.size () > maxItems) {
                double ratio = (maxItems * 0.75) / list.size ();
                for (Object object : list) {
                    Long l = (Long) object;
                    if (Math.random () > ratio) {
                        deleteList.add (l);
                    }
                }
            }
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in cleanMap: ", e);
            tx.rollback ();
        }
        if (deleteList.size () > 0) {
            long [] ids = new long [deleteList.size ()];
            int index = 0;
            for (Long l : deleteList) {
                ids [index] = l;
                index ++;
            }
            fastDeleteItemsByID (ids);
        }
    }
    fireDataChange (PART.ITEMS);
}


private void executeUpdate (final Appendable sql, final Statement stat, final MetaTable table) throws IllegalStateException, SQLException {
    boolean validateCase = false;
    switch (table.getOrm2ddlPolicy ()) {
        case INHERITED :
            throw new IllegalStateException ("An internal error due the DDL policy: " + table.getOrm2ddlPolicy ());
        case DO_NOTHING :
            return;
        case VALIDATE :
            validateCase = true;
        case WARNING :
            String msg = "A database validation (caused by the parameter " + MetaTable.ORM2DLL_POLICY + ") have found an inconsistency. " + "There is required a database change: " + sql;
            if (validateCase) {
                throw new IllegalStateException (msg);
            }
            else {
                LOGGER.log (Level.WARNING, msg);
            }
        default :
            stat.executeUpdate (sql.toString ());
            LOGGER.log (Level.INFO, sql.toString ());
    }
}


-----Function Pair=364=-----==

private ResultSet doSelectQuery (String sName, LinkedHashMap < String, Object > hmParameters, PreparedStatement oStatement) {
    ResultSet oResult;
    Connection oConnection = this.getConnection ();
    oResult = null;
    if (oConnection == null) {
        return null;
    }
    try {
        oResult = oStatement.executeQuery ();
        oResult.first ();
    } catch (SQLException oException) {
        if (this.reloadConnection ()) return this.doSelectQuery (sName, hmParameters, oStatement);
        else {
            throw new DatabaseException (ErrorCode.DATABASE_SELECT_QUERY, this.getQuery (sName, hmParameters), oException);
        }
    }
    return oResult;
}


public void testForceCharset1 () throws Exception {
    Properties props = new Properties ();
    props.setProperty (Messages.get (Driver.CHARSET), "Cp1251");
    props.setProperty (Messages.get (Driver.SENDSTRINGPARAMETERSASUNICODE), "false");
    Connection con = getConnectionOverrideProperties (props);
    try {
        String value = "–ê–ë–í";
        PreparedStatement pstmt = con.prepareStatement ("select ?");
        pstmt.setString (1, value);
        ResultSet rs = pstmt.executeQuery ();
        assertTrue (rs.next ());
        assertEquals (value, rs.getString (1));
        assertFalse (rs.next ());
        rs.close ();
        pstmt.close ();
    } finally {
        con.close ();
    }
}


-----Function Pair=365=-----==

public List < Ranks > findAllRanks () {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Ranks");
        List < Ranks > rankList = query.list ();
        tr.commit ();
        return rankList;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public RestServiceResult listMaterialForMenu (RestServiceResult serviceResult, Long nMenuId) {
    ArrayList < CoMaterial > list = new ArrayList < CoMaterial > ();
    CoMenu coMenu = new CoMenuDAO ().findById (nMenuId);
    EntityManagerHelper.refresh (coMenu);
    if (coMenu != null) {
        Set < CoMaterial > setMaterials = coMenu.getCoMaterials ();
        for (Iterator < CoMaterial > iterator = setMaterials.iterator (); iterator.hasNext ();) {
            CoMaterial coMaterial = (CoMaterial) iterator.next ();
            list.add (coMaterial);
        }
    }
    Object [] array = {list.size ()};
    serviceResult.setMessage (MessageFormat.format (bundle.getString ("material.list.success"), array));
    serviceResult.setObjResult (list);
    serviceResult.setNumResult (list.size ());
    return serviceResult;
}


-----Function Pair=366=-----==

public Connection getRepositoryConnection (boApplication app, String reposiToryName, int type) {
    String repositoryNameLower = reposiToryName.toLowerCase ();
    Connection ret = (Connection) p_connectionCache.get (repositoryNameLower + "[" + type + "]");
    try {
        if (ret == null || ret.isClosed ()) {
            if (type == 1) {
                ret = boRepository.getRepository (app, repositoryNameLower).getDedicatedConnection ();
            }
            else if (type == 2) {
                ret = boRepository.getRepository (app, repositoryNameLower).getDedicatedConnectionDef ();
            }
            p_connectionCache.put (repositoryNameLower + "[" + type + "]", ret);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return ret;
}


private void Update (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement ("update users set name=?,account=?,telephone=?,fax=?,email=?,mobile=?,face=?,cx=?,dept=?,utype=? where id=?");
        pstmt.setString (1, name);
        pstmt.setString (2, account);
        pstmt.setString (3, telephone);
        pstmt.setString (4, fax);
        pstmt.setString (5, email);
        pstmt.setString (6, mobile);
        pstmt.setString (7, face);
        pstmt.setInt (8, index);
        pstmt.setString (9, dept.GetId ());
        pstmt.setInt (10, type);
        pstmt.setString (11, id);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=367=-----==

public _Flight get (int id, int currentPilot) throws Exception, SQLException {
    ResultSet rs = null;
    _Flight _flight = new _Flight ();
    try {
        Statement stmt = conn.getStatement ();
        rs = stmt.executeQuery ("select id, nr, dato, flytype_id, startart, slaebetid, " + "motortid, svaevetid, distance, " + "startsted_id, landingssted_id, " + "note, straek, udelanding, kaptajn, instruktoer, " + "forsaede, passager, afbrudtstart " + "from flyvning " + "where pilot_id = " + currentPilot + " " + "and id = " + id);
        if (rs.next ()) {
            _flight.id = rs.getInt (1);
            _flight.nr = rs.getInt (2);
            _flight.dato = new java.util.Date (rs.getLong (3));
            _flight.flytype_id = rs.getInt (4);
            _flight.startart = rs.getString (5);
            _flight.slaebetid = rs.getInt (6);
            _flight.motortid = rs.getInt (7);
            _flight.svaevetid = rs.getInt (8);
            _flight.distance = rs.getInt (9);
            _flight.startsted_id = rs.getInt (10);
            _flight.landingssted_id = rs.getInt (11);
            _flight.note = rs.getString (12);
            _flight.straek = convertFromString (rs.getString (13));
            _flight.udelanding = convertFromString (rs.getString (14));
            _flight.kaptajn = convertFromString (rs.getString (15));
            _flight.instruktoer = convertFromString (rs.getString (16));
            _flight.forsaede = convertFromString (rs.getString (17));
            _flight.passager = convertFromString (rs.getString (18));
            _flight.afbrudtstart = convertFromString (rs.getString (19));
        }
        else _flight = null;
        stmt.close ();
    } catch (SQLException sqle) {
        log.error (sqle);
        _flight = null;
        throw sqle;
    } catch (Exception e) {
        log.error (e);
        _flight = null;
        throw e;
    } finally {
        rs = null;
    }
    return _flight;
}


private void jbInit () throws Exception {
    iniciar (740, 540);
    conecta ();
    dt = new DatosTabla (ct);
    dtBloq = new DatosTabla (ct);
    st = ct.createStatement ();
    st1 = ct.createStatement ();
    Pprinc.setDefButton (Baceptar);
    statusBar = new StatusBar (this);
    Pprinc.setLayout (null);
    cLabel1.setText ("De Fecha");
    cLabel1.setBounds (new Rectangle (11, 22, 55, 18));
    feciniE.setText ("01-04-2003");
    feciniE.setBounds (new Rectangle (70, 22, 70, 18));
    fecfinE.setText ("05-04-2003");
    fecfinE.setBounds (new Rectangle (213, 22, 77, 18));
    cLabel2.setText ("A");
    cLabel2.setBounds (new Rectangle (190, 23, 19, 17));
    Baceptar.setBounds (new Rectangle (118, 43, 108, 24));
    Baceptar.setText ("Aceptar");
    Vector v = new Vector ();
    Bsintar.setBounds (new Rectangle (137, 314, 168, 27));
    Bsintar.setText ("Mostar Ventas S/Tarifa");
    BactTar.setBounds (new Rectangle (354, 314, 97, 27));
    BactTar.setText ("Act.Tarifa");
    PintrDatos.setBorder (BorderFactory.createRaisedBevelBorder ());
    PintrDatos.setBounds (new Rectangle (156, 0, 311, 75));
    cPanel1.setBounds (new Rectangle (99, 3, 321, 74));
    PintrDatos.setLayout (null);
    cPanel1.setBorder (BorderFactory.createRaisedBevelBorder ());
    cPanel1.setBounds (new Rectangle (6, 78, 721, 369));
    cPanel1.setLayout (null);
    cLabel3.setBackground (Color.orange);
    cLabel3.setForeground (Color.white);
    cLabel3.setOpaque (true);
    cLabel3.setPreferredSize (new Dimension (42, 15));
    cLabel3.setHorizontalAlignment (SwingConstants.CENTER);
    cLabel3.setText ("Insertar Datos Venta en \'ven_angulo_iber\"");
    cLabel3.setBounds (new Rectangle (17, 4, 282, 14));
    Pconsulta.setLayout (null);
    feciniE1.setBounds (new Rectangle (178, 5, 79, 18));
    feciniE1.setText ("27-04-2003");
    cLabel4.setBounds (new Rectangle (119, 5, 55, 18));
    cLabel4.setText ("De Fecha");
    cLabel5.setBounds (new Rectangle (265, 6, 19, 17));
    cLabel5.setText ("A");
    fecfinE1.setBounds (new Rectangle (282, 5, 83, 20));
    fecfinE1.setText ("31-05-2003");
    Bacecon.setBounds (new Rectangle (179, 43, 105, 26));
    Bacecon.setText ("Aceptar");
    Pconsulta.setDefButton (Bacecon);
    Pconsulta.setDefButtonDisable (false);
    cPanel2.setBorder (BorderFactory.createLoweredBevelBorder ());
    cPanel2.setText ("cPanel2");
    cPanel2.setBounds (new Rectangle (15, 89, 434, 125));
    cPanel2.setLayout (null);
    cLabel6.setText ("Datos Raul Angulo");
    cLabel6.setBounds (new Rectangle (8, 11, 105, 16));
    nombficE.setText ("/home/cpuente/documentos/angulo/junio/ventas.csv");
    nombficE.setBounds (new Rectangle (9, 31, 391, 18));
    Bcarfic.setBounds (new Rectangle (159, 73, 132, 27));
    Bcarfic.setText ("Cargar Fichero");
    Bbusfic.setBounds (new Rectangle (405, 28, 22, 23));
    Bbusfic.setMargin (new Insets (0, 0, 0, 0));
    Bbusfic.setText ("");
    cPanel3.setBorder (BorderFactory.createEtchedBorder ());
    cPanel3.setBounds (new Rectangle (16, 221, 440, 83));
    cPanel3.setLayout (null);
    cLabel7.setBounds (new Rectangle (11, 5, 86, 17));
    cLabel7.setText ("Tarifa a cargar");
    Bcarfic1.setText ("Cargar Fichero");
    Bcarfic1.setBounds (new Rectangle (156, 48, 132, 27));
    nombficE1.setBounds (new Rectangle (9, 27, 391, 18));
    nombficE1.setText ("/home/cpuente/documentos/angulo/junio/tarifa.txt");
    Bbusfic1.setText ("");
    Bbusfic1.setMargin (new Insets (0, 0, 0, 0));
    Bbusfic1.setBounds (new Rectangle (406, 23, 22, 23));
    v.add ("Num.Alb");
    v.add ("Fec.Albaran");
    v.add ("Cliente");
    v.add ("Nombre Cliente");
    v.add ("Producto");
    v.add ("Nombre Producto");
    v.add ("K.Venta");
    v.add ("Pr.Venta");
    v.add ("Pr.Tarifa");
    jt.setCabecera (v);
    jt.setAnchoColumna (new int [] {54, 78, 52, 185, 50, 167, 45, 42, 62});
    jt.setCellEditable (true, 8);
    jt.setBounds (new Rectangle (6, 5, 701, 290));
    this.getContentPane ().add (statusBar, BorderLayout.SOUTH);
    this.getContentPane ().add (TPentra, BorderLayout.CENTER);
    TPentra.add ("Actualizar", Pprinc);
    TPentra.add (Pconsulta, "Consulta");
    Pconsulta.add (fecfinE1, null);
    Pconsulta.add (cLabel4, null);
    Pconsulta.add (feciniE1, null);
    Pconsulta.add (cLabel5, null);
    Pconsulta.add (Bacecon, null);
    Pconsulta.add (cPanel2, null);
    cPanel2.add (cLabel6, null);
    cPanel2.add (nombficE, null);
    cPanel2.add (Bbusfic, null);
    cPanel2.add (Bcarfic, null);
    Pconsulta.add (cPanel3, null);
    cPanel3.add (cLabel7, null);
    cPanel3.add (nombficE1, null);
    cPanel3.add (Bbusfic1, null);
    cPanel3.add (Bcarfic1, null);
    Pprinc.add (cPanel1, null);
    PintrDatos.add (Baceptar, null);
    PintrDatos.add (feciniE, null);
    PintrDatos.add (fecfinE, null);
    PintrDatos.add (cLabel2, null);
    PintrDatos.add (cLabel1, null);
    PintrDatos.add (cLabel3, null);
    Pprinc.add (cPanel1, null);
    cPanel1.add (BactTar, null);
    cPanel1.add (Bsintar, null);
    cPanel1.add (jt, null);
    Pprinc.add (PintrDatos, null);
}


-----Function Pair=368=-----==

public void iniciarVentana () throws Exception {
    String feulin;
    gnu.chu.Menu.LoginDB.iniciarLKEmpresa (EU, dtStat);
    s = "select MAX(rgs_fecha) as cci_feccon from v_regstock as r,v_motregu  as m " + " where r.emp_codi = " + EU.em_cod + " and r.tir_codi = m.tir_codi " + " and M.tir_afestk='=' ";
    dtStat.select (s);
    if (dtStat.getDatos ("cci_feccon") == null) feulin = "01-01-" + EU.ejercicio;
    else feulin = dtStat.getFecha ("cci_feccon", "dd-MM-yyyy");
    s = "select * from v_motregu WHERE tir_afestk='='";
    if (! dtStat.select (s)) throw new Exception ("No encontrado Motivo tipo Inventario");
    tirCodi = dtStat.getInt ("tir_codi");
    valoraC.addItem ("--", "-");
    valoraC.addItem ("SI", "S");
    valoraC.addItem ("NO", "N");
    jtCab.setAltButton (Bactgrid);
    jtLin.setAltButton (Bactgrid);
    jtCab.setDefButton (Baceptar);
    jtLin.setDefButton (Baceptar);
    jtCab.setButton (KeyEvent.VK_F4, Baceptar);
    jtLin.setButton (KeyEvent.VK_F4, Baceptar);
    jtCab.setButton (KeyEvent.VK_F5, Bcalc);
    jtLin.setButton (KeyEvent.VK_F5, Bcalc);
    eje_numeE.setColumnaAlias ("eje_nume");
    deo_fechaE.setColumnaAlias ("deo_fecha");
    deo_codiE.setColumnaAlias ("deo_codi");
    tid_codiE.setColumnaAlias ("tid_codi");
    pro_codiE.setColumnaAlias ("pro_codi");
    deo_ejelotE.setColumnaAlias ("deo_ejelot");
    deo_emplotE.setColumnaAlias ("deo_emplot");
    deo_serlotE.setColumnaAlias ("deo_serlot");
    pro_loteE.setColumnaAlias ("pro_lote");
    pro_numindE.setColumnaAlias ("pro_numind");
    deo_kilosE.setColumnaAlias ("deo_kilos");
    deo_prcostE.setColumnaAlias ("deo_prcost");
    deo_ejlogeE.setColumnaAlias ("deo_ejloge");
    deo_emlogeE.setColumnaAlias ("deo_emloge");
    deo_selogeE.setColumnaAlias ("deo_seloge");
    deo_nulogeE.setColumnaAlias ("deo_nuloge");
    grd_numeE.setColumnaAlias ("deo_numdes");
    feulinE.setText (feulin);
    activarEventos ();
    verDatos (dtCons);
    this.setEnabled (true);
    mensajeErr ("");
    activar (false);
}


public void lock (String oid, String key) throws PersisterException {
    String lock = getLock (oid);
    if (lock == null) {
        throw new PersisterException ("Object does not exist: OID = " + oid);
    }
    else if (! NULL.equals (lock) && (! lock.equals (key))) {
        throw new PersisterException ("The object is currently locked with another key: OID = " + oid + ", LOCK = " + lock + ", KEY = " + key);
    }
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("update " + _table_name + " set " + _key_col + " = ?, " + _ts_col + " = ? where " + _oid_col + " = ?");
        ps.setString (1, key);
        ps.setLong (2, System.currentTimeMillis ());
        ps.setString (3, oid);
        ps.executeUpdate ();
    } catch (Throwable th) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (Throwable th2) {
            }
        }
        throw new PersisterException ("Failed to lock object: OID = " + oid + ", KEY = " + key, th);
    } finally {
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=369=-----==

protected void copyEntity (EOEntity entity) throws SQLException {
    EOAttribute [] attributes = attributesArray (entity.attributes ());
    String tableName = entity.externalName ();
    String [] columnNames = columnsFromAttributes (attributes, true);
    String [] columnNamesWithoutQuotes = columnsFromAttributes (attributes, false);
    StringBuffer selectBuf = new StringBuffer ();
    selectBuf.append ("select ");
    selectBuf.append (columnsFromAttributesAsArray (attributes, _quoteSource).componentsJoinedByString (", ")).append (" from ");
    if (_quoteSource) {
        selectBuf.append ("\"" + tableName + "\"");
    }
    else {
        selectBuf.append (tableName);
    }
    EOQualifier qualifier = entity.restrictingQualifier ();
    if (qualifier != null) {
        EOAdaptor adaptor = EOAdaptor.adaptorWithName ("JDBC");
        adaptor.setConnectionDictionary (_sourceDictionary);
        EOSQLExpressionFactory factory = adaptor.expressionFactory ();
        EOSQLExpression sqlExpression = factory.createExpression (entity);
        String sqlString = EOQualifierSQLGeneration.Support._sqlStringForSQLExpression (qualifier, sqlExpression);
        selectBuf.append (" where ").append (sqlString);
    }
    selectBuf.append (";");
    String sql = selectBuf.toString ();
    Statement stmt = _source.createStatement ();
    StringBuffer insertBuf = new StringBuffer ();
    insertBuf.append ("insert into ");
    if (_quoteDestination) {
        insertBuf.append ("\"" + tableName + "\"");
    }
    else {
        insertBuf.append (tableName);
    }
    insertBuf.append (" (").append (columnsFromAttributesAsArray (attributes, _quoteDestination).componentsJoinedByString (", ")).append (") values (");
    for (int i = columnNames.length; i -- > 0;) {
        insertBuf.append ("?");
        if (i > 0) {
            insertBuf.append (", ");
        }
    }
    insertBuf.append (");");
    String insertSql = insertBuf.toString ();
    System.out.println ("CopyTask.copyEntity: " + insertSql);
    PreparedStatement upps = _dest.prepareStatement (insertSql);
    ResultSet rows = stmt.executeQuery (sql);
    int rowsCount = 0;
    while (rows.next ()) {
        rowsCount ++;
        if (rows.getRow () % 1000 == 0) {
            System.out.println ("CopyTask.copyEntity: table " + tableName + ", inserted " + rows.getRow () + " rows");
            log.info ("table " + tableName + ", inserted " + rows.getRow () + " rows");
        }
        NSMutableSet < File > tempfilesToDelete = new NSMutableSet < File > ();
        for (int i = 0; i < columnNamesWithoutQuotes.length; i ++) {
            String columnName = columnNamesWithoutQuotes [i];
            int type = rows.getMetaData ().getColumnType (i + 1);
            Object o = rows.getObject (columnName);
            if (log.isDebugEnabled ()) {
                if (o != null) {
                    log.info ("column=" + columnName + ", value class=" + o.getClass ().getName () + ", value=" + o);
                }
                else {
                    log.info ("column=" + columnName + ", value class unknown, value is null");
                }
            }
            if (o instanceof Blob) {
                Blob b = (Blob) o;
                InputStream bis = b.getBinaryStream ();
                File tempFile = null;
                try {
                    tempFile = File.createTempFile ("TempJDBC", ".blob");
                    ERXFileUtilities.writeInputStreamToFile (bis, tempFile);
                } catch (IOException e5) {
                    log.error ("could not create tempFile for row " + rows.getRow () + " and column " + columnName + ", setting column value to null!");
                    upps.setNull (i + 1, type);
                    if (tempFile != null) if (! tempFile.delete ()) tempFile.delete ();
                    continue;
                }
                FileInputStream fis;
                try {
                    fis = new FileInputStream (tempFile);
                } catch (FileNotFoundException e6) {
                    log.error ("could not create FileInputStream from tempFile for row " + rows.getRow () + " and column " + columnName + ", setting column value to null!");
                    upps.setNull (i + 1, type);
                    if (tempFile != null) if (! tempFile.delete ()) tempFile.delete ();
                    continue;
                }
                upps.setBinaryStream (i + 1, fis, (int) tempFile.length ());
                tempfilesToDelete.addObject (tempFile);
            }
            else if (o != null) {
                upps.setObject (i + 1, o);
            }
            else {
                upps.setNull (i + 1, type);
            }
        }
        upps.executeUpdate ();
        upps.clearParameters ();
        for (Enumeration e = tempfilesToDelete.objectEnumerator (); e.hasMoreElements ();) {
            File f = (File) e.nextElement ();
            if (! f.delete ()) f.delete ();
        }
    }
    log.info ("table " + tableName + ", inserted " + rowsCount + " rows");
    rows.close ();
}


public Long addUserInfo (AuthSession authSession, AuthInfo authInfo, List < RoleEditableBean > roles) {
    DatabaseAdapter db = null;
    try {
        db = DatabaseAdapter.getInstance ();
        Long companyId = authSession.checkCompanyId (authInfo.getCompanyId ());
        Long holdingId = authSession.checkHoldingId (authInfo.getHoldingId ());
        Long id = addUserInfo (db, authInfo, roles, companyId, holdingId);
        db.commit ();
        return id;
    } catch (Throwable e) {
        try {
            if (db != null) db.rollback ();
        } catch (Exception e001) {
        }
        final String es = "Error add user auth";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db);
        db = null;
    }
}


-----Function Pair=370=-----==

public int getMessageCount (Board board, int maxDaysBack) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps;
    if (maxDaysBack < 0) {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM " + getMessageTableName () + " WHERE board=? AND isvalid=TRUE");
        ps.setInt (1, board.getPrimaryKey ().intValue ());
    }
    else {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM " + getMessageTableName () + " WHERE msgdatetime>=? AND board=? AND isvalid=TRUE");
        LocalDate localDate = new LocalDate (DateTimeZone.UTC).minusDays (maxDaysBack);
        ps.setLong (1, localDate.toDateMidnight (DateTimeZone.UTC).getMillis ());
        ps.setInt (2, board.getPrimaryKey ().intValue ());
    }
    int count = 0;
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        count = rs.getInt (1);
    }
    rs.close ();
    ps.close ();
    return count;
}


public Boolean createDatabaseTable (String FileName) {
    Boolean result = false;
    try {
        ExecuteSqlScript sqlExec = new ExecuteSqlScript (FileName, getJDBCConnection ());
        sqlExec.loadScript ();
        sqlExec.execute ();
        result = true;
    } catch (IOException ex) {
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (SQLException ex) {
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return result;
}


-----Function Pair=371=-----=1=

public boolean setupDatabaseSchema () {
    Configuration cfg = Configuration.getInstance ();
    Connection con = getConnection ();
    if (null == con) return false;
    try {
        String sql = FileTool.readFile (cfg.getProperty ("database.sql.rootdir") + System.getProperty ("file.separator") + cfg.getProperty ("database.sql.mysql.setupschema"));
        sql = sql.replaceAll (MYSQL_SQL_SCHEMA_REPLACEMENT, StateSaver.getInstance ().getDatabaseSettings ().getSchema ());
        con.setAutoCommit (false);
        Statement stmt = con.createStatement ();
        String [] sqlParts = sql.split (";");
        for (String sqlPart : sqlParts) {
            if (sqlPart.trim ().length () > 0) stmt.executeUpdate (sqlPart);
        }
        con.commit ();
        JOptionPane.showMessageDialog (null, language.getProperty ("database.messages.executionsuccess"), language.getProperty ("dialog.information.title"), JOptionPane.INFORMATION_MESSAGE);
        return true;
    } catch (SQLException e) {
        Logger.logException (e);
    }
    try {
        if (con != null) con.rollback ();
    } catch (SQLException e) {
        Logger.logException (e);
    }
    JOptionPane.showMessageDialog (null, language.getProperty ("database.messages.executionerror"), language.getProperty ("dialog.error.title"), JOptionPane.ERROR_MESSAGE);
    return false;
}


public int subclass (int objectId, String description) throws FidoDatabaseException, ObjectNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "insert into Objects (Description) " + "values ('" + description + "')";
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            if (contains (stmt, objectId) == false) throw new ObjectNotFoundException (objectId);
            stmt.executeUpdate (sql);
            int id;
            sql = "select currval('objects_objectid_seq')";
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new SQLException ("No rows returned from select currval() query");
            else id = rs.getInt (1);
            ObjectLinkTable objectLinkList = new ObjectLinkTable ();
            objectLinkList.linkObjects (stmt, id, "isa", objectId);
            conn.commit ();
            return id;
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=372=-----==

public RestServiceResult createMenuUser (RestServiceResult serviceResult, CoMenu coMenu, Long nUserId) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_MENU_USER);
        query.setParameter (1, coMenu.getMenuId ());
        query.setParameter (2, nUserId);
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coMenu.getMenuName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("menu.createMenuUser.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la unit: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("menu.createMenuUser.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


public Template doTemplate () throws Exception {
    HttpSession session = request.getSession ();
    String template_name = "vtl/sis/setup_exam.vm";
    String submit = getParam ("command");
    context.put ("examDetail", new Hashtable ());
    if ("add".equals (submit) || "update".equals (submit)) {
        Hashtable exam = add ();
        context.put ("examDetail", exam);
    }
    else if ("getdata".equals (submit)) {
        Hashtable exam = getdata ();
        context.put ("examDetail", exam);
    }
    else if ("delete".equals (submit)) {
        delete ();
    }
    else if ("updatedisplay".equals (submit)) {
        String [] ids = request.getParameterValues ("exam_ids");
        if (ids != null) updateDisplay (ids);
    }
    Vector v = list ();
    context.put ("examVector", v);
    Template template = engine.getTemplate (template_name);
    return template;
}


-----Function Pair=373=-----==

public RestServiceResult listAnnouncementForUser (RestServiceResult serviceResult, Long nUserId) {
    log.info ("El usuario es: " + nUserId);
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    if (maUser == null) {
        serviceResult.setError (true);
    }
    else {
        List < AgAnnouncement > list = new ArrayList < AgAnnouncement > (maUser.getAgAnnouncements ());
        if (list.size () == 0) {
            log.info ("lista de anuncios vacia..");
        }
        else {
            log.info ("lista de anuncios cargada..");
        }
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        address1.setPerson (person);
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        address2.setPerson (person);
        person.getAddresses ().add (address2);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=374=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public boolean deleteImcompleteCartsClient (String mailClient) {
    Connection conexion = null;
    PreparedStatement deleteHistorialCarros = null;
    PreparedStatement deleteProdCarro = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        conexion.setAutoCommit (false);
        ArrayList < String > carrosIncompletos = this.requestIncompleteCarts (mailClient);
        if (carrosIncompletos != null) {
            deleteHistorialCarros = conexion.prepareStatement ("DELETE FROM " + nameBD + ".HistorialCarritos WHERE CodigoCarrito=?");
            deleteProdCarro = conexion.prepareStatement ("DELETE FROM " + nameBD + ".Carritos WHERE CodigoCarrito=?");
            for (int i = 0; i < carrosIncompletos.size (); i ++) {
                deleteHistorialCarros.setString (1, carrosIncompletos.get (i));
                deleteHistorialCarros.execute ();
                deleteHistorialCarros.clearParameters ();
                deleteProdCarro.setString (1, carrosIncompletos.get (i));
                deleteProdCarro.execute ();
                deleteProdCarro.clearParameters ();
            }
        }
        conexion.commit ();
        exito = true;
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error borrando los carritos incompletos de un usuario", ex);
        try {
            conexion.rollback ();
        } catch (SQLException ex1) {
            logger.log (Level.SEVERE, "Error haciendo rollback de la transacci√≥n para borrar carros incompletos de un usuario", ex1);
        }
    } finally {
        cerrarConexionYStatement (conexion, deleteHistorialCarros, deleteProdCarro);
    }
    return exito;
}


-----Function Pair=375=-----==

public void testFilter () throws Exception {
    Session s;
    Transaction tx;
    s = openSession ();
    tx = s.beginTransaction ();
    s.createQuery ("delete Forest").executeUpdate ();
    Forest f1 = new Forest ();
    f1.setLength (2);
    s.persist (f1);
    Forest f2 = new Forest ();
    f2.setLength (20);
    s.persist (f2);
    Forest f3 = new Forest ();
    f3.setLength (200);
    s.persist (f3);
    tx.commit ();
    s.close ();
    s = openSession ();
    tx = s.beginTransaction ();
    s.enableFilter ("betweenLength").setParameter ("minLength", 5).setParameter ("maxLength", 50);
    long count = ((Long) s.createQuery ("select count(*) from Forest").iterate ().next ()).intValue ();
    assertEquals (1, count);
    s.disableFilter ("betweenLength");
    s.enableFilter ("minLength").setParameter ("minLength", 5);
    count = ((Long) s.createQuery ("select count(*) from Forest").iterate ().next ()).longValue ();
    assertEquals (2l, count);
    s.disableFilter ("minLength");
    tx.rollback ();
    s.close ();
}


public void testInnerJoinOneToManyUniFKOwner () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        UserGroup grp = new UserGroup (101, "JPOX Users");
        GroupMember member1 = new GroupMember (201, "Joe User");
        grp.getMembers ().add (member1);
        em.persist (grp);
        em.flush ();
        List result = em.createQuery ("SELECT Object(G) FROM " + UserGroup.class.getName () + " G " + "INNER JOIN G.members M").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=376=-----==

public void createStorageSchema (String type) throws Exception {
    Session session = null;
    Transaction tx = null;
    try {
        String schema = "/storage-" + type + ".sql";
        session = sessionFactory.openSession ();
        SQLQuery sqlQuery = session.createSQLQuery (AppUtil.readClasspathFile (schema));
        sqlQuery.executeUpdate ();
    } catch (Exception ex) {
        if (tx != null) {
            tx.rollback ();
        }
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


public String [] app2Hosts (String appName) throws XregistryException {
    Connection connection = globalContext.createConnection ();
    PreparedStatement statement = null;
    ResultSet results = null;
    try {
        statement = connection.prepareStatement (GIVEN_APP_FIND_HOSTS_SQL);
        statement.setString (1, appName);
        log.info ("Execuate SQL " + statement);
        results = statement.executeQuery ();
        ArrayList < String > list = new ArrayList < String > ();
        while (results.next ()) {
            list.add (results.getString (HOST_NAME));
        }
        return Utils.toStrListToArray (list);
    } catch (SQLException e) {
        throw new XregistryException (e);
    } finally {
        try {
            results.close ();
            statement.close ();
            globalContext.closeConnection (connection);
        } catch (SQLException e) {
            throw new XregistryException (e);
        }
    }
}


-----Function Pair=377=-----==

public static HashMap < SeedGroupExperimentIdInstanceId, Integer > getMaxRunsForSeedGroupsByExperimentIdsAndInstanceId (List < Integer > seed_groups, List < Integer > expIds, List < Integer > instanceIds) throws SQLException {
    HashMap < SeedGroupExperimentIdInstanceId, Integer > res = new HashMap < SeedGroupExperimentIdInstanceId, Integer > ();
    if (expIds.isEmpty () || seed_groups.isEmpty () || instanceIds.isEmpty ()) {
        return res;
    }
    Statement st = DatabaseConnector.getInstance ().getConn ().createStatement ();
    ResultSet rs = st.executeQuery ("SELECT MAX(RUN), ExperimentResults.Experiment_idExperiment, seed_group, Instances_idInstance " + "FROM ExperimentResults JOIN SolverConfig ON (ExperimentResults.SolverConfig_idSolverConfig = SolverConfig.idSolverConfig) " + "WHERE ExperimentResults.Experiment_idExperiment IN (" + edacc.experiment.Util.getIdArray (expIds) + ") AND seed_group IN (" + edacc.experiment.Util.getIdArray (seed_groups) + ") AND Instances_idInstance IN (" + edacc.experiment.Util.getIdArray (instanceIds) + ") GROUP BY ExperimentResults.Experiment_idExperiment, seed_group, Instances_idInstance;");
    while (rs.next ()) {
        int maxRuns = rs.getInt (1);
        int expId = rs.getInt (2);
        int seedGroup = rs.getInt (3);
        int instanceId = rs.getInt (4);
        res.put (new SeedGroupExperimentIdInstanceId (seedGroup, expId, instanceId), maxRuns);
    }
    rs.close ();
    st.close ();
    return res;
}


public void ResetPassword (String uid, String pass) throws NpsException {
    if (! IsSysAdmin () && ! IsLocalAdmin ()) throw new NpsException (ErrorHelper.ACCESS_NOPRIVILEGE);
    Connection conn = null;
    try {
        conn = Database.GetDatabase ("fly").GetConnection ();
        if (! IsSysAdmin ()) {
            User aUser = GetUser (conn, uid);
            if (aUser == null) throw new NpsException ("√ªÔøΩÔøΩÔøΩ“µÔøΩ÷∏ÔøΩÔøΩÔøΩ√ªÔøΩÔøΩÔøΩœ¢ÔøΩÔøΩÔøΩ«πÔøΩŒªÔøΩÔøΩÔøΩ√ªÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ", ErrorHelper.SYS_NOUSER);
        }
        ChangePassword (conn, uid, pass);
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=378=-----==

public void testCancel0001 () throws Exception {
    Connection con2 = getConnection ();
    Statement stmt = con.createStatement ();
    assertFalse (stmt.execute ("create table ##SAfe0001 (id int primary key, val varchar(20) null)"));
    assertFalse (stmt.execute ("insert into ##SAfe0001 values (1, 'Line 1') " + "insert into ##SAfe0001 values (2, 'Line 2')"));
    assertEquals (1, stmt.getUpdateCount ());
    assertTrue (! stmt.getMoreResults ());
    assertEquals (1, stmt.getUpdateCount ());
    assertTrue (! stmt.getMoreResults ());
    assertEquals (- 1, stmt.getUpdateCount ());
    con.setAutoCommit (false);
    stmt.executeUpdate ("update ##SAfe0001 set val='Updated Line' where id=1");
    final Statement stmt2 = con2.createStatement ();
    new Thread () {
        public void run () {
            try {
                sleep (1000);
                stmt2.cancel ();
            } catch (Exception ex) {
                ex.printStackTrace ();
            }
        }
    }
    .start ();
    try {
        stmt2.executeQuery ("if 1 = 1 select * from ##SAfe0001");
        stmt2.getMoreResults ();
        fail ("Expecting cancel exception");
    } catch (SQLException ex) {
        assertEquals ("Expecting cancel exception. Got " + ex.getMessage (), "HY008", ex.getSQLState ());
    }
    con.setAutoCommit (true);
    stmt.execute ("drop table ##SAfe0001");
    stmt.close ();
    ResultSet rs = stmt2.executeQuery ("select 1");
    assertTrue (rs.next ());
    assertEquals (1, rs.getInt (1));
    assertTrue (! rs.next ());
    stmt2.close ();
    con2.close ();
}


public List getFutureTransaction (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from FutureTransaction R where R.uid=? and R.nextRunDate = ? order by R.id";
        GregorianCalendar today = new GregorianCalendar ();
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setDate (1, today.getTime ());
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=379=-----==

public boolean crear () {
    int result = 0;
    String sql = "insert into ronda" + "(divisionxTorneo_idDivisionxTorneo, fechaRonda, nRonda, estado ) " + "values (?, ?, ?, ?)";
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        populatePreparedStatement (unaRonda);
        result = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (result > 0);
}


public void executeGetByEmail () {
    Session session = null;
    Transaction tx = null;
    String email = (String) parameters.get (DataConnector.RECORD_KEY_PARAMETER);
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        Object allResults = session.find ("from BasicUser as user where user.person.contacts['email'].value='" + email + "' order by user.person.lastName");
        if (allResults != null) {
            ArrayList arrayList = (ArrayList) allResults;
            if (arrayList.size () == 0) {
                responseCode = 1;
                responseString = "Record not found";
            }
            else {
                Iterator i = arrayList.iterator ();
                executionResults = i.next ();
                responseCode = 0;
                responseString = "Execution complete";
            }
        }
        else {
            responseCode = 1;
            responseString = "Record not found";
        }
        tx.commit ();
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


-----Function Pair=380=-----==

public Imovel procurarImovelId (final Integer id) throws Exception {
    Session session = Hibernate.getSessionFactory ().getCurrentSession ();
    try {
        session.beginTransaction ();
        Imovel returnImovel = (Imovel) session.createQuery ("from Imovel where codImovel =" + id);
        session.getTransaction ().commit ();
        return returnImovel;
    } catch (HibernateException e) {
        if (session != null) {
            session.getTransaction ().rollback ();
        }
        throw new HibernateException ("HIBERNATE Erro no Procurar Por ID Imovel: ", e);
    } catch (Exception e) {
        throw new Exception ("", e);
    }
}


public static < T extends Comparable < T > > void BubbleSortComparable1 (T [] num) {
    int j;
    boolean flag = true;
    T temp;
    while (flag) {
        flag = false;
        for (j = 0; j < num.length - 1; j ++) {
            if (num [j].compareTo (num [j + 1]) > 0) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=381=-----==

public static ArrayList < ExperimentResult > getAllByInstanceId (int id) throws NoConnectionToDBException, SQLException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException {
    ArrayList < ExperimentResult > v = new ArrayList < ExperimentResult > ();
    HashMap < Integer, ExperimentResult > expResultsMap = new HashMap < Integer, ExperimentResult > ();
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (selectQuery + "WHERE Instances_idInstance=?;");
    st.setInt (1, id);
    ResultSet rs = st.executeQuery ();
    while (rs.next ()) {
        ExperimentResult er = getExperimentResultFromResultSet (rs);
        er.setSaved ();
        expResultsMap.put (er.getId (), er);
        v.add (er);
    }
    ExperimentResultHasPropertyDAO.assign (expResultsMap, v);
    rs.close ();
    st.close ();
    return v;
}


public static Tab getTab (String usrlogin, String tabid) throws DbException {
    Tab tab = null;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("tab_title");
        r.add ("display_type");
        r.add ("user_login", usrlogin);
        r.add ("tab_id", tabid);
        sql = r.getSQLSelect ("tab_user");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            String tab_title = rs.getString ("tab_title");
            String displaytype = rs.getString ("display_type");
            tab = new Tab (tabid, tab_title, displaytype);
        }
    } catch (SQLException sqlex) {
        throw new DbException (sqlex.getMessage () + " : " + sql);
    } finally {
        if (db != null) db.close ();
    }
    return tab;
}


-----Function Pair=382=-----==

private void createTables () throws Exception {
    String databaseType = Environment.getInstance ().getDatabaseType ();
    String resourceName = new StringBuffer ().append ("create_").append (databaseType).append (".sql").toString ();
    InputStream createScriptStream = WikiBase.getInstance ().getResourceAsStream (resourceName);
    if (createScriptStream == null) {
        logger.log (Level.SEVERE, "Can't find create script: " + resourceName);
        throw new WikiException ("unable to create database, sql script file missing: " + resourceName);
    }
    BufferedReader in = new BufferedReader (new InputStreamReader (createScriptStream));
    StringBuffer buffer = new StringBuffer ();
    while (true) {
        String line = in.readLine ();
        if (line == null) {
            break;
        }
        if (line.length () > 0 && line.charAt (0) != '#') buffer.append (line);
    }
    in.close ();
    StringTokenizer tokens = new StringTokenizer (buffer.toString (), ";");
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        Statement st = conn.createStatement ();
        while (tokens.hasMoreTokens ()) {
            String token = tokens.nextToken ();
            try {
                st.executeUpdate (token);
            } catch (SQLException e) {
                logger.log (Level.WARNING, "", e);
            }
        }
        st.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
}


public StringSet querySiteUuid (String siteUuid) throws SQLException {
    siteUuid = Val.chkStr (siteUuid);
    PreparedStatement st = null;
    StringSet uuids = new StringSet (false, true, true);
    try {
        Connection con = returnConnection ().getJdbcConnection ();
        String sSql = null;
        if (getIsDbCaseSensitive (this.getRequestContext ())) {
            sSql = "SELECT DOCUUID FROM " + getResourceTableName () + " WHERE SITEUUID=? AND UPPER(PUBMETHOD)=?";
        }
        else {
            sSql = "SELECT DOCUUID FROM " + getResourceTableName () + " WHERE SITEUUID=? AND PUBMETHOD=?";
        }
        logExpression (sSql);
        st = con.prepareStatement (sSql);
        st.setString (1, siteUuid);
        st.setString (2, MmdEnums.PublicationMethod.harvester.toString ().toUpperCase ());
        ResultSet rs = st.executeQuery ();
        while (rs.next ()) {
            uuids.add (rs.getString (1));
        }
    } finally {
        closeStatement (st);
    }
    return uuids;
}


-----Function Pair=383=-----==

public boolean deleteSite (String username, int sid) {
    DBConnection con = null;
    int rs = 0;
    try {
        con = DBServiceManager.allocateConnection ();
        StringBuffer query = new StringBuffer ();
        query.append ("UPDATE mdir_Site SET di_site_deleted_date=getdate(),di_site_deleted_by");
        query.append ("=\'" + username + "\' WHERE di_site_id=" + sid);
        rs = con.executeUpdate (query.toString ());
    } catch (SQLException e) {
    } finally {
        if (con != null) {
            con.release ();
        }
    }
    return (rs != 0);
}


public String copyMessage (DBMimeMessage oSrcMsg) throws MessagingException {
    if (DebugFile.trace) {
        DebugFile.writeln ("Begin DBFolder.copyMessage()");
        DebugFile.incIdent ();
    }
    BigDecimal oPg = null;
    BigDecimal oPos = null;
    int iLen = 0;
    String sId = null;
    try {
        String sSQL = "SELECT " + DB.pg_message + "," + DB.id_message + "," + DB.nu_position + "," + DB.len_mimemsg + " FROM " + DB.k_mime_msgs + " WHERE " + DB.gu_mimemsg + "=";
        if (DebugFile.trace) DebugFile.writeln ("Connection.prepareStatement(" + sSQL + "'" + oSrcMsg.getMessageGuid () + "')");
        PreparedStatement oStmt = getConnection ().prepareStatement (sSQL + "?", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
        oStmt.setString (1, oSrcMsg.getMessageGuid ());
        ResultSet oRSet = oStmt.executeQuery ();
        oRSet.next ();
        oPg = oRSet.getBigDecimal (1);
        sId = oRSet.getString (2);
        oPos = oRSet.getBigDecimal (3);
        iLen = oRSet.getInt (4);
        oRSet.close ();
        oStmt.close ();
    } catch (SQLException sqle) {
        try {
            getConnection ().rollback ();
        } catch (Exception ignore) {
        }
        if (DebugFile.trace) {
            DebugFile.writeln ("DBFolder.copyMessage() SQLException " + sqle.getMessage ());
            DebugFile.decIdent ();
        }
        throw new MessagingException ("DBFolder.copyMessage() SQLException " + sqle.getMessage (), sqle);
    }
    if (null == oPg) throw new MessagingException ("DBFolder.copyMessage() Source Message not found");
    DBFolder oSrcFldr = (DBFolder) oSrcMsg.getFolder ();
    MboxFile oMboxSrc = null;
    MimeMessage oMimeSrc;
    String sNewGuid = null;
    try {
        if ((oSrcFldr.mode & MODE_MBOX) != 0) {
            oMboxSrc = new MboxFile (oSrcFldr.getFile (), MboxFile.READ_ONLY);
            InputStream oInStrm = oMboxSrc.getMessageAsStream (oPos.longValue (), iLen);
            oMimeSrc = new MimeMessage (Session.getDefaultInstance (new Properties ()), oInStrm);
            oInStrm.close ();
            oMboxSrc.close ();
            oMboxSrc = null;
            String sId2 = oMimeSrc.getMessageID ();
            if ((sId != null) && (sId2 != null)) {
                if (! sId.trim ().equals (sId2.trim ())) {
                    throw new MessagingException ("MessageID " + sId + " at database does not match MessageID " + oMimeSrc.getMessageID () + " at MBOX file " + oSrcFldr.getFile ().getName () + " for message index " + oPg.toString ());
                }
            }
            appendMessage (oMimeSrc);
        }
        else {
            ByteArrayOutputStream oByOutStrm = new ByteArrayOutputStream ();
            oSrcMsg.writeTo (oByOutStrm);
            ByteArrayInputStream oByInStrm = new ByteArrayInputStream (oByOutStrm.toByteArray ());
            oByOutStrm.close ();
            oMimeSrc = new MimeMessage (Session.getDefaultInstance (new Properties ()), oByInStrm);
            oByInStrm.close ();
            appendMessage (oMimeSrc);
        }
    } catch (Exception e) {
        if (oMboxSrc != null) {
            try {
                oMboxSrc.close ();
            } catch (Exception ignore) {
            }
        }
        try {
            oSrcFldr.getConnection ().rollback ();
        } catch (Exception ignore) {
        }
        if (DebugFile.trace) {
            DebugFile.writeln ("DBFolder.copyMessage() " + e.getClass ().getName () + e.getMessage ());
            DebugFile.decIdent ();
        }
        throw new MessagingException (e.getMessage (), e);
    }
    if (DebugFile.trace) {
        DebugFile.decIdent ();
        DebugFile.writeln ("End DBFolder.copyMessage() : " + sNewGuid);
    }
    return sNewGuid;
}


-----Function Pair=384=-----==

public Subject findBySubjectID (Integer subjectID) throws SelectException, DBConnectionException {
    Subject subject = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("SUBJECT_ID", subjectID);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                subject = new Subject ();
                subject.setName (result.getString ("SUBJECT_NAME"));
                subject.setDescription (result.getString ("SUBJECT_DESCRIPTION"));
                subject.setId (result.getInt ("SUBJECT_ID"));
                subject.setCoeff (result.getFloat ("SUBJECT_COEFFICIENT"));
                subject.setAlias (result.getString ("SUBJECT_ALIAS"));
                subject.setTeachingUnit (null);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return subject;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nGlossId) {
    ToGloss maGloss = new ToGlossDAO ().findById (nGlossId);
    if (maGloss == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("gloss.search.notFound"));
    }
    else {
        List < ToGloss > list = new ArrayList < ToGloss > ();
        EntityManagerHelper.refresh (maGloss);
        list.add (maGloss);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("gloss.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=385=-----==

void incValora () {
    if (dtCons.getNOREG ()) {
        mensajeErr ("No hay registros Activos");
        return;
    }
    int grdNume = grd_numeE2.getValorInt ();
    if (grdNume < 100) {
        mensajeErr ("Grupo debe ser Superior a 99");
        return;
    }
    try {
        s = "SELECT * FROM grupdesp WHERE eje_nume = " + dtCons.getInt ("eje_nume") + " AND  emp_codi = " + dtCons.getInt ("emp_codi") + " AND grd_nume = " + grdNume;
        if (! dtAdd.select (s, true)) {
            msgBox ("Grupo NO ENCONTRADO en Despieces");
            return;
        }
        dtAdd.edit (dtAdd.getCondWhere ());
        dtAdd.setDato ("grd_incval", grd_incvalE.getSelecion ());
        dtAdd.update (stUp);
        ctUp.commit ();
        if (grd_incvalE.isSelected ()) mensajeErr ("Grupo marcado para Valorar");
        else mensajeErr ("Grupo marcado para NO Valorar");
        grd_incvalE1.setSelecion (grd_incvalE.getSelecion ());
    } catch (Exception k) {
        Error ("Error al Marcar Para Valorar", k);
    }
}


private String findExistingUuidFromField (String field, String value) throws SQLException {
    String sUuid = "";
    PreparedStatement st = null;
    try {
        value = Val.chkStr (value);
        if (value.length () > 0) {
            Connection con = returnConnection ().getJdbcConnection ();
            StringBuilder sbSql = new StringBuilder ();
            sbSql.append ("SELECT DOCUUID FROM ").append (getResourceTableName ());
            if (getIsDbCaseSensitive (this.getRequestContext ())) {
                sbSql.append (" WHERE UPPER(").append (field).append (")=?");
            }
            else {
                sbSql.append (" WHERE ").append (field).append ("=?");
            }
            logExpression (sbSql.toString ());
            st = con.prepareStatement (sbSql.toString ());
            st.setString (1, value.toUpperCase ());
            ResultSet rs = st.executeQuery ();
            int n = 0;
            while (rs.next ()) {
                n ++;
                sUuid = Val.chkStr (rs.getString (1));
                if (n > 1) {
                    sUuid = "";
                    break;
                }
            }
        }
    } finally {
        closeStatement (st);
    }
    return sUuid;
}


-----Function Pair=386=-----==

public RestServiceResult delete (RestServiceResult serviceResult, ToExercise1Group toExercise1Group) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_EXERCITE1_GROUP);
        query.setParameter (1, toExercise1Group.getExerciseGroupId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise1Group);
        Object [] arrayParam = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el ejercicio grupal s1: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public int deleteObject (String name, String filter) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String q = "delete from " + name + " P ";
        if (filter != null) {
            q = q + " where P." + filter;
        }
        Query query = s.createQuery (q);
        int ret = query.executeUpdate ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=387=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("exercises1.search.notFound"));
    }
    else {
        List < CoExercises1 > list = new ArrayList < CoExercises1 > ();
        EntityManagerHelper.refresh (coExercises1);
        list.add (coExercises1);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public void addForumrecommend (List < Forumrecommend > forumcommendList) {
    Transaction transaction = null;
    try {
        SessionFactory factory = HibernateUtil.getSessionFactory ();
        Session session = factory.getCurrentSession ();
        transaction = session.beginTransaction ();
        for (int i = 0; i < forumcommendList.size (); i ++) {
            session.save (forumcommendList.get (i));
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    }
}


-----Function Pair=388=-----==

public IllnessListDocument getDiagnosisPatientStatsReport () {
    ResultSet rsReport = null;
    IllnessListDocument doc = null;
    try {
        helper = new DBHelper ();
        PreparedStatement psReport = helper.prepareStatement (SQL.getDiagnosisPatientStatsReport ());
        rsReport = psReport.executeQuery ();
        doc = IllnessListDocument.Factory.newInstance ();
        doc.addNewIllnessList ();
        while (rsReport.next ()) {
            Illness i = doc.getIllnessList ().addNewIllness ();
            i.setCount (new BigInteger (String.valueOf (rsReport.getInt ("COUNT"))));
            i.setIllness (rsReport.getString ("ILLNESS"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsReport != null) {
                rsReport.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


public Long addUserInfo (AuthSession authSession, AuthInfo authInfo, List < RoleEditableBean > roles) {
    DatabaseAdapter db = null;
    try {
        db = DatabaseAdapter.getInstance ();
        Long companyId = authSession.checkCompanyId (authInfo.getCompanyId ());
        Long holdingId = authSession.checkHoldingId (authInfo.getHoldingId ());
        Long id = addUserInfo (db, authInfo, roles, companyId, holdingId);
        db.commit ();
        return id;
    } catch (Throwable e) {
        try {
            if (db != null) db.rollback ();
        } catch (Exception e001) {
        }
        final String es = "Error add user auth";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db);
        db = null;
    }
}


-----Function Pair=389=-----==

public Vector getFlightDialogTableData (int currentPilot) throws SQLException {
    Object data [] = null;
    Statement stmt;
    ResultSet rs = null;
    int columnCount;
    int y = 0;
    Vector rows = null, row = null;
    try {
        String sQuery = "select nr, dato, flytype.navn, " + "svaevetid, distance, airfield1.name, airfield2.name, flyvning.id " + "from flyvning, flytype, airfield airfield1, airfield airfield2  " + "where flytype.id = flytype_id " + "and pilot_id = " + currentPilot + " " + "and airfield1.id = startsted_id " + "and airfield2.id = landingssted_id " + "order by nr";
        stmt = conn.getStatement ();
        rs = stmt.executeQuery (sQuery);
        columnCount = rs.getMetaData ().getColumnCount ();
        rows = new Vector (200);
        if (! rs.next ()) {
            log.info ("Oops, no rows selected in flyvning, creating fake");
            row = new Vector (columnCount);
            row.addElement (new Integer (0));
            row.addElement (Calendar.getInstance ().getTime ());
            row.addElement ("");
            row.addElement (new Integer (0));
            row.addElement (new Integer (0));
            row.addElement ("");
            row.addElement ("");
            row.addElement (new Integer (0));
            rows.addElement (row);
        }
        else {
            do {
                row = new Vector (columnCount);
                for (y = 0; y < columnCount; y ++) {
                    log.info ("Type :" + rs.getObject (y + 1).getClass () + " " + (((rs.getObject (y + 1)) instanceof java.math.BigDecimal)));
                    if (rs.getObject (y + 1) instanceof java.math.BigDecimal && y != 1) {
                        log.info ("Changed " + rs.getString (y + 1) + " " + y);
                        row.addElement (new Integer (rs.getInt (y + 1)));
                    }
                    else row.addElement (rs.getObject (y + 1));
                    if (row.get (y) == null) {
                        row.set (y, "");
                    }
                }
                row.set (1, new java.util.Date (rs.getLong (2)));
                rows.addElement (row);
            }
            while (rs.next ());
        }
    } catch (SQLException sqle) {
        log.debug (sqle);
        throw sqle;
    }
    if (rs != null) rs.close ();
    if (stmt != null) stmt.close ();
    return rows;
}


private Vector getItems (String cat) {
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    Vector items = new Vector ();
    try {
        conn = dbMan.getPOSConnection ();
        stmt = conn.createStatement ();
        if (stmt.execute ("select * from " + strPOSPrefix + "items where item_building = '" + settings.get (DBSettings.MAIN_BUILDING) + "' and item_visible = '1' and item_category = '" + cat + "' order by item_name")) {
            rs = stmt.getResultSet ();
            while (rs.next ()) {
                OrderItem single;
                int id = rs.getInt ("item_id");
                String name = rs.getString ("item_name");
                String desc = rs.getString ("item_description");
                String category = rs.getString ("item_category");
                String build = rs.getString ("item_building");
                double price = rs.getDouble ("item_price");
                double redPrice = rs.getDouble ("item_reducedprice");
                boolean free = (rs.getString ("item_allowfree").compareTo ("1") == 0);
                boolean reduced = (rs.getString ("item_allowreduced").compareTo ("1") == 0);
                boolean typeA = (rs.getString ("item_istypea").compareTo ("1") == 0);
                int freeBL = rs.getInt ("item_fr_bl");
                single = new OrderItem (id, name, desc, category, build, price, redPrice, free, reduced, typeA, freeBL);
                if (single.completeItem ()) items.add (single);
            }
        }
        stmt = null;
        rs = null;
        stmt = conn.createStatement ();
        if (stmt.execute ("select " + strPOSPrefix + "batch_master.mb_name, " + strPOSPrefix + "batch_master.mb_id from " + strPOSPrefix + "batch_master where " + strPOSPrefix + "batch_master.mb_active = '1' and " + strPOSPrefix + "batch_master.mb_building = '" + settings.get (DBSettings.MAIN_BUILDING) + "' and " + strPOSPrefix + "batch_master.mb_category = '" + cat + "' order by " + strPOSPrefix + "batch_master.mb_name")) {
            rs = stmt.getResultSet ();
            while (rs.next ()) {
                String batchName = rs.getString ("mb_name");
                int batchID = rs.getInt ("mb_id");
                if (batchName != null && batchID >= 0) {
                    PSBatchItem batch = new PSBatchItem (batchName);
                    Statement stmtItem = null;
                    ResultSet rsItem = null;
                    stmtItem = conn.createStatement ();
                    if (stmtItem.execute ("select " + strPOSPrefix + "items.* from (SELECT * FROM " + strPOSPrefix + "batch_items WHERE ib_batchid = '" + batchID + "') " + strPOSPrefix + "batch_items inner join (SELECT * FROM " + strPOSPrefix + "items WHERE item_visible = '1' and item_building = '" + settings.get (DBSettings.MAIN_BUILDING) + "') " + strPOSPrefix + "items on ( " + strPOSPrefix + "batch_items.ib_itemid = " + strPOSPrefix + "items.item_id ) order by item_name")) {
                        rsItem = stmtItem.getResultSet ();
                        while (rsItem.next ()) {
                            OrderItem single;
                            int id = rsItem.getInt ("item_id");
                            String name = rsItem.getString ("item_name");
                            String desc = rsItem.getString ("item_description");
                            String category = rsItem.getString ("item_category");
                            String build = rsItem.getString ("item_building");
                            double price = rsItem.getDouble ("item_price");
                            double redPrice = rsItem.getDouble ("item_reducedprice");
                            boolean free = (rsItem.getString ("item_allowfree").compareTo ("1") == 0);
                            boolean reduced = (rsItem.getString ("item_allowreduced").compareTo ("1") == 0);
                            boolean typeA = (rsItem.getString ("item_istypea").compareTo ("1") == 0);
                            int freeBL = rsItem.getInt ("item_fr_bl");
                            single = new OrderItem (id, name, desc, category, build, price, redPrice, free, reduced, typeA, freeBL);
                            if (single.completeItem ()) batch.addItem (single);
                        }
                        if (batch.getItems ().size () > 0) items.add (batch);
                    }
                }
            }
        }
    } catch (SQLException sqlEx) {
        System.err.println ("SQLException: " + sqlEx.getMessage ());
        System.err.println ("SQLState: " + sqlEx.getSQLState ());
        System.err.println ("VendorError: " + sqlEx.getErrorCode ());
        return null;
    } catch (Exception e) {
        System.err.println ("Exception: " + e.getMessage ());
        System.err.println (e);
        return null;
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (SQLException sqlEx) {
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close ();
                } catch (SQLException sqlEx) {
                    stmt = null;
                }
            }
        }
    }
    return items;
}


-----Function Pair=390=-----==

private Hashtable getApplicantData (ResultSet rs) throws Exception {
    Hashtable applicantInfo = new Hashtable ();
    applicantInfo.put ("id", getString (rs, "applicant_id"));
    applicantInfo.put ("password", getString (rs, "password"));
    applicantInfo.put ("name", getString (rs, "applicant_name"));
    applicantInfo.put ("address1", getString (rs, "address1"));
    applicantInfo.put ("address2", getString (rs, "address2"));
    applicantInfo.put ("address3", getString (rs, "address3"));
    applicantInfo.put ("city", getString (rs, "city"));
    applicantInfo.put ("state", getString (rs, "state"));
    applicantInfo.put ("poscode", getString (rs, "poscode"));
    applicantInfo.put ("country_code", getString (rs, "country_code"));
    applicantInfo.put ("email", getString (rs, "email"));
    applicantInfo.put ("phone", getString (rs, "phone"));
    applicantInfo.put ("gender", getString (rs, "gender"));
    try {
        applicantInfo.put ("birth_date", getString (rs, "birth_date"));
        java.util.Date birthDate = rs.getDate ("birth_date");
        if (birthDate != null) {
            Calendar c = new java.util.GregorianCalendar ();
            c.setTime (birthDate);
            int year = c.get (Calendar.YEAR);
            int month = c.get (Calendar.MONTH) + 1;
            int day = c.get (Calendar.DAY_OF_MONTH);
            applicantInfo.put ("birth_year", new Integer (year));
            applicantInfo.put ("birth_month", new Integer (month));
            applicantInfo.put ("birth_day", new Integer (day));
        }
        java.util.Date apply_date = rs.getDate ("apply_date");
        applicantInfo.put ("ip_address", getString (rs, "ip_address"));
        if (apply_date != null) {
            applicantInfo.put ("apply_date", mecca.sis.tools.DateTool.getDateFormatted (apply_date));
        }
        else {
            applicantInfo.put ("apply_date", "");
        }
    } catch (Exception e2) {
    }
    return applicantInfo;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=391=-----==

public static Hashtable getDataMap () throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        Hashtable dataMap = new Hashtable ();
        {
            r.add ("data_id");
            r.add ("data_name");
            sql = r.getSQLSelect ("custom_data");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                dataMap.put (rs.getString ("data_id"), rs.getString ("data_name"));
            }
        }
        return dataMap;
    } finally {
        if (db != null) db.close ();
    }
}


public division getDivision (int idDivision) {
    try {
        String sql = "SELECT * FROM divisionxTorneo " + " WHERE idDivisionxTorneo = " + idDivision;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            this.laDivision = new division ();
            populateDivisiones (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return this.laDivision;
}


-----Function Pair=392=-----==

public TxDecorator getTxDecorator (long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from TxDecorator R where R.txId=?";
        Query q = s.createQuery (query);
        q.setLong (0, txId);
        return (TxDecorator) q.uniqueResult ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public Object executeUpdateParameterised (String query, int queryTimeOut) throws DException {
    try {
        if (connectionStatus) throw new DException ("DSE279", null);
        Object parsedObject = Parser.parseQuery (query);
        if (parsedObject instanceof SQLdatastatement) {
            if (((String) getUserSession ().getTransactionAccessMode ()).equalsIgnoreCase ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            _StatementExecutionContext sec = getStatementExecutionContext ();
            return ((StatementExecuter) parsedObject).run (sec);
        }
        else if (parsedObject instanceof SQLschemastatement) {
            commit ();
            _ServerSession ss = getSystemServerSession ();
            if (((String) getUserSession ().getTransactionAccessMode ()).equalsIgnoreCase ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            _DataDictionary dd = getDataDictionary ();
            dd.lockDDL ();
            try {
                try {
                    ((SQLschemastatement) parsedObject).run (this);
                } catch (DException ex) {
                    dd.restoreGeneratedKeys ();
                    createIndexesList.clear ();
                    ss.rollback ();
                    throw ex;
                }
                if (! (parsedObject instanceof dropdatabasestatement)) {
                    ((ServerSession) ss).createIndexesList = createIndexesList;
                    ss.commit ();
                    createIndexesList.clear ();
                }
            } finally {
                dd.releaseDDL ();
            }
            return new Integer (Integer.MIN_VALUE);
        }
    } catch (DException de) {
        throw de;
    } catch (RuntimeException de) {
        throw de;
    }
    throw new DException ("DSE533", null);
}


-----Function Pair=393=-----==

public Forums findById (Short fid) {
    Session session = null;
    Transaction tran = null;
    Forums forum = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tran = session.beginTransaction ();
        forum = (Forums) session.get (Forums.class, fid);
        tran.commit ();
    } catch (HibernateException e) {
        if (tran != null) {
            tran.rollback ();
        }
        e.printStackTrace ();
    }
    return forum;
}


public long findTableSize (String sql) {
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Transaction tran = null;
    long dataSize = 0;
    try {
        Session session = SessionFactory.getSession ();
        tran = session.beginTransaction ();
        conn = session.connection ();
        pstmt = conn.prepareStatement (sql);
        rs = pstmt.executeQuery ();
        while (rs.next ()) {
            dataSize += rs.getLong ("Data_length");
            dataSize += rs.getLong ("Index_length");
        }
        tran.commit ();
    } catch (SQLException e) {
        e.printStackTrace ();
        if (tran != null) {
            tran.rollback ();
        }
    } finally {
        try {
            if (tran != null) {
                tran = null;
            }
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return dataSize;
}


-----Function Pair=394=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        address1.setPerson (person);
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        address2.setPerson (person);
        person.getAddresses ().add (address2);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static Vector getListOfModules (String role, String usrlogin, String tab) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        Vector vu = new Vector ();
        {
            sql = "SELECT module_id FROM user_module_template WHERE user_login = '" + usrlogin + "' AND tab_id = '" + tab + "'";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                String id = rs.getString ("module_id");
                vu.addElement (id);
            }
        }
        Vector v = new Vector ();
        {
            sql = "SELECT m.module_id AS module_id, module_title, " + "module_class, module_group FROM module m, role_module r " + "WHERE m.module_id = r.module_id AND user_role = '" + role + "' " + "ORDER BY module_group, module_title";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                String id = rs.getString ("module_id");
                String title = rs.getString ("module_title");
                String klazz = rs.getString ("module_class");
                String group = rs.getString ("module_group");
                boolean marked = vu.contains (id) ? true : false;
                Module module = new Module2 (id, title, klazz, marked);
                module.setGroupName (group != null ? group : "");
                v.addElement (module);
            }
        }
        return v;
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=395=-----==

protected static void processDocumentDataPDF (String pdfDocumentPath, OutputStream outputStream, int nCopies, String originalText, String copiesText, Properties prop) throws Exception {
    int tpx = Integer.parseInt (prop.getProperty ("copyTextPositionX", "270"));
    int tpy = Integer.parseInt (prop.getProperty ("copyTextPositionY", "680"));
    int trd = Integer.parseInt (prop.getProperty ("copyTextRotateDegrees", "90"));
    int tfs = Integer.parseInt (prop.getProperty ("copyTextFontSize", "14"));
    int tcr = Integer.parseInt (prop.getProperty ("copyTextColorR", "211"));
    int tcg = Integer.parseInt (prop.getProperty ("copyTextColorG", "211"));
    int tcb = Integer.parseInt (prop.getProperty ("copyTextColorB", "211"));
    PdfReader originalDoc = new PdfReader (pdfDocumentPath);
    int nPages = originalDoc.getNumberOfPages ();
    int currentPage = 1;
    PdfStamper resultDoc = new PdfStamper (originalDoc, outputStream);
    addPDFLabelText (originalText, resultDoc.getOverContent (currentPage), tpx, tpy, trd, tfs, tcr, tcg, tcb);
    currentPage = nPages;
    for (int nCopy = 0; nCopy < nCopies; nCopy ++) {
        for (int i = 1; i <= nPages; i ++) {
            currentPage ++;
            resultDoc.insertPage (currentPage, PageSize.A4);
            PdfContentByte under = resultDoc.getUnderContent (currentPage);
            under.addTemplate (resultDoc.getImportedPage (originalDoc, i), 1, 0, 0, 1, 0, 0);
            String copyTextWithPageNumber = copiesText.replaceAll ("%CN", "" + (nCopy + 1));
            if (i == 1) addPDFLabelText (copyTextWithPageNumber, resultDoc.getOverContent (currentPage), tpx, tpy, trd, tfs, tcr, tcg, tcb);
        }
    }
    resultDoc.close ();
}


public void testPreparedStatement0008 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0008              " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0008 values (?, ?)");
    final int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pstmt.setInt (1, i);
        pstmt.setString (2, theString.substring (0, i));
        count += pstmt.executeUpdate ();
    }
    assertEquals (count, rowsToAdd);
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("select s, i from #t0008");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
        assertEquals (rs.getString (1).trim ().length (), rs.getInt (2));
    }
    assertTrue (count == rowsToAdd);
    stmt.close ();
    pstmt.close ();
}


-----Function Pair=396=-----==

protected int [] getRowCounts (Vector inTable, Vector inSchema) throws Exception {
    if (! displayRowCounts) {
        return (null);
    }
    String rowCountSelect = "SELECT COUNT(*) FROM ";
    int [] counts;
    String name;
    counts = new int [inTable.size ()];
    try {
        Statement select = rowConn.createStatement ();
        for (int i = 0; i < inTable.size (); i ++) {
            try {
                String schemaPart = (String) inSchema.elementAt (i);
                schemaPart = schemaPart == null ? "" : (schemaPart + '.');
                name = schemaPart + (String) inTable.elementAt (i);
                ResultSet resultSet = select.executeQuery (rowCountSelect + name);
                while (resultSet.next ()) {
                    counts [i] = resultSet.getInt (1);
                }
            } catch (Exception e) {
                System.err.println ("Unable to get row count for table " + inSchema.elementAt (i) + '.' + inTable.elementAt (i) + ".  Using value '0': " + e);
            }
        }
    } catch (Exception e) {
        CommonSwing.errorMessage (e);
    }
    return (counts);
}


protected void readRecord (GetDocumentRequest request, String uuid) throws ImsServiceException, SQLException {
    PreparedStatement st = null;
    try {
        this.authorize (request, uuid);
        ManagedConnection mc = returnConnection ();
        Connection con = mc.getJdbcConnection ();
        IClobMutator cm = mc.getClobMutator ();
        StringBuffer sql = new StringBuffer ();
        sql.append ("SELECT UPDATEDATE");
        sql.append (" FROM ").append (getResourceTableName ()).append (" WHERE DOCUUID=?");
        logExpression (sql.toString ());
        st = con.prepareStatement (sql.toString ());
        st.setString (1, uuid);
        ResultSet rs = st.executeQuery ();
        if (rs.next ()) {
            request.setUpdateTimestamp (rs.getTimestamp (1));
            request.setActionStatus (ImsRequest.ACTION_STATUS_OK);
            closeStatement (st);
            sql = new StringBuffer ();
            sql.append ("SELECT XML");
            sql.append (" FROM ").append (getResourceDataTableName ()).append (" WHERE DOCUUID=?");
            st = con.prepareStatement (sql.toString ());
            st.setString (1, uuid);
            rs = st.executeQuery ();
            if (rs.next ()) {
                request.setXml (cm.get (rs, 1));
            }
        }
    } finally {
        closeStatement (st);
    }
}


-----Function Pair=397=-----==

public void sendFeedback () throws IOException {
    String urlToGet;
    String redirectURL;
    if (success) {
        urlToGet = "SuccessUrl";
        redirectURL = msg.getValue (urlToGet) [0];
        if (redirectURL.equals (Config.EMPTY_STR)) {
            redirectURL = "success.jsp";
        }
    }
    else {
        urlToGet = "FailureUrl";
        Enumeration e = failMessages.keys ();
        String query;
        while (e.hasMoreElements ()) {
            query = (String) e.nextElement ();
            MraldOutFile.appendToFile (query + " | " + failMessages.get (query).toString ());
        }
        redirectURL = msg.getValue (urlToGet) [0];
        if (redirectURL.equals ("")) {
            redirectURL = "failure.jsp";
        }
    }
    msg.setRedirect (redirectURL);
}


private boolean insertKnownBoard (Board board) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps = db.prepareStatement ("INSERT INTO KNOWNBOARDS " + "(boardname,publickey,privatekey,description) VALUES (?,?,?,?)");
    ps.setString (1, board.getName ());
    ps.setString (2, (board.getPublicKey () == null ? "" : board.getPublicKey ()));
    ps.setString (3, (board.getPrivateKey () == null ? "" : board.getPrivateKey ()));
    ps.setString (4, board.getDescription ());
    boolean insertWasOk = false;
    try {
        insertWasOk = (ps.executeUpdate () == 1);
    } finally {
        ps.close ();
    }
    return insertWasOk;
}


-----Function Pair=398=-----==

public void testSavepoint2 () throws Exception {
    String savepointName = "SAVEPOINT_1";
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #savepoint2 (data int)");
    stmt.close ();
    con.setAutoCommit (false);
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #savepoint2 (data) VALUES (?)");
    pstmt.setInt (1, 1);
    assertTrue (pstmt.executeUpdate () == 1);
    Savepoint savepoint = con.setSavepoint (savepointName);
    assertNotNull (savepoint);
    assertTrue (savepointName.equals (savepoint.getSavepointName ()));
    try {
        savepoint.getSavepointId ();
        assertTrue (false);
    } catch (SQLException e) {
    }
    pstmt.setInt (1, 2);
    assertTrue (pstmt.executeUpdate () == 1);
    pstmt.close ();
    stmt = con.createStatement ();
    ResultSet rs = stmt.executeQuery ("SELECT SUM(data) FROM #savepoint2");
    assertTrue (rs.next ());
    assertTrue (rs.getInt (1) == 3);
    assertTrue (! rs.next ());
    stmt.close ();
    rs.close ();
    con.rollback (savepoint);
    try {
        con.rollback (null);
        assertTrue (false);
    } catch (SQLException e) {
    }
    try {
        con.rollback (savepoint);
        assertTrue (false);
    } catch (SQLException e) {
    }
    try {
        con.releaseSavepoint (null);
        assertTrue (false);
    } catch (SQLException e) {
    }
    try {
        con.releaseSavepoint (savepoint);
        assertTrue (false);
    } catch (SQLException e) {
    }
    con.commit ();
    stmt = con.createStatement ();
    rs = stmt.executeQuery ("SELECT SUM(data) FROM #savepoint2");
    assertTrue (rs.next ());
    assertTrue (rs.getInt (1) == 1);
    assertTrue (! rs.next ());
    stmt.close ();
    rs.close ();
    con.setAutoCommit (true);
    try {
        con.setSavepoint ();
        assertTrue (false);
    } catch (SQLException e) {
    }
    try {
        con.setSavepoint (savepointName);
        assertTrue (false);
    } catch (SQLException e) {
    }
}


private void fillPicks () throws Exception {
    MLookup orgL = MLookupFactory.get (Env.getCtx (), m_WindowNo, 0, 2223, DisplayType.TableDir);
    fWarehouse = new VLookup ("M_Warehouse_ID", true, false, true, orgL);
    lWarehouse.setText (Msg.translate (Env.getCtx (), "M_Warehouse_ID"));
    fWarehouse.addVetoableChangeListener (this);
    m_M_Warehouse_ID = fWarehouse.getValue ();
    MLookup bpL = MLookupFactory.get (Env.getCtx (), m_WindowNo, 0, 2762, DisplayType.Search);
    fBPartner = new VLookup ("C_BPartner_ID", false, false, true, bpL);
    lBPartner.setText (Msg.translate (Env.getCtx (), "C_BPartner_ID"));
    fBPartner.addVetoableChangeListener (this);
    lDocType.setText (Msg.translate (Env.getCtx (), "C_DocType_ID"));
    cmbDocType.addItem (new KeyNamePair (MOrder.Table_ID, Msg.translate (Env.getCtx (), "Order")));
    cmbDocType.addItem (new KeyNamePair (MRMA.Table_ID, Msg.translate (Env.getCtx (), "VendorRMA")));
    cmbDocType.addActionListener (this);
}


-----Function Pair=399=-----==

public RestServiceResult check (RestServiceResult serviceResult, Long nLanguageId, String sWord) {
    List < MaSpell > listMaSpell = null;
    log.info ("nLanguageId: " + nLanguageId);
    Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.SELECT_MA_SPELL, MaSpell.class);
    query.setParameter (1, nLanguageId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listMaSpell = query.getResultList ();
    int error = 0;
    boolean revisar = true;
    String cleanWord = delDot (sWord.toLowerCase ());
    for (int i = 0; i < listMaSpell.size (); i ++) {
        error = computeLevenshteinDistance (cleanWord, listMaSpell.get (i).getWord ().toLowerCase ());
        if (error == 0) {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("spell.check.notErrorFound"));
            revisar = false;
            break;
        }
    }
    if (revisar) {
        List < MaSpell > listSpellChoises = new ArrayList < MaSpell > ();
        for (int i = 0; i < listMaSpell.size (); i ++) {
            error = computeLevenshteinDistance (cleanWord, listMaSpell.get (i).getWord ().toLowerCase ());
            if (error < 3) {
                listSpellChoises.add (listMaSpell.get (i));
            }
        }
        Object [] arrayParam = {listSpellChoises.size ()};
        if (listSpellChoises.size () == 0) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.check.noChoises"), arrayParam));
        }
        else {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.check.success"), arrayParam));
        }
        serviceResult.setObjResult (listSpellChoises);
        serviceResult.setNumResult (listSpellChoises.size ());
    }
    return serviceResult;
}


public void testPreparedStatement0040 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0040 (" + " c255 char(255)     not null, " + " v255 varchar(255)  not null) ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0040 values (?, ?)");
    String along = getLongString ('a');
    String blong = getLongString ('b');
    pstmt.setString (1, along);
    pstmt.setString (2, along);
    int count = pstmt.executeUpdate ();
    assertEquals (count, 1);
    pstmt.close ();
    count = stmt.executeUpdate ("" + "insert into #t0040 values ( " + "'" + blong + "', " + "'" + blong + "')");
    assertEquals (count, 1);
    pstmt = con.prepareStatement ("select c255, v255 from #t0040 order by c255");
    ResultSet rs = pstmt.executeQuery ();
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), along);
    assertEquals (rs.getString ("v255"), along);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), blong);
    assertEquals (rs.getString ("v255"), blong);
    assertTrue ("Expected no result set", ! rs.next ());
    pstmt.close ();
    rs = stmt.executeQuery ("select c255, v255 from #t0040 order by c255");
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), along);
    assertEquals (rs.getString ("v255"), along);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString ("c255"), blong);
    assertEquals (rs.getString ("v255"), blong);
    assertTrue ("Expected no result set", ! rs.next ());
    stmt.close ();
}


-----Function Pair=400=-----==

public RestServiceResult listNewsForCourse (RestServiceResult serviceResult, Long nCourseId) {
    CoCourse coCourse = new CoCourseDAO ().findById (nCourseId);
    EntityManagerHelper.refresh (coCourse);
    List < ToNews > list = new ArrayList < ToNews > ();
    list.addAll (coCourse.getToNewses ());
    if (list.size () == 0) {
        serviceResult.setMessage (bundle.getString ("news.list.notFound"));
    }
    else {
        Object [] array = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.list.success"), array));
    }
    serviceResult.setObjResult (list);
    serviceResult.setNumResult (list.size ());
    return serviceResult;
}


public AbstractBaseObject getByKeyWord (String keyWord) throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    StringBuffer sqlStatCnt = new StringBuffer ();
    try {
        sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE");
        sqlStat.append (" FROM DMS_RELATIONAL_WORD A ");
        sqlStat.append (" WHERE A.PARENT_ID=0 AND A.WORD = ? AND A.RECORD_STATUS = ?  ");
        preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
        this.setPrepareStatement (preStat, 1, keyWord.trim ());
        this.setPrepareStatement (preStat, 2, GlobalConstant.RECORD_STATUS_ACTIVE);
        rs = preStat.executeQuery ();
        if (rs != null && rs.next ()) {
            DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
            tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
            tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
            tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
            tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
            tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
            tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
            tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
            tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
            tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
            tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
            tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
            tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
            return (tmpDmsRelationalWord);
        }
        else {
            return null;
        }
    } catch (ApplicationException appEx) {
        throw appEx;
    } catch (SQLException sqle) {
        log.error (sqle, sqle);
        throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
    } catch (Exception e) {
        log.error (e, e);
        throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
    } finally {
        try {
            rs.close ();
        } catch (Exception ignore) {
        } finally {
            rs = null;
        }
        try {
            preStat.close ();
        } catch (Exception ignore) {
        } finally {
            preStat = null;
        }
    }
}


