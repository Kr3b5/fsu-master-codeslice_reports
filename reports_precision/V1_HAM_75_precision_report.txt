Found 15/400 pairs as clones in the BCB
-----Function Pair=1=-----==

protected void doGotoMarker (IMarker marker) {
    String elementId = marker.getAttribute (org.eclipse.gmf.runtime.common.core.resources.IMarker.ELEMENT_ID, null);
    if (elementId == null || ! (getEditor () instanceof DiagramEditor)) {
        return;
    }
    DiagramEditor editor = (DiagramEditor) getEditor ();
    Map editPartRegistry = editor.getDiagramGraphicalViewer ().getEditPartRegistry ();
    EObject targetView = editor.getDiagram ().eResource ().getEObject (elementId);
    if (targetView == null) {
        return;
    }
    EditPart targetEditPart = (EditPart) editPartRegistry.get (targetView);
    if (targetEditPart != null) {
        MathDiagramEditorUtil.selectElementsInDiagram (editor, Arrays.asList (new EditPart [] {targetEditPart}));
    }
}


public boolean update (Resource localResouce, Resource serverResource, boolean publish, DawnRemoteConnection dawnRemoteConnection) throws Exception {
    try {
        logger.info (ResourceHelper.saveToXML ((XMLResource) serverResource));
        if (lastLocalResource == null) {
            copyLocalResourceToLastResource (localResouce);
        }
        boolean conflicted = identifyConflictsAndChanges (localResouce, (XMIResource) serverResource);
        setSelectedElements ();
        synchronizeDiagramXMI (localResouce, serverResource);
        ResourceDiffHelper r = new ResourceDiffHelper ();
        r.doDiff (localResouce, serverResource);
        addElements (localResouce, r);
        changeElements (r);
        deleteElements (r);
        lastServerResource = serverResource;
        if (publish) {
            logger.info ("PUBLISCHING AFTER UPDATING!!!!");
            this.publish ((GMFResource) localResouce, dawnRemoteConnection);
        }
        if (conflicted) {
            return true;
        }
    } catch (InterruptedException e1) {
        e1.printStackTrace ();
    }
    return false;
}


-----Function Pair=2=-----==

protected void createErrorComposite (Composite parent) {
    fErrorComposite = new Composite (parent, SWT.NULL);
    fErrorComposite.setLayout (new GridLayout ());
    fErrorComposite.setLayoutData (new GridData (GridData.FILL_BOTH));
    String message1 = Messages.AbstractDiagramEditor_0;
    String message2 = Messages.AbstractDiagramEditor_1;
    CLabel imageLabel = new CLabel (fErrorComposite, SWT.NULL);
    imageLabel.setImage (Display.getDefault ().getSystemImage (SWT.ICON_INFORMATION));
    imageLabel.setText (message1);
    String fileName = fNullInput.getFileName ();
    if (fileName != null) {
        message2 += " " + fileName;
    }
    Label l = new Label (fErrorComposite, SWT.NULL);
    l.setText (message2);
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=3=-----==

public static Area getAreaForTriangles (Triangle [] triangles) {
    GeneralPath tmppath = new GeneralPath ();
    Area retarea = new Area ();
    System.out.println ("getAreaForTriangles()");
    if (triangles != null) {
        System.out.println ("Total triangles: " + triangles.length);
        tmppath.moveTo (triangles [0].v1.x, triangles [0].v1.y);
        for (int n = 0; n < triangles.length; n ++) {
            tmppath.lineTo (triangles [n].v1.x, triangles [n].v1.y);
            tmppath.lineTo (triangles [n].v2.x, triangles [n].v2.y);
            tmppath.lineTo (triangles [n].v3.x, triangles [n].v3.y);
        }
        tmppath.closePath ();
        return new Area (tmppath);
    }
    return null;
}


void normalizeMethod (JCMethodDecl md, List < JCStatement > initCode) {
    if (md.name == names.init && TreeInfo.isInitialConstructor (md)) {
        List < JCStatement > stats = md.body.stats;
        ListBuffer < JCStatement > newstats = new ListBuffer < JCStatement > ();
        if (stats.nonEmpty ()) {
            while (TreeInfo.isSyntheticInit (stats.head)) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
            newstats.append (stats.head);
            stats = stats.tail;
            while (stats.nonEmpty () && TreeInfo.isSyntheticInit (stats.head)) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
            newstats.appendList (initCode);
            while (stats.nonEmpty ()) {
                newstats.append (stats.head);
                stats = stats.tail;
            }
        }
        md.body.stats = newstats.toList ();
        if (md.body.endpos == Position.NOPOS) md.body.endpos = TreeInfo.endPos (md.body.stats.last ());
    }
}


-----Function Pair=4=-----==

protected void buildChromosome () {
    segments = new ChromosomeSegment [numSegments];
    transformGroups = new TransformGroup [numSegments];
    tempTransformGroups = new TransformGroup [numSegments];
    currentPos = new int [numSegments];
    temp = new int [numSegments];
    tempTransform = new Transform3D ();
    tr = new Transform3D ();
    Transform3D initialTransform = getInitialTransform ();
    Transform3D modifierTransform = getModifierTransform ();
    int start = 0, segmentLength;
    for (int i = 0; i < numSegments; i ++) {
        segments [i] = getSegment ();
        segments [i].setPickable (true);
        transformGroups [i] = new TransformGroup (initialTransform);
        transformGroups [i].addChild (segments [i]);
        transformGroups [i].setCapability (TransformGroup.ALLOW_TRANSFORM_WRITE);
        transformGroups [i].setCapability (BranchGroup.ALLOW_CHILDREN_EXTEND);
        transformGroups [i].setCapability (BranchGroup.ALLOW_CHILDREN_WRITE);
        tg.addChild (transformGroups [i]);
        currentPos [i] = i;
        segmentLength = (int) (((i + 1) / (float) numSegments) * length) - start;
        if (segmentLength <= 0) segmentLength = 1;
        segments [i].position = start;
        segments [i].length = segmentLength;
        segments [i].id = String.valueOf (i);
        start += segmentLength;
        initialTransform.mul (modifierTransform);
    }
}


public void setPixels (int nArgs, FtsAtom args []) {
    int i = 0;
    int j = 0;
    pixelsSize = args [0].intValue;
    int oldSize = size;
    size = args [1].intValue;
    t_pixels = new double [pixelsSize + 10];
    b_pixels = new double [pixelsSize + 10];
    boolean notify = false;
    if (isIvec ()) for (i = 0; i < nArgs - 3; i += 2) {
        t_pixels [j] = (double) args [i + 2].intValue;
        b_pixels [j] = (double) args [i + 3].intValue;
        j ++;
    }
    else for (i = 0; i < nArgs - 3; i += 2) {
        t_pixels [j] = args [i + 2].doubleValue;
        b_pixels [j] = args [i + 3].doubleValue;
        j ++;
    }
    if (oldSize != size) notifyTableUpdated ();
    else if (pixelsSize <= nArgs - 2) notifySet ();
}


-----Function Pair=5=-----==

final void createMissingBlocks () {
    int nd = suite.disCnt ();
    if (blocks == null) throw new AssertionError ("CreateAllBlocks() should have been called prior to createMissingBlocks()");
    if (blocks.length < nd) {
        LearnerBlock b [] = new LearnerBlock [nd];
        for (int i = 0; i < blocks.length; i ++) b [i] = blocks [i];
        blocks = b;
    }
    else if (blocks.length > nd) {
        throw new AssertionError (blocks.length > nd);
    }
    for (int did = 0; did < nd; did ++) {
        Discrimination dis = suite.getDisc (did);
        if (blocks [did] == null) {
            if (suite.isFallback (did)) throw new AssertionError ("It is too late to create a learner for the fallback discrimination - it had to be done the very first thing!");
            LearnerBlock fb = null;
            if (suite.createNDMode == Suite.CreateNewDiscriminationMode.AssumeDefaultHistory) {
                fb = findFallbackBlock ();
                if (fb == null) {
                    throw new AssertionError ("This learner has not been provided with the fallback learning block, which means that we cannot AssumeDefaultHistory for new discrimination " + dis);
                }
                else if (fb.dis.claCount () != dis.claCount () || fb.dis.getDefaultCla () == null || dis.getDefaultCla () == null) {
                    String errmsg = "Cannot AssumeDefaultHistory for discrimination '" + dis + "' with " + dis.claCount () + " classes (def=" + dis.getDefaultCla () + "), because of a structure mismatch with the fallback discrimination " + fb.dis + " with " + fb.dis.claCount () + " classes (def=" + fb.dis.getDefaultCla () + ")";
                    if (fb.isZero ()) {
                        Logging.warning ("Although " + errmsg + ", it does not matter, since the fallback learner is still zero");
                        fb = null;
                    }
                    else {
                        throw new AssertionError (errmsg);
                    }
                }
            }
            blocks [did] = createBlock (dis, fb);
        }
        if (dis != blocks [did].dis) throw new AssertionError ("Discrimination mismatch on learner block validation?!");
    }
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=6=-----==

private void paintRealObj (Graphics g) {
    DataManagerCore oarray = d_con.getPointerData ();
    int select_id = oarray.getSelectRealObjNum ();
    calcDist ();
    for (Iterator < RealObject > it = oarray.objectIterator (); it.hasNext ();) {
        final RealObject robj = it.next ();
        String id = robj.getID ();
        int i = oarray.searchRealObjectInternalID (id);
        double z = oarray.getRealPhyZ (i);
        double x = oarray.getRealPhyX (i);
        double y = oarray.getRealPhyY (i);
        SimplePoint3d size = oarray.getRealSize (id);
        if (size != null) {
            if (robj.getFrontPositionID () != null && robj.getBackPositionID () != null) {
                final SimpleVector3d direction = robj.getDirection ();
                double theta_obj = getTheta (direction.x, direction.y);
                setModelDataDirectionObject (x, y, - z, size.x, size.y, size.z, theta_obj);
                if (select_id == i) DrawModel (g, i, true, (float) (0.2 + 0.01 * i), (float) 0.5, 10, 16);
                else DrawModel (g, i, true, (float) (0.7 + 0.01 * i), (float) 0.5, 10, 16);
            }
            else {
                setModelDataBox (x, y, - z, size.x, size.y, size.z, 0);
                if (select_id == i) DrawModel (g, i, true, (float) (0.2 + 0.01 * i), (float) 0.5, 8, 12);
                else DrawModel (g, i, true, (float) (0.7 + 0.01 * i), (float) 0.5, 8, 12);
            }
        }
    }
}


public void moveTo (Session session, int newPos) throws SQLException {
    PageStore store = index.getPageStore ();
    store.logUndo (this, data);
    PageBtreeNode p2 = PageBtreeNode.create (index, newPos, parentPageId);
    readAllRows ();
    p2.childPageIds = childPageIds;
    p2.rows = rows;
    p2.entryCount = entryCount;
    p2.offsets = offsets;
    p2.onlyPosition = onlyPosition;
    p2.parentPageId = parentPageId;
    p2.start = start;
    store.update (p2);
    if (parentPageId == ROOT) {
        index.setRootPageId (session, newPos);
    }
    else {
        PageBtreeNode p = (PageBtreeNode) store.getPage (parentPageId);
        p.moveChild (getPos (), newPos);
    }
    for (int i = 0; i < childPageIds.length; i ++) {
        PageBtree p = (PageBtree) store.getPage (childPageIds [i]);
        p.setParentPageId (newPos);
        store.update (p);
    }
    store.free (getPos (), true);
}


-----Function Pair=7=-----==

private ArrayList < Face > emitPolygon (Obj parent, Vertex [] v) {
    ArrayList < Face > triangles = new ArrayList < Face > ();
    int n = v.length;
    int prev, cur, next;
    int [] vp;
    int count;
    int min_vert;
    int i;
    double dist;
    double min_dist;
    boolean poly_orientation;
    boolean beenHere = false;
    vp = new int [n];
    poly_orientation = this.orientation (v);
    for (i = 0; i < n; i ++) vp [i] = i;
    count = n;
    while (count > 3) {
        min_dist = Double.MAX_VALUE;
        min_vert = 0;
        for (cur = 0; cur < count; cur ++) {
            prev = cur - 1;
            next = cur + 1;
            if (cur == 0) prev = count - 1;
            else if (next == count) next = 0;
            if ((determinant (vp [prev], vp [cur], vp [next], v) == poly_orientation) && no_interior (vp [prev], vp [cur], vp [next], v, vp, count, poly_orientation) && ((dist = distance2 (v [vp [prev]].getX (), v [vp [prev]].getY (), v [vp [next]].getX (), v [vp [next]].getY ())) < min_dist)) {
                min_dist = dist;
                min_vert = cur;
            }
        }
        if (min_dist == Double.MAX_VALUE) {
            if (beenHere) return null;
            poly_orientation = ! poly_orientation;
            beenHere = true;
        }
        else {
            beenHere = false;
            prev = min_vert - 1;
            next = min_vert + 1;
            if (min_vert == 0) prev = count - 1;
            else if (next == count) next = 0;
            triangles.add (new Face (parent, v [vp [prev]], v [vp [min_vert]], v [vp [next]]));
            count --;
            for (i = min_vert; i < count; i ++) vp [i] = vp [i + 1];
        }
    }
    triangles.add (new Face (parent, v [vp [0]], v [vp [1]], v [vp [2]]));
    return triangles;
}


private void normals () {
    for (int y = 0; y < 256; y ++) {
        for (int x = 0; x < 256; x ++) {
            int i = y * 256 + x;
            if (plotList [i] != null) {
                int dx1 = 0;
                int dy1 = 0;
                int dz1 = 0;
                for (int y_ = - 1; y_ <= 1; y_ ++) for (int x_ = - 1; x_ < 1; x_ ++) {
                    int yn = y + y_;
                    int xn = x + x_;
                    if (yn >= 0 && yn < 256 && xn >= 0 && xn < 256 - 1) {
                        dx1 += 1;
                        int pos = yn * 256 + xn;
                        if (plotList [pos + 1] != null && plotList [pos] != null) dz1 += plotList [pos + 1].z - plotList [pos].z;
                    }
                }
                int dx2 = 0;
                int dy2 = 0;
                int dz2 = 0;
                for (int y_ = - 1; y_ < 1; y_ ++) for (int x_ = - 1; x_ <= 1; x_ ++) {
                    int yn = y + y_;
                    int xn = x + x_;
                    if (yn >= 0 && yn < 256 - 1 && xn >= 0 && xn < 256) {
                        dy2 += 1;
                        int pos = yn * 256 + xn;
                        if (plotList [pos + 256] != null && plotList [pos] != null) dz2 += plotList [pos + 256].z - plotList [pos].z;
                    }
                }
                int dx = 10 * (dy1 * dz2 - dz1 * dy2);
                int dy = - 10 * (dx1 * dz2 - dz1 * dx2);
                int dz = 10 * (dx1 * dy2 - dy1 * dx2);
                int len = (int) Math.sqrt (dx * dx + dy * dy + dz * dz);
                plotList [i].dx = dx;
                plotList [i].dy = dy;
                plotList [i].dz = dz;
                plotList [i].len = (len > 0) ? len : 1;
            }
        }
    }
}


-----Function Pair=8=-----==

public Decimal dotrap (int type, String what, Decimal oper, Decimal result) {
    Decimal def = result;
    switch (type) {
        case FLAG_INVALID :
            def = newInstance (ZERO);
            def.sign = result.sign;
            def.nans = QNAN;
            break;
        case FLAG_DIV_ZERO :
            if (nans == FINITE && mant [DIGITS - 1] != 0) {
                def = newInstance (ZERO);
                def.sign = (byte) (sign * oper.sign);
                def.nans = INFINITE;
            }
            if (nans == FINITE && mant [DIGITS - 1] == 0) {
                def = newInstance (ZERO);
                def.nans = QNAN;
            }
            if (nans == INFINITE || nans == QNAN) {
                def = newInstance (ZERO);
                def.nans = QNAN;
            }
            if (nans == INFINITE || nans == SNAN) {
                def = newInstance (ZERO);
                def.nans = QNAN;
            }
            break;
        case FLAG_UNDERFLOW :
            if ((result.exp + DIGITS) < minExp) {
                def = newInstance (ZERO);
                def.sign = result.sign;
            }
            else {
                def = newInstance (result);
            }
            result.exp = result.exp + errScale;
            break;
        case FLAG_OVERFLOW :
            result.exp = result.exp - errScale;
            def = newInstance (ZERO);
            def.sign = result.sign;
            def.nans = INFINITE;
            break;
        default :
            def = result;
            break;
    }
    return trap (type, what, oper, def, result);
}


public void doGetInstanceCommand (String command, String [] args) {
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            JDP_Class jdpClass = new JDP_Class ();
            jdpClass.address = parseHex32 (args [1]);
            jdpClass.name = args [0].substring (1, rparen);
            jdpClass.instance = true;
            try {
                user.bmap.classToJDPClass (jdpClass.name, jdpClass.address, false, jdpClass);
                jdpClass.fields.trimToSize ();
                jdp_console.writeOutput (jdpClass);
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            } catch (NoSuchClassException e2) {
                jdp_console.writeOutput (jdpClass.name + " is an invalid class name");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
    }
    else {
        jdp_console.writeOutput ("invalid args for getinstance");
    }
    return;
}


-----Function Pair=9=-----==

private ComponentColorModel createAlphaComponentColorModel (int dataType, int numBands, boolean isAlphaPremultiplied, int transparency) {
    ComponentColorModel ccm = null;
    int RGBBits [] = null;
    ColorSpace cs = null;
    switch (numBands) {
        case 2 :
            cs = ColorSpace.getInstance (ColorSpace.CS_GRAY);
            break;
        case 4 :
            cs = ColorSpace.getInstance (ColorSpace.CS_sRGB);
            break;
        default :
            throw new IllegalArgumentException ();
    }
    int componentSize = 0;
    switch (dataType) {
        case DataBuffer.TYPE_BYTE :
            componentSize = 8;
            break;
        case DataBuffer.TYPE_USHORT :
        case DataBuffer.TYPE_SHORT :
            componentSize = 16;
            break;
        case DataBuffer.TYPE_INT :
            componentSize = 32;
            break;
        default :
            throw new IllegalArgumentException ();
    }
    RGBBits = new int [numBands];
    for (int i = 0; i < numBands; i ++) {
        RGBBits [i] = componentSize;
    }
    ccm = new ComponentColorModel (cs, RGBBits, true, isAlphaPremultiplied, transparency, dataType);
    return ccm;
}


public static int [] varParseArrayDimension (String name) throws NumberFormatException {
    int bracketLeft, bracketRight;
    boolean gettingDimension = true;
    String dimString = name;
    int numDim = 0;
    int index = 0;
    int result [];
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        if (bracketRight == - 1) {
            gettingDimension = false;
        }
        else {
            numDim ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    result = new int [numDim];
    index = 0;
    dimString = name;
    gettingDimension = true;
    while (gettingDimension) {
        bracketRight = dimString.indexOf (']');
        bracketLeft = dimString.indexOf ('[');
        if (bracketRight == - 1 || bracketLeft == - 1) {
            gettingDimension = false;
        }
        else {
            result [index] = Integer.valueOf (dimString.substring (bracketLeft + 1, bracketRight)).intValue ();
            index ++;
            if (bracketRight == (dimString.length () - 1)) gettingDimension = false;
            else dimString = dimString.substring (bracketRight + 1);
        }
    }
    return result;
}


-----Function Pair=10=-----==

protected double [] [] getBeta (double [] [] ob) {
    int l = ob.length;
    int stateCount = stProb.length;
    double [] tmp = new double [stateCount];
    double [] [] beta = new double [l] [stateCount];
    for (int i = 0; i < stateCount; i ++) {
        beta [l - 1] [i] = 0;
    }
    for (int t = l - 2; t >= 0; t --) {
        for (int i = 0; i < stateCount; i ++) {
            for (int j = 0; j < stateCount; j ++) {
                tmp [j] = transProb [i] [j] + getLogDensity (j, ob [t + 1]) + beta [t + 1] [j];
            }
            beta [t] [i] = logSumExp (tmp, 0, tmp.length);
        }
    }
    return beta;
}


public boolean processGestureEvent (MTGestureEvent ge) {
    DragEvent de = (DragEvent) ge;
    float x = de.getDragCursor ().getCurrentEvtPosX ();
    float y = de.getDragCursor ().getCurrentEvtPosY ();
    switch (de.getId ()) {
        case 0 :
        case 1 :
            int xIndex = (int) ToolsMath.map (x, 0.0F, MT4jSettings.getInstance ().getWindowWidth (), 0.0F, 126F);
            int yIndex = (int) ToolsMath.map (y, 0.0F, MT4jSettings.getInstance ().getWindowHeight (), 0.0F, 126F);
            if (xIndex < 0) xIndex = 0;
            if (xIndex > 125) xIndex = 125;
            if (yIndex < 0) yIndex = 0;
            if (yIndex > 125) yIndex = 125;
            extforce [xIndex] [yIndex] = - 3.92F;
            break;
    }
    return false;
}


-----Function Pair=11=-----==

public void exportShapes (List < Shape > list) {
    JFileChooser fc = new JFileChooser (System.getProperty ("user.home"));
    fc.setMultiSelectionEnabled (false);
    fc.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
    int ret = fc.showSaveDialog (gui);
    if (ret != JFileChooser.APPROVE_OPTION) {
        return;
    }
    File path = fc.getSelectedFile ();
    if (path.isFile ()) {
        path = path.getParentFile ();
    }
    if (path == null || path.isFile () || ! path.canWrite ()) {
        displayMessage ("Cannot save to this location");
        return;
    }
    StringBuffer exported = new StringBuffer ("Shapes Exported:\n\n");
    StringBuffer skipped = new StringBuffer ("Skipped shapes:\n\n");
    for (Shape shape : list) {
        try {
            exportShape (shape, path);
            exported.append (String.format ("%s: %s\n", shape.getPrimaryKey (), shape.getName ()));
        } catch (FileExistsException fee) {
            skipped.append (String.format ("%s: %s | %s\n", shape.getPrimaryKey (), shape.getName (), fee.getMessage ()));
        }
    }
    displayLongMessage (exported.toString () + "\n\n" + skipped, "Export result:");
}


private void initEnergyFactors () {
    double attrSum = 0.0;
    for (Node node : nodes) {
        for (Edge edge : attrEdges.get (node)) {
            attrSum += edge.weight;
        }
    }
    double repuSum = 0.0;
    for (Node node : nodes) repuSum += node.weight;
    if (repuSum > 0.0 && attrSum > 0.0) {
        final double density = attrSum / repuSum / repuSum;
        repuFactor = density * Math.pow (repuSum, 0.5 * (attrExponent - repuExponent));
        gravFactor = density * repuSum * Math.pow (gravFactor, attrExponent - repuExponent);
    }
    else {
        repuFactor = 1.0;
    }
}


-----Function Pair=12=-----==

public Map getCourseTypeMap (String modelId, String courseId, String examKnowledgePoint) {
    Table table = null;
    HashMap ctMap = null;
    try {
        String sql = "select strQuestionTypeId as typeId,count(strQuestionTypeId) as typeCount from Question ";
        String sqlWhere = " where isDelete = 0 and  STRCOURSEID ='" + courseId + "'";
        if (modelId.equals ("1")) {
            sqlWhere += " and STRQUESTIONID like '" + GetMac.getMacAddressIP ().split (",") [0] + "%'";
        }
        if (examKnowledgePoint != null && ! examKnowledgePoint.equals ("")) {
            String insql = getKnowledgePoints (examKnowledgePoint);
            if (insql.equals ("")) {
                insql = "'err'";
            }
            sqlWhere += " and (strFirstPoint in(" + insql + ") or strSecondPoint in(" + insql + ") or strThirdPoint in(" + insql + "))";
        }
        String sqlGroup = " group by strQuestionTypeId ";
        table = DataEngine.getInstance ().executeQuery (sql + sqlWhere + sqlGroup);
        if (table != null || table.getRowCount () > 0) {
            ctMap = new HashMap ();
            for (int j = 0; j < table.getRowCount (); j ++) {
                ctMap.put (table.getCellValue (j, 0), table.getCellValue (j, 1));
            }
        }
        return ctMap;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return new HashMap ();
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=13=-----==

public void processOrders (RdpPacket_Localised data, int next_packet, int n_orders) throws OrderException, RdesktopException {
    int present = 0;
    int order_flags = 0, order_type = 0;
    int size = 0, processed = 0;
    boolean delta;
    while (processed < n_orders) {
        order_flags = data.get8 ();
        if ((order_flags & RDP_ORDER_STANDARD) == 0) {
            throw new OrderException ("Order parsing failed!");
        }
        if ((order_flags & RDP_ORDER_SECONDARY) != 0) {
            this.processSecondaryOrders (data);
        }
        else {
            if ((order_flags & RDP_ORDER_CHANGE) != 0) {
                os.setOrderType (data.get8 ());
            }
            switch (os.getOrderType ()) {
                case RDP_ORDER_TRIBLT :
                case RDP_ORDER_TEXT2 :
                    size = 3;
                    break;
                case RDP_ORDER_PATBLT :
                case RDP_ORDER_MEMBLT :
                case RDP_ORDER_LINE :
                    size = 2;
                    break;
                default :
                    size = 1;
            }
            present = this.inPresent (data, order_flags, size);
            if ((order_flags & RDP_ORDER_BOUNDS) != 0) {
                if ((order_flags & RDP_ORDER_LASTBOUNDS) == 0) {
                    this.parseBounds (data, os.getBounds ());
                }
                surface.setClip (os.getBounds ());
            }
            delta = ((order_flags & RDP_ORDER_DELTA) != 0);
            switch (os.getOrderType ()) {
                case RDP_ORDER_DESTBLT :
                    logger.debug ("DestBlt Order");
                    this.processDestBlt (data, os.getDestBlt (), present, delta);
                    break;
                case RDP_ORDER_PATBLT :
                    logger.debug ("PatBlt Order");
                    this.processPatBlt (data, os.getPatBlt (), present, delta);
                    break;
                case RDP_ORDER_SCREENBLT :
                    logger.debug ("ScreenBlt Order");
                    this.processScreenBlt (data, os.getScreenBlt (), present, delta);
                    break;
                case RDP_ORDER_LINE :
                    logger.debug ("Line Order");
                    this.processLine (data, os.getLine (), present, delta);
                    break;
                case RDP_ORDER_RECT :
                    logger.debug ("Rectangle Order");
                    this.processRectangle (data, os.getRectangle (), present, delta);
                    break;
                case RDP_ORDER_DESKSAVE :
                    logger.debug ("Desksave!");
                    this.processDeskSave (data, os.getDeskSave (), present, delta);
                    break;
                case RDP_ORDER_MEMBLT :
                    logger.debug ("MemBlt Order");
                    this.processMemBlt (data, os.getMemBlt (), present, delta);
                    break;
                case RDP_ORDER_TRIBLT :
                    logger.debug ("TriBlt Order");
                    this.processTriBlt (data, os.getTriBlt (), present, delta);
                    break;
                case RDP_ORDER_POLYLINE :
                    logger.debug ("Polyline Order");
                    this.processPolyLine (data, os.getPolyLine (), present, delta);
                    break;
                case RDP_ORDER_TEXT2 :
                    logger.debug ("Text2 Order");
                    this.processText2 (data, os.getText2 (), present, delta);
                    break;
                default :
                    logger.warn ("Unimplemented Order type " + order_type);
                    return;
            }
            if ((order_flags & RDP_ORDER_BOUNDS) != 0) {
                surface.resetClip ();
                logger.debug ("Reset clip");
            }
        }
        processed ++;
    }
    if (data.getPosition () != next_packet) {
        throw new OrderException ("End not reached!");
    }
}


public String [] getItems (Component c, Element e) {
    String [] out = null;
    Element parent = e;
    AccessibleContext scambio = c.getAccessibleContext ();
    int max = scambio.getAccessibleChildrenCount ();
    if (max != 0) {
        out = new String [max * 4];
        for (int p = 0; p < max * 4; p ++) {
            out [p] = null;
        }
        int j = 0;
        for (int k = 0; k < max; k ++) {
            Accessible child = scambio.getAccessibleChild (k);
            out [j] = child.getAccessibleContext ().getAccessibleName ();
            out [j + 1] = child.getAccessibleContext ().getAccessibleRole ().toDisplayString (Locale.UK);
            out [j + 2] = parent.getAttributeValue ("accessibleName");
            out [j + 3] = parent.getAttributeValue ("accessibleRole");
            j = j + 4;
        }
    }
    return out;
}


-----Function Pair=14=-----==

public String [] getSelectedItem (Component c, Element e) {
    String [] out = new String [4];
    for (int i = 0; i < 4; i ++) {
        out [i] = null;
    }
    Element parent = e;
    AccessibleContext menu = c.getAccessibleContext ();
    Accessible child = null;
    int count = menu.getAccessibleChildrenCount ();
    for (int k = 0; k < count; k ++) {
        child = menu.getAccessibleChild (k);
        if (child.getAccessibleContext ().getAccessibleStateSet ().contains (AccessibleState.SELECTED)) break;
    }
    if (child.getAccessibleContext ().getAccessibleStateSet ().contains (AccessibleState.SELECTED)) {
        if (child.getAccessibleContext ().getAccessibleName () != null) {
            out [0] = child.getAccessibleContext ().getAccessibleName ();
        }
        out [1] = child.getAccessibleContext ().getAccessibleRole ().toDisplayString (Locale.UK);
        out [2] = parent.getAttributeValue ("accessibleName");
        out [3] = parent.getAttributeValue ("accessibleRole");
    }
    else {
        out = null;
    }
    return out;
}


protected String prevLine () throws Exception {
    if (book.getPosition () <= 0) return null;
    int len = 0;
    int ws = - 1;
    int index = 0;
    boolean eof = false;
    buffer.setLength (0);
    for (;;) {
        char c;
        try {
            c = book.readPrev ();
        } catch (EOFException e) {
            eof = true;
            break;
        }
        if (c == '\t') c = ' ';
        if (c == '\r' || (c == ' ' && index == 0)) continue;
        if (c == '\n') break;
        if (c == ' ') ws = index;
        len += charWidth (c);
        if (len > width - (2 * borderSpace) - scrollWidth) {
            book.readNext ();
            if ((ws != - 1) && this.isWrapSpaces ()) {
                int discard = index - ws - 1;
                for (int i = 0; i < discard; i ++) {
                    book.readNext ();
                }
                index = ws;
                buffer.setLength (index);
            }
            break;
        }
        buffer.append (c);
        index ++;
    }
    if (eof && index == 0) {
        return null;
    }
    if (! book.isRightToLeft ()) {
        buffer.reverse ();
    }
    return (buffer.toString ()).trim ();
}


-----Function Pair=15=-----==

public void cutVertical () {
    double threshold = vcut.getValue ();
    int gooddatapoints = 0;
    int currentsize = sdata.length;
    for (int i = 0; i < currentsize; i ++) if (data [i] >= threshold) gooddatapoints ++;
    double [] tempsdata = new double [gooddatapoints];
    double [] tempdata = new double [gooddatapoints];
    int j = 0;
    for (int i = 0; i < currentsize; i ++) {
        if (data [i] >= threshold) {
            tempsdata [j] = sdata [i];
            tempdata [j] = data [i];
            j ++;
        }
    }
    sdata = tempsdata;
    data = tempdata;
    dataHasBeenFit = false;
    plotData ();
}


public DoublePlane yGradient () {
    DoublePlane plane = new DoublePlane (getSize ());
    double [] src = doubleArray ();
    double [] dst = plane.doubleArray ();
    int w = getWidth ();
    int h = getHeight ();
    for (int x = 0; x < w; x ++) {
        for (int y = 0; y < h - 1; y ++) {
            int zu = x + y * w;
            int zb = zu + w;
            dst [zu] = src [zb] - src [zu] + 0.5;
        }
    }
    return plane;
}


-----Function Pair=16=-----==

public void setSort (String column, boolean ascending) {
    tableSort = column;
    tableSortAscending = ascending;
    tableSortColumn = - 1;
    if (columnNames == null) return;
    for (int i = 0; i < columnNames.length; i ++) {
        if (columnNames [i].equals (column)) {
            tableSortColumn = i;
            break;
        }
    }
    sortTable (tableSortColumn, ascending);
    tableDirty = true;
    refreshTable ();
}


static void reqListProperties (Client c) throws IOException {
    int foo, n;
    IO io = c.client;
    foo = io.readInt ();
    Window w = c.lookupWindow (foo);
    c.length -= 2;
    if (w == null) {
        c.errorValue = foo;
        c.errorReason = 3;
        return;
    }
    synchronized (io) {
        io.writeByte (1);
        Property p = w.getProperty ();
        int i = 0;
        while (p != null) {
            i ++;
            p = p.next;
        }
        io.writePad (1);
        io.writeShort (c.seq);
        io.writeInt (i);
        io.writeShort (i);
        io.writePad (22);
        p = w.getProperty ();
        while (p != null) {
            io.writeInt (p.propertyName);
            p = p.next;
        }
        io.flush ();
    }
}


-----Function Pair=17=-----==

public void setWikipedia (String wikipediaServer, String wikipediaDatabase, boolean cacheData, String wikipediaDataDirectory) {
    try {
        if (debugMode) {
            System.err.println ("--- Initializing Wikipedia database on server " + wikipediaServer + " with database " + wikipediaDatabase);
        }
        this.wikipedia = new Wikipedia (wikipediaServer, wikipediaDatabase, "root", null);
    } catch (Exception e) {
        System.err.println ("Error initializing Wikipedia database!");
        e.printStackTrace ();
    }
    if (cacheData && wikipediaDataDirectory != null) {
        cacheWikipediaData (wikipediaDataDirectory);
    }
    else if (cacheData && wikipediaDataDirectory == null) {
        System.err.println ("In order to cache Wikipedia data, specify Wikipedia data directory");
    }
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=18=-----==

public void restart () {
    IMDb = 0L;
    Oracle = 0L;
    try {
        clearRecords ();
        recordsSelect = "SELECT " + userColumn + ", " + objectColumn + ", ";
        for (Attribute attr : attributes) {
            if (attr.isRelationValued () || attr.name ().isEmpty ()) continue;
            recordsSelect += attr.name () + " ,";
        }
        recordsSelect = recordsSelect.substring (0, recordsSelect.length () - 1);
        recordsSelect += " FROM " + recordsTable;
        if (betweenCondition != null) {
            recordsSelect += " WHERE " + betweenCondition;
        }
        if (userID != null) {
            if (betweenCondition == null || ! recordsSelect.endsWith (betweenCondition)) recordsSelect += " WHERE ";
            else recordsSelect += " AND ";
            recordsSelect += userColumn + " = " + userID;
        }
        recordsStatement = provider.getConn ().prepareStatement (recordsSelect);
        records = recordsStatement.executeQuery ();
        records.next ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    getAttributes ();
}


private void drawRegressionCurve (double [] data1, double [] data2) {
    degree = (new Integer (degreeTFd.getText ())).intValue ();
    regression = new Regression (data1, data2, degree);
    String funcString = regression.polynomial ("x");
    System.out.println ("funcString = " + funcString);
    try {
        coordGenerator.setPoints (funcString, "x", windowXMin, windowXMax - windowXMin, xNMesh);
        mathPainter.setPaint (plotColorBtn.getColor ());
        curvePlotter.plot ();
        mathPainter.setPaint (dataColorBtn.getColor ());
        for (int i = 0; i < data1.length; i ++) {
            mathPainter.drawLine (data1 [i], data2 [i], data1 [i], regression.regress (data1 [i]));
        }
        leastSquaresTFd.setText ("" + (Math.round (100000.0 * regression.leastSquares ()) / 100000.0));
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=19=-----==

protected int [] getNumericInputAttributeIndices () {
    int [] indices = store.getInputAttributesIndices ();
    for (int i = 0; i < indices.length; i ++) {
        if (store.getAttributeType (i) != PreprocessingStorage.DataType.NUMERIC) {
            logger.warn ("Implemented outlier detection methods can not work on non-numeric game.data :(. Skipping attribute " + store.getAttributeName (i));
            int [] newIndices = new int [indices.length - 1];
            for (int j = 0; j < newIndices.length; j ++) {
                if (j < i) newIndices [j] = indices [j];
                else newIndices [j] = indices [j + 1];
            }
            indices = newIndices;
            i --;
        }
    }
    return indices;
}


Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


-----Function Pair=20=-----==

public boolean remove (Object obj) {
    for (int i = 0; i < current; i ++) {
        if (obj.equals (list [i])) {
            Object [] newList = new Object [size - 1];
            for (int j = 0; j < i; j ++) {
                newList [j] = list [j];
            }
            for (int k = i; k < current - 1; k ++) {
                newList [k] = list [k + 1];
            }
            list = newList;
            -- current;
            -- size;
            return true;
        }
    }
    return false;
}


public void createGrid (int width, int height) {
    grid = this.getGraphicsConfiguration ().createCompatibleVolatileImage (width, height, Transparency.TRANSLUCENT);
    Graphics2D g2d = grid.createGraphics ();
    g2d.setComposite (AlphaComposite.Src);
    g2d.setColor (new Color (0, 0, 0, 0));
    g2d.fillRect (0, 0, grid.getWidth (), grid.getHeight ());
    g2d.setBackground (new Color (0, 0, 0, 0));
    g2d.setColor (new Color (1f, 1f, 1f, 0.5f));
    for (int x = 0; x < width; x += 16) {
        g2d.drawLine (x - 1, 0, x - 1, height - 1);
    }
    for (int y = 0; y < height; y += 16) {
        g2d.drawLine (0, y - 1, width - 1, y - 1);
    }
}


-----Function Pair=21=-----==

boolean isFileFormat (LEDataInputStream stream) {
    try {
        byte [] signature = new byte [SIGNATURE_LENGTH];
        stream.read (signature);
        stream.unread (signature);
        if ((signature [0] & 0xFF) != 137) return false;
        if ((signature [1] & 0xFF) != 80) return false;
        if ((signature [2] & 0xFF) != 78) return false;
        if ((signature [3] & 0xFF) != 71) return false;
        if ((signature [4] & 0xFF) != 13) return false;
        if ((signature [5] & 0xFF) != 10) return false;
        if ((signature [6] & 0xFF) != 26) return false;
        if ((signature [7] & 0xFF) != 10) return false;
        return true;
    } catch (Exception e) {
        return false;
    }
}


public void toVrml (StringBuffer ret) {
    ret.append ("DEF ");
    ret.append (this.className);
    ret.append ("_");
    ret.append (this.id);
    ret.append (" ");
    if (url != null && url.length > 0) {
        ret.append ("Inline { url [ ");
        for (int i = 0; i < actualURL.length; i ++) {
            ret.append ("\"");
            ret.append (actualURL [i]);
            ret.append ("\",");
        }
        for (int i = 0; i < url.length; i ++) {
            ret.append ("\"");
            ret.append (url [i]);
            ret.append ("\",");
        }
        for (int i = 0; i < actualURL.length - 1; i ++) {
            ret.append ("\"http://www.vrspace.org/vrspace/");
            ret.append (actualURL [i]);
            ret.append ("\",");
        }
        if (actualURL.length > 0) {
            ret.append ("\"http://www.vrspace.org/vrspace/");
            ret.append (actualURL [actualURL.length - 1]);
            ret.append ("\"");
        }
        ret.append (" ] }");
    }
    else {
        ret.append ("Group{}");
    }
}


-----Function Pair=22=-----==

public void setTile (int x, int y, float [] tile, int tileWidth, int tileHeight) {
    if (x < 0 || x >= getWidth ()) throw new IllegalArgumentException ("x=" + x);
    if (y < 0 || y >= getHeight ()) throw new IllegalArgumentException ("y=" + y);
    if (tile == null) throw new IllegalArgumentException ("tile=" + tile);
    int iw = getWidth ();
    int ih = getHeight ();
    float xEnd = x + tileWidth;
    float yEnd = y + tileHeight;
    if (xEnd > iw) xEnd = iw;
    if (yEnd > ih) yEnd = ih;
    for (int yy = y; yy < yEnd; yy ++) {
        int ypos = yy * iw;
        int p = (yy - y) * tileWidth;
        for (int xx = x; xx < xEnd; xx ++, p ++) {
            m_data [xx + ypos] = tile [p];
        }
    }
    reset ();
}


private void getNextChangingElement (int a0, boolean isWhite, int [] ret) {
    int [] pce = this.prevChangingElems;
    int ces = this.changingElemSize;
    int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
    if (isWhite) start &= ~ 0x1;
    else start |= 0x1;
    int i = start;
    for (; i < ces; i += 2) {
        int temp = pce [i];
        if (temp > a0) {
            lastChangingElement = i;
            ret [0] = temp;
            break;
        }
    }
    if (i + 1 < ces) ret [1] = pce [i + 1];
}


-----Function Pair=23=-----==

private void reComputeFunctionValueAndGradientHelper (double [] weightsForTheta) {
    MinRiskDADenseFeaturesSemiringParser gradientSemiringParser = new MinRiskDADenseFeaturesSemiringParser (temperature);
    for (int sentID = 0; sentID < numSentence; sentID ++) {
        FeatureForest fForest = hgFactory.nextHG (sentID);
        fForest.setFeatureWeights (weightsForTheta);
        fForest.setScale (scalingFactor);
        gradientSemiringParser.setHyperGraph (fForest);
        HashMap < Integer, Double > gradients = gradientSemiringParser.computeGradientForTheta ();
        double gradientForScalingFactor = 0;
        if (shouldComputeGradientForScalingFactor) gradientForScalingFactor = computeGradientForScalingFactor (gradients, weightsForTheta, scalingFactor);
        double funcVal = gradientSemiringParser.getFuncVal ();
        double risk = gradientSemiringParser.getRisk ();
        double entropy = gradientSemiringParser.getEntropy ();
        accumulateGradient (gradients, gradientForScalingFactor, weightsForTheta, funcVal, risk, entropy);
        if (sentID > 0 && sentID % 1000 == 0) {
            logger.info ("======processed sentID =" + sentID);
        }
    }
}


private breakpoint setBreakpointAtStringClass (JDP_Field stringField) {
    JDP_Class stringClass = new JDP_Class ();
    stringClass.name = stringField.type;
    stringClass.address = stringField.address;
    try {
        user.bmap.classToJDPClass (stringClass.name, stringClass.address, false, stringClass);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field valueField = (JDP_Field) stringClass.fields.elementAt (0);
    String charArrayString = valueField.value;
    charArrayString = charArrayString.substring (1, charArrayString.indexOf ('}'));
    StringTokenizer st = new StringTokenizer (charArrayString, ", ", false);
    StringBuffer ret = new StringBuffer ();
    while (st.hasMoreTokens ()) {
        ret.append (st.nextToken ());
    }
    String className = ret.toString ();
    breakpoint bp = null;
    try {
        bp = user.bmap.findBreakpoint (className + ".main", null, user.reg.hardwareIP ());
    } catch (BmapMultipleException e1) {
        jdp_console.writeOutput (e1.getMessage ());
    } catch (BmapNotFoundException e2) {
        jdp_console.writeOutput (e2.getMessage ());
    }
    user.bpset.setBreakpoint (bp);
    return bp;
}


-----Function Pair=24=-----==

private void getNextChangingElement (int a0, boolean isWhite, int [] ret) {
    int [] pce = this.prevChangingElems;
    int ces = this.changingElemSize;
    int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
    if (isWhite) start &= ~ 0x1;
    else start |= 0x1;
    int i = start;
    for (; i < ces; i += 2) {
        int temp = pce [i];
        if (temp > a0) {
            lastChangingElement = i;
            ret [0] = temp;
            break;
        }
    }
    if (i + 1 < ces) ret [1] = pce [i + 1];
}


public static Coordinate [] rectangleFromGeometry (Geometry rectangle, int sideOne) {
    if ((rectangle.getNumGeometries () > 1) || (rectangle instanceof MultiPolygon)) rectangle = rectangle.getGeometryN (0);
    Coordinate [] p;
    if (rectangle instanceof Polygon) {
        p = ((Polygon) rectangle).getExteriorRing ().getCoordinates ();
    }
    else p = rectangle.getCoordinates ();
    if (! (p.length == 5)) return null;
    if (sideOne != 1) {
        sideOne = Math.max (1, Math.min (4, sideOne)) - 1;
        for (int j = 0; j < sideOne; j ++) {
            int n = p.length - 2;
            Coordinate t = p [0];
            for (int i = 0; i < n; i ++) {
                p [i] = p [i + 1];
            }
            p [n] = t;
        }
        p [p.length - 1] = p [0];
    }
    Coordinate p2 = perpendicularVector (p [1], p [0], p [1].distance (p [2]), true);
    Coordinate p3 = perpendicularVector (p2, p [1], p [0].distance (p [1]), true);
    Coordinate [] rectangleCoords = {p [0], p [1], p2, p3, p [0]};
    return rectangleCoords;
}


-----Function Pair=25=-----==

public void call (String a) {
    StringRef args = new StringRef (a);
    if (HELP (args, "VER")) return;
    if (args.value.length () > 0) {
        String word = StripWord (args);
        if (! word.equalsIgnoreCase ("set")) return;
        word = StripWord (args);
        try {
            Dos.dos.version.major = (byte) Integer.parseInt (word);
            Dos.dos.version.minor = (byte) Integer.parseInt (args.value);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    else WriteOut (Msg.get ("SHELL_CMD_VER_VER"), new Object [] {Config.VERSION, new Integer (Dos.dos.version.major), new Integer (Dos.dos.version.minor)});
}


public void rowCompleteCheck () {
    int count = 0;
    for (int y = 0; y < rows.length; y ++) {
        boolean hasnull = false;
        for (int x = 0; x < rows [y].blocks.length; x ++) {
            if (rows [y].blocks [x] == null) {
                hasnull = true;
                break;
            }
        }
        if (! hasnull) {
            System.err.println ("Row " + y + " complete!");
            for (int i = y; i > 0; i --) {
                rows [i] = rows [i - 1];
            }
            rows [0] = new Row (0);
            count ++;
        }
    }
    score.addLines (count);
    switch (count) {
        case 4 :
            score.addScore (1200);
            break;
        case 3 :
            score.addScore (300);
            break;
        case 2 :
            score.addScore (100);
            break;
        case 1 :
            score.addScore (40);
            break;
    }
    if (count > 1) {
        t.multiRowCompleted (count);
    }
}


-----Function Pair=26=-----==

protected static final synchronized void putCachedRaster (ColorModel cm, WritableRaster ras) {
    if (cached != null) {
        WritableRaster cras = (WritableRaster) cached.get ();
        if (cras != null) {
            int cw = cras.getWidth ();
            int ch = cras.getHeight ();
            int iw = ras.getWidth ();
            int ih = ras.getHeight ();
            if (cw >= iw && ch >= ih) {
                return;
            }
            if (cw * ch >= iw * ih) {
                return;
            }
        }
    }
    cachedModel = cm;
    cached = new WeakReference (ras);
}


public static void main (String [] args) {
    CAppBridge.init ();
    try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream (10240);
        UncachedUrlStream os = new UncachedUrlStream (CIO.getResourceURL ("broken_glass.ogg"));
        for (Object los : os.getLogicalStreams ()) {
            LogicalOggStream loStream = (LogicalOggStream) los;
            VorbisStream vStream = new VorbisStream (loStream);
            IdentificationHeader vStreamHdr = vStream.getIdentificationHeader ();
            AudioFormat audioFormat = new AudioFormat ((float) vStreamHdr.getSampleRate (), 16, vStreamHdr.getChannels (), true, true);
            System.out.println (audioFormat);
            try {
                byte [] data = new byte [1];
                while (true) {
                    vStream.readPcm (data, 0, 1);
                    baos.write (data);
                }
            } catch (EndOfOggStreamException e) {
            }
            vStream.close ();
            loStream.close ();
        }
        os.close ();
        System.out.println ("pcm data size = " + baos.size ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=27=-----==

private static String StripWord (StringRef line) {
    String scan = line.value;
    scan = scan.trim ();
    if (scan.startsWith ("\"")) {
        int end_quote = scan.indexOf ('"', 1);
        if (end_quote >= 0) {
            line.value = scan.substring (end_quote + 1).trim ();
            return scan.substring (1, end_quote);
        }
    }
    for (int i = 0; i < scan.length (); i ++) {
        if (StringHelper.isspace (scan.charAt (i))) {
            line.value = scan.substring (i).trim ();
            return scan.substring (0, i);
        }
    }
    line.value = "";
    return scan;
}


private void rankPackagesAndMoveClassesBelow () {
    int currentColumnPosition = 0;
    int currentRow = 0;
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        BOTLRuleDiagramNode node = getBOTLRuleDiagramNode (i);
        if (node.isPackage ()) {
            if (currentColumnPosition <= _vMax) {
                node.setRank (currentRow);
                currentColumnPosition ++;
            }
            else {
                node.setRank (++ currentRow);
                currentColumnPosition = 0;
            }
        }
    }
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        if (getBOTLRuleDiagramNode (i).isPackage () && (getBOTLRuleDiagramNode (i).getRank () > _maxPackageRank)) {
            _maxPackageRank = getBOTLRuleDiagramNode (i).getRank ();
        }
    }
    _maxPackageRank ++;
    for (int i = 0; i < _layoutedClassNodes.size (); i ++) {
        if (! getBOTLRuleDiagramNode (i).isPackage ()) getBOTLRuleDiagramNode (i).addRank (_maxPackageRank);
    }
}


-----Function Pair=28=-----==

public static final double [] Preprocess_Series (double [] v, boolean seriesFixedLength, boolean Nor, boolean Tip, boolean Dif) {
    int longitud = v.length;
    double min = Double.MAX_VALUE;
    double max = Double.MIN_VALUE;
    double total = 0;
    for (int pos = 0; pos < longitud; pos ++) {
        if (v [pos] < min) min = v [pos];
        if (v [pos] > max) max = v [pos];
        total += v [pos];
    }
    double amplitud = max - min;
    double media = total / longitud;
    double suma = 0;
    if (Nor) {
        for (int i = 0; i < longitud; i ++) v [i] = (v [i] - min) / amplitud;
    }
    else if (Tip) {
        for (int i = 0; i < longitud; i ++) suma += Math.pow (v [i] - media, 2);
        if (suma > 0) {
            double desv = Math.sqrt (suma / (longitud - 1));
            for (int i = 0; i < longitud; i ++) v [i] = (v [i] - media) / desv;
        }
    }
    if (Dif) longitud --;
    double [] aux = new double [longitud];
    if (Dif) for (int i = 0; i < longitud; i ++) aux [i] = v [i + 1] - v [i];
    else for (int i = 0; i < longitud; i ++) aux [i] = v [i];
    return aux;
}


public void append (Value v, int idx, boolean prio) {
    if (values.length == count) {
        Value [] newval = new Value [count * 2];
        int [] newidx = new int [count * 2];
        boolean [] newprio = new boolean [count * 2];
        for (int i = 0; i < count; i ++) {
            newval [i] = values [i];
            newidx [i] = indexes [i];
            newprio [i] = priorities [i];
        }
        values = newval;
        indexes = newidx;
        priorities = newprio;
    }
    for (int i = 0; i < count; i ++) {
        if (indexes [i] == idx) {
            if (prio || (priorities [i] == prio)) {
                values [i] = v;
                priorities [i] = prio;
            }
            return;
        }
    }
    values [count] = v;
    indexes [count] = idx;
    priorities [count] = prio;
    count ++;
}


-----Function Pair=29=-----==

private double getRepulsionEnergy (final Node node, final OctTree tree) {
    if (tree == null || tree.node == node) return 0.0;
    if (node.weight == 0.0) return 0.0;
    final double dist = getDist (positions.get (node), tree.position);
    if (tree.childCount > 0 && dist < 2.0 * tree.width ()) {
        double energy = 0.0;
        for (int i = 0; i < tree.children.length; i ++) {
            energy += getRepulsionEnergy (node, tree.children [i]);
        }
        return energy;
    }
    if (dist == 0.0) return 0.0;
    if (repuExponent == 0.0) {
        return - repuFactor * node.weight * tree.weight * Math.log (dist);
    }
    else {
        return - repuFactor * node.weight * tree.weight * Math.pow (dist, repuExponent) / repuExponent;
    }
}


protected int countValuesInArrays (int field) {
    int numValues = 0;
    int i = 1, count = 0;
    switch (PIMListImpl.getFieldDataTypeS (getListType (), field)) {
        case PIMItem.STRING :
        case PIMItem.STRING_ARRAY :
            while (count < stringids [0]) {
                if (field == stringids [i]) numValues ++;
                i += 3;
                count ++;
            }
            break;
        case PIMItem.BINARY :
            while (count < byteids [0]) {
                if (field == byteids [i]) numValues ++;
                i += 4;
                count ++;
            }
            break;
        case PIMItem.DATE :
        case PIMItem.INT :
        case PIMItem.BOOLEAN :
            while (count < longvalues [0]) {
                if (field == longvalues [i]) numValues ++;
                i += 4;
                count ++;
            }
            break;
    }
    return numValues;
}


-----Function Pair=30=-----==

void TryInitThroughDatahub () {
    if (! gotDatahubInit) {
        String programMode = getParameter ("programMode");
        if (programMode == null) {
            gotDatahubInit = true;
        }
        else {
            try {
                Applet dataHub = getAppletContext ().getApplet ("datahub");
                if (dataHub != null) {
                    net.sf.yacas.DatahubApplet cons = (net.sf.yacas.DatahubApplet) dataHub;
                    cons.setProgramMode (programMode);
                    String programContentsToLoad = "[" + cons.getProgram () + "];";
                    gotDatahubInit = true;
                    InvokeCalculationSilent (programContentsToLoad);
                }
            } catch (Exception e) {
            }
        }
    }
}


public static int [] parseMask (String mask) {
    String [] arr = getBytes (mask);
    Vector < Integer > v = new Vector < Integer > ();
    if (arr != null) {
        int add = 0;
        for (int i = arr.length - 1; i >= 0; i --) {
            if (arr [i] != null) {
                int [] bits = parseMask (Long.parseLong (arr [i], 16));
                for (int j = 0; bits != null && j < bits.length; j ++) {
                    v.add (bits [j] + add);
                }
            }
            add += 8;
        }
    }
    return sort (toArray (v.toArray (new Integer [v.size ()])));
}


-----Function Pair=31=-----==

public static void main (String [] args) {
    try {
        DiagSignalHandler.install ("SIGINT");
        Class < ? > wrappedClass = Class.forName (args [0]);
        String wrappedArgs [] = new String [args.length - 1];
        for (int i = 0; i < wrappedArgs.length; i ++) {
            wrappedArgs [i] = args [i + 1];
        }
        Class < ? > [] argTypes = new Class [1];
        argTypes [0] = wrappedArgs.getClass ();
        Method mainMethod = wrappedClass.getMethod ("main", argTypes);
        Object [] argValues = new Object [1];
        argValues [0] = wrappedArgs;
        mainMethod.invoke (wrappedClass, argValues);
    } catch (Exception e) {
        System.out.println ("AppWrap exception " + e);
    }
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=32=-----==

int allocColor (Client client, int red, int green, int blue) throws IOException {
    int pixR, pixG, pixB;
    int clss;
    int npix;
    int pixel = 0;
    if (visual.depth.depth == 16) return 0;
    clss = visual.clss;
    if ((flags & BeingCreated) != 0) {
        clss |= DynamicClass;
    }
    switch (clss) {
        case StaticColor :
        case StaticGray :
            if (visual.getDepth ().depth == 1) {
                pixel = ((red + green + blue) / 3) == 0 ? 0 : 1;
            }
            else {
                pixel = (red + green + blue) / 3;
            }
            break;
        case GrayScale :
        case PseudoColor :
            pixel = findColor (client, entries, red, green, blue, PSEUDOMAP);
            if (client.errorReason != 0) {
                return pixel;
            }
            break;
    }
    if ((pixels [client.index] != null) && (pixels [client.index].length == 1) && (((id & Client.CLIENTMASK)>> Client.CLIENTOFFSET) != client.index) && (flags & BeingCreated) == 0) {
        ClientColormap cc = new ClientColormap (Resource.fakeClientId (client), client.index, id);
        add (cc);
    }
    return pixel;
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=33=-----==

private void incrementalSortGameObjectsOnYPosition () {
    GameObject tempGameObject;
    for (int i = 0; i < size - 1; i ++) {
        if (gameObjects [i].y - gameObjects [i].boundingDimension / 2 > gameObjects [i + 1].y - gameObjects [i + 1].boundingDimension / 2) {
            tempGameObject = gameObjects [i];
            gameObjects [i] = gameObjects [i + 1];
            gameObjects [i + 1] = tempGameObject;
            int j = i;
            while (j > 0 && gameObjects [j].y - gameObjects [j].boundingDimension / 2 < gameObjects [j - 1].y - gameObjects [j - 1].boundingDimension / 2) {
                tempGameObject = gameObjects [j];
                gameObjects [j] = gameObjects [j - 1];
                gameObjects [j - 1] = tempGameObject;
                j --;
            }
            j = i + 1;
            while (j < size - 1 && gameObjects [j].y - gameObjects [j].boundingDimension / 2 > gameObjects [j + 1].y - gameObjects [j + 1].boundingDimension / 2) {
                tempGameObject = gameObjects [j];
                gameObjects [j] = gameObjects [j + 1];
                gameObjects [j + 1] = tempGameObject;
                j ++;
            }
        }
    }
}


static void sort (int [] a) {
    int i = 0;
    while (i < a.length - 1) {
        int j = 0;
        while (j < (a.length - i) - 1) {
            if (a [j] > a [j + 1]) {
                int aux = a [j];
                a [j] = a [j + 1];
                a [j + 1] = aux;
            }
            j = j + 1;
        }
        i = i + 1;
    }
}


-----Function Pair=34=-----==

private JComponent createBoardUI () {
    JComponent boardPanel = new JPanel ();
    boardPanel.setLayout (new BoxLayout (boardPanel, BoxLayout.Y_AXIS));
    boardPanel.setBorder (BorderFactory.createCompoundBorder (BorderFactory.createTitledBorder ("Board"), BorderFactory.createEmptyBorder (0, 10, 10, 10)));
    JLabel patternLabel = new JLabel ("Pattern:");
    patternLabel.setDisplayedMnemonic ('P');
    patternLabel.setLabelFor (boardPatterns);
    patternLabel.setAlignmentX (JComponent.LEFT_ALIGNMENT);
    JScrollPane scrollPane = new JScrollPane (boardPatterns, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    scrollPane.setAlignmentX (JComponent.LEFT_ALIGNMENT);
    scrollPane.setMaximumSize (new Dimension (Integer.MAX_VALUE, Integer.MAX_VALUE));
    JPanel colorsPanel = new PreferredSizedPanel (new TableLayout (1, 0, 5));
    colorsPanel.setAlignmentX (JComponent.LEFT_ALIGNMENT);
    colorsPanel.add (darkSquares);
    colorsPanel.add (lightSquares);
    boardPanel.add (patternLabel);
    boardPanel.add (Box.createVerticalStrut (5));
    boardPanel.add (scrollPane);
    boardPanel.add (Box.createVerticalStrut (10));
    boardPanel.add (colorsPanel);
    boardColorsPanel = colorsPanel;
    return boardPanel;
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=35=-----==

public void startElement (String uri, String localName, String qName, Attributes attributes) {
    System.out.println ("Element start: " + qName);
    for (int i = 0; i < attributes.getLength (); i ++) {
        System.out.print ("Attr: " + attributes.getQName (i));
        System.out.println (", " + attributes.getValue (i));
        if (pano_id == null && attributes.getQName (i) == "pano_id") {
            pano_id = attributes.getValue (i);
        }
        else if (pano_id != null && iLinks < MAX_LINK && attributes.getQName (i) == "pano_id") {
            pano_id_link [iLinks] = attributes.getValue (i);
            System.out.println ("linked! [" + iLinks + "] from " + pano_id + " to " + pano_id_link [iLinks]);
            iLinks ++;
        }
        if (attributes.getQName (i) == "pano_yaw_deg") {
            pano_yaw_deg = attributes.getValue (i);
        }
        else if (attributes.getQName (i) == "tilt_yaw_deg") {
            tilt_yaw_deg = attributes.getValue (i);
        }
        else if (pano_id != null && iDegLinks < 3 && attributes.getQName (i) == "yaw_deg") {
            yaw_deg_link [iDegLinks] = attributes.getValue (i);
            iDegLinks ++;
        }
        if (attributes.getQName (i) == "lat") {
            lat = attributes.getValue (i);
        }
        else if (attributes.getQName (i) == "lng") {
            lng = attributes.getValue (i);
        }
    }
}


void recalculate () {
    plainFont = getFont ();
    if (plainFont == null) plainFont = new Font ("Helvetica", Font.PLAIN, 12);
    boldFont = new Font (plainFont.getFamily (), Font.BOLD, plainFont.getSize ());
    fmBoldFont = getFontMetrics (boldFont);
    Z = fmBoldFont.getHeight () + 2 * lineWidth + 2 * YTitle + 1;
    for (int i = 0; i < nbTab; ++ i) {
        arrBeg [i] = (i == 0) ? xTabOffset : arrEnd [i - 1];
        arrEnd [i] = arrBeg [i] + 2 * XTitle + fmBoldFont.stringWidth (arrName [i]) + 2 * lineWidth;
    }
    if (selected >= 0) {
        arrBeg [selected] -= lineWidth;
        arrEnd [selected] += lineWidth;
    }
    mustRecalculate = false;
}


-----Function Pair=36=-----==

public static Vector getGlobalElementsInXSD (Document doc) {
    Vector elementVector = new Vector ();
    NodeList nodeList = doc.getDocumentElement ().getChildNodes ();
    int index = 0;
    while (index < nodeList.getLength ()) {
        if (nodeList.item (index).getNodeType () == Element.ELEMENT_NODE) break;
        index ++;
    }
    Node elementNode = nodeList.item (index);
    Element element = (Element) nodeList.item (index);
    if (element.getLocalName ().equals ("element")) {
        elementVector.add (element);
    }
    Node nextSibling = null;
    while ((nextSibling = elementNode.getNextSibling ()) != null) {
        System.out.println (element.getLocalName () + " - " + nextSibling.getLocalName ());
        if (nextSibling.getNodeType () == Element.ELEMENT_NODE) {
            Element nextElement = (Element) nextSibling;
            if (nextElement.getLocalName ().equals ("element")) {
                elementVector.add (nextElement);
            }
        }
        elementNode = nextSibling;
    }
    return elementVector;
}


private void compileBootImage (String args []) {
    String bi_args [] = new String [args.length - 1];
    String bi_name = args [args.length - 1];
    Class pub_cl;
    Object pub_obj;
    java.lang.reflect.Method pub_methods [];
    jdp_console.writeOutput ("Compiling Boot Image for " + bi_name + " . . . ");
    for (int i = 0; i < bi_args.length; i ++) {
        bi_args [i] = args [i + 1];
    }
    try {
        pub_cl = Class.forName (args [0]);
        pub_obj = pub_cl.newInstance ();
        pub_methods = pub_cl.getMethods ();
        for (int n = 0; n < pub_methods.length; n ++) {
            if (pub_methods [n].getName ().equals ("main")) {
                Object invoke_args [] = {bi_args};
                pub_methods [n].invoke (pub_obj, invoke_args);
                return;
            }
        }
    } catch (ClassNotFoundException e) {
        jdp_console.writeOutput ("cannot compile, publicizing class loader not found: " + args [0]);
        System.exit (1);
    } catch (InstantiationException e1) {
        jdp_console.writeOutput ("cannot compile, problem instantiating class");
        System.exit (1);
    } catch (IllegalAccessException e2) {
        jdp_console.writeOutput ("cannot compile, illegal access to class");
        System.exit (1);
    } catch (InvocationTargetException e3) {
        jdp_console.writeOutput ("cannot compile, Invocation Target Exception:");
        jdp_console.writeOutput (e3.getMessage ());
        System.exit (1);
    }
}


-----Function Pair=37=-----==

public static int [] sort (int [] v) {
    int i;
    int l = v.length;
    int [] index = new int [l];
    for (i = 0; i < l; i ++) index [i] = i;
    int tmp;
    boolean change = true;
    while (change) {
        change = false;
        for (i = 0; i < l - 1; i ++) {
            if (v [index [i]] > v [index [i + 1]]) {
                tmp = index [i];
                index [i] = index [i + 1];
                index [i + 1] = tmp;
                change = true;
            }
        }
    }
    return index;
}


private void bruteForceSort (int values []) {
    int len = values.length;
    for (int i = len; i > 1; i --) {
        int v = values [len - 1];
        int insertionPoint = 0;
        for (insertionPoint = 0; insertionPoint < values.length - i; insertionPoint ++) {
            if (v <= values [insertionPoint]) {
                break;
            }
        }
        int numToMove = len - insertionPoint - 1;
        System.arraycopy (values, insertionPoint, values, insertionPoint + 1, numToMove);
        values [insertionPoint] = v;
    }
}


-----Function Pair=38=-----==

public StreetView () {
    menuBar = new JMenuBar ();
    menuGo = new JMenu ("Go");
    menuGoStrait = new JMenuItem ("Go Ahead");
    menuGoRight = new JMenuItem ("Go Other way");
    menuGoLeft = new JMenuItem ("Go Back");
    menuKeepGoing = new JCheckBoxMenuItem ("Keep Going");
    menuGoStrait.addActionListener (this);
    menuGoRight.addActionListener (this);
    menuGoLeft.addActionListener (this);
    menuKeepGoing.addActionListener (this);
    menuBar.add (menuGo);
    menuGo.add (menuGoStrait);
    menuGo.add (menuGoRight);
    menuGo.add (menuGoLeft);
    menuGo.add (menuKeepGoing);
    menuTurn = new JMenu ("Turn");
    menuTurnRight = new JMenuItem ("Turn Right");
    menuTurnLeft = new JMenuItem ("Turn Left");
    menuKeepTurning = new JCheckBoxMenuItem ("Keep Turning");
    menuTurnRight.addActionListener (this);
    menuTurnLeft.addActionListener (this);
    menuKeepTurning.addActionListener (this);
    menuBar.add (menuTurn);
    menuTurn.add (menuTurnRight);
    menuTurn.add (menuTurnLeft);
    menuTurn.add (menuKeepTurning);
    getRootPane ().setJMenuBar (menuBar);
    img = null;
    mLat = 35.685727;
    mLng = 139.76121;
    mPanoId = mPanoIdPrev = mPanoIdNext = null;
    mXid = mXidPrev = 0;
    pano_id_link = new String [MAX_LINK + 1];
    for (int i = 0; i < MAX_LINK + 1; i ++) {
        pano_id_link [i] = null;
    }
    mDir = 195.84 + DIVIDED_DEG * (mXid - 3);
    if (mDir < 0.0) {
        mDir += 360.0;
    }
    else if (mDir > 360.0) {
        mDir -= 360.0;
    }
    mDirPrev = mDir;
    new Timer (INTERVAL, new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            repaint ();
            if (img == null || ! mPanoId.equals (mPanoIdNext) || mXidPrev != mXid) {
                try {
                    grab (mLat, mLng, mPanoIdNext, mXid);
                    if (fKeepGoing) {
                        mXid = - 1;
                        mPanoIdNext = pano_id_link [0];
                    }
                    else if (fKeepTurning) {
                        if (mXid < 0) {
                            mXid = mXidPrev;
                        }
                        mXid ++;
                        if (mXid > 6) mXid = 0;
                    }
                } catch (Exception e1) {
                    e1.printStackTrace ();
                }
            }
        }
    }
    ).start ();
}


public void update (float time, Vector3 lookat) {
    if (firstRun == true) {
        firstRun = false;
        position.y = terrain.terrainIntersection (new Vector3 (position.x, position.z, 0));
    }
    forwardDirection = new Vector3 (goal.x - position.x, 0, goal.z - position.z);
    forwardDirection.normalize ();
    float timeInterval = time - oldTime;
    oldTime = time;
    float distance = timeInterval * speed;
    float realDistance = (float) Math.sqrt (Math.pow (position.x - goal.x, 2) + Math.pow (position.z - goal.z, 2));
    if (realDistance < distance) distance = realDistance;
    float directionRadians = this.direction (position, goal);
    Vector3 newPosition = new Vector3 ((float) (position.x + distance * forwardDirection.x), (float) (position.z + distance * forwardDirection.z), (float) 0);
    float newY = terrain.terrainIntersection (new Vector3 (newPosition.x, newPosition.y, 0));
    float nextY = terrain.terrainIntersection (new Vector3 (newPosition.x + forwardDirection.x * 0.01f, newPosition.y + forwardDirection.z * 0.01f, 0));
    float incline = (nextY - newY) / 0.01f;
    if (goal.x != position.x || goal.z != position.z) {
        {
            position.x = newPosition.x;
            position.z = newPosition.y;
            position.y = newY;
        }
    }
    float tempx = position.x + cameraDistance * (float) Math.cos ((double) time / 100.0);
    float tempy = position.z + cameraDistance * (float) Math.sin ((double) time / 100.0);
    if (lookat != null) {
        Vector3 lookFrom = new Vector3 (lookat.x - position.x, lookat.y - position.y, lookat.z - position.z);
        lookFrom.normalize ();
        tempx = position.x + cameraDistance * (lookFrom.x);
        tempy = position.z + cameraDistance * (lookFrom.z);
    }
    cameraDirection = new Vector3 (tempx, position.y + cameraDistance / 2.0f, tempy);
}


-----Function Pair=39=-----==

void riffleTalon () {
    LOGGER.info (getName () + ".riffleTalon() - " + cardsTalon);
    if (cardsTalon.size () > 2) {
        MauMauCard c;
        int left = 0;
        int right = 0;
        for (int i = 0; i < (deck.getCardsCount ()); i ++) {
            while (left == right) {
                left = deck.getRandomInt (cardsTalon.size ());
                right = deck.getRandomInt (cardsTalon.size ());
            }
            c = cardsTalon.elementAt (left);
            cardsTalon.setElementAt (cardsTalon.elementAt (right), left);
            cardsTalon.setElementAt (c, right);
            left = right;
        }
    }
    LOGGER.info (getName () + ".riffledTalon() - " + cardsTalon);
}


public static void BubbleSortDouble1 (double [] num) {
    boolean flag = true;
    double temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=40=-----==

public static void bubbleSort (String [] a) {
    Collator myCollator = Collator.getInstance ();
    boolean switched = true;
    for (int pass = 0; pass < a.length - 1 && switched; pass ++) {
        switched = false;
        for (int i = 0; i < a.length - pass - 1; i ++) {
            if (myCollator.compare (a [i], a [i + 1]) > 0) {
                switched = true;
                String temp = a [i];
                a [i] = a [i + 1];
                a [i + 1] = temp;
            }
        }
    }
}


private double [] getKnotArray (int uik, double [] orig, int nSegments) {
    double [] knots = new double [uik];
    if (isClosed) {
        int i, j;
        for (i = (this.degree - 1), j = (nSegments - 1); i >= 0; i --, j --) {
            knots [i] = knots [i + 1] - (orig [j + 1] - orig [j]);
        }
        for (i = (this.degree + 1), j = 1; j < (nSegments + 1); i ++, j ++) {
            knots [i] = orig [j];
        }
        for (j = 0; j < this.degree; i ++, j ++) {
            knots [i] = knots [i - 1] + (orig [j + 1] - orig [j]);
        }
    }
    else {
        for (int i = 0; i < knots.length; i ++) {
            knots [i] = orig [i];
        }
    }
    return knots;
}


-----Function Pair=41=-----==

public void paint (Graphics g) {
    Iterator i = rects.iterator ();
    int count = 0;
    int idx = 0;
    int group = 0;
    while ((group < counts.length - 1) && (idx == counts [group])) group ++;
    int cmax = counts.length - 1;
    while (i.hasNext ()) {
        Rectangle r = (Rectangle) i.next ();
        Color c;
        c = new Color (1f, (cmax - group) / (float) cmax, 0, (count + 1f) / rects.size ());
        g.setColor (c);
        g.drawRect (r.x, r.y, r.width, r.height);
        count ++;
        idx ++;
        while ((group < counts.length - 1) && (idx == counts [group])) {
            group ++;
            idx = 0;
        }
    }
}


public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


-----Function Pair=42=-----==

void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=43=-----==

private void checkDimension (DiagnosticPosition pos, Type t) {
    switch (t.tag) {
        case METHOD :
            checkDimension (pos, t.getReturnType ());
            for (List < Type > args = t.getParameterTypes (); args.nonEmpty (); args = args.tail) checkDimension (pos, args.head);
            break;
        case ARRAY :
            if (types.dimensions (t) > ClassFile.MAX_DIMENSIONS) {
                log.error (pos, "limit.dimensions");
                nerrs ++;
            }
            break;
        default :
            break;
    }
}


private static void OpenSocket () {
    int sockNum, sockAlloc;
    sockNum = swapByte (CPU_Regs.reg_edx.word ());
    if (socketCount >= SOCKETTABLESIZE) {
        CPU_Regs.reg_eax.low (0xfe);
        return;
    }
    if (sockNum == 0x0000) {
        sockAlloc = 0x4002;
        while (sockInUse (sockAlloc) && (sockAlloc < 0x7fff)) sockAlloc ++;
        if (sockAlloc > 0x7fff) {
            Log.log_msg ("IPX: Out of dynamic sockets");
        }
        sockNum = sockAlloc;
    }
    else {
        if (sockInUse (sockNum)) {
            CPU_Regs.reg_eax.low (0xff);
            return;
        }
    }
    opensockets [socketCount] = sockNum;
    socketCount ++;
    CPU_Regs.reg_eax.low (0x00);
    CPU_Regs.reg_edx.word (swapByte (sockNum));
}


-----Function Pair=44=-----==

private void parseRunArgs (String args []) {
    String bootimage = null;
    int i;
    for (i = 0; i < args.length; i ++) {
        if (args [i].equals ("-n")) {
            classesNeededFilename = args [++ i];
        }
        else if (args [i].equals ("-classpath")) {
            classpath = args [++ i];
        }
        else if (args [i].equals ("-i")) {
            bootimage = args [++ i];
        }
        else {
            break;
        }
    }
    if (classpath == null) {
        jdp_console.writeOutput ("ERROR:  no classpath, static fields will be incorrect");
    }
    if (classesNeededFilename == null) {
        jdp_console.writeOutput ("ERROR: no classesNeeded file, line number will not be correct");
        return;
    }
    if (bootimage != null) {
        saved_progname = bootimage;
        bi_args = new String [args.length - i + 2];
        int j = 0;
        bi_args [j ++] = bi_runner;
        bi_args [j ++] = "-X:i=" + bootimage;
        for (int k = i; k < args.length; k ++) {
            bi_args [j ++] = args [k];
        }
    }
    else {
        saved_progname = args [args.length - 1];
        bi_args = new String [2];
        bi_args [0] = bi_runner;
        bi_args [1] = saved_progname;
    }
}


protected void build () {
    if (isPopupMenuVisible () || valid_) return;
    FuLog.debug ("BMT: build menu internal frames");
    valid_ = true;
    removeAll ();
    if (desktop_ == null) {
        number_ = 0;
        return;
    }
    JInternalFrame [] frames = desktop_.getAllFrames ();
    number_ = frames.length;
    for (int i = 0; i < frames.length - 1; i ++) {
        String t0 = frames [i].getTitle ();
        String t1 = frames [i + 1].getTitle ();
        if (t0 == null) System.err.println ("No title for " + frames [i].getName ());
        if ((t0 != null) && (t1 != null) && (t1.compareTo (t0) < 0)) {
            JInternalFrame tmp = frames [i];
            frames [i] = frames [i + 1];
            frames [i + 1] = tmp;
            i -= 2;
            if (i < 0) i = - 1;
        }
    }
    for (int i = 0; i < frames.length; i ++) {
        JInternalFrame f = frames [i];
        String n = f.getName ();
        if ((n != null) && (f.getClientProperty ("JInternalFrame.isPalette") != Boolean.TRUE)) {
            if (n.startsWith ("if")) n = n.substring (2);
            BuMenuItem mi = addMenuItem (f.getTitle (), "FILLE_ACTIVER(" + n + ")", true, BuInternalFrame.getShortcut (f));
            Icon icon = f.getFrameIcon ();
            if (icon instanceof BuIcon) mi.setIcon (BuResource.BU.reduceMenuIcon ((BuIcon) icon));
            else mi.setIcon (icon);
        }
    }
    computeMnemonics ();
}


-----Function Pair=45=-----==

public Node removeChild (int n) {
    int numChildren = getChildCount ();
    if (n >= numChildren) {
        throw new IllegalArgumentException ("Nonexistent child");
    }
    Node [] newChild = new Node [numChildren - 1];
    for (int i = 0; i < n; i ++) {
        newChild [i] = child [i];
    }
    for (int i = n; i < numChildren - 1; i ++) {
        newChild [i] = child [i + 1];
    }
    Node removed = child [n];
    removed.setParent (null);
    child = newChild;
    return removed;
}


public static String [] toArgs (String line) {
    String lineargs [];
    String str = new String (line);
    Vector vec = new Vector ();
    for (;;) {
        while (str.startsWith (" ")) str = str.substring (1);
        if (str.length () == 0) break;
        int end = str.indexOf (" ");
        if (end == - 1) {
            vec.addElement (str);
            str = "";
        }
        else {
            vec.addElement (str.substring (0, end));
            str = str.substring (end);
        }
    }
    if (vec.size () != 0) {
        lineargs = new String [vec.size ()];
        for (int i = 0; i < lineargs.length; ++ i) lineargs [i] = (String) vec.elementAt (i);
        return lineargs;
    }
    return null;
}


-----Function Pair=46=-----==

public boolean loadColors (File file) {
    if ((file != null) && file.exists ()) {
        final Path path = new Path (file.getAbsolutePath ());
        final String fileExt = path.getFileExtension ();
        if (fileExt.equalsIgnoreCase ("aco")) {
            disposeColorItems ();
            final byte [] acoData = IOUtils.readFile (file, 0);
            colors = Aco.readColors (acoData, colorContainer.getDisplay ());
            final Rectangle rect = colorContainer.getClientArea ();
            columns = (rect.width / 17);
            savePrefs (file);
            return true;
        }
        else if (fileExt.equalsIgnoreCase ("gpl")) {
            final ProxyColor [] colors2 = GimpPaletteReader.readGimpPalette (colorContainer.getDisplay (), file);
            if (colors2 == null) {
                return false;
            }
            disposeColorItems ();
            colors = colors2;
            final Rectangle rect = colorContainer.getClientArea ();
            columns = (rect.width / 17);
            savePrefs (file);
            return true;
        }
        else if (fileExt.equalsIgnoreCase ("ifpc")) {
            disposeColorItems ();
            try {
                final Object object = IOUtils.readObject (file);
                convertToColorAndGradient (object, file.getName ());
                savePrefs (file);
                return true;
            } catch (final IOException e) {
                e.printStackTrace ();
            }
        }
    }
    return false;
}


public static Geometry rectangleBufferArcs (Geometry rectangle, double frontAngle, double rearAngle, double [] distances, int sideOne, double arcTolerance) {
    Coordinate [] p = rectangleFromGeometry (rectangle, sideOne);
    if (p == null) return null;
    int count = 0;
    for (int i = 0; i < distances.length; i ++) {
        if (distances [i] != 0.0) count ++;
    }
    Polygon [] arcs = new Polygon [count];
    count = 0;
    if (distances [0] != 0.0) arcs [count ++] = (Polygon) bufferArc (p [0], p [1], frontAngle, frontAngle, distances [0], arcTolerance);
    if (distances [1] != 0.0) arcs [count ++] = (Polygon) bufferArc (p [1], p [2], 90 - frontAngle, 90 - rearAngle, distances [1], arcTolerance);
    if (distances [2] != 0.0) arcs [count ++] = (Polygon) bufferArc (p [2], p [3], rearAngle, rearAngle, distances [2], arcTolerance);
    if (distances [3] != 0.0) arcs [count ++] = (Polygon) bufferArc (p [3], p [0], 90 - rearAngle, 90 - frontAngle, distances [3], arcTolerance);
    if (count == 1) return arcs [0];
    else return new GeometryFactory ().createMultiPolygon (arcs);
}


-----Function Pair=47=-----==

String substitute (String input, String var, String [] fields, String [] fieldData) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        if (DEBUG) System.out.println ("checking for occurrence of " + var + " in :" + input.substring (oidx));
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        if (input.charAt (idx) != '.') throw new IOException ("no field");
        idx ++;
        int idx_save = idx;
        for (int i = 0; i < fields.length; i ++) {
            String fld = fields [i];
            int flen = fld.length ();
            if (DEBUG) System.out.println ("checking if it is field " + fld);
            if (input.regionMatches (idx, fld, 0, flen)) {
                String value = fieldData [i];
                if (DEBUG) System.out.println ("field matches. outputting data :" + value);
                out.append (value);
                idx += flen;
                break;
            }
        }
        if (idx == idx_save) throw new IOException ("unknown field");
        oidx = idx;
    }
    if (DEBUG) System.out.println ("no more variables left on this line");
    out.append (input.substring (oidx));
    return out.toString ();
}


protected void drawContents (Graphics2D g) {
    Rectangle r = new Rectangle (bounds.x + IOPort.SIZE, bounds.y + IOPort.SIZE, bounds.width - 2 * IOPort.SIZE, bounds.height - 2 * IOPort.SIZE);
    double miny = Double.MAX_VALUE, maxy = - Double.MAX_VALUE;
    for (int i = 0; i < y.length; i ++) {
        if (y [i] < miny) miny = y [i];
        if (y [i] > maxy) maxy = y [i];
    }
    g.setColor (Color.white);
    g.fillRect (r.x, r.y, r.width, r.height);
    g.setColor (Color.black);
    if (shape == SMOOTH_INTERPOLATE) {
        int lastx = (int) (r.x + x [0] * r.width);
        int lasty = (int) (r.y + (maxy - y [0]) * r.height / (maxy - miny));
        for (int i = 0; i < x.length - 1; i ++) {
            double dx = x [i + 1] - x [i];
            int nextx = 0, nexty = 0;
            if (dx == 0.0) {
                nextx = (int) (r.x + x [i + 1] * r.width);
                nexty = (int) (r.y + (maxy - y [i + 1]) * r.height / (maxy - miny));
            }
            else for (int j = 1; j < 8; j ++) {
                double xf = x [i] + j * 0.125 * dx, yf = calcValue (xf);
                nextx = (int) (r.x + xf * r.width);
                nexty = (int) (r.y + (maxy - yf) * r.height / (maxy - miny));
                g.drawLine (lastx, lasty, nextx, nexty);
                lastx = nextx;
                lasty = nexty;
            }
            g.drawLine (lastx, lasty, nextx, nexty);
            lastx = nextx;
            lasty = nexty;
        }
        return;
    }
    for (int i = 0; i < x.length - 1; i ++) {
        int x1 = (int) (r.x + x [i] * r.width);
        int y1 = (int) (r.y + (maxy - y [i]) * r.height / (maxy - miny));
        int x2 = (int) (r.x + x [i + 1] * r.width);
        int y2 = (int) (r.y + (maxy - y [i + 1]) * r.height / (maxy - miny));
        g.drawLine (x1, y1, x2, y2);
    }
}


-----Function Pair=48=-----==

void processTemplateRegion (Vector region) throws IOException {
    String inLine = (String) region.elementAt (0);
    int command = getTemplateCommand (inLine);
    switch (command) {
        case FOREACH :
            processForeachRegion (region);
            break;
        case LOOP :
            processLoopRegion (region);
            break;
        case COUNT :
            processCountRegion (region);
            break;
        case SPLIT :
            processSplitRegion (region);
            break;
        case JOIN :
            processJoinRegion (region);
            break;
        case LET :
            processLetRegion (region);
            break;
        case EVAL :
            processEvalRegion (region);
            break;
        case IF :
            processCondRegion (region);
            break;
        case INCLUDE :
            processIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
}


void processTemplateRegion (Vector region) throws IOException {
    String inLine = (String) region.elementAt (0);
    int command = getTemplateCommand (inLine);
    switch (command) {
        case FOREACH :
            processForeachRegion (region);
            break;
        case LOOP :
            processLoopRegion (region);
            break;
        case COUNT :
            processCountRegion (region);
            break;
        case SPLIT :
            processSplitRegion (region);
            break;
        case JOIN :
            processJoinRegion (region);
            break;
        case LET :
            processLetRegion (region);
            break;
        case EVAL :
            processEvalRegion (region);
            break;
        case IF :
            processCondRegion (region);
            break;
        case INCLUDE :
            processIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
}


-----Function Pair=49=-----==

void resetColors () {
    if ((colors == null) || (colors.length == 0)) {
        return;
    }
    final Control [] children = colorContainer.getChildren ();
    final int length = gradientDatas == null ? 0 : gradientDatas.length;
    if (colors.length != children.length - length) {
        return;
    }
    final IProxyColor [] colors2 = new ProxyColor [colors.length];
    for (int i = 0; i < colors.length; i ++) {
        final int index = colors [i].getIndex ();
        if ((index < children.length) && (index > - 1)) {
            colors2 [index] = colors [i];
        }
        else {
            System.err.println ("resetColors()");
        }
    }
    colors = colors2;
    updateColors ();
}


public static void selectSort (int [] a) {
    if (a == null) {
        throw new IllegalArgumentException ("Null-pointed array");
    }
    for (int i = 0; i <= a.length - 2; i ++) {
        int min = a [i];
        int index = i;
        for (int j = i; j <= a.length - 1; j ++) {
            if (a [j] < min) {
                min = a [j];
                index = j;
            }
        }
        a [index] = a [i];
        a [i] = min;
    }
}


-----Function Pair=50=-----==

int walk (Node node, int [] keyList, int count) throws IOException {
    int i;
    if (count > keyList.length - 1) {
        return keyList.length;
    }
    for (i = 0; i < NODE_ELEMENTS + 1 && count < keyList.length; i ++) {
        if (node.child [i] > 0) {
            int parent_offset = node.offset;
            node.load (node.child [i]);
            count = walk (node, keyList, count);
            node.load (parent_offset);
        }
        if (node.key [i] > 0 && count < keyList.length) {
            keyList [count ++] = node.key [i];
        }
        else {
            break;
        }
    }
    return count;
}


public void doFullFrame (String command, String [] args) {
    int from, to;
    try {
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstackTraceFull (0, 20));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    int fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstackTraceFull (fp));
                }
                else {
                    from = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstackTraceFull (from, from));
                }
                break;
            case 2 :
                from = Integer.parseInt (args [0]);
                to = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstackTraceFull (from, to));
                break;
            default :
                printHelp (command);
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad stack frame numbers (decimal) or frame pointer value (hex)");
    }
}


-----Function Pair=51=-----==

private static void f (int i, byte [] key, byte [] a, byte [] x) {
    byte [] e = new byte [64];
    byte [] ikey = new byte [64];
    byte [] y = new byte [64];
    System.arraycopy (a, 0, e, 0, e.length);
    transpose (e, EP, 48);
    for (int j = rots [i]; j > 0; j --) {
        rotate (key);
    }
    System.arraycopy (key, 0, ikey, 0, ikey.length);
    transpose (ikey, KeyTr2, 48);
    for (int j = 0; j < 48; j ++) {
        y [j] = (byte) (e [j] ^ ikey [j]);
    }
    for (int j = 0; j < 8; j ++) {
        int k = j + 1;
        int r = 32 * y [6 * k - 6] + 8 * y [6 * k - 5] + 4 * y [6 * k - 4] + 2 * y [6 * k - 3] + y [6 * k - 2] + 16 * y [6 * k - 1];
        int xb = s_boxes [j] [r];
        x [4 * k - 4] = (byte) ((xb>> 3) & 1);
        x [4 * k - 3] = (byte) ((xb>> 2) & 1);
        x [4 * k - 2] = (byte) ((xb>> 1) & 1);
        x [4 * k - 1] = (byte) (xb & 1);
    }
    transpose (x, ptr, 32);
}


private void processRawBitmapCache (RdpPacket_Localised data) throws RdesktopException {
    int cache_id = data.get8 ();
    data.incrementPosition (1);
    int width = data.get8 ();
    int height = data.get8 ();
    int bpp = data.get8 ();
    int Bpp = (bpp + 7) / 8;
    int bufsize = data.getLittleEndian16 ();
    int cache_idx = data.getLittleEndian16 ();
    int pdata = data.getPosition ();
    data.incrementPosition (bufsize);
    byte [] inverted = new byte [width * height * Bpp];
    int pinverted = (height - 1) * (width * Bpp);
    for (int y = 0; y < height; y ++) {
        data.copyToByteArray (inverted, pinverted, pdata, width * Bpp);
        pinverted -= width * Bpp;
        pdata += width * Bpp;
    }
    cache.putBitmap (cache_id, cache_idx, new Bitmap (Bitmap.convertImage (inverted, Bpp), width, height, 0, 0), 0);
}


-----Function Pair=52=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


public void run (String arg) {
    ImagePlus imp = WindowManager.getCurrentImage ();
    if (imp == null) {
        IJ.showMessage ("Save As ", "No images are open.");
        return;
    }
    String name = imp.getTitle ();
    int dotIndex = name.lastIndexOf (".");
    if (dotIndex >= 0) name = name.substring (0, dotIndex);
    AnimatedGifEncoder2 fr = new AnimatedGifEncoder2 ();
    fr.name = name;
    if (! fr.setoptions ()) return;
    name = fr.name;
    IJ.register (Gif_Stack_Writer.class);
    SaveDialog sd = new SaveDialog ("Filename", name + "." + type, "." + type);
    String file = sd.getFileName ();
    if (file == null) return;
    String directory = sd.getDirectory ();
    ImageStack stack = imp.getStack ();
    ImagePlus tmp = new ImagePlus ();
    int nSlices = stack.getSize ();
    fr.start (directory + file);
    for (int i = 1; i <= nSlices; i ++) {
        IJ.showStatus ("writing: " + i + "/" + nSlices);
        IJ.showProgress ((double) i / nSlices);
        tmp.setProcessor (null, stack.getProcessor (i));
        try {
            fr.addFrame (tmp);
        } catch (Exception e) {
            IJ.showMessage ("Save as " + type, "" + e);
        }
        System.gc ();
    }
    fr.finish ();
    IJ.showStatus ("");
    IJ.showProgress (1.0);
}


-----Function Pair=53=-----==

boolean ReadVTOC (int drive, int volume, int data, IntRef error) {
    short subunit = GetSubUnit (drive);
    if (! ReadSectors (subunit, false, 16 + volume, 1, data)) {
        error.value = MSCDEX_ERROR_DRIVE_NOT_READY;
        return false;
    }
    byte [] id = new byte [5];
    Memory.MEM_BlockRead (data + 1, id, 5);
    if (! "CD001".equals (new String (id))) {
        error.value = MSCDEX_ERROR_BAD_FORMAT;
        return false;
    }
    short type = Memory.mem_readb (data);
    error.value = (type == 1) ? 1 : (type == 0xFF) ? 0xFF : 0;
    return true;
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=54=-----==

private void GenerateOpponentAddGadgets (int tries) {
    if (getGadgetSlots () > 0) {
        int numGadgets = 0;
        if (Game.CurrentGame ().Difficulty () == Difficulty.Impossible) {
            numGadgets = getGadgetSlots ();
        }
        else {
            numGadgets = Functions.GetRandom (getGadgetSlots () + 1);
            if (numGadgets < getGadgetSlots () && (tries > 4 || (tries > 2 && Functions.GetRandom (2) > 0))) {
                numGadgets ++;
            }
        }
        for (int i = 0; i < numGadgets; i ++) {
            int bestGadgetType = 0;
            for (int j = 0; j < tries; j ++) {
                int x = Functions.GetRandom (100);
                int sum = Consts.Gadgets [0].Chance ();
                int gadgetType = 0;
                while (sum < x && gadgetType <= Consts.Gadgets.length - 1) {
                    gadgetType ++;
                    sum += Consts.Gadgets [gadgetType].Chance ();
                }
                if (! HasGadget (Consts.Gadgets [gadgetType].Type ()) && gadgetType > bestGadgetType) {
                    bestGadgetType = gadgetType;
                }
            }
            AddEquipment (Consts.Gadgets [bestGadgetType]);
        }
    }
}


public synchronized void dotsNoLight () {
    for (int i = pixels.length - 1; i >= 0; i --) {
        pixels [i] = 0;
        pixelsZ [i] = 1000;
    }
    for (int i = plotList.length - 1; i >= 0; i --) {
        PlotVal p0 = plotList [i];
        if (p0 != null) {
            tr.transform (p0);
            int x = tr.X;
            int y = tr.Y;
            int z = tr.Z;
            if ((x & ~ 511) == 0 && (y & ~ 511) == 0) {
                int pos = (y << 9) | x;
                if (z < pixelsZ [pos]) {
                    pixelsZ [pos] = z;
                    pixels [pos] = (lutNr == ORIGINAL) ? p0.color : getLutColor (p0);
                }
            }
        }
    }
    image = Toolkit.getDefaultToolkit ().createImage (source);
    imageRegion.setImage (image);
}


-----Function Pair=55=-----==

void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) {
        if (value.length > 0) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
        else System.out.println ("doing conditional " + arg + " " + op + " <NO ARGUMENT TOKEN FOUND>");
    }
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


void makeWandCurveFromROI (Roi roi) {
    if (roi.getType () == Roi.POLYGON) {
        PolygonRoi p = (PolygonRoi) roi;
        int [] px = p.getXCoordinates ();
        int [] py = p.getYCoordinates ();
        Rectangle r = p.getBoundingRect ();
        x = new int [p.getNCoordinates ()];
        y = new int [p.getNCoordinates ()];
        for (int i = p.getNCoordinates () - 1; i > - 1; i --) {
            x [i] = r.x + px [i];
            y [i] = r.y + py [i];
        }
    }
    else {
        IJ.write ("Warning! WandCurve can't be made from ROIs other than POLYGON_ROI");
    }
}


-----Function Pair=56=-----==

public void append (String s) {
    if (s.length () == 0) return;
    for (int i = 0; i < count; i ++) {
        if (s.equals (strings [i])) {
            for (int j = i + 1; j < count; j ++) strings [j - 1] = strings [j];
            -- count;
            break;
        }
    }
    if (count == limit) {
        for (int i = 0; i < limit - 1; i ++) strings [i] = strings [i + 1];
        -- count;
    }
    strings [count ++] = s;
    reset ();
}


public void interpolate (int start, int end, double startValue, double endValue) {
    if (end >= getSize ()) end = getSize () - 1;
    args.clear ();
    args.addInt (start);
    args.addInt (end);
    if (isIvec ()) {
        args.addInt ((int) startValue);
        args.addInt ((int) endValue);
    }
    else {
        args.addDouble (startValue);
        args.addDouble (endValue);
    }
    try {
        send (FtsSymbol.get ("interpolate"), args);
    } catch (IOException e) {
        System.err.println ("FtsTableObject: I/O Error sending interpolate Message!");
        e.printStackTrace ();
    }
}


-----Function Pair=57=-----==

void copyUnsupportedNioImageToImageData (NioImageBuffer nioImage, int srcX, int srcY, int dstX, int dstY, int copyWidth, int copyHeight, ImageData iData) {
    if (MasterControl.isDevLoggable (Level.INFO)) {
        MasterControl.getDevLogger ().info ("ImageComponent - Copying Unsupported NioImage, use a different image type");
    }
    assert (iData.getType () == ImageDataType.TYPE_BYTE_BUFFER);
    assert (getImageFormatType () == ImageFormatType.TYPE_BYTE_RGBA);
    int length = copyWidth * copyHeight;
    ByteBuffer srcBuffer = (ByteBuffer) nioImage.getDataBuffer ();
    srcBuffer.rewind ();
    ByteBuffer dstBuffer = iData.getAsByteBuffer ();
    dstBuffer.rewind ();
    for (int i = 0; i < length; i += 4) {
        dstBuffer.put (i, srcBuffer.get (i + 3));
        dstBuffer.put (i + 1, srcBuffer.get (i + 2));
        dstBuffer.put (i + 2, srcBuffer.get (i + 1));
        dstBuffer.put (i + 3, srcBuffer.get (i));
    }
}


protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getBlue ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


-----Function Pair=58=-----==

public boolean runCommand () {
    String cmd;
    String cmd_args [];
    if (macro.next ()) {
        String cmd_arg_string = " ";
        cmd = macro.cmd ();
        cmd_args = macro.args ();
        for (int i = 0; i < cmd_args.length; i ++) {
            cmd_arg_string += cmd_args [i] + " ";
        }
        jdp_console.writeOutput ("\n");
        jdp_console.writeOutput ("Macro line " + macro.currentLine () + ": " + cmd + cmd_arg_string);
    }
    else {
        jdp_console.readCommand (user);
        cmd = jdp_console.cmd ();
        cmd_args = jdp_console.args ();
    }
    if (! cmd.equals ("")) {
        if (cmd.equals ("quit") || cmd.equals ("q")) {
            return true;
        }
        else {
            try {
                return jdpCommand (cmd, cmd_args);
            } catch (Exception e) {
                jdp_console.writeOutput ("ERROR executing jdp command: " + e.getMessage ());
                jdp_console.writeOutput ("email to jvm-coders or try again . . . ");
            }
        }
    }
    return false;
}


private static double [] createSdOfDerivation (double [] diffOut) {
    double [] sds = new double [diffOut.length];
    for (int i = 0; i < diffOut.length; i ++) {
        double [] tmp = new double [SD_CALC_SIZE_NR];
        for (int j = 0; (j < tmp.length); j ++) {
            if (i + j < diffOut.length) {
                tmp [j] = diffOut [i + j];
            }
            else {
                tmp [j] = 0;
            }
        }
        sds [i] = sd (tmp);
    }
    return sds;
}


-----Function Pair=59=-----==

private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandHMMTree (ParallelHMMStateState hmmStateState, String modelName, Map expandedStates) {
    edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = hmmStateState;
    HMMState hmmState = hmmStateState.getHMMState ();
    HMMStateArc [] arcs = hmmState.getSuccessors ();
    for (int i = 0; i < arcs.length; i ++) {
        HMMState nextHmmState = arcs [i].getHMMState ();
        if (nextHmmState == hmmState) {
            attachState (hmmStateState, hmmStateState, logMath.linearToLog (arcs [i].getProbability ()), 0.0, 0.0);
            lastState = hmmStateState;
        }
        else {
            ParallelHMMStateState nextState = null;
            if (expandedStates.containsKey (nextHmmState)) {
                nextState = (ParallelHMMStateState) expandedStates.get (nextHmmState);
            }
            else {
                nextState = new ParallelHMMStateState (hmmStateState.getParent (), modelName, nextHmmState, tokenStackCapacity);
                expandedStates.put (nextHmmState, nextState);
            }
            nextState.setColor (Color.GREEN);
            attachState (hmmStateState, nextState, logMath.linearToLog (arcs [i].getProbability ()), 0.0, 0.0);
            lastState = expandHMMTree (nextState, modelName, expandedStates);
        }
    }
    return lastState;
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=60=-----==

public static boolean geometryIsSegmentOf (Geometry geo1, Geometry geo2) {
    if (geo1.getNumPoints () > geo2.getNumPoints ()) return false;
    int numGeos1 = geo1.getNumGeometries ();
    int numGeos2 = geo2.getNumGeometries ();
    if ((numGeos1 == 1) && (numGeos2 == 1)) {
        Coordinate [] coords1 = geo1.getCoordinates ();
        Coordinate [] coords2 = geo2.getCoordinates ();
        int i1 = 0;
        int i2 = 0;
        while (i2 < coords2.length) {
            if (coords1 [0].equals2D (coords2 [i2])) break;
            i2 ++;
        }
        if (i2 == coords2.length) return false;
        while ((i1 < coords1.length) && (i2 < coords2.length)) {
            if (! coords1 [i1].equals2D (coords2 [i2])) return false;
            i1 ++;
            i2 ++;
        }
        return (i1 == coords1.length);
    }
    else {
        boolean foundMatch = false;
        for (int i = 0; i < numGeos1; i ++) {
            foundMatch = false;
            for (int j = 0; j < numGeos2; j ++) {
                if (geometryIsSegmentOf (geo1.getGeometryN (i), geo2.getGeometryN (j))) {
                    foundMatch = true;
                    break;
                }
            }
            if (! foundMatch) return false;
        }
        return foundMatch;
    }
}


public RobotList < Enemy > sort_decr_Enemy (RobotList < Enemy > list, String field) {
    int length = list.size ();
    Index_value [] enemy_dist = new Index_value [length];
    if (field.equals ("") || field.equals ("location")) {
        Location cur_loc = this.getLocation ();
        for (int i = 0; i < length; i ++) {
            enemy_dist [i] = new Index_value (i, distance (cur_loc, list.get (i).location));
        }
    }
    else if (field.equals ("health")) {
        for (int i = 0; i < length; i ++) {
            enemy_dist [i] = new Index_value (i, list.get (i).health);
        }
    }
    else {
        say ("impossible to sort list - nothing modified");
        return list;
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (enemy_dist [i].value < enemy_dist [i + 1].value) {
                Index_value a = enemy_dist [i];
                enemy_dist [i] = enemy_dist [i + 1];
                enemy_dist [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Enemy > new_enemy_list = new RobotList < Enemy > (Enemy.class);
    for (int i = 0; i < length; i ++) {
        new_enemy_list.addLast (list.get (enemy_dist [i].index));
    }
    return new_enemy_list;
}


-----Function Pair=61=-----==

public void plotData () {
    datapanel.removeAllGraphData ();
    datapanel.setColorSurfaceData (null);
    BasicGraphData rawgraphdata = new BasicGraphData ();
    BasicGraphData fitgraphdata = new BasicGraphData ();
    if (! linearplot) {
        double temp;
        logdata = new double [currentyvalues.length];
        for (int i = 0; i < logdata.length; i ++) {
            temp = currentyvalues [i];
            if (temp <= 0.0) temp = 0.00001;
            logdata [i] = Math.log (temp) / Math.log (10);
        }
        rawgraphdata.addPoint (xphase, logdata);
    }
    else rawgraphdata.addPoint (xphase, currentyvalues);
    rawgraphdata.setDrawPointsOn (true);
    rawgraphdata.setDrawLinesOn (false);
    rawgraphdata.setGraphProperty ("Legend", new String ("raw data"));
    rawgraphdata.setGraphColor (Color.RED);
    datapanel.addGraphData (rawgraphdata);
    datapanel.setAxisNameY (" ");
    datapanel.setLegendButtonVisible (true);
    datapanel.setChooseModeButtonVisible (true);
    datapanel.setGridLinesVisibleX (true);
    datapanel.setGridLinesVisibleY (true);
    datapanel.setName ("BSM " + bsmname);
    if (dataHasBeenFit) {
        center = center + phi0;
        double xmin = center - 5 * sigma;
        double xmax = center + 5 * sigma;
        double points = 100.0;
        double inc = (xmax - xmin) / points;
        int npoints = (new Double (points)).intValue ();
        xfit = new double [npoints];
        yfit = new double [npoints];
        int i = 0;
        double x = xmin;
        while (x <= xmax && i < npoints) {
            xfit [i] = x;
            yfit [i] = amp * Math.exp (- (x - center) * (x - center) / (2.0 * sigma * sigma * .7));
            x += inc;
            i ++;
        }
        if (! linearplot) {
            double temp;
            ylogfit = new double [yfit.length];
            for (int j = 0; j < ylogfit.length; j ++) {
                temp = yfit [j];
                if (temp <= 0.0) temp = 0.00001;
                ylogfit [j] = Math.log (temp) / Math.log (10);
            }
            fitgraphdata.addPoint (xfit, ylogfit);
        }
        else {
            fitgraphdata.addPoint (xfit, yfit);
        }
        fitgraphdata.setDrawPointsOn (false);
        fitgraphdata.setDrawLinesOn (true);
        fitgraphdata.setGraphProperty ("Legend", new String ("fit data"));
        fitgraphdata.setGraphColor (Color.black);
        datapanel.addGraphData (fitgraphdata);
    }
}


public String [] openForEdit (final String lines [], boolean editable) {
    final Shell shell = new Shell (display, SWT.DIALOG_TRIM | SWT.APPLICATION_MODAL);
    GridLayout layout = new GridLayout ();
    layout.numColumns = 3;
    shell.setLayout (layout);
    shell.setText ("Edit Field");
    Label seriesLabel = new Label (shell, SWT.NONE);
    GridData gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 3;
    seriesLabel.setLayoutData (gridData);
    seriesLabel.setText ("Series Name");
    final Text line1 = new Text (shell, SWT.BORDER);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 3;
    line1.setLayoutData (gridData);
    line1.setEditable (editable);
    if (editable == false) {
        shell.setText (lines [1]);
        line1.setVisible (false);
    }
    line1.setText (lines [1]);
    Label episodeLabel = new Label (shell, SWT.NONE);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 3;
    episodeLabel.setLayoutData (gridData);
    episodeLabel.setText ("Episode Number");
    final Text line2 = new Text (shell, SWT.BORDER);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 3;
    line2.setLayoutData (gridData);
    line2.setEditable (true);
    Button commit = new Button (shell, SWT.PUSH);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 1;
    commit.setLayoutData (gridData);
    commit.setText ("Commit Changes");
    commit.addListener (SWT.Selection, new Listener () {
        public void handleEvent (Event e) {
            lines [1] = line1.getText ();
            lines [2] = line2.getText ();
            if (lines [1] == null) {
                shell.close ();
                shell.dispose ();
                return;
            }
            if (lines [2] == null) {
                lines [2] = "Nothing Entered ";
            }
            epiMaker = new EpiMaker ();
            epiMaker.commentWriter (pluginInterface, lines);
            shell.close ();
            shell.dispose ();
            readEpifile ();
        }
    }
    );
    Button cancel = new Button (shell, SWT.PUSH);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 1;
    cancel.setLayoutData (gridData);
    cancel.setText ("Cancel");
    cancel.addListener (SWT.Selection, new Listener () {
        public void handleEvent (Event e) {
            shell.close ();
            shell.dispose ();
        }
    }
    );
    Label spacer = new Label (shell, SWT.PUSH);
    gridData = new GridData (GridData.FILL_HORIZONTAL);
    gridData.horizontalSpan = 1;
    spacer.setLayoutData (gridData);
    spacer.setText ("                                               ");
    line2.addKeyListener (new KeyListener () {
        public void keyPressed (KeyEvent e) {
            int escPressed = 0;
            switch (e.character) {
                case SWT.CR :
                    escPressed = 1;
                    break;
            }
            if (escPressed == 1) {
                lines [1] = line1.getText ();
                lines [2] = line2.getText ();
                if (lines [1] == null) {
                    shell.close ();
                    shell.dispose ();
                    return;
                }
                if (lines [2] == null) {
                    lines [2] = "Nothing Entered ";
                }
                epiMaker = new EpiMaker ();
                epiMaker.commentWriter (pluginInterface, lines);
                shell.close ();
                shell.dispose ();
                readEpifile ();
            }
        } public void keyReleased (KeyEvent e) {
        }
    }
    );
    shell.pack ();
    Monitor primary = display.getPrimaryMonitor ();
    Rectangle bounds = display.getBounds ();
    Rectangle rect = shell.getBounds ();
    int x = bounds.x + (bounds.width - rect.width) / 2;
    int y = bounds.y + (bounds.height - rect.height) / 2;
    shell.setLocation (x, y);
    shell.open ();
    while (! shell.isDisposed ()) {
        if (! display.readAndDispatch ()) display.sleep ();
    }
    return lines;
}


-----Function Pair=62=-----==

public void design () {
    aCoeff = new double [order + 1];
    bCoeff = new double [order + 1];
    double [] newA = new double [order + 1];
    double [] newB = new double [order + 1];
    locatePolesAndZeros ();
    aCoeff [0] = 1.0;
    bCoeff [0] = 1.0;
    for (int i = 1; i <= order; i ++) {
        aCoeff [i] = 0.0;
        bCoeff [i] = 0.0;
    }
    int k = 0;
    int n = order;
    int pairs = n / 2;
    if (isOdd (order)) {
        aCoeff [1] = - z [1];
        bCoeff [1] = - pReal [1];
        k = 1;
    }
    for (int p = 1; p <= pairs; p ++) {
        int m = 2 * p - 1 + k;
        double alpha1 = - (z [m] + z [m + 1]);
        double alpha2 = z [m] * z [m + 1];
        double beta1 = - 2.0 * pReal [m];
        double beta2 = sqr (pReal [m]) + sqr (pImag [m]);
        newA [1] = aCoeff [1] + alpha1 * aCoeff [0];
        newB [1] = bCoeff [1] + beta1 * bCoeff [0];
        for (int i = 2; i <= n; i ++) {
            newA [i] = aCoeff [i] + alpha1 * aCoeff [i - 1] + alpha2 * aCoeff [i - 2];
            newB [i] = bCoeff [i] + beta1 * bCoeff [i - 1] + beta2 * bCoeff [i - 2];
        }
        for (int i = 1; i <= n; i ++) {
            aCoeff [i] = newA [i];
            bCoeff [i] = newB [i];
        }
    }
}


private void calcCoefficients () {
    a0 = new double [x.length - 1];
    a1 = new double [x.length - 1];
    a2 = new double [x.length - 1];
    a3 = new double [x.length - 1];
    b = new double [x.length];
    if (shape == LINEAR) {
        for (int i = 0; i < a0.length; i ++) {
            double dx = x [i + 1] - x [i];
            if (dx == 0.0) continue;
            a1 [i] = (y [i + 1] - y [i]) / dx;
            a0 [i] = y [i] - a1 [i] * x [i];
            a1 [i] *= 0.5;
            b [i + 1] = b [i] + x [i + 1] * (a0 [i] + x [i + 1] * a1 [i]) - x [i] * (a0 [i] + x [i] * a1 [i]);
        }
        for (int i = 1; i < b.length - 1; i ++) b [i] -= x [i] * (a0 [i] + x [i] * a1 [i]);
        return;
    }
    double m [] [] = new double [4] [4], a [] = new double [4], deriv [] = new double [x.length];
    for (int i = 1; i < x.length - 1; i ++) if (x [i - 1] != x [i + 1]) deriv [i] = (y [i + 1] - y [i - 1]) / (x [i + 1] - x [i]);
    if (repeat) deriv [0] = deriv [x.length - 1] = (y [1] - y [y.length - 2]) / (1.0 + x [1] - x [x.length - 2]);
    for (int i = 0; i < a0.length; i ++) {
        m [0] [0] = 0.0;
        m [0] [1] = 1.0;
        m [0] [2] = 2.0 * x [i];
        m [0] [3] = 3.0 * x [i] * x [i];
        a [0] = deriv [i];
        m [1] [0] = 1.0;
        m [1] [1] = x [i];
        m [1] [2] = x [i] * x [i];
        m [1] [3] = x [i] * x [i] * x [i];
        a [1] = y [i];
        m [2] [0] = 1.0;
        m [2] [1] = x [i + 1];
        m [2] [2] = x [i + 1] * x [i + 1];
        m [2] [3] = x [i + 1] * x [i + 1] * x [i + 1];
        a [2] = y [i + 1];
        m [3] [0] = 0.0;
        m [3] [1] = 1.0;
        m [3] [2] = 2.0 * x [i + 1];
        m [3] [3] = 3.0 * x [i + 1] * x [i + 1];
        a [3] = deriv [i + 1];
        SVD.solve (m, a);
        a0 [i] = a [0];
        a1 [i] = 0.5 * a [1];
        a2 [i] = a [2] / 3.0;
        a3 [i] = 0.25 * a [3];
        b [i + 1] = b [i] + x [i + 1] * (a0 [i] + x [i + 1] * (a1 [i] + x [i + 1] * (a2 [i] + x [i + 1] * a3 [i]))) - x [i] * (a0 [i] + x [i] * (a1 [i] + x [i] * (a2 [i] + x [i] * a3 [i])));
    }
    for (int i = 1; i < b.length - 1; i ++) b [i] -= x [i] * (a0 [i] + x [i] * (a1 [i] + x [i] * (a2 [i] + x [i] * a3 [i])));
}


-----Function Pair=63=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


public void selectionChanged (SelectionChangedEvent e) {
    if (e.isSelected ()) {
        for (int i = 0; i < cbTeamsArray.length; i ++) {
            if (cbTeamsArray [i] == owner) {
                matrix [i] [TANKTEAM_INDEX] = "      " + owner.getSelectedValue ();
                PlayerTeam pt;
                String team1Str = GameLanguage.getString ("br.furb.inf.tcc.tankcoders.game.PlayerTeam.TEAM_1");
                if (owner.getSelectedValue ().equals (team1Str)) {
                    pt = PlayerTeam.TEAM_1;
                }
                else {
                    pt = PlayerTeam.TEAM_2;
                }
                PlayerTank tank = localPlayer.getTankByName (matrix [i] [TANKNAME_INDEX]);
                if (tank.getTeam ().getTeamEnum () != pt) {
                    tank.setTeam (getTeamObjByEnum (pt));
                    ChangeTeam ct = new ChangeTeam ();
                    ct.setPlayerId (localPlayer.getId ());
                    ct.setTankName (matrix [i] [TANKNAME_INDEX]);
                    ct.setTeam (pt);
                    gameClient.sendToServer (ct);
                }
                break;
            }
        }
    }
}


-----Function Pair=64=-----==

void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


private void cosft (float z [], int n, int isign) {
    double theta, wi = 0.0, wpi, wpr, wr = 1.0, wtemp;
    float a [], sum, y1, y2;
    int j, n2;
    a = new float [n + 2];
    for (j = 1; j <= n + 1; j ++) {
        a [j] = z [j - 1];
    }
    theta = PI / n;
    wtemp = Math.sin (0.5 * theta);
    wpr = - 2.0 * wtemp * wtemp;
    wpi = Math.sin (theta);
    sum = (float) (0.5 * (a [1] - a [n + 1]));
    a [1] = (float) (0.5 * (a [1] + a [n + 1]));
    n2 = n + 2;
    for (j = 2; j <= (n>> 1); j ++) {
        wr = (wtemp = wr) * wpr - wi * wpi + wr;
        wi = wi * wpr + wtemp * wpi + wi;
        y1 = (float) (0.5 * (a [j] + a [n2 - j]));
        y2 = (a [j] - a [n2 - j]);
        a [j] = (float) (y1 - wi * y2);
        a [n2 - j] = (float) (y1 + wi * y2);
        sum += wr * y2;
    }
    realft (a, n, 1);
    a [n + 1] = a [2];
    a [2] = sum;
    for (j = 4; j <= n; j += 2) {
        sum += a [j];
        a [j] = sum;
    }
    if (isign == 1) {
        for (j = 1; j <= n + 1; j ++) {
            z [j - 1] = a [j];
        }
    }
    else if (isign == - 1) {
        for (j = 1; j <= n + 1; j ++) {
            z [j - 1] = (float) (2.0 * a [j] / n);
        }
    }
    a = null;
}


-----Function Pair=65=-----==

public String downloadFile (String alias, String remoteDirectory, String remoteFile, File file) throws Exception {
    try {
        FTPClient client = (FTPClient) connections.get (alias);
        client.cwd (remoteDirectory);
        InputStream iStream = client.retrieveFileStream (remoteFile);
        OutputStream oStream = new FileOutputStream (file);
        Util.copyStream (iStream, oStream);
        iStream.close ();
        oStream.close ();
        client.completePendingCommand ();
    } catch (Exception e) {
        String [] stack = ExceptionHelper.getStackTrace (e);
        return StringArrayHelper.arrayToString (stack, "<br/>");
    }
    return "";
}


public void advancedSearch (final ArrayList < String > catsToSearch) {
    ArrayList < Thread > threadList = new ArrayList < Thread > ();
    class advSearchElem extends Thread {
        TreeNode toSearch;
        protected advSearchElem (TreeNode node) {
            super ();
            this.toSearch = node;
        } protected TreeNode getToSearch () {
            return this.toSearch;
        } public void run () {
            parseHTMLPage (getToSearch (), false);
        }
    }
    for (String cat : catsToSearch) {
        for (TreeNode searchNode : (ArrayList < TreeNode >) categories.get (cat)) {
            advSearchElem e = new advSearchElem (searchNode);
            e.start ();
            threadList.add (e);
        }
    }
    try {
        for (Thread t : threadList) {
            t.join ();
        }
    } catch (InterruptedException ie) {
        ie.printStackTrace ();
    }
    checkLinks ();
    System.out.println ("Check finished: " + failCnt);
    if (failCnt > 0) {
        for (TreeNode node : failedList) {
            System.out.println ("failed links is: " + node.getURL ());
        }
    }
}


-----Function Pair=66=-----==

public static QcSessionParameters convertToSessionParameters (final TaskRepository pRepository, final boolean mustHaveCredentials) throws QcException {
    final QcSessionParameters qcSessionParameters = new QcSessionParameters ();
    final String repositoryUrl = pRepository.getRepositoryUrl ();
    qcSessionParameters.setUrl (QcRepositoryConnector.extractRepositoryURL (repositoryUrl));
    String domain = pRepository.getProperty (IQcConstants.DOMAIN_NAME);
    final boolean urlNotBlank = StringUtils.isNotBlank (repositoryUrl);
    if (StringUtils.isBlank (domain) && urlNotBlank) {
        domain = QcRepositoryConnector.extractDomain (repositoryUrl);
    }
    qcSessionParameters.setDomain (domain);
    String project = pRepository.getProperty (IQcConstants.PROJECT_NAME);
    if (StringUtils.isBlank (project) && urlNotBlank) {
        project = QcRepositoryConnector.extractProject (repositoryUrl);
    }
    qcSessionParameters.setProject (project);
    final AuthenticationCredentials credentials = pRepository.getCredentials (AuthenticationType.REPOSITORY);
    if (credentials != null) {
        qcSessionParameters.setUserName (credentials.getUserName ());
        qcSessionParameters.setPassWord (credentials.getPassword ());
    }
    else {
        if (mustHaveCredentials) throw new QcException (Messages.QcRepositoryConfiguration_Error_Credentials);
    }
    return qcSessionParameters;
}


private void sendBufferToClient (final ByteBuffer buf, final String expectedMsgString, final Delivery delivery) throws Exception {
    final String name = "dummy";
    DummyClient client = createDummyClient (name);
    try {
        client.connect (serverNode.getAppPort ());
        assertTrue (client.login ());
        final int numMessages = 3;
        for (int i = 0; i < numMessages; i ++) {
            txnScheduler.runTask (new TestAbstractKernelRunnable () {
                public void run () {
                    ClientSession session = (ClientSession) AppContext.getDataManager ().getBinding (name);
                    System.err.println ("Sending messages");
                    session.send (buf, delivery);
                }
            }
            , taskOwner);
        }
        System.err.println ("waiting for client to receive messages");
        client.waitForClientToReceiveExpectedMessages (numMessages);
        for (byte [] message : client.clientReceivedMessages) {
            if (message.length == 0) {
                fail ("message buffer emtpy");
            }
            String msgString = (new MessageBuffer (message)).getString ();
            if (! msgString.equals (expectedMsgString)) {
                fail ("expected: " + expectedMsgString + ", received: " + msgString);
            }
            else {
                System.err.println ("received expected message: " + msgString);
            }
        }
    } finally {
        client.disconnect ();
    }
}


-----Function Pair=67=-----=1=

public static void main (String [] args) {
    Document document = new Document (PageSize.A4.rotate ());
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapterX/gis.pdf"));
        document.open ();
        Image large = Image.getInstance ("resources/in_action/chapterX/foobar.png");
        Image small = Image.getInstance ("resources/in_action/chapterX/foobar_thumb.png");
        float [] widths = {large.getWidth (), small.getWidth () * 2};
        PdfPTable table = new PdfPTable (widths);
        PdfPCell cell = new PdfPCell (large, true);
        cell.setBorderWidth (3);
        cell.setBorderColor (new GrayColor (0.7f));
        cell.setUseBorderPadding (true);
        table.addCell (cell);
        PdfPTable innertable = new PdfPTable (1);
        cell = new PdfPCell (small, true);
        cell.setBorder (PdfPCell.BOTTOM);
        cell.setBorderWidth (3);
        cell.setBorderColor (new GrayColor (0.7f));
        cell.setUseBorderPadding (true);
        innertable.addCell (cell);
        PdfPTable legendtable = new PdfPTable (1);
        legendtable.getDefaultCell ().setBorder (PdfPCell.NO_BORDER);
        legendtable.addCell ("Legend");
        legendtable.addCell ("test1");
        legendtable.addCell ("test2");
        legendtable.addCell ("test3");
        legendtable.addCell ("test4");
        legendtable.addCell ("test5");
        legendtable.addCell ("test6");
        legendtable.addCell ("test7");
        cell = new PdfPCell (legendtable);
        cell.setBorder (PdfPCell.BOTTOM);
        cell.setBorderWidth (3);
        cell.setBorderColor (new GrayColor (0.7f));
        cell.setUseBorderPadding (true);
        innertable.addCell (cell);
        cell = new PdfPCell ();
        cell.setBorder (PdfPCell.NO_BORDER);
        cell.setBackgroundColor (new GrayColor (0.7f));
        innertable.addCell (cell);
        cell = new PdfPCell (innertable);
        cell.setBorderWidth (3);
        cell.setBorderColor (new GrayColor (0.7f));
        cell.setUseBorderPadding (true);
        cell.setCellEvent (new GisExample ());
        table.addCell (cell);
        document.add (table);
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (DocumentException e) {
        e.printStackTrace ();
    }
    document.close ();
}


public static void main (String [] args) {
    System.out.println ("Glossary");
    Document document = new Document ();
    try {
        PdfWriter writer = PdfWriter.getInstance (document, new FileOutputStream ("Glossary.pdf"));
        Glossary generic = new Glossary ();
        writer.setPageEvent (generic);
        document.open ();
        String [] f = new String [14];
        f [0] = "Courier";
        f [1] = "Courier Bold";
        f [2] = "Courier Italic";
        f [3] = "Courier Bold Italic";
        f [4] = "Helvetica";
        f [5] = "Helvetica bold";
        f [6] = "Helvetica italic";
        f [7] = "Helvetica bold italic";
        f [8] = "Times New Roman";
        f [9] = "Times New Roman bold";
        f [10] = "Times New Roman italic";
        f [11] = "Times New Roman bold italic";
        f [12] = "Symbol";
        f [13] = "Zapfdingbats";
        Font [] fonts = new Font [14];
        fonts [0] = FontFactory.getFont (FontFactory.COURIER, 12, Font.NORMAL);
        fonts [1] = FontFactory.getFont (FontFactory.COURIER, 12, Font.BOLD);
        fonts [2] = FontFactory.getFont (FontFactory.COURIER, 12, Font.ITALIC);
        fonts [3] = FontFactory.getFont (FontFactory.COURIER, 12, Font.BOLD | Font.ITALIC);
        fonts [4] = FontFactory.getFont (FontFactory.HELVETICA, 12, Font.NORMAL);
        fonts [5] = FontFactory.getFont (FontFactory.HELVETICA, 12, Font.BOLD);
        fonts [6] = FontFactory.getFont (FontFactory.HELVETICA, 12, Font.ITALIC);
        fonts [7] = FontFactory.getFont (FontFactory.HELVETICA, 12, Font.BOLD | Font.ITALIC);
        fonts [8] = FontFactory.getFont (FontFactory.TIMES_ROMAN, 12, Font.NORMAL);
        fonts [9] = FontFactory.getFont (FontFactory.TIMES_ROMAN, 12, Font.BOLD);
        fonts [10] = FontFactory.getFont (FontFactory.TIMES_ROMAN, 12, Font.ITALIC);
        fonts [11] = FontFactory.getFont (FontFactory.TIMES_ROMAN, 12, Font.BOLD | Font.ITALIC);
        fonts [12] = FontFactory.getFont (FontFactory.SYMBOL, 12, Font.NORMAL);
        fonts [13] = FontFactory.getFont (FontFactory.ZAPFDINGBATS, 12, Font.NORMAL);
        for (int i = 0; i < 14; i ++) {
            Chunk chunk = new Chunk ("This is font ", fonts [i]);
            Paragraph p = new Paragraph (chunk);
            p.add (new Phrase (new Chunk (f [i], fonts [i]).setGenericTag (f [i])));
            document.add (p);
            if (i % 4 == 3) {
                document.newPage ();
            }
        }
        document.newPage ();
        for (Iterator i = generic.glossary.keySet ().iterator (); i.hasNext ();) {
            String key = (String) i.next ();
            int page = ((Integer) generic.glossary.get (key)).intValue ();
            Paragraph g = new Paragraph (key);
            g.add (" : page ");
            g.add (String.valueOf (page));
            document.add (g);
        }
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


-----Function Pair=68=-----==

public void keyPressed (KeyEvent evt_) {
    int priority_ = Thread.currentThread ().getPriority ();
    if (priority_ != Thread.MAX_PRIORITY) {
        Thread.currentThread ().setPriority (Thread.MAX_PRIORITY);
    }
    switch (evt_.getKeyCode ()) {
        case KeyEvent.VK_UP :
            String cmd_ = getPartialCommand ();
            if (partialCmd == null) partialCmd = cmd_;
            if (evt_.isControlDown ()) partialCmd = "";
            cmd_ = partialCmd.length () == 0 ? getHistory (- 1) : getHistoryUp (partialCmd);
            if (cmd_ != null) setCommand (cmd_, cmd_.length ());
            evt_.consume ();
            break;
        case KeyEvent.VK_DOWN :
            cmd_ = getPartialCommand ();
            if (partialCmd == null) partialCmd = cmd_;
            if (evt_.isControlDown ()) partialCmd = "";
            cmd_ = partialCmd.length () == 0 ? getHistory (+ 1) : getHistoryDown (partialCmd);
            if (cmd_ != null) setCommand (cmd_, cmd_.length ());
            evt_.consume ();
            break;
        case KeyEvent.VK_ENTER :
            partialCmd = null;
            evt_.consume ();
            cmd_ = getCommand ();
            if (evt_.isControlDown ()) {
                addCmdToHistory (cmd_);
                setCommand ("", 0);
                write (cmd_ + "\n");
                diagnoze (cmd_);
                return;
            }
            synchronized (Dterm.this) {
                if (evalCommand (cmd_, true)) {
                    addCmdToHistory (cmd_);
                    setCommand ("", 0);
                }
                else RUVOutputManager.SYSTEM_OUT.print (new String (new byte [] {7}));
            }
            break;
        case KeyEvent.VK_TAB :
            evt_.consume ();
            cmd_ = getCommand ();
            if (cmd_.trim ().length () > 0) autocomplete (cmd_, tf.getCaretPosition ());
            else setCommand (cmd_ + "    ", cmd_.length () + 4);
            break;
        case KeyEvent.VK_LEFT :
            if (tf.getCaretPosition () > 0) tf.setCaretPosition (tf.getCaretPosition () - 1);
            evt_.consume ();
            break;
        case KeyEvent.VK_RIGHT :
            if (tf.getCaretPosition () < tf.getText ().length ()) tf.setCaretPosition (tf.getCaretPosition () + 1);
            evt_.consume ();
            break;
    }
}


public void actionPerformed (ActionEvent e) {
    if (stop.getText ().equals ("Pause")) {
        stop.setText ("Start");
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            backup [r] [c] = b [r] [c].getText ();
            b [r] [c].setText (" ");
        }
        canUpdateTimer = false;
    }
    else {
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            b [r] [c].setText (backup [r] [c]);
        }
        stop.setText ("Pause");
        canUpdateTimer = true;
    }
}


-----Function Pair=69=-----==

protected boolean run () {
    try {
        for (IAction action : rootMediaDir.getActions ()) {
            action.setTestMode (getController ().isTestRun ());
        }
        doUpdateCheck ();
        MediaDirConfig dirConfig = rootMediaDir.getMediaDirConfig ();
        for (File mediaFile : files) {
            if (dirConfig.getMode () == Mode.FILM) {
                IFilm f = fromStore.getFilm (rootMediaDir, mediaFile);
                if (f == null) {
                    fatal (MessageFormat.format (Messages.getString ("CLICopyStoreToStore.UNABLE_FIND_FILM"), mediaFile));
                    return false;
                }
                Integer part = getFilmPart (mediaFile, f);
                toStore.cacheFilm (dirConfig.getMediaDir (), mediaFile, f, part);
            }
            else {
                IEpisode episode = fromStore.getEpisode (rootMediaDir, mediaFile);
                toStore.cacheEpisode (rootMediaDir.getMediaDirConfig ().getMediaDir (), mediaFile, episode);
            }
            log.info (MessageFormat.format (Messages.getString ("CLICopyStoreToStore.STORE_UPDATED"), toStore.getClass ().getName (), mediaFile));
        }
        return true;
    } catch (Exception e) {
        log.error (e.getMessage (), e);
    }
    return false;
}


public void addMapAt (Map map, int i) throws IOException {
    FileResource resource = new FileResource (map.getName (), map.getName (), map.getMapListHome ());
    Translate translate_name = new Translate (map.getName ());
    if (i >= map_files.size ()) {
        map_files.addElement (resource);
        translate_name_vec.addElement (translate_name);
    }
    else {
        map_files.insertElementAt (resource, i);
        translate_name_vec.insertElementAt (translate_name, i);
    }
    if (map_cache != null) {
        map.setStatus (Map.NEW);
        map_cache.put (map.getName (), map);
    }
    if (getSelectedMapIndex () >= i) {
        selected_map_index ++;
    }
    modified = true;
}


-----Function Pair=70=-----==

public static void copyDirectory (File srcDir, File destDir, FileFilter filter, boolean preserveFileDate) throws IOException {
    if (srcDir == null) {
        throw new NullPointerException ("Source must not be null");
    }
    if (destDir == null) {
        throw new NullPointerException ("Destination must not be null");
    }
    if (srcDir.exists () == false) {
        throw new FileNotFoundException ("Source '" + srcDir + "' does not exist");
    }
    if (srcDir.isDirectory () == false) {
        throw new IOException ("Source '" + srcDir + "' exists but is not a directory");
    }
    if (srcDir.getCanonicalPath ().equals (destDir.getCanonicalPath ())) {
        throw new IOException ("Source '" + srcDir + "' and destination '" + destDir + "' are the same");
    }
    List < String > exclusionList = null;
    if (destDir.getCanonicalPath ().startsWith (srcDir.getCanonicalPath ())) {
        File [] srcFiles = filter == null ? srcDir.listFiles () : srcDir.listFiles (filter);
        if (srcFiles != null && srcFiles.length > 0) {
            exclusionList = new ArrayList < String > (srcFiles.length);
            for (int i = 0; i < srcFiles.length; i ++) {
                File copiedFile = new File (destDir, srcFiles [i].getName ());
                exclusionList.add (copiedFile.getCanonicalPath ());
            }
        }
    }
    doCopyDirectory (srcDir, destDir, filter, preserveFileDate, exclusionList);
}


public static void generateKeys2 (int keySize, Path publicKey, Path privateKey) throws NoSuchAlgorithmException, IOException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance ("RSA");
    keyGen.initialize (keySize);
    KeyPair keyPair = keyGen.generateKeyPair ();
    PublicKey pubkey = keyPair.getPublic ();
    PrivateKey privkey = keyPair.getPrivate ();
    Files.createDirectories (publicKey.getParent ());
    Files.createFile (publicKey);
    Files.createDirectories (privateKey.getParent ());
    Files.createFile (privateKey);
    ObjectOutputStream oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (publicKey.toFile ())));
    oout.writeObject (pubkey);
    oout.close ();
    oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (privateKey.toFile ())));
    oout.writeObject (privkey);
    oout.close ();
}


-----Function Pair=71=-----==

public void executeApplicationMainClass (String [] args) {
    Field sysPathsField = null;
    Object oldFieldValue = null;
    boolean accessible = false;
    try {
        for (File lib : libraries) {
            addToClasspath (lib);
        }
        String s = System.getProperty ("java.library.path");
        if (s != null) {
            s += File.pathSeparatorChar + tmpDir.getCanonicalPath () + LIB_DIR_3RD_PARTY + File.pathSeparatorChar + tmpDir.getCanonicalPath () + LIB_DIR;
        }
        else {
            s = tmpDir.getCanonicalPath () + LIB_DIR_3RD_PARTY + File.pathSeparatorChar + tmpDir.getCanonicalPath () + LIB_DIR;
        }
        s += File.pathSeparator + tmpDir.getCanonicalPath () + RESOURCES;
        sysPathsField = getSysPathsField ();
        if (sysPathsField != null) {
            accessible = sysPathsField.isAccessible ();
            if (! accessible) {
                sysPathsField.setAccessible (true);
            }
            oldFieldValue = sysPathsField.get (ClassLoader.class);
            sysPathsField.set (ClassLoader.class, null);
        }
        System.setProperty ("java.library.path", s);
        Class clazz = Class.forName (appMainClass);
        Method m = clazz.getMethod ("main", new Class [] {args.getClass ()});
        m.invoke (null, new Object [] {args});
    } catch (ClassNotFoundException e) {
        throw new RuntimeException ("Can't load the main class", e);
    } catch (NoSuchMethodException e) {
        throw new RuntimeException ("Can't find the main() method of the main class", e);
    } catch (InvocationTargetException e) {
        throw new RuntimeException (e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException (e);
    } catch (IOException e) {
        throw new RuntimeException (e);
    } finally {
        if (sysPathsField != null) {
            try {
                sysPathsField.set (ClassLoader.class, oldFieldValue);
            } catch (IllegalAccessException e) {
            }
            sysPathsField.setAccessible (accessible);
        }
    }
}


private void verificacionFiles (File _fileWorkspace, File _fileWebServer, String carpeta) {
    ArrayList < String > _archivosWorkspace = new ArrayList < String > ();
    for (int indice = 0; indice < _fileWorkspace.listFiles ().length; indice ++) {
        _archivosWorkspace.add (_fileWorkspace.listFiles () [indice].getName ());
    }
    ArrayList < String > _archivosWebServer = new ArrayList < String > ();
    for (int indice = 0; indice < _fileWebServer.listFiles ().length; indice ++) {
        _archivosWebServer.add (_fileWebServer.listFiles () [indice].getName ());
    }
    for (String tempWorkspace : _archivosWorkspace) {
        for (String tempWebServer : _archivosWebServer) {
            if (tempWorkspace.equals (tempWebServer)) {
                _archivosWebServer.remove (tempWebServer);
                break;
            }
        }
    }
    for (String tempWebServer : _archivosWebServer) {
        File file = new File (_fileWebServer.getAbsolutePath () + Constant.SEPARATOR + tempWebServer);
        deleteEnd (file);
    }
}


-----Function Pair=72=-----==

public static List < String > getPlatformList () throws SevenZipNativeInitializationException {
    if (availablePlatforms != null) {
        return availablePlatforms;
    }
    InputStream propertiesInputStream = SevenZip.class.getResourceAsStream (SEVENZIPJBINDING_PLATFORMS_PROPRETIES_FILENAME);
    if (propertiesInputStream == null) {
        throw new SevenZipNativeInitializationException ("Can not find 7-Zip-JBinding platform property file " + SEVENZIPJBINDING_PLATFORMS_PROPRETIES_FILENAME + ". Make sure the 'sevenzipjbinding-<Platform>.jar' file is " + "in the class path or consider initializing SevenZipJBinding manualy using one of " + "the offered initialization methods: 'net.sf.sevenzipjbinding.SevenZip.init*()'");
    }
    Properties properties = new Properties ();
    try {
        properties.load (propertiesInputStream);
    } catch (IOException e) {
        throwInitException (e, "Error loading existing property file " + SEVENZIPJBINDING_PLATFORMS_PROPRETIES_FILENAME);
    }
    List < String > platformList = new ArrayList < String > ();
    for (int i = 1;; i ++) {
        String platform = properties.getProperty ("platform." + i);
        if (platform == null) {
            break;
        }
        platformList.add (platform);
    }
    return availablePlatforms = platformList;
}


public static boolean preloadCategory (String category) {
    boolean success = true;
    PluginInfo pi [] = findAllMatchingCategory (category);
    if (pi != null) {
        for (int i = 0; i < pi.length; i ++) {
            JarLoader jl = new JarLoader (pi [i].jarname);
            try {
                if (pi [i].theclass == null) {
                    pi [i].theclass = jl.loadClass (pi [i].classname);
                }
            } catch (Exception e) {
                Log.warning ("Could not preload class \"" + pi [i].classname + "\". Reason: " + e);
                success = false;
            }
        }
    }
    return success;
}


-----Function Pair=73=-----==

public static void copyFile (File source, File target) throws Exception {
    if (source.isDirectory ()) {
        if (! target.isDirectory ()) {
            target.mkdirs ();
        }
        String [] children = source.list ();
        for (int i = 0; i < children.length; i ++) {
            copyFile (new File (source, children [i]), new File (target, children [i]));
        }
    }
    else {
        FileChannel inChannel = new FileInputStream (source).getChannel ();
        FileChannel outChannel = new FileOutputStream (target).getChannel ();
        try {
            int maxCount = (64 * 1024 * 1024) - (32 * 1024);
            long size = inChannel.size ();
            long position = 0;
            while (position < size) {
                position += inChannel.transferTo (position, maxCount, outChannel);
            }
        } catch (IOException e) {
            errorLog ("{Malgn.copyFile} " + e.getMessage ());
            throw e;
        } finally {
            if (inChannel != null) inChannel.close ();
            if (outChannel != null) outChannel.close ();
        }
    }
}


public void layoutContainer (Container container) {
    Component [] children = container.getComponents ();
    if (children != null && children.length > 0) {
        int numChildren = children.length;
        Dimension [] sizes = new Dimension [numChildren];
        Insets insets = container.getInsets ();
        int yLocation = insets.top + topMargin;
        int maxWidth = 0;
        for (int counter = 0; counter < numChildren; counter ++) {
            sizes [counter] = children [counter].getPreferredSize ();
            maxWidth = Math.max (maxWidth, sizes [counter].width);
        }
        int xLocation, xOffset;
        if (container.getComponentOrientation ().isLeftToRight ()) {
            xLocation = container.getSize ().width - insets.left - maxWidth;
            xOffset = hGap + maxWidth;
        }
        else {
            xLocation = insets.left;
            xOffset = - (hGap + maxWidth);
        }
        for (int counter = numChildren - 1; counter >= 0; counter --) {
            children [counter].setBounds (xLocation, yLocation, maxWidth, sizes [counter].height);
            xLocation -= xOffset;
        }
    }
}


-----Function Pair=74=-----==

void saveSettings (File file) throws IOException {
    settingsFile = file;
    if (settingsFile == null) {
        setTitle ("ProCamTracker");
    }
    else {
        setTitle (settingsFile.getName () + " - ProCamTracker");
    }
    XMLEncoder encoder = new XMLEncoder (new BufferedOutputStream (new FileOutputStream (settingsFile)));
    encoder.writeObject (cameraSettings);
    encoder.writeObject (projectorSettings);
    encoder.writeObject (objectFinderSettings);
    encoder.writeObject (markerDetectorSettings);
    encoder.writeObject (alignerSettings);
    encoder.writeObject (handMouseSettings);
    encoder.writeObject (virtualBallSettings);
    encoder.writeObject (realityAugmentorSettings);
    encoder.writeObject (trackingSettings);
    encoder.close ();
}


public void actionPerformed (final ActionEvent e) {
    final Thread runner = new Thread () {
        @Override
        public void run () {
            Runnable runnable = new Runnable () {
                public void run () {
                    if ((JIFileTable.this.catagorysFrame != null) && JIFileTable.this.catagorysFrame.isDisplayable ()) {
                        JIFileTable.this.catagorysFrame.setTitle ();
                        JIFileTable.this.catagorysFrame.requestFocus ();
                        JIFileTable.this.catagorysFrame.toFront ();
                    }
                    else {
                        JIFileTable.this.catagorysFrame = new JICatTreeFrame ();
                    }
                }
            }
            ;
            SwingUtilities.invokeLater (runnable);
        }
    }
    ;
    runner.start ();
}


-----Function Pair=75=-----==

public static void streamCopyFile (File srcFile, File destFile) {
    try {
        FileInputStream fi = new FileInputStream (srcFile);
        FileOutputStream fo = new FileOutputStream (destFile);
        byte [] buf = new byte [1024];
        int readLength = 0;
        while (readLength != - 1) {
            readLength = fi.read (buf);
            if (readLength != - 1) {
                fo.write (buf, 0, readLength);
            }
        }
        fo.close ();
        fi.close ();
    } catch (Exception e) {
    }
}


static void processPreview () {
    if (! preview.isShowing ()) return;
    PreviewFrame.reset ();
    final List < Future < WorkContainer > > futures = new ArrayList < Future < WorkContainer > > (OptionsObject.getOrderedDithers ().length + OptionsObject.getErrorDithers ().length);
    try {
        if (inFiles == null) {
            return;
        }
        if (inFiles.length > 0) {
            File f = inFiles [0];
            if (f.getPath ().endsWith (".avi") || f.getPath ().endsWith (".mov")) {
                setStatusMessage ("Preview only works for images - a video was selected.");
                return;
            }
            disableInput ();
            BufferedImage image = ImageIO.read (f);
            for (Object dither : OptionsObject.getOrderedDithers ()) {
                Future < WorkContainer > future = WorkDispatcher.submitPreviewWork (image, dither);
                futures.add (future);
            }
            for (Object dither : OptionsObject.getErrorDithers ()) {
                Future < WorkContainer > future = WorkDispatcher.submitPreviewWork (image, dither);
                futures.add (future);
            }
        }
        startPreviewWaiter (futures);
    } catch (Exception e) {
        setStatusMessage (e.getMessage ());
    }
}


-----Function Pair=76=-----==

public void actionPerformed (final ActionEvent e) {
    final Thread runner = new Thread () {
        @Override
        public void run () {
            Runnable runnable = new Runnable () {
                public void run () {
                    if ((JIFileTable.this.catagorysFrame != null) && JIFileTable.this.catagorysFrame.isDisplayable ()) {
                        JIFileTable.this.catagorysFrame.setTitle ();
                        JIFileTable.this.catagorysFrame.requestFocus ();
                        JIFileTable.this.catagorysFrame.toFront ();
                    }
                    else {
                        JIFileTable.this.catagorysFrame = new JICatTreeFrame ();
                    }
                }
            }
            ;
            SwingUtilities.invokeLater (runnable);
        }
    }
    ;
    runner.start ();
}


public boolean receiveItems (String [] uris, int move_mode) {
    try {
        if (connectAndLogin (uri) < 0) {
            notify (s (R.string.ftp_nologin), Commander.OPERATION_FAILED);
            return false;
        }
        if (uris == null || uris.length == 0) {
            notify (s (R.string.copy_err), Commander.OPERATION_FAILED);
            return false;
        }
        File [] list = Utils.getListOfFiles (uris);
        if (list == null) {
            notify ("Something wrong with the files", Commander.OPERATION_FAILED);
            return false;
        }
        notify (Commander.OPERATION_STARTED);
        worker = new CopyToEngine (workerHandler, list, move_mode);
        worker.start ();
        return true;
    } catch (Exception e) {
        notify ("Exception: " + e.getMessage (), Commander.OPERATION_FAILED);
    }
    return false;
}


-----Function Pair=77=-----==

public void run () {
    SimpleDateFormat df = new SimpleDateFormat ("yyyy:MM:dd HH:mm:ss");
    dialog.printlnAction (I18N.translate ("Reading EXIF data"));
    logger.info ("exif data loading ...");
    String errFiles = "";
    String errMsg = "";
    File file = null;
    int count = 0;
    try {
        for (Object obj : files) {
            file = (File) obj;
            try {
                dialog.printItem (I18N.translate ("Image") + " " + file.getName ());
                Date date = JPEG.getEXIFDate (JPEG.getEXIF (file));
                if (date != null) {
                    Calendar cal = I18N.getCalendar (date);
                    cal.add (Calendar.DAY_OF_YEAR, (Integer) shiftDaySpinner.getValue ());
                    cal.add (Calendar.HOUR, (Integer) shiftHourSpinner.getValue ());
                    cal.add (Calendar.MINUTE, (Integer) shiftMinSpinner.getValue ());
                    cal.add (Calendar.SECOND, (Integer) shiftSecSpinner.getValue ());
                    JPEG.transformEXIF (file, Exif.DATETIMEORIGINAL, df.format (cal.getTime ()));
                    dialog.printlnItemOK ();
                }
                else {
                    dialog.printlnError (I18N.translate ("Photo hasn't EXIF date."));
                    errMsg += I18N.translate ("Photo hasn't EXIF date.") + Config.LS;
                    errFiles += ", " + file.getName ();
                    dialog.printlnItemBAD ();
                }
                count ++;
                dialog.setPercent ((count * 100) / files.length);
            } catch (Exception exc) {
                dialog.printlnItemBAD ();
                if (exc.getMessage () != null) {
                    dialog.printlnError (exc.getMessage ());
                }
                errMsg += exc.getMessage () + Config.LS;
                errFiles += ", " + file.getName ();
            }
            if (stop) {
                throw new HException (I18N.translate ("Operation was canceled."));
            }
        }
        timeChooser.setDate (JPEG.getEXIFDate (JPEG.getEXIF (file)));
    } catch (HException exc) {
        dialog.printlnError (exc.getMessage ());
        new HMessageDialog (window.changer.topFrame, HMessageDialog.MESSAGE_WARNING, exc.getMessage ());
    } finally {
        dialog.close ();
        if (! errFiles.equals ("")) {
            errFiles = errFiles.substring (2);
            new HMessageDialog (window.changer.topFrame, HMessageDialog.MESSAGE_ERROR, I18N.translate ("Time was not shifted in these files.") + Config.LS + errFiles + Config.LS + Config.LS + errMsg);
        }
    }
}


public static boolean copyFileCover (String srcFileName, String descFileName, boolean coverlay) {
    File srcFile = new File (srcFileName);
    if (! srcFile.exists ()) {
        System.out.println ("复制文件失败，源文件" + srcFileName + "不存在!");
        return false;
    }
    else if (! srcFile.isFile ()) {
        System.out.println ("复制文件失败，" + srcFileName + "不是一个文件!");
        return false;
    }
    File descFile = new File (descFileName);
    if (descFile.exists ()) {
        if (coverlay) {
            System.out.println ("目标文件已存在，准备删除!");
            if (! FileOperateUtils.delFile (descFileName)) {
                System.out.println ("删除目标文件" + descFileName + "失败!");
                return false;
            }
        }
        else {
            System.out.println ("复制文件失败，目标文件" + descFileName + "已存在!");
            return false;
        }
    }
    else {
        if (! descFile.getParentFile ().exists ()) {
            System.out.println ("目标文件所在的目录不存在，创建目录!");
            if (! descFile.getParentFile ().mkdirs ()) {
                System.out.println ("创建目标文件所在的目录失败!");
                return false;
            }
        }
    }
    int readByte = 0;
    InputStream ins = null;
    OutputStream outs = null;
    try {
        ins = new FileInputStream (srcFile);
        outs = new FileOutputStream (descFile);
        byte [] buf = new byte [1024];
        while ((readByte = ins.read (buf)) != - 1) {
            outs.write (buf, 0, readByte);
        }
        System.out.println ("复制单个文件" + srcFileName + "到" + descFileName + "成功!");
        return true;
    } catch (Exception e) {
        System.out.println ("复制文件失败：" + e.getMessage ());
        return false;
    } finally {
        if (outs != null) {
            try {
                outs.close ();
            } catch (IOException oute) {
                oute.printStackTrace ();
            }
        }
        if (ins != null) {
            try {
                ins.close ();
            } catch (IOException ine) {
                ine.printStackTrace ();
            }
        }
    }
}


-----Function Pair=78=-----==

public void rollback (String path, int revision) {
    File file = new File (configuration.getWorkCopyDir () + path);
    try {
        if (file.isFile ()) {
            InputStream is = svnClient.getContent (new SVNUrl (configuration.getSvnDir () + path), new SVNRevision.Number (revision));
            FileUtil.createFile (is, file);
        }
        else {
            revert (path, true);
            deleteFile (file);
            String uuid = UUID.randomUUID ().toString ();
            File tempFile = new File (configuration.getWorkCopyDir () + File.separator + uuid);
            svnClient.doExport (new SVNUrl (configuration.getSvnDir () + path), tempFile, new SVNRevision.Number (revision), true);
            FileUtils.copyDirectory (tempFile, file);
            FileUtils.deleteDirectory (tempFile);
        }
    } catch (MalformedURLException e) {
        logger.error ("The MalformedURLException!", e);
    } catch (SVNClientException e) {
        logger.error ("The SVNClientException!", e);
    } catch (IOException e) {
        logger.error ("The IOException!", e);
    }
}


public void remove (String fs, FilenameFilter ff, boolean tf) throws Exception {
    File f = new File (fs);
    if (f.getName ().length () < 1) return;
    String [] flist = f.list (ff);
    if (flist == null || flist.length < 1) {
        if (! (f.isDirectory () && ! tf)) f.delete ();
        return;
    }
    for (int i = 0; i < flist.length; i ++) {
        String p = f.getAbsolutePath ();
        if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
        FileUtil.deleteAll (p + flist [i], ff, tf);
    }
    if (f != null) if (! (f.isDirectory () && ! tf)) f.delete ();
}


-----Function Pair=79=-----==

public static boolean isDirectoryWritable (File directory) {
    boolean result = true;
    File tmpFile = new File (directory, "test.tmp");
    try {
        BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (tmpFile));
        for (int i = 0; i < 10; i ++) {
            bos.write (0);
        }
        bos.close ();
        tmpFile.delete ();
    } catch (Exception e) {
        result = false;
    }
    return result;
}


public void run () {
    try {
        InputStreamReader isr = new InputStreamReader (is);
        BufferedReader br = new BufferedReader (isr);
        PrintWriter pw = new PrintWriter (outFile);
        String line = null;
        while ((line = br.readLine ()) != null) {
            pw.println (line);
        }
        pw.flush ();
        pw.close ();
        br.close ();
    } catch (IOException e) {
        LOG.error ("Error copying scapval output stream to file: " + outFile.getAbsolutePath (), e);
    }
}


-----Function Pair=80=-----==

public void run () {
    try {
        InputStreamReader isr = new InputStreamReader (is);
        BufferedReader br = new BufferedReader (isr);
        PrintWriter pw = new PrintWriter (outFile);
        String line = null;
        while ((line = br.readLine ()) != null) {
            pw.println (line);
        }
        pw.flush ();
        pw.close ();
        br.close ();
    } catch (IOException e) {
        LOG.error ("Error copying scapval output stream to file: " + outFile.getAbsolutePath (), e);
    }
}


public static boolean copyDir (File srcDir, File destDir) {
    if (null == srcDir || ! srcDir.exists () || ! srcDir.isDirectory ()) {
        log.error ("srcDir(" + srcDir + ") is invalid !");
        return false;
    }
    if (srcDir.equals (destDir)) {
        log.error ("srcDir(" + srcDir + ") is the same as destDir(" + destDir + ") !");
        return false;
    }
    List < File > fileList = listDescendFiles (srcDir, null);
    File path = null;
    for (File file : fileList) {
        path = new File (file.getParent ().replace (srcDir.getAbsolutePath (), destDir.getAbsolutePath ()));
        if (! copyFile (file, path)) {
            return false;
        }
    }
    return true;
}


-----Function Pair=81=-----==

public static void shuffle2 (int [] a) {
    Random random = new Random ();
    random.nextInt ();
    for (int i = a.length - 1; i >= 1; i --) {
        int j = random.nextInt (i + 1);
        int tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public static boolean recursiveDelete (File f) {
    String defSaveDir = COConfigurationManager.getStringParameter ("Default save path");
    String moveToDir = COConfigurationManager.getStringParameter ("Completed Files Directory", "");
    try {
        moveToDir = new File (moveToDir).getCanonicalPath ();
    } catch (Throwable e) {
    }
    try {
        defSaveDir = new File (defSaveDir).getCanonicalPath ();
    } catch (Throwable e) {
    }
    try {
        if (f.getCanonicalPath ().equals (moveToDir)) {
            System.out.println ("FileUtil::recursiveDelete:: not allowed to delete the MoveTo dir !");
            return (false);
        }
        if (f.getCanonicalPath ().equals (defSaveDir)) {
            System.out.println ("FileUtil::recursiveDelete:: not allowed to delete the default data dir !");
            return (false);
        }
        if (f.isDirectory ()) {
            File [] files = f.listFiles ();
            for (int i = 0; i < files.length; i ++) {
                if (! recursiveDelete (files [i])) {
                    return (false);
                }
            }
            if (! f.delete ()) {
                return (false);
            }
        }
        else {
            if (! f.delete ()) {
                return (false);
            }
        }
    } catch (Exception ignore) {
    }
    return (true);
}


-----Function Pair=82=-----==

protected void moveSelectedFavoritesToTab (final String title, final boolean copy) {
    FavoritesModel model = (FavoritesModel) playListTable.getModel ();
    JTabbedPane pane = favoritesView.getTabbedPane ();
    int index = pane.indexOfTab (title);
    IFavorites panel = (IFavorites) pane.getComponentAt (index);
    int [] rows = playListTable.getSelectedRows ();
    for (int i = 0; i < rows.length; i ++) {
        int row = rowSorter.convertRowIndexToModel (rows [i]);
        panel.addToFavorites (new File [] {model.getFile (model.getValueAt (row, 0))});
        if (! copy) {
            model.removeRow (row);
            for (int j = i + 1; j < rows.length; j ++) {
                rows [j] = rows [j] - 1;
            }
        }
    }
}


public static String [] getSeasons (final String site) {
    File location = new File (Program.Settings ().getDataFolder ());
    File [] allSeasons = location.listFiles (new DirectoryFileFilter ());
    LinkedList < String > seasons = new LinkedList < String > ();
    if (location.exists ()) {
        for (int i = 0; i < allSeasons.length; i ++) {
            File [] allSites = allSeasons [i].listFiles (new FileFilter () {
                @Override
                public boolean accept (File f) {
                    return f.isDirectory () && f.getName ().contains (site) && ! f.getName ().contains (".svn");
                }
            }
            );
            if (allSites.length > 0) {
                seasons.add (allSeasons [i].getName ());
            }
        }
    }
    String [] a = {};
    return seasons.toArray (a);
}


-----Function Pair=83=-----==

protected void parse () {
    List fieldList = new ArrayList ();
    int lastEnd = 0;
    Pattern pattern = Pattern.compile ("\\$\\{(.+?)\\}");
    Matcher matcher = pattern.matcher (template);
    while (matcher.find ()) {
        if (matcher.start () > lastEnd) {
            String text = template.substring (lastEnd, matcher.start ());
            fieldList.add (new TextField (text));
        }
        fieldList.add (new DollarField (matcher.group (1)));
        lastEnd = matcher.end ();
    }
    if (lastEnd < template.length ()) {
        String text = template.substring (lastEnd);
        fieldList.add (new TextField (text));
    }
    fields = new TemplateField [fieldList.size ()];
    for (int i = 0; i < fields.length; i ++) {
        fields [i] = (TemplateField) fieldList.get (i);
    }
}


public static String getReplacementText (Matcher m, CharSequence template) {
    int cursor = 0;
    StringBuffer result = new StringBuffer ();
    while (cursor < template.length ()) {
        char nextChar = template.charAt (cursor);
        if (nextChar == '\\') {
            nextChar = template.charAt (++ cursor);
            switch (nextChar) {
                case 'n' :
                    nextChar = '\n';
                    break;
                case 't' :
                    nextChar = '\t';
                    break;
            }
            result.append (nextChar);
            cursor ++;
        }
        else if (nextChar == '$') {
            cursor ++;
            int refNum = template.charAt (cursor) - '0';
            if ((refNum < 0) || (refNum > 9)) {
                throw new IndexOutOfBoundsException ("No group " + template.charAt (cursor));
            }
            cursor ++;
            boolean done = false;
            while (! done) {
                if (cursor >= template.length ()) {
                    break;
                }
                int nextDigit = template.charAt (cursor) - '0';
                if ((nextDigit < 0) || (nextDigit > 9)) {
                    break;
                }
                int newRefNum = (refNum * 10) + nextDigit;
                if (m.groupCount () < newRefNum) {
                    done = true;
                }
                else {
                    refNum = newRefNum;
                    cursor ++;
                }
            }
            if (m.group (refNum) != null) result.append (m.group (refNum));
        }
        else {
            result.append (nextChar);
            cursor ++;
        }
    }
    return result.toString ();
}


-----Function Pair=84=-----==

private String markup (String content) {
    if (content == null || content.length () == 0) {
        return "";
    }
    Pattern p = Pattern.compile (PHOTOS_START_TAG + ".+?" + PHOTOS_END_TAG, Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    Matcher m = p.matcher (content);
    while (m.find ()) {
        int start = m.start ();
        int end = m.end ();
        String textToMarkup = content.substring (start, end);
        textToMarkup = textToMarkup.substring (PHOTOS_START_TAG.length (), textToMarkup.length () - PHOTOS_END_TAG.length ());
        StringBuffer buf = new StringBuffer ();
        buf.append ("<div class=\"photos\">\n");
        try {
            BufferedReader reader = new BufferedReader (new StringReader (textToMarkup));
            String line = reader.readLine ();
            buf.append ("<div>\n");
            boolean foundPhotos = false;
            while (line != null) {
                if (line.trim ().equals ("")) {
                    if (foundPhotos) {
                        buf.append ("</div>\n");
                        buf.append ("<div>\n");
                    }
                }
                else {
                    String [] tokens = line.split ("\\|");
                    buf.append ("<img src=\"");
                    buf.append (tokens [0]);
                    buf.append ("\" class=\"photo\" alt=\"");
                    if (tokens.length == 2) {
                        buf.append (tokens [1]);
                    }
                    buf.append ("\" />\n");
                    foundPhotos = true;
                }
                line = reader.readLine ();
            }
            buf.append ("</div>\n");
        } catch (IOException ioe) {
            log.warn (ioe);
        }
        buf.append ("</div>");
        content = content.substring (0, start) + buf.toString () + content.substring (end, content.length ());
        m = p.matcher (content);
    }
    return content;
}


public static String injectAfterOption (Message extend, Message by, String extendProto, String byContent) {
    Pattern messageRegexp = Pattern.compile ("([\\n\\r]?[ \\t]*message\\s+" + extend.getName () + "\\s+\\{[^{}]*[\\n\\r][ \\t]*)(option\\s+extends\\s+=\\s+" + by.getName () + "\\s*;)", Pattern.MULTILINE);
    Matcher matcher = messageRegexp.matcher (extendProto);
    if (matcher.find ()) {
        Pattern indentRegexp = Pattern.compile ("[\\n\\r]([ \\t]+)option\\s+extends\\s+=\\s+" + by.getName () + "\\s*;", Pattern.MULTILINE);
        Matcher indent = indentRegexp.matcher (extendProto.substring (matcher.start (), matcher.end ()));
        String indentation = "";
        if (indent.find ()) {
            int is = matcher.start () + indent.start (1), ie = matcher.start () + indent.end (1);
            indentation = generateIndentation (extendProto.substring (is, ie), 0);
        }
        StringBuffer sb = new StringBuffer ();
        matcher.appendReplacement (sb, "$1" + "// " + generateTimestamp (extend, by) + LINE_SEPARATOR + indentation + "// $2" + LINE_SEPARATOR + insertIndentation (byContent, indentation));
        matcher.appendTail (sb);
        return sb.toString ();
    }
    return extendProto;
}


-----Function Pair=85=-----==

private static JFreeChart createScatterChart () {
    GXYPlot plot = new GXYPlot ();
    plot.setBackgroundPaint (null);
    plot.setOutlinePaint (null);
    XYLineAndShapeRenderer renderer = new XYLineAndShapeRenderer (false, true);
    renderer.setBasePaint (new Color (0x76A4FB));
    renderer.setAutoPopulateSeriesPaint (false);
    plot.setRenderer (renderer);
    GValueAxis xAxis = new GValueAxis ();
    xAxis.setTickLabelsVisible (false);
    xAxis.setTickMarksVisible (false);
    plot.setDomainAxis (xAxis);
    GValueAxis yAxis = new GValueAxis ();
    yAxis.setTickLabelsVisible (false);
    yAxis.setTickMarksVisible (false);
    plot.setRangeAxis (yAxis);
    plot.setDomainGridlinesVisible (false);
    plot.setRangeGridlinesVisible (false);
    JFreeChart chart = new JFreeChart (plot);
    chart.setBackgroundPaint (Color.white);
    chart.removeLegend ();
    return chart;
}


public int getDayOfMonth () {
    String sVal = get ("val");
    if (sVal.compareTo ("") == 0) return - 1;
    String sPattern = "^(\\d+|X+)-(\\d+|H\\d|Q\\d|SP|SU|WI|FA|XX)-(\\d+)(T|$)";
    Pattern pattern = Pattern.compile (sPattern);
    Matcher m = pattern.matcher (sVal);
    if (m.find ()) {
        try {
            int iRes = Integer.parseInt (m.group (3));
            return iRes;
        } catch (Exception e) {
        }
    }
    return - 1;
}


-----Function Pair=86=-----==

private void appendIn (StringBuilder sb, String field, List < String > params) {
    sb.append ("`").append (field).append ("`");
    sb.append (" ");
    sb.append ("IN");
    sb.append (" (");
    boolean quoteParam = true;
    int i = 0;
    for (String param : params) {
        if (i > 0) {
            sb.append (",");
        }
        if (quoteParam) {
            sb.append ("'");
        }
        sb.append (param);
        if (quoteParam) {
            sb.append ("'");
        }
    }
    sb.append (")");
}


protected < T extends Pair < Integer, Integer > > Pair < int [], int [] > parseMassesAndIntensities (List < T > peaks) {
    if (peaks.size () == 0) {
        throw new IllegalArgumentException ("Peaklist was of length 0");
    }
    ArrayList < Pair < Integer, Integer > > tempPeaks = new ArrayList < Pair < Integer, Integer > > (peaks);
    java.util.Collections.sort (tempPeaks, reverseIntensityComp);
    int zeroIntensityCount = 0;
    for (Pair < Integer, Integer > pair : tempPeaks) {
        if (pair.getSecond () == 0) {
            zeroIntensityCount ++;
        }
        else {
            break;
        }
    }
    int [] intensities = new int [tempPeaks.size () - zeroIntensityCount];
    int [] masses = new int [tempPeaks.size () - zeroIntensityCount];
    for (int i = zeroIntensityCount, j = 0; i < tempPeaks.size (); i ++, j ++) {
        masses [j] = tempPeaks.get (i).getFirst ();
        intensities [j] = tempPeaks.get (i).getSecond ();
    }
    return new Pair < int [], int [] > (masses, intensities);
}


-----Function Pair=87=-----==

private static void processGridLinesSpec (String spec, JFreeChart chart) {
    String [] parts = breakString (spec, ',');
    double xAxisStepSize = 0.0;
    double yAxisStepSize = 0.0;
    float lineSegLength = 3f;
    float blankSegLength = 6f;
    if (parts.length > 0) {
        try {
            xAxisStepSize = Double.parseDouble (parts [0]);
        } catch (NumberFormatException e) {
        }
    }
    if (parts.length > 1) {
        try {
            yAxisStepSize = Double.parseDouble (parts [1]);
        } catch (NumberFormatException e) {
        }
    }
    if (parts.length > 2) {
        try {
            lineSegLength = Float.parseFloat (parts [2]) * 0.85f;
        } catch (NumberFormatException e) {
        }
    }
    if (parts.length > 3) {
        try {
            blankSegLength = Float.parseFloat (parts [3]) * 0.85f;
        } catch (NumberFormatException e) {
        }
    }
    if (lineSegLength == 0 && blankSegLength == 0) {
        lineSegLength = 1f;
    }
    if (lineSegLength > 0) {
        Stroke stroke = new BasicStroke (1.0f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND, 10f, new float [] {lineSegLength, blankSegLength}, 0);
        Plot p = chart.getPlot ();
        if (p instanceof CategoryPlot) {
            GCategoryPlot plot = (GCategoryPlot) p;
            plot.setDomainGridlinesVisible (true);
            plot.setRangeGridlinesVisible (true);
            plot.setDomainGridlineStroke (stroke);
            plot.setRangeGridlineStroke (stroke);
            plot.setXAxisStepSize (xAxisStepSize / 100.0);
            plot.setYAxisStepSize (yAxisStepSize / 100.0);
        }
        else if (p instanceof XYPlot) {
            GXYPlot plot = (GXYPlot) p;
            plot.setDomainGridlinesVisible (true);
            plot.setRangeGridlinesVisible (true);
            plot.setDomainGridlineStroke (stroke);
            plot.setRangeGridlineStroke (stroke);
            plot.setXAxisStepSize (xAxisStepSize / 100.0);
            plot.setYAxisStepSize (yAxisStepSize / 100.0);
        }
    }
}


public static int addHiddenPostFields (String page, String startFromPattern, List < String > names, List < String > values) throws ConversationException {
    Pattern p;
    Matcher m;
    p = Pattern.compile (startFromPattern);
    m = p.matcher (page);
    if (! m.find ()) {
        throw new ConversationException ("Can't find start of form with pattern \"" + startFromPattern + "\"");
    }
    int startPos = m.start ();
    p = Pattern.compile ("</form>");
    m = p.matcher (page);
    m.region (startPos, page.length ());
    int endPos = page.length ();
    if (m.find ()) {
        endPos = m.end ();
    }
    p = Pattern.compile ("<input(?=[^>]*type=\"hidden\")[^>]*name=\"(.*?)\"[^>]*value=\"(.*?)\"");
    m = p.matcher (page);
    m.region (startPos, endPos);
    while (m.find ()) {
        String name = m.group (1);
        String value = m.group (2);
        names.add (name);
        values.add (value);
    }
    p = Pattern.compile ("<input(?=[^>]*type=\"hidden\")[^>]*value=\"(.*?)\"[^>]*name=\"(.*?)\"");
    m = p.matcher (page);
    m.region (startPos, endPos);
    while (m.find ()) {
        String name = m.group (1);
        String value = m.group (2);
        names.add (name);
        values.add (value);
    }
    return startPos;
}


-----Function Pair=88=-----=1=

public void plot (Point me) {
    cont.clear ();
    cont.bbox.setBounds (getBounds ());
    aTfrqG.setToIdentity ();
    aTphase.setToIdentity ();
    String strResult;
    DecimalFormat df = new DecimalFormat ();
    df.applyPattern ("0.#E0");
    try {
        MathAnalog.evaluate ("<<Graphics`Graphics`", false);
        if (! acSweep.isEmpty ()) MathAnalog.evaluate ("v =" + aiSignal + "/." + acSweep + "[[1]]", false);
        MathAnalog.evaluate ("nv = InterpolatingFunctionToList[v]", false);
        MathAnalog.evaluate ("vAbs = Interpolation[Abs[nv]]", false);
        String deb = MathAnalog.evaluateToOutputForm ("v", 0, false);
        if (! deb.startsWith ("v")) {
            if (linearY) {
                if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{Abs[" + function + "[f]], vAbs[f]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
                else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{Abs[" + function + "[f]], vAbs[f]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
            }
            else {
                if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{20*Log[10, Abs[" + function + "[f]]], 20*Log[10, vAbs[f]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
                else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{20*Log[10, Abs[" + function + "[f]]], 20*Log[10, vAbs[f]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
            }
        }
        else {
            if (linearY) {
                if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{Abs[" + function + "[f]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
                else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{Abs[" + function + "[f]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
            }
            else {
                if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{20*Log[10, Abs[" + function + "[f]]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
                else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{20*Log[10, Abs[" + function + "[f]]]}, {f," + minValue + "," + maxValue + "}" + ",PlotRange->All, GridLines -> Automatic]]", 0, false);
            }
        }
        Pattern pattern = Pattern.compile ("Line\\[[^\\]]*\\]");
        Matcher matcher = pattern.matcher (strResult);
        boolean found = false;
        CdgPolyline cdgPL = new CdgPolyline ();
        GraphicsContainer frqG = new GraphicsContainer ();
        GraphicsContainer phase = new GraphicsContainer ();
        GraphicsContainer labelMY = new GraphicsContainer ();
        GraphicsContainer labelPhX = new GraphicsContainer ();
        GraphicsContainer labelPhY = new GraphicsContainer ();
        txtPhaseY = new GraphicsContainer ();
        txtFrqGY = new GraphicsContainer ();
        txtPhaseX = new GraphicsContainer ();
        txtFrqGX = new GraphicsContainer ();
        double [] xpoints = null;
        double [] ypoints = null;
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, (byte) 0, (byte) 0, axis);
            frqG.add (cdgPL);
        }
        int index = 0;
        if (matcher.find (0)) {
            found = true;
            index = matcher.end ();
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, (byte) 0, (byte) 0, simPlot);
            frqG.add (cdgPL);
        }
        if (matcher.find (index) && ! deb.startsWith ("v")) {
            found = true;
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, (byte) 0, (byte) 0, aiPlot);
            frqG.add (cdgPL);
        }
        frqG.calculateBounds ();
        aTfrqG.scale (cont.getBounds ().getWidth () / frqG.getBounds ().getWidth (), 0.5 * cont.getBounds ().getHeight () / frqG.getBounds ().getHeight ());
        ginstF = new CdgInstance (0, 0, aTfrqG, frqG);
        ginstF.setClipRegion (frqG.bbox);
        cont.add (ginstF);
        byte layerVar = 0x00B;
        pattern = Pattern.compile ("Text\\[[^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 5, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split (",") [0];
            try {
                float f = - (float) (Float.valueOf (str) * aTfrqG.getScaleY ()) - (float) (ginstF.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (frqG.getBounds ().getMinX () * aTfrqG.getScaleX () + ginstF.trf.getTranslateX ()), f, str, layerVar, (byte) 0, fontColor);
                txtFrqGY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[[^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 5, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split (",") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTfrqG.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTfrqG.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTfrqG.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstF.trf.getTranslateY () + frqG.getBounds ().getMinY () * aTfrqG.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtFrqGX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[Superscript\\[[^\\]]*\\][^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 17, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTfrqG.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTfrqG.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTfrqG.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstF.trf.getTranslateY () + frqG.getBounds ().getMinY () * aTfrqG.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtFrqGX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[Superscript\\[[^\\]]*\\][^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 17, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f = - (float) (Float.valueOf (str) * aTfrqG.getScaleY ()) - (float) (ginstF.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (frqG.getBounds ().getMinX () * aTfrqG.getScaleX () + ginstF.trf.getTranslateX ()), f, str, layerVar, (byte) 0, fontColor);
                txtFrqGY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[NumberForm\\[[^\\]]*\\][^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 16, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTfrqG.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTfrqG.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTfrqG.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstF.trf.getTranslateY () + frqG.getBounds ().getMinY () * aTfrqG.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtFrqGX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[NumberForm\\[[^\\]]*\\][^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 16, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f = - (float) (Float.valueOf (str) * aTfrqG.getScaleY ()) - (float) (ginstF.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (frqG.getBounds ().getMinX () * aTfrqG.getScaleX () + ginstF.trf.getTranslateX ()), f, str, layerVar, (byte) 0, fontColor);
                txtFrqGY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        CdgText cdgTl = new CdgText ((float) (ginstF.trf.getTranslateY () + frqG.getBounds ().getMinY () * aTfrqG.getScaleY ()), (float) (frqG.getBounds ().getMinX () * aTfrqG.getScaleX () + ginstF.trf.getTranslateX ()) - 10, "Magnitude", layerVar, (byte) 0, fontColor);
        labelMY.add (cdgTl);
        MathAnalog.evaluate ("x1 = InterpolatingFunctionToList[" + function + "]", false);
        MathAnalog.evaluate ("x2 = {{x1[[1, 1]], 180/Pi*Arg[x1[[1, 2]]]}}", false);
        MathAnalog.evaluate ("offset = 0", false);
        MathAnalog.evaluate ("Do[ If[(Abs[180/Pi*(Arg[x1[[i, 2]]] - Arg[x1[[i - 1, 2]]])] > 0.9*360), If[(Arg[x1[[i, 2]]] - Arg[x1[[i - 1, 2]]]) < 0, offset += 360; AppendTo[x2, { x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}], offset -= 360; AppendTo[x2, {x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}]], AppendTo[x2, {x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}]], {i, 2, Length[x1]}]", false);
        MathAnalog.evaluate ("ifun = Interpolation[x2]", false);
        MathAnalog.evaluate ("x1 = InterpolatingFunctionToList[v]", false);
        MathAnalog.evaluate ("x2 = {{x1[[1, 1]], 180/Pi*Arg[x1[[1, 2]]]}}", false);
        MathAnalog.evaluate ("offset = 0", false);
        MathAnalog.evaluate ("Do[ If[(Abs[180/Pi*(Arg[x1[[i, 2]]] - Arg[x1[[i - 1, 2]]])] > 0.9*360), If[(Arg[x1[[i, 2]]] - Arg[x1[[i - 1, 2]]]) < 0, offset += 360; AppendTo[x2, { x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}], offset -= 360; AppendTo[x2, {x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}]], AppendTo[x2, {x1[[i, 1]], 180/Pi*Arg[x1[[i, 2]]] + offset}]], {i, 2, Length[x1]}]", false);
        MathAnalog.evaluate ("iv = Interpolation[x2]", false);
        if (! deb.startsWith ("v")) {
            if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{ifun[f], iv[f]}, {f," + minValue + "," + maxValue + "}" + ", GridLines -> Automatic, PlotRange->All]]", 0, false);
            else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{ifun[f], iv[f]}, {f," + minValue + "," + maxValue + "}" + ", GridLines -> Automatic, PlotRange->All]]", 0, false);
        }
        else {
            if (logarithmic) strResult = MathAnalog.evaluateToInputForm ("FullGraphics[LogLinearPlot[{ifun[f]}, {f," + minValue + "," + maxValue + "}" + ", GridLines -> Automatic, PlotRange->All]]", 0, false);
            else strResult = MathAnalog.evaluateToInputForm ("FullGraphics[Plot[{ifun[f]}, {f," + minValue + "," + maxValue + "}" + ", GridLines -> Automatic, PlotRange->All]]", 0, false);
        }
        pattern = Pattern.compile ("Line\\[[^\\]]*\\]");
        matcher = pattern.matcher (strResult);
        found = false;
        layerVar = 0x00A;
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, layerVar, (byte) 0, axis);
            phase.add (cdgPL);
        }
        index = 0;
        if (matcher.find (0)) {
            found = true;
            index = matcher.end ();
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, layerVar, (byte) 0, simPlot);
            phase.add (cdgPL);
        }
        if (matcher.find (index) && ! deb.startsWith ("v")) {
            found = true;
            String str = strResult.substring (matcher.start () + 7, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            String [] lines = str.split ("[}], [{]");
            xpoints = new double [lines.length];
            ypoints = new double [lines.length];
            for (int i = 0; i < lines.length; i ++) {
                xpoints [i] = Double.valueOf (lines [i].split (", ") [0]);
                ypoints [i] = Double.valueOf (lines [i].split (", ") [1]);
            }
            cdgPL = new CdgPolyline (xpoints, ypoints, xpoints.length, layerVar, (byte) 0, aiPlot);
            phase.add (cdgPL);
        }
        phase.calculateBounds ();
        aTphase.scale (cont.getBounds ().getWidth () / phase.getBounds ().getWidth (), 0.5 * cont.getBounds ().getHeight () / phase.getBounds ().getHeight ());
        ginstPh = new CdgInstance (0, (int) (aTfrqG.getScaleY () * frqG.bbox.getMinY () - aTphase.getScaleY () * phase.bbox.getMaxY ()) - 10, aTphase, phase);
        ginstPh.setClipRegion (phase.bbox);
        cont.add (ginstPh);
        layerVar = 0x00B;
        pattern = Pattern.compile ("Text\\[[^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 5, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split (",") [0];
            try {
                float f = - (float) (Float.valueOf (str) * aTphase.getScaleY ()) - (float) (ginstPh.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (phase.getBounds ().getMinX () * aTphase.getScaleX () + ginstPh.trf.getTranslateX ()), f, str + "�", layerVar, (byte) 0, fontColor);
                txtPhaseY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[[^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 5, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split (",") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTphase.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTphase.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTphase.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstPh.trf.getTranslateY () + phase.getBounds ().getMinY () * aTphase.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtPhaseX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[Superscript\\[[^\\]]*\\][^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 17, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTphase.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTphase.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTphase.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstPh.trf.getTranslateY () + phase.getBounds ().getMinY () * aTphase.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtPhaseX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[Superscript\\[[^\\]]*\\][^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 17, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f = - (float) (Float.valueOf (str) * aTphase.getScaleY ()) - (float) (ginstPh.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (phase.getBounds ().getMinX () * aTphase.getScaleX () + ginstPh.trf.getTranslateX ()), f, str + "�", layerVar, (byte) 0, fontColor);
                txtPhaseY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[NumberForm\\[[^\\]]*\\][^\\]]*1\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 16, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f;
                if (logarithmic) {
                    if (version.startsWith ("6")) f = (float) (Math.log (Float.valueOf (str)) * aTphase.getScaleX ());
                    else f = (float) (Math.log10 (Float.valueOf (str)) * aTphase.getScaleX ());
                }
                else f = (float) (Float.valueOf (str) * aTphase.getScaleX () / 1);
                CdgText cdgT = new CdgText (f, - (float) (ginstPh.trf.getTranslateY () + phase.getBounds ().getMinY () * aTphase.getScaleY ()), str, layerVar, (byte) 0, fontColor);
                txtPhaseX.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        pattern = Pattern.compile ("Text\\[NumberForm\\[[^\\]]*\\][^\\]]*0\\Q.\\E[}]\\]");
        matcher = pattern.matcher (strResult);
        while (matcher.find ()) {
            found = true;
            String str = strResult.substring (matcher.start () + 16, matcher.end () - 3).replaceAll ("\\Q.\\E*[*][\\Q^\\E]", "E");
            str = str.split ("]") [0];
            str = str.replace ("0, ", "E");
            try {
                float f = - (float) (Float.valueOf (str) * aTphase.getScaleY ()) - (float) (ginstPh.trf.getTranslateY ());
                CdgText cdgT = new CdgText ((float) (phase.getBounds ().getMinX () * aTphase.getScaleX () + ginstPh.trf.getTranslateX ()), f, str + "�", layerVar, (byte) 0, fontColor);
                txtPhaseY.add (cdgT);
            } catch (NumberFormatException e) {
            }
        }
        AffineTransform atLabel = new AffineTransform (1, 0, 0, - 1, 0, 0);
        cdgTl = new CdgText ((float) (phase.getBounds ().getMinX () * aTphase.getScaleX () + ginstPh.trf.getTranslateX ()), - (float) (ginstPh.trf.getTranslateY () + phase.getBounds ().getMinY () * aTphase.getScaleY ()) + 20, "Frequency", layerVar, (byte) 0, fontColor);
        labelPhX.add (cdgTl);
        labelPhX.calculateBounds ();
        CdgInstance ginstlabelPhX = new CdgInstance (0, 0, atLabel, labelPhX);
        cont.add (ginstlabelPhX);
        atLabel.concatenate (new AffineTransform (0, - 1, 1, 0, 0, 0));
        cdgTl = new CdgText ((float) (ginstPh.trf.getTranslateY () + phase.getBounds ().getMinY () * aTphase.getScaleY ()), (float) (phase.getBounds ().getMinX () * aTphase.getScaleX () + ginstPh.trf.getTranslateX ()) - 10, "Phase", layerVar, (byte) 0, fontColor);
        labelPhY.add (cdgTl);
        labelPhY.calculateBounds ();
        CdgInstance ginstlabelPhY = new CdgInstance (0, 0, atLabel, labelPhY);
        cont.add (ginstlabelPhY);
        labelMY.calculateBounds ();
        CdgInstance ginstlabelMY = new CdgInstance (0, 0, atLabel, labelMY);
        cont.add (ginstlabelMY);
        txtFrqGY.calculateBounds ();
        AffineTransform atTxt = new AffineTransform (1, 0, 0, - 1, 0, 0);
        CdgInstance ginstTxtFrqGY = new CdgInstance (0, 0, atTxt, txtFrqGY);
        ginstTxtFrqGY.setClipRegion (txtFrqGY.bbox);
        cont.add (ginstTxtFrqGY);
        txtPhaseY.calculateBounds ();
        CdgInstance ginstTxtPhaseY = new CdgInstance (0, 0, atTxt, txtPhaseY);
        ginstTxtPhaseY.setClipRegion (txtPhaseY.bbox);
        cont.add (ginstTxtPhaseY);
        txtFrqGX.calculateBounds ();
        CdgInstance ginstTxtFrqGX = new CdgInstance (0, 0, atTxt, txtFrqGX);
        ginstTxtFrqGX.setClipRegion (txtFrqGX.bbox);
        cont.add (ginstTxtFrqGX);
        txtPhaseX.calculateBounds ();
        CdgInstance ginstTxtPhaseX = new CdgInstance (0, 0, atTxt, txtPhaseX);
        ginstTxtPhaseX.setClipRegion (txtPhaseX.bbox);
        cont.add (ginstTxtPhaseX);
        cont.calculateBounds ();
        for (int i = 0; i < pointCounter; i ++) {
            try {
                double im = (cPoint [i].im () / (2 * Math.PI));
                if (logarithmic) if (version.startsWith ("6")) paintLine (new Point2D.Double (Math.log (im), 0));
                else paintLine (new Point2D.Double (Math.log10 (im), 0));
                else paintLine (new Point2D.Double (im, 0));
            } catch (Exception e) {
            }
        }
        Fit ();
        if (! found) {
            System.out.println ("wrong Graphics");
        }
    } catch (MathLinkException e) {
        e.printStackTrace ();
    }
}


public String wikify (String s, WikiPageHandler handler) {
    s = s.replace ("\\\\[", "_BRACKETOPEN_");
    if (getReplaceNewlineWithP ()) {
        s = s.replaceAll ("\r\n\r\n", "\n<p>\n");
        s = s.replaceAll ("\r\r", "\n<p>\n");
    }
    s = s.replaceAll ("'''''([^']+)'''''", "<b><i>$1</i></b>");
    s = s.replaceAll ("'''([^']+)'''", "<b>$1</b>");
    s = s.replaceAll ("''([^']+)''", "<i>$1</i>");
    Pattern pattern;
    Matcher matcher;
    pattern = Pattern.compile ("\\[\\[([^\\]|]+)\\|?([^\\]]*)\\]\\]");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String name = matcher.group (1);
        String label = matcher.group (2);
        int start = matcher.start (0);
        int end = matcher.end (0);
        String link;
        if (handler == null) {
            if (label.trim ().length () == 0) {
                label = name;
            }
            link = "<a href=\"" + name + "\">" + label + "</a>";
        }
        else {
            link = handler.getWikiLink (this, name, label);
        }
        s = s.substring (0, start) + link + s.substring (end);
        matcher = pattern.matcher (s);
    }
    int cnt = 0;
    pattern = Pattern.compile ("\\[([^\\]]+)\\]");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String name = matcher.group (1).trim ();
        int idx = name.indexOf (" ");
        int start = matcher.start (0);
        int end = matcher.end (0);
        if (idx > 0) {
            String label = name.substring (idx);
            name = name.substring (0, idx);
            String ahref = "<a title=\"" + name + "\" class=\"wiki-link-external\" target=\"externalpage\" href=\"" + name + "\">";
            s = s.substring (0, start) + ahref + label + "</a>" + s.substring (end);
        }
        else {
            cnt ++;
            String ahref = "<a title=\"" + name + "\" class=\"wiki-link-external\" target=\"externalpage\" href=\"" + name + "\">";
            s = s.substring (0, start) + ahref + "_BRACKETOPEN_" + cnt + "_BRACKETCLOSE_</a>" + s.substring (end);
        }
        matcher = pattern.matcher (s);
    }
    List headings = new ArrayList ();
    pattern = Pattern.compile ("(?m)^\\s*(==+)([^=]+)(==+)\\s*$");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String prefix = matcher.group (1).trim ();
        String label = matcher.group (2).trim ();
        int start = matcher.start (0);
        int end = matcher.end (0);
        int level = prefix.length ();
        String value;
        if (label.startsWith ("{{")) {
            value = "<div class=\"wiki-h" + level + "\">" + label + "</div>";
        }
        else {
            value = "<a name=\"" + label + "\"></a><div class=\"wiki-h" + level + "\">" + label + "</div>";
            headings.add (new Object [] {new Integer (level), label});
        }
        s = s.substring (0, start) + value + s.substring (end);
        matcher = pattern.matcher (s);
    }
    int ulCnt = 0;
    int olCnt = 0;
    StringBuffer buff = new StringBuffer ();
    for (String line : (List < String >) StringUtil.split (s, "\n", false, false)) {
        String tline = line.trim ();
        if (tline.equals ("----")) {
            buff.append ("<hr>");
            buff.append ("\n");
            continue;
        }
        int starCnt = 0;
        while (tline.startsWith ("*")) {
            tline = tline.substring (1);
            starCnt ++;
        }
        if (starCnt > 0) {
            if (starCnt > ulCnt) {
                while (starCnt > ulCnt) {
                    buff.append ("<ul>\n");
                    ulCnt ++;
                }
            }
            else {
                while ((starCnt < ulCnt) && (ulCnt > 0)) {
                    buff.append ("</ul>\n");
                    ulCnt --;
                }
            }
            buff.append ("<li> ");
            buff.append (tline);
            buff.append ("</li> ");
            buff.append ("\n");
            continue;
        }
        while (ulCnt > 0) {
            buff.append ("</ul>\n");
            ulCnt --;
        }
        int hashCnt = 0;
        while (tline.startsWith ("#")) {
            tline = tline.substring (1);
            hashCnt ++;
        }
        if (hashCnt > 0) {
            if (hashCnt > olCnt) {
                while (hashCnt > olCnt) {
                    buff.append ("<ol>\n");
                    olCnt ++;
                }
            }
            else {
                while ((hashCnt < olCnt) && (olCnt > 0)) {
                    buff.append ("</ol>\n");
                    olCnt --;
                }
            }
            buff.append ("<li> ");
            buff.append (tline);
            buff.append ("\n");
            continue;
        }
        while (olCnt > 0) {
            buff.append ("</ol>\n");
            olCnt --;
        }
        buff.append (line);
        buff.append ("\n");
    }
    while (ulCnt > 0) {
        buff.append ("</ul>\n");
        ulCnt --;
    }
    while (olCnt > 0) {
        buff.append ("</ol>\n");
        olCnt --;
    }
    s = buff.toString ();
    StringBuffer sb = new StringBuffer ();
    int baseIdx = 0;
    while (true) {
        int idx1 = s.indexOf ("{{", baseIdx);
        if (idx1 < 0) {
            sb.append (s.substring (baseIdx));
            break;
        }
        int idx2 = s.indexOf ("}}", idx1);
        if (idx2 <= idx1) {
            sb.append (s.substring (baseIdx));
            break;
        }
        sb.append (s.substring (baseIdx, idx1));
        String property = s.substring (idx1 + 2, idx2);
        baseIdx = idx2 + 2;
        if (property.equals ("noheading")) {
            makeHeadings = false;
        }
        else {
            String value = null;
            if (handler != null) {
                value = handler.getWikiPropertyValue (this, property);
            }
            if (value == null) {
                value = "Unknown property:" + property;
            }
            sb.append (value);
        }
    }
    s = sb.toString ();
    sb = new StringBuffer ();
    while (true) {
        int idx1 = s.indexOf ("<block");
        if (idx1 < 0) {
            break;
        }
        int idx2 = s.indexOf (">", idx1);
        if (idx2 < 0) {
            break;
        }
        int idx3 = s.indexOf ("</block>", idx2);
        if (idx3 < 0) {
            break;
        }
        String first = s.substring (0, idx1);
        String attrs = s.substring (idx1 + 6, idx2);
        String inner = s.substring (idx2 + 1, idx3);
        Hashtable props = StringUtil.parseHtmlProperties (attrs);
        boolean open = Misc.getProperty (props, "open", true);
        String title = Misc.getProperty (props, "title", "");
        sb.append (first);
        sb.append (HtmlUtil.makeShowHideBlock (title, inner, open, HtmlUtil.cssClass ("wiki-blockheader"), HtmlUtil.cssClass ("wiki-block")));
        s = s.substring (idx3 + "</block>".length ());
    }
    sb.append (s);
    s = sb.toString ();
    s = s.replace ("_BRACKETOPEN_", "[");
    s = s.replace ("_BRACKETCLOSE_", "]");
    if (getMakeHeadings ()) {
        if (headings.size () >= 2) {
            StringBuffer toc = new StringBuffer ();
            makeHeadings (headings, toc, - 1, "");
            String block = HtmlUtil.makeShowHideBlock ("Contents", toc.toString (), true, HtmlUtil.cssClass ("wiki-tocheader"), HtmlUtil.cssClass ("wiki-toc"));
            floatBoxes.add (block);
            String blocks = "<table class=\"wiki-toc-wrapper\" align=\"right\" width=\"30%\"><tr><td>" + StringUtil.join ("<br>", floatBoxes) + "</td></tr></table>";
            s = blocks + s;
        }
    }
    if (categoryLinks.size () > 0) {
        s = s + HtmlUtil.div ("<b>Categories:</b> " + StringUtil.join ("&nbsp;|&nbsp; ", categoryLinks), HtmlUtil.cssClass ("wiki-categories"));
    }
    return s;
}


-----Function Pair=89=-----==

public static List < UserUrlCat > parseBookmark (File bookmarkFile) throws Exception {
    List < UserUrlCat > userUrlCatList = new ArrayList < UserUrlCat > (10);
    UserUrlCat userUrlCat, defaultUserUrlCat = new UserUrlCat ();
    defaultUserUrlCat.setCatName ("收藏夹");
    defaultUserUrlCat.setCatCreateType (UserUrlCat.CAT_CREATE_TYPE_UNLINIT);
    String src = FileIO.readAsString (bookmarkFile, FileUtil.getCharset (bookmarkFile));
    src = formatBookmark (src);
    List < Object [] > tempCatList = new ArrayList < Object [] > (10);
    Pattern p = Pattern.compile ("<(h\\d)[^>]*>([^<]*)</\\1>", Pattern.CASE_INSENSITIVE);
    Matcher m = p.matcher (src);
    while (m.find ()) {
        tempCatList.add (new Object [] {m.group (2), m.start (), m.end ()});
    }
    String noCatUrls = null;
    if (tempCatList.size () == 0) {
        noCatUrls = src;
    }
    else {
        noCatUrls = src.substring (0, (Integer) tempCatList.get (0) [1]);
    }
    if (null != noCatUrls && ! noCatUrls.trim ().equals ("")) {
        parseUserUrl (noCatUrls, defaultUserUrlCat.getUserUrlList ());
    }
    String catUrls = null, catName;
    for (int i = 0; i < tempCatList.size (); i ++) {
        if (i == tempCatList.size () - 1) {
            catUrls = src.substring ((Integer) tempCatList.get (i) [2]);
        }
        else {
            catUrls = src.substring ((Integer) tempCatList.get (i) [2], (Integer) tempCatList.get (i + 1) [1]);
        }
        catName = tempCatList.get (i) [0].toString ().trim ();
        if (catName.equals ("")) {
            parseUserUrl (catUrls, defaultUserUrlCat.getUserUrlList ());
        }
        else {
            userUrlCat = new UserUrlCat ().setCatName (catName);
            userUrlCat.setCatCreateType (UserUrlCat.CAT_CREATE_TYPE_UNLINIT);
            parseUserUrl (catUrls, userUrlCat.getUserUrlList ());
            if (userUrlCat.getUserUrlList ().size () > 0) {
                userUrlCatList.add (userUrlCat);
            }
        }
    }
    if (defaultUserUrlCat.getUserUrlList ().size () > 0) {
        userUrlCatList.add (defaultUserUrlCat);
    }
    return userUrlCatList;
}


private static ArrayList translateStyle (ArrayList text, String regex, String twikiTag, String openningHtmlTag, String closingHtmlTag) {
    for (int i = 0; i < text.size (); ++ i) {
        String sCurrentLineProcess = "";
        String sCurrentLine = (String) text.get (i);
        Pattern p = Pattern.compile (regex);
        Matcher m = p.matcher (sCurrentLine);
        boolean result = m.find ();
        if (result == true) {
            int startChain = 0;
            while (result) {
                int startRegex = m.start ();
                int endRegex = m.end ();
                sCurrentLineProcess += sCurrentLine.substring (startChain, startRegex);
                String sRegex = sCurrentLine.substring (startRegex, endRegex);
                sRegex = sRegex.substring (sRegex.indexOf (twikiTag) + twikiTag.length ());
                sRegex = sRegex.substring (0, sRegex.lastIndexOf (twikiTag));
                if (sRegex.length () > 0) {
                    sCurrentLineProcess += openningHtmlTag + sRegex + closingHtmlTag;
                }
                startChain = endRegex;
                result = m.find ();
                if (! result) {
                    sCurrentLineProcess += sCurrentLine.substring (endRegex);
                }
            }
        }
        else {
            sCurrentLineProcess = sCurrentLine;
        }
        text.set (i, sCurrentLineProcess);
    }
    return text;
}


-----Function Pair=90=-----==

private Control addLabel (Control controlTop, String text) {
    Label label = new Label (dialog, SWT.LEFT);
    FormData formDatalabel = new FormData ();
    if (controlTop == null) {
        formDatalabel.top = new FormAttachment (0, padding);
        formDatalabel.bottom = new FormAttachment (0, padding + 16);
    }
    else {
        formDatalabel.top = new FormAttachment (controlTop, padding, SWT.BOTTOM);
        formDatalabel.bottom = new FormAttachment (controlTop, padding + 16, SWT.BOTTOM);
    }
    formDatalabel.left = new FormAttachment (0, padding);
    formDatalabel.right = new FormAttachment (100, - padding);
    label.setLayoutData (formDatalabel);
    label.setText (text);
    return label;
}


public static void main (String [] args) {
    Console console = System.console ();
    if (console == null) {
        System.err.println ("No console.");
        System.exit (1);
    }
    while (true) {
        String regex = console.readLine ("%nEnter your regex: ");
        Pattern pattern = Pattern.compile (regex);
        String input = console.readLine ("Enter input string to search: ");
        Matcher matcher = pattern.matcher (input);
        boolean found = false;
        while (matcher.find ()) {
            console.format ("I found the text \"%s\" starting at " + "index %d and ending at index %d.%n", matcher.group (), matcher.start (), matcher.end ());
            found = true;
        }
        if (! found) {
            console.format ("No match found.%n");
        }
        String [] arr = input.split (regex);
        for (int i = 0; i < arr.length; i ++) {
            console.format ("a[%d]='%s' \n", i, arr [i]);
        }
    }
}


-----Function Pair=91=-----==

public static boolean isInnerIP (String domain) {
    if (! UrlUtil.isIp (domain)) {
        return false;
    }
    boolean isInnerIp = false;
    long ipNum = getIpNum (domain);
    long aBegin = getIpNum ("10.0.0.0");
    long aEnd = getIpNum ("10.255.255.255");
    long bBegin = getIpNum ("172.16.0.0");
    long bEnd = getIpNum ("172.31.255.255");
    long cBegin = getIpNum ("192.168.0.0");
    long cEnd = getIpNum ("192.168.255.255");
    isInnerIp = isInner (ipNum, aBegin, aEnd) || isInner (ipNum, bBegin, bEnd) || isInner (ipNum, cBegin, cEnd) || domain.equals ("127.0.0.1");
    return isInnerIp;
}


protected EventConnections getEventConnections (Element eventConnectionsElem) {
    if (eventConnectionsElem != null && eventConnectionsElem.getName ().equals ("EventConnections")) {
        List content = eventConnectionsElem.getChildren ();
        int size = content.size ();
        if (size > 0) {
            Hashtable < String, Connection > hashTable = new Hashtable < String, Connection > (size);
            Iterator iterator = content.iterator ();
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Connection connection = getConnection (currentElement);
                hashTable.put (connection.getSource () + connection.getDestination (), connection);
            }
            EventConnections eventConnections = new EventConnections (hashTable);
            return eventConnections;
        }
        else {
            System.err.println ("Invalid child element size in getEventConnections()");
            if (this.console != null) {
                console.setText ("Invalid child element size in getEventConnections()");
            }
            return null;
        }
    }
    else {
        System.err.println ("Invalid element input in getEventConnections()");
        if (this.console != null) {
            console.setText ("Invalid element input in getEventConnections()");
        }
        return null;
    }
}


-----Function Pair=92=-----==

public static void main (String [] args) {
    if (args.length < 2) {
        print ("Usage: \njava TestRegularExpression " + "characterSequence regularExpression+");
        System.exit (0);
    }
    print ("Input: \" " + args [0] + "\"");
    for (String arg : args) {
        print ("Regular expression: \" " + arg + "\" ");
        Pattern p = Pattern.compile (arg);
        Matcher m = p.matcher (args [0]);
        while (m.find ()) {
            print ("Match \" " + m.group () + "\" at positions " + m.start () + "-" + (m.end () - 1));
        }
    }
}


public void test_toMatchResult () {
    String testPattern = "(((abb)a)(bb))";
    String testString = "babbabbcccabbabbabbabbabb";
    Pattern pat = Pattern.compile (testPattern);
    Matcher mat = pat.matcher (testString);
    mat.region (1, 7);
    assertTrue ("matcher should find pattern in given region", mat.matches ());
    assertEquals ("matched section should start from 1 position", 1, mat.toMatchResult ().start ());
    assertEquals ("matched section for 2 group should start from 1 position", 1, mat.toMatchResult ().start (2));
    assertEquals ("matched section for whole pattern should end on 7 position", 7, mat.toMatchResult ().end ());
    assertEquals ("matched section for 3 group should end at 4 position", 4, mat.toMatchResult ().end (3));
    assertEquals ("group not matched", "abbabb", mat.toMatchResult ().group ());
    assertEquals ("3 group not matched", "abb", mat.toMatchResult ().group (3));
    assertEquals ("Total number of groups does not matched with given pattern", 4, mat.toMatchResult ().groupCount ());
}


-----Function Pair=93=-----==

public float [] [] mtxMargin (final float [] [] mtx) {
    int nrow = mtx.length;
    int ncol = mtx [0].length;
    float [] margCol = new float [ncol];
    float [] margRow = new float [nrow];
    for (int j = 0; j < ncol; j ++) {
        for (int i = 0; i < nrow; i ++) {
            margCol [j] += mtx [i] [j];
        }
    }
    for (int i = 0; i < nrow; i ++) {
        for (int j = 0; j < ncol; j ++) {
            margRow [i] += mtx [i] [j];
        }
    }
    float [] [] margin = new float [2] [];
    margin [0] = margRow;
    margin [1] = margCol;
    return (margin);
}


public static void dcopy_f77 (int n, double dx [], int incx, double dy [], int incy) {
    double dtemp;
    int i, ix, iy, m;
    if (n <= 0) return;
    if ((incx == 1) && (incy == 1)) {
        m = n % 7;
        for (i = 1; i <= m; i ++) {
            dy [i] = dx [i];
        }
        for (i = m + 1; i <= n; i += 7) {
            dy [i] = dx [i];
            dy [i + 1] = dx [i + 1];
            dy [i + 2] = dx [i + 2];
            dy [i + 3] = dx [i + 3];
            dy [i + 4] = dx [i + 4];
            dy [i + 5] = dx [i + 5];
            dy [i + 6] = dx [i + 6];
        }
        return;
    }
    else {
        ix = 1;
        iy = 1;
        if (incx < 0) ix = (- n + 1) * incx + 1;
        if (incy < 0) iy = (- n + 1) * incy + 1;
        for (i = 1; i <= n; i ++) {
            dy [iy] = dx [ix];
            ix += incx;
            iy += incy;
        }
        return;
    }
}


-----Function Pair=94=-----==

public float [] [] calDominance (final float [] [] rawScore) {
    int nInd = rawScore.length;
    int nObj = rawScore [0].length;
    float [] [] dom = new float [nInd] [nInd];
    for (int i = 0; i < nInd; i ++) {
        for (int j = (i + 1); j < nInd; j ++) {
            dom [i] [j] = (float) checkDominance (rawScore [i], rawScore [j]);
            if (dom [i] [j] == 1) {
                dom [j] [i] = - 1;
                dom [i] [j] = 0;
            }
        }
    }
    return (dom);
}


public static void transpose3 (double [] [] in, double [] [] out) {
    if (D.isIdentityMatrix (in)) {
        if (in != out) D.identityMatrix (out);
        return;
    }
    double [] [] copyIn;
    if (in == out) {
        D.copyMatrix (in, _dummyMatrix);
        copyIn = _dummyMatrix;
    }
    else {
        copyIn = in;
    }
    for (int rowI = 0; rowI < 3; rowI ++) {
        for (int colI = 0; colI < 3; colI ++) {
            out [colI] [rowI] = copyIn [rowI] [colI];
        }
    }
}


-----Function Pair=95=-----==

public ComplexMatrix add (final ComplexMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawAdd (m);
        default :
            if (numRows == m.rows () && numCols == m.columns ()) {
                final double arrayRe [] [] = new double [numRows] [numCols];
                final double arrayIm [] [] = new double [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    arrayRe [i] [0] = matrixRe [i] [0] + m.getElement (i, 0).real ();
                    arrayIm [i] [0] = matrixIm [i] [0] + m.getElement (i, 0).imag ();
                    for (j = 1; j < numCols; j ++) {
                        arrayRe [i] [j] = matrixRe [i] [j] + m.getElement (i, j).real ();
                        arrayIm [i] [j] = matrixIm [i] [j] + m.getElement (i, j).imag ();
                    }
                }
                return new ComplexSquareMatrix (arrayRe, arrayIm);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


public static double [] [] grid2Array (IDataGrid grid) {
    Vector < Integer > doubleCols = new Vector < Integer > ();
    for (int i = 0; i < grid.getNumCols (); i ++) {
        if (grid.getPoint (0, i) instanceof Double) {
            doubleCols.add (i);
        }
    }
    double [] [] lrn = new double [grid.getNumRows ()] [doubleCols.size ()];
    for (int i = 0; i < lrn.length; i ++) {
        for (int j = 0; j < lrn [0].length; j ++) {
            lrn [i] [j] = ((Double) grid.getPoint (i, doubleCols.get (j))).doubleValue ();
        }
    }
    return lrn;
}


-----Function Pair=96=-----==

public static String toString (double [] [] a) {
    int rows = a.length;
    int cols = a [0].length;
    StringBuffer sb = new StringBuffer (4000);
    Formatter formatter = new Formatter (sb, Locale.US);
    sb.append ("       ");
    for (int j = 0; j < cols; j ++) {
        formatter.format ("     [%1$3d]", j);
    }
    sb.append (CR);
    for (int i = 0; i < rows; i ++) {
        formatter.format (" [%1$3d] ", i);
        for (int j = 0; j < cols; j ++) {
            formatter.format (" %1$ 6f", a [i] [j]);
        }
        sb.append (CR);
    }
    return sb.toString ();
}


public static RealMatrix computeDistanceMatrix (Point2D [] vertices) {
    int numVertices = vertices.length;
    RealMatrix distanceMatrix = null;
    try {
        distanceMatrix = MatrixUtils.createRealMatrix (numVertices, numVertices);
        for (int i = 0; i < numVertices; i ++) {
            distanceMatrix.setEntry (i, i, 0.0);
            for (int j = (i + 1); j < numVertices; j ++) {
                double distance = vertices [i].distance (vertices [j]);
                distanceMatrix.setEntry (i, j, distance);
                distanceMatrix.setEntry (j, i, distance);
            }
        }
    } catch (Exception e) {
        logger.severe (e.getCause ().toString () + " : " + e.toString () + " : " + e.getMessage ());
        e.printStackTrace ();
        distanceMatrix = MatrixUtils.createRealMatrix (0, 0);
    }
    return distanceMatrix;
}


-----Function Pair=97=-----==

public void paint (Graphics pGraphics) {
    Color lForegroundColor;
    int lX, lY;
    lForegroundColor = pGraphics.getColor ();
    for (lX = 0; lX < aColors.length; lX += 1) {
        for (lY = 0; lY < aColors.length; lY += 1) {
            if (aSelection [lX] [lY]) {
                pGraphics.setColor (lForegroundColor);
                pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING, BORDER_WIDTH + lY * CELL_SPACING, SELECTION_CELL_SIZE, SELECTION_CELL_SIZE);
                pGraphics.setColor (getBackground ());
                pGraphics.drawRect (BORDER_WIDTH + lX * CELL_SPACING + OUTER_CELL_OFFSET - 1, BORDER_WIDTH + lY * CELL_SPACING + OUTER_CELL_OFFSET - 1, OUTER_CELL_SIZE + 1, OUTER_CELL_SIZE + 1);
            }
            pGraphics.setColor (aColors [lX]);
            pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING + OUTER_CELL_OFFSET, BORDER_WIDTH + lY * CELL_SPACING + OUTER_CELL_OFFSET, OUTER_CELL_SIZE, OUTER_CELL_SIZE);
            pGraphics.setColor (aColors [lY]);
            pGraphics.fillRect (BORDER_WIDTH + lX * CELL_SPACING + INNER_CELL_OFFSET, BORDER_WIDTH + lY * CELL_SPACING + INNER_CELL_OFFSET, INNER_CELL_SIZE, INNER_CELL_SIZE);
        }
    }
}


public void reverseOrientation () {
    MeshVertex swapVert;
    float swapSmooth;
    int i, j;
    for (i = 0; i < usize / 2; i ++) {
        for (j = 0; j < vsize; j ++) {
            swapVert = vertex [i + usize * j];
            vertex [i + usize * j] = vertex [usize - 1 - i + usize * j];
            vertex [usize - 1 - i + usize * j] = swapVert;
        }
        swapSmooth = usmoothness [i];
        usmoothness [i] = usmoothness [usize - 1 - i];
        usmoothness [usize - 1 - i] = swapSmooth;
    }
    cachedMesh = null;
}


-----Function Pair=98=-----=1=

private static double [] [] getDistances (List < Sequence > seqs, PairwiseAligner aligner, TreeBuilderFactory.DistanceModel model, final ProgressListener progressListener) throws CannotBuildDistanceMatrixException {
    final int n = seqs.size ();
    double [] [] d;
    final long memoryRequired = ((long) n) * n * 8;
    if (n > 100) {
        final long maxMemory = Runtime.getRuntime ().maxMemory ();
        if (memoryRequired > maxMemory) {
            throw new CannotBuildDistanceMatrixException (getNotEnoughMemoryMessage (memoryRequired));
        }
    }
    try {
        d = new double [n] [n];
    } catch (OutOfMemoryError e) {
        throw new CannotBuildDistanceMatrixException (getNotEnoughMemoryMessage (memoryRequired));
    }
    CompositeProgressListener compositeProgressListener = new CompositeProgressListener (progressListener, getProgressIncrements (n));
    for (int i = 0; i < n; ++ i) {
        compositeProgressListener.beginSubtask ();
        CompositeProgressListener subComposite = new CompositeProgressListener (compositeProgressListener, (n - (i + 1)) * 2);
        for (int j = i + 1; j < n; ++ j) {
            subComposite.beginSubtask ();
            PairwiseAligner.Result result = aligner.doAlignment (seqs.get (i), seqs.get (j), subComposite);
            if (progressListener.isCanceled ()) return d;
            subComposite.beginSubtask ();
            BasicDistanceMatrix matrix;
            switch (model) {
                case F84 :
                    matrix = new F84DistanceMatrix (result.alignment, subComposite);
                    break;
                case HKY :
                    matrix = new HKYDistanceMatrix (result.alignment, subComposite);
                    break;
                case TamuraNei :
                    matrix = new TamuraNeiDistanceMatrix (result.alignment, subComposite);
                    break;
                case JukesCantor :
                default :
                    matrix = new JukesCantorDistanceMatrix (result.alignment, subComposite);
            }
            d [i] [j] = matrix.getDistances () [0] [1];
            d [j] [i] = d [i] [j];
        }
    }
    return d;
}


public CovarianceMatrix (short [] [] vectors) {
    int vectorLength = vectors [0].length;
    dimension = vectors.length;
    smallMatrix = new double [dimension] [dimension];
    for (int rowIndex = 0; rowIndex < smallMatrix.length; rowIndex ++) {
        for (int colIndex = 0; colIndex < rowIndex + 1; colIndex ++) {
            smallMatrix [rowIndex] [colIndex] = 0;
            for (int i = 0; i < vectorLength; i ++) {
                smallMatrix [rowIndex] [colIndex] += vectors [rowIndex] [i] * vectors [colIndex] [i];
            }
            smallMatrix [colIndex] [rowIndex] = smallMatrix [rowIndex] [colIndex];
        }
    }
    this.tridiagonalize ();
    this.performQLalgorithm ();
    ArrayList < EigenValueAndVector > tempList = new ArrayList < EigenValueAndVector > (dimension);
    for (int i = 0; i < dimension; i ++) {
        double [] eigenVector = new double [vectorLength];
        double length = 0;
        for (int j = 0; j < vectorLength; j ++) {
            double value = 0;
            for (int k = 0; k < vectors.length; k ++) {
                value += (vectors [k] [j]) * (smallMatrix [k] [i]);
            }
            eigenVector [j] = value;
            length += value * value;
        }
        length = Math.sqrt (length);
        for (int j = 0; j < eigenVector.length; j ++) {
            eigenVector [j] /= length;
        }
        EigenValueAndVector evv = new EigenValueAndVector ();
        evv.eigenVector = eigenVector;
        evv.eigenValue = eig [i];
        tempList.add (evv);
    }
    Collections.sort (tempList);
    eigenValueAndVectors = new EigenValueAndVector [dimension];
    tempList.toArray (eigenValueAndVectors);
}


-----Function Pair=99=-----==

public ComplexMatrix scalarMultiply (final Complex z) {
    final double real = z.real ();
    final double imag = z.imag ();
    final double arrayRe [] [] = new double [numRows] [numCols];
    final double arrayIm [] [] = new double [numRows] [numCols];
    for (int j, i = 0; i < numRows; i ++) {
        arrayRe [i] [0] = real * matrixRe [i] [0] - imag * matrixIm [i] [0];
        arrayIm [i] [0] = imag * matrixRe [i] [0] + real * matrixIm [i] [0];
        for (j = 1; j < numCols; j ++) {
            arrayRe [i] [j] = real * matrixRe [i] [j] - imag * matrixIm [i] [j];
            arrayIm [i] [j] = imag * matrixRe [i] [j] + real * matrixIm [i] [j];
        }
    }
    return new ComplexMatrix (arrayRe, arrayIm);
}


public ContingencyTable (double [] [] observed) {
    try {
        this.observed = observed;
        this.numberRow = observed.length;
        this.numberCol = observed [0].length;
        this.rowSumObserved = new int [this.numberRow];
        this.colSumObserved = new int [this.numberCol];
        double [] [] currentColumnArray = new double [this.numberCol] [this.numberRow];
        for (int i = 0; i < this.numberRow; i ++) {
            rowSumObserved [i] = (int) AnalysisUtility.sum (observed [i]);
            for (int j = 0; j < this.numberCol; j ++) {
                currentColumnArray [j] [i] = observed [i] [j];
                this.grandTotal += observed [i] [j];
            }
        }
        for (int j = 0; j < this.numberCol; j ++) {
            colSumObserved [j] = (int) AnalysisUtility.sum (currentColumnArray [j]);
        }
    } catch (DataIsEmptyException e) {
    } catch (NullPointerException e) {
    }
}


-----Function Pair=100=-----==

private void analysisExcel () {
    FileOutput fout = null;
    if (this.fileNumberingSet) {
        fout = new FileOutput (this.outputFilename, 'n');
    }
    else {
        fout = new FileOutput (this.outputFilename);
    }
    if (! pcaDone) this.pca ();
    if (! this.monteCarloDone) this.monteCarlo ();
    fout.println ("PRINCIPAL COMPONENT ANALYSIS");
    fout.println ("Program: PCA - Analysis Output");
    for (int i = 0; i < this.titleLines; i ++) fout.println (title [i]);
    Date d = new Date ();
    String day = DateFormat.getDateInstance ().format (d);
    String tim = DateFormat.getTimeInstance ().format (d);
    fout.println ("Program executed at " + tim + " on " + day);
    fout.println ();
    if (this.covRhoOption) {
        fout.println ("Covariance matrix used");
    }
    else {
        fout.println ("Correlation matrix used");
    }
    fout.println ();
    fout.println ("ALL EIGENVALUES");
    fout.printtab ("Component ");
    fout.printtab ("Unordered ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Proportion ");
    fout.printtab ("Cumulative ");
    fout.println ("Difference ");
    fout.printtab (" ");
    fout.printtab ("index");
    fout.printtab (" ");
    fout.printtab ("as % ");
    fout.printtab ("percentage ");
    fout.println (" ");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab (i + 1);
        fout.printtab ((this.eigenValueIndices [i] + 1));
        fout.printtab (Fmath.truncate (this.orderedEigenValues [i], this.trunc));
        fout.printtab (Fmath.truncate (this.proportionPercentage [i], this.trunc));
        fout.printtab (Fmath.truncate (this.cumulativePercentage [i], this.trunc));
        if (i < this.nItems - 1) {
            fout.printtab (Fmath.truncate ((this.orderedEigenValues [i] - this.orderedEigenValues [i + 1]), this.trunc));
        }
        else {
            fout.printtab (" ");
        }
        fout.printtab (" ");
        fout.println ();
    }
    fout.println ();
    int nMax = this.greaterThanOneLimit;
    if (nMax < this.meanCrossover) nMax = this.meanCrossover;
    if (nMax < this.percentileCrossover) nMax = this.percentileCrossover;
    fout.println ("EXTRACTED EIGENVALUES");
    fout.printtab (" ");
    fout.printtab ("Greater than unity");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab ("Greater than Monte Carlo Mean ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.println ("Greater than Monte Carlo Percentile");
    fout.printtab ("Component ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Proportion ");
    fout.printtab ("Cumulative ");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Proportion ");
    fout.printtab ("Cumulative ");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Proportion ");
    fout.printtab ("Cumulative ");
    fout.println (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab ("as % ");
    fout.printtab ("percentage ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab ("as % ");
    fout.printtab ("percentage ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab ("as % ");
    fout.printtab ("percentage ");
    fout.println (" ");
    int ii = 0;
    while (ii < nMax) {
        fout.printtab (ii + 1);
        if (ii < this.greaterThanOneLimit) {
            fout.printtab (Fmath.truncate (this.orderedEigenValues [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.proportionPercentage [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.cumulativePercentage [ii], this.trunc));
            fout.printtab (" ");
        }
        if (ii < this.meanCrossover) {
            fout.printtab (Fmath.truncate (this.orderedEigenValues [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.proportionPercentage [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.cumulativePercentage [ii], this.trunc));
            fout.printtab (" ");
        }
        if (ii < this.percentileCrossover) {
            fout.printtab (Fmath.truncate (this.orderedEigenValues [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.proportionPercentage [ii], this.trunc));
            fout.printtab (Fmath.truncate (this.cumulativePercentage [ii], this.trunc));
        }
        fout.println ();
        ii ++;
    }
    fout.println ();
    fout.println ("PARALLEL ANALYSIS");
    fout.println ("Number of simulations = " + this.nMonteCarlo);
    if (this.gaussianDeviates) {
        fout.println ("Gaussian random deviates used");
    }
    else {
        fout.println ("Uniform random deviates used");
    }
    fout.println ("Percentile value used = " + this.percentile + " %");
    fout.println ();
    fout.printtab ("Component ");
    fout.printtab ("Data ");
    fout.printtab ("Proportion ");
    fout.printtab ("Cumulative ");
    fout.printtab (" ");
    fout.printtab ("Data ");
    fout.printtab ("Monte Carlo ");
    fout.printtab ("Monte Carlo ");
    fout.println ("Monte Carlo ");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("as % ");
    fout.printtab ("percentage ");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Eigenvalue ");
    fout.printtab ("Eigenvalue ");
    fout.println ("Eigenvalue ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab (" ");
    fout.printtab ("Percentile ");
    fout.printtab ("Mean ");
    fout.println ("Standard Deviation ");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab (i + 1);
        fout.printtab (Fmath.truncate (this.orderedEigenValues [i], this.trunc));
        fout.printtab (Fmath.truncate (this.proportionPercentage [i], this.trunc));
        fout.printtab (Fmath.truncate (this.cumulativePercentage [i], this.trunc));
        fout.printtab (" ");
        fout.printtab (Fmath.truncate (this.orderedEigenValues [i], this.trunc));
        fout.printtab (Fmath.truncate (this.randomEigenValuesPercentiles [i], this.trunc));
        fout.printtab (Fmath.truncate (this.randomEigenValuesMeans [i], this.trunc));
        fout.println (Fmath.truncate (this.randomEigenValuesSDs [i], this.trunc));
    }
    fout.println ();
    fout.println ("CORRELATION MATRIX");
    fout.println ("Original component indices in parenthesis");
    fout.println ();
    fout.printtab (" ");
    fout.printtab ("component");
    for (int i = 0; i < this.nItems; i ++) fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
    fout.println ();
    fout.println ("component");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
        fout.printtab (" ");
        for (int j = 0; j < this.nItems; j ++) fout.printtab (Fmath.truncate (this.correlationMatrix.getElement (j, i), this.trunc));
        fout.println ();
    }
    fout.println ();
    fout.println ("COVARIANCE MATRIX");
    fout.println ("Original component indices in parenthesis");
    fout.println ();
    fout.printtab (" ");
    fout.printtab ("component");
    for (int i = 0; i < this.nItems; i ++) fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
    fout.println ();
    fout.println ("component");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
        fout.printtab (" ");
        for (int j = 0; j < this.nItems; j ++) fout.printtab (Fmath.truncate (this.covarianceMatrix.getElement (j, i), this.trunc));
        fout.println ();
    }
    fout.println ();
    fout.println ("EIGENVECTORS");
    fout.println ("Original component indices in parenthesis");
    fout.println ("Vector corresponding to an ordered eigenvalues in each row");
    fout.println ();
    fout.printtab (" ");
    fout.printtab ("component");
    for (int i = 0; i < this.nItems; i ++) fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
    fout.println ();
    fout.println ("component");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab ((i + 1) + " (" + (this.eigenValueIndices [i] + 1) + ")");
        fout.printtab (" ");
        for (int j = 0; j < this.nItems; j ++) fout.printtab (Fmath.truncate (this.orderedEigenVectorsAsRows [i] [j], this.trunc));
        fout.println ();
    }
    fout.println ();
    fout.println ("LOADING FACTORS");
    fout.println ("Original  indices in parenthesis");
    fout.println ("Loading factors corresponding to an ordered eigenvalues in each row");
    fout.println ();
    fout.printtab (" ");
    fout.printtab ("component");
    for (int i = 0; i < this.nItems; i ++) fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue");
    fout.printtab ("% Proportion");
    fout.println ("Cumulative %");
    fout.println ("factor");
    for (int i = 0; i < this.nItems; i ++) {
        fout.printtab ((i + 1) + " (" + (this.eigenValueIndices [i] + 1) + ")");
        fout.printtab (" ");
        for (int j = 0; j < this.nItems; j ++) fout.printtab (Fmath.truncate (this.loadingFactorsAsRows [i] [j], this.trunc));
        fout.printtab (" ");
        fout.printtab (Fmath.truncate (this.orderedEigenValues [i], this.trunc));
        fout.printtab (Fmath.truncate (proportionPercentage [i], this.trunc));
        fout.println (Fmath.truncate (cumulativePercentage [i], this.trunc));
    }
    fout.println ();
    fout.println ("ROTATED LOADING FACTORS");
    if (this.varimaxOption) {
        fout.println ("NORMAL VARIMAX");
    }
    else {
        fout.println ("RAW VARIMAX");
    }
    String message = "The ordered eigenvalues with Monte Carlo means and percentiles in parenthesis";
    message += "\n (Total number of eigenvalues = " + this.nItems + ")";
    int nDisplay = this.nItems;
    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    int screenHeight = screenSize.height;
    int nDisplayLimit = 20 * screenHeight / 800;
    if (nDisplay > nDisplay) nDisplay = nDisplayLimit;
    for (int i = 0; i < nDisplay; i ++) {
        message += "\n " + Fmath.truncate (this.orderedEigenValues [i], 4) + " (" + Fmath.truncate (this.randomEigenValuesMeans [i], 4) + "  " + Fmath.truncate (this.randomEigenValuesPercentiles [i], 4) + ")";
    }
    if (nDisplay < this.nItems) message += "\n . . . ";
    message += "\nEnter number of eigenvalues to be extracted";
    int nExtracted = this.greaterThanOneLimit;
    nExtracted = Db.readInt (message, nExtracted);
    this.varimaxRotation (nExtracted);
    fout.println ("Varimax rotation for " + nExtracted + " extracted factors");
    fout.println ("Rotated loading factors and eigenvalues scaled to ensure total 'rotated variance' matches unrotated variance for the extracted factors");
    fout.println ("Original  indices in parenthesis");
    fout.println ();
    fout.printtab (" ");
    fout.printtab ("component");
    for (int i = 0; i < this.nItems; i ++) fout.printtab ((this.eigenValueIndices [i] + 1) + " (" + (i + 1) + ")");
    fout.printtab (" ");
    fout.printtab ("Eigenvalue");
    fout.printtab ("% Proportion");
    fout.println ("Cumulative %");
    fout.println ("factor");
    for (int i = 0; i < nExtracted; i ++) {
        fout.printtab ((i + 1) + " (" + (this.eigenValueIndices [i] + 1) + ")");
        fout.printtab (" ");
        for (int j = 0; j < this.nItems; j ++) fout.printtab (Fmath.truncate (this.rotatedLoadingFactorsAsRows [i] [j], this.trunc));
        fout.printtab (" ");
        fout.printtab (Fmath.truncate (rotatedEigenValues [i], this.trunc));
        fout.printtab (Fmath.truncate (rotatedProportionPercentage [i], this.trunc));
        fout.println (Fmath.truncate (rotatedCumulativePercentage [i], this.trunc));
    }
    fout.println ();
    fout.close ();
}


static void identifyTargetGroups (Gene [] tars, Gene [] mods, boolean [] pos) {
    int n = ArrayUtils.countTrue (pos);
    double [] [] cm = getCorrelationMatrix (mods, pos);
    double [] [] cmt = getCorrelationMatrix (mods, tars, pos);
    double [] [] pmt = getCorrelationPvalMatrix (cmt, n);
    List < Integer > [] [] [] groups = new List [mods.length] [3] [];
    List < Integer > m1 = null;
    List < Integer > m2 = null;
    for (int i = 0; i < mods.length; i ++) {
        groups [i] [0] = new List [2];
        groups [i] [0] [0] = getAffectedTargets (cmt, pmt, cm, i, n, 1);
        groups [i] [0] [1] = getAffectedTargets (cmt, pmt, cm, i, n, - 1);
        List < Integer > [] [] halves = identifyTargetsTakeHalves (tars, mods, i, pos);
        groups [i] [1] = halves [1];
        groups [i] [2] = halves [0];
        if (mods [i].getSymbol ().equals ("VDR") && (n == 83 || n == 131)) {
        }
        if (mods [i].getSymbol ().equals ("ESR1") && n == 353) {
            m1 = groups [i] [0] [0];
        }
        if (mods [i].getSymbol ().equals ("AR") && n == 353) {
            m2 = groups [i] [0] [0];
        }
    }
    if (m1 != null && m2 != null) SetUtils.printVenn (new HashSet (m1), new HashSet (m2));
    int [] ord = getOrdering (groups);
    List < Gene > topMods = new ArrayList < Gene > ();
    System.out.println ("NucRec\tp\tn\tp-\tn-\tp+\tn+");
    for (int i : ord) {
        if (topMods.size () < 10) topMods.add (mods [i]);
        String s = mods [i].getSymbol ();
        if (s.length () < 4) s += "  ";
        System.out.println (s + "\t" + groups [i] [0] [0].size () + "\t" + groups [i] [0] [1].size () + "\t" + groups [i] [1] [0].size () + "\t" + groups [i] [1] [1].size () + "\t" + groups [i] [2] [0].size () + "\t" + groups [i] [2] [1].size ());
    }
}


-----Function Pair=101=-----==

public Matrix mul (Matrix b) {
    Matrix c = new Matrix (rowCount, b.columnCount);
    int i, j, k;
    double cij;
    for (i = 0; i < rowCount; i ++) {
        for (j = 0; j < b.columnCount; j ++) {
            cij = 0.0;
            for (k = 0; k < b.rowCount; k ++) {
                cij += matrix [i] [k] * b.matrix [k] [j];
            }
            c.matrix [i] [j] = cij;
        }
    }
    return c;
}


public static Vector split1 (String array) {
    int startIndex;
    int endIndex;
    String tempString = new String (array);
    String searchedStr = new String ();
    Vector splittedVec = new Vector ();
    while (true) {
        if ((startIndex = tempString.indexOf ('{')) == - 1) break;
        endIndex = tempString.indexOf ('}');
        searchedStr = tempString.substring (startIndex + 1, endIndex);
        splittedVec.add (searchedStr);
        tempString = tempString.substring (endIndex + 1);
    }
    return splittedVec;
}


-----Function Pair=102=-----==

public double [] projectSnp (double [] parents, int pos, int [] popIndex) {
    Object [] [] markers = theAGPMap.getInterval (chromosome, pos);
    int left = AGPMap.getMarkerPosition (markers [0]);
    if (left == - 1) left = 0;
    int right = AGPMap.getMarkerPosition (markers [1]);
    if (right == - 1) right = chromosomeLength [chromosome - 1];
    double pd = ((double) (pos - left)) / ((double) (right - left));
    int leftmarker = AGPMap.getMarkerNumber (markers [0]);
    if (leftmarker == - 1) leftmarker = 0;
    else leftmarker = leftmarker - firstMarker + 1;
    int rightmarker = AGPMap.getMarkerNumber (markers [1]);
    if (rightmarker == - 1) rightmarker = maxmarker;
    else rightmarker = rightmarker - firstMarker + 1;
    int nSamples = residualSamples.length;
    double [] snpvalues = new double [nSamples];
    for (int i = 0; i < nSamples; i ++) {
        snpvalues [i] = genotypes [sampleIndex [i]] [leftmarker] * (1 - pd) + genotypes [sampleIndex [i]] [rightmarker] * pd;
        snpvalues [i] = snpvalues [i] * parents [popIndex [i]];
    }
    return snpvalues;
}


public static double [] [] inverse (final double [] [] mat) {
    final int m = mat.length;
    final int n = mat [0].length;
    int r, c;
    int k = 1;
    final double [] [] ak = new double [m] [1];
    double [] [] dk, ck, bk;
    double [] [] R_plus;
    for (r = 0; r < m; r ++) {
        ak [r] [0] = mat [r] [0];
    }
    if (! equals (ak, 0.0)) {
        R_plus = mul (transpose (ak), (1.0 / (dot (ak, ak))));
    }
    else {
        R_plus = new double [1] [m];
    }
    while (k < n) {
        for (r = 0; r < m; r ++) {
            ak [r] [0] = mat [r] [k];
        }
        dk = matrixProd (R_plus, ak);
        final double [] [] T = new double [m] [k];
        for (r = 0; r < m; r ++) {
            for (c = 0; c < k; c ++) {
                T [r] [c] = mat [r] [c];
            }
        }
        ck = diff (ak, matrixProd (T, dk));
        if (! equals (ck, 0.0)) {
            bk = mul (transpose (ck), 1.0 / dot (ck, ck));
        }
        else {
            bk = matrixProd (mul (transpose (dk), 1.0 / (1.0 + dot (dk, dk))), R_plus);
        }
        final double [] [] N = diff (R_plus, matrixProd (dk, bk));
        R_plus = new double [N.length + 1] [N [0].length];
        for (r = 0; r < N.length; r ++) {
            for (c = 0; c < N [0].length; c ++) {
                R_plus [r] [c] = N [r] [c];
            }
        }
        for (c = 0; c < N [0].length; c ++) {
            R_plus [R_plus.length - 1] [c] = bk [0] [c];
        }
        k ++;
    }
    return R_plus;
}


-----Function Pair=103=-----==

public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


void addRRset (Name name, Message response, RRset rrset, int section, int flags) {
    for (int s = 1; s <= section; s ++) if (response.findRRset (name, rrset.getType (), s)) return;
    if ((flags & FLAG_SIGONLY) == 0) {
        Iterator it = rrset.rrs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
    if ((flags & (FLAG_SIGONLY | FLAG_DNSSECOK)) != 0) {
        Iterator it = rrset.sigs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
}


-----Function Pair=104=-----==

public void go () {
    memPFrame = pframe;
    subfr = 0;
    if (! rev) {
        if (pframe < (game.npframes - 1)) {
            pframe ++;
        }
        else {
            if (loop) {
                pframe = 0;
            }
            else {
                pframe = game.npframes - 1;
            }
        }
    }
    else {
        if (pframe > 0) {
            pframe --;
        }
        else {
            if (loop) pframe = game.npframes - 1;
            else {
                pframe = 0;
            }
        }
    }
}


SqueezeCube (BufferedReader br, BufferedWriter bw) {
    this.br = br;
    this.bw = bw;
    try {
        readTitleLines ();
        readAtomCountAndOriginLine ();
        readVolumetricVectorLines ();
        readAtomLines ();
        readOptionalMolecularOrbitalLine ();
        readVolumetricData ();
        squeezeVolumetricData (0.001f);
        writeHeader ();
        writeVolumetricData ();
        bw.flush ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=105=-----==

ConcreteProject (String filename) {
    this.filename = filename;
    Workbench.addToTab ("Project", new ProjectTab (this), false);
    project_clock = 0;
    StringTokenizer token;
    int nr_comps = 0;
    int nr_connects = 0;
    try {
        RandomAccessFile project_file = new RandomAccessFile (filename, "r");
        String line = " ";
        line = project_file.readLine ();
        line = project_file.readLine ();
        if (line.indexOf ("Version") > 0) {
            String verparts [] = line.split (" ");
            version = Double.parseDouble (verparts [2]);
            line = project_file.readLine ();
        }
        line = project_file.readLine ();
        while (! (line.charAt (0) == '#')) {
            line = project_file.readLine ();
            nr_comps ++;
        }
        line = project_file.readLine ();
        while (! (line.charAt (0) == '#')) {
            line = project_file.readLine ();
            nr_connects ++;
        }
        comps = new Component [nr_comps];
        connects = new Connection [nr_connects];
        comp_types = new String [nr_comps];
        comp_data = new String [nr_comps];
        project_file.seek (0);
        while (! line.equals ("# Components:")) line = project_file.readLine ();
        for (int i = 0; i < nr_comps; i ++) {
            token = new StringTokenizer (project_file.readLine ());
            comp_types [i] = token.nextToken ();
            if (token.hasMoreTokens ()) comp_data [i] = token.nextToken ();
            while (token.hasMoreTokens ()) comp_data [i] = comp_data [i] + " " + token.nextToken ();
        }
        createComponents ();
        while (! line.equals ("# Connections:")) line = project_file.readLine ();
        for (int i = 0; i < nr_connects; i ++) {
            token = new StringTokenizer (project_file.readLine (), ":,", false);
            String src = token.nextToken ();
            String src_pin = token.nextToken ();
            String dest = token.nextToken ();
            String dest_pin = token.nextToken ();
            connects [i] = new Connection (comps [Integer.valueOf (src).intValue ()], Integer.valueOf (src_pin).intValue (), comps [Integer.valueOf (dest).intValue ()], Integer.valueOf (dest_pin).intValue ());
        }
        if (version >= 1.0) {
            while (! line.equals ("# Connection info:")) line = project_file.readLine ();
            for (int i = 0; i < nr_connects; i ++) connectioninfo.addElement (project_file.readLine ());
            infowindow = new ConnectionInfo (connectioninfo);
        }
    } catch (IOException e) {
        System.out.println ("Error reading project file");
    }
    bottompanel = new BottomPanel (this, filename);
    postPinUpdate (null);
}


private void parseSimpleProtFile (String fname) {
    try {
        BufferedReader inputStream = new BufferedReader (new FileReader (fname));
        String line;
        String seperators = ",\t;: ";
        String sep = null;
        line = inputStream.readLine ();
        int col = 0;
        int whichsep = 0;
        StringTokenizer tokens = null;
        while ((col <= 1) && (whichsep < seperators.length ())) {
            sep = seperators.substring (whichsep, whichsep + 1);
            tokens = new StringTokenizer (line, sep);
            col = tokens.countTokens ();
            whichsep ++;
        }
        if (col <= 1) {
            System.out.println ("Header line in " + fname + " does not contain identifiable seperators (tried comma, tab, semicolon, colon, space) - quitting");
            System.exit (1);
        }
        for (; col -- > 0;) {
            hdrNames.add (tokens.nextToken ());
        }
        Pattern pat = Pattern.compile ("(\\D+)(\\d+)");
        col = hdrNames.size ();
        Vector < String > tmp_groupNames = new Vector < String > ();
        for (int replicate = 2; replicate -- > 0;) {
            for (; col -- > 1;) {
                Matcher anum2 = pat.matcher (hdrNames.get (col));
                Boolean match2 = anum2.matches ();
                Matcher anum1 = pat.matcher (hdrNames.get (col - 1));
                nReplicates [replicate] += 1;
                if ((! anum1.matches ()) || (! match2) || (anum1.groupCount () != 2) || (anum2.groupCount () != 2) || (! anum1.group (1).equals (anum2.group (1)))) {
                    tmp_groupNames.add (anum2.group (1));
                    break;
                }
            }
        }
        for (int i = tmp_groupNames.size (); i -- > 0;) {
            groupNames.add (tmp_groupNames.get (i));
        }
        while (col < hdrNames.size ()) {
            hdrNames.remove (col);
        }
        int minReplicates = Math.min (nReplicates [0], nReplicates [1]);
        while ((line = inputStream.readLine ()) != null) {
            tokens = new StringTokenizer (line, sep);
            if (tokens.countTokens () != (nReplicates [0] + nReplicates [1] + hdrNames.size ())) {
                continue;
            }
            Vector < String > proteinInfo = new Vector < String > ();
            for (int h = hdrNames.size (); h -- > 0;) {
                proteinInfo.add (tokens.nextToken ());
            }
            double [] counts = new double [2 * minReplicates];
            double [] averages = {0, 0};
            int c = 0;
            for (int rep = 0; rep < 2; rep ++) {
                for (int i = 0; i < nReplicates [rep]; i ++) {
                    if (i < minReplicates) {
                        counts [c] = Double.parseDouble (tokens.nextToken ());
                        averages [rep] += counts [c ++];
                    }
                    else {
                        Double.parseDouble (tokens.nextToken ());
                    }
                }
            }
            proteinInfo.add (Double.toString (averages [0] / minReplicates));
            proteinInfo.add (Double.toString (averages [1] / minReplicates));
            Protein p = new Protein (proteinInfo, counts);
            proteinList.add (p);
        }
        inputStream.close ();
        hdrNames.add (this.groupNames.get (0) + " avgSC");
        hdrNames.add (this.groupNames.get (1) + " avgSC");
    } catch (IOException e) {
        System.out.println ("Error opening file " + fname + ": " + e.toString ());
        System.exit (1);
    }
}


-----Function Pair=106=-----==

public LiferaySQL (String sql) {
    System.out.println (sql);
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        Properties props = new Properties ();
        try {
            props.load (new FileInputStream (new File ("db.properties")));
        } catch (IOException ioe) {
            ioe.printStackTrace ();
            return;
        }
        String driver = props.getProperty ("driver");
        String url = props.getProperty ("url");
        String user = props.getProperty ("user");
        String password = props.getProperty ("password");
        Class.forName (driver);
        con = DriverManager.getConnection (url, user, password);
        con.setAutoCommit (false);
        File sqlFile = new File (sql);
        if (sqlFile.exists ()) {
            StringBuffer sb = new StringBuffer ();
            BufferedReader br = new BufferedReader (new FileReader (sqlFile));
            String line = null;
            while ((line = br.readLine ()) != null) {
                if (! line.startsWith ("--")) {
                    sb.append (line);
                }
            }
            br.close ();
            StringTokenizer st = new StringTokenizer (sb.toString (), ";");
            while (st.hasMoreTokens ()) {
                line = st.nextToken ();
                System.out.println (line + ";");
                ps = con.prepareStatement (line);
                ps.executeUpdate ();
            }
        }
        else if (sql.toLowerCase ().startsWith ("insert ") || sql.toLowerCase ().startsWith ("update ")) {
            ps = con.prepareStatement (sql);
            ps.executeUpdate (sql);
        }
        else {
            ps = con.prepareStatement (sql);
            rs = ps.executeQuery (sql);
            ResultSetMetaData rsmd = rs.getMetaData ();
            int [] width = new int [rsmd.getColumnCount () + 1];
            StringBuffer sb = new StringBuffer ();
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                width [i] = rsmd.getColumnLabel (i).length ();
            }
            List results = new ArrayList ();
            while (rs.next ()) {
                String [] rowResult = new String [rsmd.getColumnCount () + 1];
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    Object obj = rs.getObject (i);
                    if (obj != null) {
                        rowResult [i] = obj.toString ();
                        int objWidth = obj.toString ().length ();
                        if (width [i] < objWidth) {
                            width [i] = objWidth;
                        }
                    }
                    else {
                        rowResult [i] = "";
                    }
                }
                results.add (rowResult);
            }
            _printLine (rsmd, width, sb);
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                String label = rsmd.getColumnLabel (i);
                sb.append ("| ").append (label);
                for (int j = 0; j <= width [i] - label.length (); j ++) {
                    sb.append (" ");
                }
            }
            sb.append ("|\n");
            _printLine (rsmd, width, sb);
            Iterator itr = results.iterator ();
            while (itr.hasNext ()) {
                String [] rowResult = (String []) itr.next ();
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    String s = rowResult [i];
                    sb.append ("| ").append (s);
                    for (int j = 0; j <= width [i] - s.length (); j ++) {
                        sb.append (" ");
                    }
                }
                sb.append ("|\n");
            }
            _printLine (rsmd, width, sb);
            System.out.println (sb.toString ());
        }
        con.commit ();
    } catch (SQLException sqle) {
        while (sqle != null) {
            sqle.printStackTrace ();
            sqle = sqle.getNextException ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        _cleanUp (con, ps, rs);
    }
}


void processForeachRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variable in FOREACH");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in FOREACH");
    String file_name = pst.nextToken ();
    String select = null;
    String start = null;
    String end = null;
    boolean inRange = false;
    if (pst.hasMoreTokens ()) {
        select = pst.nextToken ();
        if (! pst.hasMoreTokens ()) throw new IOException ("Missing field value in FOREACH");
        String fval = pst.nextToken ();
        int dotdot = fval.indexOf ("..");
        if (dotdot != - 1 && dotdot == fval.lastIndexOf ("..")) {
            start = fval.substring (0, dotdot);
            end = fval.substring (dotdot + 2);
        }
        else {
            start = fval;
        }
    }
    if (DEBUG) System.out.println ("doing foreach with varname " + var_name + " on data file :" + file_name);
    if (DEBUG && select != null) {
        System.out.print ("   selecting records with " + select);
        if (end == null) System.out.println (" equal to \"" + start + "\"");
        else System.out.println (" between \"" + start + "\" and \"" + end + "\"");
    }
    BufferedReader data;
    try {
        data = new BufferedReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        data = new BufferedReader (new FileReader (inDir + file_name));
    }
    Vector fields_v = new Vector ();
    Vector fpl_v = new Vector ();
    for (String inLine = getNextLine (data); (inLine != null && inLine.length () != 0); inLine = getNextLine (data)) {
        StringTokenizer st = new StringTokenizer (inLine);
        fpl_v.addElement (new Integer (st.countTokens ()));
        while (st.hasMoreTokens ()) {
            String tok = st.nextToken ();
            if (DEBUG) System.out.println ("read field " + fields_v.size () + " :" + tok);
            fields_v.addElement (tok);
        }
    }
    fields_v.addElement (indexField);
    int [] fieldsPerLine = new int [fpl_v.size ()];
    for (int i = 0; i < fieldsPerLine.length; i ++) fieldsPerLine [i] = ((Integer) fpl_v.elementAt (i)).intValue ();
    String [] fields = new String [fields_v.size ()];
    for (int i = 0; i < fields.length; i ++) fields [i] = (String) fields_v.elementAt (i);
    dataFileLoop : for (int curField = 0;; curField ++) {
        int i = 0;
        String [] fieldData = new String [fields.length];
        for (int j = 0; j < fieldsPerLine.length; j ++) {
            String line = getNextLine (data);
            if (line == null) break dataFileLoop;
            if (fieldsPerLine [j] == 1) {
                if (DEBUG) System.out.println ("read field " + fields [i] + " :" + line);
                fieldData [i ++] = line;
            }
            else {
                if (DEBUG) System.out.println ("reading " + fieldsPerLine [j] + " fields");
                StringTokenizer st = new StringTokenizer (line);
                try {
                    for (int k = 0; k < fieldsPerLine [j]; k ++) {
                        String tok = st.nextToken ();
                        if (DEBUG) System.out.println ("read field " + fields [i] + ": " + tok);
                        fieldData [i ++] = tok;
                    }
                } catch (NoSuchElementException x) {
                    throw new IOException ("Missing field " + fields [i]);
                }
            }
        }
        if (fieldsPerLine.length != 1) getNextLine (data);
        fieldData [i ++] = Integer.toString (curField);
        if (select != null) {
            for (int j = 0; j < fields.length; j ++) {
                if (DEBUG) System.out.println ("checking if select is field " + fields [j]);
                if (select.equals (fields [j])) {
                    String value = fieldData [j];
                    if (value.equals (start)) inRange = true;
                    else if (end == null) inRange = false;
                    else if (value.equals (end)) end = null;
                    if (DEBUG) System.out.println ("record in range; including");
                    break;
                }
            }
            if (! inRange) break dataFileLoop;
        }
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name, fields, fieldData);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name, fields, fieldData);
                processTemplateRegion (newRegion);
            }
        }
    }
    data.close ();
}


-----Function Pair=107=-----==

void addAuthority (Message response, Name name, Zone zone) {
    if (response.getHeader ().getCount (Section.ANSWER) > 0 || zone == null) {
        RRset nsRecords = findExactMatch (name, Type.NS, DClass.IN, false);
        if (nsRecords == null) {
            if (zone != null) nsRecords = zone.getNS ();
            else {
                RRset [] rrsets;
                rrsets = cache.findRecords (Name.root, Type.NS, DClass.IN);
                if (rrsets == null) nsRecords = null;
                else nsRecords = rrsets [0];
            }
        }
        if (nsRecords == null) return;
        Enumeration e = nsRecords.rrs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (response.findRecord (r, Section.ANSWER) == false) response.addRecord (r, Section.AUTHORITY);
        }
        e = nsRecords.sigs ();
        while (e.hasMoreElements ()) {
            Record r = (Record) e.nextElement ();
            if (response.findRecord (r, Section.ANSWER) == false) response.addRecord (r, Section.AUTHORITY);
        }
    }
    else {
        SOARecord soa = (SOARecord) zone.getSOA ();
        response.addRecord (soa, Section.AUTHORITY);
    }
}


public static void execute (String documentFolderPath) throws IOException {
    int i, fcnt = 0;
    init ();
    File documentFolder = new File (documentFolderPath);
    File [] fullFileList = documentFolder.listFiles ();
    for (i = 0; i < fullFileList.length; i ++) if (fullFileList [i].isFile ()) fcnt ++;
    fileList = new File [fcnt];
    for (i = 0, fcnt = 0; i < fullFileList.length; i ++) if (fullFileList [i].isFile ()) fileList [fcnt ++] = fullFileList [i];
    similarities = new HashMap [fileList.length];
    for (i = 0; i < fileList.length; i ++) similarities [i] = new HashMap ();
    documentCount = fileList.length;
    for (i = 0; i < fileList.length; i ++) getWordsFromFile (fileList [i], i);
    normalizetempImpactValues ();
    System.out.println ("getWordsFromFile is Finished!!");
    System.out.println ("Total File Count: " + fileList.length);
    for (i = 0; i < fileList.length; i ++) {
        if (i % 10 == 0) System.out.println (i + "th file is being processed!!!");
        processFile (fileList [i], i);
    }
    report ();
}


-----Function Pair=108=-----==

public void testLogWritableNonExistent () throws Exception {
    File logDir = new File ("testLogWritableNonExistent");
    if (logDir.exists ()) {
        for (File f : logDir.listFiles ()) {
            f.delete ();
        }
        logDir.delete ();
    }
    assertFalse ("Log dir does not exist", logDir.exists ());
    DiskLog log = new DiskLog ();
    log.setReadOnly (false);
    log.setLogDir (logDir.getAbsolutePath ());
    log.prepare ();
    log.release ();
    assertTrue ("Log dir exists", logDir.exists () && logDir.isDirectory ());
}


void run (Collection < Example > examples) throws IOException {
    for (Example e : examples) {
        startExample (e);
        if (showFiles) {
            showFile (e, e.infoFile);
            Set < File > srcFiles = new TreeSet < File > (e.srcFiles);
            srcFiles.remove (e.infoFile);
            showFiles (e, srcFiles);
            showFiles (e, e.srcPathFiles);
            showFiles (e, e.procFiles);
            showFiles (e, e.supportFiles);
        }
        run (e);
    }
}


-----Function Pair=109=-----==

private void computeNumbers (boolean mode) {
    if (mode) {
        if (executionNumber == 0) executionNumber = 1;
        else executionNumber ++;
        replayNumber = 1;
    }
    else {
        String path = referenceScenario.getLogLink ();
        String [] decompname = path.split ("_");
        int numexec = new Integer (decompname [1]);
        int numrepl = 0;
        executionNumber = numexec;
        File res = new File (getPathRes ());
        if (res.isDirectory ()) {
            File [] tabFile = res.listFiles ();
            for (int i = 0; i < tabFile.length; i ++) {
                File file = tabFile [i];
                if (file.isDirectory ()) {
                    String name = file.getName ();
                    String [] decompnamecomp = name.split ("_");
                    int numexeccomp = new Integer (decompnamecomp [1]);
                    int numreplcomp = new Integer (decompnamecomp [2]);
                    if (numexec == numexeccomp) {
                        if (numreplcomp > numrepl) {
                            numrepl = numreplcomp;
                        }
                    }
                }
            }
        }
        replayNumber = numrepl;
        replayNumber ++;
    }
}


public void save () throws SSHException, ScenarioException {
    String pathRoot = getPathRoot ();
    String pathTmp = pathRoot + "tmp";
    File fileTmp = new File (pathTmp);
    fileTmp.mkdir ();
    SSHManager.getLog (pathTmp, Config.getString ("pathResRemoteLinux"), currentScenario.getPcList ());
    String pathRes = getPathRes ();
    String pathExec = pathRes + "exec_" + executionNumber + "_" + replayNumber + "/";
    currentScenario.setLogLink (pathExec);
    writeCurrentScenario (pathExec);
    File [] tabFile = fileTmp.listFiles ();
    int ff = 0;
    while (ff < tabFile.length) {
        File source = tabFile [ff];
        if (source.isFile ()) {
            String nameFile = source.getName ();
            int num = Character.getNumericValue (nameFile.charAt (14));
            File destination = new File (pathExec + "host" + num + "/" + nameFile);
            copier (source, destination);
            source.delete ();
        }
        ff ++;
    }
    fileTmp.delete ();
}


-----Function Pair=110=-----==

private void removeFileList (FileListFileSystem fileSystem, VFile selectedFile, VFile [] markedFiles) throws VFSException {
    JFDDialog dialog = null;
    try {
        dialog = getJFD ().createDialog ();
        dialog.setTitle (JFDResource.LABELS.getString ("title_delete"));
        dialog.addMessage (JFDResource.MESSAGES.getString ("message_delete_filelist_file"));
        dialog.addButton (OK, JFDResource.LABELS.getString ("ok"), 'y', true);
        dialog.addButton (CANCEL, JFDResource.LABELS.getString ("cancel"), 'n', false);
        dialog.pack ();
        dialog.setVisible (true);
        String answer = dialog.getButtonAnswer ();
        if (answer == null || CANCEL.equals (answer)) {
            return;
        }
        if (markedFiles == null || markedFiles.length == 0) {
            markedFiles = new VFile [1];
            markedFiles [0] = selectedFile;
        }
        fileSystem.initFileTree (this);
        for (int i = 0; i < markedFiles.length; i ++) {
            fileSystem.removeFile (markedFiles [i]);
        }
        fileSystem.save ();
    } finally {
        if (dialog != null) {
            dialog.dispose ();
        }
    }
}


public static void getContents (final Reader reader, final OutputStream outputStream, final long maxLength) {
    if (reader == null) {
        return;
    }
    try {
        int total = 0;
        char [] chars = new char [1024];
        int read = reader.read (chars);
        while (read > - 1 && total < maxLength) {
            total += read;
            byte [] bytes = new byte [read];
            for (int i = 0; i < read; i ++) {
                bytes [i] = (byte) chars [i];
            }
            outputStream.write (bytes, 0, bytes.length);
            read = reader.read (chars);
        }
    } catch (Exception e) {
        LOGGER.error ("Exception accessing the file contents.", e);
    } finally {
        try {
            reader.close ();
        } catch (Exception e) {
            LOGGER.error ("Exception closing input stream " + reader, e);
        }
    }
}


-----Function Pair=111=-----==

protected static Vector < Country > getShipToLocations (AuctionPlatform auctionPlatform, AuctionPlatformSite auctionPlatformSite) throws DatabaseInitiationException {
    insureStatus ();
    Vector < Country > result = new Vector < Country > ();
    try {
        Statement statement = PLATFORMDATACONNECTION.createStatement ();
        if (hasStaticData (statement, ExistingStaticData.TYPE_SHIPTOLOCATIONS, auctionPlatform, auctionPlatformSite)) {
            if (statement.execute ("select code from " + TABLE_SHIPTOLOCATIONS + " where apid=" + auctionPlatform.getId () + " and apsid=" + auctionPlatformSite.getCode ())) {
                ResultSet resultSet = statement.getResultSet ();
                while (resultSet.next ()) {
                    result.add (new Country (resultSet.getInt (1)));
                }
                resultSet.close ();
            }
            statement.close ();
            return result;
        }
        else {
            statement.close ();
            return null;
        }
    } catch (SQLException sqlException) {
        Logger.log (sqlException);
        return null;
    }
}


protected Map < File, List < File > > setupStoresAndActions () throws ConfigException, StoreException {
    Map < File, List < File > > newFiles = new HashMap < File, List < File > > ();
    for (File mediaDirLoc : getController ().getMediaDirectories ()) {
        for (IAction action : getController ().getMediaDirectory (mediaDirLoc).getActions ()) {
            action.setTestMode (getController ().isTestRun ());
        }
        newFiles.put (mediaDirLoc, new ArrayList < File > ());
    }
    for (File mediaDirLoc : getController ().getMediaDirectories ()) {
        for (IStore store : getController ().getMediaDirectory (mediaDirLoc).getStores ()) {
            store.init (getController (), getController ().getNativeFolder ());
        }
    }
    return newFiles;
}


-----Function Pair=112=-----==

public void copyFile (File sourceFile, String toDir, boolean create, boolean overwrite) throws FileNotFoundException, IOException {
    FileInputStream source = null;
    FileOutputStream destination = null;
    byte [] buffer;
    int bytes_read;
    File toFile = new File (toDir);
    if (create && ! toFile.exists ()) toFile.mkdirs ();
    if (toFile.exists ()) {
        File destFile = new File (toDir + "/" + sourceFile.getName ());
        try {
            if (! destFile.exists () || overwrite) {
                source = new FileInputStream (sourceFile);
                destination = new FileOutputStream (destFile);
                buffer = new byte [1024];
                while (true) {
                    bytes_read = source.read (buffer);
                    if (bytes_read == - 1) break;
                    destination.write (buffer, 0, bytes_read);
                }
            }
        } catch (Exception exx) {
            exx.printStackTrace ();
        } finally {
            if (source != null) try {
                source.close ();
            } catch (IOException e) {
            }
            if (destination != null) try {
                destination.close ();
            } catch (IOException e) {
            }
        }
    }
}


protected void copyFile (File src, File dest) throws IOException {
    if (src.exists ()) {
        if (src.isDirectory ()) {
            dest.mkdir ();
            File children [] = src.listFiles ();
            for (int i = 0; i < children.length; i ++) {
                File srcChild = children [i];
                File destChild = new File (dest, srcChild.getName ());
                copyFile (srcChild, destChild);
            }
        }
        else {
            dest.createNewFile ();
            OutputStream out = new FileOutputStream (dest);
            InputStream in = new FileInputStream (src);
            int c;
            while ((c = in.read ()) >= 0) {
                out.write (c);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=113=-----==

public static void sendInputStreamToOutputStream (final int pBufferSize, final InputStream pInput, final OutputStream pOutput) throws IOException {
    final BufferedInputStream bis = new BufferedInputStream (pInput);
    final BufferedOutputStream bos = new BufferedOutputStream (pOutput);
    try {
        final byte [] buff = new byte [pBufferSize];
        int bytesRead;
        while (- 1 != (bytesRead = bis.read (buff, 0, buff.length))) {
            bos.write (buff, 0, bytesRead);
            bos.flush ();
        }
    } finally {
        pInput.close ();
        if (bis != null) bis.close ();
        if (bos != null) bos.close ();
    }
    return;
}


public static void copyFile (File source, File dest) throws IOException {
    if (! dest.exists ()) {
        dest.createNewFile ();
    }
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (source);
        out = new FileOutputStream (dest);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
    } finally {
        in.close ();
        out.close ();
    }
}


-----Function Pair=114=-----==

public void testAllGroups () throws LDAPException {
    LDAPConnection con = new LDAPConnection ();
    con.connect ("localhost", 50983);
    Util util = new Util ();
    LDAPSearchResults res = con.search ("ou=groups,dc=compinternal,dc=com", 2, "(objectClass=*)", new String [0], false);
    LDAPAttributeSet attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("objectClass", "organizationalUnit"));
    attribs.add (new LDAPAttribute ("ou", "groups"));
    LDAPEntry entry = new LDAPEntry ("ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("base entry failed");
    }
    attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("uniqueMember", "uid=jjeffords,dc=nam,dc=compinternal,dc=com"));
    attribs.add (new LDAPAttribute ("objectClass", "groupOfUniquenames"));
    attribs.add (new LDAPAttribute ("cn", "Admins"));
    entry = new LDAPEntry ("cn=Admins,ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    LDAPEntry entry2 = res.next ();
    if (! util.compareEntry (entry, entry2)) {
        fail ("1st entry failed " + entry2.toString ());
    }
    attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("uniqueMember", "uid=jjackson,dc=nam,dc=compinternal,dc=com"));
    attribs.getAttribute ("uniqueMember").addValue ("uid=aalberts,dc=nam,dc=compinternal,dc=com");
    attribs.add (new LDAPAttribute ("objectClass", "groupOfUniqueNames"));
    attribs.add (new LDAPAttribute ("cn", "Users"));
    entry = new LDAPEntry ("cn=Users,ou=groups,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("2st entry failed");
    }
    if (res.hasMore ()) {
        fail ("too many entries");
    }
    con.disconnect ();
}


public void finished () {
    _processingDialog.setVisible (false);
    _processingDialog.dispose ();
    JarOptionsDialog.this.setEnabled (true);
    if (_success) {
        if (_exceptions.size () > 0) {
            ScrollableListDialog < String > dialog = new ScrollableListDialog.Builder < String > ().setOwner (JarOptionsDialog.this).setTitle ("Problems Creating Jar").setText ("There were problems creating this jar file, but DrJava was probably able to recover.").setItems (new ArrayList < String > (_exceptions)).setMessageType (JOptionPane.ERROR_MESSAGE).build ();
            Utilities.setPopupLoc (dialog, JarOptionsDialog.this);
            dialog.showDialog ();
        }
        if ((_jarAll.isSelected () || _jarClasses.isSelected ()) && _makeExecutable.isSelected ()) {
            Object [] options = {"OK", "Run"};
            int res = JOptionPane.showOptionDialog (JarOptionsDialog.this, "Jar file successfully written to '" + _jarFileSelector.getFileFromField ().getName () + "'", "Jar Creation Successful", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, options, options [0]);
            JarOptionsDialog.this.setVisible (false);
            if (1 == res) {
                SwingWorker jarRunner = new SwingWorker () {
                    public Object construct () {
                        try {
                            File cp = _jarFileSelector.getFileFromField ();
                            File wd = cp.getParentFile ();
                            Process p = JVMBuilder.DEFAULT.classPath (cp).directory (wd).start (_mainClassField.getText ());
                            ConcurrentUtil.copyProcessErr (p, System.err);
                            ConcurrentUtil.copyProcessOut (p, System.out);
                            p.waitFor ();
                            JOptionPane.showMessageDialog (JarOptionsDialog.this, "Execution of jar file terminated (exit value = " + p.exitValue () + ")", "Execution terminated.", JOptionPane.INFORMATION_MESSAGE);
                        } catch (Exception e) {
                            JOptionPane.showMessageDialog (JarOptionsDialog.this, "An error occured while running the jar file: \n" + e, "Error", JOptionPane.ERROR_MESSAGE);
                        } finally {
                            JarOptionsDialog.this.setVisible (false);
                        }
                        return null;
                    }
                }
                ;
                jarRunner.start ();
            }
        }
        else {
            JOptionPane.showMessageDialog (JarOptionsDialog.this, "Jar file successfully written to '" + _jarFileSelector.getFileFromField ().getName () + "'", "Jar Creation Successful", JOptionPane.INFORMATION_MESSAGE);
            JarOptionsDialog.this.setVisible (false);
        }
    }
    else {
        ManifestWriter mw = new ManifestWriter ();
        if (_makeExecutable.isSelected ()) mw.setMainClass (_mainClassField.getText ());
        else mw.setManifestContents (_customManifestText);
        Manifest m = mw.getManifest ();
        if (m != null) {
            if (_exceptions.size () > 0) {
                ScrollableListDialog < String > dialog = new ScrollableListDialog.Builder < String > ().setOwner (JarOptionsDialog.this).setTitle ("Error Creating Jar").setText ("<html>An error occured while creating the jar file. This could be because the file<br>" + "that you are writing to or the file you are reading from could not be opened.</html>").setItems (new ArrayList < String > (_exceptions)).setMessageType (JOptionPane.ERROR_MESSAGE).build ();
                Utilities.setPopupLoc (dialog, JarOptionsDialog.this);
                dialog.showDialog ();
            }
            else {
                JOptionPane.showMessageDialog (JarOptionsDialog.this, "An error occured while creating the jar file. This could be because the file that you " + "are writing to or the file you are reading from could not be opened.", "Error Creating Jar", JOptionPane.ERROR_MESSAGE);
            }
        }
        else {
            if (_exceptions.size () > 0) {
                ScrollableListDialog < String > dialog = new ScrollableListDialog.Builder < String > ().setOwner (JarOptionsDialog.this).setTitle ("Error Creating Jar").setText ("The supplied manifest does not conform to the 1.0 Manifest format specification").setItems (new ArrayList < String > (_exceptions)).setMessageType (JOptionPane.ERROR_MESSAGE).build ();
                Utilities.setPopupLoc (dialog, JarOptionsDialog.this);
                dialog.showDialog ();
            }
            else {
                JOptionPane.showMessageDialog (JarOptionsDialog.this, "The supplied manifest does not conform to the 1.0 Manifest format specification.", "Error Creating Jar", JOptionPane.ERROR_MESSAGE);
            }
        }
        JarOptionsDialog.this.setVisible (false);
    }
    _model.refreshActiveDocument ();
}


-----Function Pair=115=-----==

public void testBaseSearchObject () throws LDAPException {
    LDAPConnection con = new LDAPConnection ();
    con.connect ("localhost", 50983);
    Util util = new Util ();
    LDAPSearchResults res = con.search ("uid=aalberts,dc=nam,dc=compinternal,dc=com", 0, "(objectClass=*)", new String [0], false);
    LDAPAttributeSet attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("l", "LA"));
    attribs.getAttribute ("l").addValue ("NY");
    attribs.add (new LDAPAttribute ("objectClass", "inetOrgPerson"));
    attribs.add (new LDAPAttribute ("uid", "aalberts"));
    attribs.add (new LDAPAttribute ("givenname", "Al"));
    attribs.add (new LDAPAttribute ("sn", "Alberts"));
    LDAPEntry entry = new LDAPEntry ("uid=aalberts,dc=nam,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("1st entry failed");
    }
    if (res.hasMore ()) {
        fail ("too many entries");
    }
    con.disconnect ();
}


public static int countjavas (File dir) {
    int cj = 0;
    File [] fls = dir.listFiles ();
    for (int i = 0; i < fls.length; i ++) {
        if (fls [i].isDirectory ()) {
            continue;
        }
        if (fls [i].toString ().endsWith (".java")) {
            cj ++;
        }
        if (fls [i].toString ().endsWith (".class")) {
            cj ++;
        }
        if (fls [i].toString ().indexOf ("SourceUtil.java") > - 1) {
            cj --;
        }
        if (fls [i].toString ().indexOf ("SourceUtil.class") > - 1) {
            cj --;
        }
        if (fls [i].toString ().indexOf ("Ask.java") > - 1) {
            cj --;
        }
        if (fls [i].toString ().indexOf ("Ask.class") > - 1) {
            cj --;
        }
        if (fls [i].toString ().indexOf ("MakeFromSource.java") > - 1) {
            cj --;
        }
        if (fls [i].toString ().indexOf ("MakeFromSource.class") > - 1) {
            cj --;
        }
        if (cj > 0) {
            break;
        }
    }
    return cj;
}


-----Function Pair=116=-----==

public void openInicialConfiguration () {
    if (mainPanel != null) {
        try {
            Map < String, Account > accounts = (Map < String, Account >) system.query (new GetAccounts ());
            Map < String, Person > employee = (Map < String, Person >) system.query (new GetEmployee ());
            Map < String, ClassRoom > classRoom = (Map < String, ClassRoom >) system.query (new GetClassRoom ());
            Map < String, Course > courses = (Map < String, Course >) system.query (new GetCourse ());
            float contValueOfCourses = 0;
            for (Course course : courses.values ()) {
                contValueOfCourses += course.getValue ();
            }
            if (employee.size () == 0 || accounts.size () == 0 || classRoom.size () == 0 || contValueOfCourses == 0) {
                if (inicialConfigurationcTabFolder == null) {
                    createInicialConfigurationCTabFolder ();
                }
                InicialConfiguration inicialConfiguration = new InicialConfiguration (inicialConfigurationcTabFolder, SWT.NONE);
                inicialConfigurationcTabFolder.setSelection (inicialConfiguration);
            }
            else {
                closeInicialConfiguration ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


public static void copyDirectory (File sourceDir, File destDir) throws IOException {
    if (! destDir.exists ()) {
        destDir.mkdir ();
    }
    File [] children = sourceDir.listFiles ();
    for (File sourceChild : children) {
        String name = sourceChild.getName ();
        File destChild = new File (destDir, name);
        if (sourceChild.isDirectory ()) {
            copyDirectory (sourceChild, destChild);
        }
        else {
            copyFile (sourceChild, destChild);
        }
    }
}


-----Function Pair=117=-----==

private ArrayList getJobDirectoriesPath (String dir) {
    ArrayList dirList = new ArrayList ();
    File [] fileArray;
    File f = new File (dir);
    fileArray = f.listFiles ();
    if (fileArray != null) {
        String remove = new String (dir + "/");
        for (int i = 0; i < fileArray.length; i ++) {
            if (fileArray [i].isDirectory () && ! fileArray [i].getName ().endsWith ("_files")) {
                dirList.add (fileArray [i].getAbsolutePath ().substring (remove.length ()));
            }
        }
    }
    Collections.sort (dirList);
    return dirList;
}


private static void checkArgs (String [] args) {
    Options options = createCommandlineOptions ();
    try {
        CommandLineParser parser = new GnuParser ();
        CommandLine cmd = parser.parse (options, args);
        if (cmd.hasOption (SAFEMODE)) {
            Settings.resetSettings ();
        }
        if (cmd.hasOption (HELP)) {
            printHelp (options);
        }
        if (cmd.hasOption (SERVER)) {
            String value = cmd.getOptionValue (SERVER);
            String ip = value.substring (0, value.indexOf (Client.IP_PORT_SEPARATOR));
            Globals.setServerIP (ip);
            int port = Integer.parseInt (value.substring (value.indexOf (Client.IP_PORT_SEPARATOR) + 1));
            Globals.setServerPort (port);
        }
        if (cmd.hasOption (DEBUG)) {
            Globals.enableDebug ();
        }
    } catch (ParseException ex) {
        System.err.println ("Parsing failed. Reason: " + ex.getMessage ());
        System.exit (1);
    } catch (Exception ex) {
        printHelp (options);
    }
}


-----Function Pair=118=-----==

private static void checkArgs (String [] args) {
    Options options = createCommandlineOptions ();
    try {
        CommandLineParser parser = new GnuParser ();
        CommandLine cmd = parser.parse (options, args);
        if (cmd.hasOption (SAFEMODE)) {
            safemode = true;
        }
        if (cmd.hasOption (HELP)) {
            printHelp (options);
            System.exit (0);
        }
        if (cmd.hasOption (SERVER)) {
            String value = cmd.getOptionValue (SERVER);
            String ip = value.substring (0, value.indexOf (OnlineClientData.IP_PORT_SEPARATOR));
            Globals.setServerIP (ip);
            int port = Integer.parseInt (value.substring (value.indexOf (OnlineClientData.IP_PORT_SEPARATOR) + 1));
            Globals.setServerPort (port);
        }
        if (cmd.hasOption (DEBUG)) {
            Globals.enableDebug ();
        }
        if (cmd.hasOption (MULTIPLE_INSTANCES)) {
            multipleInstances = true;
        }
    } catch (ParseException ex) {
        System.out.println (ex.getMessage ());
        System.out.println ();
        printHelp (options);
        System.exit (1);
    }
}


private byte [] showAutoDelItems (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "AutoDelItems.html");
    HashMap < String, KeepForDetails > items = store.getAutoDelList ();
    String [] key = (String []) items.keySet ().toArray (new String [0]);
    for (int x = 0; x < key.length; x ++) {
        KeepForDetails item = (KeepForDetails) items.get (key [x]);
        out.append ("<tr>\n");
        out.append ("<td>" + item.getCreated ().toString () + "</td>");
        out.append ("<td>" + item.getFileName () + "</td>");
        out.append ("<td>" + item.getKeepFor () + "</td>");
        out.append ("<td><a href='/servlet/" + urlData.getServletClass () + "?action=07&id=" + key [x] + "'>remove</a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$itemList", out.toString ());
    template.replaceAll ("$autoDelLog", store.getAutoDelLog ());
    return template.getPageBytes ();
}


-----Function Pair=119=-----==

private static File extractJar () throws Exception {
    File jar = new File (jarPath);
    ZipFile zip = new ZipFile (jar);
    Enumeration < ZipEntry > zipEntry = (Enumeration < ZipEntry >) zip.entries ();
    File directory = new File (jar.getParent (), jar.getName ().replace (".jar", "_") + System.currentTimeMillis ());
    directory.mkdir ();
    while (zipEntry.hasMoreElements ()) {
        ZipEntry entry = zipEntry.nextElement ();
        File file = new File (directory, entry.getName ());
        if (entry.isDirectory ()) {
            file.mkdir ();
        }
        else {
            File parent = file.getParentFile ();
            if (! parent.exists ()) parent.mkdirs ();
            BufferedInputStream in = new BufferedInputStream (zip.getInputStream (entry));
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            byte [] b = new byte [1024000];
            for (int i = in.read (b); i > - 1; i = in.read (b)) {
                if (i != 0) out.write (b, 0, i);
            }
            in.close ();
            out.close ();
        }
    }
    zip.close ();
    return directory;
}


private String getRelativePath (File from, File to) throws IOException {
    String s = File.separator;
    String [] fromCP = from.getCanonicalPath ().split (s);
    String [] toCP = to.getCanonicalPath ().split (s);
    int lastCommonIndex = - 1;
    for (int i = 0; fromCP [i].equals (toCP [i]); i ++) {
        lastCommonIndex = i;
    }
    StringBuilder b = new StringBuilder ();
    for (int i = fromCP.length - 1; i > lastCommonIndex; i --) {
        b.append ("..").append (s);
    }
    for (int i = lastCommonIndex + 1; i < toCP.length; i ++) {
        b.append (toCP [i]).append (s);
    }
    b.deleteCharAt (b.length () - 1);
    return b.toString ();
}


-----Function Pair=120=-----==

public static int binarySearch2 (int arr [], int key) {
    int imin = 0;
    int imax = arr.length - 1;
    while (imin <= imax) {
        int imid = imin + (imax - imin) / 2;
        if (key < arr [imid]) imax = imid - 1;
        else if (key > arr [imid]) imin = imid + 1;
        else return imid;
    }
    return - 1;
}


private String toHexString (byte [] bytes) {
    String result = "";
    if (bytes != null) {
        char [] HEX_ARRAY = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
        char [] hexChars = new char [bytes.length * 2];
        int v;
        for (int j = 0; j < bytes.length; j ++) {
            v = bytes [j] & 0xFF;
            hexChars [j * 2] = HEX_ARRAY [v / 16];
            hexChars [j * 2 + 1] = HEX_ARRAY [v % 16];
        }
        result = new String (hexChars);
    }
    return insertColons (result, 1);
}


-----Function Pair=121=-----==

public static void main (String [] args) {
    byte dec [] = decode (new String (encode (new byte [] {- 112})).toCharArray ());
    if (true) return;
    boolean decode = false;
    if (args.length == 0) {
        Log.info.out ("usage:  java Base64 [-d[ecode]] filename");
        System.exit (0);
    }
    for (int i = 0; i < args.length; i ++) {
        if ("-decode".equalsIgnoreCase (args [i])) decode = true;
        else if ("-d".equalsIgnoreCase (args [i])) decode = true;
    }
    String filename = args [args.length - 1];
    File file = new File (filename);
    if (! file.exists ()) {
        Log.info.out ("Error:  file '" + filename + "' doesn't exist!");
        System.exit (0);
    }
    if (decode) {
        char [] encoded = readChars (file);
        byte [] decoded = decode (encoded);
        writeBytes (file, decoded);
    }
    else {
        byte [] decoded = readBytes (file);
        char [] encoded = encode (decoded);
        writeChars (file, encoded);
    }
}


public static void main (final String [] args) throws Exception {
    final File gameXmlFile = new FileOpen ("Select xml file", ".xml").getFile ();
    if (gameXmlFile == null) {
        System.out.println ("No file selected");
        return;
    }
    final InputStream source = XmlUpdater.class.getResourceAsStream ("gameupdate.xslt");
    if (source == null) {
        throw new IllegalStateException ("Could not find xslt file");
    }
    final Transformer trans = TransformerFactory.newInstance ().newTransformer (new StreamSource (source));
    final InputStream gameXmlStream = new BufferedInputStream (new FileInputStream (gameXmlFile));
    ByteArrayOutputStream resultBuf;
    try {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
        factory.setValidating (true);
        final URL url = XmlUpdater.class.getResource ("");
        final String system = url.toExternalForm ();
        final Source xmlSource = new StreamSource (gameXmlStream, system);
        resultBuf = new ByteArrayOutputStream ();
        trans.transform (xmlSource, new StreamResult (resultBuf));
    } finally {
        gameXmlStream.close ();
    }
    gameXmlFile.renameTo (new File (gameXmlFile.getAbsolutePath () + ".backup"));
    new FileOutputStream (gameXmlFile).write (resultBuf.toByteArray ());
    System.out.println ("Successfully updated:" + gameXmlFile);
}


-----Function Pair=122=-----==

private void addAllUploadedFiles (ZipOutputStream zipout, int progressStart, int progressLength) throws IOException, FileNotFoundException {
    File uploadPath = Utilities.uploadPath (virtualWiki, "");
    String [] files = uploadPath.list ();
    int bytesRead = 0;
    byte byteArray [] = new byte [4096];
    for (int i = 0; i < files.length; i ++) {
        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / (double) files.length), 99);
        logger.debug ("Adding uploaded file " + files [i]);
        ZipEntry entry = new ZipEntry (files [i]);
        try {
            FileInputStream in = new FileInputStream (Utilities.uploadPath (virtualWiki, files [i]));
            zipout.putNextEntry (entry);
            while (in.available () > 0) {
                bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
                zipout.write (byteArray, 0, bytesRead);
            }
            zipout.closeEntry ();
            zipout.flush ();
        } catch (FileNotFoundException e) {
            logger.warn ("Could not open file!", e);
        } catch (IOException e) {
            logger.warn ("IOException!", e);
            try {
                zipout.closeEntry ();
                zipout.flush ();
            } catch (IOException e1) {
            }
        }
    }
}


private static void copy (File source, File destination) throws IOException, DocumentException {
    SWFReader reader = new SWFReader (new FileInputStream (source));
    SWFDocumentReader docReader = new SWFDocumentReader ();
    reader.addListener (docReader);
    reader.read ();
    SWFDocument sourceDoc = docReader.getDocument ();
    XMLWriter xmlWriter = new XMLWriter (sourceDoc);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    xmlWriter.write (baos, false);
    ByteArrayInputStream bais = new ByteArrayInputStream (baos.toByteArray ());
    XMLReader xmlReader = new XMLReader (bais);
    SWFDocument targetDoc = xmlReader.getDocument ();
    SWFWriter writer = new SWFWriter (targetDoc, new FileOutputStream (destination));
    writer.write ();
}


-----Function Pair=123=-----==

private DigitalObject processObject (DigitalObject object, JsonSimple workflow, Properties metadata) throws TransformerException {
    String oid = object.getId ();
    String title = workflow.getString (null, Strings.NODE_FORMDATA, "title");
    FedoraClient fedora = null;
    try {
        fedora = fedoraConnect ();
    } catch (TransformerException ex) {
        error ("Error connecting to VITAL", ex, oid, title);
    }
    String vitalPid = metadata.getProperty (Strings.PROP_VITAL_KEY);
    if (vitalPid != null) {
        log.debug ("Existing VITAL object: '{}'", vitalPid);
        if (! datastreamExists (fedora, vitalPid, "DC")) {
            String message = " !!! WARNING !!! The expected VITAL object '" + vitalPid + "' was not found. A new object will be created instead!";
            error (message, null, oid, title);
            vitalPid = null;
        }
    }
    if (vitalPid == null) {
        try {
            vitalPid = createNewObject (fedora, object.getId ());
            log.debug ("New VITAL object created: '{}'", vitalPid);
            metadata.setProperty (Strings.PROP_VITAL_KEY, vitalPid);
            object.close ();
        } catch (Exception ex) {
            error ("Failed to create object in VITAL", ex, oid, title);
        }
    }
    if (! waitProperties.isEmpty ()) {
        boolean process = false;
        for (String test : waitProperties) {
            String value = metadata.getProperty (test);
            if (value != null) {
                log.info ("Wait condition '{}' found.", test);
                process = true;
            }
        }
        if (! process) {
            log.info ("No wait conditions have been met, processing halted");
            return object;
        }
    }
    try {
        String isActive = metadata.getProperty (Strings.PROP_VITAL_ACTIVE);
        if (isActive == null) {
            log.info ("Activating object in fedora: '{}'", oid);
            String cutTitle = title;
            if (cutTitle.length () > 250) {
                cutTitle = cutTitle.substring (0, 250) + "...";
            }
            fedora.getAPIM ().modifyObject (vitalPid, "A", cutTitle, null, "ReDBox activating object: '" + oid + "'");
            metadata.setProperty (Strings.PROP_VITAL_ACTIVE, "true");
            object.close ();
        }
    } catch (Exception ex) {
        error ("Failed to activate object in VITAL", ex, oid, title);
    }
    try {
        processDatastreams (fedora, object, vitalPid);
    } catch (Exception ex) {
        error ("Failed to send object to VITAL", ex, oid, title);
    }
    return object;
}


private byte [] deleteSchedules (HTTPurl urlData) throws Exception {
    String action = urlData.getParameter ("deleteaction");
    String older = urlData.getParameter ("older");
    String status = urlData.getParameter ("status");
    System.out.println ("older=" + older + "status=" + status);
    int minutesOffset = 0;
    int statusInt = - 1;
    try {
        minutesOffset = Integer.parseInt (older);
        statusInt = Integer.parseInt (status);
    } catch (Exception e) {
    }
    long timeLimit = (new Date ().getTime ()) - (minutesOffset * 60 * 1000);
    System.out.println ("Time offset = " + minutesOffset + " linit = " + timeLimit + " status=" + statusInt);
    String [] keys = store.getScheduleKeys ();
    boolean deletedItem = false;
    for (int x = 0; x < keys.length; x ++) {
        ScheduleItem item = store.getScheduleItem (keys [x]);
        System.out.println ("Schedule time = " + item.getStart ().getTime () + " status = " + item.getState ());
        if ((item.getStart ().getTime () < timeLimit || minutesOffset == - 1) && (item.getState () == statusInt || statusInt == - 1)) {
            if (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR) {
                ScheduleItem removedItem = store.removeScheduleItem (item.toString ());
                if ("0".equals (action)) archiveOldItem (removedItem);
                deletedItem = true;
            }
        }
    }
    if (deletedItem) store.saveSchedule (null);
    String redirect = "HTTP/1.0 302 Moved Temporarily\n";
    redirect += "Location: /servlet/ScheduleDataRes\n\n";
    return redirect.getBytes ();
}


-----Function Pair=124=-----==

static Object checkType (Class expectedType, Object value) throws XmlRpcException {
    if (value instanceof Boolean && (Boolean.TYPE.isAssignableFrom (expectedType) || Boolean.class.isAssignableFrom (expectedType))) {
        return value;
    }
    else if (value instanceof Integer) {
        if (Integer.TYPE.isAssignableFrom (expectedType) || Integer.class.isAssignableFrom (expectedType)) {
            return value;
        }
        else if (Byte.TYPE.isAssignableFrom (expectedType) || Byte.class.isAssignableFrom (expectedType)) {
            return new Byte ((byte) ((Integer) value).intValue ());
        }
        else if (Long.TYPE.isAssignableFrom (expectedType) || Long.class.isAssignableFrom (expectedType)) {
            return new Long (((Integer) value).intValue ());
        }
        else if (Short.TYPE.isAssignableFrom (expectedType) || Short.class.isAssignableFrom (expectedType)) {
            return new Short ((short) ((Integer) value).intValue ());
        }
    }
    else if (value instanceof Double) {
        if (Float.TYPE.isAssignableFrom (expectedType) || Float.class.isAssignableFrom (expectedType)) {
            Float tmp = new Float (((Double) value).doubleValue ());
            return tmp;
        }
        else if (Double.TYPE.isAssignableFrom (expectedType) || Double.class.isAssignableFrom (expectedType)) {
            return value;
        }
    }
    else if (value instanceof String) {
        if (Character.TYPE.isAssignableFrom (expectedType) || Character.class.isAssignableFrom (expectedType)) {
            return new Character (((String) value).charAt (0));
        }
    }
    else if (value instanceof Hashtable) {
        if (containsObject (value)) {
            return buildObject ((Hashtable) value, expectedType);
        }
        else {
            if (Hashtable.class.isAssignableFrom (expectedType)) {
                checkForContainedObjects ((Map) value);
                return value;
            }
            else if (Map.class.isAssignableFrom (expectedType)) {
                checkForContainedObjects ((Map) value);
                if (expectedType.isAssignableFrom (HashMap.class)) {
                    return new HashMap ((Map) value);
                }
                else if (expectedType.isAssignableFrom (WeakHashMap.class)) {
                    return new WeakHashMap ((Map) value);
                }
                else if (expectedType.isAssignableFrom (TreeMap.class)) {
                    return new TreeMap ((Map) value);
                }
            }
        }
    }
    else if (value instanceof Vector) {
        if (expectedType.isAssignableFrom (Vector.class)) {
            checkForContainedObjects ((Vector) value);
            return value;
        }
        else if (Collection.class.isAssignableFrom (expectedType)) {
            checkForContainedObjects ((Vector) value);
            if (expectedType.isAssignableFrom (LinkedList.class)) {
                return new LinkedList ((Collection) value);
            }
            else if (expectedType.isAssignableFrom (ArrayList.class)) {
                return new ArrayList ((Collection) value);
            }
            else if (expectedType.isAssignableFrom (HashSet.class)) {
                return new HashSet ((Collection) value);
            }
            else if (expectedType.isAssignableFrom (TreeSet.class)) {
                return new TreeSet ((Collection) value);
            }
        }
        else if (expectedType.isArray ()) {
            Vector v = (Vector) value;
            Object array = Array.newInstance (expectedType.getComponentType (), v.size ());
            for (int i = 0; i < v.size (); ++ i) {
                Array.set (array, i, v.elementAt (i));
            }
            value = array;
        }
    }
    if (value == null || expectedType.isInstance (value)) {
        return value;
    }
    throw new XmlRpcException ("Field type does not match. Cannot convert " + value.getClass ().getName () + " into " + expectedType.getName ());
}


private String [] getFieldName (String name) {
    String [] cleanName = new String [2];
    String fieldName = name.trim ();
    String fieldAlias = "";
    Matcher matches = myStringWrappers.matcher (fieldName);
    if (matches.find ()) {
        fieldName = matches.replaceAll ("");
    }
    if (fieldName.indexOf ('.') > - 1) {
        fieldName = fieldName.substring (fieldName.indexOf ('.') + 1);
    }
    Matcher fieldNAlias = myAlias.matcher (fieldName);
    if (fieldNAlias.find ()) {
        String [] splitName = myAlias.split (fieldName);
        fieldName = splitName [0];
        fieldAlias = splitName [1];
    }
    else {
        fieldAlias = fieldName;
    }
    cleanName [0] = fieldAlias.trim ();
    cleanName [1] = fieldName.trim ();
    return cleanName;
}


-----Function Pair=125=-----==

public FtpReply canLogin (BaseFtpConnection baseconn, User user) {
    int count = getConfig ().getMaxUsersTotal ();
    if (user.isExempt ()) count = Math.max (count, count + getConfig ().getMaxUsersExempt ());
    int userCount = 0;
    int ipCount = 0;
    if (_conns.size () > count) return new FtpReply (550, "The site is full, try again later.");
    synchronized (_conns) {
        for (Iterator iter = _conns.iterator (); iter.hasNext ();) {
            BaseFtpConnection tempConnection = (BaseFtpConnection) iter.next ();
            try {
                User tempUser = tempConnection.getUser ();
                if (tempUser.getUsername ().equals (user.getUsername ())) {
                    userCount ++;
                    if (tempConnection.getClientAddress ().equals (baseconn.getClientAddress ())) {
                        ipCount ++;
                    }
                }
            } catch (NoSuchUserException ex) {
            }
        }
    }
    if (user.getMaxLoginsPerIP () > 0 && ipCount > user.getMaxLoginsPerIP ()) return new FtpReply (530, "Sorry, your maximum number of connections from this IP (" + user.getMaxLoginsPerIP () + ") has been reached.");
    if (user.getMaxLogins () > 0 && userCount > user.getMaxLogins ()) return new FtpReply (530, "Sorry, your account is restricted to " + user.getMaxLogins () + " simultaneous logins.");
    if (! baseconn.isSecure () && getConfig ().checkUserRejectInsecure (user)) {
        return new FtpReply (530, "USE SECURE CONNECTION");
    }
    else if (baseconn.isSecure () && getConfig ().checkUserRejectSecure (user)) {
        return new FtpReply (530, "USE INSECURE CONNECTION");
    }
    return null;
}


public void showResults (final StringBuffer results, String title) {
    results.append ("\n");
    if (resultWindow == null) {
        area = new JTextArea ();
        resultScrollPane = new JScrollPane (area);
        resultWindow = new JFrame ();
        JButton saveLogButton = new JButton ("Save log...");
        saveLogButton.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                if (chooser == null) chooser = new JFileChooser ();
                int retval = chooser.showSaveDialog (mainWindow);
                if (retval != JFileChooser.CANCEL_OPTION) {
                    File f = chooser.getSelectedFile ();
                    try {
                        PrintStream fo = new PrintStream (f);
                        fo.print (area.getText ());
                        fo.close ();
                    } catch (FileNotFoundException e1) {
                        JOptionPane.showMessageDialog (mainWindow, "Error, could not save logfile to " + f);
                    }
                }
            }
        }
        );
        JButton clearLogButton = new JButton ("Clear");
        clearLogButton.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                area.setText ("");
            }
        }
        );
        JPanel topPanel = new JPanel (new FlowLayout ());
        topPanel.add (saveLogButton);
        topPanel.add (clearLogButton);
        resultWindow.add (topPanel, BorderLayout.SOUTH);
        resultWindow.add (resultScrollPane, BorderLayout.CENTER);
        resultWindow.setLocationRelativeTo (mainWindow);
        resultWindow.setLocation ((int) mainWindow.getX (), (int) mainWindow.getY () + mainWindow.getHeight ());
        resultWindow.setSize (new Dimension (mainWindow.getWidth (), 300));
    }
    results.append (area.getText ());
    area.setText (results.toString ());
    resultScrollPane.setViewportView (area);
    resultWindow.setTitle ("Results : " + title);
    if (! resultWindow.isVisible ()) resultWindow.setVisible (true);
}


-----Function Pair=126=-----==

public AbstractField createField (String type, String name, Properties prop) throws GrammarFactoryException {
    AbstractField field = null;
    try {
        String className = (String) mapping.get (type.toUpperCase ());
        if (className == null || "".equals (className)) {
            throw new ClassNotFoundException ("datatype not found in mapping");
        }
        Constructor c = Class.forName (className).getConstructor (new Class [] {String.class, Properties.class});
        Object o = c.newInstance (new Object [] {name, prop});
        field = (AbstractField) o;
    } catch (ClassNotFoundException e) {
        throw new GrammarFactoryException ("cannot create field. type: " + type + ", name: " + name + ")", e.getException ());
    } catch (NoSuchMethodException e) {
        throw new GrammarFactoryException ("cannot create field. type: " + type + ", name: " + name + ")", e.getCause ());
    } catch (InstantiationException e) {
        throw new GrammarFactoryException ("cannot create field. type: " + type + ", name: " + name + ")", e.getCause ());
    } catch (IllegalAccessException e) {
        throw new GrammarFactoryException ("cannot create field. type: " + type + ", name: " + name + ")", e.getCause ());
    } catch (InvocationTargetException e) {
        throw new GrammarFactoryException ("cannot create field. type: " + type + ", name: " + name + ")", e.getCause ());
    }
    if (field == null) {
        throw new GrammarFactoryException ("field type [" + type + "]  doesn't exist. (field name: " + name + ")", null);
    }
    else {
        return field;
    }
}


public List getSiblingTreeAttributes (String id, String attributeName) {
    List result = new ArrayList ();
    for (Iterator it = getSiblings (id).iterator (); it.hasNext ();) {
        XMLNode node = (XMLNode) it.next ();
        if (node.getAttribute (attributeName) != null) {
            result.add (node.getAttribute (attributeName));
        }
    }
    for (Iterator it = children.keySet ().iterator (); it.hasNext ();) {
        String key = (String) it.next ();
        for (Iterator jt = ((List) children.get (key)).iterator (); jt.hasNext ();) {
            result.addAll (((XMLNode) jt.next ()).getSiblingTreeAttributes (id, attributeName));
        }
    }
    return result;
}


-----Function Pair=127=-----==

public void paint (final Graphics thisGraphics) {
    final Rectangle theseBounds = View.this.theVisualizationViewer.getBounds ();
    final Color thisBackColor = View.this.theSettings.theBackColor;
    if (thisBackColor != null) {
        thisGraphics.setColor (View.this.theSettings.theBackColor);
        thisGraphics.fillRect (0, 0, theseBounds.width, theseBounds.height);
        final Graphics2D thisGraphics2D = (Graphics2D) thisGraphics;
        final MultiLayerTransformer thisTransformer = View.this.theVisualizationViewer.getRenderContext ().getMultiLayerTransformer ();
        if (View.this.theSettings.frameView) {
            final Dimension thisSize = View.this.theVisualizationViewer.getGraphLayout ().getSize ();
            final RoundRectangle2D thisRectangle = new RoundRectangle2D.Double ();
            thisRectangle.setRoundRect (0, 0, thisSize.getWidth (), thisSize.getHeight (), 25, 25);
            final Shape thisShape = thisTransformer.transform (thisRectangle);
            thisGraphics2D.setColor (View.theFrameViewColor);
            thisGraphics2D.draw (thisShape);
            if (View.this.theSettings.split) {
                final Pair < Rectangle > theseSpaces = LayoutUtils.split (View.this.getGraphLayout ().getSize (), View.this.theSettings.splitVertically, View.this.theSettings.theSplitRatio);
                final Rectangle thisSpace1 = theseSpaces.getFirst ();
                final Rectangle thisSpace2 = theseSpaces.getSecond ();
                final RoundRectangle2D thisRectangle1 = new RoundRectangle2D.Double ();
                thisRectangle1.setRoundRect (thisSpace1.x, thisSpace1.y, thisSpace1.getWidth (), thisSpace1.getHeight (), 25, 25);
                final RoundRectangle2D thisRectangle2 = new RoundRectangle2D.Double ();
                thisRectangle2.setRoundRect (thisSpace2.x, thisSpace2.y, thisSpace2.getWidth (), thisSpace2.getHeight (), 25, 25);
                final Shape thisShape1 = thisTransformer.transform (thisRectangle1);
                final Shape thisShape2 = thisTransformer.transform (thisRectangle2);
                thisGraphics.setColor (View.theFrameViewColor1);
                thisGraphics2D.draw (thisShape1);
                thisGraphics.setColor (View.theFrameViewColor2);
                thisGraphics2D.draw (thisShape2);
            }
        }
    }
    if (View.this.theBackImage != null) {
        thisGraphics.setPaintMode ();
        final int xinc = View.this.theBackImage.getWidth (null);
        final int yinc = View.this.theBackImage.getHeight (null);
        if (xinc <= 0 || yinc <= 0) return;
        final int xmax = theseBounds.width;
        final int ymax = theseBounds.height;
        for (int y = 0; y < ymax; y += yinc) {
            for (int x = 0; x < xmax; x += xinc) {
                thisGraphics.drawImage (View.this.theBackImage, x, y, null);
            }
        }
    }
}


private static void pipe_agent_step () throws IOException {
    String buf1, buf2;
    int act, count = 0, obs_case;
    double r;
    Class partypes [];
    Method meth;
    Object arglist [];
    Object retobj2 = null;
    try {
        buf1 = br.readLine ();
        while (buf1 == null) buf1 = br.readLine ();
        buf2 = br.readLine ();
        while (buf2 == null || buf2.length () <= 0) buf2 = br.readLine ();
        r = Double.parseDouble (buf2);
        st = new StringTokenizer (buf1);
        while (st.hasMoreTokens ()) {
            token [count] = st.nextToken ().trim ();
            if (! token [count].equals ("\n")) count ++;
        }
        if (count == 1) {
            obs_case = 1;
            for (int i = 0; i < token [0].length (); i ++) if (token [0].charAt (i) == '.') obs_case = 2;
        }
        else {
            obs_case = 3;
            for (int i = 0; i < count; i ++) for (int j = 0; j < token [i].length (); j ++) if (token [i].charAt (j) == '.') obs_case = 4;
        }
        if (obs_case == 1) {
            si = Integer.parseInt (token [0]);
            partypes = new Class [2];
            partypes [0] = Double.TYPE;
            partypes [1] = Integer.TYPE;
            meth = agent.getMethod ("agent_step", partypes);
            arglist = new Object [2];
            arglist [0] = new Double (r);
            arglist [1] = new Integer (si);
            retobj2 = meth.invoke (retobj, arglist);
        }
        else if (obs_case == 2) {
            sf = Double.parseDouble (token [0]);
            partypes = new Class [2];
            partypes [0] = Double.TYPE;
            partypes [1] = Double.TYPE;
            meth = agent.getMethod ("agent_step", partypes);
            arglist = new Object [2];
            arglist [0] = new Double (r);
            arglist [1] = new Double (sf);
            retobj2 = meth.invoke (retobj, arglist);
        }
        else if (obs_case == 3) {
            sia = new int [count];
            for (int i = 0; i < count; i ++) sia [i] = Integer.parseInt (token [i]);
            partypes = new Class [2];
            partypes [0] = Double.TYPE;
            partypes [1] = Class.forName ("[I");
            meth = agent.getMethod ("agent_step", partypes);
            arglist = new Object [2];
            arglist [0] = new Double (r);
            arglist [1] = sia;
            retobj2 = meth.invoke (retobj, arglist);
        }
        else if (obs_case == 4) {
            sfa = new double [count];
            for (int i = 0; i < count; i ++) sfa [i] = Double.parseDouble (token [i]);
            partypes = new Class [2];
            partypes [0] = Double.TYPE;
            partypes [1] = Class.forName ("[D");
            meth = agent.getMethod ("agent_step", partypes);
            arglist = new Object [2];
            arglist [0] = new Double (r);
            arglist [1] = sfa;
            retobj2 = meth.invoke (retobj, arglist);
        }
        buf2 = "";
        if (retobj2 instanceof Integer) {
            Integer retval1 = (Integer) retobj2;
            buf2 = String.valueOf (retval1.intValue ());
        }
        else if (retobj2 instanceof Double) {
            Double retval2 = (Double) retobj2;
            buf2 = String.valueOf (retval2.doubleValue ());
        }
        else if (Class.forName ("[I").isInstance (retobj2)) {
            buf2 = "";
            for (int i = 0; i < Array.getLength (retobj2); i ++) buf2 = buf2 + String.valueOf (Array.getInt (retobj2, i)) + " ";
            buf2 = buf2.trim ();
        }
        else if (Class.forName ("[D").isInstance (retobj2)) {
            buf2 = "";
            for (int i = 0; i < Array.getLength (retobj2); i ++) buf2 = buf2 + String.valueOf (Array.getDouble (retobj2, i)) + " ";
            buf2 = buf2.trim ();
        }
        else {
            System.out.println ("ERROR4: Action is not a valid type. RL-Framework supports \nInt, \nDouble, \nInt Array, \nDouble Array \nfor Observation type when using pipe communication. \nExiting...\n");
            System.exit (1);
        }
        file.write (buf2 + "\n");
        file.flush ();
    } catch (InvocationTargetException e) {
        System.err.println ("\nError: Error in your agent_step method!!\n");
        e.printStackTrace ();
    } catch (Throwable e) {
        System.err.println ("ERROR: Arguments are not valid. RL-Framework supports \nInt, \nDouble, \nInt Array, \nDouble Array \nfor Observation type when using pipe communication. \nExiting...\n");
        e.printStackTrace ();
    }
}


-----Function Pair=128=-----==

public void complementMissingArguments () {
    if (parser == null) return;
    ArgumentDefinition [] arguList = parser.getArgumentDefinitions ();
    Map < String, List < Object > > options = args.getOptions ();
    for (int a = 0; a < arguList.length; a ++) {
        ArgumentDefinition argDef = arguList [a];
        if (! argDef.isRequiredArgument () && argDef.getDefaultValue () != null) {
            if (! options.containsKey (argDef.getName ())) {
                List < Object > defaultOption = new ArrayList < Object > (1);
                defaultOption.add (argDef.getDefaultValue ());
                options.put (argDef.getName (), defaultOption);
            }
        }
    }
}


public Node createSimpleNodeForBO (IBusinessObject businessObject, NodesFactoryKeys configuration) {
    Map < NodesFactoryKeys, Class > nodeMap = this.factoryMap.get (businessObject.getClass ());
    if (nodeMap == null) {
        return null;
    }
    Class nodeClass = nodeMap.get (configuration);
    if (nodeClass == null) {
        return null;
    }
    try {
        Constructor nodeConstructor = nodeClass.getConstructor (businessObject.getClass ());
        return (Node) nodeConstructor.newInstance (businessObject);
    } catch (InstantiationException ex) {
        Exceptions.printStackTrace (ex);
    } catch (IllegalAccessException ex) {
        Exceptions.printStackTrace (ex);
    } catch (IllegalArgumentException ex) {
        Exceptions.printStackTrace (ex);
    } catch (InvocationTargetException ex) {
        Exceptions.printStackTrace (ex);
    } catch (NoSuchMethodException ex) {
        Exceptions.printStackTrace (ex);
    } catch (SecurityException ex) {
        Exceptions.printStackTrace (ex);
    }
    return null;
}


-----Function Pair=129=-----=1=

public synchronized ArrayList < Plugin > getPlugins () {
    ArrayList < Plugin > plugins = new ArrayList < Plugin > ();
    File f = new File ("plugins/");
    if (! f.exists ()) {
        JOptionPane.showMessageDialog (mainWindow, "Plugin-directory not found at " + f.getAbsolutePath ());
        return null;
    }
    String [] descriptorNames = f.list ();
    try {
        for (int i = 0; i < descriptorNames.length; i ++) {
            if (descriptorNames [i].endsWith (".class")) {
                String name = "plugins." + (descriptorNames [i].substring (0, descriptorNames [i].length () - 6));
                if (! name.contains ("$")) {
                    ClassLoader loader = getClass ().getClassLoader ().getSystemClassLoader ();
                    Constructor c = loader.loadClass (name).getConstructors () [0];
                    plugins.add ((Plugin) c.newInstance ());
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return plugins;
}


private void getInstances (Class < ? > targetClass, Class < ? extends TestProfile > testProfile) {
    if (testProfile == null) {
        error ("You must specify a testProfile. Look at another unit test to see how to do this.");
        return;
    }
    if (targetClass == null) {
        error ("You must specify a targetClass. Look at another unit test to see how to do this.");
        return;
    }
    testProfileName = testProfile.getName ();
    targetClassName = targetClass.getName ();
    if (! isTestProfile (testProfile)) {
        error (testProfileName + " must implement the 'TestProfile' interface.");
        return;
    }
    String clazz = null;
    try {
        clazz = testProfileName;
        Constructor < ? extends TestProfile > profileConstructor = testProfile.getConstructor ();
        testProfileInstance = profileConstructor.newInstance ();
        clazz = targetClassName;
        Constructor < ? > targetConstructor = targetClass.getConstructor ();
        targetInstance = targetConstructor.newInstance ();
    } catch (NoSuchMethodException exception) {
        error ("Could not instantiate " + clazz + ". It must have a no-argument constructor.");
    } catch (InstantiationException exception) {
        error ("Could not instantiate " + clazz + ". Exception during target object initialization.");
        Log.out (exception);
    } catch (IllegalAccessException exception) {
        error ("Could not instantiate " + clazz + ". Make sure its constructor is public.");
    } catch (InvocationTargetException exception) {
        error ("Could not instantiate " + clazz + ".");
    }
}


-----Function Pair=130=-----==

public < T extends Element > List < T > getElements (ElementKey < ?, T > key) {
    ImmutableList.Builder < T > builder = ImmutableList.builder ();
    Object obj = getElementObject (key);
    if (obj != null) {
        try {
            if (obj instanceof Element) {
                T adapted = adapt (key, (Element) obj);
                builder.add (adapted);
            }
            else {
                for (Object o : (Collection < ? >) obj) {
                    Element e = (Element) o;
                    builder.add (adapt (key, (Element) o));
                }
            }
        } catch (ContentCreationException e) {
            throw new IllegalArgumentException ("Unable to adapt to " + key.getElementType (), e);
        }
    }
    return builder.build ();
}


private PlanLine buildPlanLine (String strLine) throws LineSyntaxException {
    String range = extract (strLine, DIGITS_RANGE);
    String [] digits = range.split (RANGE_SEP);
    int start = Integer.valueOf (digits [0].trim ());
    int end = Integer.valueOf (digits [1].trim ());
    if (end < start) {
        throwException (lineNumber, "'" + range + "' is not a valid range.", LineSyntaxException.class);
    }
    PlanLine line = new PlanLine (start, end);
    String dir = extract (strLine, DIRECTIVE);
    if (! "".equals (dir)) {
        line.setDirective (buildDirective (dir));
    }
    return line;
}


-----Function Pair=131=-----==

public IModelInstanceElement getProperty (Property property) throws PropertyAccessException, PropertyNotFoundException {
    if (property == null) {
        throw new IllegalArgumentException ("Parameter 'property' must not be null.");
    }
    IModelInstanceElement result;
    if (this.myEObject == null) {
        result = this.myFactory.createModelInstanceElement (null, property.getType ());
    }
    else {
        EStructuralFeature sf = this.myEObject.eClass ().getEStructuralFeature (property.getName ());
        if (sf == null) {
            String msg = EcoreModelInstanceTypeMessages.EcoreModelInstanceObject_PropertyNotFoundInModelInstanceElement;
            msg = NLS.bind (msg, property, this.myEObject);
            throw new PropertyAccessException (msg);
        }
        Object adapteeResult = this.myEObject.eGet (sf);
        result = AbstractModelInstance.adaptInvocationResult (adapteeResult, property.getType (), this.myFactory);
    }
    return result;
}


private static void pipe_env_get_random_seed () throws IOException {
    String buf;
    try {
        Method meth = agent.getMethod ("env_get_random_seed", null);
        Object retobj2 = meth.invoke (retobj, null);
        buf = "";
        if (retobj2 instanceof Integer) {
            Integer retval1 = (Integer) retobj2;
            buf = String.valueOf (retval1.intValue ());
        }
        else if (retobj2 instanceof Double) {
            Double retval2 = (Double) retobj2;
            buf = String.valueOf (retval2.doubleValue ());
        }
        else if (Class.forName ("[I").isInstance (retobj2)) {
            buf = "";
            for (int i = 0; i < Array.getLength (retobj2); i ++) buf = buf + String.valueOf (Array.getInt (retobj2, i)) + " ";
            buf = buf.trim ();
        }
        else if (Class.forName ("[D").isInstance (retobj2)) {
            buf = "";
            for (int i = 0; i < Array.getLength (retobj2); i ++) buf = buf + String.valueOf (Array.getDouble (retobj2, i)) + " ";
            buf = buf.trim ();
        }
        else {
            System.out.println ("ERROR7: Random_seed_key is not a valid type. RL-Framework supports \nInt, \nDouble, \nInt Array, \nDouble Array \nfor Observation type when using pipe communication. \nExiting...\n");
            System.exit (1);
        }
        file.write (buf + "\n");
        file.flush ();
    } catch (InvocationTargetException e) {
        System.err.println ("\nError: Error in your env_get_random_seed method!!\n");
        e.printStackTrace ();
    } catch (Throwable e) {
        file.write ("NOTIMPLEMENTED" + "\n");
        file.flush ();
    }
}


-----Function Pair=132=-----==

static void removeLogLevel (String name) {
    ConfigurationParameters.BestMatch bl;
    AbstractWrapper wrapper;
    LogLevel level;
    Iterator i;
    synchronized (cache_) {
        for (i = cache_.iterator (); i.hasNext ();) {
            wrapper = (AbstractWrapper) i.next ();
            if (wrapper.lname_.equals (name)) {
                bl = LoggingConfiguration.atPresent ().getLogLevel (name);
                wrapper.lname_ = bl.getName ();
                level = (LogLevel) bl.getValue ();
                wrapper.setLogLevel (level);
            }
        }
    }
}


public byte [] generateImage (InputStream reportFile, Map < String, Object > parameterMap) {
    File targetFile;
    try {
        targetFile = File.createTempFile ("Jasper_", ".html");
    } catch (IOException e1) {
        throw new RuntimeException ("Unable to create temporary report file.", e1);
    }
    targetFile.deleteOnExit ();
    String filename = targetFile.getAbsolutePath ();
    this.generateHtml (reportFile, parameterMap, filename);
    File imageFile = new File (filename + "_files/img_0_0_0");
    if (imageFile.exists ()) {
        return FileUtil.readFileAsBytes (imageFile);
    }
    else return null;
}


-----Function Pair=133=-----=1=

public static Object newInstance (Class o_clazz, Object [] args, Class [] clazzes) throws Throwable {
    boolean [] is_null = new boolean [args.length];
    for (int i = 0; i < args.length; i ++) {
        is_null [i] = (args [i] == null);
    }
    Constructor cons = getConstructor (o_clazz, clazzes, is_null);
    boolean access = cons.isAccessible ();
    cons.setAccessible (true);
    Object o;
    try {
        o = cons.newInstance (args);
    } catch (InvocationTargetException e) {
        throw e.getTargetException ();
    } finally {
        cons.setAccessible (access);
    }
    return o;
}


public void widgetSelected (SelectionEvent e) {
    ListDialog typeSelectionDialog = new ListDialog (PlatformUI.getWorkbench ().getDisplay ().getActiveShell ());
    typeSelectionDialog.setContentProvider (new ArrayContentProvider () {
        @Override
        public Object [] getElements (Object inputElement) {
            Class < ? > [] wizards = {CreateAtopTaskWizard.class, CreateJmtTaskWizard.class};
            return wizards;
        }
    }
    );
    typeSelectionDialog.setLabelProvider (new LabelProvider () {
        @Override
        public String getText (Object element) {
            if (element instanceof Class < ? >) {
                Class < ? extends INewTaskWizard > wizardClass = (Class < ? extends INewTaskWizard >) element;
                if (wizardClass.equals (CreateAtopTaskWizard.class)) return "ATOP Task";
                else if (wizardClass.equals (CreateJmtTaskWizard.class)) return "JMT Task";
                else return "UNKNOWN";
            }
            else return "UNKNOWN";
        }
    }
    );
    typeSelectionDialog.setTitle ("Add New Task");
    typeSelectionDialog.setMessage ("Select the type of task to create :");
    typeSelectionDialog.setInput (new Integer (1));
    if (typeSelectionDialog.open () == WizardDialog.OK) {
        if (typeSelectionDialog.getResult ().length == 1) {
            Class < ? extends INewTaskWizard > wizardClass = (Class < ? extends INewTaskWizard >) typeSelectionDialog.getResult () [0];
            try {
                Constructor < ? extends INewTaskWizard > constr = wizardClass.getConstructor (ModelingProject.class, String.class);
                INewTaskWizard wizard = constr.newInstance (getInputProject (), getInputProjectFileName ());
                WizardDialog dialog = new WizardDialog (PlatformUI.getWorkbench ().getDisplay ().getActiveShell (), wizard);
                if (dialog.open () == WizardDialog.OK) {
                    tasksListSectionPart.markStale ();
                    tasksListSectionPart.markDirty ();
                }
            } catch (Exception e1) {
                e1.printStackTrace ();
            }
        }
    }
}


-----Function Pair=134=-----==

private byte [] moveTunerUp (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex > 0 && tunerIndex < devList.getDeviceCount ()) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex - 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=135=-----=1=

public void execute () {
    if (includes != null && includes.trim ().isEmpty ()) return;
    DirectoryScanner s = getDirectoryScanner (srcDir);
    String [] files = s.getIncludedFiles ();
    files = filter (srcDir, destDir, files);
    if (files.length == 0) return;
    System.out.println ("Generating " + files.length + " stub files to " + destDir);
    List < String > classNames = new ArrayList < String > ();
    for (String file : files) {
        classNames.add (file.replaceAll (".java$", "").replace ('/', '.'));
    }
    if (! fork) {
        GenStubs m = new GenStubs ();
        boolean ok = m.run (srcDir.getPath (), destDir, classNames);
        if (! ok) throw new BuildException ("genstubs failed");
    }
    else {
        List < String > cmd = new ArrayList < String > ();
        String java_home = System.getProperty ("java.home");
        cmd.add (new File (new File (java_home, "bin"), "java").getPath ());
        if (classpath != null) cmd.add ("-Xbootclasspath/p:" + classpath);
        cmd.add (GenStubs.class.getName ());
        cmd.add ("-sourcepath");
        cmd.add (srcDir.getPath ());
        cmd.add ("-s");
        cmd.add (destDir.getPath ());
        cmd.addAll (classNames);
        ProcessBuilder pb = new ProcessBuilder (cmd);
        pb.redirectErrorStream (true);
        try {
            Process p = pb.start ();
            BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
            try {
                String line;
                while ((line = in.readLine ()) != null) System.out.println (line);
            } finally {
                in.close ();
            }
            int rc = p.waitFor ();
            if (rc != 0) throw new BuildException ("genstubs failed");
        } catch (IOException e) {
            throw new BuildException ("genstubs failed", e);
        } catch (InterruptedException e) {
            throw new BuildException ("genstubs failed", e);
        }
    }
}


void run () throws Exception {
    File javaHome = new File (System.getProperty ("java.home"));
    if (javaHome.getName ().equals ("jre")) javaHome = javaHome.getParentFile ();
    File javaExe = new File (new File (javaHome, "bin"), "java");
    String classpath = System.getProperty ("java.class.path");
    String [] cmd = {javaExe.getPath (), "-verbose:class", "-classpath", classpath, ToolProviderTest2.class.getName (), "javax.tools.ToolProvider"};
    ProcessBuilder pb = new ProcessBuilder (cmd).redirectErrorStream (true);
    Process p = pb.start ();
    BufferedReader r = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    String line;
    boolean found = false;
    while ((line = r.readLine ()) != null) {
        System.err.println (line);
        if (line.contains ("com.sun.tools.javac.")) found = true;
    }
    int rc = p.waitFor ();
    if (rc != 0) error ("Unexpected exit code: " + rc);
    if (! found) System.err.println ("expected class name not found");
    if (errors > 0) throw new Exception (errors + " errors occurred");
}


-----Function Pair=136=-----==

private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


private static String execCmd (String cmd) {
    String msg = new String ("");
    boolean cmdOK = true;
    Process proc = null;
    Runtime runtime = Runtime.getRuntime ();
    try {
        proc = runtime.exec (cmd);
        InputStreamReader isrError = new InputStreamReader (proc.getErrorStream ());
        BufferedReader brError = new BufferedReader (isrError);
        String line = null;
        while ((line = brError.readLine ()) != null) {
            System.out.println ("ERROR MSG>" + line);
        }
        InputStreamReader isrOutput = new InputStreamReader (proc.getInputStream ());
        BufferedReader brOutput = new BufferedReader (isrOutput);
        line = null;
        while ((line = brOutput.readLine ()) != null) {
            System.out.println ("OUTPUT>" + line);
        }
        int exitVal = proc.waitFor ();
        System.out.println ("ExitValue: " + exitVal);
    } catch (Exception e) {
        cmdOK = false;
        msg += "Problem executing command: " + cmd + "  DAMN. Exception " + e.toString ();
        System.err.println (msg);
    }
    if (cmdOK) {
        msg += "Command: " + cmd + " OK.";
    }
    return msg;
}


-----Function Pair=137=-----==

public static String readerToString (Reader rdr) {
    String ret = null;
    try {
        int len = 0;
        char [] buf = new char [2048];
        StringWriter wrt = new StringWriter ();
        while ((len = rdr.read (buf)) != - 1) {
            wrt.write (buf, 0, len);
        }
        ret = wrt.toString ();
    } catch (UnsupportedEncodingException e) {
    } catch (IOException e) {
    }
    return ret;
}


public static String encodeResponseForSuccess (Method serviceMethod, Object object, SerializationPolicy serializationPolicy, int flags) throws SerializationException {
    if (serviceMethod == null) {
        throw new NullPointerException ("serviceMethod cannot be null");
    }
    if (serializationPolicy == null) {
        throw new NullPointerException ("serializationPolicy");
    }
    Class < ? > methodReturnType = serviceMethod.getReturnType ();
    if (methodReturnType != void.class && object != null) {
        Class < ? > actualReturnType;
        if (methodReturnType.isPrimitive ()) {
            actualReturnType = getPrimitiveClassFromWrapper (object.getClass ());
        }
        else {
            actualReturnType = object.getClass ();
        }
        if (actualReturnType == null || ! methodReturnType.isAssignableFrom (actualReturnType)) {
            throw new IllegalArgumentException ("Type '" + printTypeName (object.getClass ()) + "' does not match the return type in the method's signature: '" + getSourceRepresentation (serviceMethod) + "'");
        }
    }
    return encodeResponse (methodReturnType, object, false, flags, serializationPolicy);
}


-----Function Pair=138=-----==

private byte [] encodeStringOld (String text) {
    int len = text.length () + 4;
    int mod = (len % 8);
    if (mod > 0) {
        for (; mod != 0; len ++) {
            mod = len % 8;
        }
        len --;
    }
    len = len - 4;
    StringBuffer textBuffer = new StringBuffer (text);
    textBuffer.setLength (len);
    String encoded = crcHeader (textBuffer.toString ()) + textBuffer;
    return encoded.getBytes ();
}


private byte [] readFile (String path) {
    if (log.isDebugEnabled ()) log.debug ("-------------============= usao u read= ");
    File file = new File (path);
    byte bytes [] = (byte []) null;
    try {
        if (log.isDebugEnabled ()) log.debug ("-------------============= pravi input stream");
        InputStream is = new FileInputStream (file);
        if (log.isDebugEnabled ()) log.debug ("-------------============= uzima duzinu");
        long length = file.length ();
        bytes = new byte [(int) length];
        int offset = 0;
        for (int numRead = 0; offset < bytes.length && (numRead = is.read (bytes, offset, bytes.length - offset)) >= 0;) {
            offset += numRead;
            if (log.isDebugEnabled ()) log.debug ("-------------============= offset= " + offset);
        }
        if (offset < bytes.length) throw new DocumentAccessException ("Could not completely read file " + file.getName ());
        if (log.isDebugEnabled ()) log.debug ("-------------============= pre close");
        is.close ();
    } catch (Exception e) {
        throw new DocumentAccessException (e.getMessage ());
    }
    return bytes;
}


-----Function Pair=139=-----==

public static long getCRC32 (InputStream iFile1, InputStream iFile2, InputStream iFile3, InputStream iFile4, InputStream iFile5, InputStream iFile6, InputStream iFile7, InputStream iFile8, InputStream iFile9, InputStream iFile10) throws IOException {
    CRC32 crc = new CRC32 ();
    try {
        if (iFile1 != null) {
            System.out.println ("Updating CRC for Stream 1 ...");
            crc.update (getBytesFromInputStream (iFile1));
            System.out.println ("Computed.");
        }
        if (iFile2 != null) {
            System.out.println ("Updating CRC for Stream 2 ...");
            crc.update (getBytesFromInputStream (iFile2));
            System.out.println ("Computed.");
        }
        if (iFile3 != null) {
            System.out.println ("Updating CRC for Stream 3 ...");
            crc.update (getBytesFromInputStream (iFile3));
            System.out.println ("Computed.");
        }
        if (iFile4 != null) {
            System.out.println ("Updating CRC for Stream 4 ...");
            crc.update (getBytesFromInputStream (iFile4));
            System.out.println ("Computed.");
        }
        if (iFile5 != null) {
            System.out.println ("Updating CRC for Stream 5 ...");
            crc.update (getBytesFromInputStream (iFile5));
            System.out.println ("Computed.");
        }
        if (iFile6 != null) {
            System.out.println ("Updating CRC for Stream 6 ...");
            crc.update (getBytesFromInputStream (iFile6));
            System.out.println ("Computed.");
        }
        if (iFile7 != null) {
            System.out.println ("Updating CRC for Stream 7 ...");
            crc.update (getBytesFromInputStream (iFile7));
            System.out.println ("Computed.");
        }
        if (iFile8 != null) {
            System.out.println ("Updating CRC for Stream 8 ...");
            crc.update (getBytesFromInputStream (iFile8));
            System.out.println ("Computed.");
        }
        if (iFile9 != null) {
            System.out.println ("Updating CRC for Stream 9 ...");
            crc.update (getBytesFromInputStream (iFile9));
            System.out.println ("Computed.");
        }
        if (iFile10 != null) {
            System.out.println ("Updating CRC for Stream 10 ...");
            crc.update (getBytesFromInputStream (iFile10));
            System.out.println ("Computed.");
        }
        return crc.getValue ();
    } catch (IOException ex) {
        System.err.println ("ERROR : CRC32 Java computation error : " + ex.getMessage ());
        System.err.println ("Full Stack below :\n" + ex.getMessage ());
        System.err.println ("Throwing exception ...\nBye.");
        throw ex;
    }
}


public void updateItemData (final int dataStartBlock, final byte [] data) throws IOException {
    final int dataStartBlocksIndex = this.validateDataStartBlock (dataStartBlock);
    if (this.readOnlyMode) throw new IOException ("Cannot update data in read only mode!");
    if (dataStartBlocksIndex < 0) throw new IOException ("Data start block " + dataStartBlock + " doesn't exist!");
    final int [] currentDataChain = this.getItemDataChain (dataStartBlocksIndex);
    int blocksNeeded = calculateBlocksNeeded (data.length);
    if (blocksNeeded == 0) blocksNeeded = 1;
    if (blocksNeeded < currentDataChain.length) {
        final int [] updateDataBlockIndices = new int [blocksNeeded];
        System.arraycopy (currentDataChain, 0, updateDataBlockIndices, 0, blocksNeeded);
        final byte [] formattedBlockData = formatSingleItemDataBlocks (data, updateDataBlockIndices);
        blockFile.writeBlocks (updateDataBlockIndices, formattedBlockData, 0);
        int [] deallocatedBlocks = this.deallocateDataChain (dataStartBlocksIndex, currentDataChain.length - blocksNeeded);
        for (int i = 0; i < deallocatedBlocks.length; i ++) {
            this.blockFile.writePartialBlock (deallocatedBlocks [i], 0, this.deallocatedBlockHeaderBuffer, 0, this.deallocatedBlockHeaderBuffer.length);
        }
    }
    else if (blocksNeeded > currentDataChain.length) {
        final int [] newBlockIndices = this.allocateDataChain (blocksNeeded - currentDataChain.length);
        final int [] newDataChain = new int [blocksNeeded];
        System.arraycopy (currentDataChain, 0, newDataChain, 0, currentDataChain.length);
        System.arraycopy (newBlockIndices, 0, newDataChain, currentDataChain.length, newBlockIndices.length);
        this.dataChainsArray.set (dataStartBlocksIndex, newDataChain);
        final byte [] formattedBlockData = formatSingleItemDataBlocks (data, newDataChain);
        blockFile.writeBlocks (newDataChain, formattedBlockData, 0);
    }
    else {
        final byte [] formattedBlockData = formatSingleItemDataBlocks (data, currentDataChain);
        blockFile.writeBlocks (currentDataChain, formattedBlockData, 0);
    }
    this.itemDataSizes.set (dataStartBlocksIndex, data.length);
}


-----Function Pair=140=-----==

private static int [] getSmallImage (final File file, final Map < File, int [] > images) throws IOException {
    int [] result = images.get (file);
    if (null == result) {
        final Image bigImage = new ImageIcon (file.getAbsolutePath ()).getImage ();
        final Image smallImage = bigImage.getScaledInstance (SZ, SZ, Image.SCALE_AREA_AVERAGING);
        final PixelGrabber pg = new PixelGrabber (smallImage, 0, 0, SZ, SZ, result = new int [SZ_SQ], 0, SZ);
        try {
            pg.grabPixels ();
        } catch (final InterruptedException x) {
            throw new IOException ("Interrupted whilst waiting for pixels for image " + file + '.');
        }
        if (0 != (pg.getStatus () & ImageObserver.ABORT)) {
            s_log.error ("Pixel grab aborted or errored for image " + file + '.');
        }
        images.put (file, result);
    }
    return result;
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=141=-----==

public void createDiff (File nvdir, File ovdir, boolean verbose) throws IOException {
    String nvers = nvdir.getName ();
    String overs = ovdir.getName ();
    try {
        if (Long.parseLong (nvers) <= Long.parseLong (overs)) {
            String err = "New version (" + nvers + ") must be greater " + "than old version (" + overs + ").";
            throw new IOException (err);
        }
    } catch (NumberFormatException nfe) {
        throw new IOException ("Non-numeric versions? [nvers=" + nvers + ", overs=" + overs + "].");
    }
    Application oapp = new Application (ovdir, null);
    oapp.init (false);
    ArrayList < Resource > orsrcs = new ArrayList < Resource > ();
    orsrcs.addAll (oapp.getCodeResources ());
    orsrcs.addAll (oapp.getResources ());
    Application napp = new Application (nvdir, null);
    napp.init (false);
    ArrayList < Resource > nrsrcs = new ArrayList < Resource > ();
    nrsrcs.addAll (napp.getCodeResources ());
    nrsrcs.addAll (napp.getResources ());
    File patch = new File (nvdir, "patch" + overs + ".dat");
    createPatch (patch, orsrcs, nrsrcs, verbose);
    for (String auxgroup : napp.getAuxGroups ()) {
        orsrcs = new ArrayList < Resource > ();
        orsrcs.addAll (oapp.getResources (auxgroup));
        nrsrcs = new ArrayList < Resource > ();
        nrsrcs.addAll (napp.getResources (auxgroup));
        patch = new File (nvdir, "patch-" + auxgroup + overs + ".dat");
        createPatch (patch, orsrcs, nrsrcs, verbose);
    }
}


public final void handleArchiveStart (final File parentDir, final File archive, final Manifest manifest) {
    final Logger log = m_log;
    if (log.atTRACE2 ()) log.trace2 ("handleArchiveStart", "[" + parentDir + "] [" + archive + "]");
    if (DO_DEPENDS_CHECKING) {
        final File fullArchiveFile = Files.newFile (parentDir, archive);
        m_currentArchiveTS = fullArchiveFile.lastModified ();
        if ($assert.ENABLED) $assert.ASSERT (m_currentArchiveTS > 0, "invalid ts: " + m_currentArchiveTS);
    }
    if ((m_outMode == OutMode.OUT_MODE_FULLCOPY) || (m_outMode == OutMode.OUT_MODE_OVERWRITE)) {
        final Manifest outManifest = manifest != null ? new Manifest (manifest) : new Manifest ();
        final Attributes mainAttrs = outManifest.getMainAttributes ();
        if (manifest == null) mainAttrs.put (Attributes.Name.MANIFEST_VERSION, "1.0");
        mainAttrs.put (new Attributes.Name ("Created-By"), IAppConstants.APP_NAME + " v" + IAppConstants.APP_VERSION_WITH_BUILD_ID_AND_TAG);
        mainAttrs.put (Attributes.Name.IMPLEMENTATION_TITLE, "instrumented version of [" + archive.getAbsolutePath () + "]");
        mainAttrs.put (Attributes.Name.SPECIFICATION_TITLE, "instrumented on " + new Date (m_timeStamp) + " [" + Property.getSystemFingerprint () + "]");
        if (m_outMode == OutMode.OUT_MODE_FULLCOPY) {
            try {
                final OutputStream out = new FileOutputStream (getFullOutFile (parentDir, archive, IN_LIB));
                m_archiveOut = outManifest != null ? new JarOutputStream (out, outManifest) : new JarOutputStream (out);
            } catch (IOException ioe) {
                throw new EMMARuntimeException (ioe);
            }
        }
        else if (m_outMode == OutMode.OUT_MODE_OVERWRITE) {
            m_origArchiveFile = Files.newFile (parentDir, archive);
            final String archiveName = Files.getFileName (archive) + IAppConstants.APP_NAME_LC;
            final String archiveExt = EMMAProperties.PROPERTY_TEMP_FILE_EXT;
            try {
                m_tempArchiveFile = Files.createTempFile (parentDir, archiveName, archiveExt);
                if (log.atTRACE2 ()) log.trace2 ("handleArchiveStart", "created temp archive [" + m_tempArchiveFile.getAbsolutePath () + "]");
                final OutputStream out = new FileOutputStream (m_tempArchiveFile);
                m_archiveOut = outManifest != null ? new JarOutputStream (out, outManifest) : new JarOutputStream (out);
            } catch (IOException ioe) {
                throw new EMMARuntimeException (ioe);
            }
        }
    }
}


-----Function Pair=142=-----==

protected static String getZipEntryName (File directory, File file, boolean pathWithFirstDirectory) throws IOException {
    String ret = file.getPath ();
    String sourcePath = directory.getPath ();
    int ind = ret.indexOf (sourcePath);
    if (ind >= 0) {
        if (pathWithFirstDirectory) {
            sourcePath = sourcePath.replaceAll (directory.getName (), "");
        }
        ret = ret.substring (sourcePath.length ());
    }
    else {
        throw new IOException ("Erreur: getZipEntryName -- ???");
    }
    StringBuffer tmpBuf = new StringBuffer ();
    char tmpChar;
    for (int i = 0; i < ret.length (); i ++) {
        tmpChar = ret.charAt (i);
        if (tmpChar == '\\') {
            tmpBuf.append ('/');
        }
        else {
            tmpBuf.append (tmpChar);
        }
    }
    if (tmpBuf.charAt (0) == '/') {
        return tmpBuf.toString ().substring (1);
    }
    else {
        return tmpBuf.toString ();
    }
}


public JarReader (String jarPath, String midletName) throws DataPrepException {
    ZipEntry mapIndex;
    this.jarPath = jarPath;
    this.midletName = midletName;
    try {
        this.jarFile = new ZipFile (jarPath);
    } catch (IOException e) {
        if (Main.DEBUG) e.printStackTrace ();
        throw new DataPrepException (DataPrepException.INVALID_JAR);
    }
    this.parseManifest ();
    if ((mapIndex = this.jarFile.getEntry (MAP_INDEX_FILE)) != null) {
        DataInputStream is = null;
        int maxId = 0;
        try {
            is = new DataInputStream (this.jarFile.getInputStream (mapIndex));
            this.jarMapIds = new int [is.readInt ()];
            for (int i = 0; i < this.jarMapIds.length; ++ i) {
                this.jarMapIds [i] = is.readInt ();
                if (this.jarMapIds [i] > maxId) {
                    maxId = this.jarMapIds [i];
                }
            }
            this.newMapId = maxId + 1;
        } catch (IOException e) {
            if (Main.DEBUG) e.printStackTrace ();
            throw new DataPrepException (DataPrepException.INVALID_JAR);
        } finally {
            try {
                if (is != null) {
                    is.close ();
                }
            } catch (Exception e) {
            }
        }
    }
    else {
        this.newMapId = 1;
        this.jarMapIds = new int [0];
    }
}


-----Function Pair=143=-----==

public void createZip (File zipFileName, Vector < File > selected) {
    try {
        byte [] buffer = new byte [4096];
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipFileName), 8096));
        out.setLevel (Deflater.BEST_COMPRESSION);
        out.setMethod (ZipOutputStream.DEFLATED);
        for (int i = 0; i < selected.size (); i ++) {
            FileInputStream in = new FileInputStream (selected.get (i));
            String file = selected.get (i).getPath ();
            if (file.indexOf ("\\") != - 1) file = file.substring (file.lastIndexOf (Options.fs) + 1, file.length ());
            ZipEntry ze = new ZipEntry (file);
            out.putNextEntry (ze);
            int len;
            while ((len = in.read (buffer)) > 0) out.write (buffer, 0, len);
            out.closeEntry ();
            in.close ();
            selected.get (i).delete ();
        }
        out.close ();
    } catch (IllegalArgumentException iae) {
        iae.printStackTrace ();
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


public void generateText (File input, File output, int width, int height) {
    ImageGenerator imageGenerator = new ImageGenerator (o);
    if (input.isDirectory () && output.isDirectory ()) try {
        File [] dir = input.listFiles ();
        Vector < File > v = new Vector < File > ();
        for (int i = 0; i < dir.length; i ++) try {
            String end = dir [i].toString ().substring (dir [i].toString ().lastIndexOf (".") + 1, dir [i].toString ().length ());
            if (dir [i].isFile () && (end.equalsIgnoreCase ("jpg") || end.equalsIgnoreCase ("jpeg"))) v.addElement (dir [i]);
        } catch (Exception st) {
            st.printStackTrace ();
        }
        System.out.println (mes.getString ("Generator.28", v.size (), input.toString (), Integer.toString ((int) (o.getQuality () * 100))) + ls + ls);
        for (int i = 0; i < v.size (); i ++) {
            System.out.print (mes.getString ("Generator.10") + v.elementAt (i).getName () + "\t . . . ");
            try {
                imageGenerator.generateImage (output, v.elementAt (i), ImageIO.read (v.elementAt (i)));
                System.out.println (mes.getString ("Generator.12"));
            } catch (Exception e) {
                System.out.println ("error");
                e.printStackTrace ();
            }
        }
        System.out.println (ls + mes.getString ("Generator.44", v.size (), output) + ls);
    } catch (Exception ex) {
        System.out.println (ex);
    }
    else if (input.isFile ()) {
        try {
            imageGenerator.generateImage (output, input, ImageIO.read (input));
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=144=-----==

public void actionPerformed (ActionEvent e) {
    Roster roster = Roster.instance ();
    ZipOutputStream zipper = null;
    try {
        String roster_filename_extension = ".roster";
        JFileChooser chooser = new JFileChooser ();
        int returnVal = chooser.showSaveDialog (_parent);
        if (returnVal != JFileChooser.APPROVE_OPTION) {
            return;
        }
        String filename = chooser.getSelectedFile ().getAbsolutePath ();
        if (! filename.endsWith (roster_filename_extension)) {
            filename = filename.concat (roster_filename_extension);
        }
        zipper = new ZipOutputStream (new FileOutputStream (filename));
        for (int index = 0; index < roster.numEntries (); index ++) {
            RosterEntry entry = roster.getEntry (index);
            copyFileToStream (entry.getPathName (), "roster", zipper, entry.getId ());
        }
        copyFileToStream (Roster.defaultRosterFilename (), null, zipper, null);
        zipper.setComment ("Roster file saved from DecoderPro " + jmri.Version.name ());
        zipper.close ();
    } catch (FileNotFoundException ex) {
        ex.printStackTrace ();
    } catch (IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (zipper != null) {
            try {
                zipper.close ();
            } catch (IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
}


void writeJad (String jarLocation, long jarSize) throws IOException {
    DataOutputStream os = new DataOutputStream (this.jadFile);
    for (int i = 0; i < this.manifestLines.size (); ++ i) {
        for (int j = 0; j < MANIFEST_ONLY_LINES.length; ++ j) {
            if (this.manifestLines.elementAt (i).startsWith (MANIFEST_ONLY_LINES [j])) {
                continue;
            }
        }
        os.writeBytes (this.manifestLines.elementAt (i));
        os.writeByte ('\n');
    }
    os.writeBytes (JAD_FILESIZE + JAD_SEPARATOR + jarSize + "\n");
    os.writeBytes (JAD_FILENAME + JAD_SEPARATOR + jarLocation + "\n");
    os.flush ();
    this.jadFile.close ();
    this.jadFile = null;
}


-----Function Pair=145=-----==

public static void gzip (String filesource, String gzdest) throws FileNotFoundException, IOException {
    GZIPOutputStream out = new GZIPOutputStream (new FileOutputStream (gzdest));
    try {
        BufferedOutputStream bos = new BufferedOutputStream (out);
        try {
            FileInputStream in = new FileInputStream (filesource);
            try {
                BufferedInputStream bis = new BufferedInputStream (in);
                try {
                    byte [] buf = new byte [BUFFER_SIZE];
                    int len;
                    while ((len = bis.read (buf, 0, BUFFER_SIZE)) > 0) {
                        bos.write (buf, 0, len);
                    }
                    buf = null;
                } finally {
                    bis.close ();
                }
            } finally {
                in.close ();
            }
        } finally {
            bos.close ();
        }
    } finally {
        out.close ();
    }
    if (! new File (gzdest).exists ()) throw new FileNotFoundException ("Le fichier " + gzdest + " n'a pas �t� cr��");
}


private void writeDirectory () throws IOException {
    long pad = 10;
    if (index.size () == 0) {
        file.seek (dirStartLoc);
        file.writeLong (0);
    }
    else {
        long loc = allocateSpace (blockSize);
        file.seek (dirStartLoc);
        file.writeLong (loc);
        long stopLoc = loc + blockSize;
        file.seek (loc);
        file.writeLong (blockSize);
        Collection c = index.values ();
        Iterator i = c.iterator ();
        while (i.hasNext ()) {
            DirEntry d = (DirEntry) i.next ();
            if ((d.estimateSize () + loc + pad) > stopLoc) {
                loc = allocateSpace (blockSize);
                file.writeByte (0);
                file.writeLong (loc);
                file.seek (loc);
                file.writeLong (blockSize);
                stopLoc = loc + blockSize;
            }
            file.writeByte (1);
            d.write ();
            loc = file.getFilePointer ();
            if (loc >= stopLoc) {
                throw new Error ("Writing directory exceeded block size");
            }
        }
        file.writeByte (0);
        file.writeLong (0);
    }
}


-----Function Pair=146=-----==

public void process (String filename) {
    double start = System.currentTimeMillis ();
    Console.println (0, "Saving file " + filename + ".");
    Console.startProgress ("Saving file.");
    ONDEXGraph graph = mainFrame.getONDEXGraph ();
    if (visible) graph = processVisible (graph);
    try {
        XMLEncoder encoder;
        if (! packed) {
            encoder = new XMLEncoder (new BufferedOutputStream (new FileOutputStream (filename)));
        }
        else {
            File file = new File (filename);
            ZipEntry zipEntry = new ZipEntry (file.getName ());
            ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (file));
            zipOutputStream.putNextEntry (zipEntry);
            encoder = new XMLEncoder (new BufferedOutputStream (zipOutputStream));
        }
        encoder.setPersistenceDelegate (Object2ObjectOpenHashMap.class, encoder.getPersistenceDelegate (Map.class));
        encoder.setPersistenceDelegate (Int2ObjectOpenHashMap.class, encoder.getPersistenceDelegate (Map.class));
        encoder.writeObject (graph);
        encoder.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    Console.println (0, "Saving finished. - " + (System.currentTimeMillis () - start) / 1000 + " s");
    Console.stopProgress ();
}


public static byte [] getBytesFromFile (File file) throws IOException {
    InputStream is = new FileInputStream (file);
    long length = file.length ();
    if (length > Integer.MAX_VALUE) {
    }
    byte [] bytes = new byte [(int) length];
    int offset = 0;
    int numRead = 0;
    while (offset < bytes.length && (numRead = is.read (bytes, offset, bytes.length - offset)) >= 0) {
        offset += numRead;
    }
    if (offset < bytes.length) {
        throw new IOException ("Could not completely read file " + file.getName ());
    }
    is.close ();
    return bytes;
}


-----Function Pair=147=-----==

private static void findFilesHelper (File file, String [] filteredExtensions, Vector result) {
    if (! file.exists ()) {
        return;
    }
    if (file.isDirectory ()) {
        String [] entries = file.list ();
        for (int i = 0; i < entries.length; i ++) {
            findFilesHelper (new File (file, entries [i]), filteredExtensions, result);
        }
    }
    else {
        if ((filteredExtensions == null) || (filteredExtensions.length == 0)) {
            result.addElement (file);
            return;
        }
        for (int i = 0; i < filteredExtensions.length; i ++) {
            if (file.getName ().endsWith (filteredExtensions [i])) {
                result.addElement (file);
                return;
            }
        }
    }
}


protected void writeCentralFileHeader (ZipEntry ze) throws IOException {
    writeOut (CFH_SIG);
    written += WORD;
    writeOut (ZipShort.getBytes ((ze.getPlatform () << 8) | 20));
    written += SHORT;
    if (ze.getMethod () == DEFLATED && raf == null) {
        writeOut (ZipShort.getBytes (20));
        writeOut (ZipShort.getBytes (8));
    }
    else {
        writeOut (ZipShort.getBytes (10));
        writeOut (ZERO);
    }
    written += WORD;
    writeOut (ZipShort.getBytes (ze.getMethod ()));
    written += SHORT;
    writeOut (toDosTime (ze.getTime ()));
    written += WORD;
    writeOut (ZipLong.getBytes (ze.getCrc ()));
    writeOut (ZipLong.getBytes (ze.getCompressedSize ()));
    writeOut (ZipLong.getBytes (ze.getSize ()));
    written += 12;
    byte [] name = getBytes (ze.getName ());
    writeOut (ZipShort.getBytes (name.length));
    written += SHORT;
    byte [] extra = ze.getCentralDirectoryExtra ();
    writeOut (ZipShort.getBytes (extra.length));
    written += SHORT;
    String comm = ze.getComment ();
    if (comm == null) {
        comm = "";
    }
    byte [] commentB = getBytes (comm);
    writeOut (ZipShort.getBytes (commentB.length));
    written += SHORT;
    writeOut (ZERO);
    written += SHORT;
    writeOut (ZipShort.getBytes (ze.getInternalAttributes ()));
    written += SHORT;
    writeOut (ZipLong.getBytes (ze.getExternalAttributes ()));
    written += WORD;
    writeOut ((byte []) offsets.get (ze));
    written += WORD;
    writeOut (name);
    written += name.length;
    writeOut (extra);
    written += extra.length;
    writeOut (commentB);
    written += commentB.length;
}


-----Function Pair=148=-----==

private static void zipFileOrDirectory (ZipOutputStream out, File fileOrDirectory, String curPath) {
    FileInputStream in = null;
    try {
        if (! fileOrDirectory.isDirectory ()) {
            byte [] buffer = new byte [4096];
            int bytes_read;
            in = new FileInputStream (fileOrDirectory);
            ZipEntry entry = new ZipEntry (curPath + fileOrDirectory.getName ());
            out.putNextEntry (entry);
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
            }
            out.closeEntry ();
        }
        else {
            File [] entries = fileOrDirectory.listFiles ();
            for (int i = 0; i < entries.length; i ++) {
                zipFileOrDirectory (out, entries [i], curPath + fileOrDirectory.getName () + "/");
            }
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (IOException ex) {
            }
        }
    }
}


public static void unzip (InputStream in, String output) {
    try {
        if (! output.endsWith ("/")) output = output + "/";
        ZipInputStream zip = new ZipInputStream (in);
        ZipEntry entry = null;
        while ((entry = zip.getNextEntry ()) != null) {
            if (entry.isDirectory ()) {
                FileUtils.forceMkdir (new File (output + entry.getName ()));
            }
            else {
                FileOutputStream out = new FileOutputStream (output + entry.getName ());
                byte [] buffer = new byte [1024];
                int length = - 1;
                while ((length = zip.read (buffer, 0, 1024)) > 0) {
                    out.write (buffer, 0, length);
                }
                IOUtils.closeQuietly (out);
            }
        }
        IOUtils.closeQuietly (in);
    } catch (Exception e) {
        log.error ("���ܳɹ���ѹ��!", e);
        throw new RuntimeException ("���ܳɹ���ѹ��!", e);
    }
}


-----Function Pair=149=-----==

protected void processRequest (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType ("application/zip");
    response.setHeader ("Content-Disposition", "inline; filename=c:/server1.zip");
    try {
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream ("server.zip");
        ZipOutputStream zipOut = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        java.util.Properties props = new java.util.Properties ();
        props.load (new java.io.FileInputStream (ejb.bprocess.util.NewGenLibRoot.getRoot () + "/SystemFiles/ENV_VAR.txt"));
        String jbossHomePath = props.getProperty ("JBOSS_HOME");
        jbossHomePath = jbossHomePath.replaceAll ("deploy", "log");
        FileInputStream fis = new FileInputStream (new File (jbossHomePath + "/server.log"));
        origin = new BufferedInputStream (fis, BUFFER);
        ZipEntry entry = new ZipEntry (jbossHomePath + "/server.log");
        zipOut.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            zipOut.write (data, 0, count);
        }
        origin.close ();
        zipOut.closeEntry ();
        java.io.FileInputStream fis1 = new java.io.FileInputStream (new java.io.File ("server.zip"));
        java.nio.channels.FileChannel fc1 = fis1.getChannel ();
        int length1 = (int) fc1.size ();
        byte buffer [] = new byte [length1];
        System.out.println ("size of zip file = " + length1);
        fis1.read (buffer);
        OutputStream out1 = response.getOutputStream ();
        out1.write (buffer);
        fis1.close ();
        out1.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void escreveLinhaArquivo (DadosSeriais dados) throws BasicException {
    Date valorData = null;
    String coluna = "";
    List < String > dadosHash = new ArrayList < String > ();
    for (int l = 0; l < dados.getDados ().size (); l ++) {
        Object [] linha = dados.getDados ().get (l);
        int num = l + cont;
        String str = null;
        try {
            xmlWriter.writeStartElement ("linha");
            xmlWriter.writeAttribute ("num", "" + num);
            for (int c = 0; c < linha.length; c ++) {
                Object valor = linha [c];
                int tipo = tipos [c];
                xmlWriter.writeStartElement ("col");
                xmlWriter.writeAttribute ("num", "" + c);
                if (valor == null) {
                    xmlWriter.writeAttribute ("nulo", "true");
                }
                else {
                    coluna += ">";
                    switch (tipo) {
                        case TEXTO :
                            str = expurgaCaracteresInvalidos (valor.toString ());
                            xmlWriter.writeCData (str);
                            dadosHash.add (str);
                            break;
                        case INTEIRO :
                            xmlWriter.writeCharacters (valor.toString ());
                            dadosHash.add (valor.toString ());
                            break;
                        case DATA :
                            valorData = (java.util.Date) valor;
                            String strData = dateFormat.format (valorData);
                            xmlWriter.writeCharacters (strData);
                            dadosHash.add (strData);
                            break;
                        case DECIMAL :
                            coluna += decimalFormat.format ((Number) valor) + "</col>";
                            xmlWriter.writeCharacters (decimalFormat.format ((Number) valor));
                            dadosHash.add (decHash.format ((Number) valor));
                    }
                }
                xmlWriter.writeEndElement ();
            }
            xmlWriter.writeEndElement ();
        } catch (Exception e) {
            throw BasicException.errorHandling ("Erro ao escrever dados em arquivo compactado", "msgErroEscreverArquivoDadosXML", e, log);
        }
        calculadorHash.adicionaLinha (dadosHash);
    }
    cont += dados.getDados ().size ();
}


-----Function Pair=150=-----==

public boolean doZipFile (String fileName, String outfile, String zipentry) {
    BufferedInputStream origin = null;
    try {
        if (! (new File (fileName)).isFile ()) return false;
        FileOutputStream dest = new FileOutputStream (outfile);
        CheckedOutputStream checksum = new CheckedOutputStream (dest, new Adler32 ());
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (checksum));
        byte data [] = new byte [BUFFER];
        FileInputStream fi = new FileInputStream (fileName);
        origin = new BufferedInputStream (fi, BUFFER);
        ZipEntry entry = new ZipEntry (FileUtil.getFileName (zipentry));
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
    return true;
}


private String getFollowingFile (String dir, String fname) {
    AbsTime argdate = null;
    if (isCompressed (fname)) {
        argdate = AbsTime.factory (getDateTime (fname.substring (0, fname.length () - 4)));
    }
    else {
        argdate = AbsTime.factory (getDateTime (fname));
    }
    String [] files = (new File (dir)).list ();
    if (files == null || files.length == 0) {
        return null;
    }
    RelTime afterdiff = null;
    String aftername = null;
    for (int i = 0; i < files.length; i ++) {
        Date date = null;
        if (isCompressed (files [i])) {
            date = getDateTime (files [i].substring (0, files [i].length () - 4));
        }
        else {
            date = getDateTime (files [i]);
        }
        if (date == null) {
            System.err.println ("PointArchiverASCII:getFollowingFile: Bad File Name " + files [i] + " in directory " + dir);
            continue;
        }
        AbsTime thisdate = AbsTime.factory (date);
        if (thisdate.isAfter (argdate)) {
            RelTime thisdiff = Time.diff (thisdate, argdate);
            if (afterdiff == null || thisdiff.getValue () < afterdiff.getValue ()) {
                afterdiff = thisdiff;
                aftername = files [i];
            }
        }
    }
    return aftername;
}


-----Function Pair=151=-----==

protected void addMeasureChart (String chartType, ReportGenerationMeasure reportGenMeasure) throws Exception {
    ChartHandlerObject chartHandler = null;
    try {
        Context initialContext = new InitialContext ();
        ChartHandlerHome chartHandlerHome = (ChartHandlerHome) PortableRemoteObject.narrow (initialContext.lookup (ChartHandlerHome.COMP_NAME), ChartHandlerHome.class);
        chartHandler = chartHandlerHome.create ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    Vector charts;
    byte [] b;
    charts = chartHandler.createMeasureCharts (chartType, reportGenMeasure);
    Enumeration enumCharts = charts.elements ();
    int chartNb = 1;
    while (enumCharts.hasMoreElements ()) {
        b = (byte []) enumCharts.nextElement ();
        String filename = chartType + chartNb + new Date ().getTime () + ".png";
        chartNb ++;
        if (reportDocHandler.isHTMLGeneration ()) imageByteArrays.put (filename, b);
        reportDocHandler.addReportText ("");
        reportDocHandler.addImage (b, "images/" + filename);
    }
}


public boolean fetchExecutionResults (EKnownAction eka) throws NJSException {
    if (eka.areResultsFetched ()) {
        if (gas_instance != null) {
            if (eka.getOutcome () instanceof AbstractTask_Outcome) {
                ResourceSet used = gas_instance.parseResources (eka.getExecutionResults ());
                ((AbstractTask_Outcome) eka.getOutcome ()).setResources (used);
                gas_instance.jobEnded (used, eka.getId ());
            }
        }
        return true;
    }
    else {
        String bssid = eka.getBSSId ();
        if (bssid == null) {
            if (logger.CHAT) logger.chat ("No BSS Id, assuming interactive execution.");
            bssid = "NONE";
        }
        if (bssid.equals ("")) {
            throw new NJSException ("Suspicious BSS Identifier, cannot fetch stdout/stderr.");
        }
        String outcome_directory = eka.getOutcomeStore ().getDirectory ();
        String disposition;
        if (eka.getAction () instanceof ExecuteTask) {
            if (eka.wasCancelled ()) {
                disposition = "DELETE";
            }
            else {
                disposition = "KEEP";
            }
        }
        else {
            disposition = "DELETE";
        }
        TSIConnection c = null;
        try {
            String commands = makeTSIIdentityLine (eka.getUspace ()) + "#TSI_ENDPROCESSING\n" + "#TSI_BSSID " + bssid + "\n" + "#TSI_OUTCOME_DIR " + outcome_directory + "\n" + "#TSI_DISPOSITION " + disposition + "\n";
            c = getTSIConnectionFactory ().getTSIConnection (eka.getIncarnatedUser ());
            String reply = c.send (commands);
            if (reply.indexOf ("UNICORE EXIT STATUS ") >= 0) {
                eka.setExecutionResults (reply);
                if (gas_instance != null) {
                    if (eka.getOutcome () instanceof AbstractTask_Outcome) {
                        ResourceSet used = gas_instance.parseResources (eka.getExecutionResults ());
                        ((AbstractTask_Outcome) eka.getOutcome ()).setResources (used);
                        gas_instance.jobEnded (used, eka.getId ());
                    }
                }
                return true;
            }
            else if (reply.indexOf ("TSI_STILLEXECUTING") >= 0) {
                if (eka.continueTestingForCompletion ()) {
                    eka.logEvent ("Job may be complete but output files not found. Assuming that job still executing");
                    return false;
                }
                else {
                    eka.logError ("Can't find output files, tried lots of times, ending job with error.");
                    eka.setExecutionResults ("TSI_OK\nUNICORE EXIT STATUS 999 +");
                    if (gas_instance != null) gas_instance.jobEnded ((ResourceSet) null, eka.getId ());
                    return true;
                }
            }
            else if (reply.startsWith ("TSI_FAILED")) {
                throw new NJSException ("Problems in end processing: " + reply);
            }
            else {
                if (eka.wasAborted () || eka.wasCancelled ()) {
                    eka.setExecutionResults ("TSI_OK\nUNICORE EXIT STATUS 0 +");
                    if (gas_instance != null) gas_instance.jobEnded ((ResourceSet) null, eka.getId ());
                    return true;
                }
                else {
                    if (eka.continueTestingForCompletion ()) {
                        eka.logEvent ("Output files found but incomplete (no status). Assuming that job still executing");
                        return false;
                    }
                    else {
                        eka.logError ("Output files are incomplete, tried lots of times, ending job with error.");
                        eka.setExecutionResults ("TSI_OK\nUNICORE EXIT STATUS 999 +");
                        if (gas_instance != null) gas_instance.jobEnded ((ResourceSet) null, eka.getId ());
                        return true;
                    }
                }
            }
        } catch (TSIUnavailableException tuex) {
            eka.logTrace ("Execution result not fectched yet because: " + tuex.getMessage ());
            return false;
        } catch (Exception ex) {
            throw new NJSException ("Fetch of results (stdout/stderr) failed\n" + ex.getMessage ());
        } finally {
            try {
                if (c != null) c.done ();
            } catch (Exception ex) {
            }
        }
    }
}


-----Function Pair=152=-----=1=

protected void addFile (Menu menu, String filepath) {
    try {
        File currentFile = new File (filepath);
        InputStream is = new FileInputStream (currentFile);
        BufferedInputStream bis = new BufferedInputStream (is);
        String decodedMenuPath = decodeMenuPath (menu.getMenuPath ());
        decodedMenuPath = decodedMenuPath + "/" + currentFile.getName ();
        decodedMenuPath = decodedMenuPath.replaceAll ("//", "/");
        ZipEntry entry = new ZipEntry (decodedMenuPath);
        zos.putNextEntry (entry);
        int len;
        while ((len = bis.read ()) != - 1) {
            zos.write (len);
        }
        bis.close ();
    } catch (Exception e) {
        log.error (e.getMessage (), e);
    }
}


public void store (OutputStream out) throws IOException {
    int u;
    Iterator i;
    ZipEntry ze;
    Map.Entry entry;
    ZipOutputStream zip;
    u = 0;
    zip = new ZipOutputStream (out);
    synchronized (map_) {
        for (i = map_.entrySet ().iterator (); i.hasNext ();) {
            entry = (Map.Entry) i.next ();
            ze = new ZipEntry ((String) entry.getKey ());
            zip.putNextEntry (ze);
            u ++;
            zip.write ((byte []) entry.getValue ());
            zip.closeEntry ();
        }
    }
}


-----Function Pair=153=-----==

public static Configurable load (String filename, String type, String tempdir) throws EDITSException {
    File file = new File (filename);
    if (! file.exists ()) throw new EDITSException ("The file " + filename + " does not exist!");
    if (! file.canRead ()) throw new EDITSException ("The file " + filename + " can not be read.");
    if (tempdir == null) tempdir = EDITS.system ().tempdir ();
    if (new File (tempdir).exists ()) new File (tempdir).mkdir ();
    tempdir = tempdir + SerializationManager.getDate () + "/";
    new File (tempdir).mkdir ();
    SerializationManager.unzipModel (filename, tempdir);
    String confFile = tempdir + "/conf.xml";
    Configurations conf = loadConfigurations (confFile);
    ConfigurationLoader loader = new ConfigurationLoader (MODELPATH, tempdir);
    loader.processConfiguration (conf);
    Configurable c = ModuleLoader.loadModule (conf, type);
    if (c == null) throw new EDITSException ("The file " + filename + " does not contain " + type + "!");
    c.read (tempdir, DEFAILT_ID);
    SerializationManager.delete (new File (tempdir));
    return c;
}


boolean initGamedat (boolean create) {
    if (create) {
        System.out.println ("Creating 'gamedat' files.");
        String fname = EFile.PATCH_INITGAME;
        try {
            if (EUtil.U7exists (fname) != null) restoreGamedat (fname);
            else {
                game.setNewGame ();
                restoreGamedat (fname = EFile.INITGAME);
            }
        } catch (IOException e) {
            ExultActivity.fileFatal (fname);
        }
    }
    else if (EUtil.U7exists (EFile.IDENTITY) == null) {
        return false;
    }
    else {
        byte id [] = new byte [256];
        try {
            RandomAccessFile identity_file = EUtil.U7open (EFile.IDENTITY, false);
            int i, cnt = identity_file.read (id);
            identity_file.close ();
            for (i = 0; i < cnt && id [i] != 0x1a && id [i] != 0x0d && id [i] != 0x0a; i ++);
            System.out.println ("Gamedat identity " + new String (id, 0, i));
        } catch (IOException e) {
        }
    }
    return true;
}


-----Function Pair=154=-----=1=

private void addExistingFileToZip (ZipOutputStream out, String entryName, String filePath) {
    if (filePath != null) {
        byte [] buf = new byte [1024];
        try {
            BufferedReader br = new BufferedReader (new FileReader (filePath));
            out.putNextEntry (new ZipEntry (entryName));
            int data;
            while ((data = br.read ()) != - 1) {
                out.write (data);
            }
            out.closeEntry ();
            br.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


private static void zipFile (File resFile, ZipOutputStream zipout, String rootpath) throws FileNotFoundException, IOException {
    rootpath = rootpath + (rootpath.trim ().length () == 0 ? "" : File.separator) + resFile.getName ();
    rootpath = new String (rootpath.getBytes ("8859_1"), "GB2312");
    if (resFile.isDirectory ()) {
        File [] fileList = resFile.listFiles ();
        for (File file : fileList) {
            zipFile (file, zipout, rootpath);
        }
    }
    else {
        byte buffer [] = new byte [BUFF_SIZE];
        BufferedInputStream in = new BufferedInputStream (new FileInputStream (resFile), BUFF_SIZE);
        zipout.putNextEntry (new ZipEntry (rootpath));
        int realLength;
        while ((realLength = in.read (buffer)) != - 1) {
            zipout.write (buffer, 0, realLength);
        }
        in.close ();
        zipout.flush ();
        zipout.closeEntry ();
    }
}


-----Function Pair=155=-----==

public static LinkedHashMap buildDirectoryFileGroups (String map) {
    String [] lines = map.split (",");
    LinkedHashMap hash = new LinkedHashMap ();
    for (int i = 0; i < lines.length; i ++) {
        String [] keyValue = lines [i].split ("=");
        if (keyValue.length != 2) {
            System.out.println ("\nError: key=value pair not found? -> " + lines [i] + "\n");
            return null;
        }
        File file = new File (keyValue [1]);
        if (file.canRead () == false || file.isDirectory () == false) {
            System.out.println ("\nError: could not read this directory -> " + file + "\n");
            return null;
        }
        if (hash.containsKey (keyValue [0])) {
            System.out.println ("\nError: duplicate key found -> " + lines [i] + "\n");
            return null;
        }
        hash.put (keyValue [0], file);
    }
    return hash;
}


public void add (ImagePlus imp, Roi roi, int n) {
    if (roi == null) return;
    String label = getLabel (imp, roi, n);
    if (label == null) return;
    list.add (label);
    roi.setName (label);
    roiCopy = (Roi) roi.clone ();
    if (imp != null) {
        Calibration cal = imp.getCalibration ();
        if (cal.xOrigin != 0.0 || cal.yOrigin != 0.0) {
            Rectangle r = roiCopy.getBounds ();
            roiCopy.setLocation (r.x - (int) cal.xOrigin, r.y - (int) cal.yOrigin);
        }
    }
    rois.put (label, roiCopy);
}


-----Function Pair=156=-----==

private String addImage (String fieldName, Element record, String mergedFieldName, List < ImageToMerge > imagesToMerge) {
    List < Element > imageRecords = XMLUtil.getChildren (record, "imagefield");
    for (int i = 0; i < imageRecords.size (); i ++) {
        Element imageRecord = (Element) imageRecords.get (i);
        String name = XMLUtil.getStringAttr (imageRecord, "name");
        if (name != null && fieldName.endsWith (name)) {
            String fileName = XMLUtil.getTextTrim (imageRecord);
            File file = new File (fileName);
            int extIndx = fileName.lastIndexOf (".");
            String mergedFileName;
            if (extIndx != - 1) mergedFileName = mergedFieldName + fileName.substring (extIndx);
            else mergedFileName = mergedFieldName + ".gif";
            imagesToMerge.add (new ImageToMerge (mergedFileName, file));
            return mergedFileName;
        }
    }
    return null;
}


public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {
    int k_blockSize = 1024;
    int byteCount;
    char [] buf = new char [k_blockSize];
    File ofp = new File (outFile);
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));
    zos.setMethod (ZipOutputStream.DEFLATED);
    OutputStreamWriter osw = new OutputStreamWriter (zos, "ISO-8859-1");
    BufferedWriter bw = new BufferedWriter (osw);
    ZipEntry zot = null;
    File ifp = new File (inFile);
    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));
    InputStreamReader isr = new InputStreamReader (zis, "ISO-8859-1");
    BufferedReader br = new BufferedReader (isr);
    ZipEntry zit = null;
    while ((zit = zis.getNextEntry ()) != null) {
        if (zit.getName ().equals ("content.xml")) {
            continue;
        }
        zot = new ZipEntry (zit.getName ());
        zos.putNextEntry (zot);
        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);
        bw.flush ();
        zos.closeEntry ();
    }
    zos.putNextEntry (new ZipEntry ("content.xml"));
    bw.flush ();
    osw = new OutputStreamWriter (zos, "UTF8");
    bw = new BufferedWriter (osw);
    return bw;
}


-----Function Pair=157=-----==

public static String getFileString (String filePath, String fileName) {
    String str = "";
    StringBuffer sb = new StringBuffer ("");
    if (new File (filePath + fileName).exists ()) {
        try {
            FileInputStream fileInputStream = new FileInputStream (filePath + fileName);
            InputStreamReader inputStreamReader = new InputStreamReader (fileInputStream, "UTF8");
            int ch = 0;
            while ((ch = inputStreamReader.read ()) != - 1) {
                sb.append ((char) ch);
            }
            fileInputStream.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
    else {
        Common.errorReport ("沒有找到" + filePath + fileName + "此一檔案");
    }
    return sb.toString ();
}


public Archive (String filename, boolean readonly) throws IOException {
    this.readOnly = readonly;
    File f = new File (filename);
    if (! f.exists ()) {
        if (readonly) {
            throw new IOException ("No such file " + filename);
        }
        file = new RandomAccessFile (filename, "rw");
        initializeFile ();
    }
    else if (readonly && USE_MAP) {
        FileInputStream fs = new FileInputStream (f);
        FileChannel fc = fs.getChannel ();
        bb = fc.map (FileChannel.MapMode.READ_ONLY, 0, f.length ());
    }
    else {
        file = new RandomAccessFile (filename, readonly ? "r" : "rw");
    }
    if (readOnly && USE_MAP) {
        readHeaderViaMap ();
    }
    else {
        readHeader ();
    }
    if (! readOnly) {
        readFreeList ();
    }
    if (readOnly && USE_MAP) {
        readDirectoryViaMap ();
    }
    else {
        readDirectory ();
    }
}


-----Function Pair=158=-----==

public static RecordTableModel inputRecordTableFile () {
    String dataString = getFileString (SetUp.getRecordFileDirectory (), "recordList.dat");
    if (! dataString.matches ("\\s*_OVER_\\s*")) {
        String [] rowStrings = dataString.split ("%%%%%%");
        Common.debugPrint ("將讀入記錄數量: " + (rowStrings.length - 1));
        RecordTableModel tableModel = new RecordTableModel (ComicDownGUI.getRecordColumns (), rowStrings.length - 1);
        try {
            for (int row = 0; row < rowStrings.length - 1; row ++) {
                String [] colStrings = rowStrings [row].split ("@@@@@@");
                for (int col = 0; col < ComicDownGUI.getRecordColumns ().size (); col ++) {
                    if (col == RecordTableEnum.ORDER) {
                        tableModel.setValueAt (new Integer (row + 1), row, col);
                    }
                    else {
                        tableModel.setValueAt (colStrings [col], row, col);
                    }
                }
                Common.recordCount ++;
            }
            Common.debugPrintln ("   ... 讀入完畢!!");
        } catch (Exception ex) {
            Common.debugPrintln ("   ... 讀入失敗!!");
        }
        return tableModel;
    }
    else {
        return new RecordTableModel (ComicDownGUI.getRecordColumns (), 0);
    }
}


protected static void addFileToJar (JarOutputStream jStream, File inputFile, String logicalFilename, ArrayList addedfiles) throws Exception {
    FileInputStream iStream = null;
    try {
        if (! addedfiles.contains (logicalFilename)) {
            iStream = new FileInputStream (inputFile);
            ZipEntry zipEntry = new ZipEntry (logicalFilename.replace ('\\', '/'));
            jStream.putNextEntry (zipEntry);
            byte [] byteBuffer = new byte [2 * 1024];
            int count = 0;
            do {
                jStream.write (byteBuffer, 0, count);
                count = iStream.read (byteBuffer, 0, byteBuffer.length);
            }
            while (count != - 1);
            addedfiles.add (logicalFilename);
        }
    } catch (IOException ioe) {
        tools.util.LogMgr.err ("Filetil.addFileToJar " + ioe);
        ioe.printStackTrace ();
    } finally {
        if (iStream != null) {
            try {
                iStream.close ();
            } catch (IOException closeException) {
            }
        }
    }
}


-----Function Pair=159=-----==

public static void runUnansiCmd (String program, String file) {
    if (! new File (file).exists ()) {
        String nowSkinName = UIManager.getLookAndFeel ().getName ();
        String colorString = "blue";
        if (nowSkinName.equals ("HiFi") || nowSkinName.equals ("Noire")) {
            colorString = "yellow";
        }
        JOptionPane.showMessageDialog (ComicDownGUI.mainFrame, "<html><font color=" + colorString + ">" + file + "</font>" + "不存在，無法開啟</html>", "提醒訊息", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    String [] cmd = new String [] {program, file};
    Map < String, String > newEnv = new HashMap < String, String > ();
    newEnv.putAll (System.getenv ());
    String [] i18n = new String [cmd.length + 2];
    i18n [0] = "cmd";
    i18n [1] = "/C";
    i18n [2] = cmd [0];
    for (int counter = 1; counter < cmd.length; counter ++) {
        String envName = "JENV_" + counter;
        i18n [counter + 2] = "%" + envName + "%";
        newEnv.put (envName, cmd [counter]);
    }
    cmd = i18n;
    ProcessBuilder pb = new ProcessBuilder (cmd);
    Map < String, String > env = pb.environment ();
    env.putAll (newEnv);
    try {
        final Process p = pb.start ();
    } catch (IOException ex) {
        Logger.getLogger (ComicDownGUI.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


-----Function Pair=160=-----==

private Association generateAssociation (ExtrinsicObject source, String type, ExtrinsicObject target) {
    AssociationImpl as = null;
    String id = null;
    try {
        if (type.contentEquals ("Extends")) {
            id = ASSOC_TYPE_EXTENDS;
        }
        else if (type.contentEquals ("Contains")) {
            id = ASSOC_TYPE_CONTAINS;
        }
        else if (type.contentEquals ("RelatedTo")) {
            id = ASSOC_TYPE_RELATEDTO;
        }
        else {
            System.out.println ("No Suitable Association Type Found.. Aborting");
            System.exit (1);
        }
        Concept cp = (Concept) bqm.getRegistryObject (id);
        as = new AssociationImpl ((LifeCycleManagerImpl) lcm);
        as.setAssociationType (cp);
        as.setSourceObject (source);
        as.setTargetObject (target);
    } catch (JAXRException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return as;
}


public static BufferedReader fetchBufferedReader (File txtFile) {
    BufferedReader in = null;
    try {
        String name = txtFile.getName ().toLowerCase ();
        if (name.endsWith (".zip")) {
            ZipFile zf = new ZipFile (txtFile);
            ZipEntry ze = (ZipEntry) zf.entries ().nextElement ();
            in = new BufferedReader (new InputStreamReader (zf.getInputStream (ze)));
        }
        else if (name.endsWith (".gz")) {
            in = new BufferedReader (new InputStreamReader (new GZIPInputStream (new FileInputStream (txtFile))));
        }
        else in = new BufferedReader (new FileReader (txtFile));
    } catch (Exception e) {
        e.printStackTrace ();
        safeClose (in);
    }
    return in;
}


-----Function Pair=161=-----==

public String compileFOP () throws EditorException {
    fopConfigPath = DocumentEngine.DEFAULT_FOP_CONFIG_FILE;
    File file = new File (fopConfigPath);
    fopConfigDir = file.getParentFile ().getAbsolutePath ();
    String filename = fopConfigDir + File.separator + "fop.zip";
    ZipOutputStream out = null;
    try {
        out = new ZipOutputStream (new FileOutputStream (filename));
    } catch (Exception ex) {
        String msg = "Unable to create a zip output stream.";
        throw new EditorException (msg, ex);
    }
    addDir (out, fopConfigDir);
    try {
        out.close ();
    } catch (Exception ex) {
        String msg = "Unable to close the input stream.";
        throw new EditorException (msg, ex);
    }
    return filename;
}


protected void compressOutputData () {
    boolean change = true;
    FormatData fd_head = null;
    FormatData fd_tail = null;
    ListIterator it;
    int ctr = 0;
    int len;
    FormatData fd = null;
    while (change) {
        if (m_fdList.size () == 0) break;
        fd_head = (FormatData) m_fdList.getFirst ();
        fd_tail = (FormatData) m_fdList.getLast ();
        if (fd_head.isWhiteSpace ()) {
            m_preNT.add (fd_head);
            m_fdList.removeFirst ();
            continue;
        }
        if (fd_tail.isWhiteSpace ()) {
            m_postNT.add (fd_tail);
            m_fdList.removeLast ();
            continue;
        }
        if (m_fdList.size () == 1) {
            if (fd_head.isTag ()) {
                m_preNT.add (fd_head);
                m_fdList.clear ();
            }
            break;
        }
        if (fd_tail.isTag () && ! fd_tail.isCloseTag ()) {
            m_postNT.add (fd_tail);
            m_fdList.removeLast ();
            continue;
        }
        if (fd_head.isTag () && fd_head.isCloseTag ()) {
            m_preNT.add (fd_head);
            m_fdList.removeFirst ();
            continue;
        }
        if (fd_tail.isTag () && fd_head.isTag () && (fd_tail.tagData () == fd_head.tagData ())) {
            if (m_fdList.size () == 1) break;
            m_postNT.add (fd_tail);
            m_preNT.add (fd_head);
            m_fdList.removeFirst ();
            m_fdList.removeLast ();
            continue;
        }
        if (fd_head.isTag ()) {
            it = m_fdList.listIterator ();
            ctr = 0;
            len = m_fdList.size ();
            while (it.hasNext ()) {
                fd = (FormatData) it.next ();
                if (ctr > 0) {
                    if (fd_head.tagData () == fd.tagData ()) break;
                }
                ctr ++;
            }
            if (ctr < len) {
                m_preNT.add (fd_head);
                m_fdList.removeFirst ();
                continue;
            }
        }
        if (m_fdList.size () == 1) {
            if (fd_head.isTag ()) {
                m_preNT.add (fd_head);
                m_fdList.clear ();
            }
            break;
        }
        if (fd_tail.isTag ()) {
            it = m_fdList.listIterator ();
            ctr = 0;
            len = m_fdList.size ();
            while (it.hasNext ()) {
                fd = (FormatData) it.next ();
                if (ctr < len) {
                    if (fd_tail.tagData () == fd.tagData ()) break;
                }
                ctr ++;
            }
            if (ctr < len) {
                m_postNT.add (fd_tail);
                m_fdList.removeLast ();
                continue;
            }
        }
        change = false;
    }
}


-----Function Pair=162=-----==

public void sliceWritePositionScoreData (int rowChunkSize, File saveDirectory, ArrayList < File > files2Zip) {
    int beginningIndex = 0;
    int endIndex = 0;
    int numberPositions = sortedPositionScores.length;
    while (true) {
        PositionScore [] slice;
        if (rowChunkSize == - 1) {
            beginningIndex = 0;
            endIndex = numberPositions;
            slice = sortedPositionScores;
        }
        else {
            beginningIndex = endIndex;
            endIndex = beginningIndex + rowChunkSize;
            if (endIndex > numberPositions) {
                endIndex = numberPositions;
            }
            else {
                int endBP = sortedPositionScores [endIndex - 1].getPosition ();
                for (int i = endIndex; i < numberPositions; i ++) {
                    if (sortedPositionScores [i].getPosition () != endBP) {
                        break;
                    }
                    endIndex ++;
                }
            }
            int num = endIndex - beginningIndex;
            slice = new PositionScore [num];
            System.arraycopy (sortedPositionScores, beginningIndex, slice, 0, num);
        }
        PositionScoreData.updateSliceInfo (slice, sliceInfo);
        PositionScoreData pd = new PositionScoreData (slice, sliceInfo);
        File savedFile = pd.write (saveDirectory, true);
        files2Zip.add (savedFile);
        if (endIndex == numberPositions) break;
    }
}


private void writeHistLogFile (ZipInputStream oldBackupIn, ZipOutputStream newBackupOut, File dataDir) throws IOException {
    File currentLog = new File (dataDir, LOG_FILE_NAME);
    if (oldBackupIn == null && ! currentLog.exists ()) return;
    ZipEntry e = new ZipEntry (HIST_LOG_FILE_NAME);
    e.setTime (System.currentTimeMillis ());
    newBackupOut.putNextEntry (e);
    byte [] histLog = null;
    if (oldBackupIn != null) {
        histLog = FileUtils.slurpContents (oldBackupIn, false);
        long totalSize = histLog.length + currentLog.length ();
        int skip = (int) Math.max (0, totalSize - maxHistLogSize);
        if (skip < histLog.length) newBackupOut.write (histLog, skip, histLog.length - skip);
        else histLog = null;
    }
    if (currentLog.exists () && currentLog.length () > 0) {
        InputStream currentLogIn = new BufferedInputStream (new FileInputStream (currentLog));
        try {
            byte [] currLogStart = new byte [100];
            int matchLen = currentLogIn.read (currLogStart);
            int lastLogEntryPos = findLastLogEntryStart (histLog);
            if (matches (histLog, lastLogEntryPos, currLogStart, 0, matchLen)) {
                int duplicateLen = histLog.length - lastLogEntryPos;
                int skip = duplicateLen - matchLen;
                if (skip > 0) currentLogIn.skip (skip);
            }
            else {
                newBackupOut.write (HIST_SEPARATOR.getBytes ());
                newBackupOut.write (currLogStart, 0, matchLen);
            }
            FileUtils.copyFile (currentLogIn, newBackupOut);
        } finally {
            currentLogIn.close ();
        }
    }
    newBackupOut.closeEntry ();
}


-----Function Pair=163=-----==

public static long unzipToDir (InputStream inzip, String basedirdest) throws IOException, SecurityException {
    long sum = 0;
    File base = new File (basedirdest);
    if (! base.exists ()) base.mkdirs ();
    try {
        CheckedInputStream checksum = new CheckedInputStream (inzip, new Adler32 ());
        try {
            BufferedInputStream bis = new BufferedInputStream (checksum);
            try {
                ZipInputStream zis = new ZipInputStream (bis);
                try {
                    ZipEntry entry;
                    File f;
                    int count;
                    byte [] buf = new byte [BUFFER_SIZE];
                    BufferedOutputStream bos;
                    FileOutputStream fos;
                    while ((entry = zis.getNextEntry ()) != null) {
                        f = new File (basedirdest, entry.getName ());
                        if (entry.isDirectory ()) f.mkdirs ();
                        else {
                            int l = entry.getName ().lastIndexOf ('/');
                            if (l != - 1) {
                                new File (basedirdest, entry.getName ().substring (0, l)).mkdirs ();
                            }
                            fos = new FileOutputStream (f);
                            try {
                                bos = new BufferedOutputStream (fos, BUFFER_SIZE);
                                try {
                                    while ((count = zis.read (buf, 0, BUFFER_SIZE)) != - 1) {
                                        bos.write (buf, 0, count);
                                    }
                                } finally {
                                    bos.close ();
                                }
                            } finally {
                                fos.close ();
                            }
                        }
                        if (entry.getTime () != - 1) {
                            f.setLastModified (entry.getTime ());
                        }
                    }
                } finally {
                    zis.close ();
                }
            } finally {
                bis.close ();
            }
        } finally {
            checksum.close ();
        }
        sum = checksum.getChecksum ().getValue ();
    } finally {
        inzip.close ();
    }
    return sum;
}


private static boolean maybeBackupFile (File f, ZipOutputStream zip, Map origFileTimes, Map origFileSizes, Map fileTimes, Map fileSizes) {
    String name = f.getName ();
    Long fileTime = new Long (f.lastModified ());
    Long fileSize = new Long (f.length ());
    fileTimes.put (name, fileTime);
    fileSizes.put (name, fileSize);
    Long prevTime = (Long) origFileTimes.get (name);
    Long prevSize = (Long) origFileSizes.get (name);
    if (prevTime != null && prevTime.equals (fileTime) && prevSize != null && prevSize.equals (fileSize)) return false;
    try {
        ZipEntry e = new ZipEntry (name);
        e.setTime (fileTime.longValue ());
        zip.putNextEntry (e);
        byte [] buffer = new byte [4096];
        FileInputStream in = new FileInputStream (f);
        int bytesRead;
        while ((bytesRead = in.read (buffer)) != - 1) zip.write (buffer, 0, bytesRead);
        in.close ();
    } catch (IOException ioe) {
        printError ("Error while backing up " + name, ioe);
    }
    return true;
}


-----Function Pair=164=-----==

public static void mergeZipAndDirToJar (String originZipFile, String originDir, ZipOutputStream zos) {
    try {
        FileInputStream fis = new FileInputStream (originZipFile);
        CheckedInputStream checksum = new CheckedInputStream (fis, new Adler32 ());
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (checksum));
        ZipEntry entry = null;
        while ((entry = zis.getNextEntry ()) != null) {
            JarEntry newEntry = new JarEntry (entry.getName ());
            zos.putNextEntry (newEntry);
            byte [] readBuffer = new byte [1024];
            int bytesIn = 0;
            while ((bytesIn = zis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            zos.closeEntry ();
        }
        zis.close ();
        File.zipDir (originDir, "", zos);
    } catch (Exception e) {
    }
}


protected ProcessContentResult generateAndSubmitFile (NodeTransaction aTran, String templateName, String outfileBaseName, WqxOperationType operationType) {
    debug ("Validating transaction...");
    validateTransaction (aTran);
    NodeTransaction transaction = aTran;
    ProcessContentResult result = new ProcessContentResult ();
    result.setSuccess (false);
    result.setStatus (CommonTransactionStatusCode.Failed);
    try {
        setOptionsFromTransactionParams (transaction);
        if (useSubmissionHistory) {
            checkForPendingSubmissions (operationType, orgId);
            result.getAuditEntries ().add (makeEntry ("No pending submissions"));
        }
        else {
            result.getAuditEntries ().add (makeEntry ("Ignoring submission history."));
        }
        result.getAuditEntries ().add (makeEntry ("Generating xml file..."));
        String docId = getIdGenerator ().createId ();
        generateXmlDoc (orgId, operationType, outfileBaseName, templateName, docId);
        result.getAuditEntries ().add (makeEntry ("Xml file generated with template " + templateName));
        Document doc = makeDocument (transaction, docId);
        result.getAuditEntries ().add (makeEntry ("Created document " + doc.getDocumentName () + " in " + getTempFilePath ()));
        result.getAuditEntries ().add (makeEntry ("Setting result..."));
        result.setPaginatedContentIndicator (new PaginationIndicator (transaction.getRequest ().getPaging ().getStart (), transaction.getRequest ().getPaging ().getCount (), true));
        result.getDocuments ().add (doc);
        transaction.getDocuments ().add (doc);
        debug ("pre-submit transaction.getId(): " + transaction.getId ());
        debug ("pre-submit transaction.getNetworkId(): " + transaction.getNetworkId ());
        PartnerIdentity partner = makePartner ();
        if (partner != null) {
            NodeClientService client = makeNodeClient (partner);
            transaction.updateWithPartnerDetails (partner);
            result.getAuditEntries ().add (makeEntry ("submitting to partner URL " + partner.getUrl ()));
            transaction = client.submit (transaction);
            debug ("submission returned with network transaction id " + transaction.getNetworkId ());
        }
        else {
            result.getAuditEntries ().add (makeEntry ("No partner configured, no submission will be made."));
        }
        getTransactionDao ().save (transaction);
        result.getAuditEntries ().add (makeEntry ("resultTran.getId(): " + transaction.getId ()));
        if (partner != null) {
            result.getAuditEntries ().add (makeEntry ("resultTran.getNetworkId(): " + transaction.getNetworkId ()));
        }
        if (useSubmissionHistory) {
            saveSubmissionHistory (transaction, operationType);
            result.getAuditEntries ().add (makeEntry ("Recorded document submission."));
        }
        result.setSuccess (true);
        result.setStatus (CommonTransactionStatusCode.Pending);
        result.getAuditEntries ().add (makeEntry ("Done: OK"));
    } catch (Exception ex) {
        error (ex);
        ex.printStackTrace ();
        result.setSuccess (false);
        result.setStatus (CommonTransactionStatusCode.Failed);
        result.getAuditEntries ().add (makeEntry ("Error while executing: " + this.getClass ().getName () + " Message: " + ex.getMessage ()));
    }
    debug ("Returning result: " + result);
    return result;
}


-----Function Pair=165=-----==

public static RegionScoreTextData merge (ArrayList < RegionScoreTextData > pdAL) {
    RegionScoreTextData [] pdArray = new RegionScoreTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionScoreTexts.length;
    RegionScoreText [] concatinate = new RegionScoreText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionScoreText [] slice = pdArray [i].sortedRegionScoreTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionScoreTextData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionScoreTextData (concatinate, sliceInfo);
}


private static void unzip (InputStream in, String destDirectory) throws IOException {
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (in));
    ZipEntry entry;
    BufferedOutputStream dest = null;
    while ((entry = zis.getNextEntry ()) != null) {
        System.out.println ("Extracting: " + entry);
        int count;
        byte data [] = new byte [BUFFER];
        if (entry.getName ().endsWith ("/")) {
            File file = new File (destDirectory + entry.getName ());
            file.mkdir ();
        }
        else {
            FileOutputStream fos;
            try {
                fos = new FileOutputStream (destDirectory + entry.getName ());
            } catch (FileNotFoundException e) {
                File parent = new File (destDirectory + entry.getName ()).getParentFile ();
                if (! parent.exists ()) {
                    parent.mkdirs ();
                }
                fos = new FileOutputStream (destDirectory + entry.getName ());
            }
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
        }
    }
    System.out.println ("Extraction complete.");
}


-----Function Pair=166=-----==

public void doZip () {
    String filename = "";
    try {
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream (outputfilename);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        Set < String > keys = files.keySet ();
        for (String key : keys) {
            filename = key;
            String fpath = files.get (key);
            FileInputStream fi = new FileInputStream (fpath);
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (key);
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
        zipComplete = true;
    } catch (FileNotFoundException e) {
        Activator.getDefault ().showMessage (bundle.getString ("Missing_File") + ": " + filename);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


void compile () throws Exception {
    System.out.println (title);
    InputStream isj = cl.getResourceAsStream ("_nanoInstaller_/resource/ni.jar");
    if (isj == null) {
        throw new Exception ("Resource ni.jar not found.\n" + "Compiler archive has not been properly compiled.");
    }
    BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (installerName));
    ZipInputStream zis = new ZipInputStream (isj);
    ZipOutputStream zos = new ZipOutputStream (bos);
    zos.setLevel (9);
    copyZipToZip (zis, zos);
    copyFileToZip ("_nanoInstaller_/properties", prop_file, zos);
    if (lang == null) {
        lang = "eng";
    }
    String filename = lang + ".lang.properties";
    File file = new File (filename);
    if (file.exists ()) {
        copyFileToZip ("_nanoInstaller_/lang.properties", lang, zos);
    }
    else {
        String res_name = "_nanoInstaller_/resource/" + filename;
        InputStream is = cl.getResourceAsStream (res_name);
        if (is == null) {
            throw new Exception ("You have chosen to use the '" + lang + "' language for messages, but\n" + "supporting resource " + res_name + "  was not found.\n");
        }
        copyResourceToZip ("_nanoInstaller_/lang.properties", is, zos);
    }
    copyDirectoryToZip (basedir, zos);
    zos.close ();
}


-----Function Pair=167=-----==

public static boolean unzipFile (String name, InputStream data, String basepath, boolean createDirectory) {
    try {
        String outputpath = basepath;
        if (createDirectory) {
            String zipfilename = name.substring (0, name.lastIndexOf ("."));
            outputpath += zipfilename + "/";
            File outputDir = new File (outputpath);
            outputDir.mkdirs ();
        }
        ZipInputStream zis = new ZipInputStream (data);
        ZipEntry ze = null;
        String shpfile = "";
        String type = "";
        while ((ze = zis.getNextEntry ()) != null) {
            System.out.println ("ze.file: " + ze.getName ());
            String fname = outputpath + ze.getName ();
            copyInputStream (zis, new BufferedOutputStream (new FileOutputStream (fname)));
            zis.closeEntry ();
        }
        zis.close ();
    } catch (Exception e) {
        System.out.println ("unable to load user kml: ");
        e.printStackTrace (System.out);
        return false;
    }
    return true;
}


private static Object createProposal (ClassLoader classLoader, Vector obs) throws Exception {
    Class propClass = Class.forName ("herschel.phs.gui.data.proposal.PhsProposal", true, classLoader);
    Object proposal = propClass.newInstance ();
    invoke (proposal, "setTitle", new Object [] {"proposal name"}, new Class [] {String.class});
    invoke (proposal, "setAbstractText", new Object [] {"Proposal abstract text"}, new Class [] {String.class});
    invoke (proposal, "setCategory", new Object [] {"SDP"}, new Class [] {String.class});
    Class [] phsScienceCategoryArgsClass = new Class [] {String.class, String.class, String.class};
    Object [] phsScienceCategoryArgs = new Object [] {"Nearby galaxies", null, null};
    Class phsScienceCategoryClass = Class.forName ("herschel.phs.gui.data.proposal.PhsScienceCategory", true, classLoader);
    Constructor createPhsScienceCategory = phsScienceCategoryClass.getConstructor (phsScienceCategoryArgsClass);
    Object phsScienceCategory = createPhsScienceCategory.newInstance (phsScienceCategoryArgs);
    invoke (proposal, "setScienceCategory", new Object [] {phsScienceCategory}, new Class [] {phsScienceCategoryClass});
    invoke (proposal, "setObservationRequests", new Object [] {obs}, new Class [] {obs.getClass ()});
    Class [] phsProgramDetailsArgsClass = new Class [] {String.class, String.class, int.class, int.class, boolean.class, boolean.class};
    Object [] phsProgramDetailsArgs = new Object [] {"SDP", "SDP", 0, 1, false, true};
    Class phsProgramDetailsClass = Class.forName ("herschel.phs.gui.data.proposal.PhsProgrammeDetails", true, classLoader);
    Constructor createPhsProgramDetails = phsProgramDetailsClass.getConstructor (phsProgramDetailsArgsClass);
    Object phsProgramDetails = createPhsProgramDetails.newInstance (phsProgramDetailsArgs);
    invoke (proposal, "setProgramDetails", new Object [] {phsProgramDetails}, new Class [] {phsProgramDetailsClass});
    return proposal;
}


-----Function Pair=168=-----==

public void compress (String fileName, String dir) {
    Files files = new Files ();
    String [] filenames = files.directoryList (dir);
    byte [] buf = new byte [1024];
    try {
        String outFilename = fileName;
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < filenames.length; i ++) {
            FileInputStream in = new FileInputStream (filenames [i]);
            String file = filenames [i].substring (dir.length () + 1);
            out.putNextEntry (new ZipEntry (file));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
    }
}


public static String transform (String src, String dest, String targetDirectory, boolean outit, String charSet, PageContext pageContext) throws JspException {
    try {
        ServletContext context = pageContext.getServletContext ();
        if (outit) {
            String outputFile = targetDirectory + dest;
            mkPath (getPath (outputFile));
            RequestDispatcher requestDispatcher = context.getRequestDispatcher (src);
            FileResponseWrapper responseWapper = new FileResponseWrapper ((HttpServletResponse) pageContext.getResponse (), outputFile, charSet);
            requestDispatcher.include (pageContext.getRequest (), responseWapper);
            responseWapper.flush ();
            responseWapper.close ();
            return dest;
        }
        else {
            RequestDispatcher requestDispatcher = context.getRequestDispatcher (src);
            StringResponseWrapper responseWapper = new StringResponseWrapper ((HttpServletResponse) pageContext.getResponse (), charSet);
            requestDispatcher.include (pageContext.getRequest (), responseWapper);
            responseWapper.flush ();
            responseWapper.close ();
            return responseWapper.toString ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
        throw new JspException ("Functions.transform() - " + e.getMessage (), e);
    } catch (ServletException e) {
        throw new JspException ("Functions.transform() - " + e.getMessage (), e);
    }
}


-----Function Pair=169=-----==

public boolean restoreFromArchive (File archive) {
    deleteFromDisk ();
    String dir = engine_.getProperty ("5pHome") + "data" + File.separator + name_;
    new File (dir).mkdir ();
    Enumeration entries;
    ZipFile zipFile;
    try {
        zipFile = new ZipFile (archive);
        entries = zipFile.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            String eName = entry.getName ();
            if (eName.startsWith ("mysql") || eName.startsWith ("derby")) {
                continue;
            }
            if (entry.isDirectory ()) {
                System.err.println ("Extracting directory: " + entry.getName ());
                (new File (dir + File.separator + eName)).mkdir ();
                continue;
            }
            eName = FPUtil.fixFilename (eName);
            (new File (dir + File.separator + eName).getParentFile ()).mkdirs ();
            FPUtil.copyInputStream (zipFile.getInputStream (entry), new BufferedOutputStream (new FileOutputStream (dir + File.separator + eName)));
        }
        zipFile.close ();
    } catch (IOException ex) {
        ex.printStackTrace ();
        return false;
    }
    this.readXMLFile (false);
    try {
        legDB_ = null;
        zipFile = new ZipFile (archive);
        switch (LegacyDB.getRDBMSCode (props_.getProperty ("rdbms"))) {
            case LegacyDB.DB_DERBY :
                legDB_ = new LegacyDerbyDB (engine_, this, zipFile);
                break;
            case LegacyDB.DB_MYSQL :
                legDB_ = new LegacyMysqlDB (engine_, this, engine_.getProperty ("dbUsername"), engine_.getProperty ("dbPassword"), zipFile);
                break;
        }
        if (legDB_ != null) {
            return true;
        }
        else {
            System.out.println ("Invalid rdbms: " + props_.getProperty ("rdbms"));
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return false;
}


private byte [] addUpdateItem (HTTPurl urlData) throws Exception {
    String id = urlData.getParameter ("id");
    ScheduleItem item = null;
    String statusPage = urlData.getParameter ("status");
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
    }
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    String mes = addSchedule (urlData, item);
    if (statusPage != null && statusPage.equals ("1")) {
        StringBuffer buff = new StringBuffer ();
        buff.append ("HTTP/1.0 200\n");
        buff.append ("Content-Type: text/xml\n\n");
        buff.append ("<schedule_add>\n");
        if (mes == null) {
            buff.append ("<status>ADDED</status>\n");
            buff.append ("<message></message>\n");
        }
        else {
            buff.append ("<status>FAILED</status>\n");
            buff.append ("<message>" + mes + "</message>\n");
        }
        buff.append ("</schedule_add>\n");
        return buff.toString ().getBytes ();
    }
    if (mes != null) throw new Exception (mes);
    StringBuffer out = new StringBuffer (4096);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=170=-----==

private byte [] stopRunningTask (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (4096);
    String id = urlData.getParameter ("id");
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    ScheduleItem si = null;
    ThreadLock.getInstance ().getLock ();
    try {
        si = store.getScheduleItem (id);
        if (si != null && si.getState () == ScheduleItem.RUNNING) {
            si.abort ();
            si.setStatus ("Aborting");
            si.setState (ScheduleItem.ABORTED);
            si.log ("Item marked for abortion");
        }
    } finally {
        ThreadLock.getInstance ().releaseLock ();
    }
    int counts = 10;
    while (si.getState () == ScheduleItem.ABORTED && counts > 0) {
        counts --;
        Thread.sleep (1000);
    }
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


public Map getSecurityDefinitionSelectionMap () {
    Map securityMap = new LinkedHashMap ();
    List availableRoles = Application.getInstance ().getAllRoles ();
    for (Iterator iter = getSecurityDefinitionList ().iterator (); iter.hasNext ();) {
        SecurityDefinition def = (SecurityDefinition) iter.next ();
        String allowedRoles = def.getAllowedRoles ();
        if (allowedRoles == null) allowedRoles = "";
        Map roleMap = new LinkedHashMap ();
        for (Iterator roleiter = availableRoles.iterator (); roleiter.hasNext ();) {
            String role = (String) roleiter.next ();
            if (allowedRoles.indexOf (role) != - 1 || "APP_ADMINISTRATOR".equals (role)) {
                roleMap.put (role, Boolean.TRUE);
            }
            else {
                roleMap.put (role, Boolean.FALSE);
            }
        }
        securityMap.put (def, roleMap);
    }
    return securityMap;
}


-----Function Pair=171=-----==

private void addFile (File aFile) throws IOException {
    if (aFile.isDirectory ()) {
        throw new IOException (aFile.getName () + " is a directory.");
    }
    String zipName = getZipName (aFile);
    ZipEntry ze = new ZipEntry (zipName);
    ze.setTime (aFile.lastModified ());
    if (aFile.length () < 51) {
        mZos.setMethod (ZipOutputStream.STORED);
        ze.setSize (aFile.length ());
        ze.setCompressedSize (aFile.length ());
        ze.setCrc (calcCRC32 (aFile));
    }
    else {
        mZos.setMethod (ZipOutputStream.DEFLATED);
    }
    mZos.putNextEntry (ze);
    byte [] buf = new byte [2048];
    int read;
    InputStream is = new FileInputStream (aFile);
    while ((read = is.read (buf, 0, buf.length)) > - 1) {
        mZos.write (buf, 0, read);
    }
    is.close ();
}


public boolean doLogin (String [] msg) {
    if (isAnonymous ()) {
        return true;
    }
    try {
        getInfo ();
        List entries = new ArrayList ();
        entries.add (HttpFormEntry.hidden (ARG_RESPONSE, RESPONSE_XML));
        entries.add (HttpFormEntry.hidden (ARG_USER_PASSWORD, getPassword ()));
        entries.add (HttpFormEntry.hidden (ARG_USER_ID, getUser ()));
        String [] result = doPost (URL_USER_LOGIN, entries);
        if (result [0] != null) {
            msg [0] = "Error logging in: " + result [0];
            return false;
        }
        String contents = result [1];
        Element root = XmlUtil.getRoot (contents);
        String body = XmlUtil.getChildText (root).trim ();
        if (responseOk (root)) {
            sessionId = body;
            return true;
        }
        else {
            msg [0] = body;
            return false;
        }
    } catch (java.io.IOException exc) {
        exc.printStackTrace ();
        msg [0] = "Could not connect to server: " + getHostname ();
    } catch (Exception exc) {
        msg [0] = "An error occurred: " + exc + "\n";
    }
    return false;
}


-----Function Pair=172=-----==

protected static List < File > getFiles (File dir, FilenameFilter filter, Date date) {
    List < File > newerFiles = new ArrayList < File > ();
    if (! dir.isDirectory ()) {
        throw new RuntimeException (dir + " is not a directory.  Bad, program!  BAD!!");
    }
    File [] children = dir.listFiles (filter);
    for (int i = 0; i < children.length; i ++) {
        if (children [i].isDirectory ()) {
            newerFiles.addAll (getFiles (children [i], filter, date));
        }
        else if (date.before (new Date (children [i].lastModified ())) && ! children [i].getName ().endsWith (".lck")) {
            newerFiles.add (children [i]);
        }
    }
    return newerFiles;
}


private static String matchPathLists (List r, List f) {
    int i;
    int j;
    String s;
    s = "";
    i = r.size () - 1;
    j = f.size () - 1;
    while ((i >= 0) && (j >= 0) && (r.get (i).equals (f.get (j)))) {
        i --;
        j --;
    }
    for (; i >= 0; i --) {
        s += ".." + File.separator;
    }
    for (; j >= 1; j --) {
        s += f.get (j) + File.separator;
    }
    s += f.get (j);
    return s;
}


-----Function Pair=173=-----==

public static long getFolderSize (boObject object, String bridge) throws boRuntimeException {
    long size = 0;
    iFile file = null;
    bridgeHandler bHandler = object.getBridge (bridge);
    bHandler.beforeFirst ();
    while (bHandler.next ()) {
        boObject objHandler = bHandler.getObject ();
        if (objHandler.exists ()) {
            if (isDocument (objHandler.getBoDefinition ().getName ())) {
                file = objHandler.getAttribute ("file").getValueiFile ();
                size += file.length ();
            }
            else {
                size += getFolderSize (objHandler, "details");
            }
        }
    }
    return size;
}


public static boolean unzip (InputStream inputStream, String targetDir) {
    ZipInputStream zipInputStream = new ZipInputStream (inputStream);
    ZipEntry zipEntry;
    FileOutputStream fileOutputStream = null;
    try {
        while ((zipEntry = zipInputStream.getNextEntry ()) != null) {
            if (! zipEntry.isDirectory ()) {
                targetDir = targetDir.endsWith ("/") || targetDir.endsWith ("\\") ? targetDir : targetDir + "/";
                File zippedFile = new File (targetDir + zipEntry.getName ());
                FileUtilsExt.deleteQuietly (zippedFile);
                fileOutputStream = new FileOutputStream (zippedFile);
                int b;
                while ((b = zipInputStream.read ()) != - 1) {
                    fileOutputStream.write (b);
                }
                fileOutputStream.close ();
            }
        }
    } catch (IOException e) {
        LOGGER.error ("Can't unzip to " + targetDir, e);
        return false;
    } finally {
        try {
            zipInputStream.closeEntry ();
            if (fileOutputStream != null) {
                fileOutputStream.close ();
            }
        } catch (IOException e) {
            LOGGER.error ("Error while closing stream.", e);
        }
    }
    return true;
}


-----Function Pair=174=-----==

private void zipProjectDir (File saveFile, File saveDir) {
    ZipOutputStream zos = null;
    BufferedInputStream bis = null;
    try {
        zos = new ZipOutputStream (new FileOutputStream (saveFile));
        List < File > allFile = new ArrayList < File > ();
        getAllProjectFile (saveDir, allFile);
        for (File file : allFile) {
            ZipEntry entry = new ZipEntry (file.getPath ());
            zos.putNextEntry (entry);
            bis = new BufferedInputStream (new FileInputStream (file));
            int count;
            byte buf [] = new byte [1024];
            while ((count = bis.read (buf, 0, 104)) != EOF) {
                zos.write (buf, 0, count);
            }
            bis.close ();
            zos.closeEntry ();
            file.delete ();
        }
        for (File dir : saveDir.listFiles ()) {
            dir.delete ();
        }
        saveDir.delete ();
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    } finally {
        try {
            if (bis != null) {
                bis.close ();
            }
            if (zos != null) {
                zos.close ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


private Vector getLines (String fileName) throws IOException {
    Vector res = new Vector ();
    if (fileName.endsWith (RES_EXTENSION)) {
        DataInputStream in = new DataInputStream (new FileInputStream (fileName));
        String line = null;
        while ((line = in.readLine ()) != null) {
            for (;;) {
                line = line.trim ();
                if (line.endsWith ("\\")) {
                    String line2 = in.readLine ();
                    if (line2 != null) line = line.substring (0, line.length () - 1) + line2;
                    else break;
                }
                else break;
            }
            res.addElement (fromEscape (line));
        }
    }
    else {
        RandomAccessFile in = new RandomAccessFile (fileName, "r");
        StringBuffer sb = new StringBuffer ();
        int factor1 = 1;
        int factor2 = 256;
        for (;;) {
            int i = in.readUnsignedByte () * factor1 + in.readUnsignedByte () * factor2;
            if (i == 0xFFFE) {
                factor1 = 256;
                factor2 = 1;
            }
            if (i != 0x0D && i != 0xFFFE && i != 0xFEFF && i != 0xFFFF) if (i != 0x0A) sb.append ((char) i);
            else {
                res.addElement (fromEscape (sb.toString ()));
                sb.setLength (0);
            }
        }
    }
    return res;
}


-----Function Pair=175=-----==

public void zipBackupData (String path) {
    File folder = new File (path);
    File [] files = folder.listFiles ();
    ZipEntry entry;
    try {
        for (int i = 0; i < files.length; i ++) {
            if (files [i].isDirectory ()) {
                entry = new ZipEntry (files [i].getPath () + "/");
                zipFile.putNextEntry (entry);
                zipBackupData (files [i].getPath ());
                continue;
            }
            FileInputStream in = new FileInputStream (files [i]);
            entry = new ZipEntry (path + "/" + files [i].getName ());
            zipFile.putNextEntry (entry);
            int c;
            while ((c = in.read ()) != - 1) zipFile.write (c);
            zipFile.closeEntry ();
            in.close ();
        }
    } catch (Exception ex) {
        CampaignData.mwlog.errLog ("Unable to backup server data files: " + path);
        CampaignData.mwlog.errLog (ex);
    }
}


public boolean writeStringToFile (String fileName, String data) {
    if (data == null) return (false);
    File f;
    FileWriter out = null;
    char dataBuf [];
    int size = data.length ();
    try {
        f = new File (fileName);
        out = new FileWriter (f);
        if (! f.canWrite ()) return (false);
        dataBuf = new char [size];
        for (int i = 0; i < size; i ++) dataBuf [i] = data.charAt (i);
        out.write (dataBuf, 0, size);
        out.close ();
        return (true);
    } catch (SecurityException e) {
        errMsgLog += "FT-WSTF SecurityException [" + fileName + "] " + e;
        lastErrMsgLog = errMsgLog;
    } catch (FileNotFoundException e) {
        errMsgLog += "FT-WSTF FileNotFoundException [" + fileName + "] " + e;
        lastErrMsgLog = errMsgLog;
    } catch (IOException e) {
        errMsgLog += "FT-WSTF IOException [" + fileName + "] " + e;
        lastErrMsgLog = errMsgLog;
    }
    return (false);
}


-----Function Pair=176=-----==

private void SaveSiteInfo (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        String sql = "insert into site(id,name,domain,unit,suffix,rooturl,artpubdir,img_rooturl,img_publish_dir,fulltext,solr_core) values(?,?,?,?,?,?,?,?,?,?,?)";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.setString (2, name);
        pstmt.setString (3, domain);
        if (unit == null) {
            pstmt.setNull (4, java.sql.Types.VARCHAR);
        }
        else {
            pstmt.setString (4, unit.GetId ());
        }
        pstmt.setString (5, GetSuffix ());
        pstmt.setString (6, GetRootURL ());
        pstmt.setString (7, GetArticleDir ().getAbsolutePath ());
        pstmt.setString (8, GetImgURL ());
        pstmt.setString (9, GetImgDir ().getAbsolutePath ());
        pstmt.setInt (10, fulltext_index ? 1 : 0);
        pstmt.setString (11, solr_core);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


public void notifyChanged (Notification msg) {
    super.notifyChanged (msg);
    if (msg.getEventType () == Notification.ADD) {
        if (msg.getNewValue () instanceof IDiagramModelImageProvider) {
            IDiagramModelImageProvider imageProvider = (IDiagramModelImageProvider) msg.getNewValue ();
            String imagePath = imageProvider.getImagePath ();
            if (imagePath != null && ! fLoadedImagePaths.contains (imagePath)) {
                fLoadedImagePaths.add (imagePath);
            }
        }
    }
    else if (msg.getEventType () == Notification.SET) {
        if (msg.getFeature () == IArchimatePackage.Literals.DIAGRAM_MODEL_IMAGE_PROVIDER__IMAGE_PATH) {
            String imagePath = (String) msg.getNewValue ();
            if (imagePath != null && ! fLoadedImagePaths.contains (imagePath)) {
                fLoadedImagePaths.add (imagePath);
            }
        }
    }
}


-----Function Pair=177=-----==

public static long getFileOrDirectorySize (File fileOrDir, long stopOnByteSize) throws FileNotFoundException, Exception {
    long size = 0L;
    if (! fileOrDir.exists ()) {
        throw new FileNotFoundException ("cannot find file or directory " + fileOrDir.getAbsolutePath ());
    }
    if (fileOrDir.isFile ()) {
        size = fileOrDir.length ();
        if (stopOnByteSize > 0 && size > stopOnByteSize) {
            throw new Exception ("Size is greater than stopOnByteSize");
        }
    }
    else {
        for (File fileOrDirectory : fileOrDir.listFiles ()) {
            size += getFileOrDirectorySize (fileOrDirectory);
            if (stopOnByteSize > 0 && size > stopOnByteSize) {
                throw new Exception ("Size is greater than stopOnByteSize");
            }
        }
    }
    return size;
}


public static void copyDirectory (File source, File destination, String endWith) throws IOException {
    if (source.exists () && source.isDirectory ()) {
        if (! destination.exists ()) {
            destination.mkdirs ();
        }
        File [] fileArray = source.listFiles ();
        for (int i = 0; i < fileArray.length; i ++) {
            if (fileArray [i].isDirectory ()) {
                copyDirectory (fileArray [i], new File (destination.getPath () + File.separator + fileArray [i].getName ()), endWith);
            }
            else {
                if (endWith != null) {
                    if (! fileArray [i].getPath ().toLowerCase ().endsWith (endWith.toLowerCase ())) {
                        continue;
                    }
                }
                copyFile (fileArray [i], new File (destination.getPath () + File.separator + fileArray [i].getName ()));
            }
        }
    }
}


-----Function Pair=178=-----==

public boolean storeDataForTransactionIdentifier (String transactionIdentifier, InputStream inputStream, int inputLength) {
    try {
        if (true) {
            System.out.println ("This does not work because Java 1.5 does not support appending to zip files");
            return false;
        }
        ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (this.zipFilePath, true));
        ZipEntry entry = new ZipEntry (ArchiveFileSupport.fileNameForTransactionIdentifier (transactionIdentifier));
        zipOutputStream.putNextEntry (entry);
        byte [] buffer = new byte [4096];
        int length;
        while ((length = inputStream.read (buffer)) > 0) {
            zipOutputStream.write (buffer, 0, length);
        }
        zipOutputStream.closeEntry ();
        zipOutputStream.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return true;
}


public static byte [] pack (String filename) throws IOException {
    byte [] data = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    ZipOutputStream zout = new ZipOutputStream (out);
    zout.setLevel (0);
    System.out.println ("ZippingFile Zipping " + filename);
    try {
        String tmp = (new File (filename)).getName ();
        System.out.println ("Storing the following file name" + tmp);
        ZipEntry ze = new ZipEntry (tmp);
        zout.putNextEntry (ze);
        FileInputStream fin = new FileInputStream (filename);
        copy (fin, zout);
        zout.closeEntry ();
        fin.close ();
    } catch (IndexOutOfBoundsException e) {
        System.out.println ("FileNotProcessed Problems processing " + filename);
    }
    zout.close ();
    data = out.toByteArray ();
    out.close ();
    return data;
}


-----Function Pair=179=-----==

private void GetSiteArticleFtps (ZipFile file) throws Exception {
    java.util.Enumeration files = file.entries ();
    while (files.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) files.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().endsWith (".aftp")) {
                InputStream in = file.getInputStream (entry);
                java.io.InputStreamReader r = new InputStreamReader (in, "UTF-8");
                java.io.BufferedReader br = new BufferedReader (r);
                String host_name = null;
                String s = br.readLine ();
                if (s != null) host_name = s.trim ();
                String host_remotedir = null;
                s = br.readLine ();
                if (s != null) host_remotedir = s.trim ();
                String host_remoteport = null;
                s = br.readLine ();
                if (s != null) host_remoteport = s.trim ();
                int host_port = 21;
                try {
                    host_port = (int) Float.parseFloat (host_remoteport);
                } catch (Exception e1) {
                }
                String host_username = null;
                s = br.readLine ();
                if (s != null) host_username = s.trim ();
                String host_userpassword = null;
                s = br.readLine ();
                if (s != null) host_userpassword = s.trim ();
                AddFtp4Article (host_name, host_remotedir, host_port, host_username, host_userpassword);
                try {
                    br.close ();
                } catch (Exception e1) {
                }
            }
        }
    }
}


private void saveInternal (File file, Collection < EdgeMappingDescriptor > descriptors, TaskMonitor monitor) throws IOException {
    if (! file.getName ().endsWith (".ov1")) {
        file = new File (file.getAbsolutePath () + ".ov1");
    }
    File graphFile = OndexPlugin.getInstance ().getOndexGraphFile ();
    File mappingFile = new File (System.getProperty ("java.io.tmpdir") + File.separator + "ondex_mapping.tsv");
    monitor.setStatus ("saving mapping descriptors...");
    monitor.setPercentCompleted (10);
    saveMapping (mappingFile, descriptors);
    File [] inFiles = new File [] {graphFile, mappingFile};
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));
    monitor.setStatus ("compressing...");
    for (File inFile : inFiles) {
        FileInputStream in = new FileInputStream (inFile);
        out.putNextEntry (new ZipEntry (inFile.getName ()));
        int len;
        byte [] buf = new byte [1024];
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.closeEntry ();
    }
    out.close ();
    monitor.setPercentCompleted (95);
}


-----Function Pair=180=-----==

public static InputStream getZipEntryStream (File zipFile, String entryName) throws IOException {
    ZipEntry zipEntry;
    ZipInputStream zIn;
    BufferedInputStream in = new BufferedInputStream (new FileInputStream (zipFile));
    zIn = new ZipInputStream (in);
    while ((zipEntry = zIn.getNextEntry ()) != null) {
        String zipEntryName = zipEntry.getName ();
        if (zipEntryName.equalsIgnoreCase (entryName)) {
            break;
        }
        zIn.closeEntry ();
    }
    if (zipEntry == null) {
        try {
            zIn.close ();
        } catch (IOException ex) {
        }
        return null;
    }
    return zIn;
}


public static OutputStream createDownload (HttpServletResponse response, String type, String zip, String filename, boolean savetodisk) throws IOException {
    if (zip == null || zip.equals ("none")) {
        response.setContentType (type);
        if (savetodisk) {
            response.setHeader ("Content-Disposition", "attachment; filename=" + filename);
        }
        return response.getOutputStream ();
    }
    else {
        response.setHeader ("Content-Disposition", "attachment; filename=" + filename + "." + zip);
        if (zip.equals ("zip")) {
            response.setContentType ("application/zip");
            ZipOutputStream zipout = new ZipOutputStream (response.getOutputStream ());
            zipout.putNextEntry (new ZipEntry (filename));
            return zipout;
        }
        else if (zip.equals ("gzip")) {
            return new GZIPOutputStream (response.getOutputStream ());
        }
        else {
            throw new IllegalArgumentException ("Invalid zip method");
        }
    }
}


-----Function Pair=181=-----==

public void compress (String filename) {
    try {
        File fin = new File (filename);
        FileInputStream uncompressed = new FileInputStream (fin);
        File fout = new File (filename + ".zip");
        ZipOutputStream compressed = new ZipOutputStream (new FileOutputStream (fout));
        String shortname;
        int lastslash = filename.lastIndexOf (FSEP);
        if (lastslash != - 1) {
            shortname = filename.substring (lastslash + 1);
        }
        else {
            shortname = filename;
        }
        compressed.putNextEntry (new ZipEntry (shortname));
        byte [] buf = new byte [4096];
        int len;
        while ((len = uncompressed.read (buf)) > 0) {
            compressed.write (buf, 0, len);
        }
        compressed.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private void CreateDsTable (NpsContext ctxt, Topic t) throws NpsException {
    if (t == null) return;
    String tablename = t.GetTable ();
    if (tablename == null || tablename.length () == 0) return;
    String dstable_name = tablename + "_prop";
    dstable_name = dstable_name.toUpperCase ();
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        String sql = "select count(*) table_count from all_tables Where table_name=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, dstable_name);
        rs = pstmt.executeQuery ();
        rs.next ();
        if (rs.getInt ("table_count") > 0) {
            try {
                rs.close ();
            } catch (Exception e) {
            }
            try {
                pstmt.close ();
            } catch (Exception e) {
            }
            sql = "select id,title,siteid,topic,state,createdate,publishdate from " + dstable_name + " where rownum<2";
            try {
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                rs = pstmt.executeQuery ();
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                stmt = ctxt.GetConnection ().createStatement ();
                sql = "Alter Table " + dstable_name + " Modify siteid default('" + t.GetSiteId () + "')";
                stmt.executeUpdate (sql);
                sql = "Alter Table " + dstable_name + " Modify topic default('" + t.GetId () + "')";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,default:" + treename + "'";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,default:" + t.GetName () + "'";
                stmt.executeUpdate (sql);
                try {
                    stmt.close ();
                } catch (Exception e1) {
                }
                return;
            } catch (Exception e) {
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                sql = "drop table " + dstable_name;
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                pstmt.executeUpdate (sql);
            }
        }
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        stmt = ctxt.GetConnection ().createStatement ();
        sql = "CREATE TABLE " + dstable_name + " (ID VARCHAR2(50) NOT NULL," + "TITLE VARCHAR2(1000) NOT NULL," + "SITEID VARCHAR2(10) DEFAULT '" + t.GetSiteId () + "' NOT NULL," + "TOPIC VARCHAR2(10) DEFAULT '" + t.GetId () + "' NOT NULL," + "STATE NUMBER," + "CREATEDATE DATE DEFAULT SYSDATE NOT NULL," + "PUBLISHDATE DATE," + "CONSTRAINT PK_" + dstable_name + " PRIMARY KEY (ID,TOPIC)" + ")";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".ID IS 'id'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TITLE IS 'title'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,site name is:" + treename + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,topic name is:" + t.GetName () + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".STATE IS 'status'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".CREATEDATE IS 'create date'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".PUBLISHDATE IS 'publish date'";
        stmt.executeUpdate (sql);
        sql = "create index idx_" + dstable_name + "_topstate on " + dstable_name + "(siteid,topic,state)";
        stmt.executeUpdate (sql);
        try {
            stmt.close ();
        } catch (Exception e) {
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        if (stmt != null) try {
            stmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=182=-----==

public void mouseClicked (MouseEvent me) {
    if (me.getClickCount () != 2) return;
    TreePath path = metadataTreeDisplay.getSelectionPath ();
    if (path == null) return;
    if (path.getLastPathComponent () instanceof SelectableEntryNode) {
        SelectableEntryNode node = (SelectableEntryNode) path.getLastPathComponent ();
        int index = getIndexByToolTip (node.getEntry ().getDescriptiveName ());
        if (index == - 1) {
            SelectableEntryPanel listPanel = new SelectableEntryPanel (node.getEntry ());
            metadataView.addTab (node.getEntry ().getShortName (), null, listPanel, node.getEntry ().getDescriptiveName ());
            metadataView.setSelectedComponent (listPanel);
        }
        else {
            metadataView.setSelectedIndex (index);
        }
    }
    else if (path.getLastPathComponent () instanceof MetadataNode) {
        MetadataNode node = (MetadataNode) path.getLastPathComponent ();
        int index = getIndexByToolTip (node.getMetadata ().getDescriptiveName ());
        if (index == - 1) {
            MetadataPanelWrapper panel = new MetadataPanelWrapper (node.getMetadata (), creator);
            metadataView.addTab (node.getMetadata ().getShortName (), null, panel, node.getMetadata ().getDescriptiveName ());
            metadataView.setSelectedComponent (panel);
        }
        else {
            metadataView.setSelectedIndex (index);
        }
    }
}


public MapObject loadMap (String path) {
    try {
        InputStream inStream = getClass ().getResourceAsStream (path);
        StringBuffer contents = new StringBuffer ();
        String line = null;
        BufferedReader reader = new BufferedReader (new InputStreamReader (inStream));
        while ((line = reader.readLine ()) != null) {
            contents.append (line);
            contents.append (MapMaker.NL);
        }
        MapObject map = new com.fj.torkel.author.MapMaker ().create (contents.toString (), false);
        return map;
    } catch (Throwable x) {
        x.printStackTrace ();
        return null;
    }
}


-----Function Pair=183=-----==

public static void unzipToDir (String zipFile, String unzipDir) throws Exception {
    ZipFile zip = new ZipFile (zipFile);
    String zipName = zipFile.substring (zipFile.lastIndexOf ("/"), zipFile.lastIndexOf ("."));
    new File (unzipDir + zipName).mkdirs ();
    for (Enumeration en = zip.entries (); en.hasMoreElements ();) {
        ZipEntry entry = (ZipEntry) en.nextElement ();
        String name = entry.getName ();
        System.out.println ("entry name: " + name);
        String newname = unzipDir + zipName + name;
        System.out.println ("new entry name: " + newname);
        if (entry.isDirectory ()) {
            (new File (newname)).mkdirs ();
        }
        else {
            System.out.println ("parent: " + new File (newname).getParentFile ());
            new File (newname).getParentFile ().mkdirs ();
        }
    }
    for (Enumeration en = zip.entries (); en.hasMoreElements ();) {
        ZipEntry entry = (ZipEntry) en.nextElement ();
        String name = entry.getName ();
        String newname = unzipDir + zipName + name;
        if (! entry.isDirectory ()) {
            int len = 0;
            byte [] buffer = new byte [2048];
            InputStream in = zip.getInputStream (entry);
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (newname));
            while ((len = in.read (buffer)) >= 0) out.write (buffer, 0, len);
            in.close ();
            out.close ();
        }
    }
    zip.close ();
}


public static void expandJar (JarURLConnection conn, File dest) throws GorillaException {
    String dir;
    try {
        dir = conn.getJarEntry ().getName ();
    } catch (IOException e) {
        throw new GorillaException ("Error reading " + conn.getURL ().toString ());
    }
    JarFile jar = null;
    try {
        jar = conn.getJarFile ();
    } catch (Exception e) {
        throw new GorillaException ("Error reading jar file " + conn.getJarFileURL ().toString (), e);
    }
    Enumeration < JarEntry > enumeration = jar.entries ();
    while (enumeration.hasMoreElements ()) {
        JarEntry entry = enumeration.nextElement ();
        String name = entry.getName ();
        if (! name.startsWith (dir)) {
            continue;
        }
        File destFile = new File (dest, name.substring ((dir).length ()));
        if (entry.isDirectory ()) {
            destFile.mkdirs ();
            continue;
        }
        BufferedInputStream in = null;
        BufferedOutputStream out = null;
        try {
            logger.debug ("Copying " + name + " to " + destFile.getPath ());
            destFile.createNewFile ();
            in = new BufferedInputStream (jar.getInputStream (entry));
            out = new BufferedOutputStream (new FileOutputStream (destFile));
            copy (in, out);
        } catch (Exception e) {
            throw new GorillaException ("Exception copying " + name + " to " + destFile.getPath ());
        } finally {
            try {
                if (in != null) {
                    in.close ();
                }
                if (out != null) {
                    out.close ();
                }
            } catch (IOException e) {
                throw new GorillaException ("Error closing config files", e);
            }
        }
    }
}


-----Function Pair=184=-----==

private void setInternal (HTTPurl urlData, HashMap < String, String > headers, OutputStream out) throws Exception {
    String data = urlData.getParameter ("data");
    String errorString = null;
    try {
        getSchFromXML (data);
    } catch (Exception e) {
        e.printStackTrace ();
        errorString = e.toString ();
    }
    XmlDoc xmlDoc = new XmlDoc ("schedule_action");
    if (errorString != null) {
        Element error = xmlDoc.createTextElement ("error", errorString);
        xmlDoc.getRoot ().appendChild (error);
    }
    else {
        Element message = xmlDoc.createTextElement ("message", "Schedule Saved");
        xmlDoc.getRoot ().appendChild (message);
    }
    out.write (xmlDoc.getDocBytes ());
}


public void relativateFiles (String graphName, Node node, ZipOutputStream out) {
    if (node.getContent () instanceof ImageContent) {
        try {
            ImageContent content = (ImageContent) node.getContent ();
            File file = content.getFile ();
            String newFileName = graphName + ".files/" + file.getName ();
            out.putNextEntry (new ZipEntry (newFileName));
            content.setFile (new File (newFileName));
            byte [] arr = new byte [(int) file.length ()];
            (new FileInputStream (file)).read (arr, 0, (int) file.length ());
            out.write (arr, 0, (int) file.length ());
            out.closeEntry ();
        } catch (IOException exc) {
        }
    }
    for (int i = 0; i < node.getChildren ().size (); i ++) {
        relativateFiles (graphName, (Node) node.getChildren ().get (i), out);
    }
}


-----Function Pair=185=-----==

public void createInstaller (File primaryFile) throws Exception {
    String baseName = primaryFile.getName ();
    if (baseName.endsWith (".jar")) {
        baseName = baseName.substring (0, baseName.length () - 4);
        baseFile = new File (primaryFile.getParentFile (), baseName);
    }
    else {
        baseFile = primaryFile;
    }
    info.setInstallerBase (baseFile.getName ());
    packJarsSeparate = (info.getWebDirURL () != null);
    primaryJarStream = getJarOutputStream (baseFile.getName () + ".jar");
    sendStart ();
    writeInstaller ();
    primaryJarStream.closeAlways ();
    sendStop ();
}


protected void addFiles (List fileNames) throws CmsImportExportException, IOException, SAXException {
    if (fileNames != null) {
        for (int i = 0; i < fileNames.size (); i ++) {
            String fileName = (String) fileNames.get (i);
            try {
                CmsFile file = getCms ().readFile (fileName, CmsResourceFilter.IGNORE_EXPIRATION);
                if (! file.getState ().isDeleted () && ! CmsWorkplace.isTemporaryFile (file)) {
                    if (checkExportResource (fileName)) {
                        if (m_parameters.isRecursive ()) {
                            addParentFolders (fileName);
                        }
                        if (isInExportableProject (file)) {
                            exportFile (file);
                        }
                    }
                }
            } catch (CmsImportExportException e) {
                throw e;
            } catch (CmsException e) {
                if (e instanceof CmsVfsException) {
                    CmsMessageContainer message = Messages.get ().container (Messages.ERR_IMPORTEXPORT_ERROR_ADDING_FILE_1, fileName);
                    if (LOG.isDebugEnabled ()) {
                        LOG.debug (message.key (), e);
                    }
                    throw new CmsImportExportException (message, e);
                }
            }
        }
    }
}


-----Function Pair=186=-----==

private void copyZip (ZipInputStream zin, org.apache.tools.zip.ZipOutputStream out, List < String > files) throws IOException {
    java.util.zip.ZipEntry zentry;
    if (! alreadyWrittenFiles.containsKey (out)) {
        alreadyWrittenFiles.put (out, new HashSet < String > ());
    }
    HashSet < String > currentSet = alreadyWrittenFiles.get (out);
    while ((zentry = zin.getNextEntry ()) != null) {
        String currentName = zentry.getName ();
        String testName = currentName.replace ('/', '.');
        testName = testName.replace ('\\', '.');
        if (files != null) {
            Iterator < String > i = files.iterator ();
            boolean founded = false;
            while (i.hasNext ()) {
                String doInclude = i.next ();
                if (testName.matches (doInclude)) {
                    founded = true;
                    break;
                }
            }
            if (! founded) {
                continue;
            }
        }
        if (currentSet.contains (currentName)) {
            continue;
        }
        try {
            org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry (currentName);
            long fileTime = zentry.getTime ();
            if (fileTime != - 1) {
                newEntry.setTime (fileTime);
            }
            out.putNextEntry (newEntry);
            PackagerHelper.copyStream (zin, out);
            out.closeEntry ();
            zin.closeEntry ();
            currentSet.add (currentName);
        } catch (ZipException x) {
        }
    }
}


public void deleteEntries (String [] entries) {
    ZipOutputStream zout = null;
    ZipInputStream zin = null;
    File tmpzip = null;
    try {
        tmpzip = File.createTempFile ("zip", ".tmp", new File ("."));
        zin = new ZipInputStream (new FileInputStream (selfFile));
        zout = new ZipOutputStream (new FileOutputStream (tmpzip));
        ZipEntry ze;
        int len = 0;
        byte [] b = new byte [4096];
        while ((ze = zin.getNextEntry ()) != null) {
            if (getContainEntry (ze.getName (), entries) != - 1) {
                zin.closeEntry ();
                count --;
                continue;
            }
            zout.putNextEntry (new ZipEntry (ze.getName ()));
            while ((len = zin.read (b)) != - 1) {
                zout.write (b, 0, len);
            }
            zout.closeEntry ();
            zin.closeEntry ();
        }
        zout.close ();
        zin.close ();
        String slefFileName = selfFile.getPath ();
        selfFile.delete ();
        tmpzip.renameTo (new File (slefFileName));
        selfFile = new File (slefFileName);
        isChanged = true;
    } catch (IOException e) {
        logger.error (e.getLocalizedMessage ());
    }
}


-----Function Pair=187=-----==

private void copyZip (ZipInputStream zin, org.apache.tools.zip.ZipOutputStream out, List < String > files) throws IOException {
    java.util.zip.ZipEntry zentry;
    if (! alreadyWrittenFiles.containsKey (out)) {
        alreadyWrittenFiles.put (out, new HashSet < String > ());
    }
    HashSet < String > currentSet = alreadyWrittenFiles.get (out);
    while ((zentry = zin.getNextEntry ()) != null) {
        String currentName = zentry.getName ();
        String testName = currentName.replace ('/', '.');
        testName = testName.replace ('\\', '.');
        if (files != null) {
            Iterator < String > i = files.iterator ();
            boolean founded = false;
            while (i.hasNext ()) {
                String doInclude = i.next ();
                if (testName.matches (doInclude)) {
                    founded = true;
                    break;
                }
            }
            if (! founded) {
                continue;
            }
        }
        if (currentSet.contains (currentName)) {
            continue;
        }
        try {
            org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry (currentName);
            long fileTime = zentry.getTime ();
            if (fileTime != - 1) {
                newEntry.setTime (fileTime);
            }
            out.putNextEntry (newEntry);
            PackagerHelper.copyStream (zin, out);
            out.closeEntry ();
            zin.closeEntry ();
            currentSet.add (currentName);
        } catch (ZipException x) {
        }
    }
}


public static Site GetSite (String id, String name, String domain, String artdir, Unit unit, String imgdir, String encoding, String suffix, String rooturl, String imgurl) throws Exception {
    if (id == null || id.length () == 0) throw new NpsException ("no site id specified", ErrorHelper.INPUT_ERROR);
    if (name == null || name.length () == 0) throw new NpsException ("no site name specified", ErrorHelper.INPUT_ERROR);
    if (artdir == null || artdir.length () == 0) throw new NpsException ("no site article dir specified", ErrorHelper.INPUT_ERROR);
    artdir = Utils.FixPath (artdir);
    if (! artdir.endsWith ("/")) artdir += "/";
    java.io.File artPubDir = new java.io.File (artdir);
    artPubDir.mkdirs ();
    if (! artPubDir.isDirectory ()) throw new NpsException (artdir, ErrorHelper.SYS_NOTFILE);
    if (imgdir != null && imgdir.length () > 0) {
        imgdir = Utils.FixPath (imgdir);
        if (! imgdir.endsWith ("/")) imgdir += "/";
        java.io.File imgPubDir = new java.io.File (imgdir);
        imgPubDir.mkdirs ();
        if (! imgPubDir.isDirectory ()) throw new NpsException (imgdir, ErrorHelper.SYS_NOTFILE);
    }
    Site site = new Site (id, name, artPubDir, unit);
    if (domain != null && domain.length () > 0) site.SetDomain (domain);
    if (suffix != null && suffix.length () > 0) site.SetSuffix (suffix);
    if (rooturl != null && rooturl.length () > 0) site.SetRootURL (rooturl);
    if (imgurl != null && imgurl.length () > 0) site.SetImgURL (imgurl);
    if (imgdir != null && imgdir.length () > 0) site.SetImgDir (imgdir);
    site.ResolveURLs ();
    site.topic_tree = new TopicTree (site, name);
    return site;
}


-----Function Pair=188=-----==

public static synchronized AppProperties get () {
    if (prop == null) {
        XStream xs = new XStream ();
        File xmlFile = _getAppPropFile ();
        try {
            InputStream is = new FileInputStream (xmlFile);
            if (xmlFile.getName ().endsWith (".gz")) is = new GZIPInputStream (is);
            else if (xmlFile.getName ().endsWith (".zip")) {
                is = new ZipFile (xmlFile).getInputStream (new ZipEntry (zipEntryName));
            }
            GLog.log (L.tr ("Starting_reading_xml_file:_") + xmlFile.getAbsolutePath ());
            prop = (AppProperties) xs.fromXML (is);
            if (! AppProperties.getDefaultVersion ().equals (prop.get ("version"))) prop = null;
            is.close ();
            GLog.log (L.tr ("Successfully_readed:_") + xmlFile.getAbsolutePath ());
        } catch (FileNotFoundException e) {
            GLog.warn (couldnotLoad + L.tr ("File_not_found:_") + xmlFile.getAbsolutePath (), e);
        } catch (IOException e) {
            GLog.warn (couldnotLoad + L.tr ("May_be_the_gzipped_file_is_currupt_or_it_is_the_wrong_file_format."), e);
        } catch (AccessControlException e) {
            GLog.warn (couldnotLoad + L.tr ("Please_specify_this_in_your_security_policy_file!"), e);
        } catch (Exception e) {
            GLog.warn (couldnotLoad + L.tr ("May_be_it_isn't_the_correct_file_version!"), e);
        }
        if (prop == null) {
            GLog.log (L.tr ("Now_fill_application_properties_with_default_values!"));
            prop = new AppProperties ();
        }
    }
    return prop;
}


public void homologarConjunto (Component componente) {
    CarpetaTematica carpeta = (CarpetaTematica) componente.getAttribute ("carpeta");
    if (carpeta != null) {
        HashMap parametros = new HashMap ();
        parametros.put ("carpeta", carpeta);
        Window win = (Window) Executions.createComponents ("/recursos/homologar.zul", null, parametros);
        try {
            win.getFellow ("btn_homologar").setAttribute ("carpeta", carpeta);
            win.doModal ();
        } catch (InterruptedException e) {
        }
    }
    else {
        try {
            Messagebox.show (Labels.getLabel ("msg_carpeta_noseleccionado"), Labels.getLabel ("msg_titulo_carpeta_seleccionado"), Messagebox.OK, Messagebox.QUESTION);
        } catch (InterruptedException e) {
        }
    }
}


-----Function Pair=189=-----==

private static void addFileToZip (String path, String srcFile, ZipOutputStream zip) throws Exception {
    File folder = new File (srcFile);
    if (folder.isDirectory ()) {
        addFolderToZip (path, srcFile, zip);
    }
    else {
        byte [] buf = new byte [1024];
        int len;
        FileInputStream in = new FileInputStream (srcFile);
        zip.putNextEntry (new ZipEntry (path + "/" + folder.getName ()));
        while ((len = in.read (buf)) > 0) {
            zip.write (buf, 0, len);
        }
        in.close ();
    }
}


protected void getBestCandidates (String word, String code, int editdistance, Set set) {
    List wordList = (List) wordDictionary.get (code);
    if (wordList == null) {
        return;
    }
    int size = wordList.size ();
    for (int i = 0; i < size; i ++) {
        String candidate = (String) wordList.get (i);
        if (isBaseNormal (candidate)) {
            int distance = EditDistance.computeDistance (word, candidate);
            if (distance == 0) {
                set.clear ();
                set.add (candidate);
                return;
            }
            set.add (candidate);
        }
    }
}


-----Function Pair=190=-----==

private int parseSecs (String str) {
    if (str.equals ("-")) {
        return 0;
    }
    int pos = 0;
    if (str.startsWith ("-")) {
        pos = 1;
    }
    ParsePosition pp = new ParsePosition (pos);
    DateTimeParseContext cal = TIME_PARSER.parse (str, pp);
    if (pp.getErrorIndex () >= 0) {
        throw new IllegalArgumentException (str);
    }
    DateTimeField hour = (DateTimeField) cal.getParsed (HOUR_OF_DAY);
    DateTimeField min = (DateTimeField) cal.getParsed (MINUTE_OF_HOUR);
    DateTimeField sec = (DateTimeField) cal.getParsed (SECOND_OF_MINUTE);
    int secs = (int) (hour.getValue () * 60 * 60 + (min != null ? min.getValue () : 0) * 60 + (sec != null ? sec.getValue () : 0));
    if (pos == 1) {
        secs = - secs;
    }
    return secs;
}


public static boolean unzip (InputStream inputStream, String targetDir) {
    ZipInputStream zipInputStream = new ZipInputStream (inputStream);
    ZipEntry zipEntry;
    FileOutputStream fileOutputStream = null;
    try {
        while ((zipEntry = zipInputStream.getNextEntry ()) != null) {
            if (! zipEntry.isDirectory ()) {
                targetDir = targetDir.endsWith ("/") || targetDir.endsWith ("\\") ? targetDir : targetDir + "/";
                File zippedFile = new File (targetDir + zipEntry.getName ());
                FileUtilsExt.deleteQuietly (zippedFile);
                fileOutputStream = new FileOutputStream (zippedFile);
                int b;
                while ((b = zipInputStream.read ()) != - 1) {
                    fileOutputStream.write (b);
                }
                fileOutputStream.close ();
            }
        }
    } catch (IOException e) {
        LOGGER.error ("Can't unzip to " + targetDir, e);
        return false;
    } finally {
        try {
            zipInputStream.closeEntry ();
            if (fileOutputStream != null) {
                fileOutputStream.close ();
            }
        } catch (IOException e) {
            LOGGER.error ("Error while closing stream.", e);
        }
    }
    return true;
}


-----Function Pair=191=-----==

public static void gunzip (InputStream fis, String dir) throws Exception {
    File dest = new File (dir);
    FileOutputStream out = null;
    GZIPInputStream zIn = null;
    try {
        out = new FileOutputStream (dest);
        zIn = new GZIPInputStream (fis);
        byte [] buffer = new byte [8 * 1024];
        int count = 0;
        do {
            out.write (buffer, 0, count);
            count = zIn.read (buffer, 0, buffer.length);
        }
        while (count != - 1);
    } finally {
        fis.close ();
        out.close ();
        zIn.close ();
    }
}


public Reader getFileAsReader (String path) throws IOException {
    File explodedFile = getExplodedFile (path);
    if ((! file.exists () && ! tmpFile.exists () && ! explodedFile.exists ()) || removedFileSet.contains (path)) throw new FileNotFoundException (path);
    if (explodedFile.exists ()) return FileUtil.getFileAsReader (explodedFile);
    ZipEntry entry = new ZipEntry (path);
    ZipFile zipFile = getZipFile ();
    InputStream in = null;
    try {
        in = new BufferedInputStream (zipFile.getInputStream (entry));
        if (in != null) {
            if (log.isDebugEnabled ()) {
                String type;
                type = FileUtil.getContentType (in);
                if (type == null) type = FileUtil.getContentType (explodedFile);
                log.debug ("FileUtil.getContentType() returned " + (type != null ? type : "(null)"));
            }
            return new InputStreamReader (in);
        }
    } catch (Exception ex) {
    }
    throw new FileNotFoundException (path);
}


-----Function Pair=192=-----==

private void saveImages (ZipOutputStream zOut) throws IOException {
    List < String > added = new ArrayList < String > ();
    for (Iterator < EObject > iter = fModel.eAllContents (); iter.hasNext ();) {
        EObject eObject = iter.next ();
        if (eObject instanceof IDiagramModelImageProvider) {
            IDiagramModelImageProvider imageProvider = (IDiagramModelImageProvider) eObject;
            String imagePath = imageProvider.getImagePath ();
            if (imagePath != null && ! added.contains (imagePath)) {
                byte [] bytes = BYTE_ARRAY_STORAGE.getEntry (imagePath);
                if (bytes != null) {
                    ZipEntry zipEntry = new ZipEntry (imagePath);
                    zOut.putNextEntry (zipEntry);
                    zOut.write (bytes);
                    zOut.closeEntry ();
                    added.add (imagePath);
                }
            }
        }
    }
}


public static String [] splitPaths (String pathString, char pathSeparator, boolean winDriveLetters) {
    boolean checkDriveLetters = (pathSeparator == ':') && winDriveLetters;
    ArrayList < String > list = new ArrayList < String > ();
    int idx = 0;
    while ((idx = pathString.indexOf (pathSeparator, idx)) >= 0) {
        String path = pathString.substring (0, idx);
        if (checkDriveLetters && ((path.length () == 1) && (pathString.charAt (idx + 1) == File.separatorChar))) {
            ++ idx;
            continue;
        }
        list.add (path);
        pathString = pathString.substring (idx + 1);
        idx = 0;
    }
    list.add (pathString);
    return list.toArray (new String [list.size ()]);
}


-----Function Pair=193=-----==

public void remove (String fs, FilenameFilter ff, boolean tf) throws Exception {
    File f = new File (fs);
    if (f.getName ().length () < 1) return;
    String [] flist = f.list (ff);
    if (flist == null || flist.length < 1) {
        if (! (f.isDirectory () && ! tf)) f.delete ();
        return;
    }
    for (int i = 0; i < flist.length; i ++) {
        String p = f.getAbsolutePath ();
        if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
        FileUtil.deleteAll (p + flist [i], ff, tf);
    }
    if (f != null) if (! (f.isDirectory () && ! tf)) f.delete ();
}


protected String runExport (ONDEXGraph graph, File file, ONDEXExport export, ONDEXPluginArguments args, ZipFormat zipFormat) throws WebserviceException {
    BufferedOndexListener bufferedOndexListener = new BufferedOndexListener (logger);
    try {
        export.addONDEXListener (bufferedOndexListener);
        logger.info ("added listener");
        export.setONDEXGraph (graph);
        logger.info ("set graph");
        addDefaultArgements (export, args);
        logger.info ("added default arguements");
        engine.runExport (export, args, graph);
        logger.info ("ran export");
        logger.info ("done");
        if (zipFormat.equals (zipFormat.RAW)) {
            return fileToString (file);
        }
        else {
            File compressed = zipFile (file, zipFormat);
            return fileToUrl (compressed);
        }
    } catch (WebserviceException e) {
        throw e;
    } catch (Exception e) {
        throw new CaughtException (e, bufferedOndexListener, logger);
    }
}


-----Function Pair=194=-----==

public static void addFilesToExistingZip (final File zipFile, final List < PatchEntry > entries, final List < String > delete) throws IOException {
    File tempFile = File.createTempFile (zipFile.getName (), null);
    tempFile.delete ();
    boolean renameOk = zipFile.renameTo (tempFile);
    if (! renameOk) {
        throw new RuntimeException ("could not rename the file " + zipFile.getAbsolutePath () + " to " + tempFile.getAbsolutePath ());
    }
    byte [] buf = new byte [1024];
    ZipInputStream zin = new ZipInputStream (new FileInputStream (tempFile));
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    ZipEntry entry = zin.getNextEntry ();
    int unchangedCount = 0;
    int deletedCount = 0;
    while (entry != null) {
        String name = entry.getName ();
        boolean notInFiles = true;
        for (PatchEntry e : entries) {
            if (e.name.equals (name)) {
                notInFiles = false;
                break;
            }
        }
        if (notInFiles && delete.contains (name)) {
            deletedCount ++;
            log (String.format ("Deleting %s (%s of %s)", name, deletedCount, delete.size ()));
            notInFiles = false;
        }
        if (notInFiles) {
            unchangedCount ++;
            gui.setProgress (String.format ("Copying unchanged files (%s so far)...", unchangedCount));
            out.putNextEntry (new ZipEntry (name));
            int len;
            while ((len = zin.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
        }
        entry = zin.getNextEntry ();
    }
    zin.close ();
    int i = 0;
    for (PatchEntry e : entries) {
        log (String.format ("Patching %s (%s of %s)", e.name, i + 1, entries.size ()), i, entries.size ());
        InputStream in = e.inStream;
        out.putNextEntry (new ZipEntry (e.name));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
        i ++;
    }
    out.close ();
    tempFile.delete ();
}


private void addFilesToJar (JarOutputStream jos, File source, String targetName, String baseName, List < String > excludes, Map < String, String > contents) throws IOException, RitaException {
    if (! targetName.startsWith (baseName)) {
        throw new RitaInternalError (targetName + " is not under " + baseName);
    }
    if (contents.containsKey (targetName) && ! source.isDirectory ()) {
        LOG.warn ("Skipping duplicate file " + targetName + " from " + source.getName () + ", already found " + "in " + contents.get (targetName));
        return;
    }
    if (! contents.containsKey (targetName)) {
        contents.put (targetName, source.getPath ());
        if (source.isDirectory ()) {
            if (targetName.length () > 0) {
                jos.putNextEntry (new ZipEntry (targetName));
            }
        }
        else {
            FileInputStream in = new FileInputStream (source);
            addToJar (jos, targetName, source.length (), source.lastModified (), in);
            in.close ();
            return;
        }
    }
    for (File subFile : source.listFiles ()) {
        String potentialName = targetName + subFile.getName ();
        if (subFile.isDirectory ()) {
            potentialName += "/";
        }
        boolean isExcluded = false;
        if (potentialName.indexOf (baseName) != 0) {
            throw new RitaInternalError (potentialName + " is not under " + baseName);
        }
        String nameUnderBasename = potentialName.substring (baseName.length ());
        for (String exclude : excludes) {
            if (FilenameUtils.wildcardMatch (nameUnderBasename, exclude)) {
                LOG.debug ("Skipping excluded file " + nameUnderBasename + " from " + source.getName () + " which matches " + exclude);
                isExcluded = true;
                break;
            }
        }
        if (isExcluded) {
        }
        else {
            addFilesToJar (jos, subFile, potentialName, baseName, excludes, contents);
        }
    }
}


-----Function Pair=195=-----==

public static Boolean compress (String sSourceDir, ArrayList < String > aFiles, String sDestinationFilename) {
    log.info ("PentahoReport() sourceDir: " + sSourceDir + " destination:" + sDestinationFilename);
    BufferedInputStream oOrigin = null;
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    Iterator < String > oIterator;
    byte [] aData;
    try {
        oDestination = new FileOutputStream (sDestinationFilename);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        aData = new byte [BUFFER_SIZE];
        oIterator = aFiles.iterator ();
        while (oIterator.hasNext ()) {
            String sFilename = (String) oIterator.next ();
            FileInputStream fisInput = new FileInputStream (sSourceDir + File.separator + sFilename);
            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);
            ZipEntry oEntry = new ZipEntry (sFilename.replace ('\\', '/'));
            oOutput.putNextEntry (oEntry);
            int iCount;
            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {
                oOutput.write (aData, 0, iCount);
            }
            oOrigin.close ();
        }
        oOutput.close ();
    } catch (Exception oException) {
        log.error (oException.getMessage ());
        oException.printStackTrace ();
        return false;
    }
    return true;
}


public void performUpdates (List < PackageDescriptor > downloadList, ProgressListener progressListener) throws IOException, UpdateServiceException_Exception {
    int i = 0;
    try {
        for (PackageDescriptor desc : downloadList) {
            String urlString = service.getDownloadURL (desc.getPackageId (), desc.getVersion (), desc.getPlatformName ());
            int minProgress = 20 + 80 * i / downloadList.size ();
            int maxProgress = 20 + 80 * (i + 1) / downloadList.size ();
            boolean incremental = UpdateManager.isIncrementalUpdate ();
            if (desc.getPackageTypeName ().equals ("RAPIDMINER_PLUGIN")) {
                ManagedExtension extension = ManagedExtension.getOrCreate (desc.getPackageId (), desc.getName (), desc.getLicenseName ());
                String baseVersion = extension.getLatestInstalledVersionBefore (desc.getVersion ());
                incremental &= baseVersion != null;
                URL url = UpdateManager.getUpdateServerURI (urlString + (incremental ? "?baseVersion=" + URLEncoder.encode (baseVersion, "UTF-8") : "")).toURL ();
                if (incremental) {
                    LogService.getRoot ().info ("Updating " + desc.getPackageId () + " incrementally.");
                    try {
                        updatePluginIncrementally (extension, openStream (url, progressListener, minProgress, maxProgress), baseVersion, desc.getVersion ());
                    } catch (IOException e) {
                        LogService.getRoot ().warning ("Incremental Update failed. Trying to fall back on non incremental Update...");
                        incremental = false;
                    }
                }
                if (! incremental) {
                    LogService.getRoot ().info ("Updating " + desc.getPackageId () + ".");
                    updatePlugin (extension, openStream (url, progressListener, minProgress, maxProgress), desc.getVersion ());
                }
                extension.addAndSelectVersion (desc.getVersion ());
            }
            else {
                URL url = UpdateManager.getUpdateServerURI (urlString + (incremental ? "?baseVersion=" + URLEncoder.encode (RapidMiner.getLongVersion (), "UTF-8") : "")).toURL ();
                LogService.getRoot ().info ("Updating RapidMiner core.");
                updateRapidMiner (openStream (url, progressListener, minProgress, maxProgress), desc.getVersion ());
            }
            i ++;
            progressListener.setCompleted (20 + 80 * i / downloadList.size ());
        }
    } catch (URISyntaxException e) {
        throw new IOException (e);
    } finally {
        progressListener.complete ();
    }
}


-----Function Pair=196=-----=1=

public boolean comprimirFicheros (String [] archivoZipear, String rutaArchivoComprimido) {
    System.out.println ("**** DENTRO DE 'comprimirFicheros' ****");
    boolean estado = false;
    try {
        FileInputStream entradaFile = null;
        BufferedInputStream entradaBuffer = null;
        File archivo = new File (rutaArchivoComprimido);
        FileOutputStream salidaFile = new FileOutputStream (archivo);
        ZipOutputStream ZIP = new ZipOutputStream (salidaFile);
        byte [] datos = new byte [TAMANO_BUFFER];
        for (int i = 0; i < archivoZipear.length; i ++) {
            String nombreArchivo = archivoZipear [i];
            System.out.println ("Archivos: " + nombreArchivo);
            entradaFile = new FileInputStream (nombreArchivo);
            entradaBuffer = new BufferedInputStream (entradaFile, TAMANO_BUFFER);
            ZipEntry entradaZip = new ZipEntry (archivoZipear [i]);
            ZIP.putNextEntry (entradaZip);
            int bytes;
            while ((bytes = entradaBuffer.read (datos)) > 0) {
                ZIP.write (datos, 0, bytes);
                estado = true;
            }
            ZIP.closeEntry ();
            entradaFile.close ();
        }
        ZIP.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        estado = false;
    } catch (Exception e) {
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


private static void replaceEntityMappings (File signserverearpath, File entityMappingXML) throws ZipException, IOException {
    ZipInputStream earFile = new ZipInputStream (new FileInputStream (signserverearpath));
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    ZipOutputStream tempZip = new ZipOutputStream (baos);
    ZipEntry next = earFile.getNextEntry ();
    while (next != null) {
        ByteArrayOutputStream content = new ByteArrayOutputStream ();
        byte [] data = new byte [30000];
        int numberread;
        while ((numberread = earFile.read (data)) != - 1) {
            content.write (data, 0, numberread);
        }
        if (next.getName ().equals ("signserver-ejb.jar")) {
            content = replaceEntityMappings (content, entityMappingXML);
            next = new ZipEntry ("signserver-ejb.jar");
        }
        tempZip.putNextEntry (next);
        tempZip.write (content.toByteArray ());
        next = earFile.getNextEntry ();
    }
    earFile.close ();
    tempZip.close ();
    FileOutputStream fos = new FileOutputStream (signserverearpath);
    fos.write (baos.toByteArray ());
    fos.close ();
}


-----Function Pair=197=-----==

private void forkJavaProcess (String jvm, File classworldsConfFile) throws MojoFailureException {
    cli.clearArgs ();
    cli.createArg ().setValue ("-classpath");
    cli.createArg ().setValue (classpath);
    cli.createArg ().setValue ("-enableassertions");
    cli.createArg ().setValue ("-Dclassworlds.conf=" + classworldsConfFile.getAbsolutePath ());
    cli.createArg ().setValue (CLASSWORLDS_LAUNCHER_CLASSNAME);
    File validationFile = new File (classworldsConfFile.getParent (), "validations.txt");
    cli.createArg ().setValue (validationFile.getAbsolutePath ());
    Log log = getLog ();
    if (log.isDebugEnabled ()) {
        log.debug (cli.toString ());
    }
    int returnCode;
    try {
        StreamConsumer out = getForkingStreamConsumer (false, false);
        StreamConsumer err = getForkingStreamConsumer (false, false);
        returnCode = CommandLineUtils.executeCommandLine (cli, out, err);
    } catch (Throwable e) {
        MojoFailureException excep = new MojoFailureException ("Error launching baseline");
        e.printStackTrace ();
        excep.initCause (e);
        throw excep;
    }
    if (returnCode != 0) {
        if (archiveOnFail) {
            archiveTestResults ();
        }
        throw new MojoFailureException ("Error executing baseline (return code " + returnCode + ")");
    }
}


private void addMapDataToRow (Row row, Map < Object, Object > rowdata) {
    Set < Entry < String, FieldProperty > > enterSet = (fieldMap).entrySet ();
    Iterator < Entry < String, FieldProperty > > entryIte = enterSet.iterator ();
    Entry < String, FieldProperty > entry = null;
    int column = 0;
    Cell cell = null;
    Object value = null;
    while (entryIte.hasNext ()) {
        cell = row.createCell (column);
        entry = entryIte.next ();
        value = rowdata.get (entry.getValue ().getProperty ());
        addCellValue (cell, value, entry.getValue ());
        column ++;
    }
}


-----Function Pair=198=-----==

private void UpdateTopicOwners (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_owner where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        Hashtable owners = t.GetOwner ();
        if (owners != null && ! owners.isEmpty ()) {
            sql = "insert into topic_owner(topid,userid) values(?,?)";
            pstmt = inCtxt.GetConnection ().prepareStatement (sql);
            Enumeration owners_elements = owners.elements ();
            while (owners_elements.hasMoreElements ()) {
                Topic.Owner owner = (Topic.Owner) owners_elements.nextElement ();
                pstmt.setString (1, t.GetId ());
                pstmt.setString (2, owner.GetID ());
                pstmt.executeUpdate ();
            }
        }
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


public final void unzip (File zip, File extractTo) throws IOException {
    deleteDirectory (extractTo);
    ZipFile archive = new ZipFile (zip);
    Enumeration e = archive.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        File file = new File (extractTo, entry.getName ());
        if (entry.isDirectory () && ! file.exists ()) {
            file.mkdirs ();
        }
        else {
            if (! file.getParentFile ().exists ()) {
                file.getParentFile ().mkdirs ();
            }
            InputStream in = archive.getInputStream (entry);
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            byte [] buffer = new byte [8192];
            int read;
            while (- 1 != (read = in.read (buffer))) {
                out.write (buffer, 0, read);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=199=-----==

public static String [] readFileLineByLine (String fileName) {
    List < String > sl = new ArrayList < String > ();
    try {
        if (! new File (fileName).exists ()) {
            new File (fileName).createNewFile ();
        }
        FileInputStream fis = new FileInputStream (new File (fileName));
        InputStreamReader isr = new InputStreamReader (fis);
        BufferedReader reader = new BufferedReader (isr);
        String currline = "";
        while ((currline != null)) {
            currline = reader.readLine ();
            if (currline != null) {
                sl.add (currline);
            }
        }
        reader.close ();
        isr.close ();
        fis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String [] strs = sl.toArray (new String [0]);
    return strs;
}


private void ZipPageTemplates (ZipOutputStream out) throws Exception {
    if (page_templates == null || page_templates.isEmpty ()) return;
    String filename = "TOPIC" + GetId () + ".pts";
    out.putNextEntry (new ZipEntry (filename));
    try {
        ZipWriter writer = new ZipWriter (out);
        for (Object obj : page_templates) {
            PageTemplate pt = (PageTemplate) obj;
            if (pt != null) {
                writer.println (pt.GetId ());
            }
        }
    } finally {
        out.closeEntry ();
    }
}


-----Function Pair=200=-----==

public String getWorkflowNameFromZipFile (File zipFile) throws Exception {
    String workflowID = new String ("");
    ZipInputStream zin = new ZipInputStream (new BufferedInputStream (new FileInputStream (zipFile)));
    ZipEntry zipEntry = null;
    while ((zipEntry = zin.getNextEntry ()) != null) {
        if (zipEntry.isDirectory ()) {
            String zipEntryName = zipEntry.getName ();
            if ("".equals (workflowID)) {
                workflowID = zipEntryName;
            }
        }
    }
    zin.close ();
    return workflowID;
}


private String GetClob (CLOB clob) throws Exception {
    if (clob == null) return null;
    Reader is = null;
    StringWriter so = null;
    try {
        is = clob.getCharacterStream ();
        so = new StringWriter ();
        int b;
        while ((b = is.read ()) != - 1) {
            so.write (b);
        }
        return so.toString ();
    } finally {
        if (so != null) try {
            so.close ();
        } catch (Exception e) {
        }
        if (is != null) try {
            is.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=201=-----==

public void actionPerformed (ActionEvent e) {
    Tracer.getInstance ().trace ("edit skin files");
    final JTextPad textpad = JTextPad.getLastUsedInstance ();
    final File skinDir = context.getJAlbumContext ().getSkinDir ();
    final File [] files = skinDir.listFiles ();
    new Thread ("loader thread") {
        @Override
        public void run () {
            boolean first = true;
            for (File f : files) {
                String ext = IO.extensionOf (f).toLowerCase ();
                if (JTextPad.fileTypes.containsKey (ext)) {
                    JTextPadDocument document = getConfiguredDocument (textpad, f);
                    if (first) {
                        textpad.setCurrentDocument (document);
                        textpad.toFront ();
                        first = false;
                    }
                }
            }
        }
    }
    .start ();
}


protected synchronized Iterator childrenInFileSystem (String mountPath, String path) throws IOException {
    LinkedList childList = new LinkedList ();
    Hashtable childTable = new Hashtable ();
    flush ();
    if (zipFile != null) {
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            ZipEntry ze = (ZipEntry) (e.nextElement ());
            String name = ze.getName ();
            if (! name.startsWith ("META-INF") && name.startsWith (path)) {
                int plen = path.length ();
                if ((plen < name.length ()) && (name.charAt (plen) == '/')) plen ++;
                int idx = name.indexOf ('/', plen);
                String childName = name.substring (plen, (idx != - 1) ? idx : name.length ());
                if ((childName.length () > 0) && (childTable.get (childName) == null)) {
                    childTable.put (childName, childName);
                    AbstractFile file = resolveInFileSystem (mountPath, ((plen == 0) ? "" : (path + SEPERATOR_CHAR)) + childName);
                    childList.add (file);
                }
            }
        }
    }
    return childList.iterator ();
}


-----Function Pair=202=-----==

public static void encodeInstancia (InstanciaBean bean, OutputStream result) throws IOException {
    ZipOutputStream zipos = new ZipOutputStream (result);
    zipos.setMethod (ZipOutputStream.DEFLATED);
    for (Iterator iterAnexo = bean.getAnexos ().keySet ().iterator (); iterAnexo.hasNext ();) {
        String key = (String) iterAnexo.next ();
        Anexo anexo = (Anexo) bean.getAnexos ().get (key);
        String entryName = ANEXO_SUBDIR + anexo.getName ();
        ZipEntry zipEntry = new ZipEntry (entryName);
        zipEntry.setTime (System.currentTimeMillis ());
        zipEntry.setSize (anexo.getData ().length);
        zipEntry.setComment (anexo.getContentType ());
        zipos.putNextEntry (zipEntry);
        zipos.write (anexo.getData (), 0, anexo.getData ().length);
        zipos.closeEntry ();
        bean.getAnexos ().put (key, entryName);
    }
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    XMLEncoder encoder = new XMLEncoder (baos);
    encoder.setPersistenceDelegate (Locale.class, new DefaultPersistenceDelegate (new String [] {"language", "country", "variant"}));
    encoder.writeObject (bean);
    encoder.close ();
    byte [] content = baos.toByteArray ();
    ZipEntry zipEntry = new ZipEntry (FORM_DATA_FILE);
    zipEntry.setSize (baos.size ());
    zipEntry.setTime (System.currentTimeMillis ());
    zipos.putNextEntry (zipEntry);
    zipos.write (content, 0, content.length);
    zipos.closeEntry ();
    zipos.close ();
}


private static ByteArrayOutputStream insertModule (ZipInputStream earFile, ZipEntry next, ByteArrayOutputStream content, String moduleType, String moduleName, String contextRoot) throws IOException {
    String application = new String (content.toByteArray (), "UTF-8");
    ByteArrayOutputStream retval = new ByteArrayOutputStream ();
    if (! application.contains (moduleName)) {
        if (moduleType.equals (MODULETYPE_WEB)) {
            String moduleText = "<module><web><web-uri>" + moduleName + "</web-uri><context-root>" + contextRoot + "</context-root></web></module>";
            application = application.replace ("</application>", moduleText + "\n</application>");
        }
        if (moduleType.equals (MODULETYPE_EJB)) {
            String moduleText = "<module><ejb>" + moduleName + "</ejb></module>";
            application = application.replace ("</application>", moduleText + "\n</application>");
        }
    }
    retval.write (application.getBytes ("UTF-8"));
    return retval;
}


-----Function Pair=203=-----==

protected void mergeSortedFiles (File outFile) throws IOException {
    SortedMap < String, ElementDescriptor > sortedDescriptors = new TreeMap < String, ElementDescriptor > ();
    for (int index = 0; index <= iterationNum; index ++) {
        String fileName = workingDirectory.getPath () + File.separator + workingFileName + index + ".csv";
        System.out.println ("Adding file to merge: " + fileName);
        File file = new File (fileName);
        BufferedReader reader = new BufferedReader (new FileReader (file));
        ElementDescriptor desc = new ElementDescriptor ();
        desc.ligne = reader.readLine ();
        desc.reader = reader;
        desc.fileName = fileName;
        desc.key = generateKeyFromLine (desc.ligne);
        sortedDescriptors.put (desc.key, desc);
    }
    OutputStream fos = new FileOutputStream (outFile);
    if (zipOutputFile) {
        fos = new ZipOutputStream (fos);
        ((ZipOutputStream) fos).setLevel (9);
        int index = outFile.getName ().toLowerCase ().indexOf (".zip");
        ZipEntry entry = new ZipEntry (outFile.getName ().substring (0, index));
        ((ZipOutputStream) fos).putNextEntry (entry);
    }
    while (sortedDescriptors.size () > 0) {
        ElementDescriptor smallestDesc = getSmallestDescriptor (sortedDescriptors);
        fos.write ((smallestDesc.ligne + "\n").getBytes ());
        sortedDescriptors.remove (smallestDesc.key);
        smallestDesc.ligne = smallestDesc.reader.readLine ();
        if (smallestDesc.ligne != null) {
            smallestDesc.key = generateKeyFromLine (smallestDesc.ligne);
            sortedDescriptors.put (smallestDesc.key, smallestDesc);
        }
        else {
            smallestDesc.reader.close ();
            if (dropTempFiles) {
                File descFile = new File (smallestDesc.fileName);
                if (! descFile.delete ()) System.out.println ("Chunk file: '" + smallestDesc.fileName + "' could not be deleted. Still opened?");
                else System.out.println ("Chunk file: '" + smallestDesc.fileName + "' has been deleted properly.");
            }
        }
    }
    fos.flush ();
    fos.close ();
}


public VFSFile _getFile (Object session, String path, Component comp) {
    ArchivePath archive = new ArchivePath (path);
    String archiveProtocol = archive.protocol;
    String archivePath = archive.pathName;
    String archiveEntry = archive.entryName;
    if (archiveEntry.equals ("")) {
        return null;
    }
    VFSFile [] directory = this._listFiles (session, this.getParentOfPath (path), comp);
    if (directory == null) {
        return null;
    }
    String canonPath = (archiveProtocol + ':' + archivePath + ArchiveVFS.archiveSeparator + ArchiveVFS.fileSeparator + archiveEntry);
    for (int i = 0; i < directory.length; i ++) {
        VFSFile entry = directory [i];
        if (entry.getPath ().equals (canonPath)) {
            return entry;
        }
    }
    return null;
}


-----Function Pair=204=-----==

public static void copyResource (Class < ? > sourceResClass, String sourceResName, File destinationFile) throws IOException {
    InputStream source = null;
    FileOutputStream destination = null;
    try {
        source = sourceResClass.getResourceAsStream (sourceResName);
        if (source == null) throw new FileNotFoundException ("Class " + sourceResClass.getName () + " could not find resource " + sourceResName);
        if (destinationFile.exists ()) {
            if (destinationFile.isFile ()) {
                if (! destinationFile.canWrite ()) throw new IOException ("FileCopy: destination file is unwriteable: " + destinationFile.getCanonicalPath ());
            }
            else throw new IOException ("FileCopy: destination is not a file: " + destinationFile.getCanonicalPath ());
        }
        else {
            File parentdir = destinationFile.getAbsoluteFile ().getParentFile ();
            if (parentdir == null || ! parentdir.exists ()) throw new IOException ("FileCopy: destination's parent directory doesn't exist: " + destinationFile.getCanonicalPath ());
            if (! parentdir.canWrite ()) throw new IOException ("FileCopy: destination's parent directory is unwriteable: " + destinationFile.getCanonicalPath ());
        }
        destination = new FileOutputStream (destinationFile);
        transferStreamData (source, destination);
    } finally {
        if (source != null) try {
            source.close ();
        } catch (IOException e) {
        }
        if (destination != null) try {
            destination.close ();
        } catch (IOException e) {
        }
    }
}


public static void obfusticateArea (Display display, Image image, Rectangle bounds, String text) {
    if (bounds.isEmpty ()) return;
    if (text == "") {
        obfusticateArea (display, image, bounds);
        return;
    }
    GC gc = new GC (image);
    try {
        gc.setBackground (display.getSystemColor (SWT.COLOR_WHITE));
        gc.setForeground (display.getSystemColor (SWT.COLOR_RED));
        gc.fillRectangle (bounds);
        gc.drawRectangle (bounds);
        gc.setClipping (bounds);
        gc.drawText (text, bounds.x + 2, bounds.y + 1);
    } finally {
        gc.dispose ();
    }
}


-----Function Pair=205=-----==

public boolean storeTransactionToZippedStream (OutputStream outputStream, boolean updateResourceFiles) {
    System.out.println ("Writing as a zipped transaction: " + this.uuid);
    ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);
    try {
        zipOutputStream.setLevel (Deflater.DEFAULT_COMPRESSION);
        String relativeFileName = ArchiveFileSupport.fileNameInSubdirectoryForTransactionIdentifier (this.uuid);
        ZipEntry zipEntry = new ZipEntry (relativeFileName);
        try {
            zipOutputStream.putNextEntry (zipEntry);
            if (! this.writeTransactionMetadataAndTriplesToUTF8Stream (zipOutputStream)) {
                return false;
            }
            zipOutputStream.closeEntry ();
        } catch (IOException e) {
            e.printStackTrace ();
            return false;
        }
        for (String transactionResourceFileReference : this.resourceFiles.keySet ()) {
            ResourceFileSpecification resourceFileSpecification = this.resourceFiles.get (transactionResourceFileReference);
            zipEntry = new ZipEntry (transactionResourceFileReference);
            zipOutputStream.putNextEntry (zipEntry);
            if (! resourceFileSpecification.copyTo (zipOutputStream, updateResourceFiles)) {
                return false;
            }
            zipOutputStream.closeEntry ();
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
        this.resetResourceFiles ();
        return false;
    } catch (IOException e) {
        e.printStackTrace ();
        this.resetResourceFiles ();
        return false;
    } finally {
        try {
            zipOutputStream.close ();
        } catch (IOException e) {
            e.printStackTrace ();
            return false;
        }
    }
    return true;
}


private static void recurseAndTarFiles (File file, TarArchiveOutputStream tos) throws IOException, FileNotFoundException {
    if (file.isDirectory ()) {
        String [] fileNames = file.list ();
        if (fileNames != null) {
            for (int i = 0; i < fileNames.length; i ++) {
                recurseAndTarFiles (new File (file, fileNames [i]), tos);
                System.out.println (fileNames [i]);
            }
        }
    }
    else if (! file.getName ().endsWith (TAR_EXTENSION)) {
        byte [] buf = new byte [1024];
        int len;
        TarArchiveEntry tarEntry = new TarArchiveEntry (file.toString ());
        System.out.println (file.toString ());
        tarEntry.setSize (file.length ());
        FileInputStream fin = new FileInputStream (file);
        BufferedInputStream in = new BufferedInputStream (fin);
        tos.putArchiveEntry (tarEntry);
        while ((len = in.read (buf)) != - 1) {
            tos.write (buf, 0, len);
        }
        in.close ();
        tos.closeArchiveEntry ();
    }
}


-----Function Pair=206=-----==

private void parseArgs (String [] args) {
    Options options = new Options ();
    OptionGroup group = new OptionGroup ();
    group.addOption (new Option ("e", "encrypt", false, "Encrypt"));
    group.addOption (new Option ("d", "decrypt", false, "Decrypt"));
    group.addOption (new Option ("v", "view", false, "View"));
    options.addOptionGroup (group);
    Option o = new Option ("r", "root", true, "Resource Root");
    o.setRequired (false);
    options.addOption (o);
    options.addOption ("a", "archive", true, "Archive Name");
    try {
        CommandLine cmd = new PosixParser ().parse (options, args, true);
        if (cmd.hasOption ('e')) {
            mode = ENCRYPT_MODE;
        }
        else if (cmd.hasOption ('d')) {
            mode = DECRYPT_MODE;
        }
        else if (cmd.hasOption ('v')) {
            mode = VIEW_MODE;
        }
        resourceRoot = cmd.getOptionValue ('r', ".");
        archiveName = cmd.getOptionValue ('a');
    } catch (MissingArgumentException e) {
        new HelpFormatter ().printHelp ("Missing argument", options);
        System.exit (1);
    } catch (UnrecognizedOptionException e) {
        new HelpFormatter ().printHelp ("Unrecognized option", options);
        System.exit (1);
    } catch (MissingOptionException e) {
        new HelpFormatter ().printHelp ("Missing option", options);
        System.exit (1);
    } catch (Exception e) {
        new HelpFormatter ().printHelp ("Unknown error", options);
        System.exit (1);
    }
}


protected void closeExportFile (Element exportNode) throws IOException, SAXException {
    getSaxWriter ().writeClose (exportNode);
    CmsXmlSaxWriter xmlSaxWriter = (CmsXmlSaxWriter) getSaxWriter ().getContentHandler ();
    xmlSaxWriter.endDocument ();
    ZipEntry entry = new ZipEntry (CmsImportExportManager.EXPORT_MANIFEST);
    getExportZipStream ().putNextEntry (entry);
    StringBuffer result = ((StringWriter) xmlSaxWriter.getWriter ()).getBuffer ();
    int steps = result.length () / SUB_LENGTH;
    int rest = result.length () % SUB_LENGTH;
    int pos = 0;
    for (int i = 0; i < steps; i ++) {
        String sub = result.substring (pos, pos + SUB_LENGTH);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
        pos += SUB_LENGTH;
    }
    if (rest > 0) {
        String sub = result.substring (pos, pos + rest);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
    }
    getExportZipStream ().closeEntry ();
    getExportZipStream ().close ();
}


-----Function Pair=207=-----==

public static void extract (byte [] source, File destination) throws IOException {
    if (! destination.exists ()) {
        destination.mkdirs ();
    }
    else if (! destination.isDirectory ()) {
        throw new IOException ("Extraction can be done into directory only!");
    }
    ZipInputStream is = new ZipInputStream (new ByteArrayInputStream (source));
    ZipEntry ze;
    while ((ze = is.getNextEntry ()) != null) {
        if (ze.getName ().endsWith (Constants.PATH_SEPARATOR)) {
            File dir = new File (destination, ze.getName ());
            dir.mkdir ();
        }
        else {
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            byte [] buffer = new byte [1024];
            int br;
            while ((br = is.read (buffer)) > 0) {
                baos.write (buffer, 0, br);
            }
            baos.close ();
            String name = URLDecoder.decode (ze.getName (), Constants.DEFAULT_ENCODING);
            File file = new File (destination, name);
            File dir = file.getParentFile ();
            if (! dir.exists ()) {
                dir.mkdirs ();
            }
            file.createNewFile ();
            FSUtils.writeFile (file, baos.toByteArray ());
        }
    }
    is.close ();
}


public void writeInstallationInformation () throws IOException, ClassNotFoundException {
    if (! idata.info.isWriteInstallationInformation ()) {
        Debug.trace ("skip writing installation information");
        return;
    }
    Debug.trace ("writing installation information");
    String installdir = idata.getInstallPath ();
    List installedpacks = new ArrayList (idata.selectedPacks);
    File installationinfo = new File (installdir + File.separator + AutomatedInstallData.INSTALLATION_INFORMATION);
    if (! installationinfo.exists ()) {
        Debug.trace ("creating info file" + installationinfo.getAbsolutePath ());
        installationinfo.createNewFile ();
    }
    else {
        Debug.trace ("installation information found");
        FileInputStream fin = new FileInputStream (installationinfo);
        ObjectInputStream oin = new ObjectInputStream (fin);
        List packs = (List) oin.readObject ();
        for (Object pack1 : packs) {
            Pack pack = (Pack) pack1;
            installedpacks.add (pack);
        }
        oin.close ();
        fin.close ();
    }
    FileOutputStream fout = new FileOutputStream (installationinfo);
    ObjectOutputStream oout = new ObjectOutputStream (fout);
    oout.writeObject (installedpacks);
    oout.writeObject (idata.variables);
    Debug.trace ("done.");
    oout.close ();
    fout.close ();
}


-----Function Pair=208=-----==

public static void UnZip (String zipLocation, String toDir) throws Exception {
    File zipFile = new File (zipLocation);
    File dir = new File (toDir);
    ZipInputStream zis = null;
    try {
        zis = new ZipInputStream (new FileInputStream (zipFile));
        for (ZipEntry ze = null; (ze = zis.getNextEntry ()) != null;) UnZipEntry (dir, zis, ze.getName (), ze.isDirectory ());
    } catch (IOException ioe) {
        throw ioe;
    } finally {
        if (zis != null) try {
            zis.close ();
        } catch (IOException e) {
            throw e;
        }
    }
}


private static void writeJarFile (ZipOutputStream myZip) throws Exception {
    myZip.putNextEntry (new ZipEntry ("org/ea/Extractor.class"));
    String p = System.getProperty ("java.class.path");
    ZipInputStream myJar = new ZipInputStream (new FileInputStream (p));
    ZipEntry ze = null;
    while ((ze = myJar.getNextEntry ()) != null) {
        if (ze.getName ().compareTo ("org/ea/Extractor.class") == 0) {
            int i = 0;
            while ((i = myJar.read ()) != - 1) {
                myZip.write (i);
            }
        }
    }
    myJar.close ();
    myZip.closeEntry ();
}


-----Function Pair=209=-----==

private static void zip (File d) throws FileNotFoundException, IOException {
    String [] entries = d.list ();
    byte [] buffer = new byte [4096];
    int bytesRead;
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (new File (d.getParent () + File.separator + "dist.zip")));
    for (int i = 0; i < entries.length; i ++) {
        File f = new File (d, entries [i]);
        if (f.isDirectory ()) continue;
        FileInputStream in = new FileInputStream (f);
        int skipl = d.getCanonicalPath ().length ();
        ZipEntry entry = new ZipEntry (f.getPath ().substring (skipl));
        out.putNextEntry (entry);
        while ((bytesRead = in.read (buffer)) != - 1) out.write (buffer, 0, bytesRead);
        in.close ();
    }
    out.close ();
    FileUtils.moveFile (new File (d.getParent () + File.separator + "dist.zip"), new File (d + File.separator + "dist.zip"));
}


public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositions [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositions.length; i ++) {
            int currentStart = sortedPositions [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedPositions [0].position);
        if (useShort) {
            int bp = sortedPositions [0].position;
            for (int i = 1; i < sortedPositions.length; i ++) {
                int currentStart = sortedPositions [i].position;
                int diff = currentStart - bp - 32768;
                workingDOS.writeShort ((short) (diff));
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositions [0].position;
            for (int i = 1; i < sortedPositions.length; i ++) {
                int currentStart = sortedPositions [i].position;
                int diff = currentStart - bp;
                workingDOS.writeInt (diff);
                bp = currentStart;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


-----Function Pair=210=-----==

public void createZip (List < String > listado, String zip_filename) {
    FileOutputStream fos = null;
    ZipOutputStream zos = null;
    try {
        fos = new FileOutputStream (zip_filename);
        zos = new ZipOutputStream (fos);
        zos.setLevel (9);
        Logger.getLogger ("sirf.actions").debug (listado);
        Set < String > listadoSet = new HashSet < String > (listado);
        for (String pathname : listadoSet) {
            Logger.getLogger ("sirf.actions").debug (pathname);
            FileInputStream fis = new FileInputStream (pathname);
            byte [] content_file = new byte [1024];
            ZipEntry ze = this.getEntry (pathname, getDirSubSistema (pathname));
            zos.putNextEntry (ze);
            while (fis.read (content_file, 0, 1024) != - 1) {
                zos.write (content_file);
            }
            zos.closeEntry ();
            fis.close ();
        }
        zos.flush ();
        zos.close ();
    } catch (FileNotFoundException e) {
        throw new ComprimirException ("Fichero no encontrado: " + e.getMessage ());
    } catch (IOException e) {
        throw new ComprimirException ("Error de entrada/salida. El fichero puede estar en uso.");
    }
}


public void addFiles () {
    JFileChooser jfilechooser = new JFileChooser ();
    jfilechooser.setCurrentDirectory (new File ("."));
    jfilechooser.setDialogType (0);
    jfilechooser.setDialogTitle ("Select Files/Directories to Add to " + currentArchive.getName ());
    jfilechooser.setMultiSelectionEnabled (true);
    jfilechooser.setFileSelectionMode (2);
    JPanel jpanel = new JPanel (new GridLayout (0, 2));
    JPanel jpanel1 = new JPanel ();
    JPanel jpanel2 = new JPanel (new GridLayout (2, 0));
    jpanel.add (jpanel2);
    jpanel1.setBorder (new TitledBorder ("Compression Method"));
    jpanel2.setBorder (new TitledBorder ("File Selection Options"));
    jpanel1.add (compressMethodComboBox);
    jpanel2.add (retrieveSubCheckBox);
    retrieveSubCheckBox.setSelected (true);
    saveDirCheckBox.setSelected (true);
    if (jfilechooser.showDialog (this, "Add...") != 0) {
        return;
    }
    else {
        File file = jfilechooser.getCurrentDirectory ();
        File afile [] = getSelectedFiles (jfilechooser);
        Adder adder = new Adder (currentArchive, afile, file);
        adder.start ();
        return;
    }
}


-----Function Pair=211=-----==

public void addMember (MModel m) throws PropertyVetoException {
    Iterator iter = _members.iterator ();
    Object currentMember = null;
    boolean memberFound = false;
    while (iter.hasNext ()) {
        currentMember = iter.next ();
        if (currentMember instanceof ProjectMemberModel) {
            MModel currentModel = ((ProjectMemberModel) currentMember).getModel ();
            if (currentModel == m) {
                memberFound = true;
                break;
            }
        }
    }
    if (! memberFound) {
        if (! _models.contains (m)) {
            addModel (m);
        }
        ProjectMember pm = new ProjectMemberModel (m, this);
        _members.addElement (pm);
    }
}


protected Dialog onCreateDialog (int id) {
    Dialog dialog = null;
    switch (id) {
        case DIALOG_EDIT_CAPTION :
            ViewGroup editCaption = (ViewGroup) getLayoutInflater ().inflate (R.layout.dialog_edit_caption, null);
            dialog = new AlertDialog.Builder (this).setView (editCaption).create ();
            dialog.setOnDismissListener (new DialogInterface.OnDismissListener () {
                @Override
                public void onDismiss (DialogInterface dlg) {
                    EditText txtField = (EditText) ((Dialog) dlg).findViewById (R.id.dialog_textfield);
                    if (mSelectedItem != null && txtField != null && txtField.getText () != null) {
                        mSelectedItem.caption = txtField.getText ().toString ().trim ();
                        mAdapter.notifyDataSetChanged ();
                    }
                }
            }
            );
            return dialog;
        case DIALOG_PROGRESS_EXPORT :
            progressDialog = new ProgressDialog (this);
            progressDialog.setProgressStyle (ProgressDialog.STYLE_HORIZONTAL);
            progressDialog.setMessage (getText (R.string.exporting));
            progressDialog.setCancelable (true);
            return progressDialog;
        case DIALOG_WAIT_EDIT_CAPTION :
            dialog = new ProgressDialog (this);
            ((ProgressDialog) dialog).setProgressStyle (ProgressDialog.STYLE_SPINNER);
            ((ProgressDialog) dialog).setMessage (getText (R.string.preparing_preview));
            ((ProgressDialog) dialog).setCancelable (false);
            return dialog;
        default :
            return null;
    }
}


-----Function Pair=212=-----==

private void linkComponents () {
    boolean fullyInitialised;
    int count = 0;
    do {
        fullyInitialised = true;
        for (int i = 0; i = parts.length; i ++) {
            HardwareComponent outer = parts [i];
            if (outer.updated ()) {
                continue;
            }
            for (int i = 0; i < parts.length; i ++) {
                HardwareComponent inner = parts [i];
                outer.updateComponent (inner);
            }
            fullyInitialised &= outer.updated ();
        }
        count ++;
    }
    while ((fullyInitialised == false) && (count < 100));
    if (! fullyInitialised) {
        StringBuilder sb = new StringBuilder ("pc >> component linking errors\n");
        List args = new ArrayList ();
        for (int i = 0; i < parts.length; i ++) {
            HardwareComponent hwc = parts [i];
            if (! hwc.initialised ()) {
                sb.append ("component {" + args.size () + "} not linked");
                args.add (hwc);
            }
        }
        LOGGING.log (Level.WARNING, sb.toString (), args.toArray ());
    }
}


public byte [] getDocument (User user, String name, Hashtable parametri) throws EXistException, PermissionDeniedException {
    String encoding = "UTF-8";
    String compression = "no";
    if (((String) parametri.get ("encoding")) == null) {
        encoding = "UTF-8";
    }
    else {
        encoding = (String) parametri.get ("encoding");
    }
    if (((String) parametri.get (EXistOutputKeys.COMPRESS_OUTPUT)) != null) {
        compression = (String) parametri.get (EXistOutputKeys.COMPRESS_OUTPUT);
    }
    RpcConnection con = pool.get ();
    try {
        String xml = con.getDocument (user, name, parametri);
        if (xml == null) throw new EXistException ("document " + name + " not found!");
        try {
            if (compression.equals ("no")) {
                return xml.getBytes (encoding);
            }
            else {
                LOG.debug ("getdocument with compression");
                return compress (xml.getBytes (encoding));
            }
        } catch (UnsupportedEncodingException uee) {
            if (compression.equals ("no")) {
                return xml.getBytes ();
            }
            else {
                LOG.debug ("getdocument with compression");
                return compress (xml.getBytes ());
            }
        }
    } catch (Exception e) {
        handleException (e);
        return null;
    } finally {
        pool.release (con);
    }
}


-----Function Pair=213=-----==

public static void playerLog (Session session, Race race, String pattern, Object...arguments) {
    try {
        InetAddress ip = null;
        javax.mail.internet.InternetAddress [] from = null;
        if (session != null) {
            ip = session.ip;
            from = session.getFrom ();
        }
        StringBuilder builder = new StringBuilder ();
        builder.append (race.getGalaxy ().getName ()).append ('\t');
        builder.append (race.getName ()).append ('\t');
        builder.append (ip != null ? ip.getHostAddress () : "-").append ('\t');
        builder.append (from != null && from.length != 0 ? from [0].getAddress () : "-").append ('\t');
        builder.append (MessageFormat.format (pattern, arguments));
        Utils.appendLogLine (new File ("secret.log"), builder.toString ());
    } catch (IOException err) {
        Galaxy.getLogger ().log (Level.SEVERE, "Can't write server log", err);
    }
}


protected void addOneJarBoot (ZipOutputStream zOut) throws IOException {
    if (zOut == null) return;
    if (onejar != null) {
        includeZip (onejar, zOut);
    }
    else {
        String ONE_JAR_BOOT = "one-jar-boot.jar";
        InputStream is = OneJarTask.class.getResourceAsStream (ONE_JAR_BOOT);
        if (is == null) throw new IOException ("Unable to load default " + ONE_JAR_BOOT + ": consider using the <one-jar onejarboot=\"...\"> option.");
        JarInputStream jis = new JarInputStream (is);
        Manifest manifest = new Manifest ();
        java.util.jar.Manifest jmanifest = jis.getManifest ();
        java.util.jar.Attributes jattributes = jmanifest.getMainAttributes ();
        try {
            manifest.addConfiguredAttribute (new Attribute ("Created-By", "One-Jar 0.98 Ant taskdef"));
            manifest.addConfiguredAttribute (new Attribute (MAIN_CLASS, jattributes.getValue (MAIN_CLASS)));
            if (oneJarMainClass != null) {
                manifest.addConfiguredAttribute (new Attribute (Boot.ONE_JAR_MAIN_CLASS, oneJarMainClass));
            }
            super.addConfiguredManifest (manifest);
        } catch (ManifestException mx) {
            throw new BuildException (mx);
        }
        super.initZipOutputStream (zOut);
        ZipEntry entry = jis.getNextEntry ();
        while (entry != null) {
            if (entry.getName ().endsWith (CLASS) || entry.getName ().equals (".version") || entry.getName ().endsWith ("license.txt")) {
                log ("entry=" + entry.getName (), Project.MSG_DEBUG);
                zOut.putNextEntry (new org.apache.tools.zip.ZipEntry (entry));
                copy (jis, zOut, false);
            }
            entry = jis.getNextJarEntry ();
        }
    }
}


-----Function Pair=214=-----==

void create (OutputStream out, Manifest manifest) throws IOException {
    ZipOutputStream zos = new JarOutputStream (out);
    if (flag0) {
        zos.setMethod (ZipOutputStream.STORED);
    }
    if (manifest != null) {
        if (vflag) {
            output (getMsg ("out.added.manifest"));
        }
        ZipEntry e = new ZipEntry (MANIFEST_DIR);
        e.setTime (System.currentTimeMillis ());
        e.setSize (0);
        e.setCrc (0);
        zos.putNextEntry (e);
        e = new ZipEntry (MANIFEST_NAME);
        e.setTime (System.currentTimeMillis ());
        if (flag0) {
            crc32Manifest (e, manifest);
        }
        zos.putNextEntry (e);
        manifest.write (zos);
        zos.closeEntry ();
    }
    for (File file : entries) {
        addFile (zos, file);
    }
    zos.close ();
}


public List < String > getFileNames (Pattern regex, boolean matchOnlyFileName) throws IOException {
    if (file.isFile () && file.getName ().endsWith (".zip")) {
        ZipFile zipfile = new ZipFile (file);
        List < String > results = new ArrayList ();
        for (Enumeration < ? extends ZipEntry > entries = zipfile.entries (); entries.hasMoreElements ();) {
            ZipEntry zipEntry = entries.nextElement ();
            if (! matchOnlyFileName && regex.matcher (zipEntry.getName ()).find ()) {
                results.add (zipEntry.getName ());
            }
            else if (regex.matcher (new File (zipEntry.getName ()).getName ()).find ()) {
                results.add (zipEntry.getName ());
            }
        }
        return results;
    }
    else if (file.isDirectory ()) {
        return findFilesInDir (regex, matchOnlyFileName, file);
    }
    else {
        throw new IOException (file.getAbsolutePath () + " is not in a compatible form");
    }
}


-----Function Pair=215=-----==

protected synchronized void addFiles (String [] fileNames, IArchiveContainer container, IProgressMonitor monitor) throws CoreException {
    monitor.beginTask ("Adding files to the archive", 3000);
    File archiveDir = new File (ZipPlugin.getRootFolder (), new Path (toString ()).lastSegment ());
    try {
        monitor.subTask ("Extracting to temporary dir");
        create (archiveDir);
        monitor.worked (10000);
        monitor.subTask ("Copy files");
        File archivePath = new Path (archiveDir.getAbsolutePath ()).append (container.getPath ()).toFile ();
        for (String fileName : fileNames) {
            File file = new File (fileName);
            Util.copy (file, new File (archivePath.getAbsolutePath (), file.getName ()));
        }
        monitor.worked (1000);
        repackage (archiveDir);
        monitor.worked (1000);
    } catch (IOException e) {
        throw ZipPlugin.createException (e);
    } catch (TarException e) {
        throw ZipPlugin.createException (e);
    } finally {
        Util.delete (archiveDir);
        monitor.done ();
    }
    if (file instanceof TarFile) {
    }
}


protected void loadCustomIcons () throws Exception {
    InputStream inXML = null;
    try {
        inXML = ResourceManager.getInstance ().getInputStream (CUSTOM_ICONS_RESOURCEFILE);
    } catch (Throwable exception) {
        Debug.trace ("Resource " + CUSTOM_ICONS_RESOURCEFILE + " not defined. No custom icons available.");
        return;
    }
    Debug.trace ("Custom icons available.");
    URL url;
    ImageIcon img;
    IXMLElement icon;
    IXMLParser parser = new XMLParser ();
    IXMLElement data = parser.parse (inXML);
    Vector < IXMLElement > children = data.getChildrenNamed ("icon");
    int size = children.size ();
    for (int i = 0; i < size; i ++) {
        icon = children.get (i);
        url = InstallerFrame.class.getResource (icon.getAttribute ("res"));
        img = new ImageIcon (url);
        Debug.trace ("Icon with id found: " + icon.getAttribute ("id"));
        icons.put (icon.getAttribute ("id"), img);
    }
    children = data.getChildrenNamed ("sysicon");
    size = children.size ();
    for (int i = 0; i < size; i ++) {
        icon = children.get (i);
        url = InstallerFrame.class.getResource (icon.getAttribute ("res"));
        img = new ImageIcon (url);
        UIManager.put (icon.getAttribute ("id"), img);
    }
}


-----Function Pair=216=-----==

public static boolean isMonitorAvailable (String host) {
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") called");
    if (! TraceFileMonitor.isMonitoringOn ()) {
        return true;
    }
    String port = "";
    try {
        port = TFPropertyLoader.getInstance ().getPortWithColon ((String) host);
    } catch (Exception ex) {
        System.out.println ("MiscUtil.isMonitorAvailable(" + host + ") - Exception: " + ex.getMessage ());
        ex.printStackTrace ();
        return false;
    }
    System.out.println ("port = " + port);
    if (! MiscUtils.isHostAlive (host, port.substring (1))) {
        return false;
    }
    long timeout = 1000;
    final String hostF = "monp://" + host + port;
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") - host with port:" + hostF);
    TimeoutExecutor te = new TimeoutExecutor ();
    Function f = new Function () {
        public Object execute () {
            MonitorConsumer mc = null;
            try {
                mc = new MonitorConsumer (hostF);
                mc.close ();
                mc = null;
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): OK");
            } catch (Exception ex) {
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): Exception - " + ex.getMessage ());
                mc = null;
                return TimeoutExecutor.RESULT_AT_TIMEOUT;
            }
            System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): true");
            mc = null;
            return new Boolean (true);
        }
    }
    ;
    Object result = null;
    try {
        result = te.executeFunctionWithTimeout (f, timeout);
    } catch (FunctionTimeoutException ftex) {
        System.out.println ("MiscUtils.isMonitorAbailable() - ftex:" + ftex.getMessage ());
        ftex.printStackTrace ();
        return false;
    }
    if (result != TimeoutExecutor.RESULT_AT_TIMEOUT) {
        return true;
    }
    return false;
}


private boolean isWriteEnabledItem (Element nodeToCheck) throws OpenXML4JException {
    for (Iterator i = nodeToCheck.elementIterator (); i.hasNext ();) {
        Element element = (Element) i.next ();
        List listOfChild = element.elements ();
        if (listOfChild.size () == 0) {
            return checkElementIsPermStart (element);
        }
        else {
            if (checkElementIsPermStart (element)) {
                return true;
            }
            for (Iterator j = listOfChild.iterator (); j.hasNext ();) {
                Element child = (Element) j.next ();
                if (checkElementIsPermStart (child)) {
                    return true;
                }
                else {
                    checkElementIsPermStart (child);
                }
            }
        }
    }
    return false;
}


-----Function Pair=217=-----==

public final void startElement (final String ns, final String localName, final String qName, final Attributes atts) throws SAXException {
    try {
        closeElement ();
        writeIdent ();
        w.write ('<' + qName);
        if (atts != null && atts.getLength () > 0) {
            writeAttributes (atts);
        }
        if (optimizeEmptyElements) {
            openElement = true;
        }
        else {
            w.write (">\n");
        }
        ident += 2;
    } catch (IOException ex) {
        throw new SAXException (ex);
    }
}


public static ByteArrayOutputStream packStream (InputStream is, String name, long time) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    ZipOutputStream zip_out = new ZipOutputStream (baos);
    try {
        byte [] data = CIO.readStream (is);
        if (data != null) {
            ZipEntry entry = new ZipEntry (name);
            entry.setTime (time);
            try {
                zip_out.putNextEntry (entry);
                zip_out.write (data);
            } catch (Exception err) {
                err.printStackTrace ();
            }
        }
    } finally {
        try {
            zip_out.close ();
        } catch (IOException e) {
        }
    }
    return baos;
}


-----Function Pair=218=-----==

public Query newFacets (List < Facet > facet, boolean forMapping) {
    ArrayList < List < QueryField > > facetFields = new ArrayList < List < QueryField > > ();
    for (int k = 0; k < facet.size (); k ++) {
        Facet f = facet.get (k);
        String [] fields = f.getFields ();
        List < QueryField > qf = new ArrayList < QueryField > ();
        for (int j = 0; j < fields.length; j ++) {
            int i = 0;
            for (i = 0; i < data.size (); i ++) {
                if (fields [j].equals (data.get (i).getName ())) {
                    qf.add (data.get (i));
                    break;
                }
            }
        }
        facetFields.add (qf);
    }
    boolean [] valid = new boolean [points.length / 2];
    int count = 0;
    for (int i = 0; i < valid.length; i ++) {
        int sum = 0;
        for (int j = 0; j < facet.size (); j ++) {
            if (facet.get (j).isValid (facetFields.get (j), i)) {
                sum ++;
            }
        }
        valid [i] = sum == facet.size ();
        if (valid [i]) {
            count ++;
        }
    }
    UploadQuery uq = newFromValidMapping (valid, count);
    uq.facets.addAll (this.facets);
    uq.facets.addAll (facet);
    return uq;
}


private static void zipFiles (final File rootDir, final File folderToZip, final ZipOutputStream zipOutputStream) {
    final byte [] buf = new byte [1024];
    final String relativePath = folderToZip.toString ().substring (rootDir.toString ().length ());
    FileInputStream in;
    final File [] files = folderToZip.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        final String filename = files [i].getName ();
        if (files [i].isDirectory ()) {
            final String dirName = relativePath + File.separator + filename;
            LOG.debug ("adding dir [" + dirName + "]");
            zipFiles (rootDir, files [i], zipOutputStream);
        }
        else {
            String filePath = relativePath + File.separator + filename;
            if (filePath.charAt (0) == File.separatorChar) {
                filePath = filePath.substring (1);
            }
            LOG.debug ("adding file [" + filePath + "]");
            try {
                in = new FileInputStream (new File (folderToZip, filename));
                zipOutputStream.putNextEntry (new ZipEntry (filePath.replace (File.separatorChar, '/')));
                int len;
                while ((len = in.read (buf)) > 0) {
                    zipOutputStream.write (buf, 0, len);
                }
                zipOutputStream.closeEntry ();
                in.close ();
            } catch (IOException ioe) {
                final String message = "Error occured while zipping file " + filePath;
                LOG.error (message, ioe);
                throw new RuntimeException (message, ioe);
            }
        }
    }
}


-----Function Pair=219=-----==

public static void main (String [] args) throws IOException {
    new File (output).mkdir ();
    IntegratedDocPlaceMakerAndTimexIterator iterator = new IntegratedDocPlaceMakerAndTimexIterator (documentPath, timexesPath, placemakerPath);
    String fileId = "nyt_eng_200201";
    String filePath = output + "\\" + fileId + ".sentences.xml";
    FileWriter nowWriter = new FileWriter (filePath, false);
    int count = 0;
    while (iterator.hasNext ()) {
        count ++;
        IntegratedDocPlaceMakerAndTimexIterator.DocumentWithPlacesAndTimexes document = iterator.next ();
        if (! document.getD ().getDId ().substring (0, 14).toLowerCase ().equals (fileId)) {
            nowWriter.flush ();
            nowWriter.close ();
            FileInputStream fileInputStream = new FileInputStream (filePath);
            File toDelete = new File (filePath);
            String fileZipPath = output + "\\" + fileId + ".sentences.zip";
            ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (new File (fileZipPath)));
            zipOutputStream.putNextEntry (new ZipEntry (fileId + ".sentences.xml"));
            fileId = document.getD ().getDId ().substring (0, 14).toLowerCase ();
            filePath = output + "\\" + fileId + ".sentences.xml";
            StreamsUtils.inputStream2OutputStream (fileInputStream, zipOutputStream);
            nowWriter = new FileWriter (output + "\\" + fileId + ".sentences.xml", false);
            toDelete.delete ();
            toDelete.deleteOnExit ();
        }
        if (count > 100) {
            count = 0;
            nowWriter.flush ();
        }
        writeSentences (nowWriter, document);
    }
    nowWriter.flush ();
    nowWriter.close ();
    FileInputStream fileInputStream = new FileInputStream (filePath);
    File toDelete = new File (filePath);
    String fileZipPath = output + "\\" + fileId + ".sentences.zip";
    ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (new File (fileZipPath)));
    zipOutputStream.putNextEntry (new ZipEntry (fileId + ".sentences.xml"));
    StreamsUtils.inputStream2OutputStream (fileInputStream, zipOutputStream);
    toDelete.delete ();
    toDelete.deleteOnExit ();
}


public static List < File > untar (File file) {
    List < File > files = new ArrayList < File > ();
    byte [] data = new byte [2048];
    try {
        BufferedOutputStream dest = null;
        TarInputStream tar = new TarInputStream (new BufferedInputStream (new FileInputStream (file)));
        TarEntry entree;
        int count;
        String repName = "temp" + file.getName ();
        File newRep = new File (repName);
        newRep.mkdirs ();
        while ((entree = tar.getNextEntry ()) != null) {
            files.add (new File (repName + "/" + entree.getName ()));
            dest = new BufferedOutputStream (new FileOutputStream (repName + "/" + entree.getName ()), 2048);
            while ((count = tar.read (data, 0, 2048)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
        }
        tar.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return files;
}


-----Function Pair=220=-----==

public static Map < String, byte [] > unzipFiles (byte [] zipBytes) throws IOException {
    InputStream bais = new ByteArrayInputStream (zipBytes);
    ZipInputStream zin = new ZipInputStream (bais);
    ZipEntry ze;
    Map < String, byte [] > extractedFiles = new HashMap < String, byte [] > ();
    while ((ze = zin.getNextEntry ()) != null) {
        ByteArrayOutputStream toScan = new ByteArrayOutputStream ();
        byte [] buf = new byte [1024];
        int len;
        while ((len = zin.read (buf)) > 0) {
            toScan.write (buf, 0, len);
        }
        byte [] fileOut = toScan.toByteArray ();
        toScan.close ();
        extractedFiles.put (ze.getName (), fileOut);
    }
    zin.close ();
    bais.close ();
    return extractedFiles;
}


public boolean writeToFile (Document doc, String fileName, boolean saveAsLocalFile) {
    OutputStreamWriter outputStreamWriter = null;
    FileOutputStream fileStream = null;
    URL url = null;
    BufferedOutputStream outputStream = null;
    boolean saveRemoteFile = ! saveAsLocalFile;
    try {
        if (saveRemoteFile) {
            url = new URL (DefaultServerSettings.getFTPURL ());
            revision = Long.parseLong (DefaultServerSettings.getResponce ());
            URLConnection urlc = url.openConnection ();
            outputStream = new BufferedOutputStream (urlc.getOutputStream ());
        }
        else {
            fileStream = new FileOutputStream (fileName);
            outputStream = new BufferedOutputStream (fileStream);
        }
        XMLOutputter XMLOut = new XMLOutputter ();
        XMLOut.setFormat (XMLOut.getFormat ().setExpandEmptyElements (true));
        if (fileName.substring (fileName.lastIndexOf ("."), fileName.length ()).equalsIgnoreCase (".aopz")) {
            ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);
            ZipEntry entry = new ZipEntry ("pathways.aop");
            zipOutputStream.putNextEntry (entry);
            XMLOut.output (doc, zipOutputStream);
            zipOutputStream.close ();
            outputStream.close ();
            System.out.println ("entry.size:" + entry.getSize ());
            if (! saveRemoteFile) fileStream.close ();
        }
        else {
            if (saveRemoteFile) outputStreamWriter = new OutputStreamWriter (outputStream, "UTF-8");
            else outputStreamWriter = new OutputStreamWriter (fileStream, "UTF-8");
            XMLOut.output (doc, outputStreamWriter);
            outputStreamWriter.close ();
        }
        return true;
    } catch (UnsupportedEncodingException e1) {
        e1.printStackTrace ();
    } catch (FileNotFoundException e1) {
        e1.printStackTrace ();
    } catch (MalformedURLException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=221=-----==

public static File createTempFile (String filename, InputStream contentStream) throws IOException {
    if (StringUtil.isBlank (filename)) {
        throw new IOException ("invalid filename " + filename);
    }
    File file = null;
    FileWriter fileWriter = null;
    try {
        file = File.createTempFile (filename, null);
        fileWriter = new FileWriter (file);
        FileOutputStream out = new FileOutputStream (file);
        if (contentStream != null) {
            int bytesRead;
            byte [] buffer = new byte [STREAM_BUFFER_SIZE];
            while ((bytesRead = contentStream.read (buffer)) != - 1) {
                out.write (buffer, 0, bytesRead);
            }
        }
    } catch (IOException e) {
        throw e;
    } finally {
        if (fileWriter != null) {
            try {
                fileWriter.close ();
            } catch (IOException e1) {
            }
        }
    }
    return file;
}


public static < T > String join (String delimiter, UnaryFunction < String, T > formatter, Collection < T > array) {
    if (array.isEmpty ()) {
        return "<empty>";
    }
    int i = 0;
    StringBuffer res = new StringBuffer ();
    for (T item : array) {
        if (formatter != null) {
            res.append (formatter.eval (item));
        }
        else {
            res.append (item);
        }
        i ++;
        if (i < array.size ()) {
            res.append (delimiter);
        }
    }
    return res.toString ();
}


-----Function Pair=222=-----==

public void stripLine (final InputStream is, final OutputStream os, final String regex) throws IOException {
    BufferedReader reader = null;
    BufferedWriter writer = null;
    String line = null;
    try {
        reader = new BufferedReader (new InputStreamReader (is, Charset.defaultCharset ()));
        writer = new BufferedWriter (new OutputStreamWriter (os, Charset.defaultCharset ()));
        while ((line = reader.readLine ()) != null) {
            if (line.matches (regex)) {
                continue;
            }
            writer.write (line);
            writer.newLine ();
        }
    } finally {
        if (reader != null) {
            reader.close ();
        }
        if (writer != null) {
            writer.close ();
        }
    }
}


public static void extract (File zipfile, File destDir, FilenameFilter filter) throws IOException {
    FileInputStream fis = new FileInputStream (zipfile);
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    ZipEntry zipentry;
    while ((zipentry = zis.getNextEntry ()) != null) {
        log.debug ("Unzipping: " + zipentry.getName ());
        File f = new File (destDir, zipentry.getName ());
        if (! f.isDirectory ()) {
            if (filter.accept (f.getParentFile (), f.getName ())) {
                f.getParentFile ().mkdirs ();
                FileOutputStream fos = new FileOutputStream (f);
                log.debug ("outputting: " + f.getName ());
                copyInputStream (zis, fos);
            }
        }
    }
}


-----Function Pair=223=-----==

public void valueChanged (ListSelectionEvent e) {
    if (e.getValueIsAdjusting ()) return;
    ListSelectionModel lsm = (ListSelectionModel) e.getSource ();
    if (lsm.isSelectionEmpty ()) {
    }
    else {
        int selectedRow = lsm.getMinSelectionIndex ();
        int index = ((Integer) myTable.getValueAt (selectedRow, myTable.getTableHeader ().getColumnModel ().getColumnIndex (CONCEPT_ID))).intValue ();
        if (index > 0) {
            if (vog.isConceptVisible (index)) {
                mainFrame.graphElementClicked (index, true, null);
                mainFrame.getGraphLibraryAdapter ().zoomTo (index);
            }
        }
    }
}


public void run () {
    if (! checkboxListMedia.getSelectedItems ().iterator ().hasNext ()) return;
    JFileChooser fc = Core.UI.getFileChooser ();
    fc.setMultiSelectionEnabled (false);
    int prev_option = fc.getFileSelectionMode ();
    fc.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
    if (fc.showSaveDialog (Core.UI) != JFileChooser.APPROVE_OPTION) {
        fc.setFileSelectionMode (prev_option);
        return;
    }
    File dest = fc.getSelectedFile ();
    fc.setFileSelectionMode (prev_option);
    Vector < Book > vector = new Vector < Book > ();
    for (Book book : checkboxListMedia.getSelectedItems ()) vector.add (book);
    Thread packer = new Packer (vector, dest);
    packer.start ();
}


-----Function Pair=224=-----==

private void idTargetSeqInGraph (boolean hideOtherTARGETSEQ) {
    ConceptClass cc = graph.getONDEXGraphData (s).getConceptClass (s, "TARGETSEQ");
    ONDEXView < AbstractConcept > concepts = graph.getConceptsOfConceptClass (s, cc);
    while (concepts.hasNext ()) {
        AbstractConcept concept = concepts.next ();
        AbstractONDEXIterator < ConceptAccession > accs = concept.getConceptAccessions (s);
        while (accs.hasNext ()) {
            String acc = accs.next ().getAccession (s).toUpperCase ();
            if (targetSeqs.containsKey (acc)) {
                targetSeqs.put (acc, concept.getId (s));
            }
            else if (hideOtherTARGETSEQ) {
                IntIterator rels = vog.getIncomingRelations (concept).iterator ();
                while (rels.hasNext ()) {
                    vog.setRelationVisible (rels.next (), false);
                }
                rels = vog.getOutgoingRelations (concept).iterator ();
                while (rels.hasNext ()) {
                    vog.setRelationVisible (rels.next (), false);
                }
                vog.setConceptVisible (concept.getId (s), false);
            }
        }
    }
    concepts.close ();
}


public void invoke (InputStream in) throws Exception {
    long size = 0;
    CRC32 crc = new CRC32 ();
    byte [] buf = new byte [4096];
    while (true) {
        int len = in.read (buf, 0, 4096);
        if (- 1 < len) {
            crc.update (buf, 0, len);
            size += len;
        }
        else {
            break;
        }
    }
    entry.setSize (size);
    entry.setCrc (crc.getValue ());
}


-----Function Pair=225=-----==

public static UserZipFile createUser (String username, String password, String filename, boolean isAdmin, boolean isExpired) throws Exception {
    MakeUserZipFileTool maker = new MakeUserZipFileTool ();
    maker.setName (username);
    maker.setPassphrase (password);
    maker.setSaveFile (new File (filename));
    if (isExpired) {
        maker.setValidDays (- 1);
    }
    else {
        maker.setValidDays (1);
    }
    UserZipFile zip = (UserZipFile) maker.makeCertificate ();
    if (isAdmin) {
        zip.setFlags (SecurityUtil.getAdmin ().getFlags ());
    }
    return zip;
}


public List < String > getMediaTags (String additionalTags) throws IOException {
    List < MediaFacade > list = getMediaList ();
    List < String > set = new LinkedList < String > ();
    set.addAll (loadTags (list));
    if (additionalTags != null) {
        String [] splts = additionalTags.split (",");
        for (String s : splts) {
            s = s.trim ();
            if (s.length () > 0 && ! set.contains (s)) set.add (s);
        }
    }
    Collections.sort (set);
    return set;
}


-----Function Pair=226=-----==

private static File getTGZFile () throws Exception {
    File [] tarGzipFiles = new File [2];
    File tarGzipFile = null;
    FileOutputStream fos = null;
    GZIPOutputStream gos = null;
    TarOutputStream zos = null;
    try {
        for (int i = 0; i < tarGzipFiles.length; i ++) {
            tarGzipFiles [i] = TempFileUtil.createTemporaryFile (".txt");
            Utils.makeTempFile (Utils.makeRandomData ((int) (100 * Math.random ())), tarGzipFiles [i]);
        }
        tarGzipFile = TempFileUtil.createTempFileWithName ("tgzTest.tgz");
        fos = new FileOutputStream (tarGzipFile);
        gos = new GZIPOutputStream (fos);
        zos = new TarOutputStream (gos);
        for (File file : tarGzipFiles) {
            TarEntry ze = new TarEntry (file.getName ());
            byte [] bytes = IOUtil.getBytes (file);
            ze.setSize (bytes.length);
            zos.putNextEntry (ze);
            zos.write (bytes);
            zos.closeEntry ();
        }
    } finally {
        IOUtil.safeClose (zos);
        IOUtil.safeClose (gos);
        IOUtil.safeClose (fos);
        for (File tmp : tarGzipFiles) {
            IOUtil.safeDelete (tmp);
        }
    }
    return tarGzipFile;
}


public static Map getMap (String input) throws IOException {
    ArrayList < MapEvent > data = new ArrayList < MapEvent > ();
    ZipFile t = new ZipFile (input);
    Enumeration test = t.entries ();
    ObjectInputStream oin = null;
    Map map = null;
    while (test.hasMoreElements ()) {
        ZipEntry temp = (ZipEntry) test.nextElement ();
        InputStream is = t.getInputStream (temp);
        if (temp.getName ().equals ("mapfile.cnf")) {
            LinkedList < String > map_data = new LinkedList < String > ();
            BufferedReader br = new BufferedReader (new InputStreamReader (is));
            String line = "";
            while (true) {
                line = br.readLine ();
                if (line == null) break;
                if (! line.startsWith ("#")) {
                    map_data.add (line);
                }
            }
            map = Parser.parseMap (map_data);
        }
        else {
            oin = new ObjectInputStream (new BufferedInputStream (is));
            try {
                Object o = oin.readObject ();
                if (o instanceof MapEvent) {
                    MapEvent e = (MapEvent) o;
                    data.add (e);
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace ();
            }
        }
    }
    if (oin != null) oin.close ();
    map.setEventData (data);
    return map;
}


-----Function Pair=227=-----=1=

private void addZipEntry (final int bufsize, final ZipOutputStream zos, final byte [] input_buffer, final File file) throws IOException {
    log.debug ("Adding zip entry for file {}", file);
    if (file.exists () && file.isFile ()) {
        final ZipEntry zip_entry = new ZipEntry (file.getName ());
        if (this.zipEntries.contains (file.getName ())) {
            log.info ("Skipping duplicate zip entry {}", file.getName ());
            return;
        }
        else {
            this.zipEntries.add (file.getName ());
        }
        zos.putNextEntry (zip_entry);
        final FileInputStream in = new FileInputStream (file);
        final BufferedInputStream source = new BufferedInputStream (in, bufsize);
        int len = 0;
        while ((len = source.read (input_buffer, 0, bufsize)) != - 1) {
            zos.write (input_buffer, 0, len);
        }
        zos.flush ();
        source.close ();
        zos.closeEntry ();
    }
    else {
        log.warn ("Skipping nonexistant file or directory {}", file);
    }
}


private void addVerifier (ZipOutputStream zos, File verifierBinary) throws IOException, ClientBinaryNotFoundException {
    InputStream in = new FileInputStream (verifierBinary);
    if (in == null) {
        throw new ClientBinaryNotFoundException ();
    }
    ZipEntry entry = new ZipEntry ("verifiers/" + verifierBinary.getName ());
    zos.putNextEntry (entry);
    byte [] buf = new byte [1024];
    int data;
    while ((data = in.read (buf)) > - 1) {
        zos.write (buf, 0, data);
    }
    zos.closeEntry ();
    in.close ();
}


-----Function Pair=228=-----==

public static File zipFolder (File inFolder, File outFile) {
    try {
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (outFile)));
        BufferedInputStream in = null;
        byte [] data = new byte [4024];
        String files [] = inFolder.list ();
        for (int i = 0; i < files.length; i ++) {
            in = new BufferedInputStream (new FileInputStream (inFolder.getPath () + "/" + files [i]), 4024);
            out.putNextEntry (new ZipEntry (files [i]));
            int count;
            while ((count = in.read (data, 0, 4024)) != - 1) {
                out.write (data, 0, count);
            }
            out.closeEntry ();
        }
        cleanUp (out);
        cleanUp (in);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return new File (outFile + ".zip");
}


public List getUserRoles () {
    List roles = new ArrayList ();
    if (Util.isItemInList (user.getId (), Application.getInstance ().getApplicationAdmins ())) roles.add ("APP_ADMINISTRATOR");
    if (getProject ().validateAdmin (user.getId ())) roles.add ("PROJ_ADMINISTRATOR");
    if (getProject ().validateUser (user.getId ())) roles.add ("PROJ_USER");
    if (getProject ().validateReadOnlyUser (user.getId ())) roles.add ("READ_ONLY");
    Map membermap = this.project.getRoleMembers ();
    if (membermap != null) {
        for (Iterator iter = Application.getInstance ().getRoleList ().iterator (); iter.hasNext ();) {
            String role = (String) iter.next ();
            String members = (String) membermap.get (role);
            if (members != null) {
                String [] memberarr = members.split (",");
                for (int i = 0; i < memberarr.length; i ++) {
                    if (this.user.getId ().equals (memberarr [i])) {
                        roles.add (role);
                        break;
                    }
                }
            }
        }
    }
    return roles;
}


-----Function Pair=229=-----=1=

public static boolean archiveFolder (String folderPath, ZipOutputStream zos, String ignoredPathPrefix) {
    try {
        File zipDir = new File (folderPath);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                archiveFolder (filePath, zos, ignoredPathPrefix);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String entryPath = f.getPath ();
            if (entryPath.startsWith (ignoredPathPrefix)) {
                entryPath = entryPath.substring (ignoredPathPrefix.length () + 1);
            }
            ZipEntry anEntry = new ZipEntry (entryPath.replace ('\\', '/'));
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return true;
}


private static void fileToZip (File argFile, File argZipFile) throws FileNotFoundException, IOException {
    FileOutputStream fileOutputStream = null;
    ZipOutputStream zipOutputStream = null;
    try {
        fileOutputStream = new FileOutputStream (argZipFile);
        zipOutputStream = new ZipOutputStream (new BufferedOutputStream (fileOutputStream));
        zipOutputStream.setMethod (ZipOutputStream.DEFLATED);
        ZipEntry zipEntry = new ZipEntry (argFile.getName ());
        zipOutputStream.putNextEntry (zipEntry);
        FileInputStream fileInputStream = new FileInputStream (argFile);
        BufferedInputStream bufferedInputStream = new BufferedInputStream (fileInputStream, BUFFER);
        byte data [] = new byte [BUFFER];
        int count;
        while ((count = bufferedInputStream.read (data, 0, BUFFER)) != - 1) {
            zipOutputStream.write (data, 0, count);
        }
        bufferedInputStream.close ();
    } finally {
        zipOutputStream.close ();
        fileOutputStream.close ();
    }
}


-----Function Pair=230=-----==

public void actionPerformed (ActionEvent ae) {
    if (treeMedia.CheckBoxRenderer.getCheckedPaths ().length < 1) return;
    JPanel panel = new JPanel ();
    panel.setSize (250, 150);
    panel.setLayout (new GridLayout (2, 1));
    JLabel lab = new JLabel ("<html><body>Delete selected file/folders?<br/><i>(This cannot be undone)</i></body></html>");
    lab.setBorder (BorderFactory.createEmptyBorder (10, 10, 10, 10));
    lab.setFont (Core.Resources.Font);
    panel.add (lab);
    JPanel bottom = new JPanel ();
    bottom.setLayout (new GridLayout (1, 2));
    JButton canc = new JButton ("Cancel");
    canc.setFont (Core.Resources.Font);
    canc.setMnemonic ('C');
    canc.setFocusable (false);
    canc.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent ae) {
            DouzDialog window = (DouzDialog) ((JComponent) ae.getSource ()).getRootPane ().getParent ();
            window.dispose ();
        }
    }
    );
    JButton ok = new JButton ("Ok");
    ok.setFont (Core.Resources.Font);
    ok.setMnemonic ('O');
    ok.setFocusable (false);
    ok.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent ae) {
            try {
                TreePath [] paths = treeMedia.CheckBoxRenderer.getCheckedPaths ();
                DataFile root_ds = Core.Repository.child (tokenBook.getID ());
                for (TreePath path : paths) try {
                    Object os [] = path.getPath ();
                    DataFile ds = root_ds;
                    for (int k = 1; k < os.length; k ++) if (os [k].toString ().startsWith ("/")) ds = ds.child (os [k].toString ().substring (1));
                    else ds = ds.child (os [k].toString ());
                    ds.delete ();
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            } catch (Exception e) {
                Core.Logger.log (e.getMessage (), Level.ERROR);
            }
            displayUI ();
            DouzDialog window = (DouzDialog) ((JComponent) ae.getSource ()).getRootPane ().getParent ();
            window.dispose ();
        }
    }
    );
    bottom.add (ok);
    bottom.add (canc);
    bottom.setBorder (BorderFactory.createEmptyBorder (15, 15, 15, 15));
    panel.add (bottom);
    try {
        Core.UI.Desktop.showDialog (panel, Core.Resources.Icons.get ("JDesktop/Explorer/Book/Media/Delete"), "Delete");
    } catch (PropertyVetoException pve) {
        Core.Logger.log (pve.getMessage (), Level.WARNING);
    }
}


private static void addZipEntry (ZipOutputStream zipOut, File zipIn, File root) throws IOException {
    BufferedInputStream inStream = new BufferedInputStream (new FileInputStream (zipIn));
    byte buffer [] = new byte [1024];
    int length;
    String zipEntryName = replaceSeparator (zipIn.getPath ().substring (root.getPath ().length () + 1));
    zipOut.putNextEntry (new ZipEntry (zipEntryName));
    try {
        length = inStream.read (buffer);
        while (length != - 1) {
            zipOut.write (buffer, 0, length);
            length = inStream.read (buffer);
        }
    } finally {
        zipOut.closeEntry ();
        inStream.close ();
    }
}


-----Function Pair=231=-----==

public void run () {
    try {
        JFileChooser fc = Core.UI.getFileChooser ();
        fc.setMultiSelectionEnabled (false);
        int prev_option = fc.getFileSelectionMode ();
        fc.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
        if (fc.showOpenDialog (Core.UI) != JFileChooser.APPROVE_OPTION) {
            fc.setMultiSelectionEnabled (false);
            fc.setFileSelectionMode (prev_option);
            return;
        }
        File dl_folder = fc.getSelectedFile ();
        Set < DataFile > dss = new TreeSet < DataFile > ();
        {
            TreePath [] paths = treeMedia.CheckBoxRenderer.getCheckedPaths ();
            DataFile root_ds = Core.Repository.child (tokenBook.getID ());
            for (TreePath path : paths) try {
                StringBuilder sb = new StringBuilder ();
                Object [] nodes = path.getPath ();
                for (int i = 0; i < nodes.length; i ++) {
                    sb.append (nodes [i].toString ());
                }
                DataFile ds = root_ds.child (sb.toString ());
                dss.add (ds);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        Thread downloader = new Downloader (dl_folder, dss);
        downloader.start ();
        try {
            while (downloader.isAlive ()) sleep (10);
        } catch (Exception e) {
        }
        fc.setMultiSelectionEnabled (false);
        fc.setFileSelectionMode (prev_option);
        displayUI ();
    } catch (Exception e) {
        Core.Logger.log (e.getMessage (), Level.ERROR);
        e.printStackTrace ();
    }
}


private void clearWorld () {
    CombatSchedule.resume ();
    tqueue.clear ();
    clearDirty ();
    UsecodeScript.clear ();
    int cnt = maps.size ();
    for (int i = 0; i < cnt; ++ i) maps.elementAt (i).clear ();
    setMap (0);
    MonsterActor.deleteAll ();
    mainActor = null;
    cameraActor = null;
    numNpcs1 = 0;
    theftCx = theftCy = - 1;
    combat = false;
    npcs.setSize (0);
    if (bodies != null) bodies.setSize (0);
    movingBarge = null;
    specialLight = 0;
    ambientLight = false;
    effects.removeAllEffects ();
}


-----Function Pair=232=-----==

public void actionPerformed (ActionEvent ae) {
    for (Book key : checkboxListMedia.getSelectedItems ()) {
        try {
            Core.Repository.child (key.getID ()).delete ();
        } catch (RepositoryException dse) {
            Core.Logger.log (dse.getMessage (), Level.ERROR);
            dse.printStackTrace ();
        } catch (DataBaseException dbe) {
            Core.Logger.log (dbe.getMessage (), Level.ERROR);
            dbe.printStackTrace ();
        }
    }
    validateUI (new DouzEvent (DouzEvent.Type.DATABASE_REFRESH, null));
    DouzDialog window = (DouzDialog) ((JComponent) ae.getSource ()).getRootPane ().getParent ();
    window.dispose ();
}


private byte [] remTunerFromList (HTTPurl urlData) throws Exception {
    int tunerIndex = - 1;
    try {
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount ()) {
                devList.remDevice (tunerIndex);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=233=-----==

public static File [] extractFiles (File directory) {
    File [] files = null;
    String [] fileNames;
    if (directory.isDirectory ()) {
        fileNames = directory.list ();
        int num = fileNames.length;
        ArrayList < File > al = new ArrayList < File > ();
        try {
            String path = directory.getCanonicalPath ();
            Pattern pat = Pattern.compile ("^\\w+.*");
            Matcher mat;
            for (int i = 0; i < num; i ++) {
                mat = pat.matcher (fileNames [i]);
                if (mat.matches ()) al.add (new File (path, fileNames [i]));
            }
            if (al.size () != 0) {
                files = new File [al.size ()];
                al.toArray (files);
            }
        } catch (IOException e) {
            System.out.println ("Problem extractFiles() " + directory);
            e.printStackTrace ();
            return null;
        }
    }
    if (files == null) {
        files = new File [1];
        files [0] = directory;
    }
    Arrays.sort (files);
    return files;
}


public static void unZipFiles (String zipFileName, String descFileName) {
    if (! descFileName.endsWith (File.separator)) {
        descFileName = descFileName + File.separator;
    }
    try {
        ZipFile zipFile = new ZipFile (zipFileName);
        ZipEntry entry = null;
        String entryName = null;
        String descFileDir = null;
        byte [] buf = new byte [4096];
        int readByte = 0;
        Enumeration enums = zipFile.entries ();
        while (enums.hasMoreElements ()) {
            entry = (ZipEntry) enums.nextElement ();
            entryName = entry.getName ();
            descFileDir = descFileName + entryName;
            if (entry.isDirectory ()) {
                new File (descFileDir).mkdirs ();
                continue;
            }
            else {
                new File (descFileDir).getParentFile ().mkdirs ();
            }
            File file = new File (descFileDir);
            FileOutputStream fouts = new FileOutputStream (file);
            InputStream ins = zipFile.getInputStream (entry);
            while ((readByte = ins.read (buf)) != - 1) {
                fouts.write (buf, 0, readByte);
            }
            fouts.close ();
            ins.close ();
        }
        System.out.println ("文件解压成功!");
    } catch (Exception e) {
        System.out.println ("文件解压失败：" + e.getMessage ());
    }
}


-----Function Pair=234=-----==

public static void batchSave (List < ExperimentResult > v, Tasks task) throws SQLException {
    if (v.isEmpty ()) {
        return;
    }
    if (v.size () > 10000) {
        boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
        try {
            DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
            ArrayList < ExperimentResult > res = new ArrayList < ExperimentResult > ();
            int jobsCreated = 0;
            for (ExperimentResult ex : v) {
                res.add (ex);
                if (res.size () == 10000) {
                    batchSave (res);
                    jobsCreated += 10000;
                    if (task != null) {
                        task.setTaskProgress (jobsCreated / (float) v.size ());
                    }
                    res.clear ();
                }
            }
            if (! res.isEmpty ()) {
                batchSave (res);
            }
            if (task != null) {
                task.setTaskProgress (0.f);
            }
        } catch (SQLException ex) {
            if (autoCommit) {
                DatabaseConnector.getInstance ().getConn ().rollback ();
            }
            throw ex;
        } catch (Error ex) {
            if (autoCommit) {
                DatabaseConnector.getInstance ().getConn ().rollback ();
            }
            throw ex;
        } catch (Throwable ex) {
            if (autoCommit) {
                DatabaseConnector.getInstance ().getConn ().rollback ();
            }
        } finally {
            DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
        }
        return;
    }
    boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        String query = getInsertQuery (v.size ());
        PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (query, PreparedStatement.RETURN_GENERATED_KEYS);
        int curCount = 1;
        curSt = st;
        for (ExperimentResult r : v) {
            st.setInt (curCount ++, r.getSolverConfigId ());
            st.setInt (curCount ++, r.getExperimentId ());
            st.setInt (curCount ++, r.getInstanceId ());
            st.setInt (curCount ++, r.getRun ());
            st.setInt (curCount ++, r.getStatus ().getStatusCode ());
            st.setInt (curCount ++, r.getSeed ());
            st.setTimestamp (curCount ++, r.getStartTime ());
            st.setInt (curCount ++, r.getPriority ());
            st.setFloat (curCount ++, r.getResultTime ());
            st.setInt (curCount ++, r.getComputeQueue ());
            st.setInt (curCount ++, r.getResultCode ().getResultCode ());
            st.setInt (curCount ++, r.getCPUTimeLimit ());
            st.setInt (curCount ++, r.getMemoryLimit ());
            st.setInt (curCount ++, r.getWallClockTimeLimit ());
            st.setInt (curCount ++, r.getStackSizeLimit ());
        }
        st.executeUpdate ();
        ResultSet rs = st.getGeneratedKeys ();
        int i = 0;
        while (rs.next ()) {
            v.get (i).setSaved ();
            v.get (i).setId (rs.getInt (1));
            i ++;
        }
        rs.close ();
        st.close ();
        query = getInsertOutputsQuery (v.size ());
        st = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
        curSt = st;
        curCount = 1;
        for (ExperimentResult r : v) {
            st.setInt (curCount ++, r.getId ());
            if (r instanceof ExperimentResultEx) {
                ExperimentResultEx rx = (ExperimentResultEx) r;
                st.setBytes (curCount ++, rx.getSolverOutput ());
                st.setBytes (curCount ++, rx.getLauncherOutput ());
                st.setBytes (curCount ++, rx.getWatcherOutput ());
                st.setBytes (curCount ++, rx.getVerifierOutput ());
            }
            else {
                st.setNull (curCount ++, java.sql.Types.BLOB);
                st.setNull (curCount ++, java.sql.Types.BLOB);
                st.setNull (curCount ++, java.sql.Types.BLOB);
                st.setNull (curCount ++, java.sql.Types.BLOB);
            }
            st.setNull (curCount ++, java.sql.Types.INTEGER);
            st.setNull (curCount ++, java.sql.Types.INTEGER);
            st.setNull (curCount ++, java.sql.Types.INTEGER);
        }
        st.executeUpdate ();
        st.close ();
    } catch (SQLException ex) {
        if (autoCommit) {
            DatabaseConnector.getInstance ().getConn ().rollback ();
        }
        throw ex;
    } catch (Error ex) {
        if (autoCommit) {
            DatabaseConnector.getInstance ().getConn ().rollback ();
        }
        throw ex;
    } catch (Throwable ex) {
        if (autoCommit) {
            DatabaseConnector.getInstance ().getConn ().rollback ();
        }
    } finally {
        curSt = null;
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
    }
}


public static void addFilesToZip (File zipFile, File [] files, String [] fileNames) throws IOException {
    File tempFile = new File (zipFile.getAbsoluteFile () + ".temp");
    if (! zipFile.renameTo (tempFile)) {
        throw new RuntimeException ("could not rename");
    }
    byte [] buf = new byte [1024];
    ZipInputStream zin = new ZipInputStream (new FileInputStream (tempFile));
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    ZipEntry entry = zin.getNextEntry ();
    while (entry != null) {
        String name = entry.getName ();
        boolean notInFiles = true;
        for (String f : fileNames) {
            if (f.equals (name)) {
                notInFiles = false;
                break;
            }
        }
        if (notInFiles) {
            out.putNextEntry (new ZipEntry (name));
            int len;
            while ((len = zin.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
        }
        entry = zin.getNextEntry ();
    }
    zin.close ();
    for (int i = 0; i < files.length; i ++) {
        InputStream in = new FileInputStream (files [i]);
        out.putNextEntry (new ZipEntry (fileNames [i]));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    tempFile.delete ();
}


-----Function Pair=235=-----==

public static void zipFiles (List < File > files, File archive, SubMonitor progress) throws IOException, SarosCancellationException {
    try {
        if (files.isEmpty ()) {
            log.warn ("The list with files to zip was empty.");
            return;
        }
        progress.beginTask ("Creating Archive", files.size ());
        OutputStream outputStream = new BufferedOutputStream (new FileOutputStream (archive));
        ZipOutputStream zipStream = new ZipOutputStream (outputStream);
        int filesZipped = 0;
        for (File file : files) {
            try {
                zipSingleFile (new WrappedFile (file), file.getName (), zipStream, progress.newChild (1));
                ++ filesZipped;
            } catch (SarosCancellationException e) {
                cleanup (archive);
                throw e;
            } catch (IllegalArgumentException e) {
                log.warn (e.getMessage ());
                continue;
            } catch (IOException e) {
                cleanup (archive);
                throw e;
            }
        }
        zipStream.close ();
        if (filesZipped == 0) {
            log.warn ("No files could be added to the archive.");
        }
    } finally {
        progress.done ();
    }
}


public void removeInactiveDocumentsAtSearchForm (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws ServletException {
    ListDmsDocumentForm searchForm = (ListDmsDocumentForm) form;
    ArrayList clipboardList = (ArrayList) request.getSession ().getAttribute (CLIPBOARD_SESSION_ATTR_NAME);
    String [] documentIDs = searchForm.getBasicSelectedID ();
    ArrayList tempDocumentIDs = new ArrayList ();
    if (! Utility.isEmpty (documentIDs)) {
        for (int i = 0; i < documentIDs.length; i ++) {
            Integer documentID = TextUtility.parseIntegerObj (documentIDs [i]);
            if (clipboardList.contains (documentID)) {
                tempDocumentIDs.add (documentID);
            }
            else {
                addMessage (request, "");
            }
        }
    }
    String [] filtretedDocumentIDs = null;
    tempDocumentIDs.toArray (filtretedDocumentIDs);
    searchForm.setBasicSelectedID (filtretedDocumentIDs);
}


-----Function Pair=236=-----==

private void upload (File up, DataFile path) throws IOException, Exception {
    DataFile dst = path.child (up.getName ());
    label_file_current = up.getName ();
    if (up.isDirectory ()) {
        progress_overall_current ++;
        dst.mkdirs ();
        for (File file : up.listFiles ()) upload (file, dst);
    }
    else {
        progress_overall_current ++;
        dst.getParent ().mkdirs ();
        dst.touch ();
        OutputStream out = dst.getOutputStream ();
        InputStream in = new FileInputStream (up);
        byte [] buff = new byte [0x800];
        int read;
        progress_file_current = 0;
        progress_file_max = up.length () + 1;
        while ((read = in.read (buff)) != - 1) {
            out.write (buff, 0, read);
            progress_file_current += read;
            if (stopped) throw new Exception ("Thread stopped by user input.");
        }
        in.close ();
        out.close ();
    }
}


private static void compress (String path, String parent, ZipOutputStream zip) throws IOException {
    File [] f = new File (path).listFiles ();
    byte [] buffer = new byte [4096];
    int bytes_read;
    for (int i = 0; i < f.length; i ++) {
        if (f [i].isFile ()) {
            FileInputStream in = new FileInputStream (f [i]);
            ZipEntry entry = new ZipEntry (parent + f [i].getName ());
            zip.putNextEntry (entry);
            while ((bytes_read = in.read (buffer)) != - 1) zip.write (buffer, 0, bytes_read);
            in.close ();
        }
        else if (f [i].isDirectory ()) {
            compress (f [i].getAbsolutePath (), parent + f [i].getName () + File.separator, zip);
        }
    }
}


-----Function Pair=237=-----==

public void closeEntry () throws IOException {
    def.finish ();
    while (! def.finished ()) deflate ();
    long uncompressed_size = def.getTotalIn ();
    long compressed_size = def.getTotalOut ();
    long ecrc = (crc.getValue ());
    bytes_written += compressed_size;
    if (outSeekable || current.getCrc () == - 1 || current.getCompressedSize () == - 1 || current.getSize () == - 1) {
        current.setCrc (ecrc);
        current.compressedSize = compressed_size;
        current.setSize (uncompressed_size);
    }
    else {
        if (current.getCrc () != ecrc || current.getCompressedSize () != compressed_size || current.getSize () != uncompressed_size) throw new ZipException ("zip entry field incorrect");
    }
    if (outSeekable) {
        long here = bytes_written;
        ((SeekableOutputStream) out).seek (currentStart + 14);
        put4 (ecrc);
        put4 (compressed_size);
        put4 (uncompressed_size);
        ((SeekableOutputStream) out).seek (here);
    }
    else bytes_written += current.writeExtHeader (out);
    crc.reset ();
    def.reset ();
    current.next = chain;
    chain = current;
    current = null;
}


void createMixer () {
    if (mixerControls != null) {
        return;
    }
    try {
        mixerControls = new MixerControls ("Mixer");
        MixerControlsFactory.createBusses (mixerControls, 2, 1);
        MixerControlsFactory.createBusStrips (mixerControls);
        audioServer = FrinikaAudioSystem.getAudioServer ();
        List < String > list = audioServer.getAvailableOutputNames ();
        mixer = new AudioMixer (mixerControls, audioServer);
        audioClient = new ProjectAudioClient ();
        FrinikaAudioSystem.installClient (audioClient);
        String outDev = FrinikaAudioSystem.configureServerOutput ();
        if (outDev != null) {
            outputProcess = new AudioInjector (audioServer.openAudioOutput (outDev, "output"));
            System.out.println ("Using " + outDev + " as audio out device");
            mixer.getMainBus ().setOutputProcess (outputProcess);
        }
        else {
            message (" No output devices found ");
        }
    } catch (Exception e) {
        e.printStackTrace ();
        System.err.println (" \n Sorry but I do not want to go on without an audio output device. \n Bye bye . . .  ");
        System.exit (1);
    }
}


-----Function Pair=238=-----==

public HashMap < String, Integer > fetchChromosomesAndLastBase () throws IOException {
    HashMap < String, DataRange > map = new HashMap < String, DataRange > ();
    for (String chrom : chromStrandRegions.keySet ()) {
        DataRange [] dr = chromStrandRegions.get (chrom);
        int lastFirstBase = 0;
        DataRange lastDataRange = null;
        for (DataRange d : dr) {
            if (d.endingBP > lastFirstBase) {
                lastFirstBase = d.endingBP;
                lastDataRange = d;
            }
        }
        map.put (chrom, lastDataRange);
    }
    ZipFile zf = new ZipFile (zipFile);
    HashMap < String, Integer > chromBase = new HashMap < String, Integer > ();
    for (String chrom : map.keySet ()) {
        DataRange dr = map.get (chrom);
        ZipEntry ze = dr.zipEntry;
        SliceInfo si = new SliceInfo (ze.getName ());
        DataInputStream dis = new DataInputStream (new BufferedInputStream (zf.getInputStream (ze)));
        String extension = si.getBinaryType ();
        int lastBase = - 1;
        if (USeqUtilities.POSITION.matcher (extension).matches ()) lastBase = new PositionData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_SCORE.matcher (extension).matches ()) lastBase = new PositionScoreData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_TEXT.matcher (extension).matches ()) lastBase = new PositionTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_SCORE_TEXT.matcher (extension).matches ()) lastBase = new PositionScoreTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION.matcher (extension).matches ()) lastBase = new RegionData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_SCORE.matcher (extension).matches ()) lastBase = new RegionScoreData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_TEXT.matcher (extension).matches ()) lastBase = new RegionTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_SCORE_TEXT.matcher (extension).matches ()) lastBase = new RegionScoreTextData (dis, si).fetchLastBase ();
        else throw new IOException ("\nFailed to recognize the binary file extension! " + ze.getName ());
        chromBase.put (chrom, new Integer (lastBase));
    }
    return chromBase;
}


public boolean addZipFile (File f, MD5ChecksumProperties p, StringBuilder sb, ZipOutputStream zos, Predicate < String > processFile) throws IOException {
    sb.append ("Adding " + f + ":\n");
    ZipFile zf = new ZipFile (f);
    Enumeration < ? extends ZipEntry > entries = zf.entries ();
    boolean result = true;
    while (entries.hasMoreElements ()) {
        ZipEntry ze = entries.nextElement ();
        if (! ze.isDirectory ()) {
            String key = ze.getName ().replace ('\\', '/');
            if (processFile.contains (key)) {
                if (zos != null) {
                    if (p.containsKey (key)) {
                        sb.append ("Warning: skipped " + key + ", already exists\n");
                    }
                    else {
                        zos.putNextEntry (new ZipEntry (key));
                        if (! p.addMD5 (key, zf.getInputStream (ze), zos)) {
                            result = false;
                            sb.append ("Warning: a different " + key + " already exists\n");
                        }
                    }
                }
                else {
                    if (! p.addMD5 (key, zf.getInputStream (ze), zos)) {
                        result = false;
                        sb.append ("Warning: a different " + key + " already exists\n");
                    }
                }
            }
        }
    }
    return result;
}


-----Function Pair=239=-----==

public HashMap < String, Integer > fetchChromosomesAndLastBase () throws IOException {
    HashMap < String, DataRange > map = new HashMap < String, DataRange > ();
    for (String chrom : chromStrandRegions.keySet ()) {
        DataRange [] dr = chromStrandRegions.get (chrom);
        int lastFirstBase = 0;
        DataRange lastDataRange = null;
        for (DataRange d : dr) {
            if (d.endingBP > lastFirstBase) {
                lastFirstBase = d.endingBP;
                lastDataRange = d;
            }
        }
        map.put (chrom, lastDataRange);
    }
    ZipFile zf = new ZipFile (zipFile);
    HashMap < String, Integer > chromBase = new HashMap < String, Integer > ();
    for (String chrom : map.keySet ()) {
        DataRange dr = map.get (chrom);
        ZipEntry ze = dr.zipEntry;
        SliceInfo si = new SliceInfo (ze.getName ());
        DataInputStream dis = new DataInputStream (new BufferedInputStream (zf.getInputStream (ze)));
        String extension = si.getBinaryType ();
        int lastBase = - 1;
        if (USeqUtilities.POSITION.matcher (extension).matches ()) lastBase = new PositionData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_SCORE.matcher (extension).matches ()) lastBase = new PositionScoreData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_TEXT.matcher (extension).matches ()) lastBase = new PositionTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.POSITION_SCORE_TEXT.matcher (extension).matches ()) lastBase = new PositionScoreTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION.matcher (extension).matches ()) lastBase = new RegionData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_SCORE.matcher (extension).matches ()) lastBase = new RegionScoreData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_TEXT.matcher (extension).matches ()) lastBase = new RegionTextData (dis, si).fetchLastBase ();
        else if (USeqUtilities.REGION_SCORE_TEXT.matcher (extension).matches ()) lastBase = new RegionScoreTextData (dis, si).fetchLastBase ();
        else throw new IOException ("\nFailed to recognize the binary file extension! " + ze.getName ());
        chromBase.put (chrom, new Integer (lastBase));
    }
    return chromBase;
}


public KMLitPlugIn (String [] args) {
    try {
        ArgHandler ah = new ArgHandler (args);
        if (ah.checkFlag ('h')) {
            System.err.println ("KMLitPlugIn command line options");
            System.err.println ("   -a <RBNB address>");
            System.err.println ("       default: localhost:3333");
            System.err.println ("   -c <count> : max number of images to return");
            System.err.println ("      default: 100");
            System.err.println ("   -h (display this help message)");
            System.err.println ("   -i <interval> : min interval between images");
            System.err.println ("      default: 1 second");
            System.err.println ("   -n <PlugIn name>");
            System.err.println ("       default: KMLit");
            System.err.println ("   -u <URL base> : beginning of image URLs");
            System.err.println ("       default: http://localhost/RBNB/");
        }
        if (ah.checkFlag ('a')) {
            String addressL = ah.getOption ('a');
            if (addressL != null) {
                address = addressL;
            }
            else {
                System.err.println ("WARNING: Null argument to the \"-a\"" + " command line option.");
            }
        }
        if (ah.checkFlag ('c')) {
            String countS = ah.getOption ('c');
            if (countS != null) {
                basecount = Integer.parseInt (countS);
            }
            else {
                System.err.println ("WARNING: Null argument to the -c command line option");
            }
        }
        if (ah.checkFlag ('i')) {
            String intervalS = ah.getOption ('i');
            if (intervalS != null) {
                baseinterval = Double.parseDouble (intervalS);
            }
            else {
                System.err.println ("WARNING: Null argument to the -i command line option");
            }
        }
        if (ah.checkFlag ('n')) {
            String name = ah.getOption ('n');
            if (name != null) {
                pluginName = name;
            }
            else {
                System.err.println ("WARNING: Null argument to the \"-n\"" + " command line option.");
            }
        }
        if (ah.checkFlag ('p')) {
            String placemarkFileNameL = ah.getOption ('p');
            if (placemarkFileNameL != null) {
                placemarkFileName = placemarkFileNameL;
            }
            else {
                System.err.println ("WARNING: Null argument to the \"-p\"" + " command line option.");
            }
        }
        if (ah.checkFlag ('u')) {
            String urlL = ah.getOption ('u');
            if (urlL != null) {
                urlBase = urlL;
            }
            else {
                System.err.println ("WARNING: Null argument to the \"-u\" command line option");
            }
        }
    } catch (Exception e) {
        System.err.println ("AppendPlugIn argument exception " + e.getMessage ());
        e.printStackTrace ();
        RBNBProcess.exit (0);
    }
}


-----Function Pair=240=-----==

public static final byte [] unZipBuffer (byte [] buffer) {
    if (buffer == null) {
        throw new RuntimeException ("buffer is null, unZipBuffer");
    }
    ByteArrayInputStream is = new ByteArrayInputStream (buffer);
    ByteArrayOutputStream os = new ByteArrayOutputStream (1000);
    try {
        MLUtil.d ("unZipBuffer: " + buffer.length);
        ZipInputStream zip = new ZipInputStream (is);
        ZipEntry zipentry = zip.getNextEntry ();
        if (zipentry == null) {
            MLUtil.runtimeError (null, "unZipBuffer failure");
            return (null);
        }
        int n;
        byte [] temp = new byte [TEMP_FILE_BUFFER_SIZE];
        while ((n = zip.read (temp)) > - 1) os.write (temp, 0, n);
        zip.closeEntry ();
        zip.close ();
        is.close ();
        os.close ();
        byte [] bb = os.toByteArray ();
        MLUtil.d ("uncompressed=" + bb.length);
        return (bb);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "unzipBuffer");
    }
    return (null);
}


public static void ensureFileContentsEqual (String fileOne, String fileTwo) throws IOException {
    File file1 = checkFileExists (fileOne);
    File file2 = checkFileExists (fileTwo);
    if (file1.length () != file2.length ()) {
        throw new IOException ("Comparison failed " + fileOne + " size=" + file1.length () + " " + fileTwo + " size=" + file2.length ());
    }
    BufferedInputStream file1Stream = new BufferedInputStream (new FileInputStream (file1));
    BufferedInputStream file2Stream = new BufferedInputStream (new FileInputStream (file2));
    int byteRead;
    int byteToCompare;
    long position = 0;
    while ((byteRead = file1Stream.read ()) != - 1) {
        byteToCompare = file2Stream.read ();
        if (byteRead != byteToCompare) {
            throw new IOException ("Comparison failed. Byte at position " + position + " in " + fileOne + " different from that in " + fileTwo);
        }
        position ++;
    }
}


-----Function Pair=241=-----==

public static void saveDialog (Component parent, String content, String lastUsedDirectory, String title) {
    final JFileChooser fc = new JFileChooser (lastUsedDirectory);
    fc.setDialogTitle (title);
    fc.setFileHidingEnabled (true);
    fc.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    fc.setMultiSelectionEnabled (false);
    int returnVal = fc.showSaveDialog (parent);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile ();
        if (file != null) {
            MainFrame.frostSettings.setValue ("lastUsedDirectory", file.getParent ());
            if (! file.isDirectory ()) {
                writeFile (content, file, "UTF-8");
            }
        }
    }
}


private byte [] showAvailablePaths (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "CapturePathsAvailable.html");
    StringBuffer buff = new StringBuffer ();
    template.replaceAll ("$title", "Available capture paths");
    String path = urlData.getParameter ("path");
    File [] files = null;
    String parent = "";
    if (path == null || path.length () == 0) {
        files = File.listRoots ();
        template.replaceAll ("$currentPath", "");
    }
    else {
        File thisPath = new File (path);
        files = thisPath.listFiles ();
        if (thisPath.getParentFile () != null) parent = thisPath.getParentFile ().getAbsolutePath ();
        String addLink = "";
        if (thisPath.exists ()) {
            addLink = " <a href='#' onClick=\"addPath('/servlet/SystemDataRes?action=32&path=" + URLEncoder.encode (thisPath.getAbsolutePath (), "UTF-8") + "');\">" + "<img alt='Add Path' border=0 src='/images/add.png' align='absmiddle' width='24' height='24'></a> " + thisPath.getAbsolutePath ();
        }
        template.replaceAll ("$currentPath", addLink);
        if (thisPath.getParentFile () != null && thisPath.getParentFile ().exists () == true) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (parent, "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(parent)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
        else {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(root)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
    }
    if (files == null) {
        files = new File [0];
    }
    int numberItems = 0;
    for (int x = 0; x < files.length; x ++) {
        if (files [x].isDirectory ()) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (files [x].getCanonicalPath (), "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='path' border=0 src='/images/showchildren.png' align='absmiddle' width='24' height='24'> ");
            buff.append (files [x].getCanonicalPath ());
            buff.append ("</a>");
            buff.append ("</td></tr>");
            numberItems ++;
        }
    }
    if (numberItems == 0) {
        buff.append ("<tr><td nowrap>No items to show</td></tr>");
    }
    template.replaceAll ("$availablePaths", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=242=-----==

private void EventHandler (Object source) {
    NpsContext ctxt = null;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        conn = Database.GetDatabase ("fly").GetConnection ();
        pstmt = conn.prepareStatement ("select account,password from users where id=?");
        pstmt.setString (1, creator);
        rs = pstmt.executeQuery ();
        if (! rs.next ()) return;
        User runas = User.Login (rs.getString ("account"), rs.getString ("password"));
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        rs = null;
        pstmt = null;
        ctxt = new NpsContext (conn, runas);
        ctxt.GetSite (topic.GetSiteId ());
        switch (lang) {
            case JAVASCRIPT :
                RunJavaScript (ctxt, source);
                break;
            case DYNAMICJAVA :
                RunDynamicJava (ctxt, source);
                break;
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error_noexception (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        if (ctxt != null) ctxt.Clear ();
    }
}


public void createZip (String _filesToZip [], String _targetZip) {
    byte [] buffer = new byte [18024];
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (_targetZip));
        out.setLevel (Deflater.DEFAULT_COMPRESSION);
        for (int i = 0; i < _filesToZip.length; i ++) {
            FileInputStream in = new FileInputStream (_filesToZip [i]);
            out.putNextEntry (new ZipEntry (_filesToZip [i]));
            int len;
            while ((len = in.read (buffer)) > 0) {
                out.write (buffer, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IllegalArgumentException iae) {
        iae.printStackTrace ();
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


-----Function Pair=243=-----==

protected List getVersionedFiles (File dir) throws IOException {
    File cvsDir = new File (dir, "CVS");
    File entriesFile = new File (cvsDir, "Entries");
    if (! entriesFile.exists ()) return Collections.EMPTY_LIST;
    List result = new LinkedList ();
    BufferedReader entries = new BufferedReader (new FileReader (entriesFile));
    String line;
    while ((line = entries.readLine ()) != null) {
        int beg = line.indexOf ('/');
        if (beg == - 1) continue;
        int end = line.indexOf ('/', beg + 1);
        if (end == - 1) continue;
        String filename = line.substring (beg + 1, end);
        result.add (filename);
    }
    if (includeCvsDirs) {
        result.add ("CVS/Root");
        result.add ("CVS/Repository");
        result.add ("CVS/Entries");
    }
    return result;
}


private synchronized void fetchGeometrySetConfigFromCache () {
    final File _cacheFile = new File (GaiaEnvironment.getCacheFileName (geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable ()) + ".gsetconfig");
    System.out.println ("Searching " + _cacheFile.getName ());
    if (! (_cacheFile.exists ())) {
        System.out.println (_cacheFile.getName () + " not found!");
    }
    else {
        System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " configuration");
        try {
            FileInputStream inFile = new FileInputStream (_cacheFile);
            ObjectInputStream inObject = new ObjectInputStream (inFile);
            Object cachedObject = inObject.readObject ();
            if (cachedObject instanceof GeometrySetConfig) {
                geometrySetConfig = (GeometrySetConfig) cachedObject;
                if (parent != null) {
                    parent.repaint ();
                }
            }
            haveConfig = true;
            needsReload = false;
        } catch (ClassNotFoundException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (InvalidClassException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (FileNotFoundException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        } catch (IOException e) {
            System.out.println ("Error: " + e.getMessage ());
            geometrySetConfig.saveData ();
        }
        System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " configuration done...");
    }
}


-----Function Pair=244=-----==

public String digest (String type, String input) throws SkceWSException {
    FileInputStream fis = null;
    try {
        if (type == null) {
            type = DEFAULT_DIGEST;
        }
        File f = new File (input);
        if (! f.exists ()) {
            Common.log (Level.SEVERE, "SKCE-ERR-4001", input);
            throw new SkceWSException ("SKCE-ERR-4001: Invalid input - input file does not exist:" + input);
        }
        else if (! f.isFile ()) {
            Common.log (Level.SEVERE, "SKCE-ERR-4002", input);
            throw new SkceWSException ("SKCE-ERR-4002: Invalid input - input file is not a file:" + input);
        }
        else if (! f.canRead ()) {
            Common.log (Level.SEVERE, "SKCE-ERR-4003", input);
            throw new SkceWSException ("SKCE-ERR-4003: Invalid input - input file is not readable:" + input);
        }
        else if (f.length () <= 0) {
            Common.log (Level.SEVERE, "SKCE-ERR-4004", input);
            throw new SkceWSException ("SKCE-ERR-4004: Invalid input - input file is empty:" + input);
        }
        fis = new FileInputStream (input);
        Common.log (Level.FINE, "SKCE-MSG-4002", input);
        byte [] plaintext = new byte [Integer.parseInt (String.valueOf (f.length ()))];
        int n = fis.read (plaintext);
        Common.log (Level.FINE, "SKCE-MSG-4032", new String [] {Integer.toString (n), input});
        fis.close ();
        if (type.equalsIgnoreCase ("SHA1") || type.equalsIgnoreCase ("SHA-1") || type.equalsIgnoreCase ("sha1")) {
            return getSHA1 (plaintext, null);
        }
        else if (type.equalsIgnoreCase ("SHA256") || type.equalsIgnoreCase ("SHA-256") || type.equalsIgnoreCase ("sha256")) {
            return getSHA256 (plaintext, null);
        }
        else if (type.equalsIgnoreCase ("SHA384") || type.equalsIgnoreCase ("SHA-384") || type.equalsIgnoreCase ("sha384")) {
            return getSHA384 (plaintext, null);
        }
        else if (type.equalsIgnoreCase ("SHA512") || type.equalsIgnoreCase ("SHA-512") || type.equalsIgnoreCase ("sha512")) {
            return getSHA512 (plaintext, null);
        }
        else {
            return null;
        }
    } catch (FileNotFoundException ex) {
        Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
    } catch (IOException ex) {
        Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
    } catch (NoSuchAlgorithmException ex) {
        Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
    } catch (NoSuchProviderException ex) {
        Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
    } catch (GeneralSecurityException ex) {
        Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
    } finally {
        try {
            fis.close ();
        } catch (IOException ex) {
            Common.log (Level.SEVERE, "SKCE-ERR-1000", ex.getLocalizedMessage ());
        }
    }
    return null;
}


private static String toEscape (String s) {
    StringBuffer res = new StringBuffer ();
    for (int i = 0; i < s.length (); i ++) {
        char ch = s.charAt (i);
        int val = (int) ch;
        if (ch == '\r') continue;
        if (val >= 0 && val < 128 && ch != '\n' && ch != '\\') res.append (ch);
        else {
            res.append ("\\u");
            String hex = Integer.toHexString (val);
            for (int j = 0; j < 4 - hex.length (); j ++) res.append ("0");
            res.append (hex);
        }
    }
    return res.toString ();
}


-----Function Pair=245=-----==

public void removeSession (String session) {
    try {
        long namesId = db.getRoot (0);
        if (namesId != 0) {
            Map dir = (Map) db.fetch (namesId);
            String name;
            Map.Entry entry;
            long id;
            String prefix = session + SESSION_SEPARATOR;
            synchronized (maps) {
                Set entries = new HashSet (dir.entrySet ());
                for (Iterator i = entries.iterator (); i.hasNext ();) {
                    entry = (Map.Entry) i.next ();
                    name = (String) entry.getKey ();
                    id = ((Long) entry.getValue ()).longValue ();
                    if (name.startsWith (prefix)) {
                        if (log.isDebugEnabled ()) {
                            log.debug ("Removing " + name + " for session " + session);
                        }
                        maps.remove (name);
                        db.setNamedObject (name, 0);
                        db.delete (id);
                    }
                }
            }
        }
        else {
            throw new IllegalStateException ("The names directory doesn't exist");
        }
    } catch (IOException ex) {
        log.error ("Unable to remove session:" + session, ex);
    }
}


public boolean take () throws MalformedURLException, IOException {
    URL u = new URL (config.get ("requestURL"));
    URLConnection uc = u.openConnection ();
    boolean ret = false;
    uc.setDoOutput (true);
    OutputStreamWriter osw = new OutputStreamWriter (uc.getOutputStream (), "UTF-8");
    osw.write ("user=" + config.get ("username") + "&passwd=" + config.get ("password"));
    osw.write ("&version=" + config.get ("version") + "&max_complexity=" + config.get ("MaxComplexity"));
    osw.write ("&layerspossible=" + config.get ("layerPossible"));
    osw.flush ();
    BufferedReader rd = new BufferedReader (new InputStreamReader (uc.getInputStream (), "UTF-8"));
    String line = rd.readLine ();
    if (line == null) {
        logger.log (Level.INFO, "no answer");
        ret = false;
    }
    else {
        String [] split = line.split ("\\|");
        if (split [0].equals ("OK") && split [1].equals ("5")) {
            tile = new Tile ();
            tile.setLayer (split [5]);
            tile.setZXY (Integer.parseInt (split [4]), Integer.parseInt (split [2]), Integer.parseInt (split [3]));
            logger.log (Level.INFO, "get request: " + tile);
            ret = true;
        }
        else if (split [0].equals ("XX") && split [1].equals ("5")) {
            logger.log (Level.INFO, "answer: " + line);
            ret = false;
        }
        else {
            logger.log (Level.INFO, "protocal error\nthe answer: " + line);
            while ((line = rd.readLine ()) != null) {
                logger.log (Level.INFO, line);
            }
            ret = false;
        }
    }
    osw.close ();
    rd.close ();
    if (ret == false) {
        tile = null;
    }
    return ret;
}


-----Function Pair=246=-----==

public void run () {
    try {
        waitForCompletion ();
    } catch (FaultType f) {
        logger.error (f);
        synchronized (status) {
            status.notifyAll ();
        }
        return;
    }
    if (AppServiceImpl.drmaaInUse || ! AppServiceImpl.globusInUse) {
        done = true;
        status.setCode (GramJob.STATUS_STAGE_OUT);
        status.setMessage ("Writing output metadata");
        if (AppServiceImpl.dbInUse) {
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException e) {
                status.setCode (GramJob.STATUS_FAILED);
                status.setMessage ("Cannot update status database after finish - " + e.getMessage ());
                logger.error (e);
                synchronized (status) {
                    status.notifyAll ();
                }
                return;
            }
        }
    }
    try {
        if (! AppServiceImpl.drmaaInUse && ! AppServiceImpl.globusInUse) {
            try {
                logger.debug ("Waiting for all outputs to be written out");
                stdoutThread.join ();
                stderrThread.join ();
                logger.debug ("All outputs successfully written out");
            } catch (InterruptedException ignore) {
            }
        }
        File stdOutFile = new File (workingDir + File.separator + "stdout.txt");
        if (! stdOutFile.exists ()) {
            throw new IOException ("Standard output missing for execution");
        }
        File stdErrFile = new File (workingDir + File.separator + "stderr.txt");
        if (! stdErrFile.exists ()) {
            throw new IOException ("Standard error missing for execution");
        }
        if (AppServiceImpl.archiveData) {
            logger.debug ("Archiving output files");
            File f = new File (workingDir);
            File [] outputFiles = f.listFiles ();
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (workingDir + File.separator + jobID + ".zip"));
            byte [] buf = new byte [1024];
            try {
                for (int i = 0; i < outputFiles.length; i ++) {
                    FileInputStream in = new FileInputStream (outputFiles [i]);
                    out.putNextEntry (new ZipEntry (outputFiles [i].getName ()));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    in.close ();
                }
                out.close ();
            } catch (IOException e) {
                logger.error (e);
                logger.error ("Error not fatal - moving on");
            }
        }
        File f = new File (workingDir);
        File [] outputFiles = f.listFiles ();
        OutputFileType [] outputFileObj = new OutputFileType [outputFiles.length - 2];
        int j = 0;
        for (int i = 0; i < outputFiles.length; i ++) {
            if (outputFiles [i].getName ().equals ("stdout.txt")) {
                outputs.setStdOut (new URI (AppServiceImpl.tomcatURL + jobID + "/stdout.txt"));
            }
            else if (outputFiles [i].getName ().equals ("stderr.txt")) {
                outputs.setStdErr (new URI (AppServiceImpl.tomcatURL + jobID + "/stderr.txt"));
            }
            else {
                OutputFileType next = new OutputFileType ();
                next.setName (outputFiles [i].getName ());
                next.setUrl (new URI (AppServiceImpl.tomcatURL + jobID + "/" + outputFiles [i].getName ()));
                outputFileObj [j ++] = next;
            }
        }
        outputs.setOutputFile (outputFileObj);
    } catch (IOException e) {
        status.setCode (GramJob.STATUS_FAILED);
        status.setMessage ("Cannot retrieve outputs after finish - " + e.getMessage ());
        logger.error (e);
        if (AppServiceImpl.dbInUse) {
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException se) {
                logger.error (se);
            }
        }
        synchronized (status) {
            status.notifyAll ();
        }
        return;
    }
    if (! AppServiceImpl.dbInUse) {
        AppServiceImpl.outputTable.put (jobID, outputs);
    }
    else {
        Connection conn = null;
        try {
            conn = DriverManager.getConnection (AppServiceImpl.dbUrl, AppServiceImpl.dbUser, AppServiceImpl.dbPasswd);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot connect to database after finish - " + e.getMessage ());
            logger.error (e);
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
        String sqlStmt = "insert into job_output(job_id, std_out, std_err) " + "values ('" + jobID + "', " + "'" + outputs.getStdOut ().toString () + "', " + "'" + outputs.getStdErr ().toString () + "');";
        Statement stmt = null;
        try {
            stmt = conn.createStatement ();
            stmt.executeUpdate (sqlStmt);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot update job output database after finish - " + e.getMessage ());
            logger.error (e);
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException se) {
                logger.error (se);
            }
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
        OutputFileType [] outputFile = outputs.getOutputFile ();
        for (int i = 0; i < outputFile.length; i ++) {
            sqlStmt = "insert into output_file(job_id, name, url) " + "values ('" + jobID + "', " + "'" + outputFile [i].getName () + "', " + "'" + outputFile [i].getUrl ().toString () + "');";
            try {
                stmt = conn.createStatement ();
                stmt.executeUpdate (sqlStmt);
            } catch (SQLException e) {
                status.setCode (GramJob.STATUS_FAILED);
                status.setMessage ("Cannot update output_file DB after finish - " + e.getMessage ());
                logger.error (e);
                try {
                    updateStatusInDatabase (jobID, status);
                } catch (SQLException se) {
                    logger.error (se);
                }
                synchronized (status) {
                    status.notifyAll ();
                }
                return;
            }
        }
    }
    if (terminatedOK ()) {
        status.setCode (GramJob.STATUS_DONE);
        status.setMessage ("Execution complete - " + "check outputs to verify successful execution");
    }
    else {
        status.setCode (GramJob.STATUS_FAILED);
        status.setMessage ("Execution failed");
    }
    if (AppServiceImpl.dbInUse) {
        try {
            updateStatusInDatabase (jobID, status);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot update status database after finish - " + e.getMessage ());
            logger.error (e);
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
    }
    AppServiceImpl.jobTable.remove (jobID);
    synchronized (status) {
        status.notifyAll ();
    }
    logger.info ("Execution complete for job: " + jobID);
}


public void run (String args []) {
    try {
        parseArgs (args);
        if (providers != null) {
            ClassLoader cl = ClassLoader.getSystemClassLoader ();
            Enumeration < String > e = providers.elements ();
            while (e.hasMoreElements ()) {
                String provName = e.nextElement ();
                Class < ? > provClass;
                if (cl != null) {
                    provClass = cl.loadClass (provName);
                }
                else {
                    provClass = Class.forName (provName);
                }
                String provArg = providerArgs.get (provName);
                Object obj;
                if (provArg == null) {
                    obj = provClass.newInstance ();
                }
                else {
                    Constructor < ? > c = provClass.getConstructor (PARAM_STRING);
                    obj = c.newInstance (provArg);
                }
                if (! (obj instanceof Provider)) {
                    MessageFormat form = new MessageFormat (rb.getString ("provName not a provider"));
                    Object [] source = {provName};
                    throw new Exception (form.format (source));
                }
                Security.addProvider ((Provider) obj);
            }
        }
        if (verify) {
            try {
                loadKeyStore (keystore, false);
            } catch (Exception e) {
                if ((keystore != null) || (storepass != null)) {
                    System.out.println (rb.getString ("jarsigner error: ") + e.getMessage ());
                    System.exit (1);
                }
            }
            verifyJar (jarfile);
        }
        else {
            loadKeyStore (keystore, true);
            getAliasInfo (alias);
            if (altSignerClass != null) {
                signingMechanism = loadSigningMechanism (altSignerClass, altSignerClasspath);
            }
            signJar (jarfile, alias, args);
        }
    } catch (Exception e) {
        System.out.println (rb.getString ("jarsigner error: ") + e);
        if (debug) {
            e.printStackTrace ();
        }
        System.exit (1);
    } finally {
        if (keypass != null) {
            Arrays.fill (keypass, ' ');
            keypass = null;
        }
        if (storepass != null) {
            Arrays.fill (storepass, ' ');
            storepass = null;
        }
    }
    if (strict) {
        int exitCode = 0;
        if (hasExpiringCert) {
            exitCode |= 2;
        }
        if (chainNotValidated) {
            exitCode |= 4;
        }
        if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
            exitCode |= 8;
        }
        if (hasUnsignedEntry) {
            exitCode |= 16;
        }
        if (notSignedByAlias || aliasNotInStore) {
            exitCode |= 32;
        }
        if (exitCode != 0) {
            System.exit (exitCode);
        }
    }
}


-----Function Pair=247=-----==

public static InputStream wrapInputStream (InputStream in, String compressionAlgorithm, String entryName) throws SQLException {
    try {
        if ("GZIP".equals (compressionAlgorithm)) {
            in = new GZIPInputStream (in);
        }
        else if ("ZIP".equals (compressionAlgorithm)) {
            ZipInputStream z = new ZipInputStream (in);
            while (true) {
                ZipEntry entry = z.getNextEntry ();
                if (entry == null) {
                    return null;
                }
                if (entryName.equals (entry.getName ())) {
                    break;
                }
            }
            in = z;
        }
        else if ("DEFLATE".equals (compressionAlgorithm)) {
            in = new InflaterInputStream (in);
        }
        else if ("LZF".equals (compressionAlgorithm)) {
            in = new LZFInputStream (in);
        }
        else if (compressionAlgorithm != null) {
            throw Message.getSQLException (ErrorCode.UNSUPPORTED_COMPRESSION_ALGORITHM_1, compressionAlgorithm);
        }
        return in;
    } catch (IOException e) {
        throw Message.convertIOException (e, null);
    }
}


private void createFile (String createFilePath, String contents) {
    try {
        File file = new File (createFilePath);
        boolean success = file.createNewFile ();
        if (success) {
            BufferedWriter out = new BufferedWriter (new FileWriter (createFilePath, true));
            out.write (contents);
            out.close ();
        }
        else {
            (new File (createFilePath)).delete ();
            createFile (createFilePath, contents);
        }
    } catch (IOException e) {
        System.out.println ("Could not create file: (debug: createFilePath() " + createFilePath + ")");
        System.out.println ("Do you have write permission for this location?");
        System.exit (1);
    }
}


-----Function Pair=248=-----==

public static File zipFile (String pathToBeZipped, String pathZippedFile) throws IOException {
    if (pathZippedFile.indexOf (".zip") < 0) {
        pathZippedFile += ".zip";
    }
    File fileASerZipado = new File (pathToBeZipped);
    byte [] buf = new byte [BUFFER_SIZE];
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (pathZippedFile));
    FileInputStream in = new FileInputStream (pathToBeZipped);
    out.putNextEntry (new ZipEntry (fileASerZipado.getName ()));
    int len;
    while ((len = in.read (buf)) > 0) {
        out.write (buf, 0, len);
    }
    out.closeEntry ();
    in.close ();
    out.close ();
    return new File (pathZippedFile);
}


private void recursiveZipWrite (File file, ZipOutputStream out, String currentParentPath) throws IOException {
    if (file.isFile ()) {
        ZipEntry entry = new ZipEntry (currentParentPath + file.getName ());
        entry.setTime (file.lastModified ());
        out.putNextEntry (entry);
        FileInputStream in = new FileInputStream (file);
        StringUtils.copy (in, out);
        in.close ();
        out.closeEntry ();
    }
    else if (file.isDirectory ()) {
        for (File subfile : file.listFiles ()) {
            recursiveZipWrite (subfile, out, currentParentPath + file.getName () + "/");
        }
    }
}


-----Function Pair=249=-----==

public boolean marshall (PackagePart part, OutputStream os) throws OpenXML4JException {
    if (! (os instanceof ZipOutputStream)) {
        logger.error ("unexpected class " + os.getClass ().getName ());
        throw new OpenXML4JException (" ZipOutputStream expected!");
    }
    if (logger.isDebugEnabled ()) {
        logger.debug ("saving CHANGED xml file");
    }
    ZipOutputStream out = (ZipOutputStream) os;
    ZipEntry ctEntry = new ZipEntry (part.getUri ().getPath ());
    try {
        out.putNextEntry (ctEntry);
        if (! Package.saveAsXmlInZip (xmlContent, part.getUri ().getPath (), out)) {
            return false;
        }
        if (logger.isDebugEnabled ()) {
            logger.debug ("recording style relationship (should be none)");
        }
        if (part.hasRelationships ()) {
            ZipPartMarshaller partMarshaller = new ZipPartMarshaller ();
            partMarshaller.marshallRelationshipPart (part.getRelationships (), PackageURIHelper.getRelationshipPartUri (part.getUri ()), out);
        }
        out.closeEntry ();
    } catch (IOException e1) {
        logger.error ("IO problem with " + part.getUri (), e1);
        return false;
    }
    return true;
}


public void save (Document doc, Element ele, String lang) throws IOException {
    XMLUtil.setType (doc, ele, this);
    if (fileResourceExtent.getName () != null) {
        ele.setAttribute ("resourceExtent", fileResourceExtent.getResource ());
    }
    if (fileResourceAttributes.getName () != null) {
        ele.setAttribute ("resourceAttributes", fileResourceAttributes.getResource ());
    }
    if (fileResourceMatrix.getName () != null) {
        ele.setAttribute ("resourceMatrix", fileResourceMatrix.getResource ());
    }
    ele.setAttribute ("name", fileresource.getName ());
    Element label_element = doc.createElement ("Label");
    if (labels != null) {
        labels.appendToElement (label_element);
    }
    else {
        labels = new Translate (fileresource.getName (), label_element);
        labels.addLabel (lang, fileresource.getName ());
        label_element.setAttribute (lang, fileresource.getName ());
    }
    ele.appendChild (label_element);
}


-----Function Pair=250=-----==

public boolean save (IFileHandle output) {
    if (output == null || output.canOpenOutput () == false) return false;
    try {
        logger.log (Level.FINE, "Saving ''{0}''", output.toString ());
        OutputStream fos = output.openOutput ();
        ZipOutputStream zos = new ZipOutputStream (fos);
        zos.putNextEntry (new ZipEntry ("OK"));
        ObjectOutputStream out = new ObjectOutputStream (zos);
        SerialisedNode sDoc = new SerialisedNode ();
        recursiveSerialise (head, sDoc);
        try {
            out.writeObject (sDoc);
        } catch (Exception ex) {
            logger.log (Level.SEVERE, "Unable to write serialised node", ex);
            return false;
        }
        zos.closeEntry ();
        out.close ();
        zos.close ();
        fos.close ();
        needsSaving = false;
        logger.log (Level.FINE, "Saved ''{0}''", output.toString ());
        return true;
    } catch (Exception ex) {
        logger.log (Level.SEVERE, "Problem writing to file", ex);
        return false;
    }
}


public static int getDefaultColor (Context ctx, String key, boolean alt) {
    Resources r = ctx.getResources ();
    if (key.equals (ColorsKeeper.CUR_COLORS)) return alt ? r.getColor (R.color.cur_def) : 0;
    if (key.equals (ColorsKeeper.BTN_COLORS)) {
        final int GINGERBREAD = 9;
        if (android.os.Build.VERSION.SDK_INT >= GINGERBREAD) return r.getColor (R.color.btn_def);
        else return alt ? r.getColor (R.color.btn_odf) : 0;
    }
    if (alt) return 0;
    if (key.equals (ColorsKeeper.BGR_COLORS)) return r.getColor (R.color.bgr_def);
    if (key.equals (ColorsKeeper.SEL_COLORS)) return r.getColor (R.color.sel_def);
    if (key.equals (ColorsKeeper.SFG_COLORS)) return r.getColor (R.color.fgr_def);
    if (key.equals (ColorsKeeper.TTL_COLORS)) return r.getColor (R.color.ttl_def);
    if (key.equals (ColorsKeeper.FGR_COLORS)) return r.getColor (R.color.fgr_def);
    return 0;
}


-----Function Pair=251=-----==

public Scribable read (String name) throws IOException, InvalidFormat {
    DirEntry d = (DirEntry) index.get (name);
    if (d == null) {
        return null;
    }
    byte [] data = new byte [(int) d.length];
    if (readOnly && usemap) {
        bb.position ((int) d.pos);
        bb.get (data);
    }
    else {
        file.seek (d.pos);
        file.read (data, 0, data.length);
    }
    ZipInputStream zip = null;
    ByteArrayInputStream bin = new ByteArrayInputStream (data);
    InputStream in = bin;
    if (d.compressed) {
        zip = new ZipInputStream (in);
        zip.getNextEntry ();
        in = zip;
    }
    ScribeInputStream sin = new ScribeInputStream (in);
    Scribable object = sin.readScribable ();
    in.close ();
    return object;
}


private String convertReferencePath (String attributeValue, int contentPathLength, String filePathFromConvert) {
    int index = attributeValue.indexOf (ASSOCIATED_FILES_PREFIX);
    if (index == - 1) return attributeValue;
    int lengthPrefix = ASSOCIATED_FILES_PREFIX.length () + index;
    String filePathToConvert = null;
    String contentPathPrefix = attributeValue.substring (lengthPrefix, index + contentPathLength - 1);
    try {
        UUID.fromString (contentPathPrefix);
        filePathToConvert = attributeValue.substring (index + ASSOCIATED_FILES_PREFIX.length () + 37);
        if (filePathFromConvert != null) {
            filePathToConvert = convertPathRelativeToFile (filePathToConvert, filePathFromConvert);
        }
    } catch (IllegalArgumentException iae) {
        log.debug ("Malformed rootFolder UUID: " + iae);
        return null;
    }
    return filePathToConvert;
}


-----Function Pair=252=-----==

public static String uploadFile (UploadedFile file) throws IOException {
    System.err.println ("in fileupload " + file.getFileName ());
    String path = Const.UPLOAD_DIR + Const.FILE_SEPARATOR;
    File up = new File (path + file.getFileName ());
    System.err.println (up.getPath ());
    FileOutputStream fos = new FileOutputStream (up);
    InputStream in = file.getInputstream ();
    byte [] buffer = new byte [Const.BUFFER_SIZE];
    int length;
    while ((length = in.read (buffer)) > 0) {
        fos.write (buffer, 0, length);
        fos.flush ();
    }
    fos.close ();
    in.close ();
    System.err.println (up.getParentFile ().listFiles ().length);
    return up.getPath ();
}


protected Element openExportFile () throws IOException, SAXException {
    setExportZipStream (new ZipOutputStream (new FileOutputStream (getExportFileName ())));
    CmsXmlSaxWriter saxHandler = new CmsXmlSaxWriter (new StringWriter (4096), OpenCms.getSystemInfo ().getDefaultEncoding ());
    saxHandler.setEscapeXml (true);
    saxHandler.setEscapeUnknownChars (true);
    setSaxWriter (new SAXWriter (saxHandler, saxHandler));
    Document doc = DocumentHelper.createDocument ();
    saxHandler.startDocument ();
    if (m_parameters.isXmlValidation ()) {
        saxHandler.startDTD (getExportNodeName (), null, CmsConfigurationManager.DEFAULT_DTD_PREFIX + CmsImportVersion7.DTD_FILENAME);
        saxHandler.endDTD ();
    }
    String exportNodeName = getExportNodeName ();
    Element exportNode = doc.addElement (exportNodeName);
    getSaxWriter ().writeOpen (exportNode);
    Element info = exportNode.addElement (CmsImportExportManager.N_INFO);
    info.addElement (CmsImportExportManager.N_CREATOR).addText (getCms ().getRequestContext ().currentUser ().getName ());
    info.addElement (CmsImportExportManager.N_OC_VERSION).addText (OpenCms.getSystemInfo ().getVersionNumber ());
    info.addElement (CmsImportExportManager.N_DATE).addText (CmsDateUtil.getHeaderDate (System.currentTimeMillis ()));
    info.addElement (CmsImportExportManager.N_INFO_PROJECT).addText (getCms ().getRequestContext ().currentProject ().getName ());
    info.addElement (CmsImportExportManager.N_VERSION).addText (CmsImportExportManager.EXPORT_VERSION);
    digestElement (exportNode, info);
    return exportNode;
}


-----Function Pair=253=-----=1=

public static void copyFile (final File sourceFile, final File destFile) throws IOException {
    if (! destFile.exists ()) {
        destFile.createNewFile ();
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    FileChannel source = null;
    FileChannel destination = null;
    try {
        source = (inStream = new FileInputStream (sourceFile)).getChannel ();
        destination = (outStream = new FileOutputStream (destFile)).getChannel ();
        destination.transferFrom (source, 0, source.size ());
    } finally {
        closeIO (source);
        closeIO (inStream);
        closeIO (destination);
        closeIO (outStream);
    }
}


private void addAuditDatastream () throws ObjectIntegrityException, StreamIOException {
    if (m_obj.getAuditRecords ().size () == 0) {
        return;
    }
    String dsId = m_pid.toURI () + "/AUDIT";
    String dsvId = dsId + "/" + DateUtility.convertDateToString (m_obj.getCreateDate ());
    Entry dsEntry = m_feed.addEntry ();
    dsEntry.setId (dsId);
    dsEntry.setTitle ("AUDIT");
    dsEntry.setUpdated (m_obj.getCreateDate ());
    dsEntry.addCategory (MODEL.STATE.uri, "A", null);
    dsEntry.addCategory (MODEL.CONTROL_GROUP.uri, "X", null);
    dsEntry.addCategory (MODEL.VERSIONABLE.uri, "false", null);
    dsEntry.addLink (dsvId, Link.REL_ALTERNATE);
    Entry dsvEntry = m_feed.addEntry ();
    dsvEntry.setId (dsvId);
    dsvEntry.setTitle ("AUDIT.0");
    dsvEntry.setUpdated (m_obj.getCreateDate ());
    ThreadHelper.addInReplyTo (dsvEntry, m_pid.toURI () + "/AUDIT");
    dsvEntry.addCategory (MODEL.FORMAT_URI.uri, AUDIT1_0.uri, null);
    dsvEntry.addCategory (MODEL.LABEL.uri, "Audit Trail for this object", null);
    if (m_format.equals (ATOM_ZIP1_1)) {
        String name = "AUDIT.0.xml";
        try {
            m_zout.putNextEntry (new ZipEntry (name));
            Reader r = new StringReader (DOTranslationUtility.getAuditTrail (m_obj));
            IOUtils.copy (r, m_zout, m_encoding);
            m_zout.closeEntry ();
            r.close ();
        } catch (IOException e) {
            throw new StreamIOException (e.getMessage (), e);
        }
        IRI iri = new IRI (name);
        dsvEntry.setSummary ("AUDIT.0");
        dsvEntry.setContent (iri, "text/xml");
    }
    else {
        dsvEntry.setContent (DOTranslationUtility.getAuditTrail (m_obj), "text/xml");
    }
}


-----Function Pair=254=-----==

public static File createZip (final String fileName, final File dirToZip, final File destDir) throws IOException {
    if (! destDir.exists () || ! destDir.isDirectory ()) {
        throw new IOException ("The destination dir doesn't exist or isn't a directory");
    }
    if (! dirToZip.exists () || ! dirToZip.isDirectory ()) {
        throw new IOException ("The directory to zip doesn't exist or isn't a directory");
    }
    final File outFile = new File (destDir.getAbsolutePath () + File.separator + fileName);
    outFile.getParentFile ().mkdirs ();
    final ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (outFile));
    try {
        zipDir (dirToZip, zos, "");
    } finally {
        zos.close ();
    }
    return outFile;
}


public void write () {
    int i;
    try {
        OutputStream os = new FileOutputStream (filename);
        ZipOutputStream zos = new ZipOutputStream (os);
        OutputStreamWriter out;
        if (compressed) {
            zos.putNextEntry (new ZipEntry ("QuizCards XML"));
            out = new OutputStreamWriter (zos);
            XML.startFile (out);
        }
        else {
            out = new OutputStreamWriter (os, "UTF-8");
            XML.startFile (out);
        }
        XML.startElement ("qcards:stack", "version", String.valueOf (QuizCards.version));
        XML.startElement ("properties");
        XML.writeElement ("title", title);
        XML.writeElement ("left_name", lName);
        XML.writeElement ("right_name", rName);
        XML.writeElement ("left_font", lFontName);
        XML.writeElement ("right_font", rFontName);
        XML.writeElement ("left_font_size", Integer.toString (lFontSize));
        XML.writeElement ("right_font_size", Integer.toString (rFontSize));
        XML.writeElement ("left_sound", String.valueOf (lSoundFlag));
        XML.writeElement ("right_sound", String.valueOf (rSoundFlag));
        XML.finishElement ();
        sets.write ();
        XML.startElement ("cards");
        for (i = 0; i < cards.size (); i ++) ((Card) cards.elementAt (i)).write (i, sets);
        XML.finishElement ();
        XML.finishElement ();
        XML.finishFile ();
        out.flush ();
        if (compressed) {
            DataOutputStream dos = new DataOutputStream (zos);
            zos.closeEntry ();
            for (i = 0; i < cards.size (); i ++) {
                ((Card) cards.elementAt (i)).writeFiles (zos, dos);
            }
            dos.flush ();
            zos.flush ();
            zos.finish ();
        }
        os.flush ();
        dirty = false;
    } catch (IOException e) {
        System.out.println (e);
    }
}


-----Function Pair=255=-----==

public void testJarFileModifiedClass () throws IOException {
    String modifiedJarName = "Modified_Class.jar";
    Support_Resources.copyFile (resources, null, modifiedJarName);
    JarFile jarFile = new JarFile (new File (resources, modifiedJarName), true);
    Enumeration < JarEntry > entries = jarFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry zipEntry = entries.nextElement ();
        jarFile.getInputStream (zipEntry);
    }
    ZipEntry zipEntry = jarFile.getEntry ("Test.class");
    InputStream in = jarFile.getInputStream (zipEntry);
    byte [] buffer = new byte [1024];
    try {
        while (in.available () > 0) {
            in.read (buffer);
        }
        fail ("SecurityException expected");
    } catch (SecurityException e) {
    }
}


public static File gunzip (File file) {
    String name = null;
    byte [] data = new byte [2048];
    try {
        GZIPInputStream zip = new GZIPInputStream (new FileInputStream (file));
        String repName = "temp" + file.getName ();
        File newRep = new File (repName);
        newRep.mkdirs ();
        name = repName + "/" + file.getName ().substring (0, file.getName ().length () - 3);
        OutputStream dest = new FileOutputStream (name);
        int count;
        while ((count = zip.read (data)) > 0) {
            dest.write (data, 0, count);
        }
        dest.close ();
        zip.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return new File (name);
}


-----Function Pair=256=-----==

public static boolean move (File oldFile, File destinationFile) throws IOException {
    if (oldFile.equals (destinationFile)) {
        return true;
    }
    if (destinationFile.exists ()) {
        return false;
    }
    if (oldFile.isDirectory ()) {
        if (! destinationFile.exists ()) {
            destinationFile.mkdirs ();
        }
        String [] content = oldFile.list ();
        boolean worked = true;
        for (String tmpFile : content) {
            worked = worked && move (new File (oldFile, tmpFile), new File (destinationFile, tmpFile));
        }
        delete (oldFile);
        return worked;
    }
    else {
        destinationFile.getParentFile ().mkdirs ();
        FileReader in = new FileReader (oldFile);
        FileWriter out = new FileWriter (destinationFile);
        for (int i = in.read (); i != - 1; i = in.read ()) {
            out.write (i);
        }
        in.close ();
        out.close ();
        destinationFile.createNewFile ();
        delete (oldFile);
        return true;
    }
}


private static void createJarFilesWith (ZipOutputStream out, List < String > filesFullPath) {
    byte [] data = new byte [COMPRESS_OUTPUTSTREAM_BUFFER_SIZE];
    BufferedInputStream origin = null;
    int counter = 0;
    for (Iterator < ? > i = filesFullPath.iterator (); i.hasNext ();) {
        String filename = (String) i.next ();
        try {
            addFileToJar (origin, out, data, filename);
            counter ++;
        } catch (FileNotFoundException e) {
            logger.error ("File '" + filename + "' couldn't be added to jar file because it doesn't exist file.", e);
        } catch (IOException e1) {
            logger.error ("File '" + filename + "' couldn't be added to jar file cause of an input/ouput error.", e1);
        }
    }
    try {
        out.close ();
        logger.debug ("Zip file was created and '" + counter + "' files was added succesfully.");
    } catch (IOException e) {
        logger.error ("Zip file couldn't be closed correctly cause by a input / output error.");
    }
}


-----Function Pair=257=-----==

private void addMapDataToRow (Row row, Map < Object, Object > rowdata) {
    Set < Entry < String, FieldProperty > > enterSet = (fieldMap).entrySet ();
    Iterator < Entry < String, FieldProperty > > entryIte = enterSet.iterator ();
    Entry < String, FieldProperty > entry = null;
    int column = 0;
    Cell cell = null;
    Object value = null;
    while (entryIte.hasNext ()) {
        cell = row.createCell (column);
        entry = entryIte.next ();
        value = rowdata.get (entry.getValue ().getProperty ());
        addCellValue (cell, value, entry.getValue ());
        column ++;
    }
}


private Actor findWitness (Actor closest_npc []) {
    Vector < GameObject > npcs = new Vector < GameObject > ();
    mainActor.findNearbyActors (npcs, EConst.c_any_shapenum, 12, 0x28);
    closest_npc [0] = null;
    int closest_dist = 5000;
    Actor witness = null;
    int closest_witness_dist = 5000;
    for (GameObject each : npcs) {
        Actor npc = (Actor) each;
        if (npc instanceof MonsterActor || npc.getFlag (GameObject.in_party) || (npc.getFrameNum () & 15) == Actor.sleep_frame || npc.getNpcNum () >= numNpcs1) continue;
        int dist = npc.distance (mainActor);
        if (dist >= closest_witness_dist || ! PathFinder.FastClient.isGrabable (npc, mainActor)) continue;
        int dir = npc.getDirection (mainActor);
        int facing = npc.getDirFacing ();
        int dirdiff = (dir - facing + 8) % 8;
        if (dirdiff < 3 || dirdiff > 5) {
            witness = npc;
            closest_witness_dist = dist;
        }
        else if (dist < closest_dist) {
            closest_npc [0] = npc;
            closest_dist = dist;
        }
    }
    return witness;
}


-----Function Pair=258=-----==

private void dumpToPDF (File dirOut, String oname, String ff, Book book, Hashtable < String, String > repl) {
    String ret = null;
    try {
        System.out.print ("Creating " + ff + ".pdf...");
        if (zout != null) {
            zout.putNextEntry (new ZipEntry (ff + ".pdf"));
            ret = book.getPDF (zout, lrfSize, repl);
        }
        else if (dirOut != null) {
            File nf = new File (dirOut, ff + ".pdf");
            nf.getParentFile ().mkdirs ();
            FileOutputStream fos = new FileOutputStream (nf);
            ret = book.getPDF (fos, lrfSize, repl);
            fos.close ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (oname + ".pdf");
            ret = book.getPDF (fos, lrfSize, repl);
            fos.close ();
        }
        System.out.println (ret);
    } catch (Exception e) {
        e.printStackTrace ();
        System.out.println ("PDF Error");
    }
}


public static RegionScoreData merge (ArrayList < RegionScoreData > pdAL) {
    RegionScoreData [] pdArray = new RegionScoreData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionScores.length;
    RegionScore [] concatinate = new RegionScore [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionScore [] slice = pdArray [i].sortedRegionScores;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionScoreData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionScoreData (concatinate, sliceInfo);
}


-----Function Pair=259=-----==

protected void zipDir (Resource dir, ZipOutputStream zOut, String vPath, int mode, ZipExtraField [] extra) throws IOException {
    if (doFilesonly) {
        logWhenWriting ("skipping directory " + vPath + " for file-only archive", Project.MSG_VERBOSE);
        return;
    }
    if (addedDirs.get (vPath) != null) {
        return;
    }
    logWhenWriting ("adding directory " + vPath, Project.MSG_VERBOSE);
    addedDirs.put (vPath, vPath);
    if (! skipWriting) {
        ZipEntry ze = new ZipEntry (vPath);
        int millisToAdd = roundUp ? ROUNDUP_MILLIS : 0;
        if (dir != null && dir.isExists ()) {
            ze.setTime (dir.getLastModified () + millisToAdd);
        }
        else {
            ze.setTime (System.currentTimeMillis () + millisToAdd);
        }
        ze.setSize (0);
        ze.setMethod (ZipEntry.STORED);
        ze.setCrc (EMPTY_CRC);
        ze.setUnixMode (mode);
        if (extra != null) {
            ze.setExtraFields (extra);
        }
        zOut.putNextEntry (ze);
    }
}


private void storeOther (String fn, LangItem lang) throws FileNotFoundException, IOException {
    Vector lines = set.store (lang.getLangId ());
    FileOutputStream f = new FileOutputStream (fn);
    f.write (0xFF);
    f.write (0xFE);
    for (int j = 0; j < lines.size (); j ++) {
        String s = (String) lines.elementAt (j);
        s = replace (s, "\n", toEscape ("\n"));
        for (int k = 0; k < s.length (); k ++) {
            char ch = s.charAt (k);
            f.write (((int) ch) & 255);
            f.write (((int) ch)>> 8);
        }
        f.write (0x0D);
        f.write (0x00);
        f.write (0x0A);
        f.write (0x00);
    }
    f.close ();
}


-----Function Pair=260=-----==

protected void addOneJarBoot (ZipOutputStream zOut) throws IOException {
    if (zOut == null) return;
    if (onejar != null) {
        includeZip (onejar, zOut);
    }
    else {
        String ONE_JAR_BOOT = "one-jar-boot.jar";
        InputStream is = OneJarTask.class.getResourceAsStream (ONE_JAR_BOOT);
        if (is == null) throw new IOException ("Unable to load default " + ONE_JAR_BOOT + ": consider using the <one-jar onejarboot=\"...\"> option.");
        JarInputStream jis = new JarInputStream (is);
        Manifest manifest = new Manifest ();
        java.util.jar.Manifest jmanifest = jis.getManifest ();
        java.util.jar.Attributes jattributes = jmanifest.getMainAttributes ();
        try {
            manifest.addConfiguredAttribute (new Attribute ("Created-By", "One-Jar 0.98 Ant taskdef"));
            manifest.addConfiguredAttribute (new Attribute (MAIN_CLASS, jattributes.getValue (MAIN_CLASS)));
            if (oneJarMainClass != null) {
                manifest.addConfiguredAttribute (new Attribute (Boot.ONE_JAR_MAIN_CLASS, oneJarMainClass));
            }
            super.addConfiguredManifest (manifest);
        } catch (ManifestException mx) {
            throw new BuildException (mx);
        }
        super.initZipOutputStream (zOut);
        ZipEntry entry = jis.getNextEntry ();
        while (entry != null) {
            if (entry.getName ().endsWith (CLASS) || entry.getName ().equals (".version") || entry.getName ().endsWith ("license.txt")) {
                log ("entry=" + entry.getName (), Project.MSG_DEBUG);
                zOut.putNextEntry (new org.apache.tools.zip.ZipEntry (entry));
                copy (jis, zOut, false);
            }
            entry = jis.getNextJarEntry ();
        }
    }
}


public static void ensureFileContentsEqual (String fileOne, String fileTwo) throws IOException {
    File file1 = checkFileExists (fileOne);
    File file2 = checkFileExists (fileTwo);
    if (file1.length () != file2.length ()) {
        throw new IOException ("Comparison failed " + fileOne + " size=" + file1.length () + " " + fileTwo + " size=" + file2.length ());
    }
    BufferedInputStream file1Stream = new BufferedInputStream (new FileInputStream (file1));
    BufferedInputStream file2Stream = new BufferedInputStream (new FileInputStream (file2));
    int byteRead;
    int byteToCompare;
    long position = 0;
    while ((byteRead = file1Stream.read ()) != - 1) {
        byteToCompare = file2Stream.read ();
        if (byteRead != byteToCompare) {
            throw new IOException ("Comparison failed. Byte at position " + position + " in " + fileOne + " different from that in " + fileTwo);
        }
        position ++;
    }
}


-----Function Pair=261=-----==

private void setRemotePath (String userID, String workflowID, String jobID, String portID, String newRemotePath, String io) {
    try {
        Vector < JobPropertyBean > jobs = getConfigData (userID, workflowID);
        for (JobPropertyBean j : jobs) {
            if (j.getName ().equals (new String (jobID))) {
                Vector < PortDataBean > ports = null;
                if (io.equals ("input")) {
                    ports = j.getInputs ();
                }
                else {
                    ports = j.getOutputs ();
                }
                for (PortDataBean p : ports) {
                    if (p.getSeq () == Long.parseLong (portID)) {
                        p.getData ().put ("remote", newRemotePath);
                    }
                }
            }
        }
        this.saveConfigData (userID, workflowID, jobs);
    } catch (Exception e) {
        throw new ASMException ("Setting remote file path on " + workflowID + " " + jobID + " " + portID + " to " + newRemotePath + " failed.");
    }
}


public static Boolean compress (ArrayList < String > aFiles, String sDestinationFilename) {
    BufferedInputStream oOrigin = null;
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    Iterator < String > oIterator;
    byte [] aData;
    try {
        oDestination = new FileOutputStream (sDestinationFilename);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        aData = new byte [BUFFER_SIZE];
        oIterator = aFiles.iterator ();
        while (oIterator.hasNext ()) {
            String sFilename = (String) oIterator.next ();
            FileInputStream fisInput = new FileInputStream (sFilename);
            oOrigin = new BufferedInputStream (fisInput, BUFFER_SIZE);
            ZipEntry oEntry = new ZipEntry (sFilename);
            oOutput.putNextEntry (oEntry);
            int iCount;
            while ((iCount = oOrigin.read (aData, 0, BUFFER_SIZE)) != - 1) {
                oOutput.write (aData, 0, iCount);
            }
            oOrigin.close ();
        }
        oOutput.close ();
    } catch (Exception e) {
        AgentLogger.getInstance ().error (e);
        return false;
    }
    return true;
}


-----Function Pair=262=-----==

public static void zipFilesToZipFile (String dirPath, File file, ZipOutputStream zouts) {
    FileInputStream fin = null;
    ZipEntry entry = null;
    byte [] buf = new byte [4096];
    int readByte = 0;
    if (file.isFile ()) {
        try {
            fin = new FileInputStream (file);
            entry = new ZipEntry (getEntryName (dirPath, file));
            zouts.putNextEntry (entry);
            while ((readByte = fin.read (buf)) != - 1) {
                zouts.write (buf, 0, readByte);
            }
            zouts.closeEntry ();
            fin.close ();
            System.out.println ("添加文件" + file.getAbsolutePath () + "到zip文件中!");
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


private byte [] importTaskListData (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        String out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Your current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        return "Security Warning: The Security Session ID you entered is not correct.".getBytes ();
    }
    boolean append = "append".equalsIgnoreCase (urlData.getParameter ("data_action"));
    String data = urlData.getParameter ("data");
    if (data != null && data.length () > 0) {
        store.importTaskList (data.trim (), append);
    }
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/SystemDataRes?action=08\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=263=-----==

public static InputStream getResourceAsStream (String url) throws BlogunityException {
    if (log.isDebugEnabled ()) {
        log.debug ("Getting InputStream for requested resource url=" + url);
    }
    if (url.charAt (0) != '/') url = "/" + url;
    String mainDataDirectory = BlogunityManager.getSystemConfiguration ().getDataDir ();
    File f = new File (mainDataDirectory, url);
    if (f.exists () && f.isFile () && f.canRead ()) {
        FileInputStream in;
        try {
            in = new FileInputStream (f);
            return in;
        } catch (FileNotFoundException e) {
            log.error ("getThemeResourceAsStream(String)", e);
            throw new BlogunityException (I18NStatusFactory.create (I18N.ERRORS.RESOURCE_NOT_FOUND, url));
        }
    }
    throw new BlogunityException (I18NStatusFactory.create (I18N.ERRORS.RESOURCE_NOT_FOUND, url));
}


private static void writeJarFile (ZipOutputStream myZip) throws Exception {
    myZip.putNextEntry (new ZipEntry ("org/ea/Extractor.class"));
    String p = System.getProperty ("java.class.path");
    ZipInputStream myJar = new ZipInputStream (new FileInputStream (p));
    ZipEntry ze = null;
    while ((ze = myJar.getNextEntry ()) != null) {
        if (ze.getName ().compareTo ("org/ea/Extractor.class") == 0) {
            int i = 0;
            while ((i = myJar.read ()) != - 1) {
                myZip.write (i);
            }
        }
    }
    myJar.close ();
    myZip.closeEntry ();
}


-----Function Pair=264=-----==

public static void saveProject (TProject project, File zipFile) throws ParserConfigurationException, IOException, TransformerException {
    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance ();
    DocumentBuilder domBuilder = domFactory.newDocumentBuilder ();
    Document doc = domBuilder.newDocument ();
    doc.appendChild (project.XMLEncode (doc));
    TProjectHandler.cleanTempDirectory ();
    TProjectHandler.copyCurrentToTemp (TAttributeEncoder.getFilePaths (doc));
    File file = new File (TProjectHandler.getTempDirectory (), "project.xml");
    BufferedWriter bufferWriter = new BufferedWriter (new OutputStreamWriter (new FileOutputStream (file), "UTF-8"));
    TransformerFactory transformerFactory = TransformerFactory.newInstance ();
    Transformer transformer = transformerFactory.newTransformer ();
    DOMSource source = new DOMSource (doc);
    StreamResult result = new StreamResult (bufferWriter);
    transformer.transform (source, result);
    bufferWriter.close ();
    TProjectHandler.saveZip (zipFile);
    TProjectHandler.cleanTempDirectory ();
}


private byte [] showEmailOptions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "EmailOptions.html");
    template.replaceAll ("$emailTo$", store.getProperty ("email.to"));
    template.replaceAll ("$emailFrom$", store.getProperty ("email.from"));
    template.replaceAll ("$emailServer$", store.getProperty ("email.server.address"));
    template.replaceAll ("$emailPort$", store.getProperty ("email.server.port"));
    if ("1".equals (store.getProperty ("email.auth.enabled"))) template.replaceAll ("$emailAuthEnabled$", "CHECKED");
    else template.replaceAll ("$emailAuthEnabled$", "");
    template.replaceAll ("$emailAuthUser$", store.getProperty ("email.auth.user"));
    template.replaceAll ("$emailAuthPassword$", store.getProperty ("email.auth.password"));
    String security = store.getProperty ("email.security");
    if ("1".equals (security)) {
        template.replaceAll ("$emailSecurityNONE$", "");
        template.replaceAll ("$emailSecuritySTARTTLS$", "SELECTED");
    }
    else {
        template.replaceAll ("$emailSecurityNONE$", "SELECTED");
        template.replaceAll ("$emailSecuritySTARTTLS$", "");
    }
    String sendServerStarted = store.getProperty ("email.send.serverstarted");
    if ("1".equals (sendServerStarted)) template.replaceAll ("$sendServerStarted$", "CHECKED");
    else template.replaceAll ("$sendServerStarted$", "");
    String sendCapFinished = store.getProperty ("email.send.capfinished");
    if ("1".equals (sendCapFinished)) template.replaceAll ("$sendCapFinished$", "CHECKED");
    else template.replaceAll ("$sendCapFinished$", "");
    String sendEpgLoaded = store.getProperty ("email.send.epgloaded");
    if ("1".equals (sendEpgLoaded)) template.replaceAll ("$sendEpgLoaded$", "CHECKED");
    else template.replaceAll ("$sendEpgLoaded$", "");
    String sendOnWarning = store.getProperty ("email.send.onwarning");
    if ("1".equals (sendOnWarning)) template.replaceAll ("$sendOnWarning$", "CHECKED");
    else template.replaceAll ("$sendOnWarning$", "");
    String sendWeeklyReport = store.getProperty ("email.send.weeklyreport");
    if ("1".equals (sendWeeklyReport)) template.replaceAll ("$sendWeeklyReport$", "CHECKED");
    else template.replaceAll ("$sendWeeklyReport$", "");
    String sendFreeSpaceLow = store.getProperty ("email.send.freespacelow");
    if ("1".equals (sendFreeSpaceLow)) template.replaceAll ("$sendFreeSpaceLow$", "CHECKED");
    else template.replaceAll ("$sendFreeSpaceLow$", "");
    return template.getPageBytes ();
}


-----Function Pair=265=-----==

public void exportComplete (int ppid, OutputStream out, String baseTempPath) {
    BASE64Encoder encoder = new BASE64Encoder ();
    ProjectExporter exporter = new ProjectExporter ();
    Document doc = exporter.createProjectDoc ();
    List < Plan > list = null;
    try {
        list = em.createQuery ("select p from Plan p where p.planProperties.id = " + ppid).getResultList ();
    } catch (Exception e1) {
        list = new ArrayList < Plan > ();
        FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
        log.error ("Could not load planProperties: ", e1);
    }
    try {
        if (list.size () != 1) {
            FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "Skipping the export of the plan with properties" + ppid + ": Couldnt load.");
        }
        else {
            String tempPath = baseTempPath;
            File tempDir = new File (tempPath);
            tempDir.mkdirs ();
            List < Integer > uploadIDs = new ArrayList < Integer > ();
            List < Integer > recordIDs = new ArrayList < Integer > ();
            try {
                exporter.addProject (list.get (0), doc, uploadIDs, recordIDs);
                writeBinaryObjects (recordIDs, uploadIDs, tempPath, encoder);
                XMLWriter writer = new XMLWriter (new FileOutputStream ("/tmp/testout" + System.currentTimeMillis () + ".xml"));
                writer.write (doc);
                writer.close ();
                addBinaryData (doc, out, tempPath);
            } catch (IOException e) {
                FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
                log.error ("Could not open response-outputstream: ", e);
            } catch (TransformerException e) {
                FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
                log.error (e);
            }
        }
    } finally {
        list.clear ();
        list = null;
        em.clear ();
        System.gc ();
    }
}


public boolean install (File zipFile) {
    final String projectName = IndicatorProjectManager.getProjectName (zipFile);
    if (projectName == null) {
        return false;
    }
    final String jHotDrawFilename = projectName + JHOTDRAW_RESERVE_WORD + ".xml";
    final String operatorIndicatorFilename = projectName + ".xml";
    boolean status = true;
    ZipInputStream in = null;
    try {
        in = new ZipInputStream (new FileInputStream (zipFile));
        ZipEntry zipEntry = null;
        while ((zipEntry = in.getNextEntry ()) != null) {
            final String name = zipEntry.getName ();
            String outFilename = null;
            if (name.equalsIgnoreCase (operatorIndicatorFilename)) {
                outFilename = this.getOperatorIndicatorFilename (projectName);
            }
            else if (name.equalsIgnoreCase (jHotDrawFilename)) {
                outFilename = this.getJHotDrawFilename (projectName);
            }
            else {
                assert (false);
            }
            OutputStream out = null;
            try {
                out = new FileOutputStream (outFilename);
                byte [] buf = new byte [1024];
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
            } finally {
                Utils.close (out);
                Utils.closeEntry (in);
            }
        }
    } catch (IOException ex) {
        log.error (null, ex);
        status = false;
    } finally {
        Utils.close (in);
    }
    if (status == false) {
        new File (this.getOperatorIndicatorFilename (projectName)).delete ();
        new File (this.getJHotDrawFilename (projectName)).delete ();
        return false;
    }
    final OperatorIndicator operatorIndicator = (OperatorIndicator) Utils.fromXML (OperatorIndicator.class, this.getOperatorIndicatorFilename (projectName));
    if (operatorIndicator == null || operatorIndicator.getType () != this.preferredOperatorIndicatorType) {
        new File (this.getOperatorIndicatorFilename (projectName)).delete ();
        new File (this.getJHotDrawFilename (projectName)).delete ();
        return false;
    }
    if (this.contains (projectName) == false) {
        this.projects.add (projectName);
    }
    return true;
}


-----Function Pair=266=-----==

public void test_main_class_in_another_zip () throws Exception {
    File fooZip = File.createTempFile ("hyts_", ".zip");
    File barZip = File.createTempFile ("hyts_", ".zip");
    fooZip.deleteOnExit ();
    barZip.deleteOnExit ();
    Manifest man = new Manifest ();
    Attributes att = man.getMainAttributes ();
    att.put (Attributes.Name.MANIFEST_VERSION, "1.0");
    att.put (Attributes.Name.MAIN_CLASS, "foo.bar.execjartest.Foo");
    att.put (Attributes.Name.CLASS_PATH, fooZip.getName ());
    File resources = Support_Resources.createTempFolder ();
    ZipOutputStream zoutFoo = new ZipOutputStream (new FileOutputStream (fooZip));
    zoutFoo.putNextEntry (new ZipEntry ("foo/bar/execjartest/Foo.class"));
    zoutFoo.write (getResource (resources, "hyts_Foo.ser"));
    zoutFoo.close ();
    ZipOutputStream zoutBar = new ZipOutputStream (new FileOutputStream (barZip));
    zoutBar.putNextEntry (new ZipEntry ("META-INF/MANIFEST.MF"));
    man.write (zoutBar);
    zoutBar.putNextEntry (new ZipEntry ("foo/bar/execjartest/Bar.class"));
    zoutBar.write (getResource (resources, "hyts_Bar.ser"));
    zoutBar.close ();
    String [] args = new String [] {"-jar", barZip.getAbsolutePath ()};
    String res = Support_Exec.execJava (args, null, false);
    assertTrue ("Error executing JAR : result returned was incorrect.", res.startsWith ("FOOBAR"));
}


public void write (ZipOutputStream out, DataOutputStream dos, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegionTexts [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegionTexts.length; i ++) {
            int currentStart = sortedRegionTexts [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegionTexts.length; i ++) {
            int diff = sortedRegionTexts [i].stop - sortedRegionTexts [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    fileType = fileType + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = null;
    try {
        out.putNextEntry (new ZipEntry (sliceInfo.getSliceName ()));
        dos.writeUTF (header);
        dos.writeInt (sortedRegionTexts [0].start);
        int bp = sortedRegionTexts [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionTexts [0].stop - sortedRegionTexts [0].start);
                dos.writeUTF (sortedRegionTexts [0].text);
                for (int i = 1; i < sortedRegionTexts.length; i ++) {
                    int currentStart = sortedRegionTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeInt (sortedRegionTexts [i].stop - sortedRegionTexts [i].start);
                    dos.writeUTF (sortedRegionTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionTexts [0].stop - sortedRegionTexts [0].start - 32768));
                dos.writeUTF (sortedRegionTexts [0].text);
                for (int i = 1; i < sortedRegionTexts.length; i ++) {
                    int currentStart = sortedRegionTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeShort ((short) (sortedRegionTexts [i].stop - sortedRegionTexts [i].start - 32768));
                    dos.writeUTF (sortedRegionTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionTexts [0].stop - sortedRegionTexts [0].start);
                dos.writeUTF (sortedRegionTexts [0].text);
                for (int i = 1; i < sortedRegionTexts.length; i ++) {
                    int currentStart = sortedRegionTexts [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeInt (sortedRegionTexts [i].stop - sortedRegionTexts [i].start);
                    dos.writeUTF (sortedRegionTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionTexts [0].stop - sortedRegionTexts [0].start - 32768));
                dos.writeUTF (sortedRegionTexts [0].text);
                for (int i = 1; i < sortedRegionTexts.length; i ++) {
                    int currentStart = sortedRegionTexts [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeShort ((short) (sortedRegionTexts [i].stop - sortedRegionTexts [i].start - 32768));
                    dos.writeUTF (sortedRegionTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        out.closeEntry ();
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (out);
        USeqUtilities.safeClose (dos);
    }
}


-----Function Pair=267=-----==

public static void unzip (String srcZipFile, String destItem) throws Exception {
    File inFile = new File (srcZipFile);
    File outFolder = new File (destItem);
    ZipInputStream in = new ZipInputStream (new FileInputStream (inFile));
    OutputStream out = null;
    ZipEntry entry;
    while ((entry = in.getNextEntry ()) != null) {
        int count;
        byte data [] = new byte [BUFFER];
        String fullpath = outFolder.getPath () + "\\" + entry.getName ();
        String dirs = fullpath.substring (0, fullpath.lastIndexOf ("\\"));
        File file = new File (dirs);
        if (! file.exists ()) {
            file.mkdirs ();
        }
        out = new FileOutputStream (fullpath);
        while ((count = in.read (data)) > 0) {
            out.write (data, 0, count);
        }
    }
    in.close ();
    out.close ();
}


private synchronized boolean delFile (String entryName) {
    if (entryName.trim ().length () == 0) return false;
    int buffer = 2048;
    byte [] data = new byte [buffer];
    FileInputStream fis;
    FileOutputStream fos;
    BufferedInputStream source;
    int count;
    try {
        File tempResFile = new File (resFileOnDisk.getCanonicalPath () + ".bak");
        if (! tempResFile.exists ()) tempResFile.createNewFile ();
        fis = new FileInputStream (resFileOnDisk);
        fos = new FileOutputStream (tempResFile);
        source = new BufferedInputStream (fis, buffer);
        while ((count = source.read (data, 0, buffer)) != - 1) {
            fos.write (data, 0, count);
        }
        fos.close ();
        source.close ();
        fis.close ();
        ZipFile oldZip = new ZipFile (tempResFile);
        resFile = null;
        fos = new FileOutputStream (resFileOnDisk);
        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (fos));
        Enumeration e = oldZip.entries ();
        while (e.hasMoreElements ()) {
            ZipEntry tmpEntry = (ZipEntry) e.nextElement ();
            if (! tmpEntry.getName ().equals (entryName)) {
                ZipEntry newEntry = new ZipEntry (tmpEntry.getName ());
                newEntry.setComment (tmpEntry.getComment ());
                zos.putNextEntry (newEntry);
                source = new BufferedInputStream (oldZip.getInputStream (tmpEntry), buffer);
                while ((count = source.read (data, 0, buffer)) != - 1) {
                    zos.write (data, 0, count);
                }
                source.close ();
            }
        }
        zos.close ();
        fos.close ();
        resFile = new ZipFile (resFileOnDisk);
        oldZip = null;
        tempResFile.deleteOnExit ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    return true;
}


-----Function Pair=268=-----==

public static void deleteEmptyFolders (String folderName) throws FileNotFoundException {
    File aStartingDir = new File (folderName);
    List < File > emptyFolders = new ArrayList < File > ();
    findEmptyFoldersInDir (aStartingDir, emptyFolders);
    List < String > fileNames = new ArrayList < String > ();
    for (File f : emptyFolders) {
        String s = f.getAbsolutePath ();
        fileNames.add (s);
    }
    for (File f : emptyFolders) {
        boolean isDeleted = f.delete ();
        if (isDeleted) {
        }
    }
}


private byte [] setServerProperty (HTTPurl urlData) throws Exception {
    String out = "";
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String [] parameter = urlData.getParameterList ();
    for (int x = 0; x < parameter.length; x ++) {
        if (! parameter [x].equals ("action") && ! parameter [x].equals ("sessionID")) {
            String value = urlData.getParameter (parameter [x]);
            if (value != null) {
                store.setServerProperty (parameter [x], value);
            }
        }
    }
    return out.getBytes ();
}


-----Function Pair=269=-----==

private Vector getWorkflow (String userID, String workflowID) {
    Vector v = null;
    try {
        ServiceType st = InformationBase.getI ().getService ("wfs", "portal", new Hashtable (), new Vector ());
        PortalWfsClient pc = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
        pc.setServiceURL (st.getServiceUrl ());
        pc.setServiceID (st.getServiceID ());
        ComDataBean commdata = new ComDataBean ();
        PORTAL = this.getPortalID ();
        commdata.setPortalID (PORTAL);
        commdata.setUserID (userID);
        commdata.setWorkflowID (workflowID);
        v = pc.getWorkflowConfigData (commdata);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return v;
}


public static File copyFileAs (String path, String newName) {
    File src = new File (path);
    File dest = new File (newName);
    try {
        if (! dest.exists ()) {
            dest.createNewFile ();
        }
        FileChannel source = new FileInputStream (src).getChannel ();
        FileChannel destination = new FileOutputStream (dest).getChannel ();
        destination.transferFrom (source, 0, source.size ());
        source.close ();
        destination.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return dest;
}


-----Function Pair=270=-----==

private void setInlineXML (Entry entry, DatastreamXMLMetadata ds) throws UnsupportedEncodingException, StreamIOException {
    String content;
    if (m_obj.hasContentModel (Models.SERVICE_DEPLOYMENT_3_0) && (ds.DatastreamID.equals ("SERVICE-PROFILE") || ds.DatastreamID.equals ("WSDL"))) {
        content = DOTranslationUtility.normalizeInlineXML (new String (ds.xmlContent, m_encoding), m_transContext);
    }
    else {
        content = new String (ds.xmlContent, m_encoding);
    }
    if (m_format.equals (ATOM_ZIP1_1)) {
        String name = ds.DSVersionID + ".xml";
        try {
            m_zout.putNextEntry (new ZipEntry (name));
            InputStream is = new ByteArrayInputStream (content.getBytes (m_encoding));
            IOUtils.copy (is, m_zout);
            m_zout.closeEntry ();
            is.close ();
        } catch (IOException e) {
            throw new StreamIOException (e.getMessage (), e);
        }
        IRI iri = new IRI (name);
        entry.setSummary (ds.DSVersionID);
        entry.setContent (iri, ds.DSMIME);
    }
    else {
        entry.setContent (content, ds.DSMIME);
    }
}


public static RegionTextData merge (ArrayList < RegionTextData > pdAL) {
    RegionTextData [] pdArray = new RegionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionTexts.length;
    RegionText [] concatinate = new RegionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionText [] slice = pdArray [i].sortedRegionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionTextData (concatinate, sliceInfo);
}


-----Function Pair=271=-----==

public static boolean replaceAndCopyFile (final Reader _fileFrom, final File _fileTo, Map < String, String > oldNew, final String _encoding) {
    boolean r = true;
    BufferedReader reader = null;
    Writer writer = null;
    try {
        reader = new BufferedReader (_fileFrom);
        writer = new BufferedWriter (_encoding == null ? new FileWriter (_fileTo) : new OutputStreamWriter (new FileOutputStream (_fileTo), _encoding));
        final StringBuffer b = new StringBuffer (8192);
        int lu;
        while ((lu = reader.read ()) != - 1) {
            b.append ((char) lu);
        }
        String n = b.toString ();
        for (Map.Entry < String, String > entry : oldNew.entrySet ()) {
            n = FuLib.replace (n, entry.getKey (), entry.getValue ());
        }
        writer.write (n);
        writer.flush ();
    } catch (final FileNotFoundException io) {
        FuLog.error ("file not found " + io.getMessage ());
        r = false;
    } catch (final UnsupportedEncodingException io) {
        FuLog.error ("encode not supported " + io.getMessage ());
        r = false;
    } catch (final IOException io) {
        FuLog.error ("i/o error " + io.getMessage ());
        r = false;
    } finally {
        try {
            if (reader != null) {
                reader.close ();
            }
            if (writer != null) {
                writer.close ();
            }
        } catch (final IOException _io) {
        }
    }
    return r;
}


public static void extract (File zipFilePath, String namePrefix, String nameEncoding, EntryReader entryReader) throws Exception {
    Assert.Arg.notNull (zipFilePath, "zipFilePath");
    Assert.Arg.notNull (nameEncoding, "nameEncoding");
    Assert.Arg.notNull (entryReader, "entryReader");
    ZipFile zipFile = new ZipFile (zipFilePath, nameEncoding);
    try {
        for (Enumeration e = zipFile.getEntries (); e.hasMoreElements ();) {
            ZipEntry entry = (ZipEntry) e.nextElement ();
            if (entry.isDirectory ()) {
                continue;
            }
            String fileName = entry.getName ();
            if (namePrefix != null) {
                if (! entry.getName ().startsWith (namePrefix)) {
                    continue;
                }
                fileName = fileName.substring (namePrefix.length ());
            }
            InputStream input = zipFile.getInputStream (entry);
            try {
                entryReader.readEntry (fileName, input);
            } finally {
                input.close ();
            }
        }
    } finally {
        if (zipFile != null) zipFile.close ();
    }
}


-----Function Pair=272=-----==

public Document readDocumentFromFile (String fileName) {
    try {
        SAXBuilder builder = new SAXBuilder ();
        URL url = getURL (fileName);
        if (fileName.substring (fileName.lastIndexOf ("."), fileName.length ()).equalsIgnoreCase (".aopz")) {
            FileInputStream fileInputStream = null;
            BufferedInputStream inputStream;
            if (url == null) {
                fileInputStream = new FileInputStream (fileName);
                inputStream = new BufferedInputStream (fileInputStream);
            }
            else {
                inputStream = new BufferedInputStream (url.openStream ());
                remoteFile = true;
            }
            ZipInputStream zipInputEntry = new ZipInputStream (inputStream);
            ZipEntry entry = zipInputEntry.getNextEntry ();
            if (entry != null) {
                String temp = readZIPEntry (zipInputEntry, (int) entry.getSize ());
                Document doc = builder.build (new StringReader (temp));
                zipInputEntry.close ();
                if (url == null) fileInputStream.close ();
                return doc;
            }
            return null;
        }
        else {
            if (url != null) return builder.build (url.openStream ());
            else return builder.build (new File (fileName));
        }
    } catch (JDOMException e) {
        e.printStackTrace ();
        return null;
    } catch (NullPointerException e) {
        e.printStackTrace ();
        return null;
    } catch (IOException e) {
        e.printStackTrace ();
        return null;
    }
}


public static void unzip (File sourceZipFile, File unzipDestinationDirectory, FileFilter filter) throws IOException {
    unzipDestinationDirectory.mkdirs ();
    if (! unzipDestinationDirectory.exists ()) {
        throw new IOException ("Unable to create destination directory: " + unzipDestinationDirectory);
    }
    ZipFile zipFile;
    zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
    Enumeration < ? extends ZipEntry > zipFileEntries = zipFile.entries ();
    while (zipFileEntries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) zipFileEntries.nextElement ();
        if (! entry.isDirectory ()) {
            String currentEntry = entry.getName ();
            File destFile = new File (unzipDestinationDirectory, currentEntry);
            if (filter == null || filter.accept (destFile)) {
                File destinationParent = destFile.getParentFile ();
                destinationParent.mkdirs ();
                BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (entry));
                FileOutputStream fos = new FileOutputStream (destFile);
                IOUtils.copyLarge (is, fos);
                fos.flush ();
                IOUtils.closeQuietly (fos);
            }
        }
    }
    zipFile.close ();
}


-----Function Pair=273=-----==

public synchronized void applyRecursiveTarDiffPatch (ZipFile oldJar, ZipFile jarDiff, ZipEntry entry, Patcher.PatchDelegate delegate, JarOutputStream jos, String tarName) throws Exception {
    ZipEntry oldEntry = oldJar.getEntry (tarName);
    logger.info ("old entry " + oldEntry.getName () + " tarName:" + tarName);
    String tarExt = null;
    if (tarName.endsWith (".tar.gz")) tarExt = ".tar.gz";
    else tarExt = ".tar";
    InputStream oldJIS = null;
    InputStream jardiffIS = null;
    File oldEntryTempFile = null;
    File entryTarDiff = null;
    try {
        oldJIS = oldJar.getInputStream (oldEntry);
        oldEntryTempFile = InputStreamUtil.writeToFile (oldJIS, null, tarExt, null);
        jardiffIS = jarDiff.getInputStream (entry);
        entryTarDiff = InputStreamUtil.writeToFile (jardiffIS, null, tarExt, null);
    } finally {
        if (oldJIS != null) oldJIS.close ();
        if (jardiffIS != null) jardiffIS.close ();
    }
    File tempEntryFile = File.createTempFile ("jdp", tarExt);
    tempEntryFile.deleteOnExit ();
    FileOutputStream fileOutputStream = new FileOutputStream (tempEntryFile);
    BufferedOutputStream entryOutputStream = new BufferedOutputStream (fileOutputStream, 2048);
    (new TarDiffPatcher ()).applyPatch (delegate, oldEntryTempFile.getAbsolutePath (), entryTarDiff.getAbsolutePath (), entryOutputStream);
    entryOutputStream.close ();
    FileInputStream entryInputStream = new FileInputStream (tempEntryFile);
    writeEntry (jos, new ZipEntry (tarName), entryInputStream);
    entryInputStream.close ();
    tempEntryFile.delete ();
    oldEntryTempFile.delete ();
    entryTarDiff.delete ();
}


protected void saveOnlyIfChangedWithMemoryBuffer (Map < ?, ? > options) throws IOException {
    URIConverter uriConverter = getURIConverter ();
    class MyByteArrayOutputStream extends ByteArrayOutputStream {
        public byte [] buffer () {
            return buf;
        } public int length () {
            return count;
        }
    }
    MyByteArrayOutputStream memoryBuffer = new MyByteArrayOutputStream ();
    try {
        save (memoryBuffer, options);
    } finally {
        memoryBuffer.close ();
    }
    byte [] newContentBuffer = memoryBuffer.buffer ();
    int length = memoryBuffer.length ();
    ByteArrayInputStream inputStream = new ByteArrayInputStream (newContentBuffer);
    InputStream underlyingInputStream = getUnderlyingInputStream (inputStream, options);
    byte [] underlyingNewContentBuffer;
    int underlyingLength;
    if (inputStream == underlyingInputStream) {
        underlyingNewContentBuffer = newContentBuffer;
        underlyingLength = length;
    }
    else {
        ByteArrayOutputStream bytes = new ByteArrayOutputStream ();
        byte [] buffer = new byte [4000];
        for (int count = underlyingInputStream.read (buffer); count > 0; count = underlyingInputStream.read (buffer)) {
            bytes.write (buffer, 0, count);
        }
        bytes.close ();
        underlyingInputStream.close ();
        underlyingNewContentBuffer = bytes.toByteArray ();
        underlyingLength = underlyingNewContentBuffer.length;
    }
    boolean equal = true;
    InputStream oldContents = null;
    try {
        oldContents = getUnderlyingInputStream (uriConverter.createInputStream (getURI (), defaultLoadOptions), options);
    } catch (IOException exception) {
        equal = false;
    }
    if (oldContents != null) {
        try {
            byte [] oldContentBuffer = new byte [underlyingLength];
            int count = oldContents.read (oldContentBuffer);
            while (count > 0 && count < underlyingLength) {
                int more = oldContents.read (oldContentBuffer, count, oldContentBuffer.length - count);
                if (more <= 0) {
                    break;
                }
                else {
                    count += more;
                }
            }
            if (count == underlyingLength && oldContents.read () == - 1) {
                for (int i = 0; i < underlyingLength; ++ i) {
                    if (oldContentBuffer [i] != underlyingNewContentBuffer [i]) {
                        equal = false;
                        break;
                    }
                }
            }
            else {
                equal = false;
            }
        } finally {
            oldContents.close ();
        }
    }
    if (! equal) {
        Map < ?, ? > response = options == null ? null : (Map < ?, ? >) options.get (URIConverter.OPTION_RESPONSE);
        if (response == null) {
            response = new HashMap < Object, Object > ();
        }
        OutputStream newContents = uriConverter.createOutputStream (getURI (), new ExtensibleURIConverterImpl.OptionsMap (URIConverter.OPTION_RESPONSE, response, options));
        try {
            newContents.write (newContentBuffer, 0, length);
        } finally {
            newContents.close ();
            Long timeStamp = (Long) response.get (URIConverter.RESPONSE_TIME_STAMP_PROPERTY);
            if (timeStamp != null) {
                setTimeStamp (timeStamp);
            }
        }
    }
}


-----Function Pair=274=-----==

private void xmlSchreibenDaten (String xmlName, String [] xmlSpalten, String [] datenArray) {
    int xmlMax = datenArray.length;
    try {
        writer.writeStartElement (xmlName);
        for (int i = 0; i < xmlMax; ++ i) {
            if (! datenArray [i].equals ("")) {
                writer.writeStartElement (xmlSpalten [i]);
                writer.writeCharacters (datenArray [i]);
                writer.writeEndElement ();
            }
        }
        writer.writeEndElement ();
        writer.writeCharacters ("\n");
    } catch (Exception ex) {
        daten.fehler.fehlerMeldung (ex, "IoXml.xmlSchreibenDaten");
    }
}


public static int count (String str, File file) throws IOException {
    BufferedReader in = new BufferedReader (new FileReader (file), BUFFER_SIZE);
    File fout = new File (StringOperations.replace (file.toString (), ".txt", ".csv"));
    PrintStream out = new PrintStream (new BufferedOutputStream (new FileOutputStream (fout), BUFFER_SIZE));
    String linha;
    int result = 0;
    while ((linha = in.readLine ()) != null) {
        String linhaOriginal = linha;
        int soma = StringOperations.count (linha, str);
        if (soma != SHORT_COUNTER) {
            System.out.println (linhaOriginal);
        }
        result += soma;
    }
    in.close ();
    out.close ();
    return result;
}


-----Function Pair=275=-----==

public static String gz2String (InputStream fis) {
    StringBuffer output = new StringBuffer ();
    GZIPInputStream gzip_in_stream;
    try {
        BufferedInputStream source = new BufferedInputStream (fis);
        gzip_in_stream = new GZIPInputStream (source);
        BufferedReader reader = FileEncoding.getReader (gzip_in_stream);
        String gutti;
        while ((gutti = reader.readLine ()) != null) {
            output.append (gutti + System.getProperty ("line.separator"));
        }
    } catch (IOException ex) {
        System.out.println ("IO Exception while unzipping data!");
        ex.printStackTrace ();
    }
    return output.toString ();
}


private Collection writeData (ZipOutputStream zipOut) throws IOException {
    zipOut.putNextEntry (new ZipEntry (DATA_FILE_NAME));
    ExportedDataValueIterator baseIter = new ExportedDataValueIterator (ctx.getData (), ctx.getHierarchy (), filter, metricsIncludes, metricsExcludes);
    DefaultDataExportFilter ddef;
    TaskListDataWatcher taskListWatcher;
    if (baseIter.isUsingExplicitNames ()) {
        logger.fine ("Using explicit name approach");
        Iterator taskListSearcher = new ExportedDataValueIterator (ctx.getData (), ctx.getHierarchy (), filter, null, Collections.singleton ("."));
        taskListWatcher = new TaskListDataWatcher (taskListSearcher);
        while (taskListWatcher.hasNext ()) {
            ThreadThrottler.tick ();
            taskListWatcher.next ();
        }
        ddef = new DefaultDataExportFilter (baseIter);
        ddef.setSkipProcessAutoData (false);
        ddef.setSkipToDateData (false);
        ddef.setSkipNodesAndLeaves (false);
        ddef.init ();
    }
    else {
        logger.fine ("Using pattern-based name approach");
        taskListWatcher = new TaskListDataWatcher (baseIter);
        ddef = new DefaultDataExportFilter (taskListWatcher);
        ddef.setIncludes (metricsIncludes);
        ddef.setExcludes (metricsExcludes);
        ddef.init ();
    }
    DataExporter exp = new DataExporterXMLv1 ();
    exp.export (zipOut, ddef);
    baseIter.iterationFinished ();
    zipOut.closeEntry ();
    return taskListWatcher.getTaskListNames ();
}


-----Function Pair=276=-----==

public static boolean makeZip (final Shell shell, String folder) {
    String zipName;
    FileDialog dialog = new FileDialog (shell, SWT.SAVE);
    dialog.setFilterNames (new String [] {"Zip Files"});
    dialog.setFilterExtensions (new String [] {"*.zip", "*.*"});
    try {
        File f = new File (folder);
        File [] filenames = f.listFiles ();
        if (filenames.length == 0) return false;
        dialog.setFilterPath (Options.getOptionValue (Options.LOGS_FOLDER));
        dialog.setFileName (f.getName () + ".zip");
        zipName = dialog.open ();
        if (zipName == null || zipName.equals ("")) {
            return false;
        }
        try {
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipName));
            zipRecursively (out, f, "");
            out.closeEntry ();
            out.close ();
            return true;
        } catch (IOException e) {
            e.printStackTrace ();
        }
    } catch (OptionNotFoundException e1) {
        e1.printStackTrace ();
    }
    return false;
}


public static Instance getById (int id) throws SQLException, InstanceClassMustBeSourceException {
    Instance c = cache.getCached (id);
    if (c != null) {
        return c;
    }
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT idInstance,  md5, name FROM " + table + " WHERE idInstance=?");
    st.setInt (1, id);
    ResultSet rs = st.executeQuery ();
    Instance i = new Instance ();
    if (rs.next ()) {
        i.setId (rs.getInt ("idInstance"));
        i.setMd5 (rs.getString ("md5"));
        i.setName (rs.getString ("name"));
        ArrayList < Instance > tmp = new ArrayList < Instance > ();
        tmp.add (i);
        InstanceHasPropertyDAO.assign (tmp);
        i.setSaved ();
        cache.cache (i);
        return i;
    }
    rs.close ();
    return null;
}


-----Function Pair=277=-----==

private void zipFiles (final File file) throws IOException {
    if (file.isDirectory ()) {
        File [] fList;
        List < File > foundedFiles;
        if (null != this.fileFilter) {
            final File [] tmpfList = file.listFiles (this.fileFilter);
            final List < File > foundedDirs = FileSearchUtils.listDirs (file);
            if (0 < foundedDirs.size ()) {
                final List < File > tmp = Arrays.asList (tmpfList);
                foundedDirs.addAll (tmp);
                foundedFiles = foundedDirs;
            }
            else {
                final List < File > tmp = Arrays.asList (tmpfList);
                foundedFiles = tmp;
            }
        }
        else {
            fList = file.listFiles ();
            final List < File > tmp = Arrays.asList (fList);
            foundedFiles = tmp;
        }
        for (int i = 0; i < foundedFiles.size (); i ++) {
            this.zipFiles (foundedFiles.get (i));
        }
    }
    else {
        this.addFile (file);
    }
}


public static void emptyDirectory (File directory) throws IOException {
    assertNotNull (directory, "Cannot empty the directory of a null argument");
    assertArgument (directory.exists (), "The directory [" + directory + "] does not exist.");
    assertArgument (directory.isDirectory (), "The path [" + directory + "] is not a directory.");
    File [] files = directory.listFiles ();
    if (files == null) {
        throw new IOException ("Failed to list contents of " + directory);
    }
    IOException exception = null;
    for (int i = 0; i < files.length; i ++) {
        File file = files [i];
        try {
            forceDelete (file);
        } catch (IOException es) {
            exception = es;
        }
    }
    if (null != exception) {
        throw exception;
    }
}


-----Function Pair=278=-----==

private List parseDuplicateFiles (String responseBodyAsString) {
    List result = new ArrayList ();
    LineNumberReader reader = new LineNumberReader (new InputStreamReader (new ByteArrayInputStream (responseBodyAsString.getBytes ())));
    try {
        String trim;
        for (String read = reader.readLine (); read != null; read = reader.readLine ()) {
            trim = read.trim ();
            if (! (trim.equals ("") || trim.equals ("\n"))) {
                result.add (read);
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return result;
}


public boolean doLogin (String [] msg) {
    if (isAnonymous ()) {
        return true;
    }
    try {
        getInfo ();
        List entries = new ArrayList ();
        entries.add (HttpFormEntry.hidden (ARG_RESPONSE, RESPONSE_XML));
        entries.add (HttpFormEntry.hidden (ARG_USER_PASSWORD, getPassword ()));
        entries.add (HttpFormEntry.hidden (ARG_USER_ID, getUser ()));
        String [] result = doPost (URL_USER_LOGIN, entries);
        if (result [0] != null) {
            msg [0] = "Error logging in: " + result [0];
            return false;
        }
        String contents = result [1];
        Element root = XmlUtil.getRoot (contents);
        String body = XmlUtil.getChildText (root).trim ();
        if (responseOk (root)) {
            sessionId = body;
            return true;
        }
        else {
            msg [0] = body;
            return false;
        }
    } catch (java.io.IOException exc) {
        exc.printStackTrace ();
        msg [0] = "Could not connect to server: " + getHostname ();
    } catch (Exception exc) {
        msg [0] = "An error occurred: " + exc + "\n";
    }
    return false;
}


-----Function Pair=279=-----==

private void writeDicomFile (java.io.File dcmFile, DicomObject blobAttrs, OutputStream out, byte [] buf) throws FileNotFoundException, IOException {
    DicomInputStream dis = new DicomInputStream (new FileInputStream (FileUtils.resolve (dcmFile)));
    dis.setHandler (new StopTagInputHandler (Tag.PixelData));
    DicomObject attrs = dis.readDicomObject ();
    if (! blobAttrs.getString (Tag.SOPInstanceUID).equals (attrs.getString (Tag.MediaStorageSOPInstanceUID))) {
        log.info ("SOPInstanceUID has been changed! correct MediaStorageSOPInstanceUID from " + attrs.getString (Tag.MediaStorageSOPInstanceUID) + " to " + blobAttrs.getString (Tag.SOPInstanceUID));
        attrs.putString (Tag.MediaStorageSOPInstanceUID, VR.UI, blobAttrs.getString (Tag.SOPInstanceUID));
    }
    if (! blobAttrs.getString (Tag.SOPClassUID).equals (attrs.getString (Tag.MediaStorageSOPClassUID))) {
        log.info ("SOPClassUID has been changed! correct MediaStorageSOPClassUID from " + attrs.getString (Tag.MediaStorageSOPClassUID) + " to " + blobAttrs.getString (Tag.SOPClassUID));
        attrs.putString (Tag.MediaStorageSOPClassUID, VR.UI, blobAttrs.getString (Tag.SOPClassUID));
    }
    blobAttrs.copyTo (attrs);
    DicomOutputStream dos = new DicomOutputStream (out);
    dos.setAutoFinish (false);
    dos.writeDicomFile (attrs);
    if (dis.tag () >= Tag.PixelData) {
        dos.writeHeader (dis.tag (), dis.vr (), dis.valueLength ());
    }
    int len;
    while (dis.available () > 0) {
        len = dis.read (buf);
        out.write (buf, 0, len);
    }
}


void test (JavaFileObject fo, File dir, String p) {
    System.err.println ("Test: " + fo);
    String expect = dir.isDirectory () ? new File (dir, p).getPath () : (dir.getPath () + "(" + p + ")");
    String found = fo.getName ();
    String found2 = found.replaceAll ("lib([\\\\/])ct.sym\\(META-INF/sym/rt.jar/", "jre$1lib$1rt.jar(");
    if (! expect.equals (found2)) {
        System.err.println ("expected: " + expect);
        System.err.println ("   found: " + found);
        if (! found.equals (found2)) System.err.println ("  found2: " + found2);
        error ("Failed: " + fo);
    }
    foundClasses.add (fo.getClass ().getSimpleName ());
    if (found.contains ("(")) {
        foundJars.add (new File (found.substring (0, found.indexOf ("("))).getName ());
    }
}


-----Function Pair=280=-----==

public void validatorXSL (Workbook workbook) throws ApplicationException {
    int numOfSheets = workbook.getNumberOfSheets ();
    for (int i = 0; i < numOfSheets; i ++) {
        Sheet sheet = workbook.getSheet (i);
        for (int j = 1; j < sheet.getRows (); j ++) {
            Cell [] cellAry = sheet.getRow (j);
            try {
                for (int k = 0; k < cellAry.length; k ++) {
                    if (k == 1 && ! Utility.isEmpty (cellAry [1].getContents ())) {
                        if (Utility.isEmpty (cellAry [k - 1].getContents ()) || cellAry [k - 1].getContents () == null) {
                            throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
                        }
                    }
                    else if (k == 2 && ! Utility.isEmpty (cellAry [2].getContents ())) {
                        if (Utility.isEmpty (cellAry [k - 1].getContents ()) || cellAry [k - 1].getContents () == null) {
                            throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
                        }
                    }
                    if (k == 2) {
                        String [] splitAry = TextUtility.splitString (TextUtility.noNull (cellAry [2].getContents ()).trim (), "//");
                        for (int loop = 0; loop < splitAry.length; loop ++) {
                            TextUtility.stringValidation (splitAry [loop]);
                        }
                    }
                    else {
                        TextUtility.stringValidation (cellAry [k].getContents ());
                    }
                }
            } catch (ApplicationException ex) {
                throw new ApplicationException (ErrorConstant.SYS_CHARACTER_ERROR);
            }
        }
    }
}


public static void createBugReport (File reportFile, Throwable exception, String userMessage, Process process, String logMessage, File [] attachments) throws IOException {
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (reportFile));
    zipOut.setComment ("RapidMiner bug report - generated " + new Date ());
    write ("message.txt", "User message", userMessage, zipOut);
    write ("_process.xml", "Process as in memory.", process.getRootOperator ().getXML (false), zipOut);
    if (process.getProcessLocation () != null) {
        try {
            String contents = process.getProcessLocation ().getRawXML ();
            write (process.getProcessLocation ().getShortName (), "Raw process file in repository.", contents, zipOut);
        } catch (Throwable t) {
            write (process.getProcessLocation ().getShortName (), "Raw process file in repository.", "could not read: " + t, zipOut);
        }
    }
    write ("_log.txt", "Log message", logMessage, zipOut);
    write ("_properties.txt", "System properties, information about java version and operating system", getProperties (), zipOut);
    write ("_exception.txt", "Exception stack trace", getStackTrace (exception), zipOut);
    for (File attachment : attachments) writeFile (attachment, zipOut);
    zipOut.close ();
}


-----Function Pair=281=-----==

public static final void buildZipBall (ZipMap zipMap, String outputFilepath) throws Exception {
    String outFilename = outputFilepath;
    if (! outFilename.endsWith (".zip")) {
        outFilename += ".zip";
    }
    logger.info ("Build ZIP file <" + outputFilepath + ">");
    ZipOutputStream out;
    out = new ZipOutputStream (new FileOutputStream (outFilename));
    long file_size = 0;
    boolean full = false;
    for (String dir : zipMap.keySet ()) {
        Set < ZipEntryRef > zers = zipMap.get (dir);
        for (ZipEntryRef zer : zers) {
            String fileitem = zer.getUri ();
            byte [] buf = new byte [1024];
            FileInputStream in;
            File f;
            if ((f = new File (fileitem)).exists ()) {
                in = new FileInputStream (fileitem);
                file_size += f.length () / 1000000;
            }
            else if ((f = new File (fileitem + ".gz")).exists ()) {
                in = new FileInputStream (fileitem + ".gz");
                file_size += f.length () / 1000000;
            }
            else {
                logger.error ("File <" + fileitem + "> or <" + fileitem + ".gz> not found");
                continue;
            }
            logger.info ("Compress " + fileitem);
            ZipEntry ze = new ZipEntry (dir + "/" + (new File (fileitem)).getName ());
            out.putNextEntry (ze);
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.closeEntry ();
            if (file_size > MAX_SIZE) {
                logger.warn ("The size of zipped file exceed " + MAX_SIZE + "Mb: zipball truncated");
                full = true;
                break;
            }
        }
        if (full) {
            break;
        }
    }
    out.closeEntry ();
    out.close ();
}


private byte [] showAvailablePaths (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CapturePathsAvailable.html");
    StringBuffer buff = new StringBuffer ();
    template.replaceAll ("$title", "Available capture paths");
    String path = urlData.getParameter ("path");
    File [] files = null;
    String parent = "";
    if (path == null || path.length () == 0) {
        files = File.listRoots ();
        template.replaceAll ("$currentPath", "");
    }
    else {
        File thisPath = new File (path);
        files = thisPath.listFiles ();
        if (thisPath.getParentFile () != null) parent = thisPath.getParentFile ().getAbsolutePath ();
        String addLink = "";
        if (thisPath.exists ()) {
            addLink = " <a href='#' onClick=\"addPath('/servlet/SystemDataRes?action=32&path=" + URLEncoder.encode (thisPath.getAbsolutePath (), "UTF-8") + "');\">" + "<img alt='Add Path' border=0 src='/images/add.png' align='absmiddle' width='24' height='24'></a> " + thisPath.getAbsolutePath ();
        }
        template.replaceAll ("$currentPath", addLink);
        if (thisPath.getParentFile () != null && thisPath.getParentFile ().exists () == true) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (parent, "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(parent)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
        else {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(root)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
    }
    if (files == null) {
        files = new File [0];
    }
    int numberItems = 0;
    for (int x = 0; x < files.length; x ++) {
        if (files [x].isDirectory ()) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (files [x].getCanonicalPath (), "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='path' border=0 src='/images/showchildren.png' align='absmiddle' width='24' height='24'> ");
            buff.append (files [x].getCanonicalPath ());
            buff.append ("</a>");
            buff.append ("</td></tr>");
            numberItems ++;
        }
    }
    if (numberItems == 0) {
        buff.append ("<tr><td nowrap>No items to show</td></tr>");
    }
    template.replaceAll ("$availablePaths", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=282=-----==

private byte [] updateTask (HTTPurl urlData, HashMap headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("task_name");
    TaskCommand task = (TaskCommand) tasks.get (name);
    if (task != null) {
        String command = urlData.getParameter ("command");
        String autoRem = urlData.getParameter ("autoRemove");
        String delay = urlData.getParameter ("delay");
        String concurrentTasks = urlData.getParameter ("concurrentTasks");
        String timeToNextSchedule = urlData.getParameter ("timeToNextSchedule");
        String whenNotCapturing = urlData.getParameter ("whenNotCapturing");
        Boolean notCap = new Boolean (false);
        if ("true".equalsIgnoreCase (whenNotCapturing)) {
            notCap = new Boolean (true);
        }
        task.setWhenNotCapturing (notCap.booleanValue ());
        int timeToNext = 0;
        try {
            timeToNext = Integer.parseInt (timeToNextSchedule);
        } catch (Exception e) {
        }
        task.setTimeToNextSchedule (timeToNext);
        int conTasks = 0;
        try {
            conTasks = Integer.parseInt (concurrentTasks);
        } catch (Exception e) {
        }
        task.setConcurrent (conTasks);
        Boolean autoRemove = new Boolean (false);
        if ("true".equalsIgnoreCase (autoRem)) {
            autoRemove = new Boolean (true);
        }
        task.setAutoRemove (autoRemove.booleanValue ());
        int delayValue = 0;
        try {
            delayValue = Integer.parseInt (delay);
        } catch (Exception e) {
        }
        task.setDelay (delayValue);
        task.setCommand (command.trim ());
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


private byte [] getTunerList (HTTPurl urlData) throws Exception {
    boolean showID = "true".equalsIgnoreCase (urlData.getParameter ("showid"));
    showID = showID | "true".equalsIgnoreCase (urlData.getCookie ("showDeviceID"));
    if ("false".equalsIgnoreCase (urlData.getParameter ("showid"))) showID = false;
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CardSetup.html");
    if (showID == true) template.addCookie ("showDeviceID", "true");
    else template.addCookie ("showDeviceID", "false");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int activeDevices = devList.getActiveDeviceCount ();
    String scanCommand = "device.exe";
    System.out.println ("Running device scan command: " + scanCommand);
    Runtime runner = Runtime.getRuntime ();
    Process scan = runner.exec (scanCommand);
    TunerScanResult tuners = new TunerScanResult ();
    tuners.readInput (scan.getInputStream ());
    tuners.parseXML ();
    StringBuffer out = new StringBuffer ();
    Vector < CaptureDevice > tunersList = tuners.getResult ();
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
    out.append ("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
    if (showID) out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>");
    else out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
    out.append ("</td></tr></table></td></tr>\n");
    for (int x = 0; x < devList.getDeviceCount (); x ++) {
        CaptureDevice cd = (CaptureDevice) devList.getDevice (x);
        out.append ("<tr>");
        out.append ("<td nowrap>" + x + "</td>");
        out.append ("<td nowrap>: ");
        out.append (cd.getName ());
        if (cd.isInUse () == true) out.append (" (Active)");
        boolean isAvailable = false;
        for (int y = 0; y < tunersList.size (); y ++) {
            CaptureDevice cd2 = (CaptureDevice) tunersList.get (y);
            if (cd.getID ().equals (cd2.getID ())) {
                isAvailable = true;
                break;
            }
        }
        if (isAvailable == false) out.append (" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
        if (showID) out.append ("(" + cd.getID () + ")");
        out.append ("</td>\n");
        out.append ("<td nowrap width='50px'> ");
        out.append (" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        out.append ("</td>\n");
        out.append ("</tr>\n");
    }
    if (devList.getDeviceCount () == 0) {
        out.append ("<tr><td colspan ='3'>No devices selected</td></tr>");
    }
    int numCards = 0;
    out.append ("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
    for (int x = 0; x < tunersList.size (); x ++) {
        CaptureDevice dev = (CaptureDevice) tunersList.get (x);
        boolean found = false;
        for (int y = 0; y < devList.getDeviceCount (); y ++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice (y);
            if (cd.getID ().equals (dev.getID ())) {
                found = true;
                break;
            }
        }
        if (! found) {
            out.append ("<tr>");
            out.append ("<td>&nbsp;</td>");
            out.append ("<td nowrap>" + dev.getName () + "</td>");
            out.append ("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode (dev.getID (), "UTF-8"));
            out.append ("&tunerName=" + URLEncoder.encode (dev.getName (), "UTF-8") + "'>");
            out.append ("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
            out.append ("</tr>\n");
            numCards ++;
        }
    }
    if (numCards == 0) {
        out.append ("<tr><td colspan ='3'>No devices available</td></tr>");
    }
    numCards = 0;
    template.replaceAll ("$cardList", out.toString ());
    template.replaceAll ("$cardCount", new Integer (activeDevices).toString ());
    return template.getPageBytes ();
}


-----Function Pair=283=-----==

public static char [] read (File f) throws IOException {
    char [] buf = new char [(int) f.length ()];
    int n = 0;
    InputStream in = new BufferedInputStream (new FileInputStream (f));
    try {
        int c, last = - 1;
        while ((c = in.read ()) >= 0) {
            if ((c & 0x80) != 0) c = readUtf8 (c, in);
            if (c == '\r') buf [n ++] = '\n';
            else if (last == '\r' && c == '\n') continue;
            else buf [n ++] = (char) c;
            last = c;
        }
    } finally {
        in.close ();
    }
    if (n == buf.length) return buf;
    char [] trim = new char [n];
    System.arraycopy (buf, 0, trim, 0, n);
    return trim;
}


private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("Tasks.DefTask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("Tasks.PreTask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("Tasks.StartErrorTask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("Tasks.NoDataErrorTask"));
    return template.getPageBytes ();
}


-----Function Pair=284=-----==

private static void getFileList (String path, StringBuffer list) {
    File current = new File (path);
    if (current.isDirectory ()) {
        File [] files = current.listFiles ();
        for (File file : files) {
            if (file.isDirectory ()) {
                if (file.list ().length == 0) {
                    list.append (ZIP_SEPERATOR).append (file.getAbsolutePath () + "/");
                }
                else {
                    getFileList (file.getAbsolutePath (), list);
                }
            }
            else {
                list.append (ZIP_SEPERATOR).append (file.getAbsolutePath ());
            }
        }
    }
}


File zip (File dir, File zipFile) throws IOException {
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
    for (File file : dir.listFiles ()) {
        if (file.isFile ()) {
            byte [] data = new byte [(int) file.length ()];
            DataInputStream in = new DataInputStream (new FileInputStream (file));
            in.readFully (data);
            in.close ();
            zipOut.putNextEntry (new ZipEntry (file.getName ()));
            zipOut.write (data, 0, data.length);
            zipOut.closeEntry ();
        }
    }
    zipOut.close ();
    return zipFile;
}


-----Function Pair=285=-----==

protected void createTable (String name, String [] entries) {
    if (! tableExists (name)) {
        Statement stmt = null;
        try {
            Connection conn = getConnectionWrapper ().getConnection ();
            stmt = conn.createStatement ();
            String sql = "CREATE TABLE " + name + " (";
            for (int i = 0; i < entries.length; i ++) {
                sql += entries [i];
                if (i < entries.length - 1) sql += ", ";
                else sql += ")";
            }
            stmt.executeUpdate (sql);
            conn.commit ();
        } catch (SQLException e) {
            if (logger.isLoggable (Logger.SEVERE)) logger.log (Logger.SEVERE, "Error creating table '" + name + "'", e);
        } finally {
            if (stmt != null) {
                try {
                    stmt.close ();
                } catch (SQLException see) {
                    see.printStackTrace ();
                }
            }
        }
    }
}


private Cipher buildCipherAES (int mode, byte [] aesKey) {
    Cipher cipherAES = null;
    try {
        if (aesKey == null) {
            return null;
        }
        SecretKeySpec sessionKey = new SecretKeySpec (aesKey, "AES");
        cipherAES = Cipher.getInstance ("AES", "BC");
        cipherAES.init (mode, sessionKey);
    } catch (Throwable t) {
        logger.log (Level.SEVERE, "Error in AES preparation", t);
        return null;
    }
    return cipherAES;
}


-----Function Pair=286=-----==

private String createOptionsList (String availableOptionsList) throws SaslException {
    cat.debug ("==> createOptionsList(\"" + availableOptionsList + "\")");
    boolean replaydetectionAvailable = false;
    boolean integrityAvailable = false;
    boolean confidentialityAvailable = false;
    String option, mandatory = DEFAULT_MANDATORY;
    int i;
    StringTokenizer st = new StringTokenizer (availableOptionsList, ",");
    while (st.hasMoreTokens ()) {
        option = st.nextToken ();
        if (option.equals ("replay detection")) replaydetectionAvailable = true;
        else if (option.startsWith ("integrity=")) {
            option = option.substring (option.indexOf ('=') + 1);
            cat.debug ("algorithm: <" + option + ">");
            for (i = 0; i < INTEGRITY_ALGORITHMS.length; i ++) if (INTEGRITY_ALGORITHMS [i].equals (option)) {
                chosenIntegrityAlgorithm = option;
                integrityAvailable = true;
                break;
            }
        }
        else if (option.startsWith ("confidentiality=")) {
            option = option.substring (option.indexOf ('=') + 1);
            cat.debug ("algorithm: <" + option + ">");
            for (i = 0; i < CONFIDENTIALITY_ALGORITHMS.length; i ++) if (CONFIDENTIALITY_ALGORITHMS [i].equals (option)) {
                chosenConfidentialityAlgorithm = option;
                confidentialityAvailable = true;
                break;
            }
        }
        else if (option.startsWith ("mandatory=")) mandatory = option.substring (option.indexOf ('=') + 1);
        else if (option.startsWith ("maxbuffersize=")) {
            String maxBufferSize = option.substring (option.indexOf ('=') + 1);
            try {
                rawSendSize = Integer.parseInt (maxBufferSize);
                if (rawSendSize > BUFFER_LIMIT || rawSendSize < 1) throw new SaslException ("Illegal value for 'maxbuffersize' option");
            } catch (NumberFormatException x) {
                throw new SaslException ("maxbuffersize=" + String.valueOf (maxBufferSize), x);
            }
        }
    }
    replayDetection = replaydetectionAvailable && Boolean.valueOf ((String) properties.get (SRP_REPLAY_DETECTION)).booleanValue ();
    boolean integrity = integrityAvailable && Boolean.valueOf ((String) properties.get (SRP_INTEGRITY_PROTECTION)).booleanValue ();
    boolean confidentiality = confidentialityAvailable && Boolean.valueOf ((String) properties.get (SRP_CONFIDENTIALITY)).booleanValue ();
    if (MANDATORY_REPLAY_DETECTION.equals (mandatory)) {
        replayDetection = true;
        integrity = true;
    }
    else if (MANDATORY_INTEGRITY.equals (mandatory)) integrity = true;
    else if (MANDATORY_CONFIDENTIALITY.equals (mandatory)) confidentiality = true;
    if (replayDetection) if (chosenIntegrityAlgorithm == null) throw new SaslException ("Replay detection is required but no " + "integrity protection algorithm was chosen");
    else;
    if (integrity) if (chosenIntegrityAlgorithm == null) throw new SaslException ("Integrity protection is required but no " + "algorithm was chosen");
    else;
    if (confidentiality) if (chosenConfidentialityAlgorithm == null) throw new SaslException ("Confidentiality protection is required " + "but no algorithm was chosen");
    else;
    StringBuffer sb = new StringBuffer ();
    if (replayDetection) sb.append ("replay detection,");
    if (integrity) sb.append ("integrity=").append (chosenIntegrityAlgorithm).append (",");
    if (confidentiality) sb.append ("confidentiality=").append (chosenConfidentialityAlgorithm).append (",");
    String result = sb.append ("maxbuffersize=").append (BUFFER_LIMIT).toString ();
    cat.debug ("<== createOptionsList() --> " + result);
    return result;
}


public static void setUpBeforeClass () throws Exception {
    KeyPairGenerator kpg = KeyPairGenerator.getInstance ("RSA");
    kpg.initialize (512);
    pair = kpg.generateKeyPair ();
    privateKeyName = ContentName.fromNative ("/test/priv");
    cache = new SecureKeyCache ();
    pubIdentifier = new PublisherPublicKeyDigest (pair.getPublic ()).digest ();
    cache.addPrivateKey (privateKeyName, pubIdentifier, pair.getPrivate ());
    myPair = kpg.generateKeyPair ();
    myPubIdentifier = new PublisherPublicKeyDigest (myPair.getPublic ()).digest ();
    cache.addMyPrivateKey (myPubIdentifier, myPair.getPrivate ());
    key = WrappedKey.generateNonceKey ();
    keyName = ContentName.fromNative ("/test/key");
    keyIdentifier = SecureKeyCache.getKeyIdentifier (key);
    cache.addKey (keyName, key);
    File f = new File (file);
    FileOutputStream fos = new FileOutputStream (f);
    ObjectOutputStream out = new ObjectOutputStream (fos);
    out.writeObject (cache);
    out.close ();
}


-----Function Pair=287=-----==

public static void moveDirectory (String move_from, String move_to, String add_suffix) throws IOException {
    File from = new File (move_from);
    File to = new File (move_to);
    if (from.canRead ()) {
        if (to.canRead ()) {
            if (to.renameTo (new File (move_to + add_suffix)) == false) {
                throw new IOException ("Could not rename '" + move_to + "' to '" + move_to + add_suffix + "' as there is a dir in the way that cannot be moved.");
            }
        }
        boolean success = from.renameTo (new File (move_to));
        if (! success) {
            throw new IOException ("Could not move '" + move_from + "' to '" + move_to + "'");
        }
    }
}


public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


-----Function Pair=288=-----==

public synchronized InputStream getInputStream (final short fid) {
    try {
        InputStream in = null;
        byte [] file = filesBytes.get (fid);
        if (file != null) {
            in = new ByteArrayInputStream (file);
            in.mark (file.length + 1);
        }
        else {
            in = bufferedStreams.get (fid);
            if (in != null && in.markSupported ()) {
                in.reset ();
            }
        }
        if (in == null) {
            startCopyingRawInputStream (fid);
            in = bufferedStreams.get (fid);
        }
        return in;
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        throw new IllegalStateException ("ERROR: " + ioe.toString ());
    }
}


private AlgorithmParameters parseAlgParameters (DerInputStream in) throws IOException, NoSuchAlgorithmException, InvalidParameterSpecException {
    AlgorithmParameters algParams = null;
    DerValue params;
    if (in.available () == 0) {
        params = null;
    }
    else {
        params = in.getDerValue ();
        if (params.tag == DerValue.tag_Null) {
            params = null;
        }
    }
    if (params != null) {
        algParams = AlgorithmParameters.getInstance ("PBE");
        algParams.init (params.toByteArray ());
    }
    return algParams;
}


-----Function Pair=289=-----==

public void run (String args []) {
    try {
        parseArgs (args);
        if (providers != null) {
            ClassLoader cl = ClassLoader.getSystemClassLoader ();
            Enumeration < String > e = providers.elements ();
            while (e.hasMoreElements ()) {
                String provName = e.nextElement ();
                Class < ? > provClass;
                if (cl != null) {
                    provClass = cl.loadClass (provName);
                }
                else {
                    provClass = Class.forName (provName);
                }
                String provArg = providerArgs.get (provName);
                Object obj;
                if (provArg == null) {
                    obj = provClass.newInstance ();
                }
                else {
                    Constructor < ? > c = provClass.getConstructor (PARAM_STRING);
                    obj = c.newInstance (provArg);
                }
                if (! (obj instanceof Provider)) {
                    MessageFormat form = new MessageFormat (rb.getString ("provName not a provider"));
                    Object [] source = {provName};
                    throw new Exception (form.format (source));
                }
                Security.addProvider ((Provider) obj);
            }
        }
        if (verify) {
            try {
                loadKeyStore (keystore, false);
            } catch (Exception e) {
                if ((keystore != null) || (storepass != null)) {
                    System.out.println (rb.getString ("jarsigner error: ") + e.getMessage ());
                    System.exit (1);
                }
            }
            verifyJar (jarfile);
        }
        else {
            loadKeyStore (keystore, true);
            getAliasInfo (alias);
            if (altSignerClass != null) {
                signingMechanism = loadSigningMechanism (altSignerClass, altSignerClasspath);
            }
            signJar (jarfile, alias, args);
        }
    } catch (Exception e) {
        System.out.println (rb.getString ("jarsigner error: ") + e);
        if (debug) {
            e.printStackTrace ();
        }
        System.exit (1);
    } finally {
        if (keypass != null) {
            Arrays.fill (keypass, ' ');
            keypass = null;
        }
        if (storepass != null) {
            Arrays.fill (storepass, ' ');
            storepass = null;
        }
    }
    if (strict) {
        int exitCode = 0;
        if (hasExpiringCert) {
            exitCode |= 2;
        }
        if (chainNotValidated) {
            exitCode |= 4;
        }
        if (badKeyUsage || badExtendedKeyUsage || badNetscapeCertType) {
            exitCode |= 8;
        }
        if (hasUnsignedEntry) {
            exitCode |= 16;
        }
        if (notSignedByAlias || aliasNotInStore) {
            exitCode |= 32;
        }
        if (exitCode != 0) {
            System.exit (exitCode);
        }
    }
}


private byte [] createEncryptedData (char [] password) throws IOException, CertificateException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidKeySpecException, InvalidKeyException, InvalidAlgorithmParameterException {
    DerOutputStream out = new DerOutputStream ();
    String alias = this.alias;
    int chainLen;
    if (this.chain == null) {
        chainLen = 0;
    }
    else {
        chainLen = this.chain.length;
    }
    for (int i = 0; i < chainLen; i ++) {
        X509Certificate cert = this.chain [i];
        DerOutputStream safeBag = new DerOutputStream ();
        safeBag.putOID (CertBag_OID);
        DerOutputStream certBag = new DerOutputStream ();
        certBag.putOID (PKCS9CertType_OID);
        {
            DerOutputStream certValue = new DerOutputStream ();
            certValue.putOctetString (cert.getEncoded ());
            certBag.write (DerValue.createTag (DerValue.TAG_CONTEXT, true, (byte) 0), certValue);
        }
        {
            DerOutputStream certout = new DerOutputStream ();
            certout.write (DerValue.tag_Sequence, certBag);
            byte [] certBagValue = certout.toByteArray ();
            DerOutputStream bagValue = new DerOutputStream ();
            bagValue.write (certBagValue);
            safeBag.write (DerValue.createTag (DerValue.TAG_CONTEXT, true, (byte) 0), bagValue);
        }
        {
            byte [] bagAttrs = null;
            String friendlyName = cert.getSubjectX500Principal ().getName ();
            if (i == 0) {
                bagAttrs = this.getBagAttributes (friendlyName, this.keyId);
            }
            else {
                bagAttrs = this.getBagAttributes (friendlyName, null);
            }
            if (bagAttrs != null) {
                safeBag.write (bagAttrs);
            }
        }
        out.write (DerValue.tag_Sequence, safeBag);
    }
    {
        DerOutputStream safeBagValue = new DerOutputStream ();
        safeBagValue.write (DerValue.tag_SequenceOf, out);
        byte [] safeBagData = safeBagValue.toByteArray ();
        byte [] encrContentInfo = this.encryptContent (safeBagData, password);
        DerOutputStream encrData = new DerOutputStream ();
        DerOutputStream encrDataContent = new DerOutputStream ();
        encrData.putInteger (0);
        encrData.write (encrContentInfo);
        encrDataContent.write (DerValue.tag_Sequence, encrData);
        return encrDataContent.toByteArray ();
    }
}


-----Function Pair=290=-----==

private String getCapturePaths (Document doc, Element formEl) {
    Element option = null;
    Text text = null;
    StringBuffer buff = new StringBuffer (1024);
    String [] capturePaths = store.getCapturePaths ();
    option = doc.createElement ("option");
    option.setAttribute ("value", "-1");
    text = doc.createTextNode ("AutoSelect");
    option.appendChild (text);
    formEl.appendChild (option);
    for (int x = 0; x < capturePaths.length; x ++) {
        option = doc.createElement ("option");
        option.setAttribute ("value", new Integer (x).toString ());
        text = doc.createTextNode (capturePaths [x]);
        option.appendChild (text);
        formEl.appendChild (option);
    }
    return buff.toString ();
}


public CJobProposition () {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    XPath xpath = XPathFactory.newInstance ().newXPath ();
    try {
        DocumentBuilder db = dbf.newDocumentBuilder ();
        doc = db.parse ("PropositionEx.xml");
        Element element = doc.getDocumentElement ();
        NodeList ndlst = element.getChildNodes ();
        ndlst = (NodeList) xpath.evaluate ("/proposition/*", element, XPathConstants.NODESET);
        for (int i = 0; i < ndlst.getLength (); i ++) {
            Node nd = ndlst.item (i);
            System.out.println (i);
            System.out.println (nd.getNodeName ());
            System.out.println (nd.getTextContent ());
        }
    } catch (Exception e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=291=-----=1=

public void importEpgAutoList (String data, boolean append) throws Exception {
    Vector < EpgMatch > importedData = new Vector < EpgMatch > ();
    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance ();
    DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder ();
    ByteArrayInputStream reader = new ByteArrayInputStream (data.toString ().getBytes ());
    Document doc = docBuilder.parse (reader);
    NodeList items = doc.getElementsByTagName ("item");
    for (int x = 0; x < items.getLength (); x ++) {
        Node item = items.item (x);
        EpgMatch matcher = new EpgMatch (item);
        importedData.add (matcher);
    }
    if (append) {
        epgMatchList.addAll (importedData);
    }
    else {
        epgMatchList = importedData;
    }
    saveEpgAutoList (null);
}


public static Node exampleDOM2DOM (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException {
    TransformerFactory tfactory = TransformerFactory.newInstance ();
    if (tfactory.getFeature (DOMSource.FEATURE)) {
        Templates templates;
        {
            DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();
            dfactory.setNamespaceAware (true);
            DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();
            org.w3c.dom.Document outNode = docBuilder.newDocument ();
            Node doc = docBuilder.parse (new InputSource (xslID));
            DOMSource dsource = new DOMSource (doc);
            dsource.setSystemId (xslID);
            templates = tfactory.newTemplates (dsource);
        }
        Transformer transformer = templates.newTransformer ();
        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();
        dfactory.setNamespaceAware (true);
        DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();
        org.w3c.dom.Document outNode = docBuilder.newDocument ();
        Node doc = docBuilder.parse (new InputSource (sourceID));
        transformer.transform (new DOMSource (doc), new DOMResult (outNode));
        Transformer serializer = tfactory.newTransformer ();
        serializer.transform (new DOMSource (outNode), new StreamResult (new OutputStreamWriter (System.out)));
        return outNode;
    }
    else {
        throw new org.xml.sax.SAXNotSupportedException ("DOM node processing not supported!");
    }
}


-----Function Pair=292=-----==

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken ());
        else if (keyword.equals ("cache")) cache = new Cache (st.nextToken ());
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


public static void main (String [] args) {
    try {
        out = new FileWriter (System.getProperty ("generateToDir") + "/OPT_Assembler.java");
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    try {
        lowLevelAsm = Class.forName ("com.ibm.JikesRVM.VM_Assembler");
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    emit ("package com.ibm.JikesRVM.opt;\n\n");
    emit ("import com.ibm.JikesRVM.*;\n\n");
    emit ("import com.ibm.JikesRVM.opt.ir.*;\n\n");
    emit ("\n\n");
    emit ("/**\n");
    emit (" *  This class is the automatically-generated assembler for\n");
    emit (" * the optimizing compiler.  It consists of methods that\n");
    emit (" * understand the possible operand combinations of each\n");
    emit (" * instruction type, and how to translate those operands to\n");
    emit (" * calls to the VM_Assember low-level emit method\n");
    emit (" *\n");
    emit (" * @see GenerateAssembler\n");
    emit (" *\n");
    emit (" * @author Julian Dolby\n");
    emit (" * @author {@link GenerateAssembler}\n");
    emit (" */\n");
    emit ("class OPT_Assembler extends OPT_AssemblerBase {\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  This class requires no special construction;\n");
    emitTab (1);
    emit (" * this constructor simply invokes the\n");
    emitTab (1);
    emit (" * constructor for VM_Assembler\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @see VM_Assembler\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("OPT_Assembler(int bcSize, boolean print) {\n");
    emitTab (2);
    emit ("super(bcSize, print);\n");
    emitTab (1);
    emit ("}");
    emit ("\n\n");
    Method [] emitters = lowLevelAsm.getDeclaredMethods ();
    Set opcodes = getOpcodes (emitters);
    Iterator i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        setCurrentOpcode (opcode);
        emitTab (1);
        emit ("/**\n");
        emitTab (1);
        emit (" *  Emit the given instruction, assuming that\n");
        emitTab (1);
        emit (" * it is a " + currentFormat + " instruction\n");
        emitTab (1);
        emit (" * and has a " + currentOpcode + " operator\n");
        emitTab (1);
        emit (" *\n");
        emitTab (1);
        emit (" * @param inst the instruction to assemble\n");
        emitTab (1);
        emit (" */\n");
        emitTab (1);
        emit ("private void do" + opcode + "(OPT_Instruction inst) {\n");
        EmitterSet emitter = buildSetForOpcode (emitters, opcode);
        boolean [] [] tp = new boolean [4] [encoding.length];
        emitter.emitSet (opcode, tp, 2);
        emitTab (1);
        emit ("}\n\n");
    }
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  The number of instructions emitted so far\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("private int instructionCount = 0;\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  Assemble the given instruction\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @param inst the instruction to assemble\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("void doInst(OPT_Instruction inst) {\n");
    emitTab (2);
    emit ("resolveForwardReferences(++instructionCount);\n");
    emitTab (2);
    emit ("switch (inst.getOpcode()) {\n");
    Set emittedOpcodes = new HashSet ();
    i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        Iterator operators = getMatchingOperators (opcode).iterator ();
        while (operators.hasNext ()) {
            Object operator = operators.next ();
            emitTab (3);
            emittedOpcodes.add (operator);
            emit ("case IA32_" + operator + "_opcode:\n");
        }
        emitTab (4);
        emit ("do" + opcode + "(inst);\n");
        emitTab (4);
        emit ("break;\n");
    }
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IA32_LOCK_opcode:\n");
    emitTab (4);
    emit ("emitLockNextInstruction();\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IG_PATCH_POINT_opcode:\n");
    emitTab (4);
    emit ("emitPatchPoint();\n");
    emitTab (4);
    emit ("break;\n");
    Set errorOpcodes = getErrorOpcodes (emittedOpcodes);
    if (! errorOpcodes.isEmpty ()) {
        i = errorOpcodes.iterator ();
        while (i.hasNext ()) {
            emitTab (3);
            emit ("case IA32_" + i.next () + "_opcode:\n");
        }
        emitTab (4);
        emit ("throw new OPT_OptimizingCompilerException(inst + \" has unimplemented IA32 opcode (check excludedOpcodes)\");\n");
    }
    emitTab (2);
    emit ("}\n");
    emitTab (2);
    emit ("inst.setmcOffset( mi );\n");
    emitTab (1);
    emit ("}\n\n");
    emit ("\n}\n");
    try {
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=293=-----==

public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                OPTRecord opt = query.getOPT ();
                if (opt != null) udpLength = opt.getPayloadSize ();
                response = generateReply (query, in, udpLength);
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (section, r);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (section, r2);
            }
            return removed;
        }
    }
    return removed;
}


-----Function Pair=294=-----==

public void serveTCP (short port) {
    try {
        ServerSocket sock = new ServerSocket (port);
        while (true) {
            Socket s = sock.accept ();
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte [] in;
            try {
                InputStream is = s.getInputStream ();
                dataIn = new DataInputStream (is);
                inLength = dataIn.readUnsignedShort ();
                in = new byte [inLength];
                dataIn.readFully (in);
            } catch (InterruptedIOException e) {
                s.close ();
                continue;
            }
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, s);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dataOut = new DataOutputStream (s.getOutputStream ());
            dataOut.writeShort (out.length);
            dataOut.write (out);
            s.close ();
        }
    } catch (IOException e) {
        System.out.println ("serveTCP: " + e);
    }
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken (), Zone.PRIMARY);
        else if (keyword.equals ("cache")) cache = new Zone (st.nextToken (), Zone.CACHE, null);
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


-----Function Pair=295=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


-----Function Pair=296=-----==

public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test135 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    reader.setSkipEmptyRecords (false);
    Assert.assertFalse (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (5L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (6L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (7L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (8L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=297=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public static final void main (String [] argv) {
    String machineName = null;
    String envName = null;
    for (int i = 0; i < argv.length; i ++) {
        machineName = argv [i].substring (0, argv [i].lastIndexOf ("."));
        envName = machineName + "Environment";
        if (new File (envName + ".java").canRead ()) {
            System.out.println ("*** Running " + envName);
            try {
                Class.forName ("examples." + envName).getMethod ("main", new Class [] {String [].class}).invoke (null, new Object [] {null});
            } catch (Exception e) {
                e.printStackTrace ();
            }
            System.out.println ("*** Completed");
        }
        else {
            System.out.println ("*** Running " + machineName);
            try {
                ((TransitionMachine) MachineConstructor.newInstance ("examples." + machineName, null)).run ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
            System.out.println ("*** Completed");
        }
    }
}


-----Function Pair=298=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


-----Function Pair=299=-----==

protected void blockClicked (final Block block) {
    Cursor waitCursor = Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR);
    setCursor (waitCursor);
    SwingWorkerUnlimited.execure (new SwingWorker < TreePath, Void > () {
        @Override
        protected TreePath doInBackground () throws Exception {
            WorldBlock b = (WorldBlock) block;
            NBTChunk chunk = (NBTChunk) b.getChunk ();
            NBTRegion region = (NBTRegion) chunk.getRegion ();
            Tag < ? > chunkTag = chunk.getTag ();
            CompoundTag compoundTag = (CompoundTag) chunkTag;
            Tag < ? > level = compoundTag.search ("Level");
            CompoundTag levelTag = (CompoundTag) level;
            Tag < ? > blocks = levelTag.search ("Blocks");
            ByteArrayTag blocksTag = (ByteArrayTag) blocks;
            int index = b.getIndex ();
            Object child = blocksTag.getChild (index);
            return treeTable.getPathForNode (region).pathByAddingChild (chunk).pathByAddingChild (level).pathByAddingChild (blocks).pathByAddingChild (child);
        }@Override
        protected void done () {
            Cursor defaultCursor = Cursor.getDefaultCursor ();
            setCursor (defaultCursor);
            try {
                TreePath path = get ();
                selectAndScroll (path);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            } catch (ExecutionException e) {
                e.printStackTrace ();
                Throwable cause = ExceptionUtils.getRootCause (e);
                showErrorDialog (cause.getMessage ());
                return;
            }
        }
    }
    );
}


protected void setTime (final String timeText, final int seekSliderValue) {
    if (SwingUtilities.isEventDispatchThread ()) {
        seekSlider.setValue (seekSliderValue);
        timeLabel.setText (timeText);
    }
    else {
        SwingUtilities.invokeLater (new Runnable () {
            @Override
            public void run () {
                seekSlider.setValue (seekSliderValue);
                timeLabel.setText (timeText);
            }
        }
        );
    }
}


-----Function Pair=300=-----==

private void updateRows () {
    NULogger.getLogger ().info ("Updating rows..");
    model.setRowCount (0);
    try {
        BufferedReader reader = new BufferedReader (new FileReader (System.getProperty ("user.home") + File.separator + "recent.log"));
        String data;
        while ((data = reader.readLine ()) != null) {
            try {
                Vector columns = new Vector ();
                String [] columnarray = data.split ("<>");
                columns.addAll (0, Arrays.asList (columnarray));
                model.addRow (columns);
            } catch (Exception e) {
                NULogger.getLogger ().log (Level.INFO, "{0}: {1}", new Object [] {getClass ().getName (), e});
                continue;
            }
        }
        reader.close ();
    } catch (Exception ex) {
        NULogger.getLogger ().severe (ex.toString ());
        System.err.println (ex);
    }
}


private static final void openNative (File f) throws IOException {
    final String os = System.getProperty ("os.name");
    final String [] cmdarray;
    if (os.startsWith ("Windows")) {
        cmdarray = new String [] {"cmd", "/c", "start", "\"\"", f.getCanonicalPath ()};
    }
    else if (os.startsWith ("Mac OS")) {
        cmdarray = new String [] {"open", f.getCanonicalPath ()};
    }
    else if (os.startsWith ("Linux")) {
        cmdarray = new String [] {"xdg-open", f.getCanonicalPath ()};
    }
    else {
        throw new IOException ("unknown way to open " + f);
    }
    try {
        final int res = Runtime.getRuntime ().exec (cmdarray).waitFor ();
        if (res != 0) throw new IOException ("error (" + res + ") executing " + Arrays.asList (cmdarray));
    } catch (InterruptedException e) {
        throw ExceptionUtils.createExn (IOException.class, "interrupted waiting for " + Arrays.asList (cmdarray), e);
    }
}


-----Function Pair=301=-----==

private void addTestControls (JPanel panel, String [] [] controls) {
    Dimension size = new Dimension (150, 15);
    if (controls.length > 0) {
        panel.setLayout (new SpringLayout ());
        for (String [] control : controls) {
            JLabel label = new JLabel (control [0], this.helpIcon, JLabel.LEFT);
            label.setToolTipText (control [1]);
            label.setPreferredSize (size);
            label.setMaximumSize (size);
            JLabel value = new JLabel (control [2]);
            panel.add (label);
            panel.add (value);
        }
        makeCompactGrid (panel, controls.length, 2, 0, 0, 4, 4);
    }
    else {
        panel.setLayout (new GridBagLayout ());
        panel.setMaximumSize (null);
        panel.setPreferredSize (null);
    }
}


public static boolean migrateFrom104jTo105 () {
    final File oldDirectory = new File (System.getProperty ("user.home") + File.separator + ".jstock" + File.separator + "1.0.4" + File.separator);
    final File newDirectory = new File (getUserDataDirectory ());
    if (newDirectory.isDirectory () && newDirectory.exists ()) {
        return true;
    }
    if (oldDirectory.isDirectory () == false || oldDirectory.exists () == false) {
        return true;
    }
    boolean success = oldDirectory.renameTo (newDirectory);
    if (! success) {
        return false;
    }
    final File indicatorDirectory = new File (getUserDataDirectory () + "indicator" + File.separator);
    final boolean status = deleteDir (indicatorDirectory, true);
    return status;
}


-----Function Pair=302=-----==

public void valueChanged (TreeSelectionEvent e) {
    Object selected = groupTree.getLastSelectedPathComponent ();
    if (selected instanceof MutableTreeNode) {
        MutableTreeNode node = (MutableTreeNode) selected;
        MutableTreeNode parent = (MutableTreeNode) node.getParent ();
        if (parent == null) {
            RootGroupNode root = (ManageGroups.RootGroupNode) treeModel.getRoot ();
            parent = root;
        }
        int numChildren = parent.getChildCount ();
        int nodeIndex = parent.getIndex (node);
        if (nodeIndex < 0) {
            return;
        }
        if (nodeIndex == 0) {
            moveUp.setEnabled (false);
        }
        else if (node instanceof RecommendationMutableTreeNode && parent.getChildAt (nodeIndex - 1) instanceof GroupMutableTreeNode) {
            moveUp.setEnabled (false);
        }
        else {
            moveUp.setEnabled (true);
        }
        if (nodeIndex + 1 == numChildren) {
            moveDown.setEnabled (false);
        }
        else if (node instanceof GroupMutableTreeNode && parent.getChildAt (nodeIndex + 1) instanceof RecommendationMutableTreeNode) {
            moveDown.setEnabled (false);
        }
        else {
            moveDown.setEnabled (true);
        }
    }
}


public void init (List < String > arguments) throws Exception {
    audioPlayer = new AudioPlayer (this);
    String mixerName = Settings.getMixerName ();
    if (! mixerName.isEmpty ()) {
        audioPlayer.setMixerName (mixerName);
    }
    SwingUtilities.invokeAndWait (new Runnable () {
        @Override
        public void run () {
            JFrame.setDefaultLookAndFeelDecorated (true);
            JDialog.setDefaultLookAndFeelDecorated (true);
            UIManager.put (SubstanceLookAndFeel.FOCUS_KIND, SubstanceConstants.FocusKind.NONE);
            SubstanceLookAndFeel.setSkin (new XtremeDarkSapphireSkin ());
            LanguageBundle.setLanguage (Locale.getDefault ());
            String title = LanguageBundle.getString ("Application.title") + " " + Version.getCurrentVersion ();
            mainFrame = new JFrame (title);
            mainFrame.setIconImages (Utilities.getLogoImages (new int [] {32, 48, 64}));
            mainFrame.setBounds (Settings.getMainFrameBounds ());
            mainFrame.addWindowListener (new WindowAdapter () {
                @Override
                public void windowClosing (WindowEvent ev) {
                    exit ();
                }
            }
            );
            createMenuBar ();
            createMainPanels ();
            mainFrame.setMinimumSize (new Dimension (controlPanel.getPreferredSize ().width + 50, 200));
            if (! Settings.containsKey ("xtrememp.mainFrame.x")) {
                mainFrame.setLocationRelativeTo (null);
            }
            mainFrame.setVisible (true);
        }
    }
    );
    SubstanceLookAndFeel.registerSkinChangeListener (this);
    if (JIntellitype.isJIntellitypeSupported ()) {
        JIntellitype.getInstance ().addIntellitypeListener (this);
    }
    if (Settings.isAutomaticCheckForUpdatesEnabled ()) {
        SoftwareUpdate.scheduleCheckForUpdates (5 * 1000);
    }
    File playlistFile = new File (Settings.getCacheDir (), DEFAULT_PLAYLIST);
    if (playlistFile.exists ()) {
        playlistManager.loadPlaylist (playlistFile.getAbsolutePath ());
    }
    playlist = playlistManager.getPlaylist ();
    playerLauncher = new PlayerLauncher (false);
    playerLauncher.execute ();
}


-----Function Pair=303=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static boolean equals (final char [] a, final char [] a2, final int off, final int len) {
    if (a == a2) {
        return true;
    }
    if (a == null || a2 == null) {
        return false;
    }
    int length = a.length;
    if (len != length) {
        return false;
    }
    for (int i = 0; i < len; i ++) {
        if (a [i] != a2 [off + i]) {
            return false;
        }
    }
    return true;
}


-----Function Pair=304=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static Object getValue (Object collection, int index) {
    collection = getValue (collection);
    Object value = collection;
    if (collection != null) {
        if (collection.getClass ().isArray ()) {
            if (index < 0 || index >= Array.getLength (collection)) {
                return null;
            }
            value = Array.get (collection, index);
        }
        else if (collection instanceof List) {
            if (index < 0 || index >= ((List) collection).size ()) {
                return null;
            }
            value = ((List) collection).get (index);
        }
        else if (collection instanceof Collection) {
            int i = 0;
            Iterator it = ((Collection) collection).iterator ();
            for (; i < index; i ++) {
                it.next ();
            }
            if (it.hasNext ()) {
                value = it.next ();
            }
            else {
                value = null;
            }
        }
    }
    return value;
}


-----Function Pair=305=-----==

public static Iterator iterate (Object collection) {
    if (collection == null) {
        return Collections.EMPTY_LIST.iterator ();
    }
    if (collection.getClass ().isArray ()) {
        int length = Array.getLength (collection);
        if (length == 0) {
            return Collections.EMPTY_LIST.iterator ();
        }
        ArrayList list = new ArrayList ();
        for (int i = 0; i < length; i ++) {
            list.add (Array.get (collection, i));
        }
        return list.iterator ();
    }
    if (collection instanceof Collection) {
        return ((Collection) collection).iterator ();
    }
    return Collections.singletonList (collection).iterator ();
}


public static Object [] fill (Object [] array, int offset, Iterator < ? > iterator) {
    if (array == null) {
        throw new IllegalArgumentException ("Argument array may not be null");
    }
    if (offset < 0 || offset >= array.length) {
        throw new IllegalArgumentException ("Invalid offset value: " + offset);
    }
    if (iterator == null) {
        throw new IllegalArgumentException ("Argument iterator may not be null");
    }
    for (int i = offset; iterator.hasNext (); i ++) {
        array [i] = iterator.next ();
    }
    return array;
}


-----Function Pair=306=-----==

private String parseUrl (String url) throws URIException {
    String base = url;
    Map < String, String [] > params = null;
    int qi = url.indexOf ("?");
    if (qi != - 1) {
        base = url.substring (0, qi);
        params = getMap (url.substring (qi + 1));
    }
    String urlTail = "";
    if (params != null) {
        Iterator < String > it = params.keySet ().iterator ();
        String key;
        while (it.hasNext ()) {
            key = it.next ();
            for (String value : params.get (key)) {
                if ("".equals (urlTail)) {
                    urlTail = "" + key + "=" + value;
                }
                else {
                    urlTail = urlTail + "&" + key + "=" + value;
                }
            }
        }
    }
    return base + "?" + urlTail;
}


public void assign (EvaluationResult value, EvaluationEnvironment env, ParsedAssignmentOperator assign) throws EvaluationException {
    if (isMethod) throw new EvaluationException ("Invalid argument for operator " + theName, this, getMatch ().index);
    EvaluationResult ctxType;
    if (theContext == null) {
        Class < ? > c = env.getImportMethodType (getName ());
        if (c == null) throw new EvaluationException (getName () + " cannot be resolved or is not a field", this, getStored ("name").index);
        ctxType = new EvaluationResult (new Type (env.getImportMethodType (getName ())));
    }
    else ctxType = theContext.evaluate (env, false, true);
    boolean isStatic = ctxType.isType ();
    if (getName ().equals ("length") && ctxType.getType ().isArray ()) throw new EvaluationException ("The final field array.length cannot be assigned", this, getStored ("name").index);
    java.lang.reflect.Field field;
    try {
        field = ctxType.getType ().getBaseType ().getField (theName);
    } catch (Exception e) {
        throw new EvaluationException ("Could not access field " + getName () + " on type " + ctxType.typeString (), e, this, getStored ("name").index);
    }
    if (field == null) throw new EvaluationException (ctxType.typeString () + "." + getName () + " cannot be resolved or is not a field", this, getStored ("name").index);
    if (env.usePublicOnly () && (field.getModifiers () & Modifier.PUBLIC) == 0) throw new EvaluationException (ctxType.typeString () + "." + theName + " is not visible", this, this.getStored ("name").index);
    if (isStatic && (field.getModifiers () & Modifier.STATIC) == 0) throw new EvaluationException ("Cannot make a static reference to non-static field " + theName + " from the type " + ctxType.typeString () + "." + theName + " is not static", this, getStored ("name").index);
    if ((field.getModifiers () & Modifier.FINAL) != 0) throw new EvaluationException ("The final field " + ctxType.typeString () + "." + theName + " cannot be assigned", this, getStored ("name").index);
    try {
        field.set (ctxType.getValue (), value.getValue ());
    } catch (Exception e) {
        throw new EvaluationException ("Could not assign field " + field.getName () + " of class " + field.getDeclaringClass ().getName (), e, this, getStored ("name").index);
    }
}


-----Function Pair=307=-----==

public byte [] generateCSR (String dnString, int keyLength) throws Exception {
    X509Name subject = CertificateUtility.stringToBcX509Name (dnString);
    KeyPair kp = CertificateUtility.generateNewKeys ("RSA", keyLength);
    X509V3CertificateGenerator v3CertGen = new X509V3CertificateGenerator ();
    X509Principal x509Principal = new X509Principal (subject);
    v3CertGen.reset ();
    v3CertGen.setSerialNumber (new BigInteger (16, new Random ()));
    v3CertGen.setIssuerDN (x509Principal);
    v3CertGen.setNotBefore (new Date (System.currentTimeMillis ()));
    v3CertGen.setNotAfter (new Date (System.currentTimeMillis () + (90 * 1000L * 60 * 60 * 24)));
    v3CertGen.setSubjectDN (x509Principal);
    v3CertGen.setPublicKey (kp.getPublic ());
    v3CertGen.setSignatureAlgorithm ("MD5WithRSAEncryption");
    X509Certificate [] cert = {v3CertGen.generateX509Certificate (kp.getPrivate ())};
    aliasForLastCSRKeyEntry = addKeyEntry (kp.getPrivate (), cert, CertificateUtility.getCommonName ((X509Certificate) cert [0]), false);
    logger.info ("Adding new CSR: " + cert [0] + " to the keystore manager");
    PKCS10CertificationRequest req1 = new PKCS10CertificationRequest ("SHA1withRSA", subject, kp.getPublic (), null, kp.getPrivate ());
    req1.verify ();
    return req1.getEncoded ();
}


private X509Certificate makeCertificate (X500Name x500name, PrivateKey issuerPrivateKey, PublicKey subjectPublicKey) throws SignatureException, InvalidKeyException, IOException, CertificateException, NoSuchProviderException, NoSuchAlgorithmException {
    long lDays = 180;
    lDays = lDays * 24 * 60 * 60;
    X509CertImpl x509certimpl;
    X500Signer x500signer = getSigner (x500name, issuerPrivateKey);
    Date date = new Date ();
    Date date1 = new Date ();
    date1.setTime (date1.getTime () + lDays * 1000L);
    CertificateValidity certificatevalidity = new CertificateValidity (date, date1);
    X509CertInfo x509certinfo = new X509CertInfo ();
    x509certinfo.set ("version", new CertificateVersion (0));
    x509certinfo.set ("serialNumber", new CertificateSerialNumber ((int) (date.getTime () / 1000L)));
    AlgorithmId algorithmid = x500signer.getAlgorithmId ();
    x509certinfo.set ("algorithmID", new CertificateAlgorithmId (algorithmid));
    x509certinfo.set ("subject", new CertificateSubjectName (x500name));
    x509certinfo.set ("key", new CertificateX509Key (subjectPublicKey));
    x509certinfo.set ("validity", certificatevalidity);
    x509certinfo.set ("issuer", new CertificateIssuerName (x500signer.getSigner ()));
    x509certimpl = new X509CertImpl (x509certinfo);
    x509certimpl.sign (issuerPrivateKey, g_keySignAlg);
    return x509certimpl;
}


-----Function Pair=308=-----==

public static void encrypt (EncryptionKeys encryptionKeys, File uploadedFile, File encryptedFile) throws Exception {
    Security.addProvider (new org.bouncycastle.jce.provider.BouncyCastleProvider ());
    Cipher cipher = Cipher.getInstance ("AES/ECB/PKCS7Padding", "BC");
    SecretKeySpec encryptionKey = new SecretKeySpec (encryptionKeys.getKeyBytes (), "AES");
    cipher.init (Cipher.ENCRYPT_MODE, encryptionKey);
    InputStream clearTextFis = new FileInputStream (uploadedFile);
    OutputStream cipherTextFos = new FileOutputStream (encryptedFile);
    cipherTextFos = new CipherOutputStream (cipherTextFos, cipher);
    byte [] buf = new byte [4096];
    int numRead = 0;
    while ((numRead = clearTextFis.read (buf)) >= 0) {
        cipherTextFos.write (buf, 0, numRead);
    }
    cipherTextFos.close ();
}


public String decryptPassword (byte [] encryptedPassword) {
    Cipher cipher;
    try {
        if (log.isDebugEnabled ()) {
            log.debug ("decrypt...");
        }
        cipher = Cipher.getInstance (this.algorithm);
        cipher.init (Cipher.DECRYPT_MODE, this.keyPair.getPrivate ());
        CipherInputStream cis = new CipherInputStream (new ByteArrayInputStream (encryptedPassword), cipher);
        ByteArrayOutputStream baosDecryptedData = new ByteArrayOutputStream ();
        byte [] buffer = new byte [8192];
        int len = 0;
        while ((len = cis.read (buffer)) > 0) {
            baosDecryptedData.write (buffer, 0, len);
        }
        baosDecryptedData.flush ();
        cis.close ();
        if (log.isDebugEnabled ()) {
            log.debug ("...finish");
        }
        return new String (baosDecryptedData.toByteArray ());
    } catch (Exception e) {
        log.error (e.getMessage (), e);
        throw new IllegalStateException (e.getMessage (), e);
    }
}


-----Function Pair=309=-----==

protected List < String > getImages () {
    List < String > result = new ArrayList < String > ();
    String text = editor.getText ();
    int image = 0;
    for (;;) {
        image = text.indexOf ("[[Image:", image);
        if (image < 0) return result;
        image = image + 8;
        int bracket = text.indexOf ("]]", image);
        int pipe = text.indexOf ('|', image);
        if (bracket < 0 || (pipe >= 0 && pipe < bracket)) bracket = pipe;
        if (bracket < 0) return result;
        result.add (text.substring (image, bracket));
        image = bracket + 1;
    }
}


public boolean execute (IContext context) {
    if (! super.execute (context)) {
        return false;
    }
    String target = action.getPara ("target");
    if (Attributes.START.equalsIgnoreCase (target)) {
        ActionScript a = new ActionScript ();
        a.setType (ActionFactory.STARTSERVERACTION);
        ActionFactory.createAction (a).execute (context);
        ActionScript b = new ActionScript ();
        b.setType (ActionFactory.MAXPAGEACTION);
        ActionFactory.createAction (b).execute (context);
        BufferedImage image = robot.createScreenCapture (new Rectangle (5, 5, 100, 10));
        robot.delay (Util.getDelayTime (Util.DELAY300));
    }
    else if (Attributes.STOP.equalsIgnoreCase (target)) {
        ActionScript a = new ActionScript ();
        a.setType (ActionFactory.STOPSERVERACTION);
        ActionFactory.createAction (a).execute (context);
    }
    return true;
}


-----Function Pair=310=-----==

public void show () {
    TacheUI tacheCourante = (TacheUI) aireDeDessin.getObjetSurvole ();
    listeBoutons [2].activer (tacheCourante.getPere () != null && tacheCourante.getPere ().getListefils ().size () > 1);
    listeBoutons [3].activer (tacheCourante.getPere () != null);
    listeBoutons [7].activer (tacheCourante.getPere () != null);
    listeBoutons [4].setTypeAction (tacheCourante.estDeroule () ? Categorie.CACHE : Categorie.VUE);
    if (tacheCourante != null) {
        int x = (int) tacheCourante.getLocationOnScreen ().getX () + aireDeDessin.getObjetSurvole ().getWidth () / 2;
        int y = (int) tacheCourante.getLocationOnScreen ().getY () + aireDeDessin.getObjetSurvole ().getHeight () / 2;
        positionScreen = new Point (x - (largeur / 2), y - (hauteur / 2));
        backgroundImage = robot.createScreenCapture (new Rectangle (positionScreen.x, positionScreen.y, largeur, hauteur));
        repaint ();
        popup = factory.getPopup (f, panel, positionScreen.x, positionScreen.y);
        popup.show ();
    }
}


private BranchGroup getInitialWorld (Pathway [] pathways, boolean orientation) {
    BranchGroup g = new BranchGroup ();
    if (orientation) {
        LineArray a = new LineArray (30, LineArray.COORDINATES | LineArray.COLOR_3);
        a.setCoordinate (0, new Point3f (- 1.0f, 0, 0));
        a.setColor (0, new Color3f (0, 1, 0));
        a.setCoordinate (1, new Point3f (1.0f, 0, 0));
        a.setColor (1, new Color3f (0, 1, 0));
        a.setCoordinate (2, new Point3f (0, - 1.0f, 0));
        a.setColor (2, new Color3f (1, 0, 0));
        a.setCoordinate (3, new Point3f (0, 1.0f, 0));
        a.setColor (3, new Color3f (1, 0, 0));
        a.setCoordinate (4, new Point3f (0, 0, - 1.0f));
        a.setColor (4, new Color3f (0, 0, 1));
        a.setCoordinate (5, new Point3f (0, 0, 1.0f));
        a.setColor (5, new Color3f (0, 0, 1));
        a.setCoordinate (6, new Point3f (0.95f, .05f, 0));
        a.setColor (6, new Color3f (0, 1, 0));
        a.setCoordinate (7, new Point3f (1, 0, 0));
        a.setColor (7, new Color3f (0, 1, 0));
        a.setCoordinate (8, new Point3f (0.95f, - .05f, 0));
        a.setColor (8, new Color3f (0, 1, 0));
        a.setCoordinate (9, new Point3f (1, 0, 0));
        a.setColor (9, new Color3f (0, 1, 0));
        a.setCoordinate (18, new Point3f (0.95f, 0, .05f));
        a.setColor (18, new Color3f (0, 1, 0));
        a.setCoordinate (19, new Point3f (1, 0, 0));
        a.setColor (19, new Color3f (0, 1, 0));
        a.setCoordinate (20, new Point3f (0.95f, 0, - .05f));
        a.setColor (20, new Color3f (0, 1, 0));
        a.setCoordinate (21, new Point3f (1, 0, 0));
        a.setColor (21, new Color3f (0, 1, 0));
        a.setCoordinate (10, new Point3f (.05f, .95f, 0));
        a.setColor (10, new Color3f (1, 0, 0));
        a.setCoordinate (11, new Point3f (0, 1, 0));
        a.setColor (11, new Color3f (1, 0, 0));
        a.setCoordinate (12, new Point3f (- .05f, .95f, 0));
        a.setColor (12, new Color3f (1, 0, 0));
        a.setCoordinate (13, new Point3f (0, 1, 0));
        a.setColor (13, new Color3f (1, 0, 0));
        a.setCoordinate (22, new Point3f (0, .95f, .05f));
        a.setColor (22, new Color3f (1, 0, 0));
        a.setCoordinate (23, new Point3f (0, 1, 0));
        a.setColor (23, new Color3f (1, 0, 0));
        a.setCoordinate (24, new Point3f (0, .95f, - .05f));
        a.setColor (24, new Color3f (1, 0, 0));
        a.setCoordinate (25, new Point3f (0, 1, 0));
        a.setColor (25, new Color3f (1, 0, 0));
        a.setCoordinate (14, new Point3f (0, .05f, .95f));
        a.setColor (14, new Color3f (0, 0, 1));
        a.setCoordinate (15, new Point3f (0, 0, 1));
        a.setColor (15, new Color3f (0, 0, 1));
        a.setCoordinate (16, new Point3f (0, - .05f, .95f));
        a.setColor (16, new Color3f (0, 0, 1));
        a.setCoordinate (17, new Point3f (0, 0, 1));
        a.setColor (17, new Color3f (0, 0, 1));
        a.setCoordinate (26, new Point3f (.05f, 0, .95f));
        a.setColor (26, new Color3f (0, 0, 1));
        a.setCoordinate (27, new Point3f (0, 0, 1));
        a.setColor (27, new Color3f (0, 0, 1));
        a.setCoordinate (28, new Point3f (- .05f, 0, .95f));
        a.setColor (28, new Color3f (0, 0, 1));
        a.setCoordinate (29, new Point3f (0, 0, 1));
        a.setColor (29, new Color3f (0, 0, 1));
        g.addChild (new Shape3D (a));
    }
    Background b = new Background (new Color3f (.20f, .20f, .20f));
    b.setApplicationBounds (new BoundingSphere (new Point3d (), 1000.0));
    b.setCapability (Background.ALLOW_COLOR_WRITE);
    g.addChild (b);
    AmbientLight lightA = new AmbientLight ();
    lightA.setInfluencingBounds (new BoundingSphere (new Point3d (0, 0, 0), 15));
    g.addChild (lightA);
    DirectionalLight lightD1 = new DirectionalLight ();
    lightD1.setDirection (new Vector3f (- 1, - 1, - 1));
    lightD1.setInfluencingBounds (new BoundingSphere (new Point3d (1, 1, 1), 15));
    g.addChild (lightD1);
    return g;
}


-----Function Pair=311=-----==

private void saveRotations () {
    File file = null;
    JFileChooser fileChooser = new JFileChooser (iCurrentRotDir);
    int returnVal = fileChooser.showSaveDialog (iAceTree);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        file = fileChooser.getSelectedFile ();
    }
    else {
        System.out.println ("Save command cancelled by user.");
        return;
    }
    iCurrentRotDir = file.getParent ();
    PrintWriter pw = null;
    try {
        FileOutputStream fos = new FileOutputStream (file);
        pw = new PrintWriter (fos, true);
    } catch (Exception e) {
        e.printStackTrace ();
        return;
    }
    pw.println ("<?xml version='1.0' encoding='utf-8'?>");
    pw.println ();
    pw.println ("<rotations>");
    for (int i = 0; i < iUndo.size (); i ++) {
        Trans t = (Trans) iUndo.get (i);
        StringBuffer sb = new StringBuffer ();
        sb.append ("<rotation ");
        sb.append ("radians=\"" + t.iAngInc + "\" ");
        sb.append ("axis=\"" + t.iAxis + "\"/>");
        pw.println (sb.toString ());
    }
    pw.println ("</rotations>");
}


public Vector < String > doInBackground () {
    Vector < String > inputFiles = new Vector < String > ();
    for (int i = 0; i < numFrames; i ++) {
        app.setTime (startTime.getCurrentGregorianCalendar ().getTimeInMillis ());
        if (movieMode == 0) {
            threeDpanel.getWwd ().redrawNow ();
        }
        else if (movieMode == 1) {
        }
        else {
        }
        createScreenCapture (tempDirStr + "/" + rootNameTempImages + i + ".jpg");
        inputFiles.addElement (tempDirStr + "/" + rootNameTempImages + i + ".jpg");
        publish ((int) (100.0 * (i + 1.0) / numFrames));
        startTime.addSeconds (timeStep);
    }
    movieStatusBar.setString ("Building Movie File.....");
    movieStatusBar.setIndeterminate (true);
    int width;
    int height;
    if (movieMode == 0) {
        width = threeDpanel.getWwdWidth ();
        height = threeDpanel.getWwdHeight ();
    }
    else if (movieMode == 1) {
        int [] twoDinfo = calculate2DMapSizeAndScreenLoc (twoDpanel);
        width = twoDinfo [0];
        height = twoDinfo [1];
    }
    else {
        width = otherPanel.getWidth ();
        height = otherPanel.getHeight ();
    }
    MediaLocator oml;
    if ((oml = createMediaLocator (outputMoviePathFinal)) == null) {
        JOptionPane.showMessageDialog (null, "ERROR Creating Output File (check permissions)", "ERROR", JOptionPane.ERROR_MESSAGE);
        System.err.println ("Cannot build media locator from: " + outputMoviePathFinal);
        publish (0);
        movieStatusBar.setString ("ERROR!");
        return inputFiles;
    }
    JpegImagesToMovie imageToMovie = new JpegImagesToMovie ();
    imageToMovie.doIt (width, height, playbackFPS, inputFiles, oml);
    boolean cleanSuccess = deleteDirectory (tempDirStr);
    publish (0);
    movieStatusBar.setString ("Finished!");
    return inputFiles;
}


-----Function Pair=312=-----==

public void testWrapUnwrapKey () throws Exception {
    setupTest ();
    Log.info ("Entering testWrapUnwrapKey");
    Log.info ("Wrap secret key in secret key.");
    WrappedKey wks = WrappedKey.wrapKey (wrappedAESKey, null, aLabel, wrappingAESKey);
    Key unwrappedKey = wks.unwrapKey (wrappingAESKey);
    Assert.assertArrayEquals (wrappedAESKey.getEncoded (), unwrappedKey.getEncoded ());
    Log.info ("Wrap secret key in public key.");
    WrappedKey wksp = WrappedKey.wrapKey (wrappedAESKey, null, aLabel, wrappingKeyPair.getPublic ());
    unwrappedKey = wksp.unwrapKey (wrappingKeyPair.getPrivate ());
    Assert.assertArrayEquals (wrappedAESKey.getEncoded (), unwrappedKey.getEncoded ());
    Log.info ("Wrap private key in public key.");
    WrappedKey wkpp = WrappedKey.wrapKey (wrappingKeyPair.getPrivate (), null, aLabel, wrappingKeyPair.getPublic ());
    unwrappedKey = wkpp.unwrapKey (wrappingKeyPair.getPrivate ());
    Assert.assertArrayEquals (wrappingKeyPair.getPrivate ().getEncoded (), unwrappedKey.getEncoded ());
    Log.info ("Wrap private key in secret key.");
    Log.info ("wpk length " + wrappingKeyPair.getPrivate ().getEncoded ().length);
    WrappedKey wkp = WrappedKey.wrapKey (wrappingKeyPair.getPrivate (), null, aLabel, wrappingAESKey);
    unwrappedKey = wkp.unwrapKey (wrappingAESKey);
    Assert.assertArrayEquals (wrappingKeyPair.getPrivate ().getEncoded (), unwrappedKey.getEncoded ());
    wksp = WrappedKey.wrapKey (wrappedAESKey, null, aLabel, wrappingEGKeyPair.getPublic ());
    unwrappedKey = wksp.unwrapKey (wrappingEGKeyPair.getPrivate ());
    Assert.assertEquals (new BigInteger (1, wrappedAESKey.getEncoded ()), new BigInteger (1, unwrappedKey.getEncoded ()));
    wkpp = WrappedKey.wrapKey (wrappingEGKeyPair.getPrivate (), null, aLabel, wrappingKeyPair.getPublic ());
    unwrappedKey = wkpp.unwrapKey (wrappingKeyPair.getPrivate ());
    Assert.assertArrayEquals (wrappingEGKeyPair.getPrivate ().getEncoded (), unwrappedKey.getEncoded ());
    Log.info ("Leaving testWrapUnwrapKey");
}


private static String getKeyInFile (String filePath) {
    BufferedReader fileReader = null;
    StringBuffer key = new StringBuffer ();
    try {
        File file = new File (filePath);
        fileReader = new BufferedReader (new FileReader (file));
        String line = fileReader.readLine ();
        while (line != null) {
            key.append (line);
            line = fileReader.readLine ();
        }
    } catch (FileNotFoundException e) {
        err.println ("Arquivo n?o encontrado.");
    } catch (IOException e) {
        err.println ("Erro de I/O (Leitura do arquivo).");
    } finally {
        if (fileReader != null) {
            try {
                fileReader.close ();
            } catch (IOException e) {
                err.println ("Erro de I/O (Fechar arquivo).");
            }
        }
    }
    return key.toString ();
}


-----Function Pair=313=-----==

private void testHeaderLength (int headerLength, int frames) throws IOException {
    int MAX = (int) Math.pow (2, 8 * headerLength) - 1;
    FramedMessage maxMessage = createFramedMessage (headerLength, MAX);
    FramingInputTransformer inputTransformer = new FramingInputTransformer (headerLength);
    inputTransformer.transform (maxMessage.both);
    ByteBuffer transformedInput = inputTransformer.getMessage ();
    System.out.println ("original message: " + maxMessage.message);
    System.out.println ("transformedInput: " + transformedInput);
    assertEquals (maxMessage.message, transformedInput);
    maxMessage = null;
    ByteBuffer [] originalMessages = new ByteBuffer [frames];
    FramedMessage allFrames = null;
    for (int i = 0; i < frames; i ++) {
        FramedMessage framedMessage = createFramedMessage (headerLength);
        originalMessages [i] = framedMessage.message;
        if (allFrames == null) {
            allFrames = framedMessage;
        }
        else {
            allFrames = new FramedMessage (allFrames.both, framedMessage.both);
        }
    }
    inputTransformer.transform (allFrames.both);
    for (int i = 0; i < frames; i ++) {
        transformedInput = inputTransformer.getMessage ();
        System.out.println ("original message: " + originalMessages [i]);
        System.out.println ("transformedInput: " + transformedInput);
        assertEquals (originalMessages [i], transformedInput);
    }
}


private static double absDiffOfMeans (double [] A, double [] B, boolean randomize) {
    Random random = new Random ();
    double aTotal = 0.0;
    double bTotal = 0.0;
    for (int i = 0; i < A.length; i ++) {
        if (randomize && random.nextBoolean ()) {
            aTotal += B [i];
            bTotal += A [i];
        }
        else {
            aTotal += A [i];
            bTotal += B [i];
        }
    }
    double aMean = aTotal / A.length;
    double bMean = bTotal / B.length;
    return Math.abs (aMean - bMean);
}


-----Function Pair=314=-----==

public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


private void assertComparatorYieldsOrder (Object [] orderedObjects, Comparator comparator) {
    Object [] keys = (Object []) orderedObjects.clone ();
    boolean isInNewOrder = false;
    while (keys.length > 1 && isInNewOrder == false) {
        shuffle : {
            Random rand = new Random ();
            for (int i = keys.length - 1; i > 0; i --) {
                Object swap = keys [i];
                int j = rand.nextInt (i + 1);
                keys [i] = keys [j];
                keys [j] = swap;
            }
        }
        testShuffle : {
            for (int i = 0; i < keys.length && ! isInNewOrder; i ++) {
                if (! orderedObjects [i].equals (keys [i])) {
                    isInNewOrder = true;
                }
            }
        }
    }
    Arrays.sort (keys, comparator);
    for (int i = 0; i < orderedObjects.length; i ++) {
        assertEquals (orderedObjects [i], keys [i]);
    }
}


-----Function Pair=315=-----==

public void addGroupInstruction (int id, int groupId) throws FidoDatabaseException, InstructionNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            InstructionTable it = new InstructionTable ();
            if (it.contains (groupId) == false) throw new InstructionNotFoundException (groupId);
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            int max = getNextRank (stmt, id);
            String sql = "insert into InstructionGroups (InstructionId, Rank, GroupInstruction) " + "values (" + id + ", " + max + ", " + groupId + ")";
            stmt.executeUpdate (sql);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public static Record first (Class < ? extends StaticRecordBase > c, String attributes, Integer...ids) throws RecordException {
    try {
        if (! attributes.startsWith ("{")) {
            attributes = "{" + attributes;
        }
        if (! attributes.endsWith ("}")) {
            attributes += "}";
        }
        JSONObject parsed = new JSONObject (attributes);
        parsed.put ("method", "first");
        List < ? extends Record > l = find (c, parsed.toString (), ids);
        if (l.isEmpty ()) {
            return null;
        }
        else {
            return l.get (0);
        }
    } catch (JSONException e) {
        throw new RecordException ("Error parsing parameters", e);
    }
}


-----Function Pair=316=-----==

private String getUpdateSql (int noOfComponents, int id) {
    StringBuffer sqlBuff = new StringBuffer ("UPDATE ");
    sqlBuff.append (m_dbItemName);
    sqlBuff.append (" SET ");
    sqlBuff.append (m_itemTable.getName ().getColumnName ());
    sqlBuff.append (" = '");
    sqlBuff.append (m_itemNameValue);
    sqlBuff.append ("'");
    for (Iterator < DbColumnExt > iter = m_itemTable.getIter (2); iter.hasNext ();) {
        DbColumnExt column = iter.next ();
        sqlBuff.append (",");
        sqlBuff.append (column.getColumnName ());
        sqlBuff.append ("=");
        appendItemValue (sqlBuff, column, noOfComponents);
    }
    sqlBuff.append (" WHERE ");
    sqlBuff.append (m_dbItemIdFieldColName);
    sqlBuff.append (" = ");
    sqlBuff.append (id);
    return sqlBuff.toString ();
}


public void addPropertyColumns (WCAChannel destination, Set < Property > properties) throws SQLException {
    Session session = HibernateUtil.getSessionFactory ().openSession ();
    Connection con = session.connection ();
    try {
        createPropertyTable (destination);
        extendPropertyList (destination, properties);
        Statement statement = con.createStatement ();
        for (Property property : properties) {
            String propertyName = removeBadChars (property.getName ());
            statement.executeUpdate (alterTable.format (new Object [] {getTableName (destination), propertyName, property.getDBColumnType ()}));
        }
        con.commit ();
        con.close ();
        session.close ();
    } catch (SQLException e) {
        con.rollback ();
        session.close ();
        throw e;
    }
}


-----Function Pair=317=-----==

private String findTerm (String column, String value, String namespaceId, Element asd) throws SQLException {
    String statement = getDAO ().getStatement (TABLE_KEY, "FIND_BY_" + column.toUpperCase ());
    statement = getDAO ().getStatement (statement, 1, "'" + value + "'");
    Statement stmt = null;
    ResultSet rs = null;
    try {
        stmt = conn.createStatement ();
        rs = stmt.executeQuery (statement + namespaceId);
        String response = findTerms (rs, asd);
        rs.close ();
        return response;
    } catch (Exception e) {
        throw new SQLException (e.getMessage ());
    } finally {
        if (rs != null) rs.close ();
        if (stmt != null) stmt.close ();
    }
}


private synchronized Object getObject (Class objClass, Serializable id) throws GridBrokerException {
    Object result = null;
    Session s = null;
    Transaction t = null;
    try {
        s = getSession ();
        t = s.beginTransaction ();
        result = s.get (objClass, id);
        t.commit ();
    } catch (Exception e) {
        if (t != null && t.isActive ()) t.rollback ();
        throw new GridBrokerException ("Error getting object:" + id, e);
    } finally {
        closeSession (s);
    }
    return result;
}


-----Function Pair=318=-----==

public void testNestedStatements0026 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0026a " + "  (i   integer not null, " + "   str char(254) not null) ");
    stmt.executeUpdate ("create table #t0026b             " + "  (i   integer not null,      " + "   t   datetime not null)     ");
    stmt.close ();
    PreparedStatement pstmtA = con.prepareStatement ("insert into #t0026a values (?, ?)");
    PreparedStatement pstmtB = con.prepareStatement ("insert into #t0026b values (?, getdate())");
    final int rowsToAdd = 100;
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pstmtA.setInt (1, i);
        StringBuffer tmp = new StringBuffer (255);
        while (tmp.length () < 240) {
            tmp.append ("row ").append (i).append (". ");
        }
        pstmtA.setString (2, tmp.toString ());
        count += pstmtA.executeUpdate ();
        pstmtB.setInt (1, i);
        pstmtB.executeUpdate ();
    }
    assertEquals (count, rowsToAdd);
    pstmtA.close ();
    pstmtB.close ();
    Statement stmtA = con.createStatement (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    Statement stmtB = con.createStatement (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
    count = 0;
    ResultSet rsA = stmtA.executeQuery ("select * from #t0026a");
    assertNotNull (rsA);
    while (rsA.next ()) {
        count ++;
        ResultSet rsB = stmtB.executeQuery ("select * from #t0026b where i=" + rsA.getInt ("i"));
        assertNotNull (rsB);
        assertTrue ("Expected a result set", rsB.next ());
        assertTrue ("Expected no result set", ! rsB.next ());
        rsB.close ();
    }
    assertEquals (count, rowsToAdd);
    stmtA.close ();
    stmtB.close ();
}


public < V extends T > void update (final V entity, Specification < ? > deltaSpecification) {
    if (entity == null) {
        log.debug ("Skipping putting of null entity");
    }
    else {
        final int RETRIES = 3;
        int index = 0;
        boolean success = false;
        Callable < Void > update = new Update (entity);
        while (index < RETRIES && ! success) {
            try {
                update.call ();
                success = true;
            } catch (Exception e) {
                log.warn ("Exception caught while updating entity [type=" + entity.getClass ().getName () + ", entityId=" + entity.getEntityId () + "]");
                ++ index;
                final EntityManager entityManager = getEntityManager ();
                entityManager.clear ();
                final V reAttachedEntity = (V) entityManager.find (entity.getClass (), entity.getEntityId ());
                updateEntityState (reAttachedEntity, deltaSpecification);
                update = new Update (reAttachedEntity);
            }
        }
    }
}


-----Function Pair=319=-----==

public String getAssignmentStatus (String pid, String vid) throws Exception {
    String sql = "select reviewText from event where ACTION_ID='assigned' AND PROPOSAL_ID='";
    sql += pid + "' AND SUBJECTUSR_ID='" + vid + "'";
    PreparedStatement prepStmt = null;
    try {
        con = database.getConnection ();
        prepStmt = con.prepareStatement (sql);
        ResultSet es = prepStmt.executeQuery ();
        if (es.next ()) reviewStatus = es.getString (1);
        else throw new Exception ("Failed to find event for Proposal: " + pid + " assigned to peer-viewer:" + vid);
        prepStmt.close ();
        con.close ();
        return reviewStatus;
    } catch (Exception e) {
        if (! con.isClosed ()) {
            prepStmt.close ();
            con.close ();
        }
        throw e;
    }
}


public Map < String, String > runQuery (String sql) {
    Session session = null;
    Transaction tran = null;
    Map < String, String > infos = new HashMap < String, String > ();
    session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    tran = session.beginTransaction ();
    Connection conn = session.connection ();
    Statement pstmt = null;
    ResultSet rs = null;
    try {
        pstmt = conn.createStatement ();
        pstmt.execute (sql);
        int num = pstmt.getUpdateCount ();
        if (num == - 1) {
            num = 0;
            rs = pstmt.executeQuery (sql);
            while (rs.next ()) {
                num ++;
            }
        }
        infos.put ("ok", String.valueOf (num));
        tran.commit ();
    } catch (SQLException e) {
        tran.rollback ();
        infos.put ("error", e.getMessage ());
        infos.put ("errorCode", e.getErrorCode () + "");
        e.printStackTrace ();
    } finally {
        try {
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (tran != null) {
                tran = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return infos;
}


-----Function Pair=320=-----==

private boolean showLoginDialog () {
    JTextField uname = new JTextField ();
    JPasswordField password = new JPasswordField ();
    int option = JOptionPane.showOptionDialog (null, new Object [] {resources_.getString ("login.name.label", "Name"), uname, resources_.getString ("login.password.label", "Password"), password}, resources_.getString ("login.title", "Login"), JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);
    if ((option == JOptionPane.CLOSED_OPTION) || (option == JOptionPane.CANCEL_OPTION)) {
        return (false);
    }
    try {
        login (uname.getText (), new String (password.getPassword ()), (BACKEND_ACCESS_MODE_READ | BACKEND_ACCESS_MODE_WRITE | BACKEND_ACCESS_MODE_FORCE));
        return (true);
    } catch (Exception e) {
        if (Debug.DEBUG) Debug.println ("exc", e + Debug.getStackTrace (e));
    }
    JOptionPane.showMessageDialog (null, resources_.getString ("admin.invalid_username_or_password.text", "Invalid username or password"), resources_.getString ("admin.invalid_username_or_password.title", "Login Error"), JOptionPane.ERROR_MESSAGE);
    return (showLoginDialog ());
}


public static void BubbleSortLong1 (long [] num) {
    boolean flag = true;
    long temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=321=-----==

public void delete (String className, String [] ids) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer deleteSB = new StringBuffer ();
        deleteSB.append ("delete from " + className + " where id in (");
        for (int i = 0; i < ids.length; i ++) {
            deleteSB.append (ids [i]);
            if (i < ids.length - 1) {
                deleteSB.append (", ");
            }
        }
        deleteSB.append (")");
        Query queryObject = getSession ().createQuery (deleteSB.toString ());
        queryObject.executeUpdate ();
        tx.commit ();
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public boolean delteFavoritesByFid (short fid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Favorites as f where f.id.fid=?");
        query.setParameter (0, fid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=322=-----==

public void testDatetimeRounding3 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 992);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 993);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr3 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr3 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr3");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public List getLockList (String virtualWiki) throws Exception {
    List all = new ArrayList ();
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        PreparedStatement stmt = conn.prepareStatement (STATEMENT_GET_LOCK_LIST);
        stmt.setString (1, virtualWiki);
        ResultSet rs = stmt.executeQuery ();
        while (rs.next ()) {
            TopicLock lock = new TopicLock (rs.getString ("virtualWiki"), rs.getString ("topic"), rs.getTimestamp ("lockat"), rs.getString ("sessionkey"));
            all.add (lock);
        }
        rs.close ();
        stmt.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return all;
}


-----Function Pair=323=-----==

public void test1899Date () throws Exception {
    Calendar originalValue = Calendar.getInstance ();
    originalValue.set (Calendar.MONTH, Calendar.DECEMBER);
    originalValue.set (Calendar.DAY_OF_MONTH, 31);
    originalValue.set (Calendar.YEAR, 1899);
    originalValue.set (Calendar.HOUR_OF_DAY, 23);
    originalValue.set (Calendar.MINUTE, 59);
    originalValue.set (Calendar.SECOND, 59);
    originalValue.set (Calendar.MILLISECOND, 990);
    PreparedStatement pstmt = con.prepareStatement ("select ?");
    pstmt.setTimestamp (1, new Timestamp (originalValue.getTime ().getTime ()));
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    final long expectedTime = originalValue.getTime ().getTime ();
    final long actualTime = getTimeInMs (rs);
    assertEquals (expectedTime, actualTime);
    assertFalse (rs.next ());
    rs.close ();
    pstmt.close ();
}


private Hashtable getApplicant (String id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        prepareRenderer (r, id);
        sql = r.getSQLSelect ("adm_applicant");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            return getApplicantData (rs);
        }
        else {
            return null;
        }
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=324=-----=1=

public void execute (JobExecutionContext context) throws JobExecutionException {
    super.execute (context);
    debug ("Start execute job " + this.getClass ().getName ());
    String dir = this.path_app_root + "/" + this.properties.get ("dir") + "/";
    try {
        File dir_f = new File (dir);
        if (! dir_f.exists ()) {
            debug ("(0) - make dir: " + dir_f + " - ");
            org.apache.commons.io.FileUtils.forceMkdir (dir_f);
        }
    } catch (IOException ex) {
        fatal ("IOException", ex);
    }
    debug ("Files:" + this.properties.get ("url"));
    String [] url_to_download = properties.get ("url").split (";");
    for (String u : url_to_download) {
        if (StringUtil.isNullOrEmpty (u)) {
            continue;
        }
        u = StringUtil.trim (u);
        debug ("(0) url: " + u);
        String f_name = u.substring (u.lastIndexOf ("/"), u.length ());
        debug ("(1) - start download: " + u + " to file name: " + new File (dir + "/" + f_name).toString ());
        com.utils.HttpUtil.downloadData (u, new File (dir + "/" + f_name).toString ());
    }
    try {
        conn_stats.setAutoCommit (false);
    } catch (SQLException e) {
        fatal ("SQLException", e);
    }
    String [] query_delete = properties.get ("query_delete").split (";");
    for (String q : query_delete) {
        if (StringUtil.isNullOrEmpty (q)) {
            continue;
        }
        q = StringUtil.trim (q);
        debug ("(2) - " + q);
        try {
            Statement stat = conn_stats.createStatement ();
            stat.executeUpdate (q);
            stat.close ();
        } catch (SQLException e) {
            try {
                conn_stats.rollback ();
            } catch (SQLException ex) {
                fatal ("SQLException", ex);
            }
            fatal ("SQLException", e);
        }
    }
    for (String u : url_to_download) {
        if (StringUtil.isNullOrEmpty (u)) {
            continue;
        }
        u = StringUtil.trim (u);
        try {
            Statement stat = conn_stats.createStatement ();
            String f_name = new File (dir + "/" + u.substring (u.lastIndexOf ("/"), u.length ())).toString ();
            debug ("(3) - start import: " + f_name);
            BigFile lines = new BigFile (f_name);
            int n = 0;
            for (String l : lines) {
                String fields [] = l.split (",");
                String query = "";
                if (f_name.indexOf ("hip_countries.csv") != - 1) {
                    query = "insert into hip_countries values (" + fields [0] + ",'" + normalize (fields [1]) + "','" + normalize (fields [2]) + "')";
                }
                else if (f_name.indexOf ("hip_ip4_city_lat_lng.csv") != - 1) {
                    query = "insert into hip_ip4_city_lat_lng values (" + fields [0] + ",'" + normalize (fields [1]) + "'," + fields [2] + "," + fields [3] + ")";
                }
                else if (f_name.indexOf ("hip_ip4_country.csv") != - 1) {
                    query = "insert into hip_ip4_country values (" + fields [0] + "," + fields [1] + ")";
                }
                debug (n + " - " + query);
                stat.executeUpdate (query);
                n ++;
            }
            debug ("(4) tot import per il file" + f_name + " : " + n);
            stat.close ();
            new File (f_name).delete ();
        } catch (SQLException ex) {
            fatal ("SQLException", ex);
            try {
                conn_stats.rollback ();
            } catch (SQLException ex2) {
                fatal ("SQLException", ex2);
            }
        } catch (IOException ex) {
            fatal ("IOException", ex);
        } catch (Exception ex3) {
            fatal ("Exception", ex3);
        }
    }
    try {
        conn_stats.commit ();
    } catch (SQLException e) {
        fatal ("SQLException", e);
    }
    try {
        conn_stats.setAutoCommit (true);
    } catch (SQLException e) {
        fatal ("SQLException", e);
    }
    try {
        debug ("(6) Vacuum");
        Statement stat = this.conn_stats.createStatement ();
        stat.executeUpdate ("VACUUM");
        stat.close ();
    } catch (SQLException e) {
        fatal ("SQLException", e);
    }
    debug ("End execute job " + this.getClass ().getName ());
}


public void update (Channel channel) throws Exception {
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    String exp = channel.getExtendParent ();
    String path = channel.getPath ();
    try {
        String sqlStr = "UPDATE t_ip_channel SET id=?,name=?,description=?,ascii_name=?,site_id=?,type=?,data_url=?,template_id=?,use_status=?,order_no=?,style=?,creator=?,create_date=?,refresh_flag=?,page_num=? where channel_path=?";
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        connection.setAutoCommit (false);
        String [] selfDefinePath = getSelfDefinePath (path, exp, connection, preparedStatement, resultSet);
        selfDefineDelete (selfDefinePath, connection, preparedStatement);
        selfDefineAdd (selfDefinePath, channel, connection, preparedStatement);
        preparedStatement = connection.prepareStatement (sqlStr);
        preparedStatement.setInt (1, channel.getChannelID ());
        preparedStatement.setString (2, channel.getName ());
        preparedStatement.setString (3, channel.getDescription ());
        preparedStatement.setString (4, channel.getAsciiName ());
        preparedStatement.setInt (5, channel.getSiteId ());
        preparedStatement.setString (6, channel.getChannelType ());
        preparedStatement.setString (7, channel.getDataUrl ());
        if (channel.getTemplateId () == null || channel.getTemplateId ().trim ().equals ("")) preparedStatement.setNull (8, Types.INTEGER);
        else preparedStatement.setInt (8, Integer.parseInt (channel.getTemplateId ()));
        preparedStatement.setString (9, channel.getUseStatus ());
        preparedStatement.setInt (10, channel.getOrderNo ());
        preparedStatement.setString (11, channel.getStyle ());
        preparedStatement.setInt (12, channel.getCreator ());
        preparedStatement.setTimestamp (13, (Timestamp) channel.getCreateDate ());
        preparedStatement.setString (14, channel.getRefresh ());
        preparedStatement.setInt (15, channel.getPageNum ());
        preparedStatement.setString (16, channel.getPath ());
        preparedStatement.executeUpdate ();
        connection.commit ();
        int resID = channel.getChannelID () + Const.CHANNEL_TYPE_RES;
        StructResource sr = new StructResource ();
        sr.setResourceID (Integer.toString (resID));
        sr.setOperateID (Integer.toString (1));
        sr.setOperateTypeID (Const.OPERATE_TYPE_ID);
        sr.setTypeID (Const.RES_TYPE_ID);
        StructAuth sa = new AuthorityManager ().getExternalAuthority (sr);
        int authID = sa.getAuthID ();
        if (authID == 0) {
            String resName = channel.getName ();
            int resTypeID = Const.RES_TYPE_ID;
            int operateTypeID = Const.OPERATE_TYPE_ID;
            String remark = "";
            AuthorityManager am = new AuthorityManager ();
            am.createExtResource (Integer.toString (resID), resName, resTypeID, operateTypeID, remark);
        }
    } catch (SQLException ex) {
        connection.rollback ();
        log.error ("����Ƶ��ʧ�ܣ�channelPath=" + channel.getPath ());
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
}


-----Function Pair=325=-----==

private DTSTransferObject [] previewSubsetDiffORA (int subsetId1, int subsetId2, PreviewOptions options) throws SQLException {
    Statement getSubsDiffStmt = null;
    try {
        String getSubsDiffQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_SUBSETS_DIFF);
        if (options.getPreviewType () == PreviewOptions.DIFF_ADDITIONS) {
            getSubsDiffQuery = this.subsetDAO.getStatement (getSubsDiffQuery, 1, String.valueOf (subsetId1));
            getSubsDiffQuery = this.subsetDAO.getStatement (getSubsDiffQuery, 2, String.valueOf (subsetId2));
        }
        else if (options.getPreviewType () == PreviewOptions.DIFF_DELETIONS) {
            getSubsDiffQuery = this.subsetDAO.getStatement (getSubsDiffQuery, 1, String.valueOf (subsetId2));
            getSubsDiffQuery = this.subsetDAO.getStatement (getSubsDiffQuery, 2, String.valueOf (subsetId1));
        }
        else {
            throw new IllegalArgumentException ("Only PreviewOptions.DIFF_ADDITIONS and PreviewOptions.DIFF_DELETIONS are supported for previewing differences.");
        }
        getSubsDiffQuery = this.subsetDAO.getStatement (getSubsDiffQuery, 3, String.valueOf (options.getLimit ()));
        getSubsDiffStmt = this.conn.createStatement ();
        ResultSet rs = getSubsDiffStmt.executeQuery (getSubsDiffQuery);
        Categories.dataDb ().debug ("Preview SQL [" + getSubsDiffQuery + "]");
        ArrayList al = new ArrayList (20);
        while (rs.next ()) {
            int concept_id = rs.getInt (1);
            String concept_code = rs.getString (2);
            String concept_name = rs.getString (3);
            int namespaceId = rs.getInt (4);
            DTSTransferObject dto = new DTSTransferObject (concept_id, concept_code, concept_name, namespaceId);
            al.add (dto);
        }
        rs.close ();
        DTSTransferObject [] dtoa = new DTSTransferObject [al.size ()];
        dtoa = (DTSTransferObject []) al.toArray (dtoa);
        return dtoa;
    } finally {
        if (getSubsDiffStmt != null) {
            getSubsDiffStmt.close ();
        }
    }
}


public static void academic_save (String applicant_id, Vector examInfo, Hashtable grade) throws Exception {
    Hashtable info = new Hashtable ();
    info.put ("applicant_id", applicant_id);
    for (int i = 0; i < examInfo.size (); i ++) {
        Hashtable exam = (Hashtable) examInfo.elementAt (i);
        String exam_id = (String) exam.get ("id");
        Vector subjects = (Vector) exam.get ("subjects");
        for (int k = 0; k < subjects.size (); k ++) {
            Hashtable subject = (Hashtable) subjects.elementAt (k);
            String subject_id = (String) subject.get ("id");
            info.put (subject_id, grade.get (subject_id));
        }
    }
    ExamResultData.save (examInfo, info);
}


-----Function Pair=326=-----==

public RowSet stmt_getRowSet (CStatementVO info, SecurityToken token) {
    validateSecurityToken (token);
    if (info.getTrxName () != null) {
        if (Trx.get (info.getTrxName (), false) == null) throw new RuntimeException ("Transaction lost - " + info.getTrxName ());
    }
    m_stmt_rowSetCount ++;
    CPreparedStatement stmt = new CPreparedStatement (info);
    RowSet rowset = null;
    try {
        rowset = stmt.getRowSet ();
    } finally {
        DB.close (stmt);
    }
    return rowset;
}


public RestServiceResult delete (RestServiceResult serviceResult, CoMatrixExercises2 coMatrixExercises2) {
    String sExerciseName = null;
    try {
        sExerciseName = coMatrixExercises2.getCoExercises2 ().getExerciseName ();
        log.error ("Eliminando la matriz tipo 2: " + sExerciseName);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_MATRIX_EXERCISES2);
        query.setParameter (1, coMatrixExercises2.getMatrixId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sExerciseName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises2.delete.success"), arrayParam));
        log.info ("Eliminando matriz tipo 2: " + sExerciseName);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la matriz tipo 2: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coMatrixExercises2.getCoExercises2 ().getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises2.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


-----Function Pair=327=-----==

public boolean exportSubset (String user, int subsetId, int namespaceId, QuerySession qs, DTSPermission permit) throws SQLException, DTSValidationException, PermissionException {
    checkPermission (permit, String.valueOf (namespaceId));
    boolean exported = false;
    PreparedStatement exportSubsetNspStmt = null;
    if (! checkNamespacePresent (namespaceId)) {
        throw new DTSValidationException ("Namespace [" + namespaceId + "] not present in the knowledgebase for the subset [ " + subsetId + "] to be exported to that namespace. Please create one and retry exporting subset.");
    }
    String assocSeqName = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_ASSOC_SEQ_NAME);
    int origTransLevel = Utilities.beginTransaction (this.conn);
    long beg = System.currentTimeMillis ();
    try {
        HashMap assocMap = new HashMap (100);
        int count = 0;
        int assocId = 1;
        long assocGid = GidGenerator.getGID (namespaceId, assocId);
        deleteNamespaceRelated (namespaceId, assocGid, qs);
        qs.check ();
        qs.setStatus ("Fetching Subset Concepts ...");
        DTSTransferObject [] subsetCons = this.getSubsetConcepts (subsetId, qs);
        qs.check ();
        String exportNspQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, EXPORT_SUBSET_NSP_STMT);
        exportSubsetNspStmt = this.conn.prepareStatement (exportNspQuery);
        int smallBatchSize = 1000;
        if (SQL.getConnType (conn).equals (SQL.ORACLE)) {
            ((oracle.jdbc.driver.OraclePreparedStatement) exportSubsetNspStmt).setExecuteBatch (smallBatchSize);
        }
        addSubsetAssocType (namespaceId, assocId, assocGid);
        qs.check ();
        qs.setStatus ("Exporting Subset Concepts to Namespace ...");
        qs.startExecute (exportSubsetNspStmt);
        for (int i = 0; i < subsetCons.length; i ++) {
            DTSTransferObject dt = subsetCons [i];
            int origConNamespaceId = dt.getNamespaceId ();
            long origConceptGid = GidGenerator.getGID (origConNamespaceId, dt.getId ());
            int conceptId = i + 1;
            long conceptGid = GidGenerator.getGID (namespaceId, conceptId);
            String conceptCode = "C" + conceptId;
            exportSubsetNspStmt.setLong (1, conceptGid);
            exportSubsetNspStmt.setInt (2, conceptId);
            exportSubsetNspStmt.setString (3, conceptCode);
            exportSubsetNspStmt.setString (4, dt.getName ());
            exportSubsetNspStmt.setInt (5, namespaceId);
            exportSubsetNspStmt.setString (6, dt.getName ().toUpperCase ());
            exportSubsetNspStmt.executeUpdate ();
            if (assocGid > 0) {
                Long fromCon = new Long (conceptGid);
                if (assocMap.containsKey (fromCon)) {
                    Vector toConVec = (Vector) assocMap.get (fromCon);
                    toConVec.addElement (new Long (origConceptGid));
                    assocMap.put (fromCon, toConVec);
                }
                else {
                    Vector toConVec = new Vector (2);
                    toConVec.addElement (new Long (origConceptGid));
                    assocMap.put (fromCon, toConVec);
                }
            }
            if ((++ count % 1000) == 0) {
                Categories.dataDb ().debug ("Exported [" + count + "] concepts to namespace [" + namespaceId + "]  for subset_id [" + subsetId + "]...");
            }
        }
        Categories.dataDb ().debug ("Exported successfully [" + count + "] concepts to namespace [" + namespaceId + "]  for subset_id [" + subsetId + "].");
        qs.endExecute ();
        qs.check ();
        this.conn.commit ();
        qs.setStatus ("Adding Concept Associations ...");
        this.addAssociations (assocMap, assocGid, assocSeqName, qs);
        qs.check ();
        this.conn.commit ();
        qs.setStatus ("Exported [" + count + "] concepts to namespace [" + namespaceId + "]");
        exported = true;
        long end = System.currentTimeMillis ();
        Categories.dataDb ().debug ("Exported [" + count + "] concepts to namespace [" + namespaceId + "] done in " + (end - beg) / 1000 + " secs");
        return exported;
    } catch (SQLException sqle) {
        Categories.dataDb ().error ("Problem exporting subset_id [" + subsetId + "] to namespace [" + namespaceId + "] : " + sqle.getMessage ());
        this.conn.rollback ();
        throw sqle;
    } finally {
        Utilities.endTransaction (this.conn, origTransLevel);
        if (exportSubsetNspStmt != null) {
            exportSubsetNspStmt.close ();
        }
    }
}


public static void registerFeatureLayer (Connection con) throws Exception {
    Statement select_layer_stmt = null;
    PreparedStatement update_layer_stmt = null;
    PreparedStatement insert_property_stmt = null;
    PreparedStatement delete_property_stmt = null;
    ResultSet rs = null;
    try {
        String project_name = "giews";
        MapContext map_context = new MapContext (project_name, new Configuration ());
        String update_layer_SQL = " update FEATURE_LAYER set X = ?, Y = ?, WIDTH = ?, HEIGHT = ? where ID = ? ";
        update_layer_stmt = con.prepareStatement (update_layer_SQL);
        String insert_property_SQL = " insert into FEATURE_LAYER_PROPERTY values ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )";
        insert_property_stmt = con.prepareStatement (insert_property_SQL);
        String delete_property_SQL = " delete from FEATURE_LAYER_PROPERTY where FEATURE_LAYER_ID =  ?  ";
        delete_property_stmt = con.prepareStatement (delete_property_SQL);
        String select_layer_SQL = " select PROJECT.LABEL as MAP_LABEL, F.ID as ID, F.LABEL as LABEL, F.CATEGORY, F.AREA_CODE, F.TOPIC_CODE, F.SOURCE_FILE as SOURCE_FILE, F.LEGEND_ID, F.METADATA_ID, F.X, F.Y, F.WIDTH, F.HEIGHT, F.NOTES " + " from FEATURE_LAYER F, PROJECT " + " where PROJECT.AREA_CODE = F.AREA_CODE " + " and F.X is null ";
        select_layer_stmt = con.createStatement ();
        rs = select_layer_stmt.executeQuery (select_layer_SQL);
        while (rs.next ()) {
            String map_name = rs.getString ("MAP_LABEL");
            int ID = rs.getInt ("ID");
            String layer_name = rs.getString ("LABEL");
            String layer_filename = fixUNC (rs.getString ("SOURCE_FILE"));
            try {
                Debug.println ("Register layer : " + ID + ", " + layer_name + ", " + layer_filename);
                Map map = new Map (map_context, map_name, new Configuration ());
                FeatureLayer flayer = getFeatureLayer (map, layer_name, layer_filename, true);
                map.addLayer (flayer, true);
                Rectangle2D bounds_ll = bounds_ll = flayer.getBounds2D ();
                update_layer_stmt.setDouble (1, bounds_ll.getX ());
                update_layer_stmt.setDouble (2, bounds_ll.getY ());
                update_layer_stmt.setDouble (3, bounds_ll.getWidth ());
                update_layer_stmt.setDouble (4, bounds_ll.getHeight ());
                update_layer_stmt.setInt (5, ID);
                update_layer_stmt.execute ();
                delete_property_stmt.setInt (1, ID);
                delete_property_stmt.execute ();
                Iterator properties = flayer.getFeaturePropertiesIterator ();
                insert_property_stmt.setInt (1, ID);
                while (properties.hasNext ()) {
                    FeatureProperties prop = (FeatureProperties) properties.next ();
                    if (prop.code != null && prop.code.length () > 0) {
                        insert_property_stmt.setString (2, prop.getCode ());
                        insert_property_stmt.setString (3, prop.getLabel ());
                        insert_property_stmt.setString (4, prop.getChildMap ());
                        insert_property_stmt.setDouble (5, prop.getLocation ().getX ());
                        insert_property_stmt.setDouble (6, prop.getLocation ().getY ());
                        insert_property_stmt.setInt (7, prop.getAnchor ());
                        insert_property_stmt.setString (8, (prop.getShow () ? "Y" : "N"));
                        insert_property_stmt.setString (9, (prop.getShowAnchorTriange () ? "Y" : "N"));
                        insert_property_stmt.setString (10, XMLUtil.XMLtoString (prop.getPatternOutline ()));
                        insert_property_stmt.execute ();
                    }
                }
                con.commit ();
            } catch (Exception e) {
                Debug.println (">>>>>> FAILED : " + ID + ", " + layer_name + ", " + layer_filename);
                Debug.println (e);
                con.rollback ();
            }
        }
    } catch (Exception e) {
        Debug.println (e);
    } finally {
        try {
            select_layer_stmt.close ();
        } catch (Exception e) {
        }
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            insert_property_stmt.close ();
        } catch (Exception e) {
        }
        try {
            delete_property_stmt.close ();
        } catch (Exception e) {
        }
        try {
            update_layer_stmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=328=-----==

private String findNamespaceID (String column, String value) throws SQLException {
    String statement = getDAO ().getStatement (TABLE_KEY, "GET_NAMESPACE");
    statement += (" " + getDAO ().getStatement (TABLE_KEY, "FIND_NAMESPACE_BY_" + column.toUpperCase ()));
    statement += ("'" + value + "'");
    ResultSet res = findNamespaceSt.executeQuery (statement);
    int id = - 1;
    while (res.next ()) {
        id = res.getInt (1);
    }
    String idString = "";
    if (id != - 1) {
        idString = Integer.toString (id);
    }
    return idString;
}


public static void createMySQLTableFromDictionary (DefTable defTable) {
    DefColumns defColumns = defTable.getDefColumns ();
    StringBuilder sqlColumns = new StringBuilder ();
    StringBuilder sqlPrimaryKeyColumns = new StringBuilder ();
    for (int i = 0; i < defColumns.size (); i ++) {
        DefColumn defColumn = defColumns.getDefColumn (i);
        if ((defColumn.isVirtual () == false) && (defColumn.isMultivalue () == false)) {
            if (sqlColumns.length () != 0) {
                sqlColumns.append (",");
            }
            sqlColumns.append ("\n`" + defColumn.getColumnName () + "` " + getMySQLDataType (defColumn) + " ");
            if (defColumn.isPrimaryKey () == true) {
                sqlColumns.append (" NOT NULL ");
            }
            else {
                sqlColumns.append (" default NULL ");
            }
        }
        if ((defColumn.isPrimaryKey () == true) && (defColumn.isMultivalue () == false)) {
            if (sqlPrimaryKeyColumns.length () != 0) {
                sqlPrimaryKeyColumns.append (",");
            }
            sqlPrimaryKeyColumns.append ("`" + defColumn.getColumnName () + "`");
        }
    }
    StringBuilder sqlCreate = new StringBuilder ();
    if (defTable.getConnectionName ().trim ().equals ("") == false) {
        sqlCreate.append ("(" + defTable.getConnectionName () + ")");
    }
    sqlCreate.append ("CREATE TABLE `" + defTable.getTableName () + "` (\n");
    sqlCreate.append (sqlColumns);
    sqlCreate.append (",\nPRIMARY KEY  (" + sqlPrimaryKeyColumns.toString () + ")");
    sqlCreate.append ("\n)");
    DLSession.getConnection ().executeUpdate (sqlCreate.toString ());
}


-----Function Pair=329=-----==

public static boolean sameExists (String query) throws SQLException {
    Connection conn = null;
    Statement st = null;
    ResultSet rs = null;
    try {
        conn = dataSource.getConnection ();
        st = conn.createStatement ();
        rs = st.executeQuery (query);
        while (rs.next ()) {
            return true;
        }
        return false;
    } finally {
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            st.close ();
        } catch (Exception e) {
        }
        try {
            conn.close ();
        } catch (Exception e) {
        }
    }
}


public Imagetypes findImagetypeById (short id) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Imagetypes types = (Imagetypes) session.get (Imagetypes.class, id);
        tr.commit ();
        return types;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=330=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nTestId) {
    CoTest coTest = new CoTestDAO ().findById (nTestId);
    if (coTest == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("test.search.notFound"));
    }
    else {
        List < CoTest > list = new ArrayList < CoTest > ();
        EntityManagerHelper.refresh (coTest);
        list.add (coTest);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("test.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public RestServiceResult update (RestServiceResult serviceResult, CoSingleTextCheckList2 coSingleTextCheckList) {
    CoSingleTextCheckList2DAO coSingleTextCheckListDAO = new CoSingleTextCheckList2DAO ();
    try {
        log.info ("Actualizando la t�cnica: " + coSingleTextCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        coSingleTextCheckListDAO.update (coSingleTextCheckList);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coSingleTextCheckList);
        Object [] arrayParam = {coSingleTextCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.update.success"), arrayParam));
        log.info ("Se actualizo la t�cnica con �xito: " + coSingleTextCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la t�cnica: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


-----Function Pair=331=-----==

public Integer [] getExtendingNamespaces (int namespaceId, DTSPermission permit) throws SQLException, XMLException {
    getExtendStmt.setInt (1, namespaceId);
    ResultSet rs = getExtendStmt.executeQuery ();
    ArrayList al = new ArrayList ();
    if (rs != null) {
        while (rs.next ()) {
            int nid = rs.getInt (1);
            al.add (new Integer (nid));
        }
        rs.close ();
    }
    Integer [] na = new Integer [al.size ()];
    na = (Integer []) al.toArray (na);
    return na;
}


private String getNewId () {
    idFlag.getBusyFlag ();
    if (id == null) {
        id = new char [NetTransferObject.MAX_LEN];
        for (int i = 0; i < NetTransferObject.MAX_LEN; i ++) id [i] = (char) 1;
    }
    String newId = new String (id);
    id [NetTransferObject.MAX_LEN - 1] ++;
    for (int i = (NetTransferObject.MAX_LEN - 1); i >= 0; i --) {
        if (id [i] == Character.MAX_VALUE) {
            id [i] = 1;
            if (i != 1) id [i - 1] ++;
            for (int j = i; j < NetTransferObject.MAX_LEN; j ++) id [j] = 1;
        }
        else break;
    }
    idFlag.freeBusyFlag ();
    return newId;
}


-----Function Pair=332=-----==

private static void query (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            LOGGER.info ("Found: " + person);
            for (Address address : person.getAddresses ()) {
                LOGGER.info ("  with address: " + address);
            }
        }
    } finally {
        session.close ();
    }
}


private void addNewStructure (String code, int path_no) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("period_schema_code");
            r.add ("period_schema_code", code);
            sql = r.getSQLSelect ("period_root");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (! found) {
            r.clear ();
            r.add ("period_schema_code", code);
            r.add ("period_root_id", code);
            r.add ("path_no", path_no);
            sql = r.getSQLInsert ("period_root");
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=333=-----==

private static void query (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            LOGGER.info ("Found: " + person);
            for (Address address : person.getAddresses ()) {
                LOGGER.info ("  with address: " + address);
            }
        }
    } finally {
        session.close ();
    }
}


public static int markProbeStarted (Db statusDb, ProbeBase probeBase, boolean trialRun) throws ControlProblem, Exception {
    _logger.debug ("Marking probe (" + probeBase.getClass ().getName () + ") as about to start with trial (" + trialRun + ")");
    if (trialRun) return - 1;
    _logger.debug ("Entering in synchronized section");
    synchronized (lock) {
        try {
            statusDb.begin ();
            Integer thread = DbHelper.getKey (statusDb.prepareStatement ("SELECT thread FROM e_probe_pid WHERE lower(probe_name) = lower('" + probeBase.getClass ().getName () + "')"));
            if (thread != null) {
                System.out.println ("The probe (" + probeBase.getClass ().getName () + ") is marked as already started. Use stop to kill id and or reset its state");
                throw new IllegalStateException ("The probe (" + probeBase.getClass ().getName () + ") is already started");
            }
            PreparedStatement ps_start = statusDb.prepareStatement ("INSERT INTO e_probe_history (probe_name, run_date, no_data, e_probe_run_status_id) VALUES (?, current_timestamp, true, ?) RETURNING e_probe_history_id");
            ps_start.setString (1, probeBase.getClass ().getName ());
            ps_start.setInt (2, ProbeStatus.NO_DATA);
            int id = DbHelper.getKey (ps_start);
            probeBase.setProbeHistoryId (id);
            unstartedProbes.add (probeBase);
            return id;
        } catch (Exception e) {
            statusDb.rollback ();
            throw e;
        } finally {
            statusDb.commitUnless ();
            _logger.debug ("Leaving synchronized section");
        }
    }
}


-----Function Pair=334=-----==

public static Hashtable getTableKey (Connection conn) throws Exception {
    StringBuffer sbTableKey = new StringBuffer ();
    sbTableKey.append ("SELECT * FROM SYS_TABLE_KEY");
    Hashtable htTableKey = new Hashtable ();
    PreparedStatement preStatTableKey = null;
    ResultSet rsTableKey = null;
    preStatTableKey = conn.prepareStatement (sbTableKey.toString ());
    rsTableKey = preStatTableKey.executeQuery ();
    while (rsTableKey.next ()) {
        htTableKey.put (rsTableKey.getString (1).trim (), new Integer (rsTableKey.getInt (2)));
    }
    preStatTableKey.close ();
    rsTableKey.close ();
    return htTableKey;
}


protected void drop (Context context) throws DataStoreException, ServletException {
    Integer category = context.getValueAsInteger (KEYFN);
    if (category != null) {
        if (category.intValue () == CATEGORYROOT) {
            throw new DataAuthException ("You may not delete the root category");
        }
        else {
            Stack queries = new Stack ();
            Object id = context.getValueAsString (keyField);
            Object parent = context.getValueAsString ("parent");
            queries.push ("update article set category = " + parent + " where category = " + id);
            queries.push ("update event set category = " + parent + " where category = " + id);
            queries.push ("update category set parent = " + parent + " where parent = " + id);
            fixupCategoryAncestry (context);
            super.drop (context, id, queries);
        }
    }
}


-----Function Pair=335=-----==

public Date findUpToDate (Date fromRemoteDb, RemoteFileState in, String dir) throws Exception {
    Date fromLocalDb = null;
    if (in.pf == null) return fromRemoteDb;
    Db db = getDb ();
    try {
        db.enter ();
        ps_find_date2.setString (1, dir);
        ps_find_date2.setString (2, in.orig_filename);
        ps_find_date2.setString (3, in.pf.getClassName ());
        ResultSet rs = db.executeQuery (ps_find_date2);
        if (rs.next ()) fromLocalDb = DateHelper.toDateOrNull (rs.getTimestamp (1));
    } finally {
        db.exit ();
    }
    if (fromLocalDb == null && fromRemoteDb != null) return fromRemoteDb;
    if (fromLocalDb != null && fromRemoteDb == null) return fromLocalDb;
    if (fromLocalDb == null && fromRemoteDb == null) return null;
    if (fromLocalDb.before (fromRemoteDb)) return fromRemoteDb;
    else return fromLocalDb;
}


public synchronized void updateMessage (FrostMessageObject mo) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps = db.prepareStatement ("UPDATE " + getMessageTableName () + " SET isdeleted=?,isnew=?,isreplied=?,isjunk=?,isflagged=?,isstarred=? " + "WHERE msgdatetime=? AND msgindex=? AND board=?");
    int ix = 1;
    ps.setBoolean (ix ++, mo.isDeleted ());
    ps.setBoolean (ix ++, mo.isNew ());
    ps.setBoolean (ix ++, mo.isReplied ());
    ps.setBoolean (ix ++, mo.isJunk ());
    ps.setBoolean (ix ++, mo.isFlagged ());
    ps.setBoolean (ix ++, mo.isStarred ());
    ps.setLong (ix ++, mo.getDateAndTime ().getMillis ());
    ps.setInt (ix ++, mo.getIndex ());
    ps.setInt (ix ++, mo.getBoard ().getPrimaryKey ().intValue ());
    int updated = ps.executeUpdate ();
    if (updated == 0) {
        System.out.println ("UPDATED is 0!!!!");
    }
    ps.close ();
}


-----Function Pair=336=-----==

protected void doNew (Connection con) throws Exception {
    if (! isValidate ()) {
        throw new CesSystemException ("Organize.doNew(): Illegal data values for insert");
    }
    PreparedStatement ps = null;
    String strQuery = "INSERT INTO " + Common.ORGANIZE_TABLE + "(organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y) " + "VALUES (?,?,?,?,?,?,?,?,?)";
    logger.debug ("wbq:6" + strQuery);
    try {
        ps = con.prepareStatement (strQuery);
        ps.setString (1, String.valueOf (this.organizeID));
        ps.setString (2, this.organizeTypeID);
        ps.setString (3, this.organizeName);
        ps.setString (4, this.organizeManager);
        ps.setString (5, this.organizeDescribe);
        ps.setString (6, this.workType);
        ps.setInt (7, showOrder);
        ps.setInt (8, this.positionX);
        ps.setInt (9, this.positionY);
        int resultCount = ps.executeUpdate ();
        if (resultCount != 1) {
            throw new CesSystemException ("Organize.doNew(): ERROR Inserting data " + "in T_SYS_ORGANIZE INSERT !! resultCount = " + resultCount);
        }
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.doNew(): SQLException while inserting new organize; " + "organize_id = " + this.organizeID + " :\n\t" + se);
    } finally {
        closePreparedStatement (ps);
    }
}


public static Vector getNewProducts (String subject) {
    Vector vec = new Vector ();
    Connection con = null;
    try {
        con = getConnection ();
        PreparedStatement statement = con.prepareStatement ("SELECT i_id, i_title, a_fname, a_lname " + "FROM item, author " + "WHERE item.i_a_id = author.a_id " + "AND item.i_subject = ? " + "ORDER BY item.i_pub_date DESC,item.i_title " + "LIMIT 0,50");
        statement.setString (1, subject);
        ResultSet rs = statement.executeQuery ();
        while (rs.next ()) {
            vec.addElement (new ShortBook (rs));
        }
        rs.close ();
        statement.close ();
        con.commit ();
        returnConnection (con);
    } catch (java.lang.Exception ex) {
        try {
            ex.printStackTrace ();
        } catch (Exception se) {
            System.err.println ("Transaction rollback failed.");
        }
    }
    return vec;
}


-----Function Pair=337=-----==

public static int deleteHql (Session session, String deleteHql, List < ISParameter > qualifications, ServiceCall call) throws Exception {
    if (call.isDebug ()) {
        Log.warn (getDebug (deleteHql, qualifications));
    }
    Query query = session.createQuery (deleteHql);
    for (ISParameter param : qualifications) {
        if (param.isList ()) {
            query.setParameterList (param.getName (), param.getValues ());
        }
        else {
            query.setParameter (param.getName (), param.getValue ());
        }
    }
    return query.executeUpdate ();
}


public < T > T merge (EntityManager em, T obj) throws RuntimeException {
    T rtnVal = null;
    boolean doCloseEntityManager = false;
    EntityManager emTemp = em;
    if (emTemp == null) {
        emTemp = getEntityManager ();
        doCloseEntityManager = true;
    }
    if (emTemp != null) {
        EntityTransaction et = emTemp.getTransaction ();
        try {
            if (et.isActive () == false) {
                et.begin ();
            }
            rtnVal = emTemp.merge (obj);
            if (et.isActive ()) {
                et.commit ();
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            if (doCloseEntityManager) {
                emTemp.close ();
            }
            throw new RuntimeException (exception);
        }
        if (doCloseEntityManager) {
            emTemp.close ();
        }
    }
    return rtnVal;
}


-----Function Pair=338=-----==

public < T > List < T > query (EntityManager em, Class < T > entityClass, int firstResult, int maxResultSize, String strQuery, Object...objs) throws RuntimeException {
    List < T > rtnVal = new ArrayList < T > ();
    List < ? > valTemp = null;
    boolean doCloseEntityManager = false;
    EntityManager emTemp = em;
    if (emTemp == null) {
        emTemp = getEntityManager ();
        doCloseEntityManager = true;
    }
    if (emTemp != null) {
        try {
            Query query = emTemp.createQuery (strQuery);
            if (objs != null) {
                int index = 1;
                for (Object obj : objs) {
                    query.setParameter (index ++, obj);
                }
            }
            if (query != null) {
                if (firstResult > 0) {
                    query.setFirstResult (firstResult);
                }
                if (maxResultSize > 0) {
                    query.setMaxResults (maxResultSize);
                }
                valTemp = query.getResultList ();
            }
        } catch (Exception exception) {
            if (doCloseEntityManager) {
                emTemp.close ();
            }
            throw new RuntimeException (exception);
        }
        if (doCloseEntityManager) {
            emTemp.close ();
        }
    }
    if (valTemp != null) {
        for (Object vObj : valTemp) {
            try {
                T tObj = entityClass.cast (vObj);
                if (tObj != null) {
                    rtnVal.add (tObj);
                }
            } catch (Exception exception) {
                throw new RuntimeException (exception);
            }
        }
    }
    return rtnVal;
}


public Vector getAllFromCategory (String gallery, String categoryname, int orderby) {
    Vector mediavector = new Vector ();
    if (categoryname != null && gallery != null) {
        String table = "";
        if (mediatype.equals (MediaVariables.MEDIA_TYPE_RINGTONE)) {
            table = MediaVariables.TABLE_RINGTONE;
        }
        else if (mediatype.equals (MediaVariables.MEDIA_TYPE_ICON)) {
            table = MediaVariables.TABLE_ICON;
        }
        else {
            return mediavector;
        }
        String order = null;
        switch (orderby) {
            case ORDER_BY_ALFABETHICAL :
                order = "and category='" + categoryname + "' order by " + table + ".name";
                break;
            case ORDER_BY_TOP_TEN :
                order = "order by " + table + ".counter DESC";
                break;
            case ORDER_BY_NEW :
                order = "order by " + table + ".in_date DESC, lower(" + table + ".name)";
                break;
            default :
                order = "order by " + table + ".name";
                break;
        }
        try {
            theConnection = DBServiceManager.allocateConnection (database);
            String query = "SELECT name, " + table + ".reference ";
            query += "FROM " + table + "," + gallery + " ";
            query += "WHERE data_type='" + mediatype + "' ";
            query += "AND " + table + ".reference = " + gallery + ".reference ";
            query += order;
            PreparedStatement state = theConnection.prepareStatement (query);
            if (orderby == ORDER_BY_NEW) {
                state.setMaxRows (MAX_NEW);
            }
            if (orderby == ORDER_BY_TOP_TEN) {
                state.setMaxRows (MAX_TOP);
            }
            if (orderby == ORDER_BY_FEATURE) {
                state.setMaxRows (MAX_FEATURE);
            }
            ResultSet rs = state.executeQuery ();
            while (rs.next ()) {
                String name = rs.getString ("name");
                int ref = rs.getInt ("reference");
                if (mediatype.equals (MediaVariables.MEDIA_TYPE_RINGTONE)) {
                    ObjectRingTone ort = new ObjectRingTone (name, ref);
                    mediavector.add (ort);
                }
                else if (mediatype.equals (MediaVariables.MEDIA_TYPE_ICON)) {
                    ObjectIcon oi = new ObjectIcon (name, ref);
                    mediavector.add (oi);
                }
            }
        } catch (SQLException e) {
            mediavector = new Vector ();
        } finally {
            if (theConnection != null) theConnection.release ();
        }
    }
    return mediavector;
}


-----Function Pair=339=-----==

public Members findMemberByName (String username) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Members m where m.username =?");
        query.setString (0, username);
        Members member = (Members) query.uniqueResult ();
        tr.commit ();
        return member;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public int getIdUltimoLocal () throws Exception {
    Connection connection = criaConexao (false);
    String sql = "SELECT MAX(idlocal) FROM Local";
    PreparedStatement stmt = null;
    ResultSet rs = null;
    int id = 0;
    try {
        stmt = connection.prepareStatement (sql);
        rs = stmt.executeQuery ();
        if (rs.next ()) {
            id = rs.getInt ("max");
        }
    } catch (SQLException e) {
        throw e;
    } finally {
        try {
            if (stmt != null) stmt.close ();
            if (rs != null) rs.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
    return id;
}


-----Function Pair=340=-----==

public boolean isEmpty () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select count(1) from Instructions";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new SQLException ("No rows returned for count(1) query");
            else {
                int num = rs.getInt (1);
                if (num == 0) return true;
                else return false;
            }
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public int addCliente (Cliente cli) throws errorConexionBD, errorSQL {
    System.out.println ("GestorCliente.addCliente()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        sql = "SELECT nif FROM persona WHERE nif='" + cli.getNif () + "'";
        System.out.println ("Ejecuando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            throw new errorSQL ("NIF duplicado en INSERT");
        }
        gd.begin ();
        sql = "INSERT INTO persona(nif, nombre, apellido1, apellido2, " + "direccion, poblacion,telefono, movil, email, fecha_baja)" + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setString (1, cli.getNif ());
        pstmt.setString (2, cli.getNombre ());
        pstmt.setString (3, cli.getApellido1 ());
        pstmt.setString (4, cli.getApellido2 ());
        pstmt.setString (5, cli.getDireccion ());
        pstmt.setString (6, cli.getPoblacion ());
        pstmt.setString (7, cli.getTelefono ());
        pstmt.setString (8, cli.getMovil ());
        pstmt.setString (9, cli.getEmail ());
        pstmt.setDate (10, (java.sql.Date) cli.getFechaBaja ());
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        pstmt.close ();
        rs.close ();
        sql = "INSERT INTO cliente (cod_cliente, tarjeta_credito, puntos)" + "VALUES (?,?,?) RETURNING cod_cliente";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, nuevoId);
        pstmt.setString (2, cli.getTarjetaCredito ());
        pstmt.setInt (3, 0);
        gd.commit ();
        System.out.println ("commit");
        rs = pstmt.executeQuery ();
        rs.close ();
        pstmt.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorCliente.addCliente()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=341=-----==

public List getPublishableList (String parentPath) throws Exception {
    Channel channel = null;
    List channels = new ArrayList ();
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        dbo = createDBOperation ();
        StringBuffer sql = new StringBuffer ().append (" select channel.*").append (",site.ascii_name site_ascii_name").append (" from t_ip_channel channel").append (",t_ip_site site").append (" where channel.channel_path like '").append (parentPath).append ("%' ").append (" and channel.site_id=site.id").append (" and (channel.refresh_flag='").append (Channel.REFRESH_FOREVER).append ("' or  channel.refresh_flag='").append (Channel.REFRESH_RIGHT_NOW).append ("' or  channel.refresh_flag='").append (Channel.REFRESH_YES).append ("')");
        ResultSet rs = dbo.select (sql.toString ());
        while (rs.next ()) {
            channel = new Channel (rs.getInt ("id"));
            channel.setAsciiName (rs.getString ("ascii_name"));
            channel.setChannelType (rs.getString ("type"));
            channel.setCreateDate (rs.getDate ("create_date"));
            channel.setCreator (rs.getInt ("creator"));
            channel.setDataUrl (rs.getString ("data_url"));
            channel.setDesc (rs.getString ("description"));
            channel.setName (rs.getString ("name"));
            channel.setOrderNo (rs.getInt ("order_no"));
            channel.setSiteId (rs.getInt ("site_id"));
            channel.setStyle (rs.getString ("style"));
            channel.setTemplateId (rs.getString ("template_id"));
            channel.setUseStatus (rs.getString ("use_status"));
            channel.setPath (rs.getString ("channel_path"));
            channel.setRefresh (rs.getString ("refresh_flag"));
            channel.setSiteAsciiName (rs.getString ("site_ascii_name"));
            channel.setPageNum (rs.getInt ("page_num"));
            channels.add (channel);
        }
    } catch (Exception e) {
        log.error ("�õ�Ƶ���б�ʱ����", e);
        throw e;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
    return channels;
}


public Map < String, Producto > searchProd (String campo, String term) {
    Map < String, Producto > productos = new HashMap < String, Producto > ();
    Connection conexion = null;
    PreparedStatement select = null;
    ResultSet rs = null;
    try {
        conexion = pool.getConnection ();
        select = conexion.prepareStatement ("SELECT* FROM " + nameBD + ".Productos WHERE " + campo + " LIKE ?");
        select.setString (1, "%" + term + "%");
        rs = select.executeQuery ();
        while (rs.next ()) {
            Producto prod = new Producto (rs.getString ("Codigo"), rs.getString ("Nombre"), rs.getDouble ("Precio"), rs.getInt ("Stock"), rs.getString ("Descripcion"), rs.getString ("Detalles"));
            productos.put (prod.getCodigo (), prod);
        }
        if (productos.size () <= 0) {
            productos = null;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error buscando producto", ex);
        productos = null;
    } finally {
        cerrarConexionYStatement (conexion, select);
        cerrarResultSet (rs);
    }
    return productos;
}


-----Function Pair=342=-----==

public boolean insertOnlineTime (Onlinetime onlinetime) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (onlinetime);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public static void createPhotoReply (PhotoReplyBean reply) {
    try {
        Session ssn = getSession ();
        int max_reply_count = ConfigDAO.getMaxReplyCount (reply.getSite ().getId ());
        beginTransaction ();
        reply.getPhoto ().incReplyCount (1);
        if (reply.getPhoto ().getReplyCount () >= max_reply_count) reply.getPhoto ().setLock (1);
        reply.getPhoto ().setLastReplyTime (new Date ());
        if (reply.getUser () != null) reply.getUser ().getCount ().incPhotoReplyCount (1);
        ssn.save (reply);
        commit ();
    } catch (HibernateException e) {
        rollback ();
        throw e;
    }
}


-----Function Pair=343=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


-----Function Pair=344=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoSingleTextCheckList2 coSingleTextCheckList) {
    String sTitle = null;
    try {
        sTitle = coSingleTextCheckList.getTitle ();
        log.error ("Eliminando la lista de chequeo: " + coSingleTextCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.DELETE_CHECK_LIST_STUDENT);
        query.setParameter (1, coSingleTextCheckList.getCheckListId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sTitle};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.delete.success"), arrayParam));
        log.info ("Eliminando el curso: " + coSingleTextCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coSingleTextCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


public boolean contains (String word) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select count(1) from Dictionary where Word = '" + word + "'";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new SQLException ("No rows returned for count(1) query");
            else {
                int num = rs.getInt (1);
                if (num == 0) return false;
                else return true;
            }
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=345=-----==

public List < PortletNameBean > getPortletNameList () {
    DatabaseAdapter db = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        db = DatabaseAdapter.getInstance ();
        String sql = "select ID_SITE_CTX_TYPE, TYPE " + "from 	WM_PORTAL_PORTLET_NAME ";
        ps = db.prepareStatement (sql);
        rs = ps.executeQuery ();
        List < PortletNameBean > list = new ArrayList < PortletNameBean > ();
        while (rs.next ()) {
            list.add (loadPortletNameFromResultSet (rs));
        }
        return list;
    } catch (Exception e) {
        String es = "Error load list of portlet names";
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


public static Funcionario selectByLogin (String login) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Funcionario objFuncionario = null;
    if (c == null) {
        return null;
    }
    try {
        String sql = "Select * from funcionario where login = ?";
        pst = c.prepareStatement (sql);
        pst.setString (1, login);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objFuncionario = new Funcionario ();
            objFuncionario.setCodigo (rs.getInt ("id_funcionario"));
            objFuncionario.setNome (rs.getString ("nome"));
            objFuncionario.setCpf (rs.getString ("cpf"));
            objFuncionario.setEmail (rs.getString ("email"));
            objFuncionario.setLogin (rs.getString ("login"));
            objFuncionario.setSenha (rs.getString ("senha"));
            objFuncionario.setTelefone (rs.getString ("telefone"));
            objFuncionario.setCargo (CargoDAO.selectByID (rs.getString ("id_cargo")));
        }
    } catch (SQLException e) {
        System.out.println ("[FuncionarioDAO.selectByLogin] Erro ao atualizar -> " + e.getMessage ());
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objFuncionario;
}


-----Function Pair=346=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public int addPedido (Pedido pe) throws errorConexionBD, errorSQL {
    System.out.println ("GestorPedido.addPedido()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        gd.begin ();
        sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, pe.getIdCliente ());
        pstmt.setInt (2, pe.getIdPromocion ());
        pstmt.setInt (3, pe.getIdProducto ());
        pstmt.setFloat (4, pe.getImporte ());
        if (pe.getFecha () != null) {
            pstmt.setDate (5, new java.sql.Date (pe.getFecha ().getTime ()));
        }
        else {
            pstmt.setNull (5, Types.DATE);
        }
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        gd.commit ();
        System.out.println ("commit");
        pstmt.close ();
        rs.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorPedido.addPedido()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=347=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void testIsNull () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T where T.firstName IS NULL").getResultList ();
        assertEquals (0, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=348=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public int getIdPartidaRegistrada (int idJugadorDiv, int idRonda) {
    int idPartida = 0;
    try {
        String sql = "SELECT idPartida FROM jugadorxdivxronda " + " WHERE jugadorxDivision_idJugadorxDivision = " + idJugadorDiv + " AND ronda_numeroRonda = " + idRonda;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            idPartida = populateIdPartida (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return idPartida;
}


-----Function Pair=349=-----==

public List retrieve (HashMap criteria) throws DAOException {
    List < Item > result = new ArrayList < Item > ();
    try {
        String search = XMLGetQuery.getQuery ("RETRIEVE") + " item";
        if (criteria != null && criteria.containsKey ("idaccount")) {
            search = "select * from item, project where project.idaccount = " + criteria.get ("idaccount") + " and project.id_project = item.idproject and idbill is null order by idproject";
        }
        else if (criteria != null) {
            search += " where";
            Set s = criteria.entrySet ();
            Iterator iter = s.iterator ();
            while (iter.hasNext ()) {
                Map.Entry e = (Map.Entry) iter.next ();
                String column = (String) e.getKey ();
                String value = (String) e.getValue ();
                if (column.equals ("archived") || column.equals ("idproject")) search += " " + column + " = " + value + " and";
                else if (column.equals ("idbill") && value.equals ("null")) search += " " + column + " is " + value + " and";
                else if (! (column.equals ("order by"))) search += " " + column + " like " + "'%" + value + "%' and";
            }
            search = search.substring (0, search.length () - 3);
            if (criteria.containsKey ("order by")) search += " order by " + criteria.get ("order by");
        }
        Statement st = connection.createStatement ();
        ResultSet rs = st.executeQuery (search);
        while (rs.next ()) {
            Item item = BusinessFactory.createItem ();
            item.setId (rs.getInt ("id_item"));
            item.setDescription (rs.getString ("item_description"));
            item.setUnit_price (rs.getDouble ("unit_price"));
            item.setQuantity (rs.getInt ("quantity"));
            item.setVat (rs.getDouble ("vat"));
            item.setIdProject (rs.getInt ("idproject"));
            item.setIdBill (rs.getInt ("idbill"));
            item.setIdCurrency (rs.getInt ("idcurrency"));
            result.add (item);
        }
        connection.commit ();
    } catch (java.sql.SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return result;
}


public MedicationReportDocument getMedicationReport () {
    MedicationReportDocument doc = null;
    ResultSet rsMeds = null;
    try {
        helper = new DBHelper ();
        doc = MedicationReportDocument.Factory.newInstance ();
        PreparedStatement psMeds = helper.prepareStatement (SQL.getMedicationReport ());
        rsMeds = psMeds.executeQuery ();
        String tmp = "";
        String mn = "";
        doc.addNewMedicationReport ();
        if (rsMeds.next ()) {
            while (true) {
                boolean finished = false;
                mn = rsMeds.getString ("MEDNO");
                if (tmp.equals ("")) {
                    tmp = mn;
                }
                String name = rsMeds.getString ("MEDICATION");
                MedicationReport mm = doc.getMedicationReport ().addNewMedication ();
                mm.setMedno (mn);
                mm.setMedication (name);
                while (tmp.equals (mn)) {
                    IllnessInfo ii = mm.addNewStats ();
                    ii.setIllness (rsMeds.getString ("ILLNESS"));
                    ii.setCount (new BigInteger (String.valueOf (rsMeds.getInt ("COUNT"))));
                    if (! rsMeds.next ()) {
                        finished = true;
                        break;
                    }
                    mn = rsMeds.getString ("MEDNO");
                }
                if (finished) {
                    break;
                }
                tmp = mn;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsMeds != null) {
                rsMeds.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


-----Function Pair=350=-----==

public static void process (PricesType prices, Long id_site, DatabaseAdapter dbDyn) throws PriceException {
    PreparedStatement ps = null;
    String sql_ = null;
    PriceListItemType debugItem = null;
    try {
        if (log.isDebugEnabled ()) {
            log.debug ("dbDyn - " + dbDyn);
            if (dbDyn != null) log.debug ("dbDyn.conn - " + dbDyn.getConnection ());
        }
        dbDyn.getConnection ().setAutoCommit (false);
        if (dbDyn.getFamaly () != DatabaseManager.MYSQL_FAMALY) {
            sql_ = "delete from WM_PRICE_IMPORT_TABLE where shop_code in " + "( select shop_code from WM_PRICE_SHOP_LIST where ID_SITE=? )";
            ps = dbDyn.prepareStatement (sql_);
            RsetTools.setLong (ps, 1, id_site);
            ps.executeUpdate ();
            ps.close ();
            ps = null;
        }
        else {
            String sqlCheck = "";
            boolean isFound = false;
            WmPriceShopListListType shops = GetWmPriceShopListWithIdSiteList.getInstance (dbDyn, id_site).item;
            boolean isFirst = true;
            for (int i = 0; i < shops.getWmPriceShopListCount (); i ++) {
                WmPriceShopListItemType shop = shops.getWmPriceShopList (i);
                isFound = true;
                if (isFirst) isFirst = false;
                else sqlCheck += ",";
                sqlCheck += ("'" + shop.getCodeShop () + "'");
            }
            if (isFound) {
                sql_ = "delete from WM_PRICE_IMPORT_TABLE where shop_code in ( " + sqlCheck + " )";
                if (log.isDebugEnabled ()) log.debug ("sql " + sql_);
                ps = dbDyn.prepareStatement (sql_);
                ps.executeUpdate ();
                ps.close ();
                ps = null;
            }
        }
        if (log.isDebugEnabled ()) log.debug ("Start unmarshalling data");
        if (prices == null) throw new PriceException ("������ ������� ����� �������. ��� ������ #10.03");
        int batchLoop = 0;
        int count = 0;
        sql_ = "insert into WM_PRICE_IMPORT_TABLE " + "(is_group, id, id_main, name, price, currency, is_to_load, shop_code, ID_UPLOAD_PRICE) " + "values (?,?,?,?,?,?,?,?,?)";
        Long id_upload_session = null;
        for (int j = 0; j < prices.getPriceListCount (); j ++) {
            PriceListType price = prices.getPriceList (j);
            if (log.isDebugEnabled ()) {
                log.debug ("shopCode " + price.getShopCode ());
                log.debug ("Size vector: " + price.getItemCount ());
            }
            for (int i = 0; (i < price.getItemCount ()) && (count < 5000); i ++, count ++) {
                if (ps == null) ps = dbDyn.prepareStatement (sql_);
                PriceListItemType item = price.getItem (i);
                debugItem = item;
                ps.setInt (1, Boolean.TRUE.equals (item.getIsGroup ()) ? 1 : 0);
                RsetTools.setLong (ps, 2, item.getItemID ());
                RsetTools.setLong (ps, 3, item.getParentID ());
                ps.setString (4, item.getNameItem ());
                RsetTools.setDouble (ps, 5, item.getPrice ());
                ps.setString (6, item.getCurr ());
                ps.setString (7, item.getIsLoad ().toString ());
                ps.setString (8, price.getShopCode ().toUpperCase ());
                RsetTools.setLong (ps, 9, id_upload_session);
                if (dbDyn.getIsBatchUpdate ()) {
                    ps.addBatch ();
                    if (++ batchLoop >= 200) {
                        int [] updateCounts = ps.executeBatch ();
                        ps.close ();
                        ps = null;
                        batchLoop = 0;
                    }
                }
                else ps.executeUpdate ();
            }
        }
        if (dbDyn.getIsBatchUpdate ()) {
            if (ps != null) {
                int [] updateCounts = ps.executeBatch ();
                ps.close ();
                ps = null;
            }
        }
        ImportPriceProcess.process (dbDyn, id_site);
        dbDyn.commit ();
    } catch (Exception e) {
        if (debugItem != null) {
            log.error ("debugItem.getIsGroup() " + (Boolean.TRUE.equals (debugItem.getIsGroup ()) ? 1 : 0));
            log.error ("debugItem.getItemID() " + debugItem.getItemID ());
            log.error ("debugItem.getParentID() " + debugItem.getParentID ());
            log.error ("debugItem.getNameItem() " + debugItem.getNameItem ());
            log.error ("debugItem.getPrice() " + debugItem.getPrice ());
            log.error ("debugItem.getCurr() " + debugItem.getCurr ());
            log.error ("debugItem.getIsLoad().toString() " + debugItem.getIsLoad ().toString ());
        }
        else log.error ("debugItem is null");
        log.error ("sql:\n" + sql_);
        final String es = "error process import price-list";
        log.error (es, e);
        try {
            dbDyn.rollback ();
        } catch (Exception e11) {
        }
        throw new PriceException (es, e);
    } finally {
        DatabaseManager.close (ps);
        ps = null;
    }
}


public boolean updateRoleType (int id, int namespaceId, RoleTypeEntry entry, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {
    checkPermission (permit, String.valueOf (namespaceId));
    boolean exist = isRoleTypeUsed (namespaceId, id);
    int linkedNamespaceId = getLinkedNamespaceId (namespaceId);
    if (linkedNamespaceId == - 1) {
        throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0027", new String [] {String.valueOf (entry.namespaceId)}));
    }
    DBRoleTypeEntry currEntry = fetchDBRoleTypeEntry (getGID (namespaceId, id));
    long domainGid = currEntry.domainGid;
    long rangeGid = currEntry.rangeGid;
    long rightIdentityGid = 0;
    long parentGid = 0;
    if (! exist) {
        if (entry.domainKindNamespaceId != 0) {
            if (entry.domainKindNamespaceId != namespaceId && entry.domainKindNamespaceId != linkedNamespaceId) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0028"));
            }
            domainGid = getGID (entry.domainKindNamespaceId, entry.domainKindId);
        }
        if (entry.rangeKindNamespaceId != 0) {
            if (entry.rangeKindNamespaceId != namespaceId && entry.rangeKindNamespaceId != linkedNamespaceId) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0029"));
            }
            rangeGid = getGID (entry.rangeKindNamespaceId, entry.rangeKindId);
        }
        if (entry.rightIdentityId != 0) {
            if (entry.rightIdentityNamespaceId != namespaceId && entry.rightIdentityNamespaceId != linkedNamespaceId) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0030"));
            }
            if (entry.rightIdentityNamespaceId == namespaceId && entry.rightIdentityId == id) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0035"));
            }
            rightIdentityGid = getGID (entry.rightIdentityNamespaceId, entry.rightIdentityId);
            DBRoleTypeEntry riEntry = fetchDBRoleTypeEntry (rightIdentityGid);
            if (riEntry == null) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0039", new String [] {"Right Identity Role Type", String.valueOf (entry.rightIdentityNamespaceId), String.valueOf (entry.rightIdentityId)}));
            }
            if (riEntry.domainGid != riEntry.rangeGid) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0036"));
            }
            if (riEntry.domainGid != rangeGid) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0037"));
            }
        }
        if (entry.parentId != 0) {
            if (entry.parentNamespaceId != namespaceId && entry.parentNamespaceId != linkedNamespaceId) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0031"));
            }
            if (entry.id != - 1) {
                if (entry.parentNamespaceId == namespaceId && entry.parentId == id) {
                    throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0032"));
                }
            }
            parentGid = getGID (entry.parentNamespaceId, entry.parentId);
            DBRoleTypeEntry pEntry = fetchDBRoleTypeEntry (parentGid);
            if (pEntry == null) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0039", new String [] {"Parent Role Type", String.valueOf (entry.parentNamespaceId), String.valueOf (entry.parentId)}));
            }
            if ((pEntry.domainGid != domainGid) || pEntry.rangeGid != rangeGid) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0038"));
            }
        }
    }
    if (entry.name != null) {
        entry.name = DTSUtil.checkValue ("Role Type Name", entry.name, DTSDataLimits.LEN_NAME);
        if (isRoleTypeExist (entry.name, linkedNamespaceId)) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0033", new String [] {entry.name}));
        }
    }
    String sql = getDAO ().getStatement (ROLE_TYPE_TABLE_KEY, "SELECT_FOR_UPDATE");
    PreparedStatement pstmt = null;
    boolean success = false;
    try {
        pstmt = conn.prepareStatement (sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
        pstmt.setInt (1, id);
        pstmt.setInt (2, namespaceId);
        ResultSet rset = pstmt.executeQuery ();
        if (rset.next ()) {
            if (entry.name != null) {
                rset.updateString (1, entry.name);
            }
            if (! exist) {
                rset.updateLong (2, domainGid);
                rset.updateLong (3, rangeGid);
                if (rightIdentityGid != 0) {
                    rset.updateLong (4, rightIdentityGid);
                }
                else {
                    rset.updateNull (4);
                }
                if (parentGid != 0) {
                    rset.updateLong (5, parentGid);
                }
                else {
                    rset.updateNull (5);
                }
            }
            rset.updateRow ();
            success = true;
        }
    } finally {
        closeStatement (pstmt);
    }
    return success;
}


-----Function Pair=351=-----==

public void testPreparedStatementSetObject3 () throws Exception {
    BigDecimal data = new BigDecimal (3.7D);
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #psso3 (data MONEY)");
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #psso3 (data) VALUES (?)");
    pstmt.setObject (1, data, Types.DECIMAL);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("SELECT data FROM #psso3");
    assertTrue (rs.next ());
    assertEquals (data.doubleValue (), rs.getDouble (1), 0);
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
}


public synchronized void complain (String fromWho, int fromExperience, String aboutWho) throws MaxComplaintsException, ExperienceTooLowException, AlreadyComplainedException, UserDBException, SQLException {
    if (fromWho.equals (aboutWho)) throw new UserDBException ("can not complain about yourself");
    con.setAutoCommit (false);
    try {
        updateUser (aboutWho);
        updateInputProvider (fromWho, fromExperience);
    } catch (Exception e) {
        con.rollback ();
        con.setAutoCommit (true);
        throw new UserDBException (e.getMessage ());
    }
    if (currentInputProvider.getNComplaints () >= maxComplaints) {
        throw new MaxComplaintsException (fromWho + " over max complaints");
    }
    if (currentInputProvider.isComplainer (currentUser)) {
        con.rollback ();
        con.setAutoCommit (true);
        updateExperiencePS.setInt (1, fromExperience);
        updateExperiencePS.setString (2, fromWho);
        if (updateExperiencePS.executeUpdate () != 1) {
            throw new UserDBException ("updateExperience had no effect");
        }
        con.setAutoCommit (false);
        throw new AlreadyComplainedException (fromWho + " already complained about " + aboutWho);
    }
    if (currentInputProvider.isVoucher (currentUser)) {
        this.removeVoucher (fromWho);
    }
    if (null == this.addComplainer (fromWho)) {
        throw new ExperienceTooLowException (fromWho + " does not have more experience than current complainers");
    }
    else {
        this.updateReputation ();
    }
    con.commit ();
    con.setAutoCommit (true);
}


-----Function Pair=352=-----==

public static List < String [] > getValuesFromSQL (final String sql, final Statement st, final String [] column) throws Exception {
    ResultSet rs = null;
    try {
        rs = st.executeQuery (sql);
        final List < String [] > result = new ArrayList < String [] > ();
        while (rs.next ()) {
            final String [] values = new String [column.length];
            for (int i = 0; i < values.length; i ++) {
                values [i] = rs.getString (column [i]);
            }
            result.add (values);
        }
        return result;
    } finally {
        closeAll (rs, null, null);
    }
}


public List getRespuestas (Examen examen) {
    List lista = new ArrayList ();
    List listaRespuestas = new ArrayList ();
    Criteria criteria = null;
    SQLQuery query = null;
    RespuestaDAO respuestaDao = new RespuestaDAO ();
    Respuesta respuesta = new Respuesta ();
    try {
        Session session = HibernateUtil.currentSession ();
        criteria = session.createCriteria (Pregunta.class);
        query = session.createSQLQuery ("SELECT codResp FROM examen_tiene_respuesta WHERE codExam = ?");
        query.setInteger (0, examen.getCodExam ());
        lista = query.list ();
        for (Iterator iterator = lista.iterator (); iterator.hasNext ();) {
            int codResp = (Integer) iterator.next ();
            respuesta = (Respuesta) respuestaDao.findById (String.valueOf (codResp)).get (0);
            listaRespuestas.add (respuesta);
        }
    } catch (HibernateException e) {
        log.error ("_____Error al obtener las respuestas para el examen con id: " + examen.getCodExam (), e);
        throw new HibernateException (e);
    }
    return listaRespuestas;
}


-----Function Pair=353=-----==

public void testPreparedStatementSetObject4 () throws Exception {
    BigDecimal data = new BigDecimal (3.7D);
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #psso4 (data MONEY)");
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #psso4 (data) VALUES (?)");
    pstmt.setObject (1, data, Types.NUMERIC, 4);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("SELECT data FROM #psso4");
    assertTrue (rs.next ());
    assertEquals (data.doubleValue (), rs.getDouble (1), 0);
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
}


public void sendFeedback () throws IOException {
    String urlToGet;
    String redirectURL;
    if (success) {
        urlToGet = "SuccessUrl";
        redirectURL = msg.getValue (urlToGet) [0];
        if (redirectURL.equals (Config.EMPTY_STR)) {
            redirectURL = "success.jsp";
        }
    }
    else {
        urlToGet = "FailureUrl";
        Enumeration e = failMessages.keys ();
        String query;
        while (e.hasMoreElements ()) {
            query = (String) e.nextElement ();
            MraldOutFile.appendToFile (query + " | " + failMessages.get (query).toString ());
        }
        redirectURL = msg.getValue (urlToGet) [0];
        if (redirectURL.equals ("")) {
            redirectURL = "failure.jsp";
        }
    }
    msg.setRedirect (redirectURL);
}


-----Function Pair=354=-----==

public void query () throws Exception {
    Connection conn = s.getConnection ();
    PreparedStatement ps = conn.prepareStatement ("select * from t_test");
    ResultSet rs = ps.executeQuery ();
    FileOutputStream fos = new FileOutputStream ("d:/bbb.xls");
    int len = - 1;
    while (rs.next ()) {
        InputStream is = rs.getBlob (6).getBinaryStream ();
        while ((len = is.read ()) != - 1) {
            fos.write (len);
        }
        fos.close ();
        is.close ();
    }
    rs.close ();
    ps.close ();
}


public RestServiceResult search (RestServiceResult serviceResult, Long nMultipleChoiceE3Id) {
    CoMultipleChoiceE3 coMultipleChoiceE3 = new CoMultipleChoiceE3DAO ().findById (nMultipleChoiceE3Id);
    if (coMultipleChoiceE3 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        List < CoMultipleChoiceE3 > list = new ArrayList < CoMultipleChoiceE3 > ();
        EntityManagerHelper.refresh (coMultipleChoiceE3);
        list.add (coMultipleChoiceE3);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=355=-----==

private void prepareList (Vector examList, Vector gradeList) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        {
            r.add ("adm_exam_id");
            r.add ("adm_exam_name");
            sql = r.getSQLSelect ("adm_exam");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("adm_exam_id"));
                h.put ("name", rs.getString ("adm_exam_name"));
                examList.addElement (h);
            }
        }
        {
            r.clear ();
            r.add ("adm_grade_display_id");
            r.add ("adm_grade_display_name");
            sql = r.getSQLSelect ("adm_display_grade_main");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("adm_grade_display_id"));
                h.put ("name", rs.getString ("adm_grade_display_name"));
                gradeList.addElement (h);
            }
        }
    } finally {
        if (db != null) db.close ();
    }
}


public static void add (Hashtable data) throws Exception {
    String applicant_id = (String) data.get ("applicant_id");
    String subject_id = (String) data.get ("subject_id");
    String subject_grade = (String) data.get ("subject_grade");
    String exam_id = (String) data.get ("exam_id");
    if ("".equals (subject_grade)) throw new Exception ("Can not have empty fields!");
    if ("".equals (subject_id)) throw new Exception ("Can not have empty fields!");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("applicant_id");
            r.add ("applicant_id", applicant_id);
            r.add ("adm_exam_id", exam_id);
            r.add ("adm_subject_id", subject_id);
            sql = r.getSQLSelect ("adm_applicant_exam");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
            else found = false;
        }
        if (! found) {
            r.clear ();
            r.add ("applicant_id", applicant_id);
            r.add ("adm_exam_id", exam_id);
            r.add ("adm_subject_id", subject_id);
            r.add ("adm_subject_grade", subject_grade);
            sql = r.getSQLInsert ("adm_applicant_exam");
            stmt.executeUpdate (sql);
        }
        else {
            r.clear ();
            r.add ("adm_subject_grade", subject_grade);
            r.update ("applicant_id", applicant_id);
            r.update ("adm_exam_id", exam_id);
            r.update ("adm_subject_id", subject_id);
            sql = r.getSQLUpdate ("adm_applicant_exam");
            stmt.executeUpdate (sql);
        }
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=356=-----==

public ArrayList < WeeklyHolidays > fetchHoliday () {
    ArrayList < WeeklyHolidays > arrayList = new ArrayList < WeeklyHolidays > ();
    Session session = HibernateUtil.getSessionFactory ().openSession ();
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction ();
        List < WeeklyHolidays > list = session.createQuery ("from WeeklyHolidays").list ();
        for (Iterator < WeeklyHolidays > iterator = list.iterator (); iterator.hasNext ();) {
            WeeklyHolidays weekObj = iterator.next ();
            weekObj.getFlag ();
            weekObj.getDayName ();
            arrayList.add (weekObj);
        }
        transaction.commit ();
        session.close ();
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return arrayList;
}


public static ArrayList < ExperimentResult > getAllByInstanceId (int id) throws NoConnectionToDBException, SQLException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException {
    ArrayList < ExperimentResult > v = new ArrayList < ExperimentResult > ();
    HashMap < Integer, ExperimentResult > expResultsMap = new HashMap < Integer, ExperimentResult > ();
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (selectQuery + "WHERE Instances_idInstance=?;");
    st.setInt (1, id);
    ResultSet rs = st.executeQuery ();
    while (rs.next ()) {
        ExperimentResult er = getExperimentResultFromResultSet (rs);
        er.setSaved ();
        expResultsMap.put (er.getId (), er);
        v.add (er);
    }
    ExperimentResultHasPropertyDAO.assign (expResultsMap, v);
    rs.close ();
    st.close ();
    return v;
}


-----Function Pair=357=-----==

public RestServiceResult delete (RestServiceResult serviceResult, MaSyntatic maSyntatic) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_MA_SYNTACTIC);
        query.setParameter (1, maSyntatic.getSytanticId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {maSyntatic.getSecuence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntactic.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la unidad sintactica: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maSyntatic.getSecuence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntactic.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public static String getCategoryName (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.categoryName from AccountCategory R where R.categoryId=(select A.categoryId from Account A where A.accountId=?)";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        String aname = (String) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=358=-----==

protected ArrayList computeConceptList (ArrayList treePaths) throws SQLException, DTSValidationException {
    prepareSql2k ();
    String minusSp = this.dao.getStatement ("SUBSET_DB", "MINUS_SP_NAME");
    String intersectSp = this.dao.getStatement ("SUBSET_DB", "INTERSECT_SP_NAME");
    ArrayList finalConList = new ArrayList (0);
    for (int i = 0; i < treePaths.size (); i ++) {
        TreePathWalker tpw = (TreePathWalker) treePaths.get (i);
        TreePathStmtProcessor tpsp = new TreePathStmtProcessor (tpw, this.dao, this.conn);
        tpsp.process ();
        int namespaceId = tpsp.getTreeNamespaceId ();
        if (! this.namespaces.contains (new Integer (namespaceId)) && (namespaceId > 0)) {
            this.namespaces.add (new Integer (namespaceId));
        }
        ArrayList treePathResults = getTreePathResults (tpsp, minusSp, intersectSp);
        Categories.dataDb ().debug (" # of matches [" + treePathResults.size () + "]");
        for (int r = 0; r < treePathResults.size (); r ++) {
            Long con = (Long) treePathResults.get (r);
            if (! finalConList.contains (con)) {
                finalConList.add (con);
            }
        }
    }
    return finalConList;
}


protected String doIt () throws Exception {
    initialize ();
    StringBuffer sql = new StringBuffer ("SELECT distinct t.ad_table_id, t.tablename " + "FROM ad_table as t " + "INNER JOIN ad_column as c ON (t.ad_table_id = c.ad_table_id) " + "WHERE t.tablename NOT IN " + elementsToCol (getExcludedTables ()));
    if (isJustUID ()) {
        sql.append (" AND (c.columnname ilike 'AD_ComponentObjectUID')");
    }
    else {
        sql.append (" AND (c.columnname ilike 'AD_ComponentVersion_ID')");
    }
    PreparedStatement ps = null;
    ResultSet rs = null;
    String sqlTable;
    StringBuffer uid = new StringBuffer ();
    M_Table table;
    List < String > keyColumns;
    try {
        getTrx (get_TrxName ()).start ();
        ps = DB.prepareStatement (sql.toString (), get_TrxName ());
        rs = ps.executeQuery ();
        while (rs.next ()) {
            table = new M_Table (getCtx (), rs.getInt ("ad_table_id"), get_TrxName ());
            uid = new StringBuffer ("'" + getComponent ().getPrefix () + PO.SEPARATORUID + table.getTableName () + "'");
            keyColumns = table.getKeyColumns ();
            for (int i = 0; i < keyColumns.size (); i ++) {
                uid.append ("||'").append (PO.SEPARATORUID).append ("'||").append (keyColumns.get (i));
            }
            sqlTable = getSqlUpdateForTable (table.getTableName (), uid.toString ());
            DB.executeUpdate (sqlTable, get_TrxName ());
        }
        getTrx (get_TrxName ()).commit ();
    } catch (Exception e) {
        getTrx (get_TrxName ()).rollback ();
        log.severe (e.getMessage ());
        throw new Exception (e.getMessage ());
    } finally {
        try {
            if (ps != null) ps.close ();
            if (rs != null) rs.close ();
        } catch (Exception e) {
            log.severe (e.getMessage ());
            throw new Exception (e.getMessage ());
        }
    }
    return "Actualizacion de tablas finalizada correctamente";
}


-----Function Pair=359=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nMatrixId) {
    CoMatrixExercises2 coMatrixExercises2 = new CoMatrixExercises2DAO ().findById (nMatrixId);
    if (coMatrixExercises2 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixExercises2.search.notFound"));
    }
    else {
        List < CoMatrixExercises2 > list = new ArrayList < CoMatrixExercises2 > ();
        EntityManagerHelper.refresh (coMatrixExercises2);
        list.add (coMatrixExercises2);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises2.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


public int deleteTT (Session s, long txId) throws Exception {
    try {
        try {
            String query = "delete from TT T where T.txId=?";
            Query q = s.createQuery (query);
            q.setLong (0, txId);
            int r = q.executeUpdate ();
            return r;
        } catch (Exception e) {
            throw e;
        }
    } catch (Exception e) {
        throw e;
    }
}


-----Function Pair=360=-----==

private static int computeLevenshteinDistance (char [] str1, char [] str2) {
    int [] [] distance = new int [str1.length + 1] [str2.length + 1];
    for (int i = 0; i <= str1.length; i ++) {
        distance [i] [0] = i;
    }
    for (int j = 0; j <= str2.length; j ++) {
        distance [0] [j] = j;
    }
    for (int i = 1; i <= str1.length; i ++) {
        for (int j = 1; j <= str2.length; j ++) {
            distance [i] [j] = minimum (distance [i - 1] [j] + 1, distance [i] [j - 1] + 1, distance [i - 1] [j - 1] + ((str1 [i - 1] == str2 [j - 1]) ? 0 : 1));
        }
    }
    return distance [str1.length] [str2.length];
}


public void runQuery (String sql, boolean noUpdateCount) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tran = session.beginTransaction ();
    Connection conn = session.connection ();
    Statement pstmt = null;
    try {
        pstmt = conn.createStatement ();
        pstmt.execute (sql);
        tran.commit ();
    } catch (SQLException e) {
        tran.rollback ();
        e.printStackTrace ();
    } finally {
        try {
            if (tran != null) {
                tran = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=361=-----==

public user getAddress (String name) {
    user myuser = new user ();
    try {
        PreparedStatement stmt = con.prepareStatement ("Select * from user where uname= ?");
        stmt.setString (1, name);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                myuser.setUid (rs.getInt ("uid"));
                myuser.setUname (rs.getString ("uname"));
                myuser.setUemail (rs.getString ("uemail"));
                myuser.setUaddr (rs.getString ("uaddr"));
                myuser.setUcontact (rs.getString ("ucontact"));
            }
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return myuser;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=362=-----==

public static Collection call (String name, Collection < Object > params) throws Exception {
    UserTransaction tr = null;
    try {
        tr = getTransaction ();
        if (tr != null) tr.begin ();
        Query query = getEntityManager ().createNamedQuery (name);
        int i = 0;
        if (params != null) for (Object obj : params) query.setParameter (++ i, obj);
        Collection c = query.getResultList ();
        if (tr != null) tr.commit ();
        return c;
    } catch (Exception ex) {
        if (tr != null) tr.rollback ();
        throw ex;
    }
}


public static boolean add (Calendar time, Calendar start, Calendar end, int timeseries, int amount) throws SQLException {
    boolean modified = false;
    switch (timeseries) {
        case TIMESERIES_YEAR :
            time.add (Calendar.YEAR, amount);
            modified = true;
            break;
        case TIMESERIES_MONTH :
            time.add (Calendar.MONTH, amount);
            modified = true;
            break;
        case TIMESERIES_DEKAD :
            int dekad = getDekad (time);
            dekad += amount;
            switch (dekad) {
                case 0 :
                    time.set (Calendar.DAY_OF_MONTH, 25);
                    time.add (Calendar.MONTH, - 1);
                    break;
                case 1 :
                    time.set (Calendar.DAY_OF_MONTH, 5);
                    break;
                case 2 :
                    time.set (Calendar.DAY_OF_MONTH, 15);
                    break;
                case 3 :
                    time.set (Calendar.DAY_OF_MONTH, 25);
                    break;
                case 4 :
                    time.set (Calendar.DAY_OF_MONTH, 5);
                    time.add (Calendar.MONTH, 1);
                    break;
            }
            modified = true;
            break;
        case TIMESERIES_BIMONTH :
            int bimonth = getDekad (time);
            bimonth += amount;
            switch (bimonth) {
                case 0 :
                    time.set (Calendar.DAY_OF_MONTH, 20);
                    time.add (Calendar.MONTH, - 1);
                    break;
                case 1 :
                    time.set (Calendar.DAY_OF_MONTH, 10);
                    break;
                case 2 :
                    time.set (Calendar.DAY_OF_MONTH, 20);
                    break;
                case 3 :
                    time.set (Calendar.DAY_OF_MONTH, 10);
                    time.add (Calendar.MONTH, 1);
                    break;
            }
            modified = true;
            break;
        case TIMESERIES_DAY :
            time.add (Calendar.DAY_OF_MONTH, amount);
            modified = true;
            break;
    }
    return modified;
}


-----Function Pair=363=-----==

public boolean deleteAnnouncement (int aid) {
    boolean ok = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("delete from announcment where aid=?");
        stmt.setInt (1, aid);
        int num = stmt.executeUpdate ();
        if (num == 1) {
            ok = true;
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return ok;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=364=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private void createNgtdic (String newSchemaName) throws SQLException {
    try {
        StringBuffer dml = new StringBuffer ();
        String name = p_ctx.getBoSession ().getRepository ().getName ();
        dml.append ("create table ").append (newSchemaName).append (".NGTDIC").append ("(").append ("TABLENAME      VARCHAR(50) BINARY not null,").append ("OBJECTNAME     VARCHAR(50) BINARY not null,").append ("OBJECTTYPE     VARCHAR(10) BINARY not null,").append ("REQUIRED       CHAR(1),").append ("FIELDSIZE      VARCHAR(10) BINARY ,").append ("FIELDTYPE      VARCHAR(50) BINARY ,").append ("FRIENDLYNAME   VARCHAR(500) BINARY ,").append ("EXPRESSION     LONGTEXT,").append ("RULES          VARCHAR(255) BINARY ,").append ("PICTURE        VARCHAR(200) BINARY ,").append ("TABLEREFERENCE VARCHAR(100) BINARY ,").append ("FIELDREFERENCE VARCHAR(255) BINARY ,").append ("MACROFIELD     VARCHAR(50) BINARY ,").append ("SYS_ICN        NUMERIC(7),").append ("SYS_USER       VARCHAR(25) BINARY ,").append ("SYS_DTCREATE   DATETIME,").append ("SYS_DTSAVE     DATETIME,").append ("DEFAULTVALUE   VARCHAR(500) BINARY ,").append ("SEARCHDOMAIN   VARCHAR(30) BINARY ,").append ("\"SCHEMA\"     VARCHAR(30) BINARY not null,").append ("NGTTABLESPACE  VARCHAR(30) BINARY ,").append ("NGTINITIAL     VARCHAR(15) BINARY ,").append ("NGTNEXT        VARCHAR(15) BINARY ,").append ("NGTPCTINCREASE VARCHAR(15) BINARY,").append ("NGTMINEXTENTS  VARCHAR(15) BINARY,").append ("NGTMAXEXTENTS  VARCHAR(15) BINARY,").append ("NGTPCTFREE     VARCHAR(15) BINARY,").append ("NGTPCTUSED     VARCHAR(15) BINARY,").append ("NGTINITRANS    VARCHAR(15) BINARY,").append ("NGTMAXTRANS    VARCHAR(15) BINARY,").append ("OWNER          VARCHAR(30) BINARY,").append ("DELETECASCADE  CHAR(1) BINARY,").append ("CACHETTL       NUMERIC(10) default -1").append (")");
        executeDDL (dml.toString (), name);
        dml.delete (0, dml.length ());
        dml.append ("alter table ").append (newSchemaName).append (".NGTDIC add primary key (\"SCHEMA\",TABLENAME,OBJECTNAME,OBJECTTYPE)");
        executeDDL (dml.toString (), name);
        dml.delete (0, dml.length ());
        dml.append ("create index ").append ("IDX_OBJECTTYPE on ").append (newSchemaName).append (".NGTDIC (OBJECTTYPE)");
        executeDDL (dml.toString (), name);
        dml.delete (0, dml.length ());
        dml.append ("create index ").append ("IDX_TABLEREFERENCE on ").append (newSchemaName).append (".NGTDIC (TABLEREFERENCE)");
        executeDDL (dml.toString (), name);
    } catch (SQLException e) {
        throw (e);
    } finally {
    }
}


-----Function Pair=365=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            if (person.getHomeState () == State.AZ) {
                person.setIncome (IncomeGroup.aboveaverage);
            }
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private StringBuffer getInsertSql (List allProps, String table) {
    StringBuffer insertSql = new StringBuffer ();
    insertSql.append ("insert into ").append (table).append ("(");
    log.info ("正在生成服务和参数关联SQL:");
    for (Iterator itCol = allProps.iterator (); itCol.hasNext ();) {
        DOBOProperty property = (DOBOProperty) itCol.next ();
        insertSql.append (property.getColName ());
        if (itCol.hasNext ()) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    insertSql.append (" values(");
    for (int i = 0; i < allProps.size (); i ++) {
        insertSql.append ("?");
        if (i < allProps.size () - 1) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    return insertSql;
}


-----Function Pair=366=-----==

private void gerarComissao () {
    int opt = Funcoes.mensagemConfirma (null, "Confirma gerar comiss�es para o vendedor " + txtNomeVend.getVlrString ().trim () + "?");
    if (opt == JOptionPane.OK_OPTION) {
        StringBuilder insert = new StringBuilder ();
        insert.append ("INSERT INTO RPCOMISSAO ");
        insert.append ("(CODEMP, CODFILIAL, CODPED, CODITPED, ");
        insert.append ("CODEMPVD, CODFILIALVD, CODVEND, VLRCOMISS ) ");
        insert.append ("VALUES ");
        insert.append ("(?,?,?,?,?,?,?,?)");
        PreparedStatement ps;
        int parameterIndex;
        boolean gerou = false;
        try {
            for (int i = 0; i < tab.getNumLinhas (); i ++) {
                if (((BigDecimal) tab.getValor (i, 8)).floatValue () > 0) {
                    parameterIndex = 1;
                    ps = con.prepareStatement (insert.toString ());
                    ps.setInt (parameterIndex ++, AplicativoRep.iCodEmp);
                    ps.setInt (parameterIndex ++, ListaCampos.getMasterFilial ("RPCOMISSAO"));
                    ps.setInt (parameterIndex ++, txtCodPed.getVlrInteger ());
                    ps.setInt (parameterIndex ++, (Integer) tab.getValor (i, ETabNota.ITEM.ordinal ()));
                    ps.setInt (parameterIndex ++, AplicativoRep.iCodEmp);
                    ps.setInt (parameterIndex ++, ListaCampos.getMasterFilial ("RPVENDEDOR"));
                    ps.setInt (parameterIndex ++, txtCodVend.getVlrInteger ());
                    ps.setBigDecimal (parameterIndex ++, (BigDecimal) tab.getValor (i, ETabNota.VLRCOMIS.ordinal ()));
                    ps.executeUpdate ();
                    gerou = true;
                }
            }
            if (gerou) {
                Funcoes.mensagemInforma (null, "Comiss�o gerada para " + txtNomeVend.getVlrString ().trim ());
                txtCodPed.setText ("0");
                lcPedido.carregaDados ();
                carregaTabela ();
                con.commit ();
            }
            else {
                Funcoes.mensagemInforma (null, "N�o foi possiv�l gerar comiss�o!\nVerifique os valores das comiss�es dos itens.");
            }
        } catch (Exception e) {
            e.printStackTrace ();
            Funcoes.mensagemErro (this, "Erro ao gerar comiss�o!\n" + e.getMessage ());
            try {
                con.rollback ();
            } catch (SQLException e1) {
                e1.printStackTrace ();
            }
        }
    }
}


public void testMultipleResults0015 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0015 " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0015 values (?, ?)");
    int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pstmt.setInt (1, i);
        pstmt.setString (2, theString.substring (0, i));
        count += pstmt.executeUpdate ();
    }
    assertEquals (count, rowsToAdd);
    pstmt.close ();
    stmt.execute ("select s from #t0015 select i from #t0015");
    ResultSet rs = stmt.getResultSet ();
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertEquals (count, rowsToAdd);
    assertTrue (stmt.getMoreResults ());
    rs = stmt.getResultSet ();
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertEquals (count, rowsToAdd);
    rs = stmt.executeQuery ("select i, s from #t0015");
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertEquals (count, rowsToAdd);
    stmt.close ();
}


-----Function Pair=367=-----=1=

public static void main (String [] args) {
    try {
        Class.forName ("org.hsqldb.jdbcDriver");
    } catch (ClassNotFoundException e) {
        System.out.println ("HSQL Driver not found.");
        System.exit (1);
    }
    Connection con = null;
    try {
        con = DriverManager.getConnection ("jdbc:hsqldb:.", "sa", "");
        con.setAutoCommit (false);
    } catch (SQLException e) {
        System.out.println ("Connection error: " + e.getMessage ());
        System.exit (e.getErrorCode ());
    }
    String createTable = "CREATE TABLE NAMES (NAME VARCHAR(100))";
    Statement stmt = null;
    try {
        stmt = con.createStatement ();
        con.commit ();
        stmt.executeUpdate (createTable);
        con.commit ();
    } catch (SQLException e) {
        System.out.println ("Create table error: " + e.getMessage ());
        try {
            con.rollback ();
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    Vector names = new Vector (4);
    names.addElement ("FRANK");
    names.addElement ("FRED");
    names.addElement ("JACK");
    names.addElement ("JIM");
    String ins = "INSERT INTO NAMES VALUES (?)";
    PreparedStatement pstmt = null;
    try {
        con.commit ();
        pstmt = con.prepareStatement (ins);
        for (int i = 0; i < names.size (); i ++) {
            pstmt.setString (1, (String) names.elementAt (i));
            pstmt.executeUpdate ();
        }
        con.commit ();
    } catch (SQLException e) {
        System.out.println ("Insert error: " + e.getMessage ());
        try {
            con.rollback ();
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    String selAll = "SELECT * FROM NAMES";
    ResultSet rs = null;
    stmt = null;
    try {
        stmt = con.createStatement ();
        rs = stmt.executeQuery (selAll);
        System.out.println ("SELECT * FROM NAMES");
        while (rs.next ()) {
            String name = rs.getString (1);
            System.out.println ("\t" + name);
        }
        stmt.close ();
    } catch (SQLException e) {
        System.out.println ("Select All error: " + e.getMessage ());
        try {
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    String selectLike = "SELECT * FROM NAMES WHERE NAME LIKE 'F%'";
    rs = null;
    stmt = null;
    try {
        stmt = con.createStatement ();
        rs = stmt.executeQuery (selectLike);
        System.out.println ("SELECT * FROM NAMES WHERE NAME LIKE 'F%'");
        while (rs.next ()) {
            String name = rs.getString (1);
            System.out.println ("\t" + name);
        }
        stmt.close ();
    } catch (SQLException e) {
        System.out.println ("Select Like error: " + e.getMessage ());
        try {
            con.close ();
            System.exit (e.getErrorCode ());
        } catch (SQLException ex) {
        }
    }
    try {
        con.close ();
    } catch (SQLException e) {
    }
}


public void insertJobLog (String userId, String [] checkId, String checkType, String objType) throws Exception {
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preStm = null;
    String sql = "insert into COFFICE_JOBLOG_CHECKAUTH (USER_ID,CHECK_ID,CHECK_TYPE,OBJ_TYPE) values (?,?,?,?)";
    String cleanSql = "delete from COFFICE_JOBLOG_CHECKAUTH where " + "user_id = '" + userId + "' and check_type = '" + checkType + "' and obj_type = '" + objType + "'";
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        connection.setAutoCommit (false);
        preStm = connection.prepareStatement (cleanSql);
        int dCount = preStm.executeUpdate ();
        preStm = connection.prepareStatement (sql);
        String sHaveIns = ",";
        for (int j = 0; j < checkId.length; j ++) {
            if (sHaveIns.indexOf ("," + checkId [j] + ",") < 0) {
                preStm.setInt (1, Integer.parseInt (userId));
                preStm.setInt (2, Integer.parseInt (checkId [j]));
                preStm.setInt (3, Integer.parseInt (checkType));
                preStm.setInt (4, Integer.parseInt (objType));
                preStm.executeUpdate ();
                sHaveIns += checkId [j] + ",";
            }
        }
        connection.commit ();
    } catch (Exception ex) {
        log.debug ((new Date ().toString ()) + " ������Ȩ��ʧ��! ");
        try {
            connection.rollback ();
        } catch (SQLException e) {
            throw e;
        }
        throw ex;
    } finally {
        close (null, null, preStm, connection, dbo);
    }
}


-----Function Pair=368=-----==

private void cloneUserHistory (Long nCourseOldId, Long nCourseNewId) {
    try {
        log.info ("CLONACION HISTORIAL DE CURSOS X USUARIO");
        CoCourse coCourse = new CoCourseDAO ().findById (nCourseOldId);
        EntityManagerHelper.refresh (coCourse);
        Set < CoCourseUserHistory > setUserHistoryOld = coCourse.getCoCourseUserHistories ();
        CoCourse coCourseNew = new CoCourseDAO ().findById (nCourseNewId);
        for (CoCourseUserHistory coCourseUserHistory : setUserHistoryOld) {
            MaUser maUser = coCourseUserHistory.getMaUser ();
            CoCourseUserHistory courseUserHistory = new CoCourseUserHistoryDAO ().findById (new CoCourseUserHistoryId (coCourseNew.getCourseId (), maUser.getUserId ()));
            log.info ("Resultado de la consulta=> " + courseUserHistory);
            if (courseUserHistory == null) {
                log.info ("Agregando HistorialxCurso: Usuario '" + maUser.getUserId () + "' - Curso '" + coCourseNew.getCourseId () + "'");
                addUserHistory (maUser, coCourseNew);
            }
            else {
                log.info ("El usuario '" + maUser.getUserId () + "' tiene el curso '" + coCourseNew.getCourseId () + "'");
            }
        }
        log.info ("Ok...Termina clonaci�n de Historial de usuarios en CURSOS");
    } catch (PersistenceException e) {
        e.printStackTrace ();
    }
}


public void assertDefaultProperty (String message, String url, Properties properties, String fieldName, String key, String expected) {
    {
        if ("sendStringParametersAsUnicode".equals (fieldName)) {
            fieldName = "useUnicode";
        }
    }
    Properties parsedProperties = (Properties) invokeStaticMethod (Driver.class, "parseURL", new Class [] {String.class, Properties.class}, new Object [] {url, properties});
    parsedProperties = (Properties) invokeStaticMethod (DefaultProperties.class, "addDefaultProperties", new Class [] {Properties.class}, new Object [] {parsedProperties});
    ConnectionJDBC2 instance = (ConnectionJDBC2) invokeConstructor (ConnectionJDBC2.class, new Class [] {}, new Object [] {});
    invokeInstanceMethod (instance, "unpackProperties", new Class [] {Properties.class}, new Object [] {parsedProperties});
    String actual = String.valueOf (invokeGetInstanceField (instance, fieldName));
    {
        if ("tdsVersion".equals (fieldName)) {
            expected = String.valueOf (DefaultProperties.getTdsVersion (expected));
        }
    }
    assertEquals (message, expected, actual);
}


-----Function Pair=369=-----==

private void updateClobs (Connection cn, ResultSet node, ArrayList clobs) throws SQLException, IOException {
    final String static_query = " WHERE \"SCHEMA\"=? AND TABLENAME=? AND OBJECTNAME=? AND OBJECTTYPE=?  ";
    StringBuffer sb = new StringBuffer ("SELECT ");
    for (short i = 0; i < clobs.size (); i ++) {
        if (i > 0) {
            sb.append (',');
        }
        sb.append ("\"").append (node.getMetaData ().getColumnName (((Integer) clobs.get (i)).intValue ())).append ("\"");
    }
    sb.append (" FROM NGTDIC ").append (static_query);
    PreparedStatement clobpstm = cn.prepareStatement (sb.toString ());
    clobpstm.setString (1, node.getString ("SCHEMA"));
    clobpstm.setString (2, node.getString ("TABLENAME"));
    clobpstm.setString (3, node.getString ("OBJECTNAME"));
    clobpstm.setString (4, node.getString ("OBJECTTYPE"));
    ResultSet clobrslt = clobpstm.executeQuery ();
    if (clobrslt.next ()) {
        for (byte y = 0; y < clobs.size (); y ++) {
            Clob clob = clobrslt.getClob (y + 1);
            clob.truncate (0);
            String strclob = node.getString (((Integer) clobs.get (y)).intValue ());
            clob.setString (1, strclob);
        }
        clobrslt.close ();
        clobpstm.close ();
    }
}


public static void cloneUserHistory (Long nActivityOldId, Long nActivityNewId) {
    try {
        log.info ("CLONACION HISTORIAL DE ACTIVIDADES X USUARIO");
        CoActivity coActivity = new CoActivityDAO ().findById (nActivityOldId);
        CoActivity coActivityNew = new CoActivityDAO ().findById (nActivityNewId);
        EntityManagerHelper.refresh (coActivity);
        EntityManagerHelper.refresh (coActivityNew);
        Set < CoActivityUserHistory > setUserHistoryOld = coActivity.getCoActivityUserHistories ();
        for (CoActivityUserHistory coActivityUserHistory : setUserHistoryOld) {
            MaUser maUser = coActivityUserHistory.getMaUser ();
            CoActivityUserHistory activityUserHistory = new CoActivityUserHistoryDAO ().findById (new CoActivityUserHistoryId (nActivityNewId, maUser.getUserId ()));
            log.info ("Resultado de la consulta=> " + activityUserHistory);
            if (activityUserHistory == null) {
                log.info ("Agregando HistorialxActividad: Usuario '" + maUser.getUserId () + "' - actividad '" + coActivityNew.getActivityId () + "'");
                addUserHistory (maUser, coActivityNew);
            }
            else {
                log.info ("El usuario '" + maUser.getUserId () + "' tiene la actividad '" + coActivityNew.getActivityId () + "'");
            }
        }
        log.info ("Ok...Termina clonaci�n de Historial de usuarios en ACTIVIDADES");
    } catch (PersistenceException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=370=-----==

public RestServiceResult listCourseForUser (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    Set < CoCourse > set = new HashSet < CoCourse > ();
    List < CoCourse > listCourse = new ArrayList < CoCourse > ();
    if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_STUDENT)) {
        List < CoCourseUser > list = new ArrayList < CoCourseUser > (maUser.getCoCourseUsers ());
        for (CoCourseUser coCourseUser : list) {
            set.add (coCourseUser.getCoCourse ());
        }
    }
    else if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_TEACHER)) {
        set = maUser.getCoCoursesForUserId ();
    }
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("course.list.notFound"));
    }
    else {
        listCourse.addAll (set);
        Object [] array = {listCourse.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.list.success"), array));
    }
    serviceResult.setObjResult (listCourse);
    return serviceResult;
}


public RestServiceResult searchByExercises (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixExercises1.search.notFound"));
    }
    else {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_MATRIX_EXERCISES1, CoMatrixExercises1.class);
        query.setParameter (1, nExerciseId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        List < CoMatrixExercises1 > list = query.getResultList ();
        if (list.size () > 0) {
            Object [] arrayParam = {list.size ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises1.search.success"), arrayParam));
            serviceResult.setObjResult (list);
            serviceResult.setNumResult (list.size ());
        }
        else {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("matrixExercises1.search.notFound"));
        }
    }
    return serviceResult;
}


-----Function Pair=371=-----==

public Boolean executeUpdateTransaction (DatabaseQuery [] aDatabaseQueries) {
    Integer iPos = 0;
    PreparedStatement [] aQueries = this.getPreparedStatements (aDatabaseQueries);
    Connection oConnection = this.getConnection ();
    Boolean bAutoCommit = true;
    if (aQueries.length == 0) {
        return true;
    }
    if (oConnection == null) {
        return false;
    }
    try {
        bAutoCommit = oConnection.getAutoCommit ();
        oConnection.setAutoCommit (false);
        for (iPos = 0; iPos < aQueries.length; iPos ++) {
            aQueries [iPos].executeUpdate ();
            aQueries [iPos].close ();
        }
        if (bAutoCommit) {
            oConnection.commit ();
            oConnection.setAutoCommit (true);
        }
    } catch (SQLException oException) {
        if (this.reloadConnection ()) return this.executeUpdateTransaction (aDatabaseQueries);
        else {
            try {
                oConnection.rollback ();
            } catch (SQLException oRollbackException) {
                throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, Strings.ROLLBACK, oRollbackException);
            }
            throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, this.getQueries (aDatabaseQueries).toString (), oException);
        }
    } finally {
        try {
            oConnection.setAutoCommit (bAutoCommit);
        } catch (SQLException oException) {
            throw new SystemException (ErrorCode.CLOSE_QUERY, null, oException);
        }
    }
    return true;
}


public RestServiceResult create (RestServiceResult serviceResult, CoActivity coActivity) {
    CoActivityDAO coActivityDAO = new CoActivityDAO ();
    try {
        coActivity.setActivityId (getSequence ("sq_co_activity"));
        EntityManagerHelper.beginTransaction ();
        coActivityDAO.save (coActivity);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coActivity);
        log.info ("Actividad creada con �xito: " + coActivity.getActivityName ());
        Object [] arrayParam = {coActivity.getActivityName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("activity.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("activity.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=372=-----==

public ArrayList < THLEvent > find (Long low, Long high) throws THLException {
    ResultSet res = null;
    try {
        String query = "SELECT * FROM " + metadataSchema + ".history";
        query += genSQLWhereIntervalClause ("seqno", low, high, false);
        query += " order by seqno";
        res = statement.executeQuery (query);
        ArrayList < THLEvent > events = new ArrayList < THLEvent > ();
        while (res.next ()) {
            THLEvent thlEvent = parseResultSet (res);
            events.add (thlEvent);
        }
        return events;
    } catch (SQLException e) {
        throw new THLException (e);
    } finally {
        if (res != null) try {
            res.close ();
        } catch (SQLException ignore) {
        }
    }
}


public static void generateKeys2 (int keySize, Path publicKey, Path privateKey) throws NoSuchAlgorithmException, IOException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance ("RSA");
    keyGen.initialize (keySize);
    KeyPair keyPair = keyGen.generateKeyPair ();
    PublicKey pubkey = keyPair.getPublic ();
    PrivateKey privkey = keyPair.getPrivate ();
    Files.createDirectories (publicKey.getParent ());
    Files.createFile (publicKey);
    Files.createDirectories (privateKey.getParent ());
    Files.createFile (privateKey);
    ObjectOutputStream oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (publicKey.toFile ())));
    oout.writeObject (pubkey);
    oout.close ();
    oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (privateKey.toFile ())));
    oout.writeObject (privkey);
    oout.close ();
}


-----Function Pair=373=-----==

public List < E > getObjectFromNamedQueryLimitedResult (int i, String namedQuery, Object...parametros) {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    int position = 1;
    List < E > array = new ArrayList < E > ();
    try {
        tx.begin ();
        Query q = em.createNamedQuery (namedQuery);
        q.setMaxResults (i);
        for (Object parametro : parametros) {
            q.setParameter (position ++, parametro);
        }
        tx.commit ();
        array = q.getResultList ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
    return array;
}


public RestServiceResult update (RestServiceResult serviceResult, CoExercises1 coExercises1, String sDeliveryDate) {
    CoExercises1DAO coExercises1DAO = new CoExercises1DAO ();
    Long nExerciseId = coExercises1.getExerciseId ();
    try {
        EntityManagerHelper.beginTransaction ();
        coExercises1DAO.update (coExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coExercises1);
        Object [] args = {coExercises1.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.update.success"), args));
        this.addDeliveryDate (nExerciseId, sDeliveryDate);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=374=-----==

public void store (THLEvent event, boolean syncCommitSeqno) throws THLException {
    try {
        long metricID = 0L;
        ReplEvent revent = event.getReplEvent ();
        ByteArrayOutputStream baob = new ByteArrayOutputStream ();
        ObjectOutputStream oob = new ObjectOutputStream (baob);
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) metricID = runtime.getMonitor ().startCPUEvent (ReplicatorMonitor.CPU_DB_SERIAL);
        oob.writeObject (revent);
        byte [] barr = baob.toByteArray ();
        InputStream is = new ByteArrayInputStream (barr);
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) runtime.getMonitor ().stopCPUEvent (ReplicatorMonitor.CPU_DB_SERIAL, metricID);
        historySeqno.setValue (event.getSeqno ());
        historyFragno.setValue (event.getFragno ());
        historyLastFrag.setValue (event.getLastFrag ());
        historySourceId.setValue (truncate (event.getSourceId (), historySourceId.getLength ()));
        historyType.setValue (event.getType ());
        historyEpochNumber.setValue (event.getEpochNumber ());
        Timestamp now = new Timestamp (System.currentTimeMillis ());
        historyLocalEnqueueTstamp.setValue (now);
        historySourceTstamp.setValue (event.getSourceTstamp ());
        historyProcessedTstamp.setValue (now);
        historyStatus.setValue (event.getStatus ());
        historyComment.setValue (null);
        historyEventId.setValue (event.getEventId ());
        historyEvent.setValue (is, barr.length);
        if (event.getFragno () == 0) {
            if (logger.isDebugEnabled ()) logger.debug ("Starting new transaction");
            conn.setAutoCommit (false);
        }
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) metricID = runtime.getMonitor ().startCPUEvent (ReplicatorMonitor.CPU_INSERTTHL);
        conn.insert (history);
        if (syncCommitSeqno) {
            updateCommitSeqnoTable (event);
        }
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) runtime.getMonitor ().stopCPUEvent (ReplicatorMonitor.CPU_INSERTTHL, metricID);
        if (event.getLastFrag ()) {
            if (logger.isDebugEnabled ()) logger.debug ("Committing");
            conn.commit ();
            conn.setAutoCommit (true);
        }
    } catch (SQLException e) {
        throw new THLException (e);
    } catch (java.io.IOException e) {
        throw new THLException (e);
    }
}


public RlxVariable getVariable (String host, String scope, String name) throws Exception {
    Session session = null;
    try {
        RlxVariable variable = null;
        session = sessionFactory.openSession ();
        Query query = session.createQuery ("from RlxVariable v where v.name = ? and v.host = ?" + (scope != null ? " and v.scope = ?" : ""));
        query.setString (0, name);
        query.setString (1, host);
        if (scope != null) {
            query.setString (2, scope);
        }
        List list = query.list ();
        if (list != null && ! list.isEmpty ()) {
            return (RlxVariable) list.get (0);
        }
        else {
            return null;
        }
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


-----Function Pair=375=-----==

public boolean hasStarredMessages (Board board, int maxDaysBack) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps;
    if (maxDaysBack < 0) {
        ps = db.prepareStatement ("SELECT isstarred FROM " + getMessageTableName () + " WHERE board=? AND isstarred=TRUE AND isvalid=TRUE");
        ps.setInt (1, board.getPrimaryKey ().intValue ());
    }
    else {
        ps = db.prepareStatement ("SELECT isstarred FROM " + getMessageTableName () + " WHERE msgdatetime>=? AND board=? AND isstarred=TRUE AND isvalid=TRUE");
        LocalDate localDate = new LocalDate (DateTimeZone.UTC).minusDays (maxDaysBack);
        ps.setLong (1, localDate.toDateMidnight (DateTimeZone.UTC).getMillis ());
        ps.setInt (2, board.getPrimaryKey ().intValue ());
    }
    ps.setMaxRows (1);
    boolean hasStarred = false;
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        hasStarred = rs.getBoolean (1);
    }
    rs.close ();
    ps.close ();
    return hasStarred;
}


public Vector getEventDatesBetween (BigDecimal owner, String orderby, Date begin, Date end) throws SQLException {
    Vector events = new Vector ();
    try {
        con = allocateConnection (tableName);
        ps = con.prepareStatement ("select startdate from cal_Event where owner=? and startdate>=? " + "and startdate<? and syncstatus<? group by startdate order by " + orderby);
        ps.setBigDecimal (1, owner);
        ps.setDate (2, begin);
        ps.setDate (3, end);
        ps.setInt (4, DELETE);
        rs = con.executeQuery (ps, null);
        while (rs.next ()) {
            events.addElement (rs.getDate ("startdate"));
        }
    } catch (SQLException e) {
        if (DEBUG) logError ("", e);
        throw e;
    } finally {
        release ();
    }
    return events;
}


-----Function Pair=376=-----==

public static Any getDocList (Connection con, Any values, Any retValue) throws SQLException {
    String sParentID = (String) values.extract_wstring ();
    PreparedStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocList");
    try {
        ps = con.prepareStatement (sSql);
        ps.setString (1, sParentID);
        ResultSet rSet = ps.executeQuery ();
        ArrayList < HashMap > arVal = new ArrayList < HashMap > ();
        while (rSet.next ()) {
            HashMap value = new HashMap ();
            value.put ("ID", rSet.getString ("IOBJID"));
            value.put ("NAME", rSet.getString ("COBJNAME"));
            value.put ("NUM", rSet.getString ("COBJNUM"));
            value.put ("USRNAME", rSet.getString ("CUSRNAME"));
            value.put ("LOGNAME", rSet.getString ("CLOGNAME"));
            value.put ("DUTY", rSet.getString ("CUSRDUTY"));
            value.put ("DCREATE", rSet.getString ("DCREATE"));
            String sExt = rSet.getString ("EXTENSION");
            if (sExt != null) sExt = sExt.replace (".", "");
            value.put ("EXT", sExt);
            arVal.add (value);
        }
        retValue.insert_Value (arVal.toArray (new HashMap [arVal.size ()]));
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


public static Long addNewUser (DatabaseAdapter db_, String first_name, String last_name, String middle_name, Long id_firm, String email, String address, String phone) throws Exception {
    PreparedStatement ps = null;
    try {
        CustomSequenceType seq = new CustomSequenceType ();
        seq.setSequenceName ("seq_WM_LIST_USER");
        seq.setTableName ("WM_LIST_USER");
        seq.setColumnName ("ID_USER");
        long id = db_.getSequenceNextValue (seq);
        ps = db_.prepareStatement ("insert into WM_LIST_USER " + "(ID_USER, FIRST_NAME, LAST_NAME, MIDDLE_NAME, " + "ID_FIRM, EMAIL, ADDRESS, TELEPHONE, DATE_START_WORK ) " + "values " + "( ?, ?, ?, ?, ?, ?, ?, ?, " + db_.getNameDateBind () + " )	");
        ps.setLong (1, id);
        ps.setString (2, first_name);
        ps.setString (3, last_name);
        ps.setString (4, middle_name);
        ps.setObject (5, id_firm);
        ps.setString (6, email);
        ps.setString (7, address);
        ps.setString (8, phone);
        db_.bindDate (ps, 9, DateTools.getCurrentTime ());
        int i = ps.executeUpdate ();
        if (log.isDebugEnabled ()) log.debug ("Count of added role - " + i);
        return id;
    } catch (Exception e) {
        log.error ("Error addNewUser", e);
        throw e;
    } finally {
        DatabaseManager.close (ps);
        ps = null;
    }
}


-----Function Pair=377=-----==

public List < User > getUserList (AuthSession authSession) {
    DatabaseAdapter db = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        db = DatabaseAdapter.getInstance ();
        String sql = "select a.ID_USER,a.ID_FIRM,a.FIRST_NAME,a.MIDDLE_NAME,a.LAST_NAME," + "       a.DATE_START_WORK,a.DATE_FIRE,a.ADDRESS,a.TELEPHONE,a.EMAIL,a.IS_DELETED " + "from   WM_LIST_USER a " + "where  a.IS_DELETED=0  and a.ID_FIRM in ";
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                String idList = authSession.getGrantedCompanyId ();
                sql += " (" + idList + ") ";
                break;
            default :
                sql += "(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)";
                break;
        }
        ps = db.prepareStatement (sql);
        int num = 1;
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                break;
            default :
                ps.setString (num ++, authSession.getUserLogin ());
                break;
        }
        rs = ps.executeQuery ();
        List < User > list = new ArrayList < User > ();
        while (rs.next ()) {
            UserBean beanPortal = loadPortalUserFromResultSet (rs);
            final Company company = InternalDaoFactory.getInternalCompanyDao ().getCompany (beanPortal.getCompanyId (), authSession);
            if (company != null) beanPortal.setCompanyName (company.getName ());
            else beanPortal.setCompanyName ("Warning. Ccompany not found");
            list.add (beanPortal);
        }
        return list;
    } catch (Exception e) {
        String es = "Error load list of portal users";
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


public List < Map < String, String > > query (DaoParam param) {
    List < Map < String, String > > lsRet = FactoryUtil.newList ();
    if (param == null) param = new DaoParam ();
    String sql = param.getSql ();
    if (sql == null || sql.length () < 10) {
        _log.showWarn ("query sql param is null! ");
        return lsRet;
    }
    List < String > lsType = param.getType ();
    List < String > lsValue = param.getValue ();
    if (lsType.size () != lsValue.size ()) {
        _log.showWarn ("query type and value size differ! ");
        return lsRet;
    }
    String dataSource = param.getDsName ();
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    TransactionObject tranObj = null;
    try {
        tranObj = _tranMng.getTransactionObject ();
        con = tranObj.getConnection (dataSource);
        if (con == null) {
            _log.showWarn ("connection is null sql=" + sql);
            return lsRet;
        }
        ps = con.prepareStatement (sql);
        if (! lsValue.isEmpty ()) {
            ps = DaoUtil.setPreStmParams (lsValue, lsType, ps);
        }
        long curTime = System.currentTimeMillis ();
        rs = ps.executeQuery ();
        DaoUtil.showQueryTime (curTime, sql);
        lsRet = DaoUtil.getRsToList (rs);
    } catch (SQLException e) {
        DaoUtil.closeTranObj (tranObj);
        DaoUtil.showException (e, sql);
        return lsRet;
    } catch (Exception e) {
        DaoUtil.closeTranObj (tranObj);
        DaoUtil.showException (e, sql);
        return lsRet;
    } finally {
        try {
            if (rs != null) rs.close ();
            rs = null;
            if (ps != null) ps.close ();
            ps = null;
        } catch (SQLException e) {
            _log.showError (e);
        }
    }
    return lsRet;
}


-----Function Pair=378=-----==

private void deleteDocsForActivityMYSQL (long id) throws SQLException {
    AIDADocument [] docs = getForActivity (id);
    if (docs != null) {
        Connection con = getConnection ();
        try {
            PreparedStatement ps = con.prepareStatement ("DELETE FROM doc_docs WHERE id = ?");
            for (int i = 0; i < docs.length; i ++) {
                ps.clearParameters ();
                ps.setLong (1, docs [i].getId ());
                ps.executeUpdate ();
            }
            ps.close ();
        } catch (SQLException sqlEx) {
            throw sqlEx;
        } finally {
            con.close ();
        }
    }
}


public static void batchUpdatePriority (ArrayList < IdValue < Integer > > v) throws SQLException {
    boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        final String query = "UPDATE " + table + " SET priority=? WHERE idJob=?";
        PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
        curSt = st;
        for (IdValue < Integer > r : v) {
            st.setInt (1, r.value);
            st.setInt (2, r.id);
            st.addBatch ();
        }
        st.executeBatch ();
        st.close ();
    } catch (Throwable e) {
        DatabaseConnector.getInstance ().getConn ().rollback ();
        if (e instanceof SQLException) {
            throw (SQLException) e;
        }
    } finally {
        curSt = null;
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
    }
}


-----Function Pair=379=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** shuffle ***");
        shuffle (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public String getJsonResponce () {
    try {
        log.debug ("Создание нового вендора: " + title);
        JSONObject json = new JSONObject ();
        if (sameTitleExists ()) {
            json.put (JSON.KEY_RESULT, JSON.VAL_SAME_TITLE_EXISTS);
            return json.toString ();
        }
        Retailer r = create ();
        json.put (JSON.KEY_RESULT, JSON.VAL_SUCCESS);
        json.put (JSON.KEY_ID, r.getId ());
        return json.toString ();
    } catch (Exception e) {
        log.warn ("Ошибка при создании нового вендора.", e);
        return Utils.wrapExceptionIntoJson (e);
    }
}


-----Function Pair=380=-----==

public List getVariableSnapshotMap (String scopePattern, Date startDate, Date endDate) throws Exception {
    Session session = null;
    try {
        session = sessionFactory.openSession ();
        Query query = session.createQuery ("from RlxVariable v, RlxVariableSnapshot vs where v.id = vs.variableId and v.scope like ? and vs.timestamp >= ? and vs.timestamp <= ?");
        query.setString (0, scopePattern);
        query.setTimestamp (1, startDate);
        query.setTimestamp (2, endDate);
        List list = query.list ();
        Hibernate.initialize (list);
        return list;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


public List getPortfolioEntries (long pid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from PortfolioEntry R where R.portfolioId=? order by R.id";
        Query q = s.createQuery (query);
        q.setLong (0, pid);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=381=-----==

public List < Ranks > findAllRanks () {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Ranks");
        List < Ranks > rankList = query.list ();
        tr.commit ();
        return rankList;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public void testNot () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT P.firstName FROM " + Person.class.getName () + " P WHERE NOT (1 = 0)").getResultList ();
        assertEquals (1, result.size ());
        result = em.createQuery ("SELECT P.firstName FROM " + Person.class.getName () + " P WHERE NOT (1 = 0 AND 1 = 2)").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=382=-----==

public List < Usergroups > findUsergroupInCredits (int Credits, short groupid) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Usergroups as u where u.type='member' and ((" + Credits + " >= u.creditshigher and u.creditslower > " + Credits + ") or (u.groupid = " + groupid + "))");
        List < Usergroups > list = query.list ();
        tr.commit ();
        return list;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public void doGet (HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {
    String context = request.getContextPath ();
    response.setContentType ("text/html");
    PrintWriter out = response.getWriter ();
    out.println ("<HTML>");
    out.println ("<HEAD>");
    out.println ("<TITLE>Load Tutorial 1 Test Data</TITLE>");
    out.println ("<LINK REL=stylesheet HREF=" + context + "/Borderless.css>");
    out.println ("</HEAD>");
    out.println ("<BODY>");
    String [] [] path = {{"Home", context + "/index"}, {"Load Tutorial 1 Test Data", null}};
    FidoServlet.header (out, path, null, context);
    try {
        load ();
        out.println ("Everything loaded OK<P>");
    } catch (Exception e) {
        out.println ("<PRE>");
        e.printStackTrace (out);
        out.println ("</PRE>");
    }
    FidoServlet.footer (out);
    out.println ("</BODY>");
    out.println ("</HTML>");
}


-----Function Pair=383=-----==

public void setBbsSession (HttpServletRequest request, String loginName, String userPass) {
    AuthorizationFactory authorizationFactory = AuthorizationFactory.getInstance ();
    Authorization authorization = null;
    try {
        authorization = authorizationFactory.getAuthorization (loginName, userPass);
        HttpSession session = request.getSession ();
        if (session != null) {
            authorization.setIP (request.getRemoteAddr () == null ? "127.0.0.1" : request.getRemoteAddr ());
            authorization.setSessionID (session.getId ());
            session.setAttribute ("authorization", authorization);
        }
    } catch (Exception e1) {
        e1.printStackTrace ();
    }
}


private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (0, address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


-----Function Pair=384=-----==

public boolean validateRangeExerciseS2Scored (CoExercises2 coExercises2, Long nUserId) {
    List < CoScoreExercises2 > listCoScoreExercises2 = new ArrayList < CoScoreExercises2 > ();
    CoScoreExercises2 coScoreExercises2 = null;
    String sFlagExerciseScore = "";
    Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_SCORE_EXERCISES2, CoScoreExercises2.class);
    query.setParameter (1, coExercises2.getExerciseId ());
    query.setParameter (2, nUserId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listCoScoreExercises2 = query.getResultList ();
    for (int i = 0; i < listCoScoreExercises2.size (); i ++) {
        coScoreExercises2 = (CoScoreExercises2) listCoScoreExercises2.get (i);
        sFlagExerciseScore = coExercises2.getFlagExerciseScore ();
    }
    if (coScoreExercises2 == null) {
        return false;
    }
    else if (sFlagExerciseScore.equalsIgnoreCase ("0")) {
        Float nScore = new Float (coScoreExercises2.getScore ());
        if (nScore < Common.CRITIC_VALUE_QUANTITATIVE || nScore >= Common.EXELLENT_VALUE_QUANTITATIVE) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        Long nScore = new Long (coScoreExercises2.getScore ());
        if (nScore < Common.CRITIC_VALUE_QUALITATIVE || nScore >= Common.EXELLENT_VALUE_QUALITATIVE) {
            return true;
        }
        else {
            return false;
        }
    }
}


public Collection < PrecoProduto > consultaPorTipo (TipoProduto tipo) throws PersistenciaException {
    if (tipo == null) {
        String erro = "Erro ao tentar consultar por tipo. Tipo informado é nulo";
        logger.error (erro);
        throw new IllegalArgumentException (erro);
    }
    EntityManager em = getEntityManager ();
    Collection < PrecoProduto > produtos = null;
    try {
        em.getTransaction ().begin ();
        Query query = em.createQuery ("select p from PrecoProduto p where p.produto.tipo like ?1").setParameter (1, tipo);
        produtos = query.getResultList ();
    } catch (Exception e) {
        String erro = "Erro ao tentar consultar produto por tipo";
        logger.error (erro);
        em.getTransaction ().rollback ();
        throw new PersistenciaException (e);
    } finally {
        em.close ();
    }
    return produtos;
}


-----Function Pair=385=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


protected static int commitNamedUpdate (String hql, Object [] args) {
    try {
        Session ssn = getSession ();
        beginTransaction ();
        Query q = ssn.getNamedQuery (hql);
        for (int i = 0; args != null && i < args.length; i ++) {
            q.setParameter (i, args [i]);
        }
        int er = q.executeUpdate ();
        commit ();
        return er;
    } catch (HibernateException e) {
        rollback ();
        throw e;
    }
}


-----Function Pair=386=-----==

public static NeuralQuote [] getByQuote (Connection c, int azioneID, int forward) throws SQLException {
    ArrayList < NeuralQuote > list = new ArrayList < NeuralQuote > ();
    PreparedStatement ps = c.prepareStatement (selectByQuote);
    ps.setInt (1, azioneID);
    ps.setInt (2, forward);
    ResultSet rs = ps.executeQuery ();
    ObjectInputStream ois;
    while (rs.next ()) {
        NeuralQuote nq = new NeuralQuote ();
        try {
            ois = new ObjectInputStream (rs.getBlob (1).getBinaryStream ());
            nq.setNet ((MLPApprox) ois.readObject ());
            ois = new ObjectInputStream (rs.getBlob (2).getBinaryStream ());
            nq.setIndexes ((ArrayList < Integer >) ois.readObject ());
        } catch (IOException e) {
            e.printStackTrace ();
        } catch (ClassNotFoundException e) {
            e.printStackTrace ();
        }
        list.add (nq);
    }
    NeuralQuote [] out = new NeuralQuote [list.size ()];
    return list.toArray (out);
}


public String [] getDocTypePaths (String siteChannelPath, boolean isFindParentNode) throws Exception {
    if (siteChannelPath == null) {
        return null;
    }
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    List list = new ArrayList ();
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        if (isFindParentNode) {
            while (siteChannelPath.length () >= 5) {
                preparedStatement = connection.prepareStatement ("select doctype_path from t_ip_doctype_channel where chan_path='" + siteChannelPath + "'");
                resultSet = preparedStatement.executeQuery ();
                boolean repeat = true;
                while (resultSet.next ()) {
                    repeat = false;
                    list.add (resultSet.getString (1));
                }
                if (repeat) {
                    siteChannelPath = siteChannelPath.substring (0, siteChannelPath.length () - 5);
                }
                else {
                    break;
                }
            }
        }
        else {
            resultSet = dbo.select ("select doctype_path from t_ip_doctype_channel where chan_path='" + siteChannelPath + "'");
            while (resultSet.next ()) {
                list.add (resultSet.getString (1));
            }
        }
    } catch (Exception ex) {
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
    String [] result = new String [list.size ()];
    for (int i = 0; i < result.length; i ++) {
        result [i] = (String) list.get (i);
    }
    return result;
}


-----Function Pair=387=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static void delete (String module_id) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        sql = "DELETE FROM role_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        sql = "DELETE FROM user_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        sql = "DELETE FROM role_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        sql = "DELETE FROM module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=388=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        person.getAddresses ().add (address2);
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public List < Favorites > findFavoritesByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Favorites as f where f.id.uid=?");
        query.setParameter (0, uid);
        List < Favorites > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=389=-----==

private void storeFieldMap (WorkingContent c, Connection conn) throws SQLException {
    SQLDialect dialect = getDatabase ().getSQLDialect ();
    if (TRANSACTIONS_ENABLED) {
        conn.setAutoCommit (false);
    }
    try {
        Object thisKey = c.getPrimaryKey ();
        deleteFieldContent (thisKey, conn);
        PreparedStatement ps = null;
        StructureItem nextItem;
        Map fieldMap = c.getFieldMap ();
        String type;
        Object value, siKey;
        for (Iterator i = c.getStructure ().getStructureItems ().iterator (); i.hasNext ();) {
            nextItem = (StructureItem) i.next ();
            type = nextItem.getDataType ().toUpperCase ();
            siKey = nextItem.getPrimaryKey ();
            value = fieldMap.get (nextItem.getName ());
            try {
                if (type.equals (StructureItem.DATE)) {
                    ps = conn.prepareStatement (sqlConstants.get ("INSERT_DATE_FIELD"));
                    ps.setObject (1, thisKey);
                    ps.setObject (2, siKey);
                    dialect.setDate (ps, 3, (Date) value);
                    ps.executeUpdate ();
                }
                else if (type.equals (StructureItem.INT) || type.equals (StructureItem.FLOAT) || type.equals (StructureItem.VARCHAR)) {
                    ps = conn.prepareStatement (sqlConstants.get ("INSERT_" + type + "_FIELD"));
                    ps.setObject (1, thisKey);
                    ps.setObject (2, siKey);
                    if (value != null) {
                        ps.setObject (3, value);
                    }
                    else {
                        int sqlType = Types.INTEGER;
                        if (type.equals (StructureItem.FLOAT)) {
                            sqlType = Types.FLOAT;
                        }
                        else if (type.equals (StructureItem.VARCHAR)) {
                            sqlType = Types.VARCHAR;
                        }
                        ps.setNull (3, sqlType);
                    }
                    ps.executeUpdate ();
                }
                else if (type.equals (StructureItem.TEXT)) {
                    setTextField (c, siKey, (String) value, conn);
                }
                if (ps != null) {
                    ps.close ();
                    ps = null;
                }
            } finally {
                if (ps != null) ps.close ();
            }
        }
        if (TRANSACTIONS_ENABLED) {
            conn.commit ();
        }
    } catch (SQLException e) {
        if (TRANSACTIONS_ENABLED) {
            conn.rollback ();
        }
        throw e;
    } finally {
        if (TRANSACTIONS_ENABLED) {
            conn.setAutoCommit (true);
        }
    }
}


public static int deleteBlacklist (int ownerId, String [] otherIds) {
    if (otherIds == null || otherIds.length == 0) return 0;
    StringBuffer hql = new StringBuffer ("DELETE FROM MyBlackListBean f WHERE f.myId=? AND f.other.id IN (");
    for (int i = 0; i < otherIds.length; i ++) {
        hql.append ("?,");
    }
    hql.append ("?)");
    Session ssn = getSession ();
    try {
        beginTransaction ();
        Query q = ssn.createQuery (hql.toString ());
        q.setInteger (0, ownerId);
        int i = 0;
        for (; i < otherIds.length; i ++) {
            String s_id = (String) otherIds [i];
            int id = - 1;
            try {
                id = Integer.parseInt (s_id);
            } catch (Exception e) {
            }
            q.setInteger (i + 1, id);
        }
        q.setInteger (i + 1, - 1);
        int er = q.executeUpdate ();
        commit ();
        return er;
    } catch (HibernateException e) {
        rollback ();
        throw e;
    }
}


-----Function Pair=390=-----==

public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=391=-----==

public String getJsonResponse () {
    try {
        log.debug ("Создание нового пользователя с именем '{}' и логином '{}'.", name, login);
        JSONObject json = new JSONObject ();
        if (sameLoginExists ()) {
            json.put (JSON.KEY_RESULT, JSON.VAL_SAME_LOGIN_EXISTS);
            return json.toString ();
        }
        int newUserId = create ();
        json.put (JSON.KEY_RESULT, JSON.VAL_SUCCESS);
        json.put (JSON.KEY_ID, newUserId);
        return json.toString ();
    } catch (Exception e) {
        log.warn ("Ошибка при создании нового пользователя.", e);
        return Utils.wrapExceptionIntoJson (e);
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=392=-----==

public String getJsonResponse () {
    try {
        log.debug ("Создание нового пользователя с именем '{}' и логином '{}'.", name, login);
        JSONObject json = new JSONObject ();
        if (sameLoginExists ()) {
            json.put (JSON.KEY_RESULT, JSON.VAL_SAME_LOGIN_EXISTS);
            return json.toString ();
        }
        int newUserId = create ();
        json.put (JSON.KEY_RESULT, JSON.VAL_SUCCESS);
        json.put (JSON.KEY_ID, newUserId);
        return json.toString ();
    } catch (Exception e) {
        log.warn ("Ошибка при создании нового пользователя.", e);
        return Utils.wrapExceptionIntoJson (e);
    }
}


public synchronized String dump () throws UserDBException, SQLException {
    StringBuffer ret = new StringBuffer ();
    ret.append ("USERS:\tNAME\tCOMPLAINERS\tVOUCHERS\tREPUTATION\n");
    rs = dumpUsersPS.executeQuery ();
    while (rs.next ()) {
        ret.append ("\t" + rs.getString ("name") + "\t\t\t\t\t");
        ret.append (rs.getInt ("reputation") + "\n");
        ret.append ("\t\t" + rs.getString ("complainers") + "\n");
        ret.append ("\t\t\t\t" + rs.getString ("vouchers") + "\n");
    }
    ret.append ("IPs:\tNAME\tEXPERIENCE\tnComplaints\tnVouches\n");
    rs = dumpInputProvidersPS.executeQuery ();
    while (rs.next ()) {
        ret.append ("\t" + rs.getString ("name") + "\t" + rs.getInt ("experience") + "\t" + "\t" + rs.getInt ("ncomplaints") + "\t" + "\t" + rs.getInt ("nvouches") + "\n");
    }
    ret.append ("REGs:\tNAME\tNOSPAM\n");
    rs = dumpRegisteredUsersPS.executeQuery ();
    while (rs.next ()) {
        ret.append ("\t" + rs.getString ("name") + "\t" + rs.getString ("nospam") + "\n");
    }
    return ret.toString ();
}


-----Function Pair=393=-----==

public void delete (DeleteInterceptorChain chain, DistinguishedName dn, LDAPConstraints constraints) throws LDAPException {
    Connection con = (Connection) chain.getRequest ().get (JdbcInsert.MYVD_DB_CON + this.dbInsertName);
    if (con == null) {
        throw new LDAPException ("Operations Error", LDAPException.OPERATIONS_ERROR, "No Database Connection");
    }
    try {
        con.setAutoCommit (false);
        String uid = ((RDN) dn.getDN ().getRDNs ().get (0)).getValue ();
        PreparedStatement ps = con.prepareStatement (this.deleteSQL);
        ps.setString (1, uid);
        ps.executeUpdate ();
        con.commit ();
    } catch (SQLException e) {
        try {
            con.rollback ();
        } catch (SQLException e1) {
            throw new LDAPException ("Could not delete entry or rollback transaction", LDAPException.OPERATIONS_ERROR, e.toString (), e);
        }
        throw new LDAPException ("Could not delete entry", LDAPException.OPERATIONS_ERROR, e.toString (), e);
    }
}


public static String GetPassword (String C_UNAME) {
    String passwd = null;
    Connection con = null;
    try {
        con = getConnection ();
        PreparedStatement get_passwd = con.prepareStatement ("SELECT c_passwd FROM customer WHERE c_uname = ?");
        get_passwd.setString (1, C_UNAME);
        ResultSet rs = get_passwd.executeQuery ();
        rs.next ();
        passwd = rs.getString ("c_passwd");
        rs.close ();
        get_passwd.close ();
        con.commit ();
        returnConnection (con);
    } catch (java.lang.Exception ex) {
        try {
            ex.printStackTrace ();
        } catch (Exception se) {
            System.err.println ("Transaction rollback failed.");
        }
    }
    return passwd;
}


-----Function Pair=394=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoScoreExercises1 coScoreExercises1) {
    String sUserName = null;
    try {
        sUserName = coScoreExercises1.getMaUser ().getUserName ();
        log.error ("Eliminando la calificaci�n del estudiante: " + sUserName);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_SCORE_EXERCISE1);
        query.setParameter (1, coScoreExercises1.getCoExercises1 ().getExerciseId ());
        query.setParameter (2, coScoreExercises1.getMaUser ().getUserId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coScoreExercises1);
        Object [] arrayParam = {sUserName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.delete.success"), arrayParam));
        log.info ("Eliminando la calificaci�n para el estudiante: " + sUserName);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la calificaci�n: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coScoreExercises1.getMaUser ().getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


void BactTar_actionPerformed (ActionEvent e) {
    int nUpd;
    double prTar = 0;
    try {
        for (int n = 0; n < jt.getRowCount (); n ++) {
            if (jt.getValString (n, 8, true).equals ("")) continue;
            try {
                prTar = Double.parseDouble (jt.getValString (n, 8));
            } catch (Exception k1) {
                continue;
            }
            String s = "update  ven_angulo_iber set ran_prcom = " + prTar + " where" + " ran_numalb = " + jt.getValorInt (n, "Num.Alb") + " and ran_fecalb = '" + Formatear.getFechaDB (jt.getValString (n, "Fec.Albaran")) + "'" + " and cli_codi = " + jt.getValorInt (n, "Cliente") + " and pro_codi = " + jt.getValorInt (n, "Producto") + " and ran_kilven = " + jt.getValString (n, "K.Venta") + " and ran_prven = " + jt.getValString (n, "Pr.Venta") + " and ran_prcom IS null ";
            nUpd = st.executeUpdate (s);
            if (nUpd != 1) throw new Exception ("NO encontrado Registro: (" + nUpd + ")+\n" + s);
        }
        ct.commit ();
        mensajeErr ("Datos Modificados...");
        BactTar.setEnabled (false);
    } catch (Exception ex) {
        fatalError ("Error al  Actualizar tarifa" + ex, ex);
    }
}


-----Function Pair=395=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private int execute (Statement s, String command, boolean expectRs) throws SQLException {
    boolean hasResultSet = s.execute (command);
    int count = 0;
    while (hasResultSet || count >= 0) {
        if (hasResultSet) {
            ResultSet rs = s.getResultSet ();
            if (expectRs) {
                if (rs.next ()) {
                    count = rs.getInt ("a");
                }
                else {
                    count = - 1;
                }
            }
            else {
                logger.warn ("Unexpected result set for: '" + command + "'");
            }
            rs.close ();
            break;
        }
        else {
            count = s.getUpdateCount ();
            return count;
        }
    }
    return count;
}


-----Function Pair=396=-----==

private List < AuthInfo > getAuthInfoMySql (DatabaseAdapter db_, Long userId, Long siteId) {
    List < AuthInfo > list = new ArrayList < AuthInfo > ();
    if (userId == null || siteId == null) {
        return list;
    }
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        String sql = "select  a01.id_auth_user " + "from    WM_AUTH_USER a01, WM_PORTAL_LIST_SITE f01 " + "where   a01.is_use_current_firm = 1 and a01.ID_FIRM = f01.ID_FIRM and f01.ID_SITE=? and " + "        a01.id_user=? " + "union " + "select  a02.id_auth_user " + "from    WM_AUTH_USER a02, WM_LIST_R_HOLDING_COMPANY d02, WM_PORTAL_LIST_SITE f02 " + "where   a02.IS_HOLDING = 1 and a02.ID_HOLDING = d02.ID_HOLDING and " + "        d02.ID_COMPANY = f02.ID_FIRM and f02.ID_SITE=? and a02.id_user=? " + "union " + "select  a04.id_auth_user " + "from    WM_AUTH_USER a04, WM_LIST_COMPANY b04, WM_PORTAL_LIST_SITE f04 " + "where   a04.is_root = 1 and b04.ID_FIRM = f04.ID_FIRM and f04.ID_SITE=? and " + "        a04.id_user=? ";
        ps = db_.prepareStatement (sql);
        ps.setLong (1, siteId);
        ps.setLong (2, userId);
        ps.setLong (3, siteId);
        ps.setLong (4, userId);
        ps.setLong (5, siteId);
        ps.setLong (6, userId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            list.add (getAuthInfo (db_, RsetTools.getLong (rs, "id_auth_user")));
        }
        return list;
    } catch (Throwable e) {
        String es = "AuthInfo.getInstance() exception";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


public List < String [] > findResource (String sql, String [] key, String...returnedRows) throws XregistryException {
    Connection connection = globalContext.createConnection ();
    PreparedStatement statement = null;
    ResultSet results = null;
    try {
        statement = connection.prepareStatement (sql);
        statement.setString (1, "%" + key [0] + "%");
        statement.setString (2, "%" + key [1] + "%");
        if (key.length >= 3) {
            statement.setString (3, key [2]);
        }
        if (key.length == 4) {
            statement.setString (4, key [3]);
        }
        log.info ("Execuate SQL " + statement);
        results = statement.executeQuery ();
        List < String [] > list = new ArrayList < String [] > ();
        while (results.next ()) {
            String [] returnValues = new String [returnedRows.length];
            for (int i = 0; i < returnedRows.length; i ++) {
                String rawName = returnedRows [i];
                returnValues [i] = results.getString (rawName);
            }
            list.add (returnValues);
        }
        return list;
    } catch (SQLException e) {
        throw new XregistryException (e);
    } finally {
        try {
            results.close ();
            statement.close ();
            globalContext.closeConnection (connection);
        } catch (SQLException e) {
            throw new XregistryException (e);
        }
    }
}


-----Function Pair=397=-----==

public List getTransactions (User u, Date dt, int status) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Transaction R where R.initiatorId=? and R.txDate <= ? and R.txStatus=? order by R.txDate desc";
        Query q = s.createQuery (query);
        q.setLong (0, u.getUid ());
        q.setTimestamp (1, dt);
        q.setInteger (2, status);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public void ChangePassword (String oldpass, String newpass) throws NpsException {
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        conn = Database.GetDatabase ("nps").GetConnection ();
        String sql = "select password from users where id=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (! rs.next ()) throw new NpsException ("û���ҵ�" + name + "���û���Ϣ", ErrorHelper.SYS_NOUSER);
        String dbpass = rs.getString ("password");
        if (oldpass != null && dbpass != null) {
            if (! oldpass.equals (dbpass)) throw new NpsException ("ԭ���벻��ȷ", ErrorHelper.SYS_PASSWORD_ERROR);
        }
        else if ((oldpass != null && dbpass == null) || (oldpass == null && dbpass != null)) {
            throw new NpsException ("ԭ���벻��ȷ", ErrorHelper.SYS_PASSWORD_ERROR);
        }
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e2) {
        }
        ChangePassword (conn, id, newpass);
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=398=-----==

public static double getCurrentBalance (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.currentBalance from Account R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        double aname = (Double) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


private void criarQuestaoMultiplaEscolha (QuestaoMultiplaEscolha q) throws SQLException {
    PreparedStatement stmt = null;
    String sql = "INSERT INTO multipla_escolha (id_questao, texto, gabarito) VALUES (?,?,?)";
    try {
        for (Alternativa alternativa : q.getAlternativa ()) {
            stmt = conexao.prepareStatement (sql);
            stmt.setInt (1, q.getIdQuestao ());
            stmt.setString (2, alternativa.getTexto ());
            stmt.setBoolean (3, alternativa.getGabarito ());
            stmt.executeUpdate ();
            conexao.commit ();
        }
    } catch (SQLException e) {
        conexao.rollback ();
        throw e;
    }
}


-----Function Pair=399=-----==

public Long checkHoldingId (Long holdingId, String userLogin) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    DatabaseAdapter db = null;
    try {
        db = DatabaseAdapter.getInstance ();
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                ps = db.prepareStatement ("select ID_HOLDING from WM_LIST_HOLDING " + "where ID_HOLDING in (" + getGrantedHoldingId (db, userLogin) + ") and ID_HOLDING=?");
                ps.setObject (1, holdingId);
                break;
            default :
                ps = db.prepareStatement ("select ID_HOLDING from v$_read_list_road where USER_LOGIN = ? and ID_ROAD=?");
                ps.setString (1, userLogin);
                ps.setObject (2, holdingId);
                break;
        }
        rs = ps.executeQuery ();
        if (rs.next ()) return RsetTools.getLong (rs, "ID_HOLDING");
        return null;
    } catch (Exception e) {
        final String es = "Error check holding id";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


public static void main (String [] args) {
    if (args.length <= 0) {
        System.out.println (" *** SQL script generator and executor ***");
        System.out.println (" You must specify name of the file with SQL script data");
        System.out.println (" Fisrt rows of this file must be:");
        System.out.println (" 1) JDBC driver class for your DBMS");
        System.out.println (" 2) URL for your database instance");
        System.out.println (" 3) user in that database (with administrator priviliges)");
        System.out.println (" 4) password of that user");
        System.out.println (" Next rows can have: '@' before schema to create,");
        System.out.println ("   '#' before table to create, '&' before table to insert,");
        System.out.println ("   '$' before trigger (inverse 'FK on delete cascade') to create,");
        System.out.println ("   '>' before table to drop, '<' before schema to drop.");
        System.out.println (" Other rows contain parameters of these actions:");
        System.out.println ("   for & action each parameter is a list of values,");
        System.out.println ("   for @ -//- is # acrion, for # -//- is column/constraint ");
        System.out.println ("    definition or $ action. $ syntax to delete from table:");
        System.out.println ("    fullNameOfTable:itsColInWhereClause=matchingColOfThisTable");
        System.out.println (" '!' before row means that it is a comment.");
        System.out.println (" If some exception is occured, all script is rolled back.");
        System.out.println (" If you specify 2nd command line argument - file name too -");
        System.out.println ("   connection will be established but all statements will");
        System.out.println ("   be saved in that output file and not transmitted to DB");
        System.out.println (" If you specify 3nd command line argument - connect_string -");
        System.out.println ("   connect information will be added to output file");
        System.out.println ("   in the form 'connect user/password@connect_string'");
        System.exit (0);
    }
    try {
        String [] info = new String [4];
        BufferedReader reader = new BufferedReader (new FileReader (new File (args [0])));
        Writer writer = null;
        try {
            for (int i = 0; i < 4; i ++) info [i] = reader.readLine ();
            try {
                Class.forName (info [0]);
                Connection connection = DriverManager.getConnection (info [1], info [2], info [3]);
                SQLScript script = new SQLScript (connection);
                if (args.length > 1) {
                    writer = new FileWriter (args [1]);
                    if (args.length > 2) writer.write ("connect " + info [2] + "/" + info [3] + "@" + args [2] + script.statementTerminator);
                }
                try {
                    System.out.println (script.executeScript (reader, writer) + " updates has been performed during script execution");
                } catch (SQLException e4) {
                    reader.close ();
                    if (writer != null) writer.close ();
                    System.out.println (" Script execution error: " + e4);
                }
                connection.close ();
            } catch (Exception e3) {
                reader.close ();
                if (writer != null) writer.close ();
                System.out.println (" Connection error: " + e3);
            }
        } catch (IOException e2) {
            System.out.println ("Error in file " + args [0]);
        }
    } catch (FileNotFoundException e1) {
        System.out.println ("File " + args [0] + " not found");
    }
}


-----Function Pair=400=-----==

public void testTransactions0010 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0010 " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    con.setAutoCommit (false);
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0010 values (?, ?)");
    int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pstmt.setInt (1, i);
        pstmt.setString (2, theString.substring (0, i));
        count += pstmt.executeUpdate ();
    }
    assertEquals (count, rowsToAdd);
    con.rollback ();
    ResultSet rs = stmt.executeQuery ("select s, i from #t0010");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
        assertEquals (rs.getString (1).trim ().length (), rs.getInt (2));
    }
    assertEquals (count, 0);
    rowsToAdd = 6;
    for (int j = 1; j <= 2; j ++) {
        count = 0;
        for (int i = 1; i <= rowsToAdd; i ++) {
            pstmt.setInt (1, i + ((j - 1) * rowsToAdd));
            pstmt.setString (2, theString.substring (0, i));
            count += pstmt.executeUpdate ();
        }
        assertEquals (count, rowsToAdd);
        con.commit ();
    }
    rs = stmt.executeQuery ("select s, i from #t0010");
    count = 0;
    while (rs.next ()) {
        count ++;
        int i = rs.getInt (2);
        if (i > rowsToAdd) {
            i -= rowsToAdd;
        }
        assertEquals (rs.getString (1).trim ().length (), i);
    }
    assertEquals (count, (2 * rowsToAdd));
    stmt.close ();
    pstmt.close ();
    con.setAutoCommit (true);
}


public List < Holding > getHoldingList (AuthSession authSession) {
    if (authSession == null) {
        return null;
    }
    DatabaseAdapter db = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        db = DatabaseAdapter.getInstance ();
        String sql = "select ID_HOLDING, full_name_HOLDING, NAME_HOLDING " + "from 	WM_LIST_HOLDING " + "where  ID_HOLDING in ";
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                String idList = authSession.getGrantedHoldingId ();
                sql += " (" + idList + ") ";
                break;
            default :
                sql += "(select z1.ID_ROAD from v$_read_list_road z1 where z1.user_login = ?)";
                break;
        }
        ps = db.prepareStatement (sql);
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                break;
            default :
                ps.setString (1, authSession.getUserLogin ());
                break;
        }
        rs = ps.executeQuery ();
        List < Holding > list = new ArrayList < Holding > ();
        while (rs.next ()) {
            HoldingBean holding = loadHoldingFromResultSet (rs);
            holding.setCompanyIdList (getCompanyIdList (db, holding.getId (), authSession));
            list.add (holding);
        }
        return list;
    } catch (Exception e) {
        String es = "Error load holding list for userLogin: " + authSession.getUserLogin ();
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


