Found 27/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public void actionPerformed (ActionEvent arg0) {
    Vector < Integer > v = new Vector < Integer > ();
    int dim = 0;
    Vector < Integer > validCols = new Vector < Integer > ();
    validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Double.class));
    validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Integer.class));
    Collections.sort (validCols);
    for (Integer in : vp.getSelectedIndices ()) {
        if (in > 0) dim ++;
        in --;
        v.add (validCols.get (in));
    }
    System.out.println ("v :");
    for (Integer vint : v) {
        System.out.print (vint + " ");
    }
    if (dim == 0) {
        JOptionPane.showMessageDialog (null, "Select at least one Variable please.");
    }
    else if (dim == 1) {
        scatter2D.clearPlot ();
        scatter2D.resetLegendEntries ();
        System.out.println ("1Dim : v.get(1) = " + v.get (1));
        scatter2D.setDataSource (scatter2D.getDataSource (), v.get (1));
        scatter2D.repaint ();
    }
    else if (dim == 2) {
        scatter2D.clearPlot ();
        scatter2D.resetLegendEntries ();
        System.out.println ("2Dim : v.get(0) = " + v.get (0) + "v.get(1) = " + v.get (1));
        scatter2D.setDataSource (scatter2D.getDataSource (), v.get (0), v.get (1));
        scatter2D.repaint ();
    }
}


protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    mindmap.Map model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, MapEditPart.MODEL_ID, MindmapDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (mindmap.diagram.part.MindmapDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (mindmap.diagram.part.MindmapDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        MindmapDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


-----Function Pair=2=-----==

public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


protected void doGotoMarker (IMarker marker) {
    String elementId = marker.getAttribute (org.eclipse.gmf.runtime.common.core.resources.IMarker.ELEMENT_ID, null);
    if (elementId == null || ! (getEditor () instanceof DiagramEditor)) {
        return;
    }
    DiagramEditor editor = (DiagramEditor) getEditor ();
    Map editPartRegistry = editor.getDiagramGraphicalViewer ().getEditPartRegistry ();
    EObject targetView = editor.getDiagram ().eResource ().getEObject (elementId);
    if (targetView == null) {
        return;
    }
    EditPart targetEditPart = (EditPart) editPartRegistry.get (targetView);
    if (targetEditPart != null) {
        OwlsDiagramEditorUtil.selectElementsInDiagram (editor, Arrays.asList (new EditPart [] {targetEditPart}));
    }
}


-----Function Pair=3=-----==

public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


-----Function Pair=4=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=5=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineAbstractNavigatorItem) {
        return;
    }
    de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineAbstractNavigatorItem abstractNavigatorItem = (de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorItem) {
        navigatorView = ((de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorGroup) {
        de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorGroup navigatorGroup = (de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorItem) {
            navigatorView = ((de.nordakademie.lejos.stateMachine.diagram.navigator.StateMachineNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=6=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof DrlModelAbstractNavigatorItem) {
        return;
    }
    DrlModelAbstractNavigatorItem abstractNavigatorItem = (DrlModelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof DrlModelNavigatorItem) {
        navigatorView = ((DrlModelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof DrlModelNavigatorGroup) {
        DrlModelNavigatorGroup navigatorGroup = (DrlModelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof DrlModelNavigatorItem) {
            navigatorView = ((DrlModelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=7=-----==

public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


-----Function Pair=8=-----==

protected float [] getExatProbTargetGivenEvidence () throws EvaluationException {
    TreeVariable targetNode = targetNodeList [0];
    try {
        net.compile ();
    } catch (Exception e) {
        throw new EvaluationException (e.getMessage ());
    }
    float [] postProbList = new float [statesProduct];
    int sProd = targetNode.getStatesSize ();
    byte [] [] stateCombinationMatrix = new byte [statesProduct] [1 + evidenceNodeList.length];
    int state = 0;
    for (int row = 0; row < statesProduct; row ++) {
        stateCombinationMatrix [row] [0] = (byte) (row / (statesProduct / sProd));
        for (int j = 0; j < evidenceNodeList.length; j ++) {
            sProd *= evidenceNodeList [j].getStatesSize ();
            state = (row / (statesProduct / sProd)) % evidenceNodeList [j].getStatesSize ();
            evidenceNodeList [j].addFinding (state);
            stateCombinationMatrix [row] [j + 1] = (byte) state;
        }
        sProd = targetNode.getStatesSize ();
        try {
            net.updateEvidences ();
            postProbList [row] = targetNode.getMarginalAt (stateCombinationMatrix [row] [0]);
        } catch (Exception e) {
            postProbList [row] = 0;
        }
        try {
            net.compile ();
        } catch (Exception e) {
            throw new EvaluationException (e.getMessage ());
        }
    }
    return postProbList;
}


public HashMap getOccurrenceTypes () {
    Collection occurstypes;
    HashMap retur = new HashMap ();
    occurDetails = new HashMap ();
    ClassInstanceIndexIF tindex = (ClassInstanceIndexIF) tm.getIndex ("net.ontopia.topicmaps.core.index.ClassInstanceIndexIF");
    occurstypes = tindex.getOccurrenceTypes ();
    Iterator ito = occurstypes.iterator ();
    while (ito.hasNext ()) {
        TopicIF t_temp = (TopicIF) ito.next ();
        Collection c_temp = tindex.getOccurrences (t_temp);
        if (! c_temp.isEmpty () && t_temp != null) {
            retur.put (ts.toString (t_temp), new Integer (c_temp.size ()));
            occurDetails.put (ts.toString (t_temp), t_temp);
        }
    }
    return retur;
}


-----Function Pair=9=-----==

private void ordenaPorNdGrupos (boolean inverso) {
    if (inverso) {
        for (int x = materias.length - 2; x >= 0; x --) for (int y = x; y <= materias.length - 2; y ++) {
            if (materias [y].length < materias [y + 1].length) {
                Grupo tmp [] = materias [y];
                materias [y] = materias [y + 1];
                materias [y + 1] = tmp;
            }
            else break;
        }
    }
    else {
        for (int x = materias.length - 2; x >= 0; x --) for (int y = x; y <= materias.length - 2; y ++) {
            if (materias [y].length > materias [y + 1].length) {
                Grupo tmp [] = materias [y];
                materias [y] = materias [y + 1];
                materias [y + 1] = tmp;
            }
            else break;
        }
    }
}


protected synchronized int findIndex (int virtualIndex) {
    int low = 0;
    int high = realSize - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (indices [mid] > virtualIndex) {
            high = mid - 1;
        }
        else if (indices [mid] < virtualIndex) {
            low = mid + 1;
        }
        else {
            return mid;
        }
    }
    throw new AssertionError ("Addressing error! (could not find proper index)");
}


-----Function Pair=10=-----==

public boolean processCommand (String [] cmdArgs, ORB orb, PrintStream out) {
    int serverId = illegalServerId;
    String endPointType = IIOP_CLEAR_TEXT.value;
    try {
        String arg;
        int i = 0;
        while (i < cmdArgs.length) {
            arg = cmdArgs [i ++];
            if (arg.equals ("-serverid")) {
                if (i < cmdArgs.length) serverId = (Integer.valueOf (cmdArgs [i ++])).intValue ();
                else return parseError;
            }
            else if (arg.equals ("-applicationName")) {
                if (i < cmdArgs.length) serverId = ServerTool.getServerIdForAlias (orb, cmdArgs [i ++]);
                else return parseError;
            }
            else if (arg.equals ("-endpointType")) {
                if (i < cmdArgs.length) endPointType = cmdArgs [i ++];
            }
        }
        if (serverId == illegalServerId) return parseError;
        Locator locator = LocatorHelper.narrow (orb.resolve_initial_references (ORBConstants.SERVER_LOCATOR_NAME));
        ServerLocation location = locator.locateServer (serverId, endPointType);
        out.println (CorbaResourceUtil.getText ("servertool.locate2", location.hostname));
        int numEntries = location.ports.length;
        for (i = 0; i < numEntries; i ++) {
            ORBPortInfo orbPort = location.ports [i];
            out.println ("\t\t" + orbPort.port + "\t\t" + endPointType + "\t\t" + orbPort.orbId);
        }
    } catch (NoSuchEndPoint ex) {
    } catch (ServerHeldDown ex) {
        out.println (CorbaResourceUtil.getText ("servertool.helddown"));
    } catch (ServerNotRegistered ex) {
        out.println (CorbaResourceUtil.getText ("servertool.nosuchserver"));
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return commandDone;
}


public void paintComponent (Graphics g) {
    Dimension dim = getSize ();
    g.setColor (Color.WHITE);
    g.fillRect (0, 0, dim.width - 1, dim.height - 1);
    g.setColor (Color.BLACK);
    g.drawRect (0, 0, dim.width - 1, dim.height - 1);
    if (image != null) {
        int max = 0;
        for (int v : histoData) {
            if (v > max) max = v;
        }
        float dx = (float) (dim.width - 2 * BORDER) / 256;
        float dy = (float) (dim.height - 2 * BORDER) / max;
        int barWidth = (int) dx < 1 ? 1 : (int) dx;
        g.setColor (Color.GRAY);
        for (int i = 0; i < 256; i ++) {
            int x = (int) (i * dx);
            int barHeight = (int) (histoData [i] * dy);
            g.fillRect (x + BORDER, dim.height - barHeight - BORDER, barWidth, barHeight);
        }
    }
    if (curve == null) return;
    g.setColor (Color.BLUE);
    for (int p = 0; p < curve.length; p ++) {
        g.drawRect (curve [p].x - 1, curve [p].y - 1, 2, 2);
    }
    for (int p = 0; p < curve.length - 1; p ++) {
        g.drawLine (curve [p].x, curve [p].y, curve [p + 1].x, curve [p + 1].y);
    }
}


-----Function Pair=11=-----==

private Geometry createGeometry (Orbitals orbitals, int index, int parts, double x1, double x2, double y1, double y2, double z1, double z2) {
    double wx, wy, wz, tx, ty, tz;
    double dx = (x2 - x1);
    double dy = (y2 - y1);
    double dz = (z2 - z1);
    long start = System.currentTimeMillis ();
    long mem = Runtime.getRuntime ().freeMemory ();
    double value, length;
    double h = 1E-4;
    Matrix m = new Matrix (3, (parts + 1) * (parts + 1) * (parts + 1));
    int j = 0;
    for (int x = 0; x <= parts; x ++) for (int y = 0; y <= parts; y ++) for (int z = 0; z <= parts; z ++) {
        tx = ((double) x / (double) parts);
        ty = ((double) y / (double) parts);
        tz = ((double) z / (double) parts);
        px [x] [y] [z] = m.matrix [0] [j] = tx * dx + x1;
        py [x] [y] [z] = m.matrix [1] [j] = ty * dy + y1;
        pz [x] [y] [z] = m.matrix [2] [j] = tz * dz + z1;
    }
    start = System.currentTimeMillis () - start;
    System.out.println ("0.Zeit:" + start + " ms");
    start = System.currentTimeMillis ();
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    mem = Runtime.getRuntime ().freeMemory ();
    start = System.currentTimeMillis () - start;
    System.out.println ("1.Zeit:" + start + " ms");
    start = System.currentTimeMillis ();
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    mem = Runtime.getRuntime ().freeMemory ();
    j = 0;
    for (int x = 0; x <= parts; x ++) for (int y = 0; y <= parts; y ++) for (int z = 0; z <= parts; z ++) {
        values [x] [y] [z] = orbitals.getValue (index, px [x] [y] [z], py [x] [y] [z], pz [x] [y] [z]);
        if (Double.isNaN (values [x] [y] [z])) values [x] [y] [z] = 0d;
        j ++;
    }
    start = System.currentTimeMillis () - start;
    System.out.println ("2.Zeit:" + start + " ms");
    start = System.currentTimeMillis ();
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    mem = Runtime.getRuntime ().freeMemory ();
    dx /= parts;
    dy /= parts;
    dz /= parts;
    for (int x = 0; x <= parts; x ++) for (int y = 0; y <= parts; y ++) for (int z = 0; z <= parts; z ++) {
        if (x < parts) {
            if (x > 0) gx [x] [y] [z] = (values [x + 1] [y] [z] - values [x - 1] [y] [z]) / (2 * dx);
            else gx [x] [y] [z] = (values [x + 1] [y] [z] - values [x] [y] [z]) / dx;
        }
        else gx [x] [y] [z] = (values [x] [y] [z] - values [x - 1] [y] [z]) / dx;
        if (y < parts) {
            if (y > 0) gy [x] [y] [z] = (values [x] [y + 1] [z] - values [x] [y - 1] [z]) / (2 * dy);
            else gy [x] [y] [z] = (values [x] [y + 1] [z] - values [x] [y] [z]) / dy;
        }
        else gy [x] [y] [z] = (values [x] [y] [z] - values [x] [y - 1] [z]) / dy;
        if (z < parts) {
            if (z > 0) gz [x] [y] [z] = (values [x] [y] [z + 1] - values [x] [y] [z - 1]) / (2 * dz);
            else gz [x] [y] [z] = (values [x] [y] [z + 1] - values [x] [y] [z]) / dz;
        }
        else gz [x] [y] [z] = (values [x] [y] [z] - values [x] [y] [z - 1]) / dz;
        length = Math.sqrt (gx [x] [y] [z] * gx [x] [y] [z] + gy [x] [y] [z] * gy [x] [y] [z] + gz [x] [y] [z] * gz [x] [y] [z]);
        gx [x] [y] [z] /= length;
        gy [x] [y] [z] /= length;
        gz [x] [y] [z] /= length;
    }
    start = System.currentTimeMillis () - start;
    System.out.println ("3.Zeit:" + start + " ms");
    start = System.currentTimeMillis ();
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    mem = Runtime.getRuntime ().freeMemory ();
    Vector triangles = new Vector ();
    GridCell gridCell = new GridCell ();
    for (int x = 0; x < parts; x ++) for (int y = 0; y < parts; y ++) for (int z = 0; z < parts; z ++) {
        gridCell.px [0] = px [x] [y] [z];
        gridCell.px [1] = px [x + 1] [y] [z];
        gridCell.px [2] = px [x + 1] [y] [z + 1];
        gridCell.px [3] = px [x] [y] [z + 1];
        gridCell.px [4] = px [x] [y + 1] [z];
        gridCell.px [5] = px [x + 1] [y + 1] [z];
        gridCell.px [6] = px [x + 1] [y + 1] [z + 1];
        gridCell.px [7] = px [x] [y + 1] [z + 1];
        gridCell.py [0] = py [x] [y] [z];
        gridCell.py [1] = py [x + 1] [y] [z];
        gridCell.py [2] = py [x + 1] [y] [z + 1];
        gridCell.py [3] = py [x] [y] [z + 1];
        gridCell.py [4] = py [x] [y + 1] [z];
        gridCell.py [5] = py [x + 1] [y + 1] [z];
        gridCell.py [6] = py [x + 1] [y + 1] [z + 1];
        gridCell.py [7] = py [x] [y + 1] [z + 1];
        gridCell.pz [0] = pz [x] [y] [z];
        gridCell.pz [1] = pz [x + 1] [y] [z];
        gridCell.pz [2] = pz [x + 1] [y] [z + 1];
        gridCell.pz [3] = pz [x] [y] [z + 1];
        gridCell.pz [4] = pz [x] [y + 1] [z];
        gridCell.pz [5] = pz [x + 1] [y + 1] [z];
        gridCell.pz [6] = pz [x + 1] [y + 1] [z + 1];
        gridCell.pz [7] = pz [x] [y + 1] [z + 1];
        gridCell.values [0] = values [x] [y] [z];
        gridCell.values [1] = values [x + 1] [y] [z];
        gridCell.values [2] = values [x + 1] [y] [z + 1];
        gridCell.values [3] = values [x] [y] [z + 1];
        gridCell.values [4] = values [x] [y + 1] [z];
        gridCell.values [5] = values [x + 1] [y + 1] [z];
        gridCell.values [6] = values [x + 1] [y + 1] [z + 1];
        gridCell.values [7] = values [x] [y + 1] [z + 1];
        gridCell.gx [0] = gx [x] [y] [z];
        gridCell.gx [1] = gx [x + 1] [y] [z];
        gridCell.gx [2] = gx [x + 1] [y] [z + 1];
        gridCell.gx [3] = gx [x] [y] [z + 1];
        gridCell.gx [4] = gx [x] [y + 1] [z];
        gridCell.gx [5] = gx [x + 1] [y + 1] [z];
        gridCell.gx [6] = gx [x + 1] [y + 1] [z + 1];
        gridCell.gx [7] = gx [x] [y + 1] [z + 1];
        gridCell.gy [0] = gy [x] [y] [z];
        gridCell.gy [1] = gy [x + 1] [y] [z];
        gridCell.gy [2] = gy [x + 1] [y] [z + 1];
        gridCell.gy [3] = gy [x] [y] [z + 1];
        gridCell.gy [4] = gy [x] [y + 1] [z];
        gridCell.gy [5] = gy [x + 1] [y + 1] [z];
        gridCell.gy [6] = gy [x + 1] [y + 1] [z + 1];
        gridCell.gy [7] = gy [x] [y + 1] [z + 1];
        gridCell.gz [0] = gz [x] [y] [z];
        gridCell.gz [1] = gz [x + 1] [y] [z];
        gridCell.gz [2] = gz [x + 1] [y] [z + 1];
        gridCell.gz [3] = gz [x] [y] [z + 1];
        gridCell.gz [4] = gz [x] [y + 1] [z];
        gridCell.gz [5] = gz [x + 1] [y + 1] [z];
        gridCell.gz [6] = gz [x + 1] [y + 1] [z + 1];
        gridCell.gz [7] = gz [x] [y + 1] [z + 1];
        polygonise (gridCell, isolevel, triangles);
        polygonise (gridCell, - isolevel, triangles);
    }
    start = System.currentTimeMillis () - start;
    System.out.println ("4.Zeit:" + start + " ms");
    start = System.currentTimeMillis ();
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    mem = Runtime.getRuntime ().freeMemory ();
    System.out.println ("Count of triangles:" + triangles.size ());
    TriangleArray trisArray;
    if (triangles.size () == 0) return null;
    trisArray = new TriangleArray (triangles.size () * 3, TriangleArray.COORDINATES | TriangleArray.NORMALS | TriangleArray.COLOR_3);
    Triangle3D t;
    for (int i = 0; i < triangles.size (); i ++) {
        t = (Triangle3D) triangles.elementAt (i);
        trisArray.setCoordinates (i * 3, t.getPoints ());
        trisArray.setColors (i * 3, t.getColors ());
        trisArray.setNormals (i * 3, t.getNormals ());
    }
    start = System.currentTimeMillis () - start;
    System.out.println ("5.Zeit:" + start + " ms");
    System.out.println ("Memory = " + (mem - Runtime.getRuntime ().freeMemory ()));
    System.out.println ();
    return trisArray;
}


public synchronized void decodeT6 (byte [] buffer, byte [] compData, int startX, int height, long tiffT6Options) {
    this.data = compData;
    compression = 4;
    bitPointer = 0;
    bytePointer = 0;
    int scanlineStride = (w + 7) / 8;
    int a0, a1, b1, b2;
    int entry, code, bits;
    boolean isWhite;
    int currIndex;
    int temp [];
    int [] b = new int [2];
    uncompressedMode = (int) ((tiffT6Options & 0x02)>> 1);
    int [] cce = currChangingElems;
    changingElemSize = 0;
    cce [changingElemSize ++] = w;
    cce [changingElemSize ++] = w;
    int lineOffset = 0;
    int bitOffset;
    for (int lines = 0; lines < height; lines ++) {
        a0 = - 1;
        isWhite = true;
        temp = prevChangingElems;
        prevChangingElems = currChangingElems;
        cce = currChangingElems = temp;
        currIndex = 0;
        bitOffset = startX;
        lastChangingElement = 0;
        while (bitOffset < w) {
            getNextChangingElement (a0, isWhite, b);
            b1 = b [0];
            b2 = b [1];
            entry = nextLesserThan8Bits (7);
            entry = (int) (twoDCodes [entry] & 0xff);
            code = (entry & 0x78)>>> 3;
            bits = entry & 0x07;
            if (code == 0) {
                if (! isWhite) {
                    setToBlack (buffer, lineOffset, bitOffset, b2 - bitOffset);
                }
                bitOffset = a0 = b2;
                updatePointer (7 - bits);
            }
            else if (code == 1) {
                updatePointer (7 - bits);
                int number;
                if (isWhite) {
                    number = decodeWhiteCodeWord ();
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                    number = decodeBlackCodeWord ();
                    setToBlack (buffer, lineOffset, bitOffset, number);
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                }
                else {
                    number = decodeBlackCodeWord ();
                    setToBlack (buffer, lineOffset, bitOffset, number);
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                    number = decodeWhiteCodeWord ();
                    bitOffset += number;
                    cce [currIndex ++] = bitOffset;
                }
                a0 = bitOffset;
            }
            else if (code <= 8) {
                a1 = b1 + (code - 5);
                cce [currIndex ++] = a1;
                if (! isWhite) {
                    setToBlack (buffer, lineOffset, bitOffset, a1 - bitOffset);
                }
                bitOffset = a0 = a1;
                isWhite = ! isWhite;
                updatePointer (7 - bits);
            }
            else if (code == 11) {
                if (nextLesserThan8Bits (3) != 7) {
                    throw new Error ("TIFFFaxDecoder5");
                }
                int zeros = 0;
                boolean exit = false;
                while (! exit) {
                    while (nextLesserThan8Bits (1) != 1) {
                        zeros ++;
                    }
                    if (zeros > 5) {
                        zeros = zeros - 6;
                        if (! isWhite && (zeros > 0)) {
                            cce [currIndex ++] = bitOffset;
                        }
                        bitOffset += zeros;
                        if (zeros > 0) {
                            isWhite = true;
                        }
                        if (nextLesserThan8Bits (1) == 0) {
                            if (! isWhite) {
                                cce [currIndex ++] = bitOffset;
                            }
                            isWhite = true;
                        }
                        else {
                            if (isWhite) {
                                cce [currIndex ++] = bitOffset;
                            }
                            isWhite = false;
                        }
                        exit = true;
                    }
                    if (zeros == 5) {
                        if (! isWhite) {
                            cce [currIndex ++] = bitOffset;
                        }
                        bitOffset += zeros;
                        isWhite = true;
                    }
                    else {
                        bitOffset += zeros;
                        cce [currIndex ++] = bitOffset;
                        setToBlack (buffer, lineOffset, bitOffset, 1);
                        ++ bitOffset;
                        isWhite = false;
                    }
                }
            }
            else {
                throw new Error ("TIFFFaxDecoder5");
            }
        }
        cce [currIndex ++] = bitOffset;
        changingElemSize = currIndex;
        lineOffset += scanlineStride;
    }
}


-----Function Pair=12=-----==

protected String dfp2sci (Decimal a) {
    char [] rawdigits = new char [DIGITS * 4];
    char [] outputbuffer = new char [DIGITS * 4 + 20];
    int p;
    int q;
    int e;
    int ae;
    int shf;
    p = 0;
    for (int i = DIGITS - 1; i >= 0; i --) {
        rawdigits [p ++] = (char) ((a.mant [i] / 1000) + '0');
        rawdigits [p ++] = (char) (((a.mant [i] / 100) % 10) + '0');
        rawdigits [p ++] = (char) (((a.mant [i] / 10) % 10) + '0');
        rawdigits [p ++] = (char) (((a.mant [i]) % 10) + '0');
    }
    for (p = 0; p < rawdigits.length; p ++) {
        if (rawdigits [p] != '0') {
            break;
        }
    }
    shf = p;
    q = 0;
    if (a.sign == - 1) {
        outputbuffer [q ++] = '-';
    }
    if (p != rawdigits.length) {
        outputbuffer [q ++] = rawdigits [p ++];
        outputbuffer [q ++] = '.';
        while (p < rawdigits.length) {
            outputbuffer [q ++] = rawdigits [p ++];
        }
    }
    else {
        outputbuffer [q ++] = '0';
        outputbuffer [q ++] = '.';
        outputbuffer [q ++] = '0';
        outputbuffer [q ++] = 'e';
        outputbuffer [q ++] = '0';
        return new String (outputbuffer, 0, 5);
    }
    outputbuffer [q ++] = 'e';
    e = a.exp * 4 - shf - 1;
    ae = e;
    if (e < 0) {
        ae = - e;
    }
    for (p = 1000000000; p > ae; p /= 10) {
    }
    if (e < 0) {
        outputbuffer [q ++] = '-';
    }
    while (p > 0) {
        outputbuffer [q ++] = (char) (ae / p + '0');
        ae = ae % p;
        p = p / 10;
    }
    return new String (outputbuffer, 0, q);
}


private void getNextChangingElement (int a0, boolean isWhite, int [] ret) {
    int [] pce = this.prevChangingElems;
    int ces = this.changingElemSize;
    int start = lastChangingElement > 0 ? lastChangingElement - 1 : 0;
    if (isWhite) {
        start &= ~ 0x1;
    }
    else {
        start |= 0x1;
    }
    int i = start;
    for (; i < ces; i += 2) {
        int temp = pce [i];
        if (temp > a0) {
            lastChangingElement = i;
            ret [0] = temp;
            break;
        }
    }
    if (i + 1 < ces) {
        ret [1] = pce [i + 1];
    }
}


-----Function Pair=13=-----==

public boolean delete (long value) {
    int j;
    for (j = 0; j < nElems; j ++) {
        if (value == a [j]) {
            break;
        }
    }
    if (j == nElems) {
        return false;
    }
    else {
        for (int k = j; k < nElems; k ++) {
            a [k] = a [k + 1];
        }
        nElems --;
        return true;
    }
}


void gen () {
    if (useJsrLocally) {
        if (tree.finalizer != null) {
            Code.State jsrState = code.state.dup ();
            jsrState.push (code.jsrReturnValue);
            tryEnv.info.cont = new Chain (code.emitJump (jsr), tryEnv.info.cont, jsrState);
        }
        assert tryEnv.info.gaps.length () % 2 == 0;
        tryEnv.info.gaps.append (code.curPc ());
    }
    else {
        assert tryEnv.info.gaps.length () % 2 == 0;
        tryEnv.info.gaps.append (code.curPc ());
        genLast ();
    }
}


-----Function Pair=14=-----==

protected void addEdge (int p1, int p2) {
    int i = ncon;
    if (p1 >= nvert || p2 >= nvert) return;
    if (i >= maxcon) if (con == null) {
        maxcon = 100;
        con = new int [maxcon];
    }
    else {
        maxcon *= 2;
        int nv [] = new int [maxcon];
        System.arraycopy (con, 0, nv, 0, con.length);
        con = nv;
    }
    if (p1 > p2) {
        int t = p1;
        p1 = p2;
        p2 = t;
    }
    con [i] = (p1 << 16) | p2;
    ncon = i + 1;
}


public int getMaxPattern () {
    Track track;
    int size;
    int value;
    boolean skip;
    int max = 0;
    for (int i = 0; i < numberOfTunes; i ++) {
        for (int j = 0; j < 3; j ++) {
            track = tracks [i] [j];
            size = track.getSize ();
            skip = false;
            for (int k = 0; k < size - 2; k ++) {
                if (skip) {
                    skip = false;
                    continue;
                }
                value = track.getValueAt (k);
                if (value == Track.PATTERN_REP) {
                    skip = true;
                    continue;
                }
                if (value > Track.PATTERN_REP) continue;
                if (value > max) max = value;
            }
        }
    }
    return max;
}


-----Function Pair=15=-----==

public boolean search () {
    Thread tread = java.lang.Thread.currentThread ();
    java.lang.management.ThreadMXBean b = java.lang.management.ManagementFactory.getThreadMXBean ();
    long startCPU = b.getThreadCpuTime (tread.getId ());
    long startUser = b.getThreadUserTime (tread.getId ());
    boolean result = store.consistency ();
    System.out.println ("*** consistency = " + result);
    Search label = new DepthFirstSearch < SetVar > ();
    SelectChoicePoint < SetVar > select = new SimpleSelect < SetVar > (vars.toArray (new SetVar [vars.size ()]), new MinLubCard < SetVar > (), new MaxGlbCard < SetVar > (), new IndomainSetMin < SetVar > ());
    label.getSolutionListener ().searchAll (false);
    label.getSolutionListener ().recordSolutions (false);
    result = label.labeling (store, select);
    if (result) {
        System.out.println ("*** Yes");
        for (int i = 0; i < weeks; i ++) {
            for (int j = 0; j < groups; j ++) {
                System.out.print (golferGroup [i] [j].dom () + " ");
            }
            System.out.println ();
        }
    }
    else System.out.println ("*** No");
    System.out.println ("ThreadCpuTime = " + (b.getThreadCpuTime (tread.getId ()) - startCPU) / (long) 1e+6 + "ms");
    System.out.println ("ThreadUserTime = " + (b.getThreadUserTime (tread.getId ()) - startUser) / (long) 1e+6 + "ms");
    return result;
}


private static ID3v2OutputFrame toFrameCOMM (String longFrameID, Number frameOrder, String value) throws UnsupportedEncodingException, IOException {
    String s;
    if (value instanceof String) s = (String) value;
    else {
        Debug.debug ("Bad value ", value + " (" + Debug.getType (value) + ")");
        Debug.dumpStack ();
        return null;
    }
    boolean use_iso = canEncodeStringInISO (s);
    int char_encoding_code = use_iso ? CHAR_ENCODING_CODE_ISO_8859_1 : CHAR_ENCODING_CODE_UTF_16_WITH_BOM;
    byte string_bytes [] = encodeString (s, use_iso);
    int result_length = string_bytes.length + 1 + 3 + 1;
    byte result [] = new byte [result_length];
    int index = 0;
    result [index ++] = (byte) char_encoding_code;
    result [index ++] = (byte) 0;
    result [index ++] = (byte) 0;
    result [index ++] = (byte) 0;
    result [index ++] = (byte) 0;
    System.arraycopy (string_bytes, 0, result, index, string_bytes.length);
    return new ID3v2OutputFrame (longFrameID, frameOrder, result);
}


-----Function Pair=16=-----==

public static int [] getLengths (String [] args) {
    int [] lengths = new int [args.length];
    for (int i = 0; i < args.length; i ++) {
        int dex1 = args [i].indexOf ('.');
        int dex2 = args [i].indexOf ('.', dex1 + 1);
        lengths [i] = Integer.parseInt (args [i].substring (dex1 + 1, dex2));
        if (i > 0) {
            if (lengths [i] < lengths [i - 1]) {
                System.out.println ("Files are in wrong order, must be from smallest to largest.");
                System.exit (0);
            }
        }
    }
    return lengths;
}


void loadByteArray (byte data []) throws IOException {
    DataElement element = (new SDPInputStream (new ByteArrayInputStream (data))).readElement ();
    if (element.getDataType () != DataElement.DATSEQ) {
        throw new IOException ("DATSEQ expected instead of " + element.getDataType ());
    }
    Enumeration en = (Enumeration) element.getValue ();
    while (en.hasMoreElements ()) {
        DataElement id = (DataElement) en.nextElement ();
        if (id.getDataType () != DataElement.U_INT_2) {
            throw new IOException ("U_INT_2 expected instead of " + id.getDataType ());
        }
        DataElement value = (DataElement) en.nextElement ();
        this.populateAttributeValue ((int) id.getLong (), value);
    }
}


-----Function Pair=17=-----==

public static boolean isSorted (int [] array, int offset, int len, boolean largest_first) {
    if (len < 2) return true;
    int last = array [offset ++];
    if (largest_first) {
        for (int i = 1; i < len; i ++) {
            int tmp = array [offset ++];
            if (tmp > last) return false;
            else last = tmp;
        }
    }
    else {
        for (int i = 1; i < len; i ++) {
            int tmp = array [offset ++];
            if (tmp < last) return false;
            else last = tmp;
        }
    }
    return true;
}


protected void framing (double inputSignal []) {
    double numFrames = (double) inputSignal.length / (double) (frameLength - shiftInterval);
    if ((numFrames / (int) numFrames) != 1) {
        numFrames = (int) numFrames + 1;
    }
    double paddedSignal [] = new double [(int) numFrames * frameLength];
    for (int n = 0; n < inputSignal.length; n ++) {
        paddedSignal [n] = inputSignal [n];
    }
    frames = new double [(int) numFrames] [frameLength];
    for (int m = 0; m < numFrames; m ++) {
        for (int n = 0; n < frameLength; n ++) {
            frames [m] [n] = paddedSignal [m * (frameLength - shiftInterval) + n];
        }
    }
}


-----Function Pair=18=-----==

private int [] removeNonCodingCharacters (String input, char [] cbuf) {
    int index = 0;
    for (int i = 0; i < input.length (); i ++) {
        char ch = input.charAt (i);
        if (isCodingCharacter (ch)) {
            cbuf [index ++] = ch;
        }
    }
    int paddingCount = 0;
    for (int i = input.length () - 1; (i >= 0) && (paddingCount < 2); i --) {
        char ch = input.charAt (i);
        if (ch == PADCHAR) {
            cbuf [index ++] = PADCHAR;
            paddingCount ++;
        }
        else if (isCodingCharacter (ch)) {
            break;
        }
    }
    return new int [] {index, paddingCount};
}


public int in (int port) {
    cont_port (port);
    if ((port & 0x00E0) == 0) return kempston;
    if ((port & 0xC002) == 0xC000 && ay_enabled) {
        if (ay_idx >= 14 && (ay_reg [7]>> ay_idx - 8 & 1) == 0) return 0xFF;
        return ay_reg [ay_idx];
    }
    int v = 0xFF;
    if ((port & 0x0001) == 0) {
        for (int i = 0; i < 8; i ++) if ((port & 0x100 << i) == 0) v &= keyboard [i];
        v &= ula28 << 2 | 0xBF;
    }
    else if (cpu.time >= 0) {
        int t = cpu.time;
        int y = t / 224;
        t %= 224;
        if (y < 192 && t < 124 && (t & 4) == 0) {
            int x = t>> 1 & 1 | t>> 2;
            if ((t & 1) == 0) x += y & 0x1800 | y << 2 & 0xE0 | y << 8 & 0x700;
            else x += 6144 | y << 2 & 0x3E0;
            v = read_ram (x);
        }
    }
    return v;
}


-----Function Pair=19=-----==

static GeneticOperator getSwapOperator (final EvolutionChamber c) {
    return new GeneticOperator () {
        @Override
        public void operate (Population arg0, List arg1) {
            for (int i = 0; i < arg0.size (); i ++) {
                if (Math.random () > c.getBaseMutationRate () / c.getChromosomeLength ()) continue;
                IChromosome chromosome = (IChromosome) ((ICloneable) arg0.getChromosome (i)).clone ();
                Gene [] beforeArray = chromosome.getGenes ();
                int randomPoint = (int) (Math.random () * beforeArray.length);
                int randomPoint2 = (int) (Math.random () * beforeArray.length);
                Gene swap = beforeArray [randomPoint];
                beforeArray [randomPoint] = beforeArray [randomPoint2];
                beforeArray [randomPoint2] = swap;
                try {
                    chromosome.setGenes (beforeArray);
                } catch (InvalidConfigurationException e) {
                    StringWriter sw = new StringWriter ();
                    e.printStackTrace (new PrintWriter (sw));
                    logger.severe (sw.toString ());
                }
                arg1.add (chromosome);
            }
        }
    }
    ;
}


public boolean isAryt (String key) {
    if (key.equals ("*")) {
        return true;
    }
    if (key.equals ("-")) {
        return true;
    }
    if (key.equals ("/")) {
        return true;
    }
    if (key.equals ("+")) {
        return true;
    }
    return false;
}


-----Function Pair=20=-----==

public static int [] sortAscending (int input []) {
    int [] order = new int [input.length];
    for (int i = 0; i < order.length; i ++) order [i] = i;
    for (int i = input.length; -- i >= 0;) {
        for (int j = 0; j < i; j ++) {
            if (input [j] > input [j + 1]) {
                int mem = input [j];
                input [j] = input [j + 1];
                input [j + 1] = mem;
                int id = order [j];
                order [j] = order [j + 1];
                order [j + 1] = id;
            }
        }
    }
    return order;
}


public static int [] sortDescending (Date [] input) {
    int [] order = new int [input.length];
    for (int i = 0; i < order.length; i ++) order [i] = i;
    for (int i = input.length; -- i >= 0;) {
        for (int j = 0; j < i; j ++) {
            if (input [i].before (input [i + 1])) {
                Date mem = input [j];
                input [j] = input [j + 1];
                input [j + 1] = mem;
                int id = order [j];
                order [j] = order [j + 1];
                order [j + 1] = id;
            }
        }
    }
    return order;
}


-----Function Pair=21=-----==

private void interpolate (int rgb1, int rgb2, int [] output) {
    int a1, r1, g1, b1, da, dr, dg, db;
    float stepSize = 1 / (float) output.length;
    a1 = (rgb1>> 24) & 0xff;
    r1 = (rgb1>> 16) & 0xff;
    g1 = (rgb1>> 8) & 0xff;
    b1 = (rgb1) & 0xff;
    da = ((rgb2>> 24) & 0xff) - a1;
    dr = ((rgb2>> 16) & 0xff) - r1;
    dg = ((rgb2>> 8) & 0xff) - g1;
    db = ((rgb2) & 0xff) - b1;
    for (int i = 0; i < output.length; i ++) {
        output [i] = (((int) ((a1 + i * da * stepSize) + .5) << 24)) | (((int) ((r1 + i * dr * stepSize) + .5) << 16)) | (((int) ((g1 + i * dg * stepSize) + .5) << 8)) | (((int) ((b1 + i * db * stepSize) + .5)));
    }
}


public int [] getStateSequence (int [] ob) {
    int l = ob.length;
    int stateCount = stProb.length;
    int [] [] top = new int [l] [stateCount];
    double [] [] d = new double [l] [stateCount];
    for (int i = 0; i < stateCount; i ++) {
        d [0] [i] = stProb [i] * obProb [i] [ob [0]];
    }
    for (int t = 1; t < l; t ++) {
        for (int i = 0; i < stateCount; i ++) {
            double max = - Double.MAX_VALUE;
            int top_state = - 1;
            for (int j = 0; j < stateCount; j ++) {
                double v = d [t - 1] [j] * transProb [j] [i];
                if (v > max) {
                    max = v;
                    top_state = j;
                }
            }
            d [t] [i] = max * obProb [i] [ob [t]];
            top [t] [i] = top_state;
        }
    }
    int [] seq = new int [l];
    double max = - Double.MAX_VALUE;
    int maxi = - 1;
    for (int i = 0; i < stateCount; i ++) {
        double v = d [l - 1] [i];
        if (v > max) {
            max = v;
            maxi = i;
        }
    }
    seq [l - 1] = maxi;
    for (int t = l - 2; t >= 0; t --) {
        seq [t] = top [t + 1] [seq [t + 1]];
    }
    return seq;
}


-----Function Pair=22=-----==

private int evalBsplineU (double t, double [] r) {
    int n_seg = nSegments ();
    ParameterDomain dmn = getParameterDomain ();
    if (! dmn.isValid (t)) {
        throw new ExceptionGeometryFatal ();
    }
    t = dmn.wrap (dmn.force (t));
    int isckt;
    int i;
    for (isckt = 1; ! (t < isckt); isckt ++);
    isckt --;
    if (isckt >= n_seg) {
        isckt = n_seg - 1;
    }
    for (i = 0; i <= degree (); i ++) {
        r [i] = 0.0;
    }
    evalUniform ((- degree ()), degree (), isckt, t, r);
    return isckt;
}


void layoutPackages () {
    int rows = getRows ();
    xPos = getHGap () / 2;
    yPos = getVGap () / 2;
    cat.debug ("Number of rows in layout process: " + rows);
    for (int curRow = 0; curRow < _maxPackageRank; curRow ++) {
        cat.debug ("Processing row nr: " + curRow);
        xPos = getHGap () / 2;
        ClassdiagramNode [] rowObject = getObjectsInRow (curRow);
        cat.debug ("Objects in this row: " + rowObject.length);
        for (int i = 0; i < rowObject.length; i ++) {
            rowObject [i].setColumn (i);
            rowObject [i].setLocation (new Point (xPos, yPos));
            xPos += rowObject [i].getSize ().getWidth () + getHGap ();
        }
        yPos += getRowHeight (curRow) + getVGap ();
    }
}


-----Function Pair=23=-----==

void registerCatch (DiagnosticPosition pos, int startpc, int endpc, int handler_pc, int catch_type) {
    if (startpc != endpc) {
        char startpc1 = (char) startpc;
        char endpc1 = (char) endpc;
        char handler_pc1 = (char) handler_pc;
        if (startpc1 == startpc && endpc1 == endpc && handler_pc1 == handler_pc) {
            code.addCatch (startpc1, endpc1, handler_pc1, (char) catch_type);
        }
        else {
            if (! useJsrLocally && ! target.generateStackMapTable ()) {
                useJsrLocally = true;
                throw new CodeSizeOverflow ();
            }
            else {
                log.error (pos, "limit.code.too.large.for.try.stmt");
                nerrs ++;
            }
        }
    }
}


public void read_short_array (short [] val, int off, int len) {
    if (0 == len) {
        return;
    }
    alignment (2);
    m_tmp_len.value = len * 2;
    int rd;
    while (m_tmp_len.value > 0) {
        rd = next (m_tmp_buf, m_tmp_off, m_tmp_len);
        for (int i = 0; i < rd - 1; i += 2, ++ off) {
            val [off] = (short) (((m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << (m_swap ? 0 : 8)) | ((m_tmp_buf.value [m_tmp_off.value + i + 1] & 0xFF) << (m_swap ? 8 : 0)));
        }
        if (rd % 2 != 0) {
            int hlf = ((m_tmp_buf.value [m_tmp_off.value + rd] & 0xFF) << (m_swap ? 0 : 8));
            int tmp = m_tmp_len.value;
            m_tmp_len.value = 1;
            next (m_tmp_buf, m_tmp_off, m_tmp_len);
            val [off] = (short) (hlf | ((m_tmp_buf.value [m_tmp_off.value] & 0xFF) << (m_swap ? 8 : 0)));
            ++ off;
            m_tmp_len.value = tmp - 1;
        }
    }
    postread (len * 2);
}


-----Function Pair=24=-----==

void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=25=-----==

void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=26=-----==

private static void encrypt (byte [] blck, int edflag) {
    byte [] p = blck;
    transpose (p, InitialTr, 64);
    for (int i = 15; i >= 0; i --) {
        int j = edflag > 0 ? i : 15 - i;
        byte [] b = new byte [64];
        System.arraycopy (p, 0, b, 0, b.length);
        byte [] x = new byte [64];
        for (int k = 31; k >= 0; k --) {
            p [k] = b [k + 32];
        }
        f (j, key, p, x);
        for (int k = 31; k >= 0; k --) {
            p [k + 32] = (byte) (b [k] ^ x [k]);
        }
    }
    transpose (p, swap, 64);
    transpose (p, FinalTr, 64);
    blck = p;
}


public OrderTO doTradeByPaper (int index, String idPaper) throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    int volume = quote.getVolume ();
    if (currTime < PERIODO) {
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, 0, preco, true);
    }
    else {
        double m = media (dias [index]);
        int v;
        if (Trend.trend (dias [index]) > 0 && dias [index] [PERIODO - 1] < m) v = VOLUME;
        else if (Trend.trend (dias [index]) < 0 && m < dias [index] [PERIODO - 1]) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, Math.abs (v), preco, true);
    }
}


-----Function Pair=27=-----=1=

void bubbleSort (int [] a) {
    int i = 0;
    int j = a.length - 1;
    int aux = 0;
    int stop = 0;
    while (stop == 0) {
        stop = 1;
        i = 0;
        while (i < j) {
            if (a [i] > a [i + 1]) {
                aux = a [i];
                a [i] = a [i + 1];
                a [i + 1] = aux;
                stop = 0;
            }
            i = i + 1;
        }
        j = j - 1;
    }
}


public void bubbleSort (int [] arr) {
    boolean swapped = true;
    int j = 0;
    int tmp;
    while (swapped) {
        swapped = false;
        j ++;
        for (int i = 0; i < arr.length - j; i ++) {
            if (arr [i] > arr [i + 1]) {
                tmp = arr [i];
                arr [i] = arr [i + 1];
                arr [i + 1] = tmp;
                swapped = true;
            }
        }
    }
}


-----Function Pair=28=-----==

public static void normalTransformcolumns (float [] [] M, boolean extreme_values, int label) {
    int lines = M.length;
    int columns = M [0].length;
    if (extreme_values) {
        means = new float [columns - label];
        stds = new float [columns - label];
    }
    else if (minNeg == null) {
        new fs.FSException ("Error on applying normal transform.", false);
    }
    for (int j = 0; j < columns - label; j ++) {
        if (M [0] [j] != skipvalue) {
            if (extreme_values) {
                float sum = 0;
                for (int i = 0; i < lines; i ++) {
                    sum += M [i] [j];
                }
                means [j] = sum / lines;
                stds [j] = 0f;
                for (int i = 0; i < lines; i ++) {
                    stds [j] += (M [i] [j] - means [j]) * (M [i] [j] - means [j]);
                }
                stds [j] /= (lines - 1);
                stds [j] = ((Double) Math.sqrt (stds [j])).floatValue ();
            }
            if (stds [j] > 0) {
                for (int i = 0; i < lines; i ++) {
                    M [i] [j] -= means [j];
                    M [i] [j] /= stds [j];
                }
            }
            else {
                for (int i = 0; i < lines; i ++) {
                    M [i] [j] = 0;
                }
            }
        }
    }
}


protected void computeCoefficients () throws ArithmeticException {
    int i, j, n;
    double c [], tc [], d, t;
    n = degree () + 1;
    coefficients = new double [n];
    for (i = 0; i < n; i ++) {
        coefficients [i] = 0.0;
    }
    c = new double [n + 1];
    c [0] = 1.0;
    for (i = 0; i < n; i ++) {
        for (j = i; j > 0; j --) {
            c [j] = c [j - 1] - c [j] * x [i];
        }
        c [0] *= (- x [i]);
        c [i + 1] = 1;
    }
    tc = new double [n];
    for (i = 0; i < n; i ++) {
        d = 1;
        for (j = 0; j < n; j ++) {
            if (i != j) {
                d *= (x [i] - x [j]);
            }
        }
        if (d == 0.0) {
            for (int k = 0; k < n; ++ k) {
                if ((i != k) && (x [i] == x [k])) {
                    throw MathRuntimeException.createArithmeticException ("identical abscissas x[{0}] == x[{1}] == {2} cause division by zero", i, k, x [i]);
                }
            }
        }
        t = y [i] / d;
        tc [n - 1] = c [n];
        coefficients [n - 1] += t * tc [n - 1];
        for (j = n - 2; j >= 0; j --) {
            tc [j] = c [j + 1] + tc [j + 1] * x [i];
            coefficients [j] += t * tc [j];
        }
    }
    coefficientsComputed = true;
}


-----Function Pair=29=-----==

protected void removeDataSource (int i) {
    DataSource ds = (DataSource) get (i);
    if (sourceInfo != null) {
        SourceInfo [] si = new SourceInfo [sourceInfo.length - 1];
        for (int j = 0; j < i; ++ j) si [j] = sourceInfo [j];
        for (int j = i; j < si.length; ++ j) si [j] = sourceInfo [j + 1];
        sourceInfo = si;
    }
    if (buffers != null) {
        Buffer [] bf = new Buffer [buffers.length - 1];
        for (int j = 0; j < i; ++ j) bf [j] = buffers [j];
        for (int j = i; j < bf.length; ++ j) bf [j] = buffers [j + 1];
        buffers = bf;
    }
    remove (i);
    for (; i < size (); ++ i) {
        Object o = get (i);
        if (o instanceof BufferedDataSource) {
            o = ((BufferedDataSource) o).dataSource;
        }
        if (o instanceof CollectiveDataSource) {
            ((CollectiveDataSource) o).myIndex = i;
        }
    }
    if (ds instanceof BufferedDataSource) {
        ds = ((BufferedDataSource) ds).dataSource;
    }
    if (ds instanceof CollectiveDataSource) {
        ((CollectiveDataSource) ds).myIndex = - 1;
    }
    notifyListenersForDataSourceRemoved (ds);
}


public void read_longlong_array (long [] val, int off, int len) {
    if (0 == len) {
        return;
    }
    alignment (8);
    m_tmp_len.value = len * 8;
    int rd;
    while (m_tmp_len.value > 0) {
        rd = next (m_tmp_buf, m_tmp_off, m_tmp_len);
        for (int i = 0; i < rd - 7; i += 8, ++ off) {
            val [off] = (((long) (m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << (long) (m_swap ? 0 : 56)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 1] & 0xFF) << (long) (m_swap ? 8 : 48)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 2] & 0xFF) << (long) (m_swap ? 16 : 40)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 3] & 0xFF) << (long) (m_swap ? 24 : 32)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 4] & 0xFF) << (long) (m_swap ? 32 : 24)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 5] & 0xFF) << (long) (m_swap ? 40 : 16)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 6] & 0xFF) << (long) (m_swap ? 48 : 8)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 7] & 0xFF) << (long) (m_swap ? 56 : 0)));
        }
        if (rd % 8 != 0) {
            val [off] = 0L;
            int rcvd = rd % 8;
            rd -= rd % 8;
            int s = 0;
            for (; s < rcvd; ++ s) {
                val [off] = val [off] | ((long) (m_tmp_buf.value [m_tmp_off.value + rd + s] & 0xFF) << (long) (m_swap ? (8 * s) : (56 - 8 * s)));
            }
            int tmp = m_tmp_len.value - (8 - s);
            while (s < 8) {
                m_tmp_len.value = 8 - s;
                rd = next (m_tmp_buf, m_tmp_off, m_tmp_len);
                for (int i = 0; i < rd; ++ i, ++ s) {
                    val [off] = val [off] | ((long) (m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << (long) (m_swap ? (8 * s) : (56 - 8 * s)));
                }
            }
            m_tmp_len.value = tmp;
        }
    }
    postread (len * 8);
}


-----Function Pair=30=-----==

public void disconnect () {
    if (client != null) {
        try {
            try {
                try {
                    client.logout ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            } finally {
                try {
                    client.disconnect ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            }
        } finally {
            client = null;
        }
    }
}


public void run () {
    jProgressBar1.setIndeterminate (true);
    jTextField1.setEnabled (false);
    jPasswordField1.setEnabled (false);
    jButton1.setEnabled (false);
    jComboBox1.setEnabled (false);
    jComboBox2.setEnabled (false);
    try {
        boolean con = handler.connect (jComboBox1.getSelectedItem ().toString (), Integer.parseInt (jComboBox2.getSelectedItem ().toString ()));
        if (con && 0 != handler.login (jTextField1.getText (), new String (jPasswordField1.getPassword ()))) {
            try {
                handler.users ();
            } catch (LoginException e) {
                try {
                    handler.bye ();
                } catch (IOException e1) {
                } finally {
                    handler.close ();
                }
            }
            getParent ().setVisible (true);
            setVisible (false);
        }
        else {
            jProgressBar1.setString ("Wrong name or bad password.");
        }
    } catch (IOException e) {
        jProgressBar1.setString ("Network Error.");
        e.printStackTrace ();
    } finally {
        jProgressBar1.setIndeterminate (false);
        jTextField1.setEnabled (true);
        jPasswordField1.setEnabled (true);
        jButton1.setEnabled (true);
        jComboBox1.setEnabled (true);
        jComboBox2.setEnabled (true);
    }
}


-----Function Pair=31=-----==

public void propertyChange (java.beans.PropertyChangeEvent evt) {
    String propertyName = evt.getPropertyName ();
    if ("started".equals (propertyName)) {
        if (! busyIconTimer.isRunning ()) {
            statusAnimationLabel.setIcon (busyIcons [0]);
            busyIconIndex = 0;
            busyIconTimer.start ();
        }
        progressBar.setVisible (true);
        progressBar.setIndeterminate (true);
    }
    else if ("done".equals (propertyName)) {
        busyIconTimer.stop ();
        statusAnimationLabel.setIcon (idleIcon);
        progressBar.setVisible (false);
        progressBar.setValue (0);
    }
    else if ("message".equals (propertyName)) {
        String text = (String) (evt.getNewValue ());
        statusMessageLabel.setText ((text == null) ? "" : text);
        messageTimer.restart ();
    }
    else if ("progress".equals (propertyName)) {
        int value = (Integer) (evt.getNewValue ());
        progressBar.setVisible (true);
        progressBar.setIndeterminate (false);
        progressBar.setValue (value);
    }
}


public static void main (String [] args) {
    GTalkBotFS thread = new GTalkBotFS ();
    String fileUserConfig = null;
    String fileCommandConfig = null;
    for (String arg : args) {
        if (arg.startsWith ("-u=")) {
            fileUserConfig = arg.substring (3);
        }
        else if (arg.startsWith ("-c=")) {
            fileCommandConfig = arg.substring (3);
        }
    }
    thread.setFileUserConfig (fileUserConfig);
    thread.setFileCommandConfig (fileCommandConfig);
    thread.start ();
}


-----Function Pair=32=-----==

public void testChannelLeaveAllAfterRelocate () throws Exception {
    String channelName = "foo";
    createChannel (channelName);
    SgsTestNode oldNode = addNode ();
    SgsTestNode newNode = addNode ();
    ClientGroup group = new ClientGroup (oldNode.getAppPort (), oneUser);
    try {
        DummyClient relocatingClient = group.getClient (REX);
        joinUsers (channelName, oneUser);
        relocatingClient.assertJoinedChannel (channelName);
        holdChannelServerMethodToNode (oldNode, "close");
        leaveAll (channelName);
        waitForHeldChannelServerMethodToNode (oldNode);
        moveClient (relocatingClient, oldNode, newNode);
        Thread.sleep (200);
        releaseChannelServerMethodHeld (oldNode);
        checkUsersJoined (channelName, noUsers);
        relocatingClient.assertLeftChannel (channelName);
    } finally {
        group.disconnect (false);
    }
}


public void resource_download_response (String Filename, byte [] binary, int length) {
    System.out.println ("resource_download_response : filename = " + Filename + ", binary size = " + new Integer (length).toString ());
    FileOutputStream fos;
    DataOutputStream ds;
    try {
        fos = new FileOutputStream ("./" + Filename);
        ds = new DataOutputStream (fos);
        ds.write (binary, 0, length);
        ds.close ();
        fos.close ();
    } catch (IOException e) {
        System.out.println ("Error creating file: ./" + Filename);
    }
    m_MyTNetWrapper.AddBuddy (102);
    m_MyTNetWrapper.getBuddyList ();
}


-----Function Pair=33=-----==

protected void loadAvatar (final String user) {
    new Thread () {
        @Override
        public void run () {
            if (con != null && con.getUser () != null) {
                try {
                    VCard vCard = new VCard ();
                    vCard.load (con, user);
                    byte [] avatarBytes = vCard.getAvatar ();
                    Bitmap avatar = BitmapFactory.decodeByteArray (avatarBytes, 0, avatarBytes.length);
                    int width = avatar.getWidth ();
                    int height = avatar.getHeight ();
                    int newWidth;
                    int newHeight;
                    float scaleX;
                    float scaleY;
                    if (width > height) {
                        newWidth = 32;
                        scaleX = ((float) newWidth / width);
                        newHeight = Math.round (height * scaleX);
                        scaleY = ((float) newHeight / height);
                    }
                    else if (height > width) {
                        newHeight = 32;
                        scaleY = ((float) newHeight / height);
                        newWidth = Math.round (width * scaleY);
                        scaleX = ((float) newWidth / width);
                    }
                    else {
                        newWidth = 32;
                        newHeight = 32;
                        scaleX = ((float) newWidth / width);
                        scaleY = ((float) newHeight / height);
                    }
                    Matrix matrix = new Matrix ();
                    matrix.postScale (scaleX, scaleY);
                    Bitmap resizedAvatar = Bitmap.createBitmap (avatar, 0, 0, width, height, matrix, true);
                    ByteArrayOutputStream bos = new ByteArrayOutputStream ();
                    resizedAvatar.compress (CompressFormat.PNG, 100, bos);
                } catch (XMPPException e) {
                    Log.e (TAG, e.getMessage ());
                }
            }
        }
    }
    .start ();
}


private JPopupMenu buildMessagePopup () {
    JPopupMenu popup = new JPopupMenu ("message popup");
    popup.add (new JMenuItem (listAction));
    popup.addSeparator ();
    popup.add (new JMenuItem (stepBackAction));
    popup.add (new JMenuItem (playAction));
    popup.add (new JMenuItem (pauseAction));
    popup.add (new JMenuItem (stopAction));
    popup.add (new JMenuItem (stepForwardAction));
    popup.addSeparator ();
    popup.add (new JMenuItem (toggleAction));
    popup.add (new JMenuItem (saveAsAction));
    popup.add (new JMenuItem (copyCallerIdToClipboard));
    popup.addSeparator ();
    popup.add (new JMenuItem (deleteAction));
    return popup;
}


-----Function Pair=34=-----==

private void exceptionHandler (String message) {
    final JFrame errFrame = new JFrame ();
    JLabel userLabel = new JLabel (message);
    errFrame.setResizable (false);
    JButton okayButton = new JButton ("Okay");
    Container contentPane = errFrame.getContentPane ();
    contentPane.setLayout (new BoxLayout (contentPane, BoxLayout.PAGE_AXIS));
    errFrame.setBounds (200, 200, 300, 300);
    JPanel userPanel = new JPanel ();
    JPanel buttonPanel = new JPanel ();
    userPanel.add (userLabel);
    buttonPanel.add (okayButton);
    errFrame.setTitle ("Error");
    contentPane.add (userPanel);
    contentPane.add (Box.createRigidArea (new Dimension (0, 50)));
    contentPane.add (buttonPanel);
    errFrame.pack ();
    errFrame.setVisible (true);
    okayButton.getRootPane ().setDefaultButton (okayButton);
    okayButton.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            errFrame.dispose ();
        }
    }
    );
    errFrame.addWindowFocusListener (new WindowFocusListener () {
        public void windowLostFocus (WindowEvent evt) {
            errFrame.requestFocus ();
        } public void windowGainedFocus (WindowEvent evt) {
        }
    }
    );
}


private FTPClient getFTPConnection (String strUser, String strPassword, String strServer, boolean binaryTransfer, String connectionNote, boolean passiveMode) {
    FTPClient ftp = new FTPClient ();
    try {
        int reply;
        ftp.connect (strServer);
        ResourcePool.LogMessage (this, ResourcePool.INFO_MESSAGE, "Connected to " + strServer + ", " + connectionNote);
        reply = ftp.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            ftp.disconnect ();
            ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP server refused connection.");
            return null;
        }
    } catch (IOException e) {
        if (ftp.isConnected ()) {
            try {
                ftp.disconnect ();
            } catch (IOException f) {
                return null;
            }
        }
        ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP Could not connect to server.");
        ResourcePool.LogException (e, this);
        return null;
    }
    try {
        if (! ftp.login (strUser, strPassword)) {
            ftp.logout ();
            ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP login failed.");
            return null;
        }
        ResourcePool.LogMessage (this, ResourcePool.INFO_MESSAGE, "Remote system is " + ftp.getSystemName () + ", " + connectionNote);
        if (binaryTransfer) {
            ftp.setFileType (FTP.BINARY_FILE_TYPE);
        }
        else {
            ftp.setFileType (FTP.ASCII_FILE_TYPE);
        }
        if (passiveMode) {
            ftp.enterLocalPassiveMode ();
        }
        else {
            ftp.enterLocalActiveMode ();
        }
    } catch (FTPConnectionClosedException e) {
        ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "Server closed connection.");
        ResourcePool.LogException (e, this);
        return null;
    } catch (IOException e) {
        ResourcePool.LogException (e, this);
        return null;
    }
    return ftp;
}


-----Function Pair=35=-----==

private void createButtonActionPerformed (java.awt.event.ActionEvent evt) {
    Client client = Client.get ();
    final boolean ok = checkFields ();
    if (! ok) {
        return;
    }
    try {
        client.connect (serverField.getText (), new Integer (portField.getText ()));
        client.createAccount (nameField.getText (), new String (password1Field.getPassword ()), mailField.getText ());
        client.login (nameField.getText (), new String (password1Field.getPassword ()));
        RPObject character = new RPObject ();
        client.createCharacter (nameField.getText (), character);
        client.chooseCharacter (nameField.getText ());
        ChatFrame chat = ChatFrame.get ();
        chat.setVisible (true);
        MainScreen.get ().setVisible (false);
        MainScreen.get ().dispose ();
    } catch (Exception e) {
        JOptionPane.showMessageDialog (MainScreen.get (), e.getMessage (), "Warning", JOptionPane.WARNING_MESSAGE);
        e.printStackTrace ();
    }
}


public void handle (Callback [] callbacks) throws IOException, UnsupportedCallbackException {
    for (Callback callback : callbacks) {
        if (callback instanceof NameCallback) {
            NameCallback ncb = (NameCallback) callback;
            ncb.setName (getUsername ());
        }
        else if (callback instanceof PasswordCallback) {
            PasswordCallback pcb = (PasswordCallback) callback;
            pcb.setPassword (getPassword ().toCharArray ());
        }
        else {
            String message = "Unknown callback requested: " + callback.getClass ().getSimpleName ();
            Log.error (message);
        }
    }
}


-----Function Pair=36=-----==

private static String extractLocation (String regkey) throws Exception {
    String cmd = "reg query " + regkey + " /ve";
    Process child = Runtime.getRuntime ().exec (cmd);
    child.waitFor ();
    BufferedReader br = new BufferedReader (new InputStreamReader (child.getInputStream ()));
    StringBuffer sb = new StringBuffer ("");
    String line = null;
    while ((line = br.readLine ()) != null) {
        sb.append (line).append (NEW_LINE);
    }
    Matcher mat = PATTERN_EXTRACTING_AUTOIT_LOCATION.matcher (sb.toString ());
    if (mat.find ()) {
        return mat.group (mat.groupCount ()).trim ();
    }
    else {
        throw new Exception ("Unable to find AutoIt Location");
    }
}


private void parse (String command) {
    String [] cmdFields = command.split (" ", 2);
    if ("exit".equals (cmdFields [0])) {
        this.running = false;
    }
    else if ("help".equals (cmdFields [0])) {
        StringBuffer sb = new StringBuffer ();
        sb.append ("The following commands are available:\n");
        sb.append ("\thelp -- this help message\n");
        sb.append ("\texit -- logout and exit the AIM client\n");
        sb.append ("\tsendim screenname message... -- send a message to screenname.").append ("  You do not need to put your message in quotes.");
        this.out.println (sb.toString ());
    }
    else if ("sendim".equals (cmdFields [0])) {
        String errorMessage = "sendim invalid.  use \"sendim buddyname message\"";
        if (2 != cmdFields.length) {
            this.out.println (errorMessage);
            return;
        }
        String [] sendIMFields = cmdFields [1].split (" ", 2);
        if (2 != sendIMFields.length) {
            this.out.println (errorMessage);
            return;
        }
        TOCMessage message = new Toc2SendIMMessage (sendIMFields [0], sendIMFields [1]);
        try {
            this.ml.sendMessage (message);
        } catch (IOException e) {
            logger.warning ("Could not send message: " + e);
        }
    }
}


-----Function Pair=37=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=38=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=39=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=40=-----==

static String readLn () {
    String newLine = System.getProperty ("line.separator");
    StringBuffer buffer = new StringBuffer ();
    int car = - 1;
    try {
        car = System.in.read ();
        while ((car > 0) && (car != newLine.charAt (0))) {
            buffer.append ((char) car);
            car = System.in.read ();
        }
        if (car == newLine.charAt (0)) System.in.skip (newLine.length () - 1);
    } catch (java.io.IOException e) {
        return (null);
    }
    if ((car < 0) && (buffer.length () == 0)) return (null);
    return (buffer.toString ()).trim ();
}


String getState (StringBuffer sfunc) {
    int modelCount = viewer.getModelCount ();
    if (modelCount < 2) return "";
    StringBuffer commands = new StringBuffer ();
    if (sfunc != null) {
        sfunc.append ("  _setFrameState;\n");
        commands.append ("function _setFrameState();\n");
    }
    commands.append ("# frame state;\n");
    commands.append ("# modelCount ").append (modelCount).append (";\n# first ").append (viewer.getModelNumberDotted (0)).append (";\n# last ").append (viewer.getModelNumberDotted (modelCount - 1)).append (";\n");
    if (backgroundModelIndex >= 0) StateManager.appendCmd (commands, "set backgroundModel " + viewer.getModelNumberDotted (backgroundModelIndex));
    StateManager.appendCmd (commands, "frame RANGE " + viewer.getModelNumberDotted (firstModelIndex) + " " + viewer.getModelNumberDotted (lastModelIndex));
    StateManager.appendCmd (commands, "animation DIRECTION " + (animationDirection == 1 ? "+1" : "-1"));
    StateManager.appendCmd (commands, "animation FPS " + animationFps);
    StateManager.appendCmd (commands, "animation MODE " + getAnimationModeName () + " " + firstFrameDelay + " " + lastFrameDelay);
    StateManager.appendCmd (commands, "frame " + viewer.getModelNumberDotted (currentModelIndex));
    StateManager.appendCmd (commands, "animation " + (! animationOn ? "OFF" : currentDirection == 1 ? "PLAY" : "PLAYREV"));
    if (animationOn && animationPaused) StateManager.appendCmd (commands, "animation PAUSE");
    if (sfunc != null) commands.append ("end function;\n\n");
    return commands.toString ();
}


-----Function Pair=41=-----==

private String getWorkItemId (String processId) throws Exception {
    String workItemId = null;
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet resultSet = null;
    new CesGlobals ().setConfigFile (Constant.DB_CONFIGE_FILE);
    DBOperationFactory factory = new ERDBOperationFactory ();
    DBOperation dbo = factory.createDBOperation (ConfigInfo.getInstance ().getPoolName ());
    String sql = "select id from t_wf_task where pros_inst_id = ? order by id desc";
    try {
        List tmp = new ArrayList ();
        con = dbo.getConnection ();
        ps = con.prepareStatement (sql);
        ps.setString (1, processId);
        resultSet = ps.executeQuery ();
        while (resultSet.next ()) {
            tmp.add (resultSet.getString (1));
        }
        workItemId = (String) tmp.get (0);
    } catch (Exception ex) {
        throw ex;
    } finally {
        resultSet.close ();
        ps.close ();
        con.close ();
        dbo.close ();
    }
    return workItemId;
}


public static String getText (File file, String encoding) throws IOException {
    StringBuffer contentBuffer = new StringBuffer ();
    try {
        FileInputStream fileInputStream = new FileInputStream (file);
        InputStreamReader is = new InputStreamReader (fileInputStream, encoding);
        BufferedReader reader = new BufferedReader (is);
        boolean more = true;
        int totalReaded = 0;
        while (more) {
            String line = reader.readLine ();
            if (line == null) {
                more = false;
            }
            else {
                contentBuffer.append (line);
                contentBuffer.append ("\n");
                totalReaded += line.length ();
            }
        }
        fileInputStream.close ();
        is.close ();
        reader.close ();
    } catch (IOException e) {
        throw e;
    }
    return contentBuffer.toString ();
}


-----Function Pair=42=-----==

public static boolean redirectInputStream (InputStream in, String path) throws IOException {
    FileOutputStream out = null;
    boolean result = false;
    try {
        out = new FileOutputStream (path);
        copyPipe (in, out, FILE_BUFFER_SIZE);
        result = true;
    } finally {
        if (out != null) {
            try {
                out.close ();
            } catch (IOException ioex) {
            }
        }
        if (in != null) {
            try {
                in.close ();
            } catch (IOException ioex) {
            }
        }
    }
    return result;
}


public static boolean save (File file, String content) {
    boolean result;
    BufferedWriter writer;
    writer = null;
    try {
        writer = new BufferedWriter (new FileWriter (file));
        writer.write (content);
        writer.flush ();
        result = true;
    } catch (Exception e) {
        e.printStackTrace ();
        result = false;
    } finally {
        if (writer != null) {
            try {
                writer.close ();
            } catch (Exception e) {
            }
        }
    }
    return result;
}


-----Function Pair=43=-----==

public void actionPerformed (ActionEvent e) {
    JToggleButton b = (JToggleButton) e.getSource ();
    JPanel oldViewPanel = currentViewPanel;
    if (b == detailsViewButton) {
        if (detailsViewPanel == null) {
            detailsViewPanel = createDetailsView (fc);
            detailsViewPanel.setPreferredSize (LIST_PREF_SIZE);
        }
        currentViewPanel = detailsViewPanel;
        listViewButton.getModel ().setRollover (false);
    }
    else {
        detailsViewButton.getModel ().setRollover (false);
        currentViewPanel = listViewPanel;
    }
    if (currentViewPanel != oldViewPanel) {
        centerPanel.remove (oldViewPanel);
        centerPanel.add (currentViewPanel, BorderLayout.CENTER);
        centerPanel.revalidate ();
        centerPanel.repaint ();
    }
}


public static void copyFile (final InputStream _source, final File _dest, boolean _close_input_stream) throws IOException {
    FileOutputStream dest = null;
    boolean close_input = _close_input_stream;
    try {
        dest = new FileOutputStream (_dest);
        close_input = false;
        copyFile (_source, dest, close_input);
    } finally {
        try {
            if (close_input) {
                _source.close ();
            }
        } catch (IOException e) {
        }
        if (dest != null) {
            dest.close ();
        }
    }
}


-----Function Pair=44=-----==

public static void copyDirectory (File src, File dst, boolean recurse) throws IOException {
    dst.mkdirs ();
    if (! dst.isDirectory ()) {
        throw new IOException ("cannot make target directory: " + dst.getAbsolutePath ());
    }
    File [] files = src.listFiles ();
    for (File f : files) {
        String name = f.getName ();
        if (! ".svn".equals (name)) {
            if (f.isFile ()) {
                copyFile (f, new File (dst, name));
            }
            else if (f.isDirectory () && recurse) {
                copyDirectory (f, new File (dst, name), true);
            }
        }
    }
}


public boolean importData (JComponent comp, Transferable t) {
    try {
        ModuleContainer mc = ((Module) target).getContainer ();
        if (t.isDataFlavorSupported (TransferableModule.prototypeFlavor)) {
            InputStream is = (InputStream) t.getTransferData (TransferableModule.prototypeFlavor);
            Module m = mc.createModule (null, is);
            ((EntityPeripheral) m).setTarget ((Module) target);
            return true;
        }
        else if (t.isDataFlavorSupported (TransferableResourceDescriptor.descriptorFlavor)) {
            ResourceDescriptor rd = (ResourceDescriptor) t.getTransferData (TransferableResourceDescriptor.descriptorFlavor);
            if (rd instanceof ModuleClassDescriptor) {
                Module m = mc.newModule ((ModuleClassDescriptor) rd);
                mc.registerModule (m);
                ((EntityPeripheral) m).setTarget ((Module) target);
                return true;
            }
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog (PeripheralPanel.this, e, "Error Transferring Peripheral", JOptionPane.ERROR_MESSAGE);
    }
    return false;
}


-----Function Pair=45=-----==

public static void main (String [] args) throws Exception {
    final List < String > argsList = Arrays.asList (args);
    XslJniGenerator generator = new XslJniGenerator ();
    File outDir = new File (".");
    if (argsList.contains ("-out")) {
        outDir = new File (argsList.get (argsList.indexOf ("-out") + 1));
    }
    if (argsList.contains ("-xml")) {
        if (! argsList.contains ("-class")) {
            System.out.println ("xml action requires -class option");
            return;
        }
        final String className = argsList.get (argsList.indexOf ("-class") + 1);
        final Class classObj = Class.forName (className);
        generator.generate_xml (classObj, outDir);
    }
    if (argsList.contains ("-native")) {
        if (! argsList.contains ("-class")) {
            System.out.println ("native action requires -class option");
            return;
        }
        final String className = argsList.get (argsList.indexOf ("-class") + 1);
        final Class classObj = Class.forName (className);
        generator.generate (classObj, outDir);
    }
}


public void replaceNamedVar (StringBuffer sqlString, String sqlVar, String filterVarValue, int max) {
    if (max <= 0) {
        max = Integer.MAX_VALUE;
    }
    List < Integer > bounds = nextUnbound (sqlString, sqlVar);
    int count = 0;
    while (bounds != null && ! bounds.isEmpty ()) {
        sqlString.replace (bounds.get (0) - OFFSET, bounds.get (1) - OFFSET, filterVarValue);
        count ++;
        if (count > max) {
            break;
        }
        bounds = nextUnbound (sqlString, sqlVar);
    }
}


-----Function Pair=46=-----=1=

public static String substituiAtributoTag (String html, String tag, String name, String atributo, String novoValor) {
    String reg = "<" + tag + "(\\s|\\s[^<]*?\\s)" + atributo + "=\".*?\"(.*?)>";
    Pattern pat = Pattern.compile (reg, Pattern.DOTALL);
    Matcher mat = pat.matcher (html);
    while (mat.find ()) {
        if (mat.group ().indexOf ("name=\"" + name + "\"") != - 1) {
            String ini = mat.group (1);
            String fim = mat.group (2);
            int st = mat.start ();
            int en = mat.end ();
            html = html.substring (0, st) + "<" + tag + ini + atributo + "=\"" + novoValor + "\" " + fim + ">" + html.substring (en);
            break;
        }
    }
    return html;
}


String parseText (String text, String patternName, Hashtable < String, String > patterns) throws JDOMException, IOException {
    String docString = "<X>" + text.replace ("&", "&amp;") + "</X>";
    Element e = org.exmaralda.common.jdomutilities.IOUtilities.readDocumentFromString (docString).getRootElement ();
    String returnText = "";
    for (Object o : e.getContent ()) {
        if (! (o instanceof Text)) {
            returnText += org.exmaralda.common.jdomutilities.IOUtilities.elementToString ((Element) o);
            continue;
        }
        Pattern p = Pattern.compile (patterns.get (patternName));
        String thisText = ((Text) o).getText ();
        Matcher m = p.matcher (thisText);
        int fromWhere = 0;
        while (m.find (fromWhere)) {
            int i1 = m.start ();
            int i2 = m.end ();
            thisText = thisText.substring (0, i1) + "<" + patternName + ">" + thisText.substring (i1, i2) + "</" + patternName + ">" + thisText.substring (i2);
            m = p.matcher (thisText);
            fromWhere = i2 + 2 * patternName.length () + 5;
        }
        returnText += thisText;
    }
    return returnText;
}


-----Function Pair=47=-----==

public void mouseClicked (MouseEvent e) {
    super.mouseClicked (e);
    if (e.getClickCount () == 2) {
        ColorSpace cspace;
        try {
            cspace = colSpacePanel1.getColorSpace ();
            float [] [] bounds = cspace.getBounds ();
            float fuzzy = (bounds [1] [0] - bounds [0] [0]) / 80f;
            int pivot = colSpacePanel1.getPivot (e, fuzzy);
            if (pivot == - 1) {
                float [] coords = new float [] {colSpacePanel1.getColSpaceX (e.getX ()), colSpacePanel1.getColSpaceY (e.getY ())};
                insertPivot (coords);
            }
            else {
                colSpacePanel1.setLastActive (pivot);
                changePivotColor ();
            }
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
}


protected static void removeNewlinesForAssertStyleJava (@Constraint ("post: s.get().size<=s@pre.get().size")
final IDocument s) {
    Pattern pattern = Pattern.compile ("assert\\s*assert(Pre|Post)Condition_(\\w*)_for_method_(\\w*)\\s*\\(([^\\)]*)\\)\\s*:" + "\\s*\"(.*)\"\\s*;" + "\\s*");
    Matcher matcher = pattern.matcher (s.get ());
    try {
        int lengthDifference = 0;
        while (matcher.find ()) {
            String replacement = "assert assert" + Matcher.quoteReplacement (matcher.group (1)) + "Condition_" + Matcher.quoteReplacement (matcher.group (2)) + "_for_method_" + Matcher.quoteReplacement (matcher.group (3)) + "(" + Matcher.quoteReplacement (matcher.group (4)) + ") : \"" + Matcher.quoteReplacement (matcher.group (5)) + "\";";
            int lengthOfMatchedString = matcher.end () - matcher.start ();
            s.replace (lengthDifference + matcher.start (), lengthOfMatchedString, replacement);
            lengthDifference -= lengthOfMatchedString - replacement.length ();
        }
    } catch (BadLocationException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=48=-----==

static void useFind () {
    Console c = System.console ();
    if (c == null) {
        System.err.println ("No console");
        System.exit (1);
    }
    while (true) {
        Pattern p = Pattern.compile (c.readLine ("%n find(), Enter your regex:"));
        Matcher m = p.matcher (c.readLine ("Enter input string to search:"));
        boolean found = false;
        while (m.find ()) {
            c.printf ("Found the text \"%s\" starting at %d and ending at %d.%n", m.group (), m.start (), m.end ());
            found = true;
        }
        if (! found) {
            c.format ("No matcher found.%n");
        }
    }
}


public static void createCacheFile (String fileName, String content, Context context) {
    if (! context.getCacheDir ().exists ()) context.getCacheDir ().mkdir ();
    if (fileName == null || content == null) return;
    FileOutputStream out = null;
    try {
        out = new FileOutputStream (new File (context.getCacheDir ().toString () + "/" + fileName));
        out.write (content.getBytes ());
        out.flush ();
    } catch (Exception e) {
        Log.e ("uiutil", "create file error", e);
    } finally {
        try {
            if (out != null) out.close ();
        } catch (IOException e) {
            Log.e ("uiutil", "create file error", e);
        }
    }
}


-----Function Pair=49=-----==

public static Vector split2 (String inputParam, char splitter) {
    int startIndex, endIndex;
    String tempString = inputParam;
    String searchedStr = new String ();
    Vector splittedVec = new Vector ();
    while (true) {
        if ((endIndex = tempString.indexOf (splitter)) == - 1) {
            splittedVec.add (tempString);
            break;
        }
        searchedStr = tempString.substring (0, endIndex);
        splittedVec.add (searchedStr);
        tempString = tempString.substring (endIndex + 1);
    }
    return splittedVec;
}


public static String Dec2BaseN (int dec, int base, int size) {
    StringBuffer str = new StringBuffer ();
    int q = dec % base, r = 0;
    while (dec >= base) {
        q = (dec / base);
        r = (dec % base);
        str.append (r + " ");
        dec = q;
    }
    str.append (q + " ");
    StringTokenizer s = new StringTokenizer (str.toString ());
    while (s.countTokens () < size) {
        str.append (0 + " ");
        s = new StringTokenizer (str.toString ());
    }
    str.setLength (str.length () - 1);
    return (str.reverse ().toString ());
}


-----Function Pair=50=-----==

private static double [] getMinMax (double [] values) {
    double [] returnArray = new double [2];
    double min = Double.MAX_VALUE;
    double max = 0;
    for (int x = 0; x < values.length; x ++) {
        if (values [x] > max) {
            max = values [x];
        }
        if (values [x] < min) {
            min = values [x];
        }
    }
    returnArray [0] = min;
    returnArray [1] = max;
    return returnArray;
}


public static int [] [] createConnectionTable (Node [] setOfNodes) {
    int partner;
    int contab [] [] = new int [setOfNodes.length] [setOfNodes.length];
    for (int f = 0; f < setOfNodes.length; f ++) {
        for (int g = 0; g < setOfNodes.length; g ++) {
            contab [f] [g] = 0;
        }
    }
    for (int f = 0; f < setOfNodes.length; f ++) {
        for (int g = 0; g < setOfNodes [f].degree; g ++) {
            partner = setOfNodes [f].nodeTable [g];
            contab [f] [partner] = setOfNodes [f].bondTable [g];
            contab [partner] [f] = setOfNodes [f].bondTable [g];
        }
    }
    return contab;
}


-----Function Pair=51=-----==

public static void main (String [] args) {
    int n = Integer.parseInt (args [0]);
    double [] [] in = new double [n] [n];
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            in [i] [j] = (double) Math.random ();
        }
    }
    Matrix origmat = new Matrix (in, n, n);
    Matrix trans = origmat.transpose ();
    Matrix symm = trans.postMultiply (origmat);
    Matrix origsymm = symm.copy ();
    long tstart = System.currentTimeMillis ();
    symm.tred ();
    long tend = System.currentTimeMillis ();
    tstart = System.currentTimeMillis ();
    symm.tqli ();
    tend = System.currentTimeMillis ();
}


public static double [] [] singleRotation (double [] [] loadingFactorMatrix, int k, int l, double angle) {
    int nRows = loadingFactorMatrix.length;
    int nColumns = loadingFactorMatrix [0].length;
    double [] [] rotatedMatrix = new double [nRows] [nColumns];
    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nColumns; j ++) {
            rotatedMatrix [i] [j] = loadingFactorMatrix [i] [j];
        }
    }
    double sinphi = Math.sin (angle);
    double cosphi = Math.cos (angle);
    for (int j = 0; j < nColumns; j ++) {
        rotatedMatrix [k] [j] = loadingFactorMatrix [k] [j] * cosphi + loadingFactorMatrix [l] [j] * sinphi;
        rotatedMatrix [l] [j] = - loadingFactorMatrix [k] [j] * sinphi + loadingFactorMatrix [l] [j] * cosphi;
    }
    return rotatedMatrix;
}


-----Function Pair=52=-----==

public String toString () {
    StringBuffer sb = new StringBuffer ();
    char [] separator = {'[', ' '};
    int n = rows.length;
    for (int i = 0; i < n; i ++) {
        separator [0] = '{';
        for (int j = 0; j < n; j ++) {
            sb.append (separator);
            sb.append (rows [i] [j]);
            separator [0] = ' ';
        }
        sb.append ('}');
        sb.append ('\n');
    }
    if (permutation != null) {
        sb.append ((parity == 1) ? '+' : '-');
        sb.append ("( " + permutation [0]);
        for (int i = 1; i < n; i ++) {
            sb.append (", " + permutation [i]);
        }
        sb.append (')');
        sb.append ('\n');
    }
    return sb.toString ();
}


public String [] getDescriptorNames () {
    String [] names;
    String [] suffix = {"w", "c", "p"};
    names = new String [3 * nhigh + 3 * nlow];
    int counter = 0;
    for (String aSuffix : suffix) {
        for (int i = 0; i < nhigh; i ++) {
            names [counter ++] = "BCUT" + aSuffix + "-" + (i + 1) + "l";
        }
        for (int i = 0; i < nlow; i ++) {
            names [counter ++] = "BCUT" + aSuffix + "-" + (i + 1) + "h";
        }
    }
    return names;
}


-----Function Pair=53=-----==

public int indexOf (Node n) {
    int i = 0;
    Node current = firstNode;
    boolean found = false;
    while (true) {
        if (current.equals (n)) {
            found = true;
            break;
        }
        if (! current.hasNextNode ()) break;
        i ++;
        current = current.getNextNode ();
    }
    if (found) return i;
    else return - 1;
}


public IntegerMatrix add (final IntegerMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawAdd (m);
        default :
            if (numRows == m.rows () && numCols == m.columns ()) {
                final int array [] [] = new int [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    array [i] [0] = matrix [i] [0] + m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) array [i] [j] = matrix [i] [j] + m.getElement (i, j);
                }
                return new IntegerMatrix (array);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


-----Function Pair=54=-----==

public Matrix distColumns (Matrix B) {
    checkRowDimension (B);
    Matrix X = new Matrix (n, B.n);
    double [] [] C = X.getArray ();
    for (int j = 0; j < n; j ++) {
        for (int k = 0; k < B.n; k ++) {
            double s = 0;
            for (int i = 0; i < m; i ++) {
                s = s + ((A [i] [j] - B.A [i] [k]) * (A [i] [j] - B.A [i] [k]));
            }
            C [k] [j] = Math.sqrt (s);
        }
    }
    return X;
}


public static RealSquareMatrix fromLowerTriangle (RealArray f) {
    int n = f.size ();
    int rows = (int) Math.round ((Math.sqrt (8 * n + 1) - 1 + 0.001) / 2.);
    if ((rows * (rows + 1)) / 2 != n) {
        throw new RuntimeException ("band number of values (" + n + ") for lower Triangle");
    }
    RealSquareMatrix temp = new RealSquareMatrix (rows);
    int count = 0;
    for (int i = 0; i < rows; i ++) {
        for (int j = 0; j <= i; j ++) {
            temp.flmat [i] [j] = f.elementAt (count);
            if (i != j) {
                temp.flmat [j] [i] = 0.0;
            }
            count ++;
        }
    }
    return temp;
}


-----Function Pair=55=-----==

public Matrix times (Matrix B) {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


private static DenseDoubleMatrix2D sort_eigenvectors_by_eigenvalues (EigenvalueDecomposition e) {
    double [] evalues = (e.getRealEigenvalues ()).toArray ();
    ValuePos [] vp = new ValuePos [evalues.length];
    for (int i = 0; i < evalues.length; i ++) {
        vp [i] = new ValuePos (evalues [i], i);
    }
    Comparator < ValuePos > byValue = new ValuePosComp ();
    Arrays.sort (vp, byValue);
    double [] [] evector = (e.getV ()).toArray ();
    double [] [] output = new double [evector.length] [evector [0].length];
    for (int i = 0; i < output.length; i ++) {
        for (int j = 0; j < output [i].length; j ++) {
            output [i] [j] = evector [i] [vp [j].pos];
        }
    }
    return new DenseDoubleMatrix2D (output);
}


-----Function Pair=56=-----==

public static boolean isSymmetric (double [] [] A) throws Exception {
    debug ("A = ");
    debug (Matlab.MatrixToString (new Matrix (A)));
    int N = A.length;
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < i; j ++) {
            if (A [i] [j] == Double.NaN || A [j] [i] == Double.NaN) {
                Logger.println ("Error in Cholesky: Matrix contains NaN");
                debug ("A = ");
                debug (Matlab.MatrixToString (new Matrix (A)));
                throw new Exception ("Matrix contains NaN");
            }
            if (A [i] [j] - A [j] [i] > EPSILON) return false;
            else A [i] [j] = A [j] [i];
        }
    }
    return true;
}


public boolean equals (Object object) {
    if (object instanceof ZMatrix) {
        ZMatrix m = (ZMatrix) object;
        if (sameSize (m)) {
            for (int i = 0; i < rows; i ++) {
                for (int j = 0; j < columns; j ++) {
                    if (coefficients [i] [j] != m.coefficients [i] [j]) {
                        return false;
                    }
                }
            }
            return true;
        }
    }
    return false;
}


-----Function Pair=57=-----==

public static double satVapPres (double t) {
    double coef [] = {6.1104546, 0.4442351, 1.4302099e-2, 2.6454708e-4, 3.0357098e-6, 2.0972268e-8, 6.0487594e-11, - 1.469687e-13};
    double escold [] = {0.648554685769663908E-01, 0.378319512256073479E-01, 0.222444934288790197E-01, 0.131828928424683120E-01, 0.787402077141244848E-02, 0.473973049488473318E-02, 0.287512035504357928E-02, 0.175743037675810294E-02, 0.108241739518850975E-02, 0.671708939185605941E-03, 0.419964702632039404E-03, 0.264524363863469876E-03, 0.167847963736813220E-03, 0.107285397631620379E-03, 0.690742634496135612E-04, 0.447940489768084267E-04, 0.292570419563937303E-04, 0.192452912634994161E-04, 0.127491372410747951E-04, 0.850507010275505138E-05, 0.571340025334971129E-05, 0.386465029673876238E-05, 0.263210971965005286E-05, 0.180491072930570428E-05, 0.124607850555816049E-05, 0.866070571346870824E-06, 0.605982217668895538E-06, 0.426821197943242768E-06, 0.302616508514379476E-06, 0.215963854234913987E-06, 0.155128954578336869E-06};
    double temp = t - 273.16;
    double retval;
    if (temp != temp) {
        retval = Double.NaN;
    }
    else if (temp > - 50.) {
        retval = (coef [0] + temp * (coef [1] + temp * (coef [2] + temp * (coef [3] + temp * (coef [4] + temp * (coef [5] + temp * (coef [6] + temp * coef [7])))))));
    }
    else {
        double tt = (- temp - 50.) / 5.;
        int inx = (int) tt;
        if (inx < escold.length) {
            retval = escold [inx] + (tt % 1.) * (escold [inx + 1] - escold [inx]);
        }
        else {
            retval = 1e-7;
        }
    }
    return retval;
}


public static double [] normalizeTuple3 (double [] in, double [] out) {
    double x = in [0];
    double y = in [1];
    double z = in [2];
    if (x == 0.0 && y == 0.0 && z == 0.0) {
        out [0] = NORMALIZED_ZERO_TUPLE3_X;
        out [1] = NORMALIZED_ZERO_TUPLE3_Y;
        out [2] = NORMALIZED_ZERO_TUPLE3_Z;
    }
    else {
        double length = Math.sqrt (x * x + y * y + z * z);
        if (length == 0.0) {
            out [0] = NORMALIZED_ZERO_TUPLE3_X;
            out [1] = NORMALIZED_ZERO_TUPLE3_Y;
            out [2] = NORMALIZED_ZERO_TUPLE3_Z;
        }
        else {
            double lengthInv = 1.0 / length;
            out [0] = lengthInv * x;
            out [1] = lengthInv * y;
            out [2] = lengthInv * z;
        }
    }
    return out;
}


-----Function Pair=58=-----==

void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=59=-----==

public void go () {
    memPFrame = pframe;
    subfr = 0;
    if (! rev) {
        if (pframe < (game.npframes - 1)) {
            pframe ++;
        }
        else {
            if (loop) {
                pframe = 0;
            }
            else {
                pframe = game.npframes - 1;
            }
        }
    }
    else {
        if (pframe > 0) {
            pframe --;
        }
        else {
            if (loop) pframe = game.npframes - 1;
            else {
                pframe = 0;
            }
        }
    }
}


private void _cleanUp (Connection con, Statement s, ResultSet rs) {
    if (rs != null) {
        try {
            rs.close ();
        } catch (Exception e) {
        }
    }
    if (s != null) {
        try {
            s.close ();
        } catch (Exception e) {
        }
    }
    if (con != null) {
        try {
            con.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=60=-----==

String substitute (String input, String var, String [] fields, String [] fieldData) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        if (DEBUG) System.out.println ("checking for occurrence of " + var + " in :" + input.substring (oidx));
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        if (input.charAt (idx) != '.') throw new IOException ("no field");
        idx ++;
        int idx_save = idx;
        for (int i = 0; i < fields.length; i ++) {
            String fld = fields [i];
            int flen = fld.length ();
            if (DEBUG) System.out.println ("checking if it is field " + fld);
            if (input.regionMatches (idx, fld, 0, flen)) {
                String value = fieldData [i];
                if (DEBUG) System.out.println ("field matches. outputting data :" + value);
                out.append (value);
                idx += flen;
                break;
            }
        }
        if (idx == idx_save) throw new IOException ("unknown field");
        oidx = idx;
    }
    if (DEBUG) System.out.println ("no more variables left on this line");
    out.append (input.substring (oidx));
    return out.toString ();
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=61=-----==

private boolean evalCond (StreamTokenizer st) throws IOException {
    int val = evalExpr (st);
    int token = st.nextToken ();
    switch (token) {
        case '>' :
            if (st.nextToken () == '=') return val >= evalExpr (st);
            else {
                st.pushBack ();
                return val > evalExpr (st);
            }
        case '<' :
            if (st.nextToken () == '=') return val <= evalExpr (st);
            else {
                st.pushBack ();
                return val < evalExpr (st);
            }
        case '=' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val == evalExpr (st);
        case '!' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val != evalExpr (st);
        default :
            throw new IOException ("Invalid token");
    }
}


private int evalFactor (StreamTokenizer st) throws IOException {
    int tok = st.nextToken ();
    switch (tok) {
        case StreamTokenizer.TT_NUMBER :
            return (int) st.nval;
        case '-' :
            return - evalFactor (st);
        case '~' :
            return ~ evalFactor (st);
        case '(' :
            int val = evalExpr (st);
            if (st.nextToken () != ')') throw new IOException ("Mismatched parentheses");
            return val;
        case StreamTokenizer.TT_WORD :
            if (st.sval.equals ("@LENGTH")) return evalLength (st);
            else throw new IOException ("Invalid token");
        default :
            throw new IOException ("Invalid token");
    }
}


-----Function Pair=62=-----==

public Vector < String > getCompoudCharacterWords (Vector < Character > characters) {
    Vector < String > dictionary_entries = new Vector < String > ();
    BufferedReader reader;
    String line;
    String hanzi_sequence = "";
    for (Character next_character : characters) {
        hanzi_sequence += next_character.traditional;
    }
    try {
        FileInputStream fis = new FileInputStream (cedictFilename);
        InputStreamReader isr = new InputStreamReader (fis, "UTF-8");
        reader = new BufferedReader (isr);
        while ((line = reader.readLine ()) != null) {
            String line_hanzi = line.substring (0, line.indexOf ('['));
            if (line_hanzi.contains (hanzi_sequence)) {
                String formatted_line = "";
                formatted_line += line.substring (0, line.indexOf ('['));
                formatted_line += line.substring (line.indexOf ('[') + 1, line.indexOf (']')) + " ";
                formatted_line += line.substring (line.indexOf ('/') + 1, line.lastIndexOf ('/'));
                dictionary_entries.add (formatted_line);
            }
        }
    } catch (Exception e) {
        System.out.println (e.getMessage ());
    }
    return dictionary_entries;
}


public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (r, section);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (r2, section);
            }
            return removed;
        }
    }
    return removed;
}


-----Function Pair=63=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=64=-----==

protected static Vector < ShippingService > getShippingServices (AuctionPlatform auctionPlatform, AuctionPlatformSite auctionPlatformSite) throws DatabaseInitiationException {
    insureStatus ();
    Vector < ShippingService > result = new Vector < ShippingService > ();
    try {
        Statement statement = PLATFORMDATACONNECTION.createStatement ();
        if (hasStaticData (statement, ExistingStaticData.TYPE_SHIPPINGSERVICES, auctionPlatform, auctionPlatformSite)) {
            if (statement.execute ("select type, name, international, carrier from " + TABLE_SHIPPINGSERVICES + " where apid=" + auctionPlatform.getId () + " and apsid=" + auctionPlatformSite.getCode ())) {
                ResultSet resultSet = statement.getResultSet ();
                while (resultSet.next ()) {
                    result.add (new ShippingService (resultSet.getString (1), resultSet.getString (2), resultSet.getBoolean (3), resultSet.getString (4)));
                }
                resultSet.close ();
            }
            statement.close ();
            return result;
        }
        else {
            statement.close ();
            return null;
        }
    } catch (SQLException sqlException) {
        Logger.log (sqlException);
        return null;
    }
}


public void testBaseSearchRoot () throws LDAPException {
    LDAPConnection con = new LDAPConnection ();
    con.connect ("localhost", 50983);
    Util util = new Util ();
    LDAPSearchResults res = con.search ("dc=nam,dc=compinternal,dc=com", 0, "(objectClass=*)", new String [0], false);
    LDAPAttributeSet attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("objectClass", "domain"));
    attribs.add (new LDAPAttribute ("dc", "nam"));
    LDAPEntry entry = new LDAPEntry ("dc=nam,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("1st entry failed");
    }
    if (res.hasMore ()) {
        fail ("too many entries");
    }
    con.disconnect ();
}


-----Function Pair=65=-----==

private void parse (String name) throws Exception {
    try {
        String line;
        line = br.readLine ();
        File templateFolder = new File ("templates");
        File [] templates = templateFolder.listFiles (new FilenameFilter () {
            public boolean accept (File dir, String name) {
                if (name.endsWith (".xml")) {
                    return true;
                }
                return false;
            }
        }
        );
        SAXBuilder builder = new SAXBuilder ();
        boolean templateFound = false;
        if (templates.length == 0) log.debug ("NO TEMPLATES! Put them to: " + templateFolder.getAbsolutePath ());
        else for (int i = 0; i < templates.length; i ++) {
            Document doc = builder.build (templates [i]);
            if (line.startsWith (doc.getRootElement ().getAttributeValue (XMLConstants.FIRST_LINE_BEGIN_XML))) {
                templateFound = true;
                log.debug ("TEMPLATE: " + templates [i].getName ());
                new Parse (br, result, doc);
                break;
            }
        }
        if (! templateFound) {
            log.debug ("NO template suits!");
            throw new WrongDataException ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
        System.out.println ("READER 241");
        result.addWrongDataFile (name);
    }
}


void makeButtons (JFrame frame) {
    Container content = frame.getContentPane ();
    WindowUtilities.setNativeLookAndFeel ();
    addWindowListener (new ExitListener ());
    content.setBackground (Color.white);
    content.setLayout (new FlowLayout ());
    ImageIcon cup = new ImageIcon ("http://veerex.googlecode.com/files/pdf_icon.jpg");
    JButton button2 = new JButton (cup);
    content.add (button2);
    ImageIcon cup1 = new ImageIcon ("http://veerex.googlecode.com/files/photo_icon.jpg");
    JButton button3 = new JButton (cup1);
    content.add (button3);
    ImageIcon cup2 = new ImageIcon ("http://veerex.googlecode.com/files/docs_icon.jpg");
    JButton button4 = new JButton (cup2);
    button4.setHorizontalTextPosition (SwingConstants.CENTER);
    content.add (button4);
    setVisible (true);
}


-----Function Pair=66=-----==

public static void copyFile (File source, File target) {
    byte [] bf = new byte [1024];
    int l = 0;
    FileInputStream in = null;
    FileOutputStream out = null;
    try {
        in = new FileInputStream (source);
        out = new FileOutputStream (target);
        while ((l = in.read (bf)) != - 1) {
            out.write (bf, 0, l);
        }
        out.flush ();
    } catch (Exception e) {
        Log.e ("uiutil", "copy file error", e);
    } finally {
        try {
            if (in != null) in.close ();
        } catch (IOException e) {
            Log.e ("uiutil", "copy file error", e);
        }
        try {
            if (out != null) out.close ();
        } catch (IOException e) {
            Log.e ("uiutil", "copy file error", e);
        }
    }
}


public static void copyFile (File source, File dest) throws IOException {
    if (! dest.exists ()) {
        dest.createNewFile ();
    }
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (source);
        out = new FileOutputStream (dest);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
    } finally {
        in.close ();
        out.close ();
    }
}


-----Function Pair=67=-----==

public int runPG (String input) {
    try {
        String processName = "cmd /C " + PG_DIR.getAbsolutePath () + "/" + getPGName ();
        Process process = Runtime.getRuntime ().exec (processName);
        G.killThread.setProcess (process);
        InputStream inputStream = process.getInputStream ();
        ByteArrayOutputStream out = new ByteArrayOutputStream ();
        byte [] buffer = new byte [512];
        int size = - 1;
        while ((size = inputStream.read (buffer)) != - 1) {
            out.write (buffer, 0, size);
        }
        out.close ();
        String output = new String (out.toByteArray ());
        System.out.println (String.format ("[%s]:%s", this.pgID, output));
        if (output.trim ().endsWith ("")) return - 1;
        return process.exitValue ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return - 1;
}


private static void drawSheet4 (HSSFSheet sheet4, HSSFWorkbook wb) {
    HSSFPatriarch patriarch = sheet4.createDrawingPatriarch ();
    HSSFTextbox textbox1 = patriarch.createTextbox (new HSSFClientAnchor (0, 0, 0, 0, (short) 1, 1, (short) 2, 2));
    textbox1.setString (new HSSFRichTextString ("This is a test"));
    HSSFTextbox textbox2 = patriarch.createTextbox (new HSSFClientAnchor (0, 0, 900, 100, (short) 3, 3, (short) 3, 4));
    textbox2.setString (new HSSFRichTextString ("Woo"));
    textbox2.setFillColor (200, 0, 0);
    textbox2.setLineStyle (HSSFSimpleShape.LINESTYLE_DOTGEL);
    HSSFTextbox textbox3 = patriarch.createTextbox (new HSSFClientAnchor (0, 0, 900, 100, (short) 4, 4, (short) 5, 4 + 1));
    HSSFFont font = wb.createFont ();
    font.setItalic (true);
    font.setUnderline (HSSFFont.U_DOUBLE);
    HSSFRichTextString string = new HSSFRichTextString ("Woo!!!");
    string.applyFont (2, 5, font);
    textbox3.setString (string);
    textbox3.setFillColor (0x08000030);
    textbox3.setLineStyle (HSSFSimpleShape.LINESTYLE_NONE);
    textbox3.setNoFill (true);
}


-----Function Pair=68=-----==

public HTTPResponse serviceRequest (HTTPRequest req) {
    StringBuffer sb = new StringBuffer ();
    String s = req.url.toString ().substring (SERVLET_PREFIX.length ());
    if (! s.startsWith ("/")) {
        return whoops ();
    }
    String f = s.substring (1);
    String path = (String) files.get (f);
    if (path == null) return whoops ();
    try {
        return fileResponse (path);
    } catch (IOException e) {
        return whoops ();
    }
}


private String getCapTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = - 1;
    if (item != null) type = item.getCapType ();
    if (type == - 1) {
        typeList.append ("<label><input name='captype' type='radio' value='-1' checked>AutoSelect</label><br>\n");
    }
    else {
        typeList.append ("<label><input name='captype' type='radio' value='-1'>AutoSelect</label><br>\n");
    }
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int x = 0; x < capabilities.size (); x ++) {
        CaptureCapability capability = capabilities.get (x);
        typeList.append ("<label><input name='captype' type='radio' value='" + capability.getTypeID () + "' ");
        if (type == capability.getTypeID ()) typeList.append ("checked");
        typeList.append (">" + capability.getName () + "</label><br>\n");
    }
    return typeList.toString ();
}


-----Function Pair=69=-----==

public void addAttachment (TolvenMessageWithAttachments tm, File attachment) throws IOException {
    FileInputStream fi = new FileInputStream (attachment);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    byte buf [] = new byte [100];
    while (true) {
        int count = fi.read (buf);
        if (count < 0) break;
        baos.write (buf, 0, count);
    }
    fi.close ();
    TolvenMessageAttachment tma = new TolvenMessageAttachment ();
    tma.setPayload (baos.toByteArray ());
    tma.setDescription ("Attachment");
    if (attachment.getName ().endsWith (".gif")) {
        tma.setMediaType ("image/gif");
    }
    if (attachment.getName ().endsWith (".jpg") || attachment.getName ().endsWith (".jpeg")) {
        tma.setMediaType ("image/jpeg");
    }
    if (attachment.getName ().endsWith (".png") || attachment.getName ().endsWith (".png")) {
        tma.setMediaType ("image/png");
    }
    if (attachment.getName ().endsWith (".tif") || attachment.getName ().endsWith (".tiff")) {
        tma.setMediaType ("image/tiff");
    }
    tm.getAttachments ().add (tma);
}


private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Run\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=44&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/RunTaskSmall.png' border='0' alt='Delete' title='Run' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("tasks.deftask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("tasks.pretask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("tasks.starterrortask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("tasks.nodataerrortask"));
    return template.getPageBytes ();
}


-----Function Pair=70=-----==

public static InputStream getExcelInputStream (ExcelModule excelModule, String templeteFile) throws Exception {
    ByteArrayOutputStream bao = new ByteArrayOutputStream ();
    FileInputStream fis = new FileInputStream (templeteFile);
    ByteArrayInputStream bas = null;
    HSSFWorkbook wb = new HSSFWorkbook (fis);
    cellStyle = wb.createCellStyle ();
    for (int i = 0; i < wb.getNumberOfSheets (); i ++) {
        HSSFSheet sheet = wb.getSheetAt (i);
        if (sheet == null || sheet.getPhysicalNumberOfRows () == 0) {
            continue;
        }
        if (StringUtil.isNotEmpty (excelModule.getSheetName (i))) {
            wb.setSheetName (i, excelModule.getSheetName (i));
        }
        int strNumRow = getRowNum (sheet);
        setOnceValue (wb, sheet, i, excelModule, strNumRow);
        setMultiValue (wb, sheet, i, excelModule, strNumRow);
    }
    wb.write (bao);
    byte [] ba = bao.toByteArray ();
    bas = new ByteArrayInputStream (ba);
    bao.close ();
    fis.close ();
    return bas;
}


void processAudioData (byte [] buffer, int index, int bytes_per_sample) {
    byte [] dummybuffer = new byte [100];
    int samples_at_11 = 0;
    switch (rate) {
        case 44100 :
            samples_at_11 = 4;
            break;
        case 22050 :
            samples_at_11 = 2;
            break;
        case 11025 :
            samples_at_11 = 1;
            break;
        default :
            System.out.println ("Huh? Here is my rate: " + rate);
    }
    int samplestoskip = samples_at_11 - 1;
    if (channels == 2) {
        samplestoskip += samples_at_11;
    }
    int bytestoskip = samplestoskip * (bits_per_sample / 8);
    System.out.println ("Bytes to skip: " + bytestoskip);
    System.out.println ("Samples to skip: " + samplestoskip);
    ByteArrayInputStream in = new ByteArrayInputStream (buffer);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    while (in.available () > 0) {
        baos.write (in.read ());
        if (bits_per_sample == 16) baos.write (in.read ());
        else baos.write (0);
        try {
            if (bytestoskip != 0) {
                int amount = in.read (dummybuffer, 0, bytestoskip);
                if (amount != bytestoskip) System.out.println ("MASSIVE PROBLEM, could not dummy buffer read: " + in.available () + ", " + amount);
            }
        } catch (Exception e) {
            System.out.println ("BAD BAD BAD " + e);
            System.out.println ("Length requested: " + bytes_per_sample);
            throw new RuntimeException (e.toString ());
        }
    }
    audiodata = baos.toByteArray ();
}


-----Function Pair=71=-----==

private static byte [] readBytes (File file) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    try {
        InputStream fis = new FileInputStream (file);
        InputStream is = new BufferedInputStream (fis);
        int count = 0;
        byte [] buf = new byte [16384];
        while ((count = is.read (buf)) != - 1) {
            if (count > 0) baos.write (buf, 0, count);
        }
        is.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return baos.toByteArray ();
}


private static char [] readChars (File file) {
    CharArrayWriter caw = new CharArrayWriter ();
    try {
        Reader fr = new FileReader (file);
        Reader in = new BufferedReader (fr);
        int count = 0;
        char [] buf = new char [16384];
        while ((count = in.read (buf)) != - 1) {
            if (count > 0) caw.write (buf, 0, count);
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return caw.toCharArray ();
}


-----Function Pair=72=-----==

public static void pipeStream (InputStream in, OutputStream out, int bufSize) throws IOException {
    try {
        byte [] buf = new byte [bufSize];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
    } finally {
        try {
            in.close ();
            out.close ();
        } catch (IOException e) {
            System.err.println ("WARNING: Could not close stream.");
        }
    }
}


public static File getFileFromBytes (byte [] b, String outputFile) {
    BufferedOutputStream stream = null;
    File file = null;
    try {
        file = new File (outputFile);
        FileOutputStream fstream = new FileOutputStream (file);
        stream = new BufferedOutputStream (fstream);
        stream.write (b);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (IOException e1) {
                e1.printStackTrace ();
            }
        }
    }
    return file;
}


-----Function Pair=73=-----==

private int getSchTblData (ScheduleItem [] itemsArray, StringBuffer content, boolean showOverlapStatus) throws Exception {
    Calendar dateFormater = Calendar.getInstance ();
    String rowHi = "class='rowHi'";
    String rowLo = "class='rowLow'";
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        dateFormater.setTime (item.getStart ());
        String type = "";
        if (item.getType () == ScheduleItem.ONCE) type = "Once";
        else if (item.getType () == ScheduleItem.DAILY) type = "Daily";
        else if (item.getType () == ScheduleItem.WEEKLY) type = "Weekly";
        else if (item.getType () == ScheduleItem.MONTHLY) type = "Monthly";
        else if (item.getType () == ScheduleItem.WEEKDAY) type = "Week Day";
        else if (item.getType () == ScheduleItem.EPG) type = "EPG";
        else type = "?" + item.getType () + "?";
        content.append ("<tr ");
        if (x % 2 == 0) content.append (rowHi + " >");
        else content.append (rowLo + " >");
        content.append ("<td class='itemdata'>");
        Vector < String > warnings = item.getWarnings ();
        if (warnings.size () > 0) {
            String waringText = "";
            for (int warnIndex = 0; warnIndex < warnings.size (); warnIndex ++) {
                waringText += " - " + warnings.get (warnIndex) + "\\n";
            }
            content.append ("<img alt='Warning' title='This Schedule has Warnings' onClick=\"warningBox('" + waringText + "', '" + item.toString () + "');\" " + "src='/images/exclaim24.png' border='0' width='22' height='24' style='cursor: pointer; cursor: hand;''> ");
        }
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (showOverlapStatus) {
            int depth = overlapDepth (item);
            if (depth > devList.getDeviceCount ()) content.append ("<img alt='To many overlapping items (" + depth + ")' title='To many overlapping items (" + depth + ")' " + "src='/images/exclaim24.png' border='0' width='22' height='24'> ");
            else content.append ("<img alt='(" + depth + ")' title='(" + depth + ")' " + "src='/images/tick.png' border='0' alt='Ok' width='24' height='24'> ");
        }
        content.append ("<a href='/servlet/ScheduleDataRes?action=07&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
        content.append ("<img src='/images/log.png' border='0' alt='Schedule Log' width='24' height='24'></a> ");
        Calendar viewDate = Calendar.getInstance ();
        viewDate.setTime (dateFormater.getTime ());
        if (viewDate.get (Calendar.HOUR_OF_DAY) <= 6) viewDate.add (Calendar.DATE, - 1);
        String egpUrl = "/servlet/EpgDataRes?action=12&year=" + viewDate.get (Calendar.YEAR) + "&month=" + (viewDate.get (Calendar.MONTH) + 1) + "&day=" + viewDate.get (Calendar.DATE) + "&scrollto=" + viewDate.get (Calendar.HOUR_OF_DAY);
        content.append ("<a href='" + egpUrl + "'>");
        content.append ("<img src='/images/epglink.png' border='0' alt='EPG Link' width='24' height='24'></a>\n");
        content.append ("</td>\n");
        content.append ("<td class='itemdata'>" + item.getName () + "</td>\n");
        int hour = dateFormater.get (Calendar.HOUR);
        if (hour == 0) hour = 12;
        String timeString = store.intToStr (hour) + ":" + store.intToStr (dateFormater.get (Calendar.MINUTE)) + " " + store.ampm.get (new Integer (dateFormater.get (Calendar.AM_PM)));
        content.append ("<td class='itemdata'><b>" + timeString + "</b></td>\n");
        String dateString = store.dayName.get (new Integer (dateFormater.get (Calendar.DAY_OF_WEEK))) + ", " + dateFormater.get (Calendar.DATE) + " " + store.monthNameShort.get (new Integer (dateFormater.get (Calendar.MONTH)));
        content.append ("<td class='itemdata'>" + dateString + "</td>\n");
        content.append ("<td class='itemdata'>" + item.getDuration () + "min</td>\n");
        content.append ("<td class='itemdata'>");
        content.append (item.getChannel ());
        content.append ("</td>\n");
        content.append ("<td class='itemdata'>" + type + "</td>\n");
        content.append ("<td class='itemdata'>" + item.getStatus () + "</td>\n");
        content.append ("<td class='itemdata'>");
        if (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.ERROR) {
            content.append ("<a onClick='return confirmAction(\"Delete\");' href='/servlet/ScheduleDataRes?action=04&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/delete.png' border='0' alt='Delete' width='24' height='24'></a>\n");
            if (item.getType () != ScheduleItem.EPG) {
                Calendar cal = Calendar.getInstance ();
                cal.setTime (item.getStart ());
                content.append (" <a href='/servlet/ScheduleDataRes?action=01&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "&month=" + cal.get (Calendar.MONTH) + "&year=" + cal.get (Calendar.YEAR) + "'>");
                content.append ("<img src='/images/edit.png' border='0' alt='Edit' width='24' height='24'></a>\n");
                content.append ("<a href='/servlet/ScheduleDataRes?action=05&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
                content.append ("<img src='/images/+5.png' border='0' alt='Add Time' width='24' height='24'></a>\n");
            }
            if (item.getType () == ScheduleItem.DAILY || item.getType () == ScheduleItem.WEEKLY || item.getType () == ScheduleItem.MONTHLY || item.getType () == ScheduleItem.WEEKDAY) {
                content.append ("<a href='/servlet/ScheduleDataRes?action=06&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
                content.append ("<img src='/images/skip.png' border='0' alt='Skip' width='24' height='24'></a>\n");
            }
        }
        if (item.getState () == ScheduleItem.RUNNING) {
            content.append ("<a onClick='return confirmAction(\"Stop\");' href='/servlet/ScheduleDataRes?action=09&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/stop.png' border='0' alt='Stop' width='24' height='24'></a>\n");
            content.append ("<a href='/servlet/ScheduleDataRes?action=05&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "'>");
            content.append ("<img src='/images/+5.png' border='0' alt='Add Time' width='24' height='24'></a>\n");
        }
        content.append ("</td>\n");
        content.append ("</tr>\n");
    }
    return 0;
}


private byte [] addScheduleFromGuideItem (HTTPurl urlData) throws Exception {
    String channel = urlData.getParameter ("channel");
    String id = urlData.getParameter ("id");
    GuideStore guide = GuideStore.getInstance ();
    String epgChan = guide.getEpgChannelFromMap (channel);
    GuideItem guideItem = guide.getProgram (epgChan, id);
    if (epgChan == null || epgChan.length () == 0) throw new Exception ("WS Channel Not Found!");
    int captype = - 1;
    ScheduleItem schItem = new ScheduleItem (guideItem, channel, captype, store.rand.nextLong (), false);
    String task = store.getProperty ("tasks.deftask");
    schItem.setPostTask (task);
    int startBuff = 0;
    int endBuff = 0;
    int endBuffEpg = 0;
    try {
        startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
        endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
        endBuffEpg = Integer.parseInt (store.getProperty ("schedule.buffer.end.epg"));
    } catch (Exception e) {
    }
    String [] patterns = store.getNamePatterns ();
    schItem.setFilePattern (patterns [0]);
    String keepFor = store.getProperty ("autodel.keepfor");
    int keepInt = 30;
    try {
        keepInt = Integer.parseInt (keepFor);
    } catch (Exception e) {
    }
    schItem.setKeepFor (keepInt);
    schItem.setCapType (captype);
    Calendar cal = Calendar.getInstance ();
    cal.setTime (schItem.getStart ());
    cal.add (Calendar.MINUTE, (startBuff * - 1));
    if (endBuffEpg > 0) {
        endBuffEpg = endBuffEpg * (int) (guideItem.getDuration () / 60);
    }
    schItem.setDuration (guideItem.getDuration () + startBuff + endBuff + endBuffEpg);
    schItem.setStart (cal);
    schItem.setType (ScheduleItem.ONCE);
    schItem.log ("New Schedule added/edited");
    boolean isAlreadyInList = guide.isAlreadyInList (schItem, 1);
    if (! isAlreadyInList) {
        store.addScheduleItem (schItem);
    }
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    StringBuffer out = new StringBuffer (4096);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=74=-----==

public FileAdapterAttributeValue (XACMLElement engineElem) throws Exception {
    this.engineElem = engineElem;
    AttributeValue attrVal = (AttributeValue) engineElem;
    if (this.engineElem.getElementName () == null) {
        this.engineElem.setElementName (ELEMENT_NAME);
    }
    xmlElement = createPolicyElement ();
    xmlElement.setAttribute (ATTR_DATATYPE, attrVal.getDataType ().toString ());
    Expression childExp = attrVal.getChildExpression ();
    if (childExp != null) {
        Class < ? > dataAdapterClz = getPolicyDataAdapterClassByXACMLElementType (childExp.getClass ());
        Constructor < ? > daConstr = dataAdapterClz.getConstructor (XACMLElement.class);
        DataAdapter da = (DataAdapter) daConstr.newInstance (childExp);
        xmlElement.appendChild ((Element) da.getDataStoreObject ());
    }
    else {
        xmlElement.appendChild (getDefaultDocument ().createTextNode (attrVal.getValue ().toString ()));
    }
}


public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


-----Function Pair=75=-----==

private void browserDiagnosticTest () {
    ClassLoader classLoader = Controller.class.getClassLoader ();
    Class < ? > jsObjectClass;
    try {
        jsObjectClass = classLoader.loadClass ("netscape.javascript.JSObject");
    } catch (ClassNotFoundException e) {
        addDetailMessage ("JSObject class not found");
        addDetailMessage ("not running inside a browser?");
        this.view.addTestResult (DiagnosticTests.BROWSER, false, e.getMessage ());
        return;
    }
    try {
        Method getWindowMethod = jsObjectClass.getMethod ("getWindow", new Class < ? > [] {java.applet.Applet.class});
        Method getMemberMethod = jsObjectClass.getMethod ("getMember", new Class < ? > [] {String.class});
        Object windowJSObject = getWindowMethod.invoke (null, this.runtime.getApplet ());
        Object navigatorJSObject = getMemberMethod.invoke (windowJSObject, "navigator");
        Object userAgent = getMemberMethod.invoke (navigatorJSObject, "userAgent");
        addDetailMessage ("user agent: " + userAgent);
        this.view.addTestResult (DiagnosticTests.BROWSER, true, userAgent.toString ());
    } catch (Exception e) {
        this.view.addTestResult (DiagnosticTests.BROWSER, false, e.getMessage ());
        return;
    }
}


public static Class [] getStaticClasses (Class cl) {
    Class [] clazzes = cl.getClasses ();
    if (clazzes == null) return null;
    Vector vec = new Vector ();
    int n = clazzes.length;
    for (int i = 0; i < n; i ++) {
        Class clazz = clazzes [i];
        if (isStatic (clazz)) {
            vec.add (clazz);
        }
    }
    if (vec.size () == 0) {
        return null;
    }
    Class [] out = new Class [vec.size ()];
    vec.toArray (out);
    return out;
}


-----Function Pair=76=-----=1=

public MarshalledObject newInstance (ActivationID id, ActivationDesc desc) throws ActivationException, RemoteException {
    try {
        if (ActivationSystemTransient.debug) System.out.println ("Instantiating " + desc.getClassName ());
        Remote object;
        Class objectClass;
        ClassLoader loader = Thread.currentThread ().getContextClassLoader ();
        objectClass = loader.loadClass (desc.getClassName ());
        Constructor constructor = objectClass.getConstructor (cConstructorTypes);
        object = (Remote) constructor.newInstance (new Object [] {id, desc.getData ()});
        ActivatableServerRef ref = UnicastServer.getActivatableRef (id);
        Remote stub = ref.exportObject (object);
        MarshalledObject marsh = new MarshalledObject (stub);
        activeObject (id, marsh);
        activeObject (id, stub);
        return marsh;
    } catch (Exception e) {
        ActivationException acex = new ActivationException ("Unable to activate " + desc.getClassName () + " from " + desc.getLocation (), e);
        throw acex;
    }
}


public < T extends Provider > T newProxyInstance () {
    long num = getUniqueNumber ();
    String proxyPkg = "";
    if (! Modifier.isPublic (providerType.getModifiers ())) {
        String name = providerType.getName ();
        int n = name.lastIndexOf ('.');
        proxyPkg = ((n == - 1) ? "" : name.substring (0, n + 1));
    }
    String proxyName = proxyPkg + proxyClassNamePrefix + num;
    Class < ? > proxyClass = null;
    byte [] proxyClassFile = ProxyGenerator.generateProxyClass (proxyName, new Class < ? > [] {providerType});
    try {
        proxyClass = JVM.defineClass (providerType.getClassLoader (), proxyName, proxyClassFile, 0, proxyClassFile.length);
    } catch (ClassFormatError e) {
        throw new IllegalArgumentException (e.toString ());
    }
    try {
        Constructor cons = proxyClass.getConstructor (constructorParams);
        return (T) cons.newInstance (new Object [] {this});
    } catch (NoSuchMethodException e) {
        throw new InternalError (e.toString ());
    } catch (IllegalAccessException e) {
        throw new InternalError (e.toString ());
    } catch (InstantiationException e) {
        throw new InternalError (e.toString ());
    } catch (InvocationTargetException e) {
        throw new InternalError (e.toString ());
    }
}


-----Function Pair=77=-----==

private static Object invokeInner (Object referer, Method method, Object [] params) throws IOException {
    Object back = null;
    try {
        back = method.invoke (referer, params);
    } catch (IllegalArgumentException e_ia) {
        StringBuffer sb = new StringBuffer ();
        if (params != null) {
            for (int i = 0; i < params.length; i ++) {
                sb.append (params [i].getClass ());
                sb.append (" ");
            }
        }
        else {
            sb.append (" no parameters");
        }
        logger.error (method.toString () + " has not arguments as " + sb.toString () + " for instance " + referer.getClass ().getName () + " " + referer.toString ());
    } catch (IllegalAccessException e_iacc) {
        logger.error (method.getName () + " is not accessible");
    } catch (InvocationTargetException e_it) {
        logger.error (method.getName () + " generated an exception on " + referer + " : ");
        e_it.getCause ().printStackTrace ();
    }
    return back;
}


private static DataSource reflectMDS (String cname, Object pds) {
    Class cls;
    Constructor cc;
    Class [] paramTypes = new Class [1];
    Object [] arg = new Object [1];
    try {
        cls = Class.forName (cname);
        paramTypes [0] = pds.getClass ();
        cc = cls.getConstructor (paramTypes);
        if (cname.indexOf ("PullDataSource") >= 0) {
            arg [0] = (PullDataSource []) pds;
        }
        else if (cname.indexOf ("PushDataSource") >= 0) {
            arg [0] = (PushDataSource []) pds;
        }
        else if (cname.indexOf ("PullBufferDataSource") >= 0) {
            arg [0] = (PullBufferDataSource []) pds;
        }
        else if (cname.indexOf ("PushBufferDataSource") >= 0) {
            arg [0] = (PushBufferDataSource []) pds;
        }
        else if (cname.indexOf ("CDPushBDS") >= 0) {
            arg [0] = (PushBufferDataSource []) pds;
        }
        return (DataSource) (cc.newInstance (arg));
    } catch (Exception ex) {
    }
    return null;
}


-----Function Pair=78=-----=1=

public DataImpl open (String id) throws BadFormException, IOException, VisADException {
    String header = getClass ().getName () + ".open(String): ";
    DataImpl data;
    try {
        Class sourceClass = Class.forName (getClass ().getPackage ().getName () + ".DODSSource");
        DataInputStream source = (DataInputStream) sourceClass.getConstructor (new Class [0]).newInstance (new Object [0]);
        sourceClass.getMethod ("open", new Class [] {String.class}).invoke (source, new Object [] {id});
        data = new Consolidator (new TimeFactorer (source)).readData ();
    } catch (ClassNotFoundException e) {
        throw new VisADException (header + e + ".  " + sourceMessage);
    } catch (NoSuchMethodException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (SecurityException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (InstantiationException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (IllegalAccessException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (IllegalArgumentException e) {
        throw new VisADException (header + e + contactMessage);
    } catch (InvocationTargetException e) {
        throw new VisADException (e.getTargetException ().getMessage ());
    }
    return data;
}


private Documentor getDocumentorFromAnnotation (final Class < ? > testClass, NakedObjectConfiguration configuration) throws InitializationError {
    final DocumentUsing documentUsingAnnotation = testClass.getAnnotation (DocumentUsing.class);
    if (documentUsingAnnotation == null) {
        return null;
    }
    final Class < ? extends Documentor > documentorClass = documentUsingAnnotation.value ();
    try {
        Constructor < ? extends Documentor > constructor = documentorClass.getConstructor (new Class [] {NakedObjectConfiguration.class, String.class});
        return constructor.newInstance (configuration, testClass.getCanonicalName ());
    } catch (SecurityException e) {
        throw new RuntimeException (e);
    } catch (IllegalArgumentException e) {
        throw new RuntimeException (e);
    } catch (InstantiationException e) {
        throw new RuntimeException (e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException (e);
    } catch (InvocationTargetException e) {
        throw new RuntimeException (e);
    } catch (NoSuchMethodException e) {
    }
    try {
        return documentorClass.newInstance ();
    } catch (InstantiationException e) {
        throw new RuntimeException (e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException (e);
    }
}


-----Function Pair=79=-----=1=

static Object createProxy (Object proxyMe) {
    InvocationHandler handler = new MyInvocationHandler (proxyMe);
    Class proxyClass = Proxy.getProxyClass (Shapes.class.getClassLoader (), new Class [] {Quads.class, Colors.class});
    Object proxy = null;
    try {
        Constructor < Class > cons;
        cons = proxyClass.getConstructor (new Class [] {InvocationHandler.class});
        proxy = cons.newInstance (new Object [] {handler});
    } catch (NoSuchMethodException nsme) {
        System.err.println ("failed: " + nsme);
    } catch (InstantiationException ie) {
        System.err.println ("failed: " + ie);
    } catch (IllegalAccessException ie) {
        System.err.println ("failed: " + ie);
    } catch (InvocationTargetException ite) {
        System.err.println ("failed: " + ite);
    }
    return proxy;
}


static Object createProxy (Object proxyMe) {
    InvocationHandler handler = new MyInvocationHandler (proxyMe);
    Class proxyClass = Proxy.getProxyClass (Shapes.class.getClassLoader (), new Class [] {Quads.class, Colors.class});
    Object proxy = null;
    try {
        Constructor < Class > cons;
        cons = proxyClass.getConstructor (new Class [] {InvocationHandler.class});
        proxy = cons.newInstance (new Object [] {handler});
    } catch (NoSuchMethodException nsme) {
        System.err.println ("failed: " + nsme);
    } catch (InstantiationException ie) {
        System.err.println ("failed: " + ie);
    } catch (IllegalAccessException ie) {
        System.err.println ("failed: " + ie);
    } catch (InvocationTargetException ite) {
        System.err.println ("failed: " + ite);
    }
    return proxy;
}


-----Function Pair=80=-----==

public Enumeration availableWizards (final String type, final boolean withTemplates) {
    if (withTemplates) {
        final Vector allWizards = new Vector ();
        if (type.equals (WizardDefinition.ALL)) {
            allWizards.addAll (templateWizardDefs.keySet ());
            allWizards.addAll (wizardDefs.keySet ());
        }
        else {
            if ((Vector) templateTypeVsDefVector.get (type) != null) {
                allWizards.addAll ((Vector) templateTypeVsDefVector.get (type));
            }
            if ((Vector) typeVsDefVector.get (type) != null) {
                allWizards.addAll ((Vector) typeVsDefVector.get (type));
            }
        }
        return allWizards.elements ();
    }
    else {
        if (type.equals (WizardDefinition.ALL)) {
            return wizardDefs.keys ();
        }
        else {
            Vector tmp = (Vector) typeVsDefVector.get (type);
            if (tmp == null) {
                tmp = new Vector ();
            }
            return tmp.elements ();
        }
    }
}


public String readParameter (String name, boolean required) {
    if (inAnApplet) {
        String s = getParameter (name);
        if ((s == null) && required) {
            fatalError (name + " parameter not specified");
        }
        return s;
    }
    for (int i = 0; i < mainArgs.length; i += 2) {
        if (mainArgs [i].equalsIgnoreCase (name)) {
            try {
                return mainArgs [i + 1];
            } catch (Exception e) {
                if (required) {
                    fatalError (name + " parameter not specified");
                }
                return null;
            }
        }
    }
    if (required) {
        fatalError (name + " parameter not specified");
    }
    return null;
}


-----Function Pair=81=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=82=-----=1=

private void testBtnActionPerformed (java.awt.event.ActionEvent evt) {
    Process p = null;
    Runtime r = Runtime.getRuntime ();
    try {
        p = r.exec ("cmd.exe /c gammu identify");
        BufferedReader rd = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        String temp = "";
        String s = "";
        while ((temp = rd.readLine ()) != null) {
            s += temp + "\n";
        }
        txtTestConn.setText (s);
    } catch (IOException ex) {
        ex.getMessage ();
    }
}


public void run () {
    try {
        if (this.finished == false) {
            Runtime runner = Runtime.getRuntime ();
            process = runner.exec (command);
            new ProcessInputReaderThread (process.getInputStream (), out);
            new ProcessInputReaderThread (process.getErrorStream (), err);
            exitCode = new Integer (process.waitFor ());
        }
    } catch (Exception e) {
        err.append ("Error running command.\n");
        ByteArrayOutputStream ba = new ByteArrayOutputStream ();
        PrintWriter errData = new PrintWriter (ba);
        e.printStackTrace (errData);
        errData.flush ();
        err.append (ba.toString ());
        e.printStackTrace ();
    }
    this.finished = true;
}


-----Function Pair=83=-----==

public boolean validateMethodGetUserArg () throws Exception {
    String testRoot = TEST_MethodGetUserArg;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("ua1", "ua1");
    sReferencePS.set ("ua2", "ua2");
    sReferencePS.set ("ua3", "ua3");
    sReferencePS.set ("ua4", "ua4");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


public boolean validateMethodLeft () throws Exception {
    String testRoot = TEST_MethodLeft;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("a", "[a]");
    sReferencePS.set ("b", "[a  ]");
    sReferencePS.set ("c", "[aa ]");
    sReferencePS.set ("d", "[aaa]");
    sReferencePS.set ("e", "[aaaa]");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=84=-----==

private byte [] moveTunerDown (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount () - 1) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex + 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


private byte [] moveTunerUp (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex > 0 && tunerIndex < devList.getDeviceCount ()) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex - 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=85=-----=1=

private void sendMailMany (Set recipients, String subject, String message, String from) throws MessagingException {
    boolean debug = false;
    List emails = new ArrayList ();
    for (Iterator iter = recipients.iterator (); iter.hasNext ();) {
        User user = (User) iter.next ();
        emails.add (user.getEmail ());
    }
    String [] rec = new String [emails.size ()];
    for (int i = 0; i < emails.size (); i ++) {
        rec [i] = (String) ((emails.toArray ()) [i]);
    }
    Properties props = new Properties ();
    props.put ("mail.smtp.host", Portlets.getPortalConfig ("smtp"));
    props.put ("mail.mime.charset", Portlets.getPortalConfig ("charset"));
    Session session = Session.getDefaultInstance (props, null);
    session.setDebug (debug);
    Message msg = new MimeMessage (session);
    InternetAddress addressFrom = new InternetAddress (from);
    msg.setFrom (addressFrom);
    InternetAddress [] addressTo = new InternetAddress [rec.length];
    for (int i = 0; i < rec.length; i ++) {
        addressTo [i] = new InternetAddress (rec [i]);
    }
    if (privacy.compareTo (MailListPortlet.PUBLIC) == 0) {
        msg.setRecipients (Message.RecipientType.TO, addressTo);
    }
    else if (privacy.compareTo (MailListPortlet.PRIVATE) == 0) {
        msg.setRecipients (Message.RecipientType.BCC, addressTo);
    }
    else {
        System.out.println ("Napačen tip vidnosti naslovov!");
    }
    msg.setSubject (subject);
    msg.setContent (message, "text/plain; charset=" + Portlets.getPortalConfig ("charset"));
    Transport.send (msg);
}


public void doPost (HttpServletRequest request, HttpServletResponse response) throws IOException, NullPointerException {
    PrintWriter out = response.getWriter ();
    response.setContentType ("text/html");
    response.setHeader ("Pragma", "No-cache");
    if (User.checkLoginCookie (request.getCookies ())) {
        String from = request.getParameter ("from");
        String subject = request.getParameter ("subject");
        String to = request.getParameter ("to");
        String bcc = request.getParameter ("bcc");
        String cc = request.getParameter ("cc");
        String content = request.getParameter ("content");
        String lid = request.getParameter ("lid");
        String mid = request.getParameter ("mid");
        String ref = request.getParameter ("ref");
        try {
            Properties props = new Properties ();
            props.put ("mail.smtp.host", "localhost");
            Session mailsession = Session.getDefaultInstance (props, null);
            Message email = new MimeMessage (mailsession);
            email.setFrom (new InternetAddress (from));
            InternetAddress [] address = {new InternetAddress (to)};
            email.setRecipients (Message.RecipientType.TO, address);
            if (! bcc.equals ("")) {
                InternetAddress [] bccaddress = {new InternetAddress (bcc)};
                email.addRecipients (Message.RecipientType.BCC, bccaddress);
            }
            if (! cc.equals ("")) {
                InternetAddress [] ccaddress = {new InternetAddress (cc)};
                email.addRecipients (Message.RecipientType.CC, ccaddress);
            }
            email.setSubject (subject);
            email.setText (content);
            Transport.send (email);
            HTMLSettings.printHeader (out, "Send Successful");
            if (ref.equals ("showMessage")) out.println ("Message sent successfully.  <a href=my?action=showMessage&lid=" + lid + "&mid=" + mid + ">Return</a> to lists.");
            else out.println ("Message sent successfully.  <a href=my?action=showList&lid=" + lid + ">Return</a> to lists.");
        } catch (MessagingException e) {
            System.out.println (e);
        }
    }
    else {
        HTMLSettings.printHeader (out, "Please log in");
        out.println ("<p>Please login <a href=login?referrer=" + request.getRequestURI () + ">here</a></p>");
    }
}


-----Function Pair=86=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void displayDiffResults () throws IOException {
    File outFile = File.createTempFile ("diff", ".htm");
    outFile.deleteOnExit ();
    FileOutputStream outStream = new FileOutputStream (outFile);
    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));
    out.write ("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
    if (addedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
        out.write (addedTable.toString ());
        out.write ("</table><br><br>");
    }
    if (modifiedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
        out.write (modifiedTable.toString ());
        out.write ("</table><br><br>");
    }
    if (deletedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
        out.write (deletedTable.toString ());
        out.write ("</table><br><br>");
    }
    out.write ("<table name=METRICS BORDER>\n");
    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {
        out.write ("<tr><td>Base:&nbsp;</td><td>");
        out.write (Long.toString (base));
        out.write ("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
        out.write (Long.toString (deleted));
        out.write ("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
        out.write (Long.toString (modified));
        out.write ("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
        out.write (Long.toString (added));
        out.write ("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
        out.write (Long.toString (added + modified));
        out.write ("</td></tr>\n");
    }
    out.write ("<tr><td>Total:&nbsp;</td><td>");
    out.write (Long.toString (total));
    out.write ("</td></tr>\n</table></div>");
    redlinesOut.close ();
    out.flush ();
    InputStream redlines = new FileInputStream (redlinesTempFile);
    byte [] buffer = new byte [4096];
    int bytesRead;
    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);
    outStream.write ("</BODY></HTML>".getBytes ());
    outStream.close ();
    Browser.launch (outFile.toURL ().toString ());
}


-----Function Pair=87=-----==

public pspdiffDialog (TinyWebServer webServer) {
    this.webServer = webServer;
    frame = new JFrame ("Compare Files/Directories");
    frame.setIconImage (java.awt.Toolkit.getDefaultToolkit ().createImage (PSPDiff.class.getResource ("icon32.gif")));
    Box vBox = Box.createVerticalBox ();
    Box hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Original file/directory (optional):"));
    hBox.add (hBox.createHorizontalStrut (150));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileA = new JTextField ());
    dontStretchVertically (fileA);
    hBox.add (browseA = new JButton ("Browse..."));
    browseA.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Modified/new file/directory:"));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileB = new JTextField ());
    dontStretchVertically (fileB);
    hBox.add (browseB = new JButton ("Browse..."));
    browseB.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (compareButton = new JButton ("Compare"));
    compareButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (closeButton = new JButton ("Close"));
    closeButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    frame.getContentPane ().add (vBox);
    frame.pack ();
    frame.show ();
}


private void initComponents () {
    initMenu ();
    drawer = new GraphDrawer ();
    drawer_Sch = new ScheduleDrawer ();
    gSource = new JPanel (new BorderLayout ());
    sSource = new JPanel (new BorderLayout ());
    jScrollPane1 = new JScrollPane (drawer);
    jScrollPane2 = new JScrollPane (drawer_Sch);
    jScrollPane3 = new JScrollPane (gSource);
    jScrollPane4 = new JScrollPane (sSource);
    jpGraph.add (jScrollPane1, BorderLayout.CENTER);
    jpShedule.add (jScrollPane2, BorderLayout.CENTER);
    jpgSource.add (jScrollPane3, BorderLayout.CENTER);
    jpsSource.add (jScrollPane4, BorderLayout.CENTER);
    jtp.addTab ("Graph", jpGraph);
    jtp.addTab ("GraphSource", jpgSource);
    jtp.addTab ("Schedule", jpShedule);
    jtp.addTab ("ScheduleSource", jpsSource);
    getContentPane ().add (jtp);
    jtp.removeTabAt (3);
    jtp.removeTabAt (2);
    setJMenuBar (jMenuBar1);
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            System.exit (0);
        } public void windowClosed (WindowEvent e) {
            System.exit (0);
        }
    }
    );
    miOpenS.setEnabled (false);
    miSaveG.setEnabled (false);
    miSaveGAs.setEnabled (false);
    miSaveS.setEnabled (false);
    miSaveSAs.setEnabled (false);
}


-----Function Pair=88=-----==

private void SaveObjet () {
    if (AllowSave) {
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Name = Ed_Nom.getText ();
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Explication = Ed_Explication.getText ();
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Chipset = Ed_Chipset.getText ();
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).X = Integer.parseInt (Ed_X.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Y = Integer.parseInt (Ed_Y.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).W = (short) Integer.parseInt (Ed_W.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).H = (short) Integer.parseInt (Ed_H.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Prix = Integer.parseInt (Ed_Prix.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).LvlMin = (short) Integer.parseInt (Ed_LvlMin.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Attaque = (short) Integer.parseInt (Ed_Attaque.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Defense = (short) Integer.parseInt (Ed_Defense.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).PV = Integer.parseInt (Ed_PV.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).PM = Integer.parseInt (Ed_PM.getText ());
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).Classe = (short) CB_Classe.getSelectedIndex ();
        parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).MagieAssoc = (short) CB_MagieAssoc.getSelectedIndex ();
        if (RB_Utilise.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 0;
        if (RB_Armeunemain.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 1;
        if (RB_Armedeuxmain.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 2;
        if (RB_Casque.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 3;
        if (RB_Armure.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 4;
        if (RB_Bouclier.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 5;
        if (RB_Objetquete.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 6;
        if (RB_Livremagie.isSelected ()) parent.general.getObjetByIndex (ObjetList.getSelectedIndex ()).ObjType = 7;
    }
}


public void keyPressed (KeyEvent e) {
    if (player.getVidas () > 0) {
        if (e.getKeyCode () == e.VK_ESCAPE) {
            tiemponivel = (int) (System.currentTimeMillis () / 1000);
            juegonuevo = false;
            opcion = 0;
            juego_empezado = false;
            en_menu_principal = true;
            repaint ();
        }
        aviso_teclas = false;
        if (sin_asignar) {
            atras = e.VK_LEFT;
            salto = e.VK_A;
            adelante = e.VK_RIGHT;
            disparo = e.VK_S;
            sin_asignar = false;
        }
        if (opcion2 == 1) {
            atras = e.getKeyCode ();
            opcion2 = 5;
            repaint ();
        }
        if (opcion2 == 2) {
            salto = e.getKeyCode ();
            opcion2 = 5;
            repaint ();
        }
        if (opcion2 == 3) {
            adelante = e.getKeyCode ();
            opcion2 = 5;
            repaint ();
        }
        if (opcion2 == 4) {
            disparo = e.getKeyCode ();
            opcion2 = 5;
            repaint ();
        }
        if (opcion2 == 0) {
            if (e.getKeyCode () == e.VK_LEFT) {
                player.setCaminaIzq (true);
            }
            if (e.getKeyCode () == e.VK_RIGHT) {
                player.setCaminaDer (true);
            }
            if (e.getKeyCode () == e.VK_A) {
                player.setSalta (true);
            }
            if (e.getKeyCode () == e.VK_S) {
                for (int i = 0; i < rayo.length; i ++) {
                    if (rayo [i].getMoviendo () == false) {
                        rayo [i].setMoviendo (true);
                        rayo [i].setRayoX (player.getPosXDer ());
                        rayo [i].setRayoY (player.getPosYAba () - Constantes.jugador_height / 2);
                        break;
                    }
                }
            }
        }
        else {
            if (e.getKeyCode () == atras) {
                player.setCaminaIzq (true);
            }
            if (e.getKeyCode () == adelante) {
                player.setCaminaDer (true);
            }
            if (e.getKeyCode () == salto) {
                player.setSalta (true);
            }
            if (e.getKeyCode () == disparo) {
                for (int i = 0; i < rayo.length; i ++) {
                    if (rayo [i].getMoviendo () == false) {
                        rayo [i].setMoviendo (true);
                        rayo [i].setRayoX (player.getPosXDer ());
                        rayo [i].setRayoY (player.getPosYAba () - Constantes.jugador_height / 2);
                        break;
                    }
                }
            }
        }
        if (e.getKeyCode () == e.VK_P) {
            if (! pause) {
                pause = true;
                dt = System.currentTimeMillis ();
            }
            else {
                pausedTime += (System.currentTimeMillis () - dt);
                dt = 0;
                pause = false;
            }
        }
        if (e.getKeyCode () == e.VK_G) {
            if (! pause) {
                pause = true;
                dt = System.currentTimeMillis ();
            }
            else {
                pausedTime += (System.currentTimeMillis () - dt);
                dt = 0;
                pause = false;
            }
            try {
                save ();
            } catch (IOException m) {
            }
        }
    }
    if (player.getVidas () == 0) {
        if (e.getKeyCode () == e.VK_Y) {
            cargaNivel ("nivel1.txt", "Images/Level1/wallpaper.png");
            juegonuevo = true;
            opcion = 1;
            juego_empezado = true;
            en_menu_principal = false;
            player.setVidas (3);
            numeronivel = 1;
        }
        if (e.getKeyCode () == e.VK_N) {
            System.exit (1);
        }
    }
}


-----Function Pair=89=-----==

private void copyFileToStream (String filename, String dirname, ZipOutputStream zipper, String comment) throws IOException {
    File file = new File (filename);
    String entryName;
    if (dirname != null) {
        entryName = dirname + "/" + file.getName ();
    }
    else {
        entryName = file.getName ();
    }
    ZipEntry zipEntry = new ZipEntry (entryName);
    zipEntry.setTime (file.lastModified ());
    zipEntry.setSize (file.length ());
    if (comment != null) {
        zipEntry.setComment (comment);
    }
    zipper.putNextEntry (zipEntry);
    FileInputStream fis = new FileInputStream (file);
    try {
        int c;
        while ((c = fis.read ()) != - 1) {
            zipper.write (c);
        }
    } finally {
        fis.close ();
    }
    zipper.closeEntry ();
}


private static void loadFileInfo (File list, Map fileTimes, Map fileSizes) {
    if (! list.exists ()) return;
    try {
        BufferedReader in = new BufferedReader (new FileReader (list));
        String line, name, time, size;
        while ((line = in.readLine ()) != null) {
            StringTokenizer tok = new StringTokenizer (line, DELIM);
            name = tok.nextToken ();
            time = tok.nextToken ();
            size = tok.nextToken ();
            fileTimes.put (name, new Long (time));
            fileSizes.put (name, new Long (size));
        }
        in.close ();
    } catch (Exception e) {
        printError (e);
    }
}


-----Function Pair=90=-----==

public boolean putString (String var, int pos) {
    char [] charArr = var.toCharArray ();
    short theChar;
    if (inRange (pos, var.length () * 2)) {
        for (int i = 0; i < var.length (); i ++) {
            theChar = (short) (charArr [i]);
            buf [pos + 0] = (short) ((theChar>> 8) & 255);
            buf [pos + 1] = (short) ((theChar) & 255);
            pos += 2;
        }
        return true;
    }
    else {
        error ();
        return false;
    }
}


public boolean load (IFileHandle input) {
    clear ();
    if (input == null || input.canOpenInput () == false) return false;
    try {
        logger.log (Level.FINE, "Loading ''{0}''", input.toString ());
        InputStream fis = input.openInput ();
        ZipInputStream zis = new ZipInputStream (fis);
        zis.getNextEntry ();
        ObjectInputStream in = new ObjectInputStream (zis);
        SerialisedNode sDoc = new SerialisedNode ();
        try {
            sDoc = ((SerialisedNode) in.readObject ());
        } catch (Exception ex) {
            logger.log (Level.SEVERE, "Unable to read serialised node", ex);
            return false;
        }
        in.close ();
        zis.close ();
        fis.close ();
        recursiveDeserialise (sDoc, head);
        logger.log (Level.FINE, "Loaded ''{0}''", input.toString ());
        return true;
    } catch (Exception ex) {
        logger.log (Level.SEVERE, "Problem reading from file", ex);
        return false;
    }
}


-----Function Pair=91=-----==

public static < T extends ZipNode > Vector < T > loadAll (InputStream inputstream, Class < T > type, ZipStreamFilter filter) throws Exception {
    Vector < T > ret = new Vector < T > (20);
    ZipInputStream zip_in = new ZipInputStream (inputstream);
    try {
        ZipEntry entry = zip_in.getNextEntry ();
        try {
            String info = new String (ZipUtil.readBytes (zip_in));
        } catch (Exception err) {
        }
        while ((entry = zip_in.getNextEntry ()) != null) {
            T object = load (zip_in, entry, type, filter);
            if (object != null) {
                ret.add (object);
            }
        }
    } finally {
        try {
            zip_in.close ();
        } catch (IOException e) {
        }
    }
    return ret;
}


public void removeModels (Set < String > modelsName) {
    Dataset dataset = SDBFactory.connectDataset (store);
    Iterator < ? > modelNameIterator = dataset.listNames ();
    if (! modelNameIterator.hasNext ()) {
        logger.info ("No models to remove");
        return;
    }
    if (modelsName.size () == 0) {
        logger.warn ("This will cleaninig up the entire database. Are you sure you want to continue? [y/N]");
        BufferedReader inputReader = new BufferedReader (new InputStreamReader (System.in));
        try {
            String confirmation = inputReader.readLine ();
            if (confirmation != null && confirmation.toLowerCase ().equals ("y")) {
                store.getTableFormatter ().truncate ();
                logger.info ("Done");
                return;
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
        logger.error ("Aborted");
        return;
    }
    String modelName = null;
    String fileName = null;
    int index;
    while (modelNameIterator.hasNext ()) {
        modelName = (String) modelNameIterator.next ();
        index = modelName.lastIndexOf ("/");
        fileName = modelName;
        if (index != - 1) {
            fileName = modelName.substring (index + 1, modelName.length ());
        }
        if (modelsName.contains (fileName)) {
            SDBFactory.connectNamedModel (store, modelName).removeAll ();
            logger.info ("Model \"" + modelName + "\" removed");
        }
    }
    shutdown ();
}


-----Function Pair=92=-----==

public static void gunzip (String gzsource, String filedest) throws FileNotFoundException, IOException {
    GZIPInputStream in = new GZIPInputStream (new FileInputStream (gzsource));
    try {
        BufferedInputStream bis = new BufferedInputStream (in);
        try {
            OutputStream out = new FileOutputStream (filedest);
            try {
                BufferedOutputStream bos = new BufferedOutputStream (out);
                try {
                    byte [] buf = new byte [BUFFER_SIZE];
                    int len;
                    while ((len = bis.read (buf, 0, BUFFER_SIZE)) != - 1) {
                        bos.write (buf, 0, len);
                    }
                    buf = null;
                } finally {
                    bos.close ();
                }
            } finally {
                out.close ();
            }
        } finally {
            bis.close ();
        }
    } finally {
        in.close ();
    }
}


private Properties filterProperties (Properties p, String prefix) {
    prefix = prefix + TranslatorConstants.KEY_SEPARATOR;
    Properties result = new PropertiesFile ();
    Iterator i = p.entrySet ().iterator ();
    while (i.hasNext ()) {
        Map.Entry prop = (Map.Entry) i.next ();
        String name = (String) prop.getKey ();
        if (! name.startsWith (prefix)) continue;
        name = name.substring (prefix.length ());
        if (name.indexOf (TranslatorConstants.KEY_SEPARATOR) != - 1) continue;
        String value = (String) prop.getValue ();
        if (value == null || value.trim ().length () == 0) continue;
        result.setProperty (name, value);
    }
    return result;
}


-----Function Pair=93=-----==

public static void writeDownloadToDescriptor (HttpServletRequest request, String fileNameWithoutExtension, String originalUrl, String fileType, String queryDescription, boolean displayTimeTaken, String completionRedirectUrl) throws IOException, FileNotFoundException {
    String downloadDirectory = System.getProperty ("java.io.tmpdir");
    File fileDescriptor = new File (downloadDirectory + File.separator + fileNameWithoutExtension + downloadDescriptorExtension);
    FileOutputStream fileOutput = new FileOutputStream (fileDescriptor);
    Properties properties = new Properties ();
    properties.put (originalUrlKey, originalUrl);
    properties.put (fileTypeKey, fileType);
    properties.put (fileDescriptionKey, queryDescription);
    properties.put (displayTimeTakenKey, Boolean.toString (displayTimeTaken));
    if (completionRedirectUrl != null) {
        properties.put (completionRedirectUrlKey, completionRedirectUrl);
    }
    Timestamp now = new Timestamp (System.currentTimeMillis ());
    SimpleDateFormat sdfDate = new SimpleDateFormat ("ddMMyyyy HHmm.ss");
    properties.put (createDateKey, sdfDate.format (now));
    properties.store (fileOutput, null);
}


public static void createModelZip (String filename, String tempdir, boolean overwrite) throws Exception {
    FileTools.checkOutput (filename, overwrite);
    BufferedInputStream origin = null;
    FileOutputStream dest = new FileOutputStream (filename);
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    int BUFFER = 2048;
    byte data [] = new byte [BUFFER];
    File f = new File (tempdir);
    for (File fs : f.listFiles ()) {
        FileInputStream fi = new FileInputStream (fs.getAbsolutePath ());
        origin = new BufferedInputStream (fi, BUFFER);
        ZipEntry entry = new ZipEntry (fs.getName ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) out.write (data, 0, count);
        out.closeEntry ();
        origin.close ();
    }
    out.close ();
}


-----Function Pair=94=-----==

public List < ArtifactStatus > getArtifactStatus (ReleaseXmlBean releaseXmlBean) {
    Set < String > installedPlugins = getInstalledPlugins ();
    Set < String > installedTranslations = getInstalledTranslations ();
    ArrayList < ArtifactStatus > result = new ArrayList < ArtifactStatus > ();
    Set < ModuleXmlBean > currentModuleBeans = releaseXmlBean.getModules ();
    for (ModuleXmlBean module : currentModuleBeans) {
        Set < ArtifactXmlBean > artifactBeans = module.getArtifacts ();
        String moduleName = module.getName ();
        for (ArtifactXmlBean artifact : artifactBeans) {
            ArtifactStatus status = new ArtifactStatus (artifact);
            status.setType (moduleName);
            if (status.isCoreArtifact ()) {
                status.setInstalled (true);
            }
            if (status.isPluginArtifact () && installedPlugins.contains (artifact.getName ())) {
                status.setInstalled (true);
            }
            if (status.isTranslationArtifact () && installedTranslations.contains (artifact.getName ())) {
                status.setInstalled (true);
            }
            result.add (status);
        }
    }
    return result;
}


public static void makeZip (String zipURL, String xmlURL, String xmlFileName) throws IOException {
    FileOutputStream fos = new FileOutputStream (new File (zipURL));
    ZipOutputStream zos = new ZipOutputStream (fos);
    FileInputStream fis = new FileInputStream (xmlURL);
    zos.putNextEntry (new ZipEntry (xmlFileName + ".xml"));
    writeInOutputStream (fis, zos);
    String bpath = PathHandler.getBLobFilePathForClient ();
    FileInputStream fisBLOB = createInputStream (bpath);
    zos.putNextEntry (new ZipEntry ("blob.lob"));
    writeInOutputStream (fisBLOB, zos);
    zos.closeEntry ();
    String cpath = PathHandler.getCLobFilePathForClient ();
    FileInputStream fisCLOB = createInputStream (cpath);
    zos.putNextEntry (new ZipEntry ("clob.lob"));
    writeInOutputStream (fisCLOB, zos);
    zos.closeEntry ();
    fis.close ();
    fisCLOB.close ();
    fisBLOB.close ();
    zos.close ();
    fos.close ();
}


-----Function Pair=95=-----==

public static String getRelativePath (File baseDir, String file) throws IOException {
    File absFile;
    File tmpF = new File (file);
    if (tmpF.isAbsolute ()) absFile = tmpF;
    else absFile = new File (baseDir, file);
    File dest = absFile;
    File b = baseDir;
    String up = "";
    while (b.getParentFile () != null) {
        String res = _getRelativePath (b, dest.getAbsolutePath ());
        if (res != null) return up + res;
        up = "../" + up;
        b = b.getParentFile ();
    }
    return absFile.getAbsolutePath ();
}


public boolean renameSnapshot (IPath source, String separator) {
    File sourceFile = source.toFile ();
    if (sourceFile.exists ()) {
        IPath destFilePath = null;
        File destFile = null;
        Date date = new Date (sourceFile.lastModified ());
        SimpleDateFormat debugDateFormat = new SimpleDateFormat ("yyMMddHHmmss");
        String extension = source.getFileExtension ();
        if (extension != null) {
            destFilePath = source.removeFileExtension ();
            destFile = new File (destFilePath.toOSString () + separator + debugDateFormat.format (date) + "." + extension);
        }
        else {
            destFile = new File (source.toOSString () + separator + debugDateFormat.format (date));
        }
        if (XPLog.isDebugEnabled ()) {
            XPLog.printDebug (LogConstants.LOG_PREFIX_LOCALSNAPSHOT + "renaming old snapshot: source=" + source.toOSString () + ", dest=" + destFile.getAbsolutePath ());
        }
        return sourceFile.renameTo (destFile);
    }
    else {
        return false;
    }
}


-----Function Pair=96=-----==

private static String replaceInlineTag (String it, String [] qname) {
    if (! it.endsWith (".i") && ! it.endsWith (".o") && ! it.endsWith (".c") && ! it.endsWith (".e") && ! it.endsWith (".a")) {
        return it;
    }
    int len = it.length ();
    String dest = it.substring (0, len - 2);
    char x = it.charAt (len - 1);
    String href = getRelativeLocation (qname, dest) + "." + x + ".html";
    String simple = dest;
    int i;
    if ((i = simple.lastIndexOf (":")) >= 0) {
        simple = simple.substring (i + 1);
    }
    return "<a href=\"" + href + "\"><code>" + simple + "</code></a>";
}


public String [] downloadLineByLine (String netAddress, String arguments) throws IOException {
    ArrayList < String > ret = new ArrayList < String > ();
    URL u = new URL (netAddress);
    URLConnection uc = u.openConnection ();
    uc.setDoOutput (true);
    PrintWriter pw = new PrintWriter (uc.getOutputStream ());
    pw.println (arguments);
    pw.close ();
    BufferedReader in = new BufferedReader (new InputStreamReader (uc.getInputStream ()));
    String res = in.readLine ();
    while (res != null) {
        ret.add (res);
        res = in.readLine ();
    }
    in.close ();
    return (String []) ret.toArray (new String [0]);
}


-----Function Pair=97=-----=1=

public static void jar (File folder, String outputname, FileFilter filter) {
    File files [] = null;
    if (filter != null) {
        files = folder.listFiles (filter);
    }
    else {
        files = folder.listFiles ();
    }
    byte [] buf = new byte [1024];
    try {
        String outFilename = outputname;
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < files.length; i ++) {
            FileInputStream in = new FileInputStream (files [i]);
            out.putNextEntry (new ZipEntry (files [i].getCanonicalPath ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
    }
}


public static void zipFiles (String filename, String [] files) throws IOException {
    ZipOutputStream zip = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (filename)));
    byte [] buffer = new byte [10000];
    for (int i = 0; i < files.length; i ++) {
        File f = new File (files [i]);
        if (f.exists ()) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (files [i]));
            zip.putNextEntry (new ZipEntry (files [i]));
            boolean done = false;
            while (! done) {
                int num = in.read (buffer);
                if (num > 0) {
                    zip.write (buffer, 0, num);
                }
                done = (num < buffer.length);
            }
            in.close ();
        }
    }
    zip.flush ();
    zip.close ();
}


-----Function Pair=98=-----==

public static boolean unzipFiles (File zipFile, File outputDir) {
    if (zipFile == null || ! zipFile.exists () || zipFile.isDirectory () || ! makeDir (outputDir)) {
        return false;
    }
    ZipInputStream in = null;
    try {
        BufferedOutputStream out = null;
        in = new ZipInputStream (new BufferedInputStream (new FileInputStream (zipFile)));
        ZipEntry entry;
        while ((entry = in.getNextEntry ()) != null) {
            try {
                int count;
                byte data [] = new byte [1000];
                File outputFile = new File (outputDir, entry.getName ());
                out = new BufferedOutputStream (new FileOutputStream (outputFile), 1000);
                while ((count = in.read (data, 0, 1000)) != - 1) {
                    out.write (data, 0, count);
                }
            } finally {
                if (out != null) {
                    out.flush ();
                    out.close ();
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        FileUtil.close (in);
    }
    return true;
}


public static void extractZipEntry (final ZipFile zipFile, final ZipEntry target, final File toDirectory) throws IOException {
    final File fileToExtract = new File (toDirectory, target.getName ());
    InputStream is = null;
    BufferedInputStream bis = null;
    FileOutputStream fos = null;
    BufferedOutputStream bos = null;
    try {
        is = zipFile.getInputStream (target);
        bis = new BufferedInputStream (is);
        new File (fileToExtract.getParent ()).mkdirs ();
        fos = new FileOutputStream (fileToExtract);
        bos = new BufferedOutputStream (fos);
        for (int c; (c = bis.read ()) != - 1;) {
            bos.write ((byte) c);
        }
        bos.flush ();
        bos.close ();
    } catch (final IOException e) {
        throw e;
    } finally {
        StreamUtils.closeInputStream (bis);
        StreamUtils.closeInputStream (is);
        StreamUtils.closeOutputStream (fos);
        StreamUtils.closeOutputStream (bos);
    }
}


-----Function Pair=99=-----==

public static List getAttachments (OMElement element) {
    OMElement resultElement = getFirstChildWithName (element, "attachment");
    if (resultElement == null) {
        return null;
    }
    OMText binaryNode = (OMText) resultElement.getFirstOMChild ();
    DataHandler actualDH = (DataHandler) binaryNode.getDataHandler ();
    List result = new ArrayList ();
    try {
        ByteArrayInputStream input = (ByteArrayInputStream) actualDH.getInputStream ();
        ZipInputStream zis = new ZipInputStream (input);
        ZipEntry entry = zis.getNextEntry ();
        while (entry != null) {
            ObjectInputStream ois = new ObjectInputStream (zis);
            Object obj = ois.readObject ();
            result.add (obj);
            entry = zis.getNextEntry ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return result;
}


public static void unzipDir (JarInputStream jis, String destinyDir, boolean importFiles) {
    try {
        final int BUFFER = 2048;
        BufferedOutputStream dest = null;
        JarEntry entry = null;
        while ((entry = jis.getNextJarEntry ()) != null) {
            boolean unzip;
            if (importFiles && isFileToUnzip (entry.getName ()) || ! importFiles) unzip = true;
            else unzip = false;
            if (unzip) {
                int count;
                byte data [] = new byte [BUFFER];
                File newFile = new File (destinyDir, entry.getName ());
                newFile.create ();
                if (! newFile.isDirectory ()) {
                    FileOutputStream fos = new FileOutputStream (newFile);
                    dest = new BufferedOutputStream (fos, BUFFER);
                    while ((count = jis.read (data, 0, BUFFER)) != - 1) {
                        dest.write (data, 0, count);
                    }
                    dest.flush ();
                    dest.close ();
                }
            }
        }
        jis.close ();
    } catch (Exception e) {
    }
}


-----Function Pair=100=-----==

public static List getAttachments (OMElement element) {
    OMElement resultElement = getFirstChildWithName (element, "attachment");
    if (resultElement == null) {
        return null;
    }
    OMText binaryNode = (OMText) resultElement.getFirstOMChild ();
    DataHandler actualDH = (DataHandler) binaryNode.getDataHandler ();
    List result = new ArrayList ();
    try {
        ByteArrayInputStream input = (ByteArrayInputStream) actualDH.getInputStream ();
        ZipInputStream zis = new ZipInputStream (input);
        ZipEntry entry = zis.getNextEntry ();
        while (entry != null) {
            ObjectInputStream ois = new ObjectInputStream (zis);
            Object obj = ois.readObject ();
            result.add (obj);
            entry = zis.getNextEntry ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return result;
}


public static void replaceInFile (File fileName, String lookFor, String replaceWith, int lineIndex) throws IOException {
    String line;
    FileInputStream fis = new FileInputStream (fileName);
    BufferedReader reader = new BufferedReader (new InputStreamReader (fis));
    RandomAccessFile raf = new RandomAccessFile (fileName, "rw");
    int lineCounter = 0;
    while ((line = reader.readLine ()) != null) {
        int originalLineLength = line.length ();
        if (lineCounter == lineIndex) {
            line = line.replaceFirst (lookFor, replaceWith);
            if (line.length () > originalLineLength) {
                throw new RuntimeException ("Attempt to replace text with a longer text is not supported");
            }
        }
        raf.write ((line + "\n").getBytes ());
        lineCounter ++;
    }
    reader.close ();
    raf.setLength (raf.getFilePointer ());
    raf.close ();
}


-----Function Pair=101=-----==

public void exportMySelf (File f) {
    setQuality (true);
    BufferedImage exportImage = new BufferedImage (size [0], size [1], (f.getName ().endsWith ("jpg")) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = exportImage.createGraphics ();
    g.setRenderingHints (getRenderingHints ());
    drawMySelfHighQuality (g);
    Iterator it = ImageIO.getImageWriters (new ImageTypeSpecifier (exportImage), (f.getName ().endsWith ("jpg")) ? "jpg" : "png");
    if (! it.hasNext ()) {
        CDoxFrame.handleError (new Throwable (CDox.getLocalizer ().get ("nowriter")), false);
        setQuality (false);
        return;
    }
    ImageWriter iw = (ImageWriter) it.next ();
    try {
        ImageOutputStream ios = ImageIO.createImageOutputStream (f);
        iw.setOutput (ios);
        iw.write (exportImage);
        iw.dispose ();
        ios.flush ();
        ios.close ();
        System.gc ();
    } catch (IOException ioe) {
        setQuality (false);
        CDoxFrame.handleError (ioe, true);
    }
    setQuality (false);
}


private void recursiveZipWrite (File file, ZipOutputStream out, String currentParentPath) throws IOException {
    if (file.isFile ()) {
        ZipEntry entry = new ZipEntry (currentParentPath + file.getName ());
        entry.setTime (file.lastModified ());
        out.putNextEntry (entry);
        FileInputStream in = new FileInputStream (file);
        StringUtils.copy (in, out);
        in.close ();
        out.closeEntry ();
    }
    else if (file.isDirectory ()) {
        for (File subfile : file.listFiles ()) {
            recursiveZipWrite (subfile, out, currentParentPath + file.getName () + "/");
        }
    }
}


-----Function Pair=102=-----==

private void addExistingFileToZip (ZipOutputStream out, String entryName, String filePath) {
    if (filePath != null) {
        byte [] buf = new byte [1024];
        try {
            BufferedReader br = new BufferedReader (new FileReader (filePath));
            out.putNextEntry (new ZipEntry (entryName));
            int data;
            while ((data = br.read ()) != - 1) {
                out.write (data);
            }
            out.closeEntry ();
            br.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public void importComponent (HierarchyNode parent) throws ApplicationException {
    JFileChooser fc = getOpenFileChooser ();
    int returnVal = fc.showOpenDialog (this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        freeze (true);
        File file = fc.getSelectedFile ();
        Document doc = openDoc (file);
        String reason = "Unknown reason";
        if (doc != null) {
            importComponentDirect (parent, doc);
        }
        freeze (false);
        if (doc == null) {
            throw new ApplicationException ("Import failed - " + reason);
        }
        setDirty (true);
    }
}


-----Function Pair=103=-----=1=

private void addFileToZip (ZipOutputStream out, String fn, String content) {
    if (fn != null) {
        byte [] buf = new byte [1024];
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream (content.getBytes ());
            out.putNextEntry (new ZipEntry (fn));
            int len;
            while ((len = bais.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            bais.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public void createCachePackage (OutputStream output) {
    int bytesRead = 0;
    byte [] transferBuffer = new byte [BUFFER_SIZE];
    try {
        ZipOutputStream zos = new ZipOutputStream (output);
        for (File file : cacheFolder.listFiles ()) {
            if (file.getName ().contains ("DS_Store") || file.getName ().endsWith (".svn")) continue;
            ZipEntry fileEntry = new ZipEntry (file.getName ());
            zos.putNextEntry (fileEntry);
            InputStream bis = new FileInputStream (file);
            while ((bytesRead = bis.read (transferBuffer)) != - 1) {
                zos.write (transferBuffer, 0, bytesRead);
            }
            bis.close ();
            zos.closeEntry ();
            logger.log (Level.INFO, "Wrote {0}, size is {1}", new Object [] {file.toString (), fileEntry.getSize ()});
        }
        zos.close ();
    } catch (IOException ex) {
        logger.log (Level.SEVERE, "Caught an IOException while making cache package: {0}", ex.getMessage ());
    }
}


-----Function Pair=104=-----==

private void addFileToZip (ZipOutputStream out, String fn, String content) {
    if (fn != null) {
        byte [] buf = new byte [1024];
        try {
            ByteArrayInputStream bais = new ByteArrayInputStream (content.getBytes ());
            out.putNextEntry (new ZipEntry (fn));
            int len;
            while ((len = bais.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            bais.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public static void unzipBytes (byte [] bytes, String aFileName, String aDirectory) {
    try {
        InputStream in = new BufferedInputStream (new ByteArrayInputStream (bytes));
        ZipInputStream zin = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zin.getNextEntry ()) != null) {
            if (e.getName ().equals (aFileName)) {
                unzip (zin, aFileName);
                break;
            }
            unzip (zin, aDirectory + e.getName ());
        }
        zin.close ();
    } catch (Exception e) {
        logger.error ("unable to unzip file" + e);
    }
}


-----Function Pair=105=-----==

public static String [] executeShellScript (String shellScript, File tempDirectory) {
    File shellFile = new File (tempDirectory, "tempFile_" + Passwords.createRandowWord (10) + ".sh");
    String fullPath = IO.getFullPathName (shellFile);
    IO.writeString (shellScript, shellFile);
    String [] cmd = {"chmod", "777", fullPath};
    String [] res = IO.executeCommandLineReturnAll (cmd);
    if (res == null || res.length != 0) {
        shellFile.delete ();
        return null;
    }
    cmd = new String [] {fullPath};
    res = IO.executeCommandLineReturnAll (cmd);
    shellFile.delete ();
    return res;
}


private TemplateEntity readThemeImportXML (final String xml) throws DocumentException {
    Document doc = DocumentHelper.parseText (xml);
    Element root = doc.getRootElement ();
    TemplateEntity template = new TemplateEntity ();
    for (Iterator < Element > i = root.elementIterator (); i.hasNext ();) {
        Element element = i.next ();
        if (element.getName ().equals ("title")) {
            template.setTitle (element.getStringValue ());
        }
        if (element.getName ().equals ("url")) {
            template.setUrl (element.getStringValue ());
        }
    }
    return template;
}


-----Function Pair=106=-----==

public static File [] extractFiles (String commaSeparList, String extension) {
    ArrayList filesAL = new ArrayList ();
    String [] items = commaSeparList.split (",");
    for (int i = 0; i < items.length; i ++) {
        File test = new File (items [i]);
        if (test.canRead () == false) return null;
        File [] files = extractFiles (test, extension);
        if (files == null) return null;
        for (int j = 0; j < files.length; j ++) {
            filesAL.add (files [j]);
        }
    }
    File [] collection = new File [filesAL.size ()];
    filesAL.toArray (collection);
    return collection;
}


public void zipSubProject (ZipOutputStream zos, ProjectHolder aHolder) {
    for (Enumeration e = aHolder.getMembers ().elements (); e.hasMoreElements ();) {
        Member aMember = (Member) e.nextElement ();
        if (! (aMember instanceof ProjectHolder)) {
            try {
                File aFile = new File (aMember.getPath ());
                FileInputStream fr = new FileInputStream (aFile);
                byte fileBuffer [] = new byte [(int) aFile.length ()];
                int count = fr.read (fileBuffer);
                String pathName = aFile.getCanonicalPath ();
                zos.putNextEntry (new ZipEntry ((pathName.substring (pathName.indexOf (System.getProperty ("file.separator")) + 1)).replace (System.getProperty ("file.separator").charAt (0), '/')));
                zos.write (fileBuffer, 0, fileBuffer.length);
                fr.close ();
            } catch (Exception ex) {
                System.err.println ("Error creating zip project : " + ex);
            }
        }
    }
    for (Enumeration e = aHolder.getSubprojects ().elements (); e.hasMoreElements ();) {
        ProjectHolder aMember = (ProjectHolder) e.nextElement ();
        zipSubProject (zos, aMember);
    }
}


-----Function Pair=107=-----==

public static int [] [] loadTableOfInts (File file) {
    int [] [] columnsRows = null;
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line = in.readLine ();
        if (line == null) return null;
        String [] tokens = line.split ("\\t");
        int numColumns = tokens.length;
        int numRows = (int) IO.countNumberOfLines (file);
        columnsRows = new int [numColumns] [numRows];
        int y = 0;
        for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        y ++;
        for (; y < numRows; y ++) {
            line = in.readLine ();
            tokens = line.split ("\\t");
            for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        }
        in.close ();
    } catch (Exception e) {
        System.out.println ("Problem loading table");
        e.printStackTrace ();
    }
    return columnsRows;
}


public static void zippaInUnaCartella (String strPathOrigine, String strPathDestinazione, String strNomeFileZip, LinkedList < String > lNomi) throws Exception {
    try {
        File f = new File (strPathOrigine);
        File fList [] = f.listFiles ();
        FileOutputStream dest = new FileOutputStream (strPathDestinazione + "/" + strNomeFileZip);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        for (int i = 0; i < fList.length; i ++) {
            if (fList [i].isFile ()) {
                if (lNomi.contains (fList [i].getName ())) {
                    aggFile (out, strPathOrigine, fList [i].getName ());
                }
            }
        }
        out.close ();
        out = null;
        dest.close ();
        dest = null;
    } catch (Exception e) {
        new Exception ("\n zippaInUnaCartella  : " + e.getMessage ());
    }
}


-----Function Pair=108=-----==

public static String [] parseColumn (File file, int index) {
    ArrayList al = new ArrayList ();
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line;
        String [] tokens;
        while ((line = in.readLine ()) != null) {
            tokens = line.split ("\\t");
            if (tokens.length <= index) al.add ("");
            else al.add (tokens [index].trim ());
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        Misc.printExit ("\nError: problem parsing matcher file, aborting.\n");
    }
    String [] col = new String [al.size ()];
    al.toArray (col);
    return col;
}


private void addAtomicFilesToBackup (ZipOutputStream zipOut, String [] filenames) throws IOException {
    List matchedFiles = new ArrayList ();
    List unmatchedFiles = new ArrayList ();
    for (int i = 0; i < filenames.length; i ++) {
        String filename = filenames [i];
        if (containsIgnoreCase (atomicFilesInOldBackup, filename)) matchedFiles.add (filename);
        else unmatchedFiles.add (filename);
    }
    if (! matchedFiles.isEmpty () && ! unmatchedFiles.isEmpty ()) {
        for (Iterator i = unmatchedFiles.iterator (); i.hasNext ();) {
            String filename = (String) i.next ();
            File file = new File (srcDirectory, filename);
            backupFile (null, null, null, zipOut, file, filename);
        }
    }
}


-----Function Pair=109=-----=1=

private static void zip (String sourceDirectory, OutputStream dest) throws FileNotFoundException, IOException {
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    StringBuffer fileList = new StringBuffer ();
    getFileList (sourceDirectory, fileList);
    String [] files = fileList.toString ().split ("\n");
    System.out.println ("Filecount:" + (files.length - 1));
    byte [] tmpBuf = new byte [BUFFER];
    for (int i = 1; i < files.length; i ++) {
        ZipEntry entry = new ZipEntry (files [i].substring (new File (sourceDirectory).getAbsolutePath ().length ()));
        out.putNextEntry (entry);
        if (new File (files [i]).isFile ()) {
            FileInputStream in = new FileInputStream (files [i]);
            int len;
            while ((len = in.read (tmpBuf)) > 0) {
                out.write (tmpBuf, 0, len);
            }
            in.close ();
        }
        out.closeEntry ();
    }
    out.close ();
    System.out.println ("Compression complete.");
}


public void addContents (ZipOutputStream pZipFile, File pDirectory, String pDirName) throws IOException {
    File [] files = pDirectory.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        File f = files [i];
        String name = pDirName.length () == 0 ? f.getName () : pDirName + "/" + f.getName ();
        if (f.isDirectory ()) {
            addContents (pZipFile, f, name);
        }
        else if (f.isFile ()) {
            FileInputStream istream = new FileInputStream (f);
            try {
                ZipEntry zipEntry = new ZipEntry (name);
                pZipFile.putNextEntry (zipEntry);
                byte [] buffer = new byte [1024];
                for (;;) {
                    int res = istream.read (buffer);
                    if (res == - 1) {
                        break;
                    }
                    else if (res > 0) {
                        pZipFile.write (buffer, 0, res);
                    }
                }
                pZipFile.closeEntry ();
                istream.close ();
                istream = null;
            } finally {
                if (istream != null) {
                    try {
                        istream.close ();
                    } catch (Throwable ignore) {
                    }
                }
            }
        }
    }
}


-----Function Pair=110=-----==

public void exportSettings () {
    String [] filenames = this.getSettingsFiles ();
    byte [] buf = new byte [1024];
    try {
        String outFilename = "ModRcon_v" + PropertyManager.MODRCON_VERSION + "_SettingsBackup.pu1";
        JFileChooser file = new JFileChooser ();
        file.setSelectedFile (new File (outFilename));
        int choice = file.showSaveDialog (parent);
        if (choice == 0) {
            String path = file.getSelectedFile ().getAbsolutePath ();
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (path));
            for (int i = 0; i < filenames.length; i ++) {
                FileInputStream in = new FileInputStream (PropertyManager.settingsPath + filenames [i]);
                out.putNextEntry (new ZipEntry (filenames [i]));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
            out.close ();
            JOptionPane.showMessageDialog (parent, "1up ModRcon Settings Exported Successfully!", "File Saved", JOptionPane.INFORMATION_MESSAGE);
        }
    } catch (IOException e) {
        System.out.println ("Error Creating Export File:" + e.getMessage ());
    }
}


private static void unzip (ZipInputStream zi, File destination) throws IOException {
    String sdest = destination.getAbsolutePath ();
    ZipEntry entry;
    while ((entry = zi.getNextEntry ()) != null) {
        String name = entry.getName ();
        if (name.startsWith ("/") || name.startsWith ("\\")) {
            name = name.substring (1);
        }
        String dest = sdest + File.separator + name;
        File f = new File (dest);
        if (entry.isDirectory ()) {
            f.mkdirs ();
        }
        else {
            f.getParentFile ().mkdirs ();
            BufferedOutputStream os = new BufferedOutputStream (new FileOutputStream (f));
            byte [] buff = new byte [4096];
            int read;
            while ((read = zi.read (buff)) > 0) {
                os.write (buff, 0, read);
            }
            os.close ();
        }
    }
}


-----Function Pair=111=-----==

public void compress (String fileName, String dir) {
    Files files = new Files ();
    String [] filenames = files.directoryList (dir);
    byte [] buf = new byte [1024];
    try {
        String outFilename = fileName;
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < filenames.length; i ++) {
            FileInputStream in = new FileInputStream (filenames [i]);
            String file = filenames [i].substring (dir.length () + 1);
            out.putNextEntry (new ZipEntry (file));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
    }
}


public String removeOnApprovalEntry (String xmlStr) {
    Element response = new Element ("Response");
    Element success = new Element ("Success");
    try {
        Element request = newGenXMLGenerator.getRootElementFromXMLDocument (xmlStr);
        String mode = request.getChildText ("Mode");
        if (mode.equals ("B")) {
            String approvalId = request.getChildText ("Id");
            String libId = request.getChildText ("LibId");
            ACQ_ON_APPROVALKey acqApprovalKey = new ACQ_ON_APPROVALKey ();
            acqApprovalKey.on_Approval_Id = new Integer (approvalId);
            acqApprovalKey.library_Id = new Integer (libId);
            LocalACQ_ON_APPROVAL localAcqOnApproval = ((LocalACQ_ON_APPROVALHome) homeFactory.getHome ("ACQ_ON_APPROVAL")).findByPrimaryKey (acqApprovalKey);
            if (localAcqOnApproval != null) {
                localAcqOnApproval.remove ();
                success.setText ("SUCCESS");
            }
            else {
                success.setText ("NOTFOUND");
            }
        }
    } catch (Exception e) {
        success.setText ("FAILED");
    }
    response.addContent (success);
    return newGenXMLGenerator.buildXMLDocument (response);
}


-----Function Pair=112=-----==

protected void copyResource (File source, File destination) {
    if (! (source.equals ((temRep)))) {
        if (source.isDirectory ()) {
            File directory = destination;
            directory.mkdir ();
            File [] files = source.listFiles ();
            if (files != null) {
                for (int i = 0; i < files.length; i ++) {
                    File f = files [i];
                    destination = new File (directory, f.getName ());
                    copyResource (f, destination);
                }
            }
        }
        else {
            FileOutputStream outStream = null;
            FileInputStream inStream = null;
            if (destination.exists ()) {
                deleteResource (destination);
            }
            try {
                destination.createNewFile ();
                inStream = new FileInputStream (source);
                outStream = new FileOutputStream (destination);
                byte buffer [] = new byte [512 * 1024];
                int nb;
                while ((nb = inStream.read (buffer)) != - 1) {
                    outStream.write (buffer, 0, nb);
                }
            } catch (java.io.FileNotFoundException f) {
            } catch (java.io.IOException e) {
            } finally {
                try {
                    if (inStream != null) inStream.close ();
                } catch (Exception e) {
                }
                try {
                    if (outStream != null) outStream.close ();
                } catch (Exception e) {
                }
            }
        }
    }
}


protected void truncate (final File file) {
    LogLog.debug ("Compression of file: " + file.getAbsolutePath () + " started.");
    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {
        final File backupRoot = new File (this.getBackupDir ());
        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {
            throw new AppenderInitializationError ("Can't create backup dir for backup storage");
        }
        SimpleDateFormat df;
        try {
            df = new SimpleDateFormat (this.getBackupDateFormat ());
        } catch (final Exception e) {
            throw new AppenderInitializationError ("Invalid date formate for backup files: " + this.getBackupDateFormat (), e);
        }
        final String date = df.format (new Date (file.lastModified ()));
        final File zipFile = new File (backupRoot, file.getName () + "." + date + ".zip");
        ZipOutputStream zos = null;
        FileInputStream fis = null;
        try {
            zos = new ZipOutputStream (new FileOutputStream (zipFile));
            final ZipEntry entry = new ZipEntry (file.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            entry.setCrc (FileUtils.checksumCRC32 (file));
            zos.putNextEntry (entry);
            fis = FileUtils.openInputStream (file);
            final byte [] buffer = new byte [1024];
            int readed;
            while ((readed = fis.read (buffer)) != - 1) {
                zos.write (buffer, 0, readed);
            }
        } catch (final Exception e) {
            throw new AppenderInitializationError ("Can't create zip file", e);
        } finally {
            if (zos != null) {
                try {
                    zos.close ();
                } catch (final IOException e) {
                    LogLog.warn ("Can't close zip file", e);
                }
            }
            if (fis != null) {
                try {
                    fis.close ();
                } catch (final IOException e) {
                    LogLog.warn ("Can't close zipped file", e);
                }
            }
        }
        if (! file.delete ()) {
            throw new AppenderInitializationError ("Can't delete old log file " + file.getAbsolutePath ());
        }
    }
}


-----Function Pair=113=-----==

private static void fromFile (boolean launch) {
    File f = openFile ();
    if (f == null) {
        if (launch) {
            main (null);
        }
    }
    else {
        Connection conn = getTemporaryConnection ();
        File fsql = unzip (f);
        try {
            RunScript.execute (conn, new FileReader (fsql));
            if (conn == null || ! importeur.verifierBDD (conn)) {
                JOptionPane.showMessageDialog (editeur, "Fichier corrompu.", "Erreur", JOptionPane.ERROR_MESSAGE);
                closeTemporaryConnection (conn);
                fromFile (launch);
            }
            else {
                setSaveFile (f);
                Serveur data = new Serveur ();
                data.importer (conn);
                changeData (data);
                closeTemporaryConnection (conn);
            }
        } catch (SQLException e) {
            JOptionPane.showMessageDialog (editeur, "Fichier corrompu.", "Erreur", JOptionPane.ERROR_MESSAGE);
            closeTemporaryConnection (conn);
        } catch (IOException e) {
            JOptionPane.showMessageDialog (editeur, "Impossible d'ouvrir le fichier.", "Erreur", JOptionPane.ERROR_MESSAGE);
            closeTemporaryConnection (conn);
        }
        fsql.delete ();
    }
}


private void updateConfigFile () {
    try {
        Properties prop = new Properties ();
        prop.put ("export", export.getText ());
        Enumeration en = listModel.elements ();
        StringBuffer mlos = new StringBuffer ();
        while (en.hasMoreElements ()) {
            File f = new File ((String) en.nextElement ());
            if (f.exists ()) {
                if (mlos.length () > 0) mlos.append (";");
                mlos.append (f.getAbsolutePath ());
            }
        }
        prop.put ("mlos", mlos.toString ());
        if (! this.projectFile.exists ()) this.projectFile.createNewFile ();
        FileOutputStream fout = new FileOutputStream (this.projectFile);
        prop.store (fout, "");
        fout.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=114=-----==

private void copyFile (ZipInputStream zis) throws FileNotFoundException, IOException {
    Vector targetFiles = directOutput.getTargetFiles ();
    String targetName = directOutput.getDestinationName ();
    logger.fine ("Direct copy to: " + targetName + " PF: " + directOutput.getSpoolPortfolio ().getUPLDirectoryName ());
    ZipEntry entry = zis.getNextEntry ();
    String zipName = null;
    String realName = null;
    String uplName = null;
    PutPortfolio_Outcome ppo = null;
    String iteration = "";
    Vector spoolOutcomes = OutcomeManager.getOutcomeEntries (directOutput.getSpoolTask ());
    if (spoolOutcomes.size () <= 0) {
        logger.severe ("Cannot find outcome of spool task for file: " + directOutput.getSourceName ());
        return;
    }
    while (entry != null) {
        zipName = entry.getName ().replace ('/', File.separatorChar);
        logger.fine ("Receiving streamed file (direct output)" + zipName);
        for (int i = 0; i < spoolOutcomes.size (); i ++) {
            ppo = (PutPortfolio_Outcome) ((OutcomeEntry) spoolOutcomes.elementAt (i)).getOutcome ();
            uplName = (new Portfolio ("", ppo.getPortfolio ().getValue ())).getUPLDirectoryName ();
            if (zipName.lastIndexOf (uplName) > 0) {
                iteration = ((OutcomeEntry) spoolOutcomes.elementAt (i)).getIteration ();
                break;
            }
        }
        realName = zipName.substring (zipName.lastIndexOf (uplName));
        realName = realName.substring (realName.indexOf (File.separator) + 1);
        targetName = directOutput.getDestinationName ().replaceAll (UC_ITERATION_COUNTS_REGEX, iteration);
        File destination = new File (targetName);
        if (destination.exists ()) {
            if (destination.isDirectory ()) {
                if (! targetName.endsWith (File.separator)) {
                    targetName = targetName + File.separator;
                }
                realName = targetName + realName;
                File destDir = new File (realName.substring (0, realName.lastIndexOf (File.separator)));
                destDir.mkdirs ();
            }
            else {
                realName = targetName;
            }
        }
        else {
            if (realName.indexOf (File.separator) > 0) {
                if (! targetName.endsWith (File.separator)) {
                    targetName = targetName + File.separator;
                }
                logger.fine ("non exixting  target:" + realName);
                String sourceDir = realName.substring (0, realName.indexOf (File.separator));
                realName = targetName + realName.substring (realName.indexOf (File.separator) + 1);
                File destDir = new File (realName.substring (0, realName.lastIndexOf (File.separator)));
                destDir.mkdirs ();
                if (this.directOutput.getTargetFilesFlag () == FileExport.CHOOSE_OVERWRITTEN_FILES) {
                    if (targetFiles.contains (realName)) {
                        copyFileFromZip (realName, zis);
                    }
                }
                else {
                    copyFileFromZip (realName, zis);
                }
                entry = zis.getNextEntry ();
                while (entry != null) {
                    zipName = entry.getName ().replace ('/', File.separatorChar);
                    logger.fine ("Receiving streamed file (direct output)" + zipName);
                    realName = zipName.substring (zipName.indexOf (directOutput.getSpoolPortfolio ().getUPLDirectoryName ()));
                    realName = realName.substring (realName.indexOf (File.separator) + 1);
                    if (! realName.startsWith (sourceDir)) {
                        logger.severe ("Multiple directories in zip stream are not allowed");
                        throw new IOException ("Multiple directorie in zip stream are not allowed");
                    }
                    realName = targetName + realName.substring (realName.indexOf (File.separator) + 1);
                    destDir = new File (realName.substring (0, realName.lastIndexOf (File.separator)));
                    destDir.mkdirs ();
                    if (this.directOutput.getTargetFilesFlag () == FileExport.CHOOSE_OVERWRITTEN_FILES) {
                        if (targetFiles.contains (realName)) {
                            copyFileFromZip (realName, zis);
                        }
                    }
                    else {
                        copyFileFromZip (realName, zis);
                    }
                    entry = zis.getNextEntry ();
                }
                this.directOutput.resetTargetFilesFlag ();
                return;
            }
            else {
                realName = targetName;
            }
        }
        if (this.directOutput.getTargetFilesFlag () == FileExport.CHOOSE_OVERWRITTEN_FILES) {
            boolean match = false;
            for (int i = 0; i < targetFiles.size (); i ++) {
                String next = (String) targetFiles.elementAt (i);
                if (realName.indexOf (next) >= 0) {
                    match = true;
                    break;
                }
            }
            if (match) {
                copyFileFromZip (realName, zis);
            }
        }
        else {
            copyFileFromZip (realName, zis);
        }
        entry = zis.getNextEntry ();
    }
    this.directOutput.resetTargetFilesFlag ();
}


private boolean updateDigests (ZipEntry ze, ZipFile zf, MessageDigest [] digests, BASE64Encoder encoder, Manifest mf) throws IOException {
    boolean update = false;
    Attributes attrs = mf.getAttributes (ze.getName ());
    String [] base64Digests = getDigests (ze, zf, digests, encoder);
    for (int i = 0; i < digests.length; i ++) {
        String name = null;
        try {
            AlgorithmId aid = AlgorithmId.get (digests [i].getAlgorithm ());
            for (Object key : attrs.keySet ()) {
                if (key instanceof Attributes.Name) {
                    String n = ((Attributes.Name) key).toString ();
                    if (n.toUpperCase (Locale.ENGLISH).endsWith ("-DIGEST")) {
                        String tmp = n.substring (0, n.length () - 7);
                        if (AlgorithmId.get (tmp).equals (aid)) {
                            name = n;
                            break;
                        }
                    }
                }
            }
        } catch (NoSuchAlgorithmException nsae) {
        }
        if (name == null) {
            name = digests [i].getAlgorithm () + "-Digest";
            attrs.putValue (name, base64Digests [i]);
            update = true;
        }
        else {
            String mfDigest = attrs.getValue (name);
            if (! mfDigest.equalsIgnoreCase (base64Digests [i])) {
                attrs.putValue (name, base64Digests [i]);
                update = true;
            }
        }
    }
    return update;
}


-----Function Pair=115=-----==

private static DataBuffer createJarFileInBuffer (File pluginBaseDir, File targetFile) {
    assert pluginBaseDir != null;
    assert targetFile != null && targetFile.isFile ();
    ZipOutputStream jarOutStream = null;
    try {
        DataBuffer buffer = new DataBuffer (1024, targetFile);
        OutputStream outstream = buffer.createOutputStream ();
        jarOutStream = new ZipOutputStream (outstream);
        for (File child : pluginBaseDir.listFiles ()) {
            addRecursivelyToJar (child, "", jarOutStream);
        }
        jarOutStream.close ();
        outstream.close ();
        return buffer;
    } catch (FileNotFoundException e) {
        throw new RuntimeException (e);
    } catch (IOException e) {
        throw new RuntimeException (e);
    } finally {
        if (jarOutStream != null) {
            try {
                jarOutStream.close ();
            } catch (IOException e) {
                throw new RuntimeException ("IO Error when trying to close output stream.", e);
            }
        }
    }
}


private byte [] readEntry (ZipInputStream zis, ZipEntry ze) throws IOException {
    long size = ze.getSize ();
    if (size > - 1) {
        byte [] buff = new byte [(int) size];
        zis.read (buff);
        return buff;
    }
    else {
        ByteArrayOutputStream bos = new ByteArrayOutputStream ();
        byte [] buff = new byte [4096];
        int n;
        while ((n = zis.read (buff)) != - 1) {
            bos.write (buff, 0, n);
        }
        return bos.toByteArray ();
    }
}


-----Function Pair=116=-----==

public void outputEntry (ZipOutputStream zos, File f, boolean isRecursive) throws Error, IOException {
    String adjustedPath = f.getPath ().replace (File.separatorChar, '/');
    if (f.isDirectory () && ! adjustedPath.endsWith ("/")) {
        adjustedPath += '/';
    }
    String fileName = f.getName ();
    ZipEntry entry = new ZipEntry (fileName);
    entry.setTime (f.lastModified ());
    zos.putNextEntry (entry);
    if (f.isDirectory ()) {
        if (isRecursive) {
            String [] files = f.list ();
            for (int i = 0; i < files.length; ++ i) {
                outputEntry (zos, new File (f, files [i]), isRecursive);
            }
        }
    }
    else {
        FileInputStream fis = new FileInputStream (f);
        byte buf [] = new byte [1024];
        for (int cnt; (cnt = fis.read (buf)) != - 1;) {
            zos.write (buf, 0, cnt);
        }
        fis.close ();
    }
}


public synchronized Vector < String > getWorkflowDevelopers (String type) throws Exception {
    Hashtable hsh = new Hashtable ();
    ServiceType st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
    PortalWfsClient wfsClient = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
    wfsClient.setServiceURL (st.getServiceUrl ());
    wfsClient.setServiceID (st.getServiceID ());
    RepositoryWorkflowBean bean = new RepositoryWorkflowBean ();
    Long id = new Long (0);
    bean.setId (id);
    bean.setWorkflowType (type);
    Vector < RepositoryWorkflowBean > wfList = wfsClient.getRepositoryItems (bean);
    if (wfList == null) {
        throw new ASM_UnknownErrorException ();
    }
    Vector < String > owners = new Vector < String > ();
    for (int i = 0; i < wfList.size (); ++ i) {
        String userId = wfList.get (i).getUserID ();
        if (! owners.contains (new String (userId))) owners.add (userId);
    }
    return owners;
}


-----Function Pair=117=-----==

private void overSizeRollover () {
    File rollTarget = null;
    File rollFile = null;
    String rollFileName = fileName + sdf.format (now);
    if (qw != null) {
        long size = ((CountingQuietWriter) qw).getCount ();
        LogLog.debug ("rolling over count=" + size);
        nextRollover = size + maxFileSize;
    }
    LogLog.debug ("maxBackupIndex=" + maxBackupIndex);
    boolean renameSucceeded = true;
    if (maxBackupIndex > 0) {
        rollFile = new File (rollFileName + '.' + maxBackupIndex);
        if (rollFile.exists () && deleteOld) {
            renameSucceeded = rollFile.delete ();
        }
        initLogPath (rollFileName);
        File [] logFiles = getLogFiles (logFileName);
        Arrays.sort (logFiles, new LogFilesComparator ());
        RenameLogFiles renameLogFiles = new RenameLogFiles (logFiles, rollFile, rollTarget, rollFileName);
        Thread renameLogs = new Thread (renameLogFiles);
        renameLogFiles.run ();
        if (renameSucceeded) {
            rollTarget = new File (rollFileName + "." + 1);
            this.closeFile ();
            rollFile = new File (fileName);
            renameSucceeded = rollFile.renameTo (rollTarget);
            if (! renameSucceeded) {
                try {
                    this.setFile (fileName, true, bufferedIO, bufferSize);
                } catch (IOException e) {
                    if (e instanceof InterruptedIOException) {
                        Thread.currentThread ().interrupt ();
                    }
                    LogLog.error ("setFile(" + fileName + ", true) call failed.", e);
                }
            }
        }
    }
    if (renameSucceeded) {
        try {
            this.setFile (fileName, false, bufferedIO, bufferSize);
            nextRollover = 0;
        } catch (IOException e) {
            if (e instanceof InterruptedIOException) {
                Thread.currentThread ().interrupt ();
            }
            LogLog.error ("setFile(" + fileName + ", false) call failed.", e);
        }
    }
}


public ArchivePath (String path) {
    String archive = path.substring ((ArchiveVFS.this.getName () + ':').length ());
    String archivePath = archive;
    String archiveEntry = "";
    int idx = - 1;
    if ((idx = archive.lastIndexOf (ArchiveVFS.archiveSeparator)) != - 1) {
        archivePath = archive.substring (0, idx);
        archiveEntry = archive.substring (idx + ArchiveVFS.archiveSeparatorLen);
    }
    for (int i = 0; i < archiveEntry.length (); i ++) {
        if (archiveEntry.charAt (i) != ArchiveVFS.fileSeparatorChar) {
            if (i > 0) {
                archiveEntry = archiveEntry.substring (i);
            }
            break;
        }
    }
    for (int i = archiveEntry.length () - 1; i >= 0; i --) {
        if (archiveEntry.charAt (i) != ArchiveVFS.fileSeparatorChar) {
            if (i < archiveEntry.length () - 1) {
                archiveEntry = archiveEntry.substring (0, i + 1);
            }
            break;
        }
    }
    this.protocol = ArchiveVFS.this.getName ();
    this.pathName = archivePath;
    this.entryName = archiveEntry;
}


-----Function Pair=118=-----==

public static PositionTextData merge (ArrayList < PositionTextData > pdAL) {
    PositionTextData [] pdArray = new PositionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionTexts.length;
    PositionText [] concatinate = new PositionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionText [] slice = pdArray [i].sortedPositionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionTextData (concatinate, sliceInfo);
}


private static void getLauncherOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT lancherOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("lancherOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


-----Function Pair=119=-----=1=

public File getLayerFile (String id) throws IOException {
    File f = null;
    if (zipFile != null) {
        ZipOutputStream out = null;
        byte [] buf = new byte [1024];
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            ZipEntry ze = (ZipEntry) e.nextElement ();
            String baseName = getBase (ze.getName ());
            if (baseName.equals (id)) {
                if (out == null) {
                    f = File.createTempFile ("layer_", ".zip");
                    out = new ZipOutputStream (new FileOutputStream (f));
                }
                InputStream in = zipFile.getInputStream (ze);
                out.putNextEntry (new ZipEntry (ze.getName ()));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
        }
        if (out != null) {
            out.close ();
        }
    }
    else {
        f = file;
    }
    return f;
}


public static void compressAll (File dir, File file) throws IOException {
    if (! dir.isDirectory ()) throw new IllegalArgumentException ("Given file is no directory");
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));
    out.setLevel (0);
    String [] entries = dir.list ();
    byte [] buffer = new byte [4096];
    int bytesRead;
    for (int i = 0; i < entries.length; i ++) {
        File f = new File (dir, entries [i]);
        if (f.isDirectory ()) continue;
        FileInputStream in = new FileInputStream (f);
        ZipEntry entry = new ZipEntry (f.getName ());
        out.putNextEntry (entry);
        while ((bytesRead = in.read (buffer)) != - 1) out.write (buffer, 0, bytesRead);
        in.close ();
    }
    out.close ();
}


-----Function Pair=120=-----=1=

public static Map < String, File > extractFiles (String input, File tempDirectory) throws IOException {
    byte data [] = new byte [BUFFER];
    BufferedOutputStream out = null;
    FileInputStream src = new FileInputStream (input);
    BufferedInputStream in = new BufferedInputStream (src);
    ZipInputStream zipin = new ZipInputStream (in);
    Map < String, File > files = new HashMap < String, File > ();
    ZipEntry entry;
    while ((entry = zipin.getNextEntry ()) != null) {
        logger.info (TAG + ": entr�e " + entry.getName () + " r�pertoire ? " + entry.isDirectory ());
        if (entry.isDirectory ()) {
            logger.info (TAG + ": Ajout de l'entr�e pour le r�pertoire: " + entry.getName ());
            files.put (entry.getName (), extractDirectory (entry.getName (), zipin, tempDirectory));
            File f = files.get (entry.getName ());
            if (f == null) logger.info (TAG + ": NULLL: ");
            continue;
        }
        File tempFile = new File (tempDirectory, entry.getName ());
        if (tempFile.exists ()) tempFile.delete ();
        tempFile.createNewFile ();
        FileOutputStream dest = new FileOutputStream (tempFile);
        out = new BufferedOutputStream (dest, BUFFER);
        int count;
        for (int c = zipin.read (); c != - 1; c = zipin.read ()) dest.write (c);
        logger.info (TAG + ": Ajout de l'entr�e: " + entry.getName () + " du fichier: " + tempFile.getAbsolutePath ());
        files.put (entry.getName (), tempFile);
        out.close ();
        dest.close ();
    }
    zipin.close ();
    in.close ();
    src.close ();
    return files;
}


public static URL toFileUrl (URL location) throws IOException {
    String protocol = location.getProtocol ().intern ();
    if (protocol != "jar") throw new IOException ("cannot explode " + location);
    JarURLConnection juc = (JarURLConnection) location.openConnection ();
    String path = juc.getEntryName ();
    String parentPath = parentPathOf (path);
    File tempDir = createTempDir ("jartemp");
    JarFile jarFile = juc.getJarFile ();
    for (Enumeration < JarEntry > en = jarFile.entries (); en.hasMoreElements ();) {
        ZipEntry entry = en.nextElement ();
        if (entry.isDirectory ()) continue;
        String entryPath = entry.getName ();
        if (entryPath.startsWith (parentPath)) {
            File dest = new File (tempDir, entryPath);
            dest.getParentFile ().mkdirs ();
            InputStream in = jarFile.getInputStream (entry);
            OutputStream out = new FileOutputStream (dest);
            IOUtils.copy (in, out);
            dest.deleteOnExit ();
        }
    }
    File realFile = new File (tempDir, path);
    return realFile.toURL ();
}


-----Function Pair=121=-----==

public static File openZIP (File zip, String folder) throws FileNotFoundException, IOException, ZipException {
    if (! zip.exists ()) {
        throw new FileNotFoundException (zip.getAbsolutePath ());
    }
    ZipFile zipFile = new ZipFile (zip.getAbsolutePath ());
    Enumeration entries = zipFile.entries ();
    File file = new File (folder);
    if (! file.exists ()) {
        file.mkdirs ();
    }
    FileOutputStream output;
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.isDirectory ()) {
            new File (folder + File.separator + entry.getName ().substring (0, entry.getName ().lastIndexOf ("/"))).mkdirs ();
        }
        else if (entry.getName ().contains ("/")) {
            new File (folder + File.separator + entry.getName ().substring (0, entry.getName ().lastIndexOf ("/"))).mkdirs ();
        }
        else {
            FileUtils.copyInputStream (zipFile.getInputStream (entry), output = new FileOutputStream (file.getAbsolutePath () + File.separator + entry.getName ()));
            output.close ();
        }
    }
    zipFile.close ();
    return file;
}


private void UpdateTopicOwners (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_owner where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        Hashtable owners = t.GetOwner ();
        if (owners != null && ! owners.isEmpty ()) {
            sql = "insert into topic_owner(topid,userid) values(?,?)";
            pstmt = inCtxt.GetConnection ().prepareStatement (sql);
            Enumeration owners_elements = owners.elements ();
            while (owners_elements.hasMoreElements ()) {
                Topic.Owner owner = (Topic.Owner) owners_elements.nextElement ();
                pstmt.setString (1, t.GetId ());
                pstmt.setString (2, owner.GetID ());
                pstmt.executeUpdate ();
            }
        }
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=122=-----==

public static String convertHexadecimal2RGB (String hexColor, String divider) {
    String hex = hexColor.replaceFirst ("#", "");
    if (hex.length () != 6) return null;
    StringBuilder sb = new StringBuilder ();
    String toCon = hex.substring (0, 2);
    int color = Integer.parseInt (toCon, 16);
    sb.append (color);
    for (int i = 2; i < 6; i += 2) {
        toCon = hex.substring (i, i + 2);
        color = Integer.parseInt (toCon, 16);
        sb.append (divider);
        sb.append (color);
    }
    return sb.toString ();
}


public String getParentOfPath (String path) {
    ArchivePath archive = new ArchivePath (path);
    String archiveProtocol = archive.protocol;
    String archivePath = archive.pathName;
    String archiveEntry = archive.entryName;
    int fileSeparatorIdx = archiveEntry.lastIndexOf (ArchiveVFS.fileSeparatorChar);
    if (fileSeparatorIdx != - 1) {
        return (archiveProtocol + ':' + archivePath + ArchiveVFS.archiveSeparator + ArchiveVFS.fileSeparator + archiveEntry.substring (0, fileSeparatorIdx));
    }
    if (archiveEntry.length () > 0) {
        return (archiveProtocol + ':' + archivePath + ArchiveVFS.archiveSeparator);
    }
    VFS vfs = VFSManager.getVFSForPath (archivePath);
    return vfs.getParentOfPath (archivePath);
}


-----Function Pair=123=-----==

public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + Misc.stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


public static final File saveEntry (final ZipFile zf, final ZipEntry target, final String parentDir) throws Exception, IOException {
    InputStream in = null;
    OutputStream out = null;
    try {
        if (! target.isDirectory ()) {
            final File file = new File (parentDir + File.separator + target.getName ());
            file.getParentFile ().mkdirs ();
            try {
                file.createNewFile ();
            } catch (final Exception e) {
                System.out.println ("�����ļ��������" + file.getAbsolutePath ());
                throw e;
            }
            in = zf.getInputStream (target);
            out = new FileOutputStream (file);
            final byte [] bytes = new byte [10240];
            int readed = - 1;
            while (true) {
                readed = in.read (bytes);
                if (readed == - 1) break;
                out.write (bytes, 0, readed);
            }
            return file;
        }
    } catch (final Exception e) {
        throw e;
    } finally {
        IOUtils.closeIO (in, out);
    }
    return null;
}


-----Function Pair=124=-----==

public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + Misc.stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


public static void extract (ZipFile zipFile, ZipEntry zipEntry, File toDir) throws IOException {
    File file = new File (toDir, zipEntry.getName ());
    File parentDir = file.getParentFile ();
    if (! parentDir.exists ()) {
        parentDir.mkdirs ();
    }
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try {
        InputStream istr = zipFile.getInputStream (zipEntry);
        bis = new BufferedInputStream (istr);
        FileOutputStream fos = new FileOutputStream (file);
        bos = new BufferedOutputStream (fos);
        StreamUtils.copyStream (bis, bos);
    } finally {
        if (bis != null) {
            bis.close ();
        }
        if (bos != null) {
            bos.close ();
        }
    }
}


-----Function Pair=125=-----==

public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + Misc.stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


private byte [] editTaskPage (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskEdit.html");
    String captcha = store.getProperty ("security.captcha");
    if ("1".equals (captcha)) {
        template.replaceAll ("$usingCAPTCHA$", "true");
    }
    else {
        template.replaceAll ("$usingCAPTCHA$", "false");
    }
    String taskName = urlData.getParameter ("name");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    TaskCommand task = (TaskCommand) tasks.get (taskName);
    if (task != null) {
        template.replaceAll ("$taskName", taskName);
        String command = task.getCommand ();
        command = command.replaceAll ("\"", "&#34;");
        command = command.replaceAll ("<", "&lt;");
        command = command.replaceAll (">", "&gt;");
        template.replaceAll ("$taskCommand", command);
        template.replaceAll ("$taskDelayFor", new Integer (task.getDelay ()).toString ());
        if (task.getAutoRemove ()) template.replaceAll ("$autoRemove", "checked");
        else template.replaceAll ("$autoRemove", "");
        template.replaceAll ("$concurrentTasks", new Integer (task.getConcurrent ()).toString ());
        template.replaceAll ("$timeToNextSchedule", new Integer (task.getTimeToNextSchedule ()).toString ());
        if (task.getWhenNotCapturing ()) template.replaceAll ("$whenNotCapturing", "checked");
        else template.replaceAll ("$whenNotCapturing", "");
    }
    else {
        String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
        return out.getBytes ();
    }
    return template.getPageBytes ();
}


-----Function Pair=126=-----=1=

public static void writeZipFile (String location, Map < String, String > files) {
    Set < Entry < String, String > > entrySet = files.entrySet ();
    ZipOutputStream zo = null;
    try {
        zo = new ZipOutputStream (new FileOutputStream (location));
        for (Iterator < Entry < String, String > > iter = entrySet.iterator (); iter.hasNext ();) {
            Map.Entry < String, String > entry = iter.next ();
            String zipFileName = entry.getKey ();
            String zipFileContent = entry.getValue ();
            ZipEntry zEntry = new ZipEntry (zipFileName);
            BufferedInputStream bis = new BufferedInputStream (new ByteArrayInputStream (zipFileContent.getBytes ()));
            int bytesRead;
            byte [] buffer = new byte [1024];
            zEntry.setMethod (ZipEntry.DEFLATED);
            zo.putNextEntry (zEntry);
            while ((bytesRead = bis.read (buffer)) != - 1) {
                zo.write (buffer, 0, bytesRead);
            }
            bis.close ();
        }
    } catch (IOException e) {
        throw new RuntimeException (e);
    } finally {
        try {
            zo.close ();
        } catch (IOException e) {
            throw new RuntimeException (e);
        }
    }
}


private void addAllImages (Environment en, ZipOutputStream zipout, int progressStart, int progressLength) throws IOException {
    String [] files = new File (imageDir).list ();
    int bytesRead = 0;
    byte byteArray [] = new byte [4096];
    FileInputStream in = null;
    for (int i = 0; i < files.length; i ++) {
        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / files.length), 99);
        File fileToHandle = new File (imageDir, files [i]);
        if (fileToHandle.isFile () && fileToHandle.canRead ()) {
            try {
                logger.fine ("Adding image file " + files [i]);
                ZipEntry entry = new ZipEntry ("images/" + files [i]);
                zipout.putNextEntry (entry);
                in = new FileInputStream (fileToHandle);
                while (in.available () > 0) {
                    bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
                    zipout.write (byteArray, 0, bytesRead);
                }
            } catch (FileNotFoundException e) {
            } catch (IOException e) {
            } finally {
                try {
                    zipout.closeEntry ();
                } catch (IOException e1) {
                }
                try {
                    zipout.flush ();
                } catch (IOException e1) {
                }
                try {
                    if (in != null) {
                        in.close ();
                        in = null;
                    }
                } catch (IOException e1) {
                }
            }
        }
    }
}


-----Function Pair=127=-----==

public String getImage (boolean molecule, String format, String path, int width, int height, boolean drawNumbers, DBAtom [] atoms) throws Exception {
    String inputstr;
    if (molecule) {
        inputstr = getMolSvg (width, height, drawNumbers);
    }
    else {
        inputstr = getSpecSvg (width, height, atoms);
    }
    ImageTranscoder it = null;
    String imagefile = path;
    if (format.equals ("jpeg")) {
        it = new JPEGTranscoder ();
        it.addTranscodingHint (JPEGTranscoder.KEY_QUALITY, new Float (.8));
        imagefile += ".jpg";
    }
    if (format.equals ("tiff")) {
        it = new TIFFTranscoder ();
        imagefile += ".tif";
    }
    if (format.equals ("png")) {
        it = new PNGTranscoder ();
        imagefile += ".png";
    }
    TranscoderInput input = new TranscoderInput (new StringReader (inputstr));
    OutputStream ostream = new FileOutputStream (imagefile);
    TranscoderOutput output = new TranscoderOutput (ostream);
    it.transcode (input, output);
    ostream.flush ();
    ostream.close ();
    return (imagefile);
}


public String button1_action () {
    RowKey [] selectedRowKeys = getTrgAttachments ().getSelectedRowKeys ();
    ServletOutputStream out = null;
    FileInputStream fileToDownload = null;
    ZipOutputStream zout = null;
    try {
        byte [] buf = new byte [1024];
        String outFilename = "mewit_files_" + UUID.randomUUID ().toString () + ".zip";
        zout = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < selectedRowKeys.length; i ++) {
            Attachment attachment = (Attachment) getSessionBean1 ().getFileRepositoryDP ().getObject (selectedRowKeys [i]);
            FileInputStream in = new FileInputStream (attachment.getFilePath ());
            zout.putNextEntry (new ZipEntry (attachment.getFileName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                zout.write (buf, 0, len);
            }
            zout.closeEntry ();
            in.close ();
        }
        zout.close ();
        java.io.File zipFile = new java.io.File (outFilename);
        fileToDownload = new FileInputStream (zipFile);
        HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance ().getExternalContext ().getResponse ();
        out = response.getOutputStream ();
        response.setHeader ("Content-Disposition", "attachment; filename=\"" + zipFile.getName () + "\"");
        response.setContentLength (fileToDownload.available ());
        int c;
        while ((c = fileToDownload.read ()) != - 1) {
            out.write (c);
        }
        out.flush ();
    } catch (Exception ex) {
        LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
    } finally {
        if (fileToDownload != null) {
            try {
                fileToDownload.close ();
            } catch (IOException ex) {
                LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException ex) {
                LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
            }
        }
    }
    return null;
}


-----Function Pair=128=-----==

public void execute () throws MojoExecutionException, MojoFailureException {
    printLicenseInfo ();
    final File finalFile = new File (buildDirectory, finalFileName);
    final List < File > libFiles = getDependencyFiles (artifacts, false, true);
    Manifest manifest = null;
    try {
        manifest = createManifest (libFiles);
    } catch (IOException e) {
        logger.error (e);
    }
    JarOutputStream out = null;
    try {
        out = new JarOutputStream (new FileOutputStream (finalFile, false), manifest);
        if (this.onejarLicenseURL != null) {
            logger.info ("Adding one-jar-license.txt to archive.");
            final URLConnection con = onejarLicenseURL.openConnection ();
            final InputStream inStream = con.getInputStream ();
            addEntryToZip (out, new ZipEntry ("one-jar-license.txt"), inStream);
        }
        logger.info ("Adding MainJAR to archive at main/" + mainJarFilename);
        addFileToZip (out, "main/", new File (buildDirectory, mainJarFilename));
        logger.info ("Adding [" + libFiles.size () + "] libaries...");
        for (File lib : libFiles) {
            final String libName = lib.getName ();
            logger.info ("Add lib: " + libName);
            if (this.unpackJARs != null && this.unpackJARs.contains (libName) && libName.endsWith (".jar")) {
                final File file = lib.getAbsoluteFile ();
                final FileInputStream fileInStream = new FileInputStream (file);
                final JarInputStream jarInStream = new JarInputStream (fileInStream);
                try {
                    logger.info ("Unpack " + libName + " contents...");
                    ZipEntry entry = jarInStream.getNextEntry ();
                    while (entry != null) {
                        try {
                            addEntryToZip (out, entry, jarInStream);
                        } catch (Exception e) {
                            printDebug (e);
                        }
                        entry = jarInStream.getNextEntry ();
                    }
                } finally {
                    IOUtils.closeQuietly (jarInStream);
                }
                continue;
            }
            if (lib.isFile () && libName.endsWith (".jar")) {
                addFileToZip (out, "lib/", lib);
            }
            else {
                addFileToZip (out, "binlib/", lib);
            }
        }
    } catch (IOException e) {
        logger.error (e);
    } finally {
        IOUtils.closeQuietly (out);
    }
    final String format = this.project.getArtifact ().getType ();
    logger.info ("Adding file:" + finalFile.getAbsolutePath () + "\n       to the list of artifacts with format " + format);
    projectHelper.attachArtifact (this.project, format, "one-jar", finalFile);
}


protected void mergeSortedFiles (File outFile) throws IOException {
    SortedMap < String, ElementDescriptor > sortedDescriptors = new TreeMap < String, ElementDescriptor > ();
    for (int index = 0; index <= iterationNum; index ++) {
        String fileName = workingDirectory.getPath () + File.separator + workingFileName + index + ".csv";
        System.out.println ("Adding file to merge: " + fileName);
        File file = new File (fileName);
        BufferedReader reader = new BufferedReader (new FileReader (file));
        ElementDescriptor desc = new ElementDescriptor ();
        desc.ligne = reader.readLine ();
        desc.reader = reader;
        desc.fileName = fileName;
        desc.key = generateKeyFromLine (desc.ligne);
        sortedDescriptors.put (desc.key, desc);
    }
    OutputStream fos = new FileOutputStream (outFile);
    if (zipOutputFile) {
        fos = new ZipOutputStream (fos);
        ((ZipOutputStream) fos).setLevel (9);
        int index = outFile.getName ().toLowerCase ().indexOf (".zip");
        ZipEntry entry = new ZipEntry (outFile.getName ().substring (0, index));
        ((ZipOutputStream) fos).putNextEntry (entry);
    }
    while (sortedDescriptors.size () > 0) {
        ElementDescriptor smallestDesc = getSmallestDescriptor (sortedDescriptors);
        fos.write ((smallestDesc.ligne + "\n").getBytes ());
        sortedDescriptors.remove (smallestDesc.key);
        smallestDesc.ligne = smallestDesc.reader.readLine ();
        if (smallestDesc.ligne != null) {
            smallestDesc.key = generateKeyFromLine (smallestDesc.ligne);
            sortedDescriptors.put (smallestDesc.key, smallestDesc);
        }
        else {
            smallestDesc.reader.close ();
            if (dropTempFiles) {
                File descFile = new File (smallestDesc.fileName);
                if (! descFile.delete ()) System.out.println ("Chunk file: '" + smallestDesc.fileName + "' could not be deleted. Still opened?");
                else System.out.println ("Chunk file: '" + smallestDesc.fileName + "' has been deleted properly.");
            }
        }
    }
    fos.flush ();
    fos.close ();
}


-----Function Pair=129=-----==

private List < String > getPackages () throws ZipException, IOException {
    List < String > packages = new ArrayList < String > ();
    BufferedInputStream inputStream = null;
    try {
        ZipEntry entry;
        ZipFile zipfile = new ZipFile (fzipIn);
        Enumeration < ? > e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            if (entry.getName ().endsWith (".class")) {
                String name = entry.getName ();
                name = name.substring (0, name.length () - 6);
                int endIndex = name.lastIndexOf ('/');
                if (endIndex > - 1) {
                    name = name.substring (0, endIndex);
                }
                name = name.replaceAll ("/", "\\.");
                if (! packages.contains (name)) {
                    packages.add (name);
                }
            }
        }
    } finally {
        if (inputStream != null) {
            inputStream.close ();
        }
    }
    return packages;
}


public static String getConfigFolder (final String sAppName, final String [] filesToSearch) {
    final List < String > folders = new LinkedList < String > ();
    try {
        File fDir = new File (".");
        if (fDir.isDirectory () && fDir.canRead ()) {
            String sPath = fDir.getCanonicalPath ();
            folders.add (sPath + File.separator + "config" + File.separator + sAppName);
            folders.add (sPath + File.separator + "config");
            folders.add (sPath);
        }
        fDir = new File ("..");
        if (fDir.isDirectory () && fDir.canRead ()) {
            String sPath = fDir.getCanonicalPath ();
            folders.add (sPath + File.separator + "config" + File.separator + sAppName);
            folders.add (sPath + File.separator + "config");
            folders.add (sPath);
        }
    } catch (IOException _) {
    }
    folders.add (System.getProperty ("user.home") + File.separator + '.' + sAppName);
    folders.add ("/etc/" + sAppName);
    for (String sPath : folders) {
        File f = new File (sPath);
        if (! f.isDirectory () || ! f.canRead ()) continue;
        for (String sFile : filesToSearch) {
            f = new File (sPath, sFile);
            if (f.isFile () && f.canRead ()) return sPath;
        }
    }
    return null;
}


-----Function Pair=130=-----==

public boolean storeDataForTransactionIdentifier (String transactionIdentifier, InputStream inputStream, int inputLength) {
    try {
        if (true) {
            System.out.println ("This does not work because Java 1.5 does not support appending to zip files");
            return false;
        }
        ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (this.zipFilePath, true));
        ZipEntry entry = new ZipEntry (ArchiveFileSupport.fileNameForTransactionIdentifier (transactionIdentifier));
        zipOutputStream.putNextEntry (entry);
        byte [] buffer = new byte [4096];
        int length;
        while ((length = inputStream.read (buffer)) > 0) {
            zipOutputStream.write (buffer, 0, length);
        }
        zipOutputStream.closeEntry ();
        zipOutputStream.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return true;
}


public boolean doLogin (String [] msg) {
    if (isAnonymous ()) {
        return true;
    }
    try {
        getInfo ();
        List entries = new ArrayList ();
        entries.add (HttpFormEntry.hidden (ARG_RESPONSE, RESPONSE_XML));
        entries.add (HttpFormEntry.hidden (ARG_USER_PASSWORD, getPassword ()));
        entries.add (HttpFormEntry.hidden (ARG_USER_ID, getUser ()));
        String [] result = doPost (URL_USER_LOGIN, entries);
        if (result [0] != null) {
            msg [0] = "Error logging in: " + result [0];
            return false;
        }
        String contents = result [1];
        Element root = XmlUtil.getRoot (contents);
        String body = XmlUtil.getChildText (root).trim ();
        if (responseOk (root)) {
            sessionId = body;
            return true;
        }
        else {
            msg [0] = body;
            return false;
        }
    } catch (java.io.IOException exc) {
        exc.printStackTrace ();
        msg [0] = "Could not connect to server: " + getHostname ();
    } catch (Exception exc) {
        msg [0] = "An error occurred: " + exc + "\n";
    }
    return false;
}


-----Function Pair=131=-----==

private void publishPage (URL url, String path, File outputFile) throws IOException {
    if (debug) {
        System.out.println ("      publishing page: " + path);
        System.out.println ("        url == " + url);
        System.out.println ("        file == " + outputFile);
    }
    StringBuffer sb = new StringBuffer ();
    try {
        InputStream is = url.openStream ();
        InputStreamReader isr = new InputStreamReader (is);
        BufferedReader br = new BufferedReader (isr);
        boolean firstLine = true;
        String line;
        do {
            line = br.readLine ();
            if (line != null) {
                if (! firstLine) sb.append ("\n");
                else firstLine = false;
                sb.append (line);
            }
        }
        while (line != null);
        br.close ();
    } catch (IOException e) {
        String mess = outputFile.toString () + ": " + e.getMessage ();
        errors.add (mess);
    }
    FileOutputStream fos = new FileOutputStream (outputFile);
    OutputStreamWriter sw = new OutputStreamWriter (fos);
    sw.write (sb.toString ());
    sw.close ();
    if (prepareArchive) archiveFiles.add (new ArchiveFile (path, outputFile));
}


public void paintMapAtTile (int x, int y, int w, int h, int toptx, int topty, int skip_above) {
    synchronized (win) {
        int savescrolltx = scrolltx, savescrollty = scrollty;
        int saveskip = skipLift;
        scrolltx = toptx;
        scrollty = topty;
        skipLift = skip_above;
        map.readMapData ();
        win.setClip (x, y, w, h);
        render.paintMap (0, 0, getWidth (), getHeight ());
        win.clearClip ();
        scrolltx = savescrolltx;
        scrollty = savescrollty;
        skipLift = saveskip;
    }
}


-----Function Pair=132=-----==

public static String get_ssl_page (String s) throws Exception {
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault ();
    SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket ("www.google.com", 443);
    PrintStream outStream = new PrintStream (sslsocket.getOutputStream ());
    outStream.println (s);
    outStream.flush ();
    DataInputStream inStream = new DataInputStream (sslsocket.getInputStream ());
    StringBuffer stb = new StringBuffer ();
    int ch = ' ';
    for (ch = inStream.read (); ch > 0; ch = inStream.read ()) {
        stb.append ((char) ch);
        if (stb.indexOf ("</html>") > - 1 || stb.indexOf ("</HTML>") > - 1) break;
    }
    inStream.close ();
    outStream.close ();
    sslsocket.close ();
    return stb.toString ();
}


private String convertReferencePath (String attributeValue, int contentPathLength, String filePathFromConvert) {
    int index = attributeValue.indexOf (ASSOCIATED_FILES_PREFIX);
    int lengthPrefix = ASSOCIATED_FILES_PREFIX.length () + index;
    String filePathToConvert = null;
    String contentPathPrefix = attributeValue.substring (lengthPrefix, index + contentPathLength - 1);
    try {
        UUID.fromString (contentPathPrefix);
        filePathToConvert = attributeValue.substring (index + ASSOCIATED_FILES_PREFIX.length () + 37);
        if (filePathFromConvert != null) {
            filePathToConvert = convertPathRelativeToFile (filePathToConvert, filePathFromConvert);
        }
    } catch (IllegalArgumentException iae) {
        log.debug ("Malformed rootFolder UUID: " + iae);
        return null;
    }
    return filePathToConvert;
}


-----Function Pair=133=-----==

public String getZipChildName (String unZipfileName) {
    StringBuffer rtn = new StringBuffer ();
    try {
        this.zipFile = new ZipFile (unZipfileName);
        String fullName = "";
        for (Enumeration entries = this.zipFile.getEntries (); entries.hasMoreElements ();) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            if (! entry.isDirectory ()) {
                fullName = entry.getName ();
                fullName = fullName.substring (fullName.indexOf ("/") + 1);
                rtn.append (",").append (fullName);
            }
        }
        this.zipFile.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    return rtn.toString ().substring (1);
}


public String [] readLineByLine (String fileName) {
    ArrayList < String > al = new ArrayList < String > ();
    String currline = "";
    try {
        if (! new File (fileName).exists ()) new File (fileName).createNewFile ();
        FileInputStream fis = new FileInputStream (new File (fileName));
        InputStreamReader isr = new InputStreamReader (fis);
        BufferedReader reader = new BufferedReader (isr);
        while ((currline != null)) {
            currline = reader.readLine ();
            if (currline != null) al.add (currline);
        }
        reader.close ();
        isr.close ();
        fis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return (String []) al.toArray (new String [0]);
}


-----Function Pair=134=-----==

public void importComponent (HierarchyNode parent) throws ApplicationException {
    JFileChooser fc = getOpenFileChooser ();
    int returnVal = fc.showOpenDialog (this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        freeze (true);
        File file = fc.getSelectedFile ();
        Document doc = openDoc (file);
        String reason = "Unknown reason";
        if (doc != null) {
            importComponentDirect (parent, doc);
        }
        freeze (false);
        if (doc == null) {
            throw new ApplicationException ("Import failed - " + reason);
        }
        setDirty (true);
    }
}


public boolean writeZip (TreeMap < Integer, Sprite > sprites, File file) {
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (new File (file.toString ().replaceAll (".pak", "_NEW.pak"))));
        out.setLevel (9);
        for (Entry < Integer, Sprite > e : sprites.entrySet ()) {
            String name = String.valueOf (e.getKey ());
            Sprite sprite = e.getValue ();
            out.putNextEntry (new ZipEntry (name));
            out.write (sprite.pack ().array ());
            out.closeEntry ();
        }
        out.close ();
        return true;
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        return false;
    }
}


-----Function Pair=135=-----==

public static void deleteDir (File file) throws IOException {
    if (file.isDirectory ()) {
        if (file.list ().length == 0) {
            file.delete ();
        }
        else {
            String files [] = file.list ();
            for (String temp : files) {
                File fileDelete = new File (file, temp);
                deleteDir (fileDelete);
            }
            if (file.list ().length == 0) {
                file.delete ();
            }
        }
    }
    else {
        file.delete ();
    }
}


public boolean esFichero (String rutaFichero) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'esFichero' ***********");
    boolean estado = false;
    File archivo = new File (rutaFichero);
    boolean existe = archivo.exists ();
    try {
        if (existe == true) {
            if (archivo.isFile () == true) {
                System.out.println ("El archivo es un Fichero ...!!!");
                estado = true;
            }
            else {
                System.out.println ("El archivo no es un Fichero ...!!!");
                estado = false;
            }
        }
        else {
            System.out.println ("La ruta no existe ...!!!");
        }
    } catch (Exception e) {
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


-----Function Pair=136=-----==

public static void dos2unix (File file) {
    if (file.isDirectory () || ! file.exists ()) return;
    String name = file.getName ();
    boolean found = false;
    File tempFile = new File (file.getAbsolutePath () + ".tmp");
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        BufferedWriter out = new BufferedWriter (new FileWriter (tempFile));
        int c;
        while ((c = in.read ()) != - 1) {
            if (c != '\r') out.write (c);
        }
        in.close ();
        out.close ();
        file.delete ();
        tempFile.renameTo (file);
    } catch (IOException e) {
        throw new RuntimeException (e.getClass () + e.getMessage ());
    }
}


public boolean save (String content) throws IOException {
    FileUtility toFile = this;
    if (this.isDirectory ()) abort ("FileUtility: destination is a directory: " + pathName);
    if (toFile.exists ()) {
        if (! toFile.canWrite ()) {
            abort ("FileUtility: destination file is unwriteable: " + pathName);
            return false;
        }
    }
    else {
        String parent = toFile.getParent ();
        File dir = new File (parent);
        if (! dir.exists ()) {
            abort ("FileUtility: destination directory doesn't exist: " + parent);
            return false;
        }
        if (dir.isFile ()) {
            abort ("FileUtility: destination is not a directory: " + parent);
            return false;
        }
        if (! dir.canWrite ()) {
            abort ("FileUtility: destination directory is unwriteable: " + parent);
            return false;
        }
    }
    FileOutputStream to = null;
    try {
        to = new FileOutputStream (toFile);
        byte [] buffer = content.getBytes ();
        int bytes_read = buffer.length;
        to.write (buffer);
    } finally {
        if (to != null) try {
            to.close ();
        } catch (IOException e) {
        }
    }
    return true;
}


-----Function Pair=137=-----==

private static void createIndex (JarOutputStream jos, List oldEntries, Map movedMap) throws IOException {
    StringWriter writer = new StringWriter ();
    writer.write (VERSION_HEADER);
    writer.write ("\r\n");
    for (int counter = 0; counter < oldEntries.size (); counter ++) {
        String name = (String) oldEntries.get (counter);
        writer.write (REMOVE_COMMAND);
        writer.write (" ");
        writeEscapedString (writer, name);
        writer.write ("\r\n");
    }
    Iterator names = movedMap.keySet ().iterator ();
    if (names != null) {
        while (names.hasNext ()) {
            String newName = (String) names.next ();
            String oldName = (String) movedMap.get (newName);
            writer.write (MOVE_COMMAND);
            writer.write (" ");
            writeEscapedString (writer, oldName);
            writer.write (" ");
            writeEscapedString (writer, newName);
            writer.write ("\r\n");
        }
    }
    ZipEntry je = new ZipEntry (INDEX_NAME);
    byte [] bytes = writer.toString ().getBytes ("UTF-8");
    writer.close ();
    jos.putNextEntry (je);
    jos.write (bytes, 0, bytes.length);
}


private void addToJarEncoded (JarOutputStream out, InputStreamReader isr, String entryName, long length) throws IOException {
    StringBuffer buffer = new StringBuffer ();
    Reader reader = new BufferedReader (isr);
    int ch;
    while ((ch = reader.read ()) > - 1) {
        buffer.append ((char) ch);
    }
    reader.close ();
    isr.close ();
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    OutputStreamWriter osw = new OutputStreamWriter (baos, "UTF8");
    osw.write (buffer.toString ());
    osw.flush ();
    ByteArrayInputStream bais = new ByteArrayInputStream (baos.toByteArray ());
    addToJar (out, bais, entryName, length);
}


-----Function Pair=138=-----==

private void writeRawData (IMessageBeanManager messageBeanManager, IMessageBeanDescriptor messageBeanDescriptor) {
    IDerivativeConverter < DataOutputStream > derivativeConverter = DerivativeFactory.createDerivativeConverter (DataOutputStream.class);
    ZipEntry ze = new ZipEntry (messageBeanDescriptor.getCanonicalName () + "_" + DATA);
    ze.setComment ((null == messageBeanDescriptor.getDescription ()) ? Namespace.NULL_TOKEN : messageBeanDescriptor.getDescription ());
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    DataOutputStream dos = new DataOutputStream (baos);
    try {
        Class messageBeanClass = Class.forName (messageBeanDescriptor.getCanonicalName ());
        PropertyDescriptor [] propertyDescriptors = BeanUtil.propertyDescriptors (messageBeanClass);
        if (null != propertyDescriptors) {
            Map < String, Method > methodMap = new HashMap < String, Method > ();
            for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {
                methodMap.put (propertyDescriptor.getName (), propertyDescriptor.getReadMethod ());
            }
            for (Object o : messageBeanManager.createIterator (messageBeanClass)) {
                for (IMessageBeanProperty beanProperty : messageBeanDescriptor.properties ()) {
                    logger.fine ("Deriving value of property " + beanProperty.getId ());
                    if (beanProperty.getDataType () != DataType.IdentityType && beanProperty.getDataType () != DataType.TransientType) {
                        Object value = null;
                        try {
                            Method readMethod = methodMap.get (beanProperty.getId ());
                            if (null != readMethod) {
                                value = readMethod.invoke (o);
                            }
                            else {
                                throw new IllegalStateException ("Incorrectly mapped property '" + beanProperty.getId () + "': please fix the property name in the IMessageBeanDescriptor registration");
                            }
                        } catch (IllegalAccessException e) {
                            e.printStackTrace ();
                        } catch (InvocationTargetException e) {
                            e.printStackTrace ();
                        }
                        derivativeConverter.convert (dos, beanProperty.getDataType (), value, IPackagingVisitor.DIRECTION_OUT);
                    }
                }
            }
            try {
                dos.flush ();
                dos.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
            try {
                byte [] data = baos.toByteArray ();
                ze.setSize (data.length);
                zipStream.putNextEntry (ze);
                zipStream.write (data, 0, data.length);
                zipStream.closeEntry ();
                zipStream.flush ();
                logger.fine ("Wrote data zip entry " + ze.getName ());
            } catch (Exception e) {
                logger.warning ("Unable to serialize message bean descriptor " + messageBeanDescriptor.toString () + ": " + e.getMessage ());
            }
        }
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
}


private boolean doLinkFinal (TreeLogger logger, File compilerWorkDir, ModuleDef module, JJSOptions precompileOptions) throws UnableToCompleteException {
    int numPermutations = new PropertyPermutations (module.getProperties (), module.getActiveLinkerNames ()).collapseProperties ().size ();
    List < File > resultFiles = new ArrayList < File > (numPermutations);
    for (int i = 0; i < numPermutations; ++ i) {
        File f = CompilePerms.makePermFilename (compilerWorkDir, i);
        if (! f.exists ()) {
            logger.log (TreeLogger.ERROR, "File not found '" + f.getAbsolutePath () + "'; please compile all permutations");
            return false;
        }
        resultFiles.add (f);
    }
    TreeLogger branch = logger.branch (TreeLogger.INFO, "Linking module " + module.getName ());
    StandardLinkerContext linkerContext = new StandardLinkerContext (branch, module, precompileOptions);
    try {
        OutputFileSet outFileSet = chooseOutputFileSet (options.getWarDir (), module.getName () + "/");
        OutputFileSet extraFileSet = chooseOutputFileSet (options.getExtraDir (), module.getName () + "/");
        OutputFileSet deployFileSet;
        if (options.getDeployDir ().equals (options.getExtraDir ())) {
            deployFileSet = extraFileSet;
        }
        else {
            deployFileSet = chooseOutputFileSet (options.getDeployDir (), module.getName () + "/");
        }
        ArtifactSet artifacts = scanCompilePermResults (logger, resultFiles);
        artifacts.addAll (linkerContext.getArtifactsForPublicResources (logger, module));
        artifacts = linkerContext.invokeFinalLink (logger, artifacts);
        doProduceOutput (logger, artifacts, linkerContext, outFileSet, deployFileSet, extraFileSet);
    } catch (IOException e) {
        logger.log (TreeLogger.ERROR, "Exception during final linking", e);
        throw new UnableToCompleteException ();
    }
    return true;
}


-----Function Pair=139=-----==

public static File getFileByExtension (ZipFile zipFile, String extension) throws IOException {
    Enumeration entries = zipFile.getEntries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.getName ().indexOf ("." + extension) != - 1) {
            InputStream in = zipFile.getInputStream (entry);
            File rtn = new File (entry.getName ());
            FileOutputStream out = new FileOutputStream (rtn);
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                out.write (buffer, 0, nNumber);
            }
            in.close ();
            out.close ();
            return rtn;
        }
    }
    return null;
}


public static void copyDirectory (File srcPath, File dstPath) throws IOException {
    if (srcPath.isDirectory ()) {
        if (! dstPath.exists ()) {
            dstPath.mkdir ();
        }
        String files [] = srcPath.list ();
        for (int i = 0; i < files.length; i ++) {
            copyDirectory (new File (srcPath, files [i]), new File (dstPath, files [i]));
        }
    }
    else {
        if (! srcPath.exists ()) {
            System.out.println ("File or directory does not exist.");
            return;
        }
        else {
            InputStream in = new FileInputStream (srcPath);
            OutputStream out = new FileOutputStream (dstPath);
            byte [] buf = new byte [1024];
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=140=-----==

public static void unzip (String zipFilename, String outdir) throws IOException {
    ZipFile zipFile = new ZipFile (zipFilename);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        byte [] buffer = new byte [1024];
        int len;
        InputStream zipin = zipFile.getInputStream (entry);
        BufferedOutputStream fileout = new BufferedOutputStream (new FileOutputStream (outdir + "\\" + entry.getName ()));
        while ((len = zipin.read (buffer)) >= 0) fileout.write (buffer, 0, len);
        zipin.close ();
        fileout.flush ();
        fileout.close ();
    }
}


private static void zip (File srcDir, File originSrcDir, ZipOutputStream dstStream) throws IOException {
    byte [] buffer = new byte [ZIP_BUFFER_SIZE];
    int bytes = 0;
    String [] dirList = srcDir.list ();
    for (int i = 0; i < dirList.length; i ++) {
        File file = new File (srcDir, dirList [i]);
        if (file.isDirectory ()) {
            zip (file, originSrcDir, dstStream);
            continue;
        }
        FileInputStream fis = new FileInputStream (file);
        ZipEntry entry = new ZipEntry (TFileHandler.removeDirectoryPath (originSrcDir.getAbsolutePath (), file.getAbsolutePath ()));
        dstStream.putNextEntry (entry);
        while ((bytes = fis.read (buffer)) != - 1) dstStream.write (buffer, 0, bytes);
        fis.close ();
    }
}


-----Function Pair=141=-----==

public static void unzip (String zipFilename, String outdir) throws IOException {
    ZipFile zipFile = new ZipFile (zipFilename);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        byte [] buffer = new byte [1024];
        int len;
        InputStream zipin = zipFile.getInputStream (entry);
        BufferedOutputStream fileout = new BufferedOutputStream (new FileOutputStream (outdir + "\\" + entry.getName ()));
        while ((len = zipin.read (buffer)) >= 0) fileout.write (buffer, 0, len);
        zipin.close ();
        fileout.flush ();
        fileout.close ();
    }
}


public static int zipFile (File file_input, File dir_output) {
    File zip_output = new File (dir_output, file_input.getName () + ".zip");
    ZipOutputStream zip_out_stream;
    try {
        FileOutputStream out = new FileOutputStream (zip_output);
        zip_out_stream = new ZipOutputStream (new BufferedOutputStream (out));
    } catch (IOException e) {
        return STATUS_OUT_FAIL;
    }
    byte [] input_buffer = new byte [BUF_SIZE];
    int len = 0;
    try {
        ZipEntry zip_entry = new ZipEntry (file_input.getName ());
        zip_out_stream.putNextEntry (zip_entry);
        FileInputStream in = new FileInputStream (file_input);
        BufferedInputStream source = new BufferedInputStream (in, BUF_SIZE);
        while ((len = source.read (input_buffer, 0, BUF_SIZE)) != - 1) zip_out_stream.write (input_buffer, 0, len);
        in.close ();
    } catch (IOException e) {
        return STATUS_ZIP_FAIL;
    }
    try {
        zip_out_stream.close ();
    } catch (IOException e) {
    }
    return STATUS_OK;
}


-----Function Pair=142=-----==

public boolean createProjectAchive (File archiveFile, Iterator fileIterator, String RootPath) {
    File f;
    boolean written;
    try {
        JarOutputStream out = new JarOutputStream (new FileOutputStream (archiveFile));
        out.setComment ("This file was created by jEdit Project Viewer\nCheck http://jedit.org !");
        out.setLevel (9);
        while (fileIterator.hasNext ()) {
            ProjectFile pf = (ProjectFile) fileIterator.next ();
            String RelativePath = pf.getPath ().substring (RootPath.length ());
            RelativePath = RelativePath.substring (0, (RelativePath.length () - pf.getName ().length ()) - 1);
            System.out.println (RelativePath);
            f = new File (pf.getPath ());
            written = writeEntry (f, out, RelativePath);
            if (! written) {
                out.close ();
                archiveFile.delete ();
                return false;
            }
        }
        out.close ();
        return true;
    } catch (Exception e) {
        System.out.println ("[createJar(), JarWriter] ERROR\n" + e);
        return false;
    }
}


public static void unzip1 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    if (! outputdir.exists ()) {
        outputdir.mkdirs ();
    }
    ArchiveInputStream zis = new ZipArchiveInputStream (new FileInputStream (zipfile));
    ArchiveEntry ae = zis.getNextEntry ();
    while (ae != null) {
        File newFile = new File (outputdir + File.separator + ae.getName ());
        if (! newFile.getParentFile ().exists ()) newFile.getParentFile ().mkdirs ();
        if (ae.isDirectory ()) {
            if (! newFile.exists ()) newFile.mkdir ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = zis.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
        }
        ae = zis.getNextEntry ();
    }
    zis.close ();
}


-----Function Pair=143=-----==

public String [] read (File f) {
    ArrayList < String > al = new ArrayList < String > ();
    String currline = "";
    try {
        FileInputStream fis = new FileInputStream (f);
        InputStreamReader isr = new InputStreamReader (fis);
        BufferedReader reader = new BufferedReader (isr);
        while ((currline != null)) {
            currline = reader.readLine ();
            if (currline != null) al.add (currline);
        }
        reader.close ();
        isr.close ();
        fis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return (String []) al.toArray (new String [0]);
}


public static void fileToZIP (File fileName, String zipFileName) {
    try {
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipFileName)));
        byte [] data = new byte [1000];
        BufferedInputStream in = new BufferedInputStream (new FileInputStream (fileName));
        int count;
        out.putNextEntry (new ZipEntry (fileName.getName ()));
        while ((count = in.read (data, 0, 1000)) != - 1) {
            out.write (data, 0, count);
        }
        in.close ();
        out.flush ();
        out.close ();
        System.out.println ("Your file is zipped");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=144=-----=1=

public void close () throws FreezeDryingException {
    try {
        if (! reading) {
            DateFormat format = new SimpleDateFormat ("yyyyMMdd_HH_mm_ss");
            String tmp = zipFileName;
            if (tmp.endsWith (".zip")) {
                tmp = tmp.substring (0, tmp.length () - 4);
            }
            File zipFile = new File (new File (path).getParentFile (), new File (tmp).getName () + "_" + format.format (new Date ()) + ".zip");
            if (! zipFile.exists ()) zipFile.createNewFile ();
            byte [] buf = new byte [1024];
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
            for (String path : writtenFiles) {
                File file = new File (path);
                FileInputStream in = new FileInputStream (file);
                out.putNextEntry (new ZipEntry (file.getName ()));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
            out.close ();
        }
        File dir = new File (path);
        for (File file : dir.listFiles ()) {
            file.delete ();
        }
        dir.delete ();
    } catch (IOException ex) {
        throw new FreezeDryingException ("Error while zipping freezedry files", ex);
    }
}


protected void truncate (File file) {
    LogLog.debug ("Compression of file: " + file.getAbsolutePath () + " started.");
    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {
        File backupRoot = new File (getBackupDir ());
        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {
            throw new AppenderInitializationError ("Can't create backup dir for backup storage");
        }
        SimpleDateFormat df;
        try {
            df = new SimpleDateFormat (getBackupDateFormat ());
        } catch (Exception e) {
            throw new AppenderInitializationError ("Invalid date formate for backup files: " + getBackupDateFormat (), e);
        }
        String date = df.format (new Date (file.lastModified ()));
        File zipFile = new File (backupRoot, file.getName () + "." + date + ".zip");
        ZipOutputStream zos = null;
        FileInputStream fis = null;
        try {
            zos = new ZipOutputStream (new FileOutputStream (zipFile));
            ZipEntry entry = new ZipEntry (file.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            entry.setCrc (FileUtils.checksumCRC32 (file));
            zos.putNextEntry (entry);
            fis = FileUtils.openInputStream (file);
            byte [] buffer = new byte [1024];
            int readed;
            while ((readed = fis.read (buffer)) != - 1) {
                zos.write (buffer, 0, readed);
            }
        } catch (Exception e) {
            throw new AppenderInitializationError ("Can't create zip file", e);
        } finally {
            if (zos != null) {
                try {
                    zos.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zip file", e);
                }
            }
            if (fis != null) {
                try {
                    fis.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zipped file", e);
                }
            }
        }
        if (! file.delete ()) {
            throw new AppenderInitializationError ("Can't delete old log file " + file.getAbsolutePath ());
        }
    }
}


-----Function Pair=145=-----=1=

private void addTopicToZip (Environment en, ZipOutputStream zipout, HashMap containingTopics, SearchEngine sedb, String defaultTopic, List ignoreTheseTopicsList, String topicname) throws Exception, IOException {
    WikiBase wb = WikiBase.getInstance ();
    Template tpl;
    tpl = new Template (ctx.getRealPath ("/WEB-INF/classes/export2html/mastertemplate.tpl"));
    tpl.setFieldGlobal ("VERSION", Environment.WIKI_VERSION);
    StringBuffer oneline = new StringBuffer ();
    if (! ignoreTheseTopicsList.contains (topicname)) {
        oneline.append (topicname);
        tpl.setFieldGlobal ("TOPICNAME", topicname);
        Topic topicObject = new Topic (topicname);
        logger.debug ("Adding topic " + topicname);
        String author = null;
        java.util.Date lastRevisionDate = null;
        if (Environment.getInstance ().isVersioningOn ()) {
            lastRevisionDate = topicObject.getMostRecentRevisionDate (virtualWiki);
            author = topicObject.getMostRecentAuthor (virtualWiki);
            if (author != null || lastRevisionDate != null) {
                tpl.setField ("SHOWVERSIONING1", "-->");
                if (author != null) tpl.setField ("AUTHOR", author);
                if (lastRevisionDate != null) tpl.setField ("MODIFYDATE", Utilities.formatDate (lastRevisionDate));
                tpl.setField ("SHOWVERSIONING2", "<!--");
            }
        }
        StringBuffer content = new StringBuffer ();
        content.append (wb.readCooked (virtualWiki, topicname, en.getStringSetting (Environment.PROPERTY_FORMAT_LEXER), en.getStringSetting (Environment.PROPERTY_LAYOUT_LEXER), "vqwiki.lex.LinkLexExportHTMLWrapper", true));
        String redirect = "redirect:";
        if (content.toString ().startsWith (redirect)) {
            StringBuffer link = new StringBuffer (content.toString ().substring (redirect.length ()).trim ());
            while (link.toString ().indexOf ("<") != - 1) {
                int startpos = link.toString ().indexOf ("<");
                int endpos = link.toString ().indexOf (">");
                if (endpos == - 1) {
                    endpos = link.length ();
                }
                else {
                    endpos ++;
                }
                link.delete (startpos, endpos);
            }
            link = new StringBuffer (safename (link.toString ().trim ()));
            link = link.append (".html");
            String nl = System.getProperty ("line.separator");
            tpl.setFieldGlobal ("REDIRECT", "<script>" + nl + "location.replace(\"" + link.toString () + "\");" + nl + "</script>" + nl + "<meta http-equiv=\"refresh\" content=\"1; " + link.toString () + "\">" + nl);
        }
        else {
            tpl.setFieldGlobal ("REDIRECT", "");
        }
        Collection searchresult = sedb.find (virtualWiki, topicname, false);
        if (searchresult != null && searchresult.size () > 0) {
            Iterator it = searchresult.iterator ();
            String divider = "";
            StringBuffer backlinks = new StringBuffer ();
            for (; it.hasNext ();) {
                SearchResultEntry result = (SearchResultEntry) it.next ();
                if (! result.getTopic ().equals (topicname)) {
                    backlinks.append (divider);
                    backlinks.append ("<a href=\"");
                    backlinks.append (safename (result.getTopic ()));
                    backlinks.append (".html\">");
                    backlinks.append (result.getTopic ());
                    backlinks.append ("</a>");
                    divider = " | ";
                    List l = (List) containingTopics.get (result.getTopic ());
                    if (l == null) {
                        l = new ArrayList ();
                    }
                    if (! l.contains (topicname)) {
                        l.add (topicname);
                    }
                    containingTopics.put (result.getTopic (), l);
                }
            }
            if (backlinks.length () > 0) {
                ResourceBundle messages = ResourceBundle.getBundle ("ApplicationResources", locale);
                content.append ("<br /><br /><span class=\"backlinks\">");
                content.append (topicname);
                content.append (" ");
                content.append (messages.getString ("topic.ismentionedon"));
                content.append (" ");
                content.append (backlinks.toString ());
                content.append ("</span>");
            }
        }
        tpl.setFieldGlobal ("CONTENTS", content.toString ());
        ZipEntry entry = new ZipEntry (safename (topicname) + ".html");
        StringReader in = new StringReader (tpl.getContent ());
        zipout.putNextEntry (entry);
        int read = 0;
        while ((read = in.read ()) != - 1) {
            zipout.write (read);
        }
        zipout.closeEntry ();
        zipout.flush ();
        if (topicname.equals (defaultTopic)) {
            entry = new ZipEntry ("index.html");
            in = new StringReader (tpl.getContent ());
            zipout.putNextEntry (entry);
            read = 0;
            while ((read = in.read ()) != - 1) {
                zipout.write (read);
            }
            zipout.closeEntry ();
            zipout.flush ();
        }
    }
}


private void showReportPage (HTTPurl urlData, OutputStream outStream) throws Exception {
    String download = urlData.getParameter ("download");
    String id = urlData.getParameter ("id");
    if (download == null || download.length () == 0) {
        PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "submit.html");
        template.replaceAll ("$schedule_id", id);
        outStream.write (template.getPageBytes ());
        return;
    }
    ScheduleItem si = store.getScheduleItem (id);
    if (si == null) {
        String redirect = "HTTP/1.0 302 Moved Temporarily\n";
        redirect += "Location: /servlet/ScheduleDataRes\n\n";
        outStream.write (redirect.getBytes ());
        return;
    }
    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();
    ZipOutputStream out = new ZipOutputStream (bytesOut);
    Vector < String > logFiles = si.getLogFileNames ();
    for (int x = 0; x < logFiles.size (); x ++) {
        File log = new File (logFiles.get (x));
        if (log.exists ()) {
            out.putNextEntry (new ZipEntry (log.getName ()));
            byte [] data = new byte [1024];
            FileInputStream is = new FileInputStream (log);
            int read = is.read (data);
            while (read > - 1) {
                out.write (data, 0, read);
                read = is.read (data);
            }
            out.closeEntry ();
        }
    }
    out.putNextEntry (new ZipEntry ("ItemLog.txt"));
    out.write (si.getLog ().getBytes ("UTF-8"));
    out.closeEntry ();
    StringBuffer buff = new StringBuffer ();
    buff.append ("Name         : " + si.getName () + "\r\n");
    buff.append ("Start        : " + si.getStart ().toString () + "\r\n");
    buff.append ("Stop         : " + si.getStop ().toString () + "\r\n");
    buff.append ("Duration     : " + si.getDuration () + "\r\n");
    buff.append ("Channel      : " + si.getChannel () + "\r\n");
    buff.append ("Path Index   : " + si.getCapturePathIndex () + "\r\n");
    buff.append ("Capture Type : " + si.getCapType () + "\r\n");
    buff.append ("Filename     : " + si.getFileName () + "\r\n");
    buff.append ("File Pattern : " + si.getFilePattern () + "\r\n");
    buff.append ("Keep For     : " + si.getKeepFor () + "\r\n");
    buff.append ("Post Task    : " + si.getPostTask () + "\r\n");
    buff.append ("State        : " + si.getState () + "\r\n");
    buff.append ("Status       : " + si.getStatus () + "\r\n");
    buff.append ("Type         : " + si.getType () + "\r\n");
    buff.append ("\r\nWarnings:\r\n");
    Vector < String > warns = si.getWarnings ();
    for (int x = 0; x < warns.size (); x ++) {
        buff.append (warns.get (x) + "\r\n");
    }
    buff.append ("\r\n");
    buff.append ("Log Files:\r\n");
    Vector < String > logs = si.getLogFileNames ();
    for (int x = 0; x < logs.size (); x ++) {
        buff.append (logs.get (x) + "\r\n");
    }
    buff.append ("\r\n");
    GuideItem item = si.getCreatedFrom ();
    if (item != null) {
        buff.append ("Created From:\r\n");
        buff.append ("Name     : " + item.getName () + "\r\n");
        buff.append ("Start    : " + item.getStart ().toString () + "\r\n");
        buff.append ("Stop     : " + item.getStop ().toString () + "\r\n");
        buff.append ("Duration : " + item.getDuration () + "\r\n");
        buff.append ("\r\n");
    }
    HashMap < Date, SignalStatistic > signal = si.getSignalStatistics ();
    if (signal.size () > 0) {
        buff.append ("Signal Statistics: (Locked, Strength, Quality)\r\n");
        Date [] keys = signal.keySet ().toArray (new Date [0]);
        for (int x = 0; x < signal.size (); x ++) {
            SignalStatistic stat = signal.get (keys [x]);
            buff.append (keys [x].toString () + " - " + stat.getLocked () + ", " + stat.getStrength () + ", " + stat.getQuality () + "\r\n");
        }
        buff.append ("\r\n");
    }
    out.putNextEntry (new ZipEntry ("ItemDetails.txt"));
    out.write (buff.toString ().getBytes ("UTF-8"));
    out.closeEntry ();
    out.flush ();
    out.close ();
    StringBuffer header = new StringBuffer ();
    header.append ("HTTP/1.1 200 OK\n");
    header.append ("Content-Type: application/zip\n");
    header.append ("Content-Length: " + bytesOut.size () + "\n");
    header.append ("Content-Disposition: attachment; filename=\"ScheduleErrorReport.zip\"\n");
    DateFormat df = new SimpleDateFormat ("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale ("En", "Us", "Unix"));
    header.append ("Last-Modified: " + df.format (new Date ()) + "\n");
    header.append ("\n");
    outStream.write (header.toString ().getBytes ());
    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());
    byte [] bytes = new byte [4096];
    int read = zipStream.read (bytes);
    while (read > - 1) {
        outStream.write (bytes, 0, read);
        outStream.flush ();
        read = zipStream.read (bytes);
    }
    return;
}


-----Function Pair=146=-----==

void xor () {
    ImagePlus imp = getImage ();
    if (imp == null) return;
    int [] indexes = list.getSelectedIndexes ();
    if (indexes.length == 1) {
        error ("More than one item must be selected, or none");
        return;
    }
    if (indexes.length == 0) indexes = getAllIndexes ();
    ShapeRoi s1 = null, s2 = null;
    for (int i = 0; i < indexes.length; i ++) {
        Roi roi = (Roi) rois.get (list.getItem (indexes [i]));
        if (! roi.isArea ()) continue;
        if (s1 == null) {
            if (roi instanceof ShapeRoi) s1 = (ShapeRoi) roi.clone ();
            else s1 = new ShapeRoi (roi);
            if (s1 == null) return;
        }
        else {
            if (roi instanceof ShapeRoi) s2 = (ShapeRoi) roi.clone ();
            else s2 = new ShapeRoi (roi);
            if (s2 == null) continue;
            s1.xor (s2);
        }
    }
    if (s1 != null) imp.setRoi (s1);
    if (record ()) Recorder.record ("roiManager", "XOR");
}


public void CopyFile (File source, File destination) throws Exception {
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream (source);
        fos = new FileOutputStream (destination);
        byte [] buffer = new byte [4096];
        int read;
        while ((read = fis.read (buffer)) != - 1) {
            fos.write (buffer, 0, read);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (fis != null) {
                fis.close ();
            }
            if (fos != null) {
                fos.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=147=-----==

public boolean readTransactionMetadataAndTriplesFromUTF8Stream (InputStream inputStream) {
    BufferedReader reader = new BufferedReader (new InputStreamReader (inputStream, Charset.forName ("UTF-8")));
    String line = null;
    try {
        line = reader.readLine ();
        if (! line.equals ("PointrelTransaction")) {
            System.out.println ("expected PointrelTransaction");
            return false;
        }
        line = reader.readLine ();
        if (! line.startsWith ("version: ")) {
            System.out.println ("expected version");
            return false;
        }
        String version = line.substring ("version: ".length ());
        if (! version.equals (currentVersion)) {
            System.out.println ("expected version to match");
            return false;
        }
        line = reader.readLine ();
        if (! line.startsWith ("uuid: ")) {
            System.out.println ("expected uuid: " + line);
            return false;
        }
        uuid = line.substring ("uuid: ".length ());
        line = reader.readLine ();
        if (! line.startsWith ("timestamp: ")) {
            System.out.println ("expected timestamp: " + line);
            return false;
        }
        timestamp = line.substring ("timestamp: ".length ());
        line = reader.readLine ();
        if (! line.equals ("")) {
            System.out.println ("expected blank line");
            return false;
        }
        while (true) {
            line = reader.readLine ();
            if (line == null) {
                System.out.println ("missing EndTransaction");
                break;
            }
            if (line.equals ("EndTransaction")) {
                break;
            }
            if (! line.equals ("Triple")) {
                System.out.println ("Expected Triple, got: " + line);
                break;
            }
            Triple triple = new Triple (this.uuid);
            if (triple.readFromUTF8Stream (reader)) {
                triples.add (triple);
            }
            else {
                System.out.println ("Problem reading triple");
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return true;
}


private static void decompileClass (File directory) throws Exception {
    boolean needDecompile = false;
    for (File file : directory.listFiles ()) {
        if (file.isDirectory ()) {
            decompileClass (file);
        }
        else {
            needDecompile = true;
        }
    }
    if (needDecompile) {
        builder.directory (directory);
        builder.redirectErrorStream (true);
        Process process = builder.start ();
        InputStream in = process.getInputStream ();
        byte [] b = new byte [1024];
        while (in.read (b) != - 1);
        in.close ();
        for (File file : directory.listFiles ()) {
            String name = file.getName ();
            if (name.endsWith (".jad")) {
                file.renameTo (new File (file.getParent (), file.getName ().replace (".jad", ".java")));
            }
            else if (name.endsWith (".class")) {
                file.delete ();
            }
        }
    }
}


-----Function Pair=148=-----==

public ChannelDataBuffer compress (ChannelDataBuffer data, ChannelDataBuffer out) throws IOException {
    ZipOutputStream zos = new ZipOutputStream (out.getOutputStream ());
    zos.putNextEntry (new ZipEntry ("temp"));
    for (ByteBuffer buf : ChannelDataBuffer.asByteBuffers (data)) {
        byte [] raw = buf.array ();
        int offset = buf.position ();
        int len = buf.limit () - buf.position ();
        zos.write (raw, offset, len);
    }
    zos.flush ();
    zos.closeEntry ();
    zos.close ();
    return out;
}


protected Collection < Community > getExplicitUserCommunities (GroupwareUser user, String role) {
    Collection < Community > communities = new ArrayList < Community > ();
    CommunityPrivilege prototype = new CommunityPrivilege ();
    prototype.setUserId (user.getId ());
    prototype.setRole (role);
    Collection < CommunityPrivilege > privileges = privilegePersister.searchByPrototype (prototype);
    for (CommunityPrivilege privilege : privileges) {
        try {
            Community community = communityPersister.getCommunityById (privilege.getCommunityId ());
            communities.add (community);
        } catch (CommunityNotFoundException e) {
            String message = "Privilege found for user " + privilege.getUserId () + " with role " + privilege.getRole () + " in community " + privilege.getCommunityId () + " but community was not found";
            log.debug (message);
        }
    }
    return communities;
}


-----Function Pair=149=-----==

static void writeStreamToFile (InputStream is, String strOutFile) throws IOException {
    BufferedInputStream bis = null;
    if (is instanceof BufferedInputStream) {
        bis = (BufferedInputStream) is;
        logger.info ("stream is already buffered.");
    }
    else {
        bis = new BufferedInputStream (is);
    }
    File file = new File (strOutFile);
    String strParent = file.getParent ();
    if (null != strParent) {
        File dir = new File (strParent);
        dir.mkdirs ();
    }
    BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (file));
    IOUtil.copyStream (bis, bos);
    bos.flush ();
    bos.close ();
    is.close ();
}


public static File createBar (File file, String newbarfilename) {
    try {
        if (newbarfilename.toLowerCase ().endsWith (".xpdl")) newbarfilename = newbarfilename.toLowerCase ().replace (".xpdl", "");
        File barcreato = new File (newbarfilename + ".bar");
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (barcreato)));
        byte [] data = new byte [1000];
        BufferedInputStream in = new BufferedInputStream (new FileInputStream (file.getCanonicalPath ()));
        int count;
        out.putNextEntry (new ZipEntry (file.getName ()));
        while ((count = in.read (data, 0, 1000)) != - 1) {
            out.write (data, 0, count);
        }
        in.close ();
        out.flush ();
        out.close ();
        System.out.println ("BAR File successfully created!");
        return barcreato;
    } catch (Exception e) {
        e.printStackTrace ();
        return null;
    }
}


-----Function Pair=150=-----==

public void saveAttributes (Attributes a) throws IOException {
    String extension = fileresource.getUpperCaseExtension ();
    saveExtentsXML (a);
    saveAttributeXML (a);
    if ("XML".equals (extension)) {
    }
    else {
        File file = new File (getBinaryFilename ());
        FileOutputStream fos = new FileOutputStream (file);
        ZipOutputStream zout = new ZipOutputStream (fos);
        zout.putNextEntry (new ZipEntry ("Attributes"));
        DataOutputStream out = new DataOutputStream (zout);
        saveAttributesBinary (out, a);
        out.close ();
        fos.close ();
    }
    String extent_tree_filename_stem = "extent_tree_";
    for (int i = 0; i < a.getExtents ().size (); i ++) {
        try {
            saveXMLDocument (extent_tree_filename_stem + i + ".xml", a.getExtents ().at (i).getExtentXML ());
        } catch (Exception e) {
        }
    }
    if (a.getIndicators () != null) {
        saveIndicatorsXML (a.getIndicators ());
    }
    if (a.getNavigatorXML () != null) {
        saveXMLDocument ("navigator.xml", a.getNavigatorXML ());
    }
}


public static RegionScoreData merge (ArrayList < RegionScoreData > pdAL) {
    RegionScoreData [] pdArray = new RegionScoreData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionScores.length;
    RegionScore [] concatinate = new RegionScore [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionScore [] slice = pdArray [i].sortedRegionScores;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionScoreData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionScoreData (concatinate, sliceInfo);
}


-----Function Pair=151=-----==

public void save (boolean overwrite, File file) throws IOException, Exception {
    if (expander == null) {
        java.util.Hashtable templates = TemplateReader.readFile (ARGO_TEE);
        expander = new OCLExpander (templates);
    }
    preSave ();
    ZipOutputStream stream = new ZipOutputStream (new FileOutputStream (file));
    BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (stream, "UTF-8"));
    ZipEntry zipEntry = new ZipEntry (getBaseName () + UNCOMPRESSED_FILE_EXT);
    stream.putNextEntry (zipEntry);
    expander.expand (writer, this, "", "");
    writer.flush ();
    stream.closeEntry ();
    String path = file.getParent ();
    Argo.log.info ("Dir ==" + path);
    int size = _members.size ();
    try {
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (! (p.getType ().equalsIgnoreCase ("xmi"))) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
                writer.flush ();
                stream.closeEntry ();
            }
        }
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (p.getType ().equalsIgnoreCase ("xmi")) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
            }
        }
    } catch (IOException e) {
        System.out.println ("hat nicht geklappt: " + e);
        e.printStackTrace ();
    }
    writer.close ();
    postSave ();
    try {
        setFile (file);
    } catch (PropertyVetoException ex) {
    }
}


public void exportTeX (File file, Tasks task) throws IOException {
    Tasks.getTaskView ().setCancelable (true);
    task.setOperationName ("Exporting jobs to TeX file");
    if (file.exists ()) {
        file.delete ();
    }
    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (file)));
    String format = "|";
    String columns = "";
    for (int i = 0; i < main.tableJobs.getColumnCount (); i ++) {
        int vis_col = main.tableJobs.convertColumnIndexToModel (i);
        columns += main.jobsTableModel.getColumnName (vis_col);
        if (main.jobsTableModel.getColumnClass (vis_col) == Integer.class || main.jobsTableModel.getColumnClass (vis_col) == Double.class || main.jobsTableModel.getColumnClass (vis_col) == Float.class || main.jobsTableModel.getColumnClass (vis_col) == int.class || main.jobsTableModel.getColumnClass (vis_col) == double.class || main.jobsTableModel.getColumnClass (vis_col) == float.class) {
            format += "r|";
        }
        else {
            format += "l|";
        }
        if (i < main.jobsTableModel.getColumnCount () - 1) {
            columns += "&";
        }
    }
    out.write ("\\documentclass[a4paper]{report}\n");
    out.write ("\\title{Results of " + activeExperiment.getName () + "}\n");
    out.write ("\\begin{document}\n");
    out.write ("\\begin{tabular}[h]{" + format + "}\n");
    out.write ("\\hline\n");
    out.write (columns + " \\\\\n");
    out.write ("\\hline\n");
    int total = main.getTableJobs ().getRowCount ();
    int done = 0;
    for (int i = 0; i < main.tableJobs.getRowCount (); i ++) {
        int vis = main.getTableJobs ().convertRowIndexToModel (i);
        done ++;
        task.setTaskProgress ((float) done / (float) total);
        if (task.isCancelled ()) {
            task.setStatus ("Cancelled");
            break;
        }
        task.setStatus ("Exporting row " + done + " of " + total);
        for (int col = 0; col < main.tableJobs.getColumnCount (); col ++) {
            int vis_col = main.tableJobs.convertColumnIndexToModel (col);
            if (main.jobsTableModel.getValueAt (vis, vis_col) == null) {
                out.write ("-");
            }
            else {
                out.write (main.jobsTableModel.getValueAt (vis, vis_col).toString ());
            }
            if (col < main.jobsTableModel.getColumnCount () - 1) {
                out.write (" & ");
            }
        }
        out.write ("\\\\\n");
    }
    out.write ("\\hline\n");
    out.write ("\\end{tabular}\n");
    out.write ("\\end{document}\n");
    out.flush ();
    out.close ();
}


-----Function Pair=152=-----==

private void processClassFile (File file) throws Exception, FileNotFoundException, IOException, MalformedURLException {
    ClassReader reader = getClassReader (file);
    String name [] = ClassNameReader.getClassInfo (reader);
    ClassWriter w = new DebuggingClassWriter (ClassWriter.COMPUTE_MAXS);
    ClassTransformer t = getClassTransformer (name);
    if (t != null) {
        if (verbose) {
            log ("processing " + file.toURL ());
        }
        new TransformingClassGenerator (new ClassReaderGenerator (getClassReader (file), attributes (), getFlags ()), t).generateClass (w);
        FileOutputStream fos = new FileOutputStream (file);
        try {
            fos.write (w.toByteArray ());
        } finally {
            fos.close ();
        }
    }
}


File createJar (String name, String...entries) throws IOException {
    File jar = new File (name);
    OutputStream out = new FileOutputStream (jar);
    try {
        JarOutputStream jos = new JarOutputStream (out);
        for (String e : entries) {
            jos.putNextEntry (new ZipEntry (e));
            jos.write (e.getBytes ());
        }
        jos.close ();
    } finally {
        out.close ();
    }
    return jar;
}


-----Function Pair=153=-----==

public String toString () {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < this.polygons.size (); ++ i) {
        sb.append (this.polygons.elementAt (i).toString ());
        sb.append ("\n\n");
    }
    for (int i = 0; i < this.polylines.size (); ++ i) {
        sb.append (this.polylines.elementAt (i).toString ());
        sb.append ("\n\n");
    }
    for (int i = 0; i < this.pois.size (); ++ i) {
        sb.append (this.pois.elementAt (i).toString ());
        sb.append ("\n\n");
    }
    return sb.toString ();
}


public static TranslationServiceAbstract getServiceByType (String language, ServiceTypes type) {
    for (TranslationServiceAbstract service : services) {
        if (type == null) {
            if (service.isLanguageSupported (language) != null) {
                return service;
            }
            continue;
        }
        if (service.getServiceType () != type) continue;
        if (service.isLanguageSupported (language) != null) {
            return service;
        }
    }
    return null;
}


-----Function Pair=154=-----=1=

public void zipIt (String zipFile) {
    byte [] buffer = new byte [1024];
    try {
        FileOutputStream fos = new FileOutputStream (zipFile);
        ZipOutputStream zos = new ZipOutputStream (fos);
        for (String file : this.fileList) {
            ZipEntry ze = new ZipEntry (file);
            zos.putNextEntry (ze);
            if (! ze.isDirectory ()) {
                FileInputStream in = new FileInputStream (SOURCE_FOLDER + File.separator + file);
                int len;
                while ((len = in.read (buffer)) > 0) {
                    zos.write (buffer, 0, len);
                }
                in.close ();
            }
        }
        zos.closeEntry ();
        zos.close ();
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}


private void zipAttachments (List attachments, ZipOutputStream zipStream) throws IOException, FileNotFoundException {
    byte [] buf = new byte [1024];
    Iterator iter = attachments.iterator ();
    while (iter.hasNext ()) {
        File attachement = (File) iter.next ();
        if (attachement.getName ().equals (m_fileable.getNameInZipArchive ())) continue;
        zipStream.putNextEntry (new ZipEntry (attachement.getName ()));
        FileInputStream in = new FileInputStream (attachement);
        int len;
        while ((len = in.read (buf)) > 0) {
            zipStream.write (buf, 0, len);
        }
        zipStream.closeEntry ();
        in.close ();
    }
}


-----Function Pair=155=-----==

public static InputStream unzip (String pZipFile, String pZipEntry, String pOutputPath) {
    try {
        ZipInputStream zis = new ZipInputStream (new FileInputStream (pZipFile));
        ZipEntry entry;
        while ((entry = zis.getNextEntry ()) != null) {
            if (entry.getName ().equals (pZipEntry)) {
                InputStream instream = deflate (zis, entry);
                zis.close ();
                return instream;
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return null;
}


public void init () {
    final Emulator emu = parent.step1.emu;
    final Hardware [] hardwares = parent.step2.hardwares;
    final ImageFormat [] formats = parent.step2.formats;
    StringBuilder explanationText = new StringBuilder (String.format (RBLanguages.get ("confirm_commit_part1"), emu.name, emu.name, emu.folder, emu.name));
    for (Hardware hardware : hardwares) {
        explanationText.append ("<li>" + hardware.name + "</li>");
    }
    explanationText.append (String.format (RBLanguages.get ("confirm_commit_part2"), emu.name));
    for (ImageFormat format : formats) {
        explanationText.append ("<li>" + format.name + "</li>");
    }
    explanationText.append (RBLanguages.get ("confirm_commit_part3"));
    explanation.setText (explanationText.toString ());
}


-----Function Pair=156=-----==

private void copyJarFilesToJar (JarOutputStream out, String jarSourceName) throws IOException {
    byte [] buffer = new byte [2048];
    InputStream isJar = getClass ().getResourceAsStream ("/" + jarSourceName);
    JarInputStream zin = new JarInputStream (isJar);
    JarEntry entry = null;
    while ((entry = zin.getNextJarEntry ()) != null) {
        ByteArrayOutputStream bos = new ByteArrayOutputStream ();
        while (true) {
            int read = zin.read (buffer);
            if (read == - 1) break;
            bos.write (buffer, 0, read);
        }
        ByteArrayInputStream bais = new ByteArrayInputStream (bos.toByteArray ());
        addToJar (out, bais, entry.getName (), bos.toByteArray ().length);
        bos.close ();
        zin.closeEntry ();
    }
    zin.close ();
    isJar.close ();
}


public void respond (RequestCycle requestCycle) {
    boolean success = false;
    OutputStream out = null;
    try {
        Response response = requestCycle.getResponse ();
        byte [] buf = new byte [WebCfgDelegate.getInstance ().getDefaultFolderPagesize ()];
        HashSet < Integer > sopHash = new HashSet < Integer > ();
        if (files.size () > 1) {
            response.setContentType ("application/zip");
            ((WebResponse) response).setAttachmentHeader ("dicom.zip");
            ZipOutputStream zos = new ZipOutputStream (response.getOutputStream ());
            out = zos;
            for (FileToExport fto : files) {
                log.debug ("Write file to zip:{}", fto.file);
                ZipEntry entry = new ZipEntry (getZipEntryName (fto.blobAttrs, sopHash));
                zos.putNextEntry (entry);
                writeDicomFile (fto.file, fto.blobAttrs, zos, buf);
                zos.closeEntry ();
            }
        }
        else {
            response.setContentType ("application/dicom");
            ((WebResponse) response).setAttachmentHeader (getTemplateParam (files.get (0).blobAttrs, "#sopIuid", sopHash) + ".dcm");
            out = response.getOutputStream ();
            writeDicomFile (files.get (0).file, files.get (0).blobAttrs, out, buf);
        }
        success = true;
    } catch (ZipException ze) {
        log.warn ("Problem creating zip file: " + ze);
    } catch (ClientAbortException cae) {
        log.warn ("Client aborted zip file download: " + cae);
    } catch (Exception e) {
        log.error ("An error occurred while attempting to stream zip file for download: ", e);
    } finally {
        logExport (files, success);
        try {
            if (out != null) out.close ();
        } catch (Exception ignore) {
        }
    }
}


-----Function Pair=157=-----==

public static boolean unzipFileOld (File path, File outputDir) {
    int BUFFER = 2048;
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (path);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry;
        while ((entry = zis.getNextEntry ()) != null) {
            if (entry.isDirectory ()) {
                File dir = new File (outputDir.getAbsolutePath () + File.separator + entry.getName ());
                dir.mkdirs ();
            }
            else {
                int count;
                byte data [] = new byte [BUFFER];
                File dir = new File (outputDir.getAbsolutePath () + File.separator + entry.getName ());
                if (! dir.exists ()) {
                    System.out.println ("Extracting: " + entry);
                    if (entry.getName ().contains (File.separator)) {
                        String [] t = entry.getName ().split (File.separator);
                        StringBuffer newDir = new StringBuffer ();
                        for (int i = 0; i < t.length - 1; i ++) {
                            newDir.append (t [i] + File.separator);
                        }
                        System.out.println ("Creating Dir: " + outputDir.getAbsolutePath () + File.separator + newDir);
                        File newDirFile = new File (outputDir.getAbsolutePath () + File.separator + newDir);
                        newDirFile.mkdirs ();
                    }
                    dest = new BufferedOutputStream (new FileOutputStream (dir.getAbsolutePath ()), BUFFER);
                    while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                        dest.write (data, 0, count);
                    }
                    dest.flush ();
                    dest.close ();
                }
                else {
                    System.out.println ("Skipping since already exists: " + entry);
                }
                File finalFile = new File (outputDir.getAbsolutePath () + File.separator + entry.getName ());
                finalFile.setExecutable (true);
                finalFile.setWritable (true);
                finalFile.setReadable (true);
            }
        }
        zis.close ();
    } catch (IOException ioe) {
        System.err.println ("Unhandled exception:");
        ioe.printStackTrace ();
        return (false);
    }
    return (true);
}


private JxTrace [] processOpenTraces (JxTrace [] traces) {
    JxTrace [] new_traces = new JxTrace [traces.length];
    for (int i = 0; i < traces.length; i ++) {
        JxTrace original = traces [i];
        double min = original.findMinimumInterval ();
        double [] [] rs_xy = original.resample (min).getXY ();
        double [] [] xy = new double [rs_xy.length + 2] [2];
        double [] [] new_xy = new double [rs_xy.length * 2] [];
        for (int p = 0, pxy = 1; p < rs_xy.length; p ++, pxy ++) xy [pxy] = rs_xy [p];
        xy [0] [0] = xy [1] [0] - (xy [2] [0] - xy [1] [0]);
        xy [0] [1] = xy [1] [1] - (xy [2] [1] - xy [1] [1]);
        int j = rs_xy.length;
        xy [j + 1] [0] = xy [j] [0] + (xy [j] [0] - xy [j - 1] [0]);
        xy [j + 1] [1] = xy [j] [1] + (xy [j] [1] - xy [j - 1] [1]);
        for (int pxy = 1, p0 = 0, p1 = new_xy.length - 1; pxy < xy.length - 1; pxy ++, p0 ++, p1 --) this.calculateTranslations (xy, pxy, min, new_xy [p0] = new double [2], new_xy [p1] = new double [2]);
        JxOrientation orientation = original.getOrientation ();
        JxClosedTrace trace = new JxClosedTrace (orientation);
        JxPoint [] points = new JxPoint [new_xy.length];
        double offset = original.getOffset ();
        for (int p = 0; p < new_xy.length; p ++) points [p] = new JxPoint (new_xy [p] [0], new_xy [p] [1], offset, 0);
        trace.addArray (points);
        new_traces [i] = trace;
    }
    return new_traces;
}


-----Function Pair=158=-----==

public static void zipOutput (String inPath, String outPath) throws Exception {
    try {
        File inFolder = new File (inPath);
        File outFolder = new File (outPath);
        if (! inFolder.exists ()) {
            return;
        }
        if (! outFolder.exists ()) {
            if (! outFolder.createNewFile ()) {
                return;
            }
        }
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (outFolder));
        zipDir (inFolder.getPath (), inFolder.getPath (), zos);
        zos.close ();
    } catch (Exception e) {
    }
}


public static boolean existsWithRetry (String fileName, int retries, long timeBetweenRetries) {
    File file = new File (fileName);
    for (int i = 0; i < retries; i ++) {
        if (i > 0) {
            try {
                Thread.sleep (timeBetweenRetries);
            } catch (InterruptedException e) {
                log.log (Level.WARNING, "Problem sleeping between file exist checking", e);
            }
        }
        if (file.exists ()) {
            return true;
        }
    }
    return false;
}


-----Function Pair=159=-----==

public void moveMap (int markmap, int targetmap) {
    FileResourceVector frv = getMapFiles ();
    String current_map_name = null;
    if (getMap () != null) {
        current_map_name = getMap ().getName ();
    }
    if (markmap < targetmap && ! (markmap == targetmap + 1)) {
        FileResource markfr = frv.at (markmap);
        frv.remove (markmap);
        frv.insertElementAt (markfr, targetmap - 1);
    }
    if (targetmap < markmap) {
        FileResource markfr = frv.at (markmap);
        frv.remove (markmap);
        frv.insertElementAt (markfr, targetmap);
    }
    if (current_map_name != null) {
        selected_map_index = findMapIndex (current_map_name);
    }
}


private static void saveFileInfo (File list, Map fileTimes, Map fileSizes) {
    try {
        Writer out = new FileWriter (list);
        Iterator i = fileTimes.keySet ().iterator ();
        String name;
        while (i.hasNext ()) {
            name = (String) i.next ();
            out.write (name);
            out.write (DELIM);
            out.write (fileTimes.get (name).toString ());
            out.write (DELIM);
            out.write (fileSizes.get (name).toString ());
            out.write ("\n");
        }
        out.flush ();
        out.close ();
    } catch (Exception e) {
        printError (e);
    }
}


-----Function Pair=160=-----==

protected static String getZipEntryName (File directory, File file, boolean pathWithFirstDirectory) throws IOException {
    String ret = file.getPath ();
    String sourcePath = directory.getPath ();
    int ind = ret.indexOf (sourcePath);
    if (ind >= 0) {
        if (pathWithFirstDirectory) {
            sourcePath = sourcePath.replaceAll (directory.getName (), "");
        }
        ret = ret.substring (sourcePath.length ());
    }
    else {
        throw new IOException ("Erreur: getZipEntryName -- ???");
    }
    StringBuffer tmpBuf = new StringBuffer ();
    char tmpChar;
    for (int i = 0; i < ret.length (); i ++) {
        tmpChar = ret.charAt (i);
        if (tmpChar == '\\') {
            tmpBuf.append ('/');
        }
        else {
            tmpBuf.append (tmpChar);
        }
    }
    if (tmpBuf.charAt (0) == '/') {
        return tmpBuf.toString ().substring (1);
    }
    else {
        return tmpBuf.toString ();
    }
}


private void createLegend () {
    Imaginator imag = new Imaginator (150, 30);
    DateFormat dfm = new SimpleDateFormat ("dd.MM.yyyy HH:mm");
    Calendar cal = Calendar.getInstance ();
    try {
        Date date = dfm.parse (day);
        cal.setTime (date);
        for (int i = 0; i < end - start; i ++) {
            try {
                BufferedImage bi = imag.createLegend (dfm.format (cal.getTime ()));
                String name = "legend_" + (start + i);
                ImageIO.write (bi, "png", new File (paths.get (1) + "\\" + name + ".png"));
                cal.add (Calendar.HOUR, 1);
            } catch (IOException ex) {
                System.out.println (ex.toString ());
                Logger.getLogger (KMZCreator.class.getName ()).log (Level.SEVERE, null, ex);
            }
        }
    } catch (ParseException e) {
        System.out.println (e.toString ());
        Logger.getLogger (KMZCreator.class.getName ()).log (Level.SEVERE, null, e);
    }
    for (int i = start; i < end; i ++) {
        boolean visibility = (i == start) ? true : false;
        ScreenOverlay sc = document.createAndAddScreenOverlay ();
        sc.withId ("sc" + i).withName ("sc" + i).withVisibility (visibility).withIcon (new Icon ().withHref ("legend_" + i + ".png")).withOverlayXY (new Vec2 ().withX (0).withY (1).withXunits (Units.FRACTION).withYunits (Units.FRACTION)).withScreenXY (new Vec2 ().withX (0).withY (1).withXunits (Units.FRACTION).withYunits (Units.FRACTION));
    }
}


-----Function Pair=161=-----==

public static List getContents (InputStream inputStream) throws IOException {
    ArrayList contents = new ArrayList ();
    InputStreamReader inputStreamReader = new InputStreamReader (inputStream);
    try {
        BufferedReader bufferedReader = new BufferedReader (inputStreamReader);
        try {
            String line = bufferedReader.readLine ();
            while (line != null) {
                contents.add (line);
                line = bufferedReader.readLine ();
            }
        } finally {
            bufferedReader.close ();
        }
    } finally {
        inputStreamReader.close ();
    }
    return contents;
}


public static File copyFile (String path) {
    File src = new File (path);
    File dest = new File (src.getName ());
    try {
        if (! dest.exists ()) {
            dest.createNewFile ();
        }
        FileChannel source = new FileInputStream (src).getChannel ();
        FileChannel destination = new FileOutputStream (dest).getChannel ();
        destination.transferFrom (source, 0, source.size ());
        source.close ();
        destination.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return dest;
}


-----Function Pair=162=-----=1=

public static void zipFiles (String filename, String [] files) throws IOException {
    ZipOutputStream zip = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (filename)));
    byte [] buffer = new byte [10000];
    for (int i = 0; i < files.length; i ++) {
        File f = new File (files [i]);
        if (f.exists ()) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (files [i]));
            zip.putNextEntry (new ZipEntry (files [i]));
            boolean done = false;
            while (! done) {
                int num = in.read (buffer);
                if (num > 0) {
                    zip.write (buffer, 0, num);
                }
                done = (num < buffer.length);
            }
            in.close ();
        }
    }
    zip.flush ();
    zip.close ();
}


public static void zipDir (String dirToZip, String zipName) throws Exception {
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipName));
    List < String > l = new ArrayList < String > ();
    listOfFiles (new File (dirToZip), l);
    byte [] readBuffer = null;
    RandomAccessFile raf = null;
    for (Iterator iterator = l.iterator (); iterator.hasNext ();) {
        String filename = (String) iterator.next ();
        raf = new RandomAccessFile (filename, "r");
        readBuffer = new byte [(int) raf.length ()];
        raf.read (readBuffer);
        ZipEntry anEntry = new ZipEntry (filename.substring (dirToZip.length ()));
        zos.putNextEntry (anEntry);
        zos.write (readBuffer, 0, (int) raf.length ());
        raf.close ();
    }
    zos.close ();
}


-----Function Pair=163=-----==

private void processEntry (final ZipInputStream zis, final ZipEntry ze, final ContentHandlerFactory handlerFactory) {
    ContentHandler handler = handlerFactory.createContentHandler ();
    try {
        boolean singleInputDocument = inRepresentation == SINGLE_XML;
        if (inRepresentation == BYTECODE) {
            ClassReader cr = new ClassReader (readEntry (zis, ze));
            cr.accept (new SAXClassAdapter (handler, singleInputDocument), 0);
        }
        else {
            XMLReader reader = XMLReaderFactory.createXMLReader ();
            reader.setContentHandler (handler);
            reader.parse (new InputSource (singleInputDocument ? (InputStream) new ProtectedInputStream (zis) : new ByteArrayInputStream (readEntry (zis, ze))));
        }
    } catch (Exception ex) {
        update (ze.getName (), 0);
        update (ex, 0);
    }
}


private void onAdd () {
    String target;
    if (lastOpenLocation == null) target = ".";
    else target = lastOpenLocation;
    JFileChooser jfc = new JFileChooser (target);
    int status = jfc.showOpenDialog (this);
    if (status == JFileChooser.APPROVE_OPTION) {
        File f = jfc.getSelectedFile ();
        lastOpenLocation = f.getAbsolutePath ();
        Enumeration e = resFile.entries ();
        while (e.hasMoreElements ()) {
            if (((ZipEntry) e.nextElement ()).getName ().equals (f.getName ())) {
                JOptionPane.showMessageDialog (this, duplicateZipEntry.toString ());
                return;
            }
        }
        String comment = (String) JOptionPane.showInputDialog (this, msgNewComment, inputCaption.toString (), JOptionPane.QUESTION_MESSAGE, null, null, "");
        if (comment == null) return;
        addFile (f, comment);
        refreshTableContents ();
    }
}


-----Function Pair=164=-----==

public boolean save (final File f) {
    if (this.zipWorkflow) {
        this.zipEntries.clear ();
        final int bufsize = 1024;
        final File zipFile = f;
        ZipOutputStream zos;
        try {
            final FileOutputStream fos = new FileOutputStream (zipFile);
            zos = new ZipOutputStream (new BufferedOutputStream (fos));
            log.info ("Created zip output stream");
            final byte [] input_buffer = new byte [bufsize];
            final Iterator < IWorkflowResult > iter = this.workflow.getResults ();
            File basedir = fileTools.prependDefaultDirsWithPrefix ("", null, this.workflow.getStartupDate ());
            log.info ("marked basedir for deletion on exit: {}", basedir);
            if (this.deleteOnExit) {
                basedir.deleteOnExit ();
            }
            log.info ("setting basedir to parent file: {}", basedir.getParentFile ());
            basedir = basedir.getParentFile ();
            while (iter.hasNext ()) {
                final IWorkflowResult iwr = iter.next ();
                if (iwr instanceof IWorkflowFileResult) {
                    final IWorkflowFileResult iwfr = (IWorkflowFileResult) iwr;
                    final File file = iwfr.getFile ();
                    log.info ("Retrieving file result {}", file);
                    final File parent = file.getParentFile ();
                    log.info ("Retrieving parent of file result {}", parent);
                    if (parent.getAbsolutePath ().startsWith (basedir.getAbsolutePath ()) && ! parent.getAbsolutePath ().equals (basedir.getAbsolutePath ())) {
                        log.info ("Marking file and parent for deletion");
                        if (this.deleteOnExit) {
                            parent.deleteOnExit ();
                            file.deleteOnExit ();
                        }
                    }
                    if (file.getAbsolutePath ().startsWith (basedir.getAbsolutePath ())) {
                        log.info ("Marking file for deletion");
                        if (this.deleteOnExit) {
                            file.deleteOnExit ();
                        }
                    }
                    if ((this.fileFilter != null) && ! this.fileFilter.accept (file)) {
                        continue;
                    }
                    else {
                        log.info ("Adding zip entry!");
                        addZipEntry (bufsize, zos, input_buffer, file);
                    }
                }
            }
            try {
                zos.flush ();
                zos.close ();
            } catch (final IOException e) {
                throw new RuntimeException (e);
            }
        } catch (final IOException e) {
            throw new RuntimeException (e);
        }
        return true;
    }
    else {
        log.debug ("Configured to not zip Workflow results!");
        return false;
    }
}


private void writeResultXML (Long actId) throws Exception {
    List < Result > res = em.createQuery ("select r from Result r " + "left join fetch r.characteristic " + "left join fetch r.sampleFraction " + "left join fetch r.primaryMeasurement.unit " + "left join fetch r.status " + "left join fetch r.valueType " + "left join fetch r.biologicalIntent " + "left join fetch r.taxon " + "left join fetch r.analyticalMethod " + "left join fetch r.analyticalMethod.context " + "left join fetch r.measurementQualifier " + "left join fetch r.detectionCondition " + "left join fetch r.elevation.unit " + "left join fetch r.weightBasis " + "left join fetch r.sampleTissueAnatomy " + "where r.activity.uid = :uid").setParameter ("uid", actId).getResultList ();
    for (Iterator < Result > i = res.iterator (); i.hasNext ();) {
        Result r = i.next ();
        if ((r.getWqx20Valid () != null) && (! r.getWqx20Valid ().booleanValue ()) && (param.getExportValidOnly () != null) && (param.getExportValidOnly ().booleanValue ())) continue;
        r.setGetTrueValues (true);
        xml.writeStartElement ("Result");
        if ((r.getDetectionCondition () != null) || (r.getCharacteristic () != null) || (r.getSampleFraction () != null) || ((r.getPrimaryMeasurement () != null) && ((r.getPrimaryMeasurement ().getValue () != null) || (r.getPrimaryMeasurement ().getUnit () != null))) || (r.getMeasurementQualifier () != null) || (r.getStatus () != null) || (r.getValueType () != null) || (r.getWeightBasis () != null) || (r.getComments () != null) || ((r.getElevation () != null) && ((r.getElevation ().getValue () != null) || (r.getElevation ().getUnit () != null))) || (r.getMeasurementPrecision () != null) || (r.getMeasurementBias () != null) || (r.getMeasurementConfidenceInterval () != null) || (r.getMeasurementLowerConfidenceLimit () != null) || (r.getMeasurementUpperConfidenceLimit () != null)) {
            xml.writeStartElement ("ResultDescription");
            if (r.getDetectionCondition () != null) writeFullElement ("ResultDetectionConditionText", r.getDetectionCondition ().getName ());
            if (r.getCharacteristic () != null) writeFullElement ("CharacteristicName", r.getCharacteristic ().getName ());
            if (r.getSampleFraction () != null) writeFullElement ("ResultSampleFractionText", r.getSampleFraction ().getName ());
            if (((r.getPrimaryMeasurement () != null) && ((r.getPrimaryMeasurement ().getValue () != null) || (r.getPrimaryMeasurement ().getUnit () != null))) || (r.getMeasurementQualifier () != null)) {
                xml.writeStartElement ("ResultMeasure");
                if (r.getPrimaryMeasurement () != null) {
                    writeFullElement ("ResultMeasureValue", r.getPrimaryMeasurement ().getValue ());
                    if (r.getPrimaryMeasurement ().getUnit () != null) writeFullElement ("MeasureUnitCode", r.getPrimaryMeasurement ().getUnit ().getCode ());
                }
                writeFullElement ("MeasureQualifierCode", (r.getMeasurementQualifier () != null) ? r.getMeasurementQualifier ().getCode () : null);
                xml.writeEndElement ();
            }
            if (r.getStatus () != null) writeFullElement ("ResultStatusIdentifier", r.getStatus ().getName ());
            if (r.getValueType () != null) writeFullElement ("ResultValueTypeName", r.getValueType ().getName ());
            if (r.getWeightBasis () != null) writeFullElement ("ResultWeightBasisText", r.getWeightBasis ().getName ());
            if ((r.getMeasurementPrecision () != null) || (r.getMeasurementBias () != null) || (r.getMeasurementConfidenceInterval () != null) || (r.getMeasurementLowerConfidenceLimit () != null) || (r.getMeasurementUpperConfidenceLimit () != null)) {
                xml.writeStartElement ("DataQuality");
                writeFullElement ("PrecisionValue", r.getMeasurementPrecision ());
                writeFullElement ("BiasValue", r.getMeasurementBias ());
                writeFullElement ("ConfidenceIntervalValue", r.getMeasurementConfidenceInterval ());
                writeFullElement ("UpperConfidenceLimitValue", r.getMeasurementUpperConfidenceLimit ());
                writeFullElement ("LowerConfidenceLimitValue", r.getMeasurementLowerConfidenceLimit ());
                xml.writeEndElement ();
            }
            writeFullElement ("ResultCommentText", r.getComments ());
            if (((r.getElevation () != null) && ((r.getElevation ().getValue () != null) || (r.getElevation ().getUnit () != null)))) {
                xml.writeStartElement ("ResultDepthHeightMeasure");
                writeFullElement ("MeasureValue", r.getElevation ().getValue ());
                if (r.getElevation ().getUnit () != null) writeFullElement ("MeasureUnitCode", r.getElevation ().getUnit ().getCode ());
                xml.writeEndElement ();
            }
            xml.writeEndElement ();
        }
        List < ResultFrequencyClass > rfcs = getResultFrequencyClasses (r.getOrganization ().getUid (), r.getUid ());
        List < ResultTaxonDetail > rtds = getTaxonomicDetails (r.getOrganization ().getUid (), r.getUid ());
        if ((r.getBiologicalIntent () != null) || (r.getBioIndividualId () != null) || (r.getTaxon () != null) || (r.getSpeciesId () != null) || (r.getSampleTissueAnatomy () != null) || (rtds != null) || (rfcs != null)) {
            xml.writeStartElement ("BiologicalResultDescription");
            if (r.getBiologicalIntent () != null) writeFullElement ("BiologicalIntentName", r.getBiologicalIntent ().getName ());
            writeFullElement ("BiologicalIndividualIdentifier", r.getBioIndividualId ());
            if (r.getTaxon () != null) writeFullElement ("SubjectTaxonomicName", r.getTaxon ().getName ());
            writeFullElement ("UnidentifiedSpeciesIdentifier", r.getSpeciesId ());
            if (r.getSampleTissueAnatomy () != null) writeFullElement ("SampleTissueAnatomyName", r.getSampleTissueAnatomy ().getName ());
            if (rtds != null) {
                Iterator < ResultTaxonDetail > i2 = rtds.iterator ();
                xml.writeStartElement ("TaxonomicDetails");
                while (i2.hasNext ()) {
                    ResultTaxonDetail rtd = i2.next ();
                    writeHabitXML (r.getOrganization ().getUid (), r.getUid ());
                    writeFullElement ("TaxonomicPollutionTolerance", rtd.getPollutionTolerance ());
                    writeFullElement ("TaxonomicPollutionToleranceScaleText", rtd.getPollutionToleranceScale ());
                    writeFullElement ("TrophicLevelName", rtd.getTrophicLevel ());
                    writeFunctionalFeedingGroupXML (r.getOrganization ().getUid (), r.getUid ());
                }
                xml.writeEndElement ();
            }
            if (rfcs != null) {
                Iterator < ResultFrequencyClass > i2 = rfcs.iterator ();
                xml.writeStartElement ("FrequencyClassInformation");
                while (i2.hasNext ()) {
                    ResultFrequencyClass rfc = i2.next ();
                    writeFullElement ("FrequencyClassDescriptorCode", rfc.getFrequencyClassDescriptor ().getName ());
                    if (rfc.getBoundsUnit () != null) writeFullElement ("FrequencyClassDescriptorUnitCode", rfc.getBoundsUnit ().getCode ());
                    writeFullElement ("LowerClassBoundValue", (rfc.getLowerBound () != null) ? rfc.getLowerBound ().toString () : null);
                    writeFullElement ("UpperClassBoundValue", (rfc.getUpperBound () != null) ? rfc.getUpperBound ().toString () : null);
                }
                xml.writeEndElement ();
            }
            xml.writeEndElement ();
        }
        if (r.getAnalyticalMethod () != null) {
            xml.writeStartElement ("ResultAnalyticalMethod");
            writeFullElement ("MethodIdentifier", r.getAnalyticalMethod ().getId ());
            writeFullElement ("MethodIdentifierContext", r.getAnalyticalMethod ().getContext ().getCode ());
            writeFullElement ("MethodName", r.getAnalyticalMethod ().getName ());
            xml.writeEndElement ();
        }
        List < ResultDetectionQuantitationLimit > rdqls = getResultDetectionQuantitationLimits (r.getOrganization ().getUid (), r.getUid ());
        if ((rdqls != null) || (false)) {
            xml.writeStartElement ("ResultLabInformation");
            if (rdqls != null) {
                Iterator < ResultDetectionQuantitationLimit > i2 = rdqls.iterator ();
                while (i2.hasNext ()) {
                    ResultDetectionQuantitationLimit rdq = i2.next ();
                    rdq.setGetTrueValues (true);
                    xml.writeStartElement ("ResultDetectionQuantitationLimit");
                    if (rdq.getType () != null) writeFullElement ("DetectionQuantitationLimitTypeName", rdq.getType ().getName ());
                    if ((rdq.getMeasurement () != null) && ((rdq.getMeasurement ().getValue () != null) || (rdq.getMeasurement ().getUnit () != null))) {
                        xml.writeStartElement ("DetectionQuantitationLimitMeasure");
                        writeFullElement ("MeasureValue", rdq.getMeasurement ().getValue ());
                        if (rdq.getMeasurement ().getUnit () != null) writeFullElement ("MeasureUnitCode", rdq.getMeasurement ().getUnit ().getCode ());
                        xml.writeEndElement ();
                    }
                    xml.writeEndElement ();
                }
            }
            xml.writeEndElement ();
        }
        xml.writeEndElement ();
    }
}


-----Function Pair=165=-----==

public void stripLine (final InputStream is, final OutputStream os, final String regex) throws IOException {
    BufferedReader reader = null;
    BufferedWriter writer = null;
    String line = null;
    try {
        reader = new BufferedReader (new InputStreamReader (is, Charset.defaultCharset ()));
        writer = new BufferedWriter (new OutputStreamWriter (os, Charset.defaultCharset ()));
        while ((line = reader.readLine ()) != null) {
            if (line.matches (regex)) {
                continue;
            }
            writer.write (line);
            writer.newLine ();
        }
    } finally {
        if (reader != null) {
            reader.close ();
        }
        if (writer != null) {
            writer.close ();
        }
    }
}


private synchronized byte [] getBytes (ZipFile zf, ZipEntry ze) throws IOException {
    int n;
    InputStream is = null;
    try {
        is = zf.getInputStream (ze);
        baos.reset ();
        long left = ze.getSize ();
        while ((left > 0) && (n = is.read (buffer, 0, buffer.length)) != - 1) {
            baos.write (buffer, 0, n);
            left -= n;
        }
    } finally {
        if (is != null) {
            is.close ();
        }
    }
    return baos.toByteArray ();
}


-----Function Pair=166=-----==

private boolean createImpl (boolean isDir) throws IOException {
    synchronized (JarFileSystem.this) {
        boolean rc = exists ();
        if (! rc) {
            String parentPath = dirname (path);
            if (parentPath != null) {
                AbstractFile parent = resolveInFileSystem (mountPath, parentPath);
                parent.mkdirs ();
                parent.touch ();
            }
            else {
                touchMountPoint (JarFileSystem.this);
            }
            String path = this.path;
            if (isDir) path += "/";
            zipEntry = new ZipEntry (path);
            buf = EMPTY_BUF;
            touch ();
        }
        return rc;
    }
}


public boolean requestNewTime (int time, TimePreference searchDirection) throws RemoteException {
    int lastTime = - 1;
    int foundTime = - 1;
    for (Integer timestep : this.timesteps.keySet ()) {
        if (searchDirection == TimePreference.EARLIER) {
            if (timestep >= time) {
                foundTime = lastTime;
                break;
            }
        }
        else {
            if (timestep >= time) {
                foundTime = timestep;
                break;
            }
        }
        lastTime = timestep;
    }
    if (foundTime == - 1) return false;
    this.nextTime = foundTime;
    this.actBuffer = null;
    return true;
}


-----Function Pair=167=-----==

public void addAction (String actionName, String eventType, Object [] parameters) {
    if (! keepLog.isSelected ()) {
        return;
    }
    DataSection data = new DataSection ();
    if ((parameters != null) && (parameters.length > 0)) {
        for (int i = 0; i < parameters.length; i ++) {
            if (parameters [i] == null) {
                data.put ("par [" + i + "] class", "null");
                data.put ("par [" + i + "] string", "null");
                data.put ("par [" + i + "] hashcode", "null");
            }
            else {
                String cn = parameters [i].getClass ().getName ();
                data.put ("par [" + i + "] class", cn.substring (cn.lastIndexOf (".") + 1));
                data.put ("par [" + i + "] string", parameters [i].toString ());
                data.put ("par [" + i + "] hashcode", "" + parameters [i].hashCode ());
            }
        }
    }
    AuditTrailEntry ate = new AuditTrailEntryImpl (data, actionName, eventType, new Date (), System.getProperty ("user.name"), null, null, null);
    try {
        historyPI.getAuditTrailEntryList ().append (ate);
    } catch (IOException ex) {
        Message.add ("Failed to write event to event history.", Message.ERROR);
    }
}


public static void zip (InputStream in, OutputStream out, String zipEntryName) throws IOException {
    ZipOutputStream zOut = new ZipOutputStream (out);
    zOut.setLevel (9);
    zOut.setMethod (Deflater.DEFLATED);
    ZipEntry zEntry = new ZipEntry (zipEntryName);
    zOut.putNextEntry (zEntry);
    byte [] data = new byte [10000];
    int inByte = in.read (data);
    while (inByte != - 1) {
        zOut.write (data, 0, inByte);
        inByte = in.read (data);
    }
    zOut.closeEntry ();
    zOut.close ();
    in.close ();
}


-----Function Pair=168=-----==

public void unzipFile (File zippedFile) {
    checkFile (zippedFile);
    File parentDir = zippedFile.getParentFile ();
    String fileNamewithoutExtenson = JefbUtils.extractFileNameWithoutExtension (zippedFile);
    File destFile = new File (parentDir.getAbsolutePath (), fileNamewithoutExtenson);
    destFile = createNonExistentDestinationFile (destFile);
    try {
        ZipFile zipFile = new ZipFile (zippedFile);
        Enumeration < ? extends ZipEntry > zipEntryEnum = zipFile.entries ();
        while (zipEntryEnum.hasMoreElements ()) {
            ZipEntry zipEntry = zipEntryEnum.nextElement ();
            extractEntry (zipFile, zipEntry, destFile.getAbsolutePath ());
        }
    } catch (Exception e) {
        String errorMessage = "Unable to unzip file [" + zippedFile.getName () + "].";
        log.error (errorMessage, e);
        throw new FileSystemException ("filemanager.msg.unable_to_unzip", errorMessage);
    }
}


private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=169=-----==

public static List < File > unzip (File zippedFile, File destinationDir) throws IOException {
    int buffer = 2048;
    List < File > unzippedFiles = new ArrayList < File > ();
    BufferedOutputStream dest;
    BufferedInputStream is;
    ZipEntry entry;
    ZipFile zipfile = new ZipFile (zippedFile);
    Enumeration e = zipfile.entries ();
    while (e.hasMoreElements ()) {
        entry = (ZipEntry) e.nextElement ();
        is = new BufferedInputStream (zipfile.getInputStream (entry));
        int count;
        byte data [] = new byte [buffer];
        File destFile;
        if (destinationDir != null) {
            destFile = new File (destinationDir, entry.getName ());
        }
        else {
            destFile = new File (entry.getName ());
        }
        FileOutputStream fos = new FileOutputStream (destFile);
        dest = new BufferedOutputStream (fos, buffer);
        while ((count = is.read (data, 0, buffer)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
        is.close ();
        unzippedFiles.add (destFile);
    }
    return unzippedFiles;
}


public static final void createZipFile (String [] sourceFiles, String zipPath, String zipFileName) throws Exception {
    ZipOutputStream zipOutStream = null;
    FileInputStream fin = null;
    try {
        zipOutStream = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipPath + File.separator + zipFileName)));
        for (int i = 0; i < sourceFiles.length; i ++) {
            File [] files = FileUtility.getFiles (sourceFiles [i]);
            for (int j = 0; j < files.length; j ++) {
                byte data [] = new byte [BUFFER_SIZE];
                File file = files [j];
                ZipEntry entry = new ZipEntry (file.getName ());
                zipOutStream.putNextEntry (entry);
                fin = new FileInputStream (file);
                int bytesRead;
                while ((bytesRead = fin.read (data, 0, BUFFER_SIZE)) > 0) {
                    zipOutStream.write (data, 0, bytesRead);
                }
                fin.close ();
                fin = null;
                zipOutStream.closeEntry ();
            }
        }
        zipOutStream.flush ();
        zipOutStream.close ();
        zipOutStream = null;
    } catch (Exception e) {
        throw new Exception (e);
    } finally {
        if (fin != null) {
            fin.close ();
            fin = null;
        }
        if (zipOutStream != null) {
            zipOutStream.close ();
            zipOutStream = null;
        }
    }
}


-----Function Pair=170=-----==

public static File createTestProject (final int numFilesInProject, final int minFileSize, final int maxFileSize) throws Exception {
    File directory = TempFileUtil.createTemporaryDirectory ();
    File nextFile;
    OutputStream out = null;
    for (int i = 0; i < numFilesInProject; i ++) {
        nextFile = new File (directory, i + ".tmp");
        try {
            out = new FileOutputStream (nextFile);
            int size = RandomUtil.getInt (maxFileSize - minFileSize + 1) + minFileSize;
            byte [] bytes = new byte [size];
            RandomUtil.getBytes (bytes);
            out.write (bytes);
        } finally {
            IOUtil.safeClose (out);
        }
    }
    return directory;
}


public void marshal (final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {
    final Message message = exchange.getIn ();
    final File file = message.getBody (File.class);
    final String fileName = file.getName ();
    final InputStream is = exchange.getContext ().getTypeConverter ().convertTo (InputStream.class, graph);
    final ZipOutputStream zipOutput = new ZipOutputStream (stream);
    zipOutput.setLevel (compressionLevel);
    try {
        zipOutput.putNextEntry (new ZipEntry (fileName));
    } catch (IOException e) {
        throw new IllegalStateException ("Error while adding a new Zip File Entry (File name: '" + fileName + "').", e);
    }
    IOHelper.copy (is, zipOutput);
    zipOutput.close ();
}


-----Function Pair=171=-----=1=

private void zip (String base, Set < DataFile > dss, ZipOutputStream zout) throws IOException, Exception {
    for (DataFile ds : dss) {
        if (ds.isDirectory ()) {
            ZipEntry entry = new ZipEntry (base + ds.getName () + "/");
            entry.setMethod (ZipEntry.DEFLATED);
            try {
                zout.putNextEntry (entry);
                zout.closeEntry ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
                Core.Logger.log (ioe.getMessage (), Level.WARNING);
            }
            zip (base + ds.getName () + "/", ds.children (), zout);
        }
        else {
            int read;
            byte [] buff = new byte [0x800];
            ZipEntry entry = new ZipEntry (base + ds.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            try {
                InputStream in = ds.getInputStream ();
                zout.putNextEntry (entry);
                progress_bytes_max = ds.size ();
                progress_bytes_current = 0;
                while ((read = in.read (buff)) != - 1) {
                    zout.write (buff, 0, read);
                    progress_bytes_current += read;
                    if (stopped) throw new Exception ("Thread stopped by user input.");
                }
                zout.closeEntry ();
                progress_file_current ++;
                in.close ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
                Core.Logger.log (ioe.getMessage (), Level.WARNING);
            }
        }
    }
}


private final void zip (File directory, File base, ZipOutputStream zos) throws IOException {
    File [] files = directory.listFiles ();
    byte [] buffer = new byte [8192];
    int read = 0;
    for (int i = 0, n = files.length; i < n; i ++) {
        if (files [i].isDirectory ()) {
            zip (files [i], base, zos);
        }
        else {
            FileInputStream in = new FileInputStream (files [i]);
            String entryStr = files [i].getPath ().substring (base.getPath ().length () + 1);
            entryStr = entryStr.replaceAll ("\\\\", "/");
            ZipEntry entry = new ZipEntry (entryStr);
            zos.putNextEntry (entry);
            while (- 1 != (read = in.read (buffer))) {
                zos.write (buffer, 0, read);
            }
            in.close ();
        }
    }
}


-----Function Pair=172=-----==

public void compactar (String arqSaida) {
    int i, cont;
    byte [] dados = new byte [TAMANHO_BUFFER];
    File f = null;
    BufferedInputStream origem = null;
    FileInputStream streamDeEntrada = null;
    FileOutputStream destino = null;
    ZipOutputStream saida = null;
    ZipEntry entry = null;
    String arquivos [];
    try {
        destino = new FileOutputStream (arqSaida, false);
        System.out.println ("Aki 3");
        f = new File (".");
        System.out.println (f.getAbsolutePath ());
        arquivos = f.list ();
        for (i = 0; i < arquivos.length; i ++) {
            File arquivo = new File (arquivos [i]);
            if (arquivo.isFile () && ! (arquivo.getName ()).equals (arqSaida)) {
                System.out.println ("Entrou IF");
                System.out.println ("Compactando: " + arquivos [i]);
                System.out.println ("TTTT");
                saida = new ZipOutputStream (new BufferedOutputStream (destino));
                System.out.println ("ZZZZ");
                streamDeEntrada = new FileInputStream (arquivo);
                origem = new BufferedInputStream (streamDeEntrada, TAMANHO_BUFFER);
                entry = new ZipEntry (arquivos [i]);
                saida.putNextEntry (entry);
                while ((cont = origem.read (dados, 0, TAMANHO_BUFFER)) != - 1) {
                    try {
                        saida.write (dados, 0, cont);
                    } catch (IOException ioe) {
                        System.out.println ("Erro de entrada e saida no zip!");
                    }
                }
                origem.close ();
            }
        }
        saida.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public static final void unzipFolder (String inFile, String outFolder) throws IOException {
    File zip = new File (inFile);
    File extractTo = new File (outFolder);
    ZipFile archive = new ZipFile (zip);
    Enumeration e = archive.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        File file = new File (extractTo, entry.getName ());
        if (entry.isDirectory () && ! file.exists ()) {
            file.mkdirs ();
        }
        else {
            if (! file.getParentFile ().exists ()) {
                file.getParentFile ().mkdirs ();
            }
            InputStream in = archive.getInputStream (entry);
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            byte [] buffer = new byte [8192];
            int read;
            while (- 1 != (read = in.read (buffer))) {
                out.write (buffer, 0, read);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=173=-----==

protected ByteArrayOutputStream compressCache (String language) throws Exception {
    if (translations.size () == 0) return null;
    ByteArrayOutputStream bout = new ByteArrayOutputStream ();
    ZipOutputStream zout = new ZipOutputStream (bout);
    Map < String, String > lang = null;
    if (language == null) {
        Set < Entry < String, Map < String, String > > > set = translations.entrySet ();
        for (Entry < String, Map < String, String > > entry : set) {
            compressSingleCache (entry.getKey (), getPropfromHashMap (entry.getValue ()), zout);
        }
        zout.finish ();
        return bout;
    }
    if (translations.containsKey (language)) {
        lang = translations.get (language);
        compressSingleCache (language, getPropfromHashMap (lang), zout);
        zout.finish ();
        return bout;
    }
    return bout;
}


public void operate () throws ApplicationException {
    InputStream inputStream = null;
    try {
        String zipfilename = filename;
        if (zipfilename.indexOf (".") >= 0) {
            zipfilename = zipfilename.substring (0, zipfilename.lastIndexOf ("."));
        }
        zipfilename = TextUtility.replaceString (zipfilename, "+", "%20");
        response.addHeader ("Content-Transfer-Encoding", "base64");
        response.addHeader ("Content-Disposition", "attachment; filename=" + zipfilename + ".zip");
        response.setContentType ("application/x-zip-compressed");
        org.apache.tools.zip.ZipOutputStream sos = new org.apache.tools.zip.ZipOutputStream (response.getOutputStream ());
        sos.setEncoding (this.encoding);
        sos.setMethod (ZipOutputStream.DEFLATED);
        org.apache.tools.zip.ZipEntry theEntry = new org.apache.tools.zip.ZipEntry (this.innerFilename);
        sos.putNextEntry (theEntry);
        byte [] buffer = new byte [DATA_BLOCK_SIZE];
        int length = - 1;
        inputStream = this.getInputStream ();
        while ((length = inputStream.read (buffer, 0, DATA_BLOCK_SIZE)) != - 1) {
            sos.write (buffer, 0, length);
        }
        sos.flush ();
        sos.close ();
    } catch (Exception e) {
        log.error (e, e);
        throw new ApplicationException (com.dcivision.framework.ErrorConstant.COMMON_FATAL_ERROR, e);
    } finally {
        try {
            inputStream.close ();
        } catch (IOException ignore) {
        }
    }
}


-----Function Pair=174=-----==

private void generateInstallCode (File javaFile, String instTemplate, String classLoader) throws IOException {
    String tempString;
    PrintWriter writer = new PrintWriter (new FileWriter (javaFile));
    int read = 0;
    byte [] buf = new byte [128];
    InputStream is = getClass ().getResourceAsStream ("/" + instTemplate);
    InputStreamReader isr = new InputStreamReader (is);
    LineNumberReader reader = new LineNumberReader (isr);
    System.out.println (VAGlobals.i18n ("VAArchiver_GeneratingInstallClassCode"));
    String line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassName"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("public class " + instClassName_ + " {");
    writer.println ("  private static final Class installClass=new " + instClassName_ + "().getClass();");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ArchivingMethod"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String ARCH_METHOD=\"" + archMethod_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> TargetType"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String TARGET_TYPE=\"" + currentTarget_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassOffset"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long ICLASS_OFFSET=" + installClassOffset_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> InstallClassSize"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    if (installClassSize_ != archOffset_) writer.println ("  private static long ICLASS_SIZE=" + installClassSize_ + "L;");
    else writer.println ("  private static long ICLASS_SIZE=-1234543210L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ArchiveOffset"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long ARCH_OFFSET=" + archOffset_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> JarSize"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static long JAR_SIZE=" + jarSize_ + "L;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIMode"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_MODE=\"" + uiMode_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIBluescreen"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_BLUESCREEN=\"" + uiBluescreen_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> UIBluescreenColor"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String UI_BLUESCREEN_COLOR=\"" + uiBluescreenColor_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> DestPath"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String DEST_PATH=\"" + destPath_ + "\";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> AppInfo"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String APP_NAME=\"" + appName_ + "\";");
    if (appVersion_ != null) writer.println ("  private static String APP_VERSION=\"" + appVersion_ + "\";");
    else writer.println ("  private static String APP_VERSION=null;");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> LinkInfos"))) {
        System.out.println ("fred " + line);
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String LINK_SECTION_NAME=\"" + linkSectionName_ + "\";");
    writer.println ("  private static String LINK_SECTION_ICON=\"" + linkSectionIcon_ + "\";");
    writer.println ("  private static String LINK_ENTRY_NAME=\"" + linkEntryName_ + "\";");
    writer.println ("  private static String LINK_ENTRY_ICON=\"" + linkEntryIcon_ + "\";");
    if (createUninstallShortcut_) tempString = "true";
    else tempString = "false";
    writer.println ("  private static boolean CREATE_UNINSTALL_SHORTCUT=" + tempString + ";");
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> LicenseKey"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    writer.println ("  private static String LICENSE_KEY_SUPPORT_NAME=\"" + licenseKeySupportClassName_ + "\";");
    System.out.println (VAGlobals.i18n ("VAArchiver_AppendingClassloader"));
    line = reader.readLine ();
    while ((line != null) && (! line.startsWith ("// --> ClassLoader"))) {
        writer.println (line);
        line = reader.readLine ();
    }
    InputStream isClassLoader = getClass ().getResourceAsStream ("/" + classLoader);
    writer.println ("  private static String[] CL_CLASS={");
    read = isClassLoader.read (buf);
    while (read > 0) {
        writer.println ("\"" + codeLine (buf, read) + "\",");
        read = isClassLoader.read (buf);
    }
    isClassLoader.close ();
    writer.println ("  };\n}");
    reader.close ();
    writer.close ();
    is.close ();
    isr.close ();
}


private static synchronized void zipDir (File zipDir, ZipOutputStream zos, String absolutePathToThemeDir, String rootDirName) throws IOException {
    String [] dirList = zipDir.list ();
    byte [] readBuffer = new byte [2156];
    int bytesIn = 0;
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (zipDir, dirList [i]);
        if (f.isDirectory ()) {
            zipDir (f, zos, absolutePathToThemeDir, rootDirName);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        String path = (StringUtils.isNotEmpty (rootDirName) ? rootDirName : "") + "/" + f.getAbsolutePath ().substring (absolutePathToThemeDir.length () + 1, f.getAbsolutePath ().length ());
        ZipEntry anEntry = new ZipEntry (path);
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            zos.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


-----Function Pair=175=-----==

private File getJStockZipFile () {
    final List < File > files = getUserDefinedDatabaseFiles ();
    final List < FileEx > fileExs = new ArrayList < FileEx > ();
    for (File file : files) {
        final String filename;
        try {
            filename = file.getCanonicalPath ();
        } catch (IOException ex) {
            log.error (null, ex);
            continue;
        }
        final int index = filename.indexOf (Utils.getApplicationVersionString ());
        if (index < 0) {
            continue;
        }
        final String output = filename.substring (index + Utils.getApplicationVersionString ().length () + File.separator.length ());
        fileExs.add (FileEx.newInstance (file, output));
    }
    final JStockOptions jStockOptions = MainFrame.getInstance ().getJStockOptions ();
    final JStockOptions insensitiveJStockOptions = jStockOptions.insensitiveClone ();
    try {
        final File tempJStockOptions = File.createTempFile (Utils.getJStockUUID (), ".xml");
        tempJStockOptions.deleteOnExit ();
        org.yccheok.jstock.gui.Utils.toXML (insensitiveJStockOptions, tempJStockOptions);
        fileExs.add (FileEx.newInstance (tempJStockOptions, "config" + File.separator + "options.xml"));
    } catch (IOException ex) {
        log.error (null, ex);
    }
    getFileEx (fileExs, "config");
    getFileEx (fileExs, "indicator");
    getFileEx (fileExs, "logos");
    for (Country country : Country.values ()) {
        getFileEx (fileExs, country + File.separator + "portfolios");
        getFileEx (fileExs, country + File.separator + "config");
        getFileEx (fileExs, country + File.separator + "watchlist");
    }
    final byte [] buf = new byte [1024];
    ZipOutputStream out = null;
    File temp = null;
    try {
        temp = File.createTempFile (Utils.getJStockUUID (), ".zip");
        temp.deleteOnExit ();
        out = new ZipOutputStream (new FileOutputStream (temp));
        for (FileEx fileEx : fileExs) {
            FileInputStream in = null;
            try {
                in = new FileInputStream (fileEx.input);
                final String zipEntryName = fileEx.output;
                out.putNextEntry (Utils.getZipEntry (zipEntryName));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
            } catch (IOException exp) {
                log.error (null, exp);
                continue;
            } finally {
                Utils.closeEntry (out);
                Utils.close (in);
            }
        }
    } catch (IOException exp) {
        log.error (null, exp);
    } finally {
        Utils.close (out);
    }
    return temp;
}


private void downloadFile (HttpServletRequest req, HttpServletResponse resp, String username, String password) {
    try {
        Utils.log (this.getClass (), "Download: Preparing download...");
        File cachePath = new File (Constants.CACHE.PATH);
        if (! cachePath.exists ()) {
            if (! cachePath.mkdir ()) {
                throw new ErrorCodeException (Constants.ERROR.MKDIRFAIL);
            }
        }
        String files = req.getParameter (Constants.PARAM_FILES);
        if (null == files) {
            throw new ErrorCodeException (Constants.ERROR.BADPARAMS);
        }
        Utils.log (this.getClass (), "Calling files: " + files);
        String cacheFileName = Utils.makeUniqueRandomName ();
        OutputStream out = Support.getFileOutputStream (cachePath, cacheFileName);
        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (new CheckedOutputStream (out, new CRC32 ())));
        zos.setEncoding (Constants.ENCODING.LOCAL_FS);
        String [] filenames = files.split (Constants.SPLITTER.FILE);
        for (String filename : filenames) {
            try {
                filename = Utils.makeArchiveAbsName (Utils.normalFileName (filename));
                Utils.log (this.getClass (), "Add a file to archive file - filename=" + filename);
                File file = new File (filename);
                String archiveName = new String (file.getName ().getBytes ("iso-8859-1"), "utf-8");
                zos.putNextEntry (new ZipEntry (archiveName));
                filename = new String ((file.getParent () == null ? "" : file.getParent ()).getBytes ("iso-8859-1"), "utf-8") + "/" + file.getName ();
                fs.retrieveFile (username, password, filename, zos);
            } catch (Exception e) {
                Utils.log (this.getClass (), "A file compress exception found - filename=" + filename);
                e.printStackTrace ();
            } finally {
                zos.closeEntry ();
            }
        }
        zos.close ();
        String packName = "package_" + System.currentTimeMillis () + ".zip";
        resp.addHeader ("Content-Disposition", "attachment;filename=" + packName);
        resp.setContentType ("application/octet-stream;name=" + packName);
        resp.setCharacterEncoding ("utf-8");
        InputStream in = Support.getFileInputStream (cachePath, cacheFileName);
        OutputStream os = resp.getOutputStream ();
        try {
            Util.copyStream (in, os);
            os.flush ();
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            in.close ();
            os.close ();
        }
        File cf = new File (cachePath, cacheFileName);
        if (cf.exists () && ! cf.delete ()) {
            cf.deleteOnExit ();
        }
    } catch (SecurityException e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.ACCESSDENIED);
    } catch (ErrorCodeException e) {
        e.printStackTrace ();
        error (req, resp, e.getErrorCode ());
    } catch (Exception e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.IOERROR);
    }
}


-----Function Pair=176=-----==

private void perform (String [] files, String path, String offset) {
    byte [] buf = new byte [4096];
    for (int i = 0; i < files.length; i ++) {
        try {
            File f = new File (path + offset + files [i]);
            BufferedInputStream in = null;
            if (f.exists () && ! f.isDirectory ()) {
                in = new BufferedInputStream (new FileInputStream (path + offset + files [i]));
            }
            else if (f.exists ()) {
                if (! files [i].endsWith ("/")) {
                    files [i] = files [i] + "/";
                }
                perform (f.list (), path, offset + files [i]);
            }
            ZipEntry tmp = new ZipEntry (offset + files [i]);
            z.putNextEntry (tmp);
            int len = 0;
            while ((in != null) && (len != StreamTokenizer.TT_EOF)) {
                len = in.read (buf);
                if (len == StreamTokenizer.TT_EOF) {
                    break;
                }
                z.write (buf, 0, len);
            }
            z.closeEntry ();
        } catch (Exception ex) {
            Log.debug ("Skipping a file (no permission?)");
        }
    }
}


public static boolean copyFileCover (String srcFileName, String descFileName, boolean coverlay) {
    File srcFile = new File (srcFileName);
    if (! srcFile.exists ()) {
        System.out.println ("复制文件失败，源文件" + srcFileName + "不存在!");
        return false;
    }
    else if (! srcFile.isFile ()) {
        System.out.println ("复制文件失败，" + srcFileName + "不是一个文件!");
        return false;
    }
    File descFile = new File (descFileName);
    if (descFile.exists ()) {
        if (coverlay) {
            System.out.println ("目标文件已存在，准备删除!");
            if (! FileOperateUtils.delFile (descFileName)) {
                System.out.println ("删除目标文件" + descFileName + "失败!");
                return false;
            }
        }
        else {
            System.out.println ("复制文件失败，目标文件" + descFileName + "已存在!");
            return false;
        }
    }
    else {
        if (! descFile.getParentFile ().exists ()) {
            System.out.println ("目标文件所在的目录不存在，创建目录!");
            if (! descFile.getParentFile ().mkdirs ()) {
                System.out.println ("创建目标文件所在的目录失败!");
                return false;
            }
        }
    }
    int readByte = 0;
    InputStream ins = null;
    OutputStream outs = null;
    try {
        ins = new FileInputStream (srcFile);
        outs = new FileOutputStream (descFile);
        byte [] buf = new byte [1024];
        while ((readByte = ins.read (buf)) != - 1) {
            outs.write (buf, 0, readByte);
        }
        System.out.println ("复制单个文件" + srcFileName + "到" + descFileName + "成功!");
        return true;
    } catch (Exception e) {
        System.out.println ("复制文件失败：" + e.getMessage ());
        return false;
    } finally {
        if (outs != null) {
            try {
                outs.close ();
            } catch (IOException oute) {
                oute.printStackTrace ();
            }
        }
        if (ins != null) {
            try {
                ins.close ();
            } catch (IOException ine) {
                ine.printStackTrace ();
            }
        }
    }
}


-----Function Pair=177=-----==

public void layoutContainer (Container parent) {
    int width = parent.getWidth (), height = parent.getHeight ();
    mediaManagerLabelInfo.setBounds (0, 0, 130, 20);
    mediaManagerInfo.setBounds (2, 22, 125, 55);
    mediaManagerLabelTasks.setBounds (0, 75 + 5, 130, 20);
    mediaManagerRefresh.setBounds (3, 75 + 25 + 1, 125, 20);
    mediaManagerImport.setBounds (3, 75 + 45 + 1, 125, 20);
    mediaManagerExport.setBounds (3, 75 + 65 + 1, 125, 20);
    mediaManagerDelete.setBounds (3, 75 + 85 + 1, 125, 20);
    mediaManagerLabelPreview.setBounds (0, 75 + 125 + 1, 130, 20);
    mediaManagerPreview.setBounds (3, 75 + 130 + 1, 125, 120);
    mediaManagerPreview.setVisible (false);
    mediaManagerLabelPreview.setVisible (false);
    mediaManagerDelete.setEnabled (false);
    mediaManagerDelete.setVisible (false);
    split.setBounds (0, 0, width, height);
}


public void startGui (String [] args) {
    QApplication.initialize (args);
    ui = new Ui_MainWindow ();
    QMainWindow qm = new QMainWindow ();
    ui.setupUi (qm);
    ui.lbl_logo_3.setPixmap (new QPixmap (("images/icon.png")));
    ui.lbl_logo.setPixmap (new QPixmap (("images/icon.png")));
    qm.setWindowIcon (new QIcon (new QPixmap ("images/icon.png")));
    ui.select_algorithm.clear ();
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "BubbleSort", null));
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "SelectionSort", null));
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "QuickSort", null));
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "FlipSort", null));
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "InsertionSort", null));
    ui.select_algorithm.addItem (com.trolltech.qt.core.QCoreApplication.translate ("MainWindow", "HeapSort", null));
    getInstance ().connectSlots ();
    getInstance ().setSimulationProgressBar (0);
    qm.show ();
    System.out.println ("curdir: " + getCurrentDir ());
    QApplication.exec ();
}


-----Function Pair=178=-----==

public void startUpdater (String fileName, String parameter) {
    try {
        log.info ("Updating Updater");
        URL fileUrl = new URL ("http://ossobook.svn.sourceforge.net/svnroot/ossobook/trunk/update/" + fileName);
        URLConnection filecon = fileUrl.openConnection ();
        ReadableByteChannel rbc = Channels.newChannel (fileUrl.openStream ());
        File testFile = new File (fileName);
        int size = filecon.getContentLength ();
        if (testFile.length () == size) {
        }
        else {
            FileOutputStream fos = new FileOutputStream (fileName);
            fos.getChannel ().transferFrom (rbc, 0, 1 << 24);
            fos.close ();
        }
        Runtime.getRuntime ().exec (new String [] {"java", "-jar", fileName, parameter});
        System.exit (0);
    } catch (IOException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


public void preProcessFileList (ProcessorInfo processorInfo, Subject peerSubject) throws Exception {
    System.out.println (" [ PreZipFilter ] Subject: " + peerSubject);
    for (int i = 0; i < processorInfo.fileList.length; i ++) {
        byte [] buf = new byte [1024];
        final String outFilename = processorInfo.fileList [i] + ".zip";
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        FileInputStream in = new FileInputStream (processorInfo.fileList [i]);
        out.putNextEntry (new ZipEntry (processorInfo.fileList [i]));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
        out.close ();
        processorInfo.fileList [i] = outFilename;
    }
}


-----Function Pair=179=-----==

public static String [] executeShellScript (String shellScript, File tempDirectory) {
    File shellFile = new File (tempDirectory, "tempFile_" + UUID.randomUUID () + ".sh");
    String fullPath = getFullPathName (shellFile);
    writeString (shellScript, shellFile);
    String [] cmd = {"chmod", "777", fullPath};
    String [] res = executeCommandLineReturnAll (cmd);
    if (res == null || res.length != 0) {
        shellFile.delete ();
        return null;
    }
    cmd = new String [] {fullPath};
    res = executeCommandLineReturnAll (cmd);
    shellFile.delete ();
    return res;
}


public Document parseToDom (Part part) {
    _log.debug ("parseToDom", new Object [] {part.getName ()});
    ZipFile officeFile = getOfficeFile ();
    ZipEntry documentXML = officeFile.getEntry (part.getName ());
    if (documentXML == null) {
        return null;
    }
    try {
        InputStream documentXMLIS = officeFile.getInputStream (documentXML);
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
        Document doc = dbf.newDocumentBuilder ().parse (documentXMLIS);
        return doc;
    } catch (Exception e) {
        throw new VRuntimeException (e);
    }
}


-----Function Pair=180=-----==

private static void getLauncherOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT lancherOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("lancherOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


private ScheduleItem [] filterItems (ScheduleItem [] itemsArray, boolean past) {
    Vector < ScheduleItem > filteredList = new Vector < ScheduleItem > ();
    Date now = new Date ();
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        if (past) {
            if (item.getStop ().getTime () < now.getTime ()) filteredList.add (item);
        }
        else {
            if (item.getStop ().getTime () >= now.getTime ()) filteredList.add (item);
        }
    }
    ScheduleItem [] items = (ScheduleItem []) filteredList.toArray (new ScheduleItem [0]);
    Arrays.sort (items);
    return items;
}


-----Function Pair=181=-----=1=

public static void zipFiles (String sourcepath, String target) {
    try {
        String source;
        String fileName;
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (target));
        File f = new File (sourcepath);
        String [] children;
        if (f.isDirectory ()) children = f.list ();
        FilenameFilter filter = new FilenameFilter () {
            public boolean accept (File dir, String name) {
                return name.endsWith (".faa");
            }
        }
        ;
        children = f.list (filter);
        for (int i = 0; i < children.length; i ++) {
            fileName = children [i];
            System.out.println ("src :" + fileName);
            source = sourcepath + fileName;
            System.out.println ("source :" + source);
            zos.putNextEntry (new ZipEntry (fileName));
            FileInputStream fis = new FileInputStream (source);
            int size = 0;
            byte [] buffer = new byte [1024];
            while ((size = fis.read (buffer, 0, buffer.length)) > 0) {
                zos.write (buffer, 0, size);
            }
            fis.close ();
        }
        zos.closeEntry ();
        zos.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void createArchive (String iDatabaseDir, String iArchiveName) throws DbBackupException {
    try {
        File archiveFile = new File (iArchiveName);
        String force = (String) parameters.get ("force");
        if (force == null && archiveFile.exists ()) {
            char response = getUserAdvisor ().askToUser (System.out, "    Archive already exist, overwrite ?", "#Yes,#No");
            if (response != 'y' && response != 'Y') {
                System.out.println ();
                throw new DbBackupException ("Backup aborted by user.");
            }
            System.out.print ("    Overwriting...");
        }
        ZipOutputStream archive = new ZipOutputStream (new FileOutputStream (archiveFile));
        archive.setComment ("Orient ODBMS backup archive \r\n" + "Created with odbbackup tool version " + oConstants.PRODUCT_VERSION + ".\r\n" + oConstants.PRODUCT_COPYRIGHTS + "\r\n\r\n" + "WARNING: MODIFING THIS ARCHIVE THE DATABASE CAN BE INCONSISTENT !!!");
        String [] files = new File (iDatabaseDir).list ();
        String filePath;
        File inFile;
        FileInputStream inStream;
        byte [] buffer;
        for (int i = 0; i < files.length; ++ i) {
            filePath = files [i];
            inFile = new File (iDatabaseDir + "/" + filePath);
            inStream = new FileInputStream (iDatabaseDir + "/" + filePath);
            buffer = new byte [(int) inFile.length ()];
            inStream.read (buffer);
            if (monitor != null) monitor.notifyStatus ("Archiving segment: " + filePath, i * 100 / files.length);
            archive.putNextEntry (new ZipEntry (filePath));
            archive.write (buffer);
        }
        archive.close ();
    } catch (Exception e) {
        throw new DbBackupException ("ERROR! Cannot backup the database.");
    }
}


-----Function Pair=182=-----==

public static final boolean zipExtract (String zipfile, String name, String dest) {
    boolean f = false;
    try {
        InputStream in = new BufferedInputStream (new FileInputStream (zipfile));
        ZipInputStream zin = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zin.getNextEntry ()) != null) {
            if (e.getName ().equals (name)) {
                FileOutputStream out = new FileOutputStream (dest);
                byte b [] = new byte [TEMP_FILE_BUFFER_SIZE];
                int len = 0;
                while ((len = zin.read (b)) != - 1) out.write (b, 0, len);
                out.close ();
                f = true;
                break;
            }
        }
        zin.close ();
    } catch (FileNotFoundException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    }
    return (f);
}


public static void ZipFiles (File zipfile, File [] files) throws IOException {
    byte [] buffer = new byte [1024];
    FileOutputStream fos = new FileOutputStream (zipfile);
    ZipOutputStream zos = new ZipOutputStream (fos);
    for (int i = 0; i < files.length; i ++) {
        File src = files [i];
        FileInputStream fis = new FileInputStream (src);
        ZipEntry entry = new ZipEntry (src.getName ());
        zos.putNextEntry (entry);
        int length;
        while ((length = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, length);
        }
        zos.closeEntry ();
        fis.close ();
    }
    zos.close ();
}


-----Function Pair=183=-----==

public void compress (File outputFile) {
    try {
        FileOutputStream dest = new FileOutputStream ((outputFile == null) ? new File (file.toString () + ".zip") : outputFile);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        FileInputStream fi = new FileInputStream (file);
        BufferedInputStream origin = null;
        origin = new BufferedInputStream (fi, BUFFER);
        ZipEntry entry = new ZipEntry (file.toString ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private final void restPrefs (File f, File sp_dir) {
    try {
        ZipFile zf = new ZipFile (f);
        for (int i = 0; i < prefFileNames.length; i ++) {
            ZipEntry ze = zf.getEntry (prefFileNames [i]);
            if (ze != null) {
                InputStream is = zf.getInputStream (ze);
                OutputStream os = new FileOutputStream (new File (sp_dir, prefFileNames [i]));
                Utils.copyBytes (is, os);
                is.close ();
                os.close ();
            }
        }
        showMessage (getString (R.string.prefs_restr));
    } catch (Throwable e) {
        e.printStackTrace ();
    }
}


-----Function Pair=184=-----==

public void write (ZipOutputStream out, DataOutputStream dos, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositionTexts [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositionTexts.length; i ++) {
            int currentStart = sortedPositionTexts [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT + USeqUtilities.TEXT;
    else fileType = USeqUtilities.INT + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = null;
    try {
        out.putNextEntry (new ZipEntry (sliceInfo.getSliceName ()));
        dos.writeUTF (header);
        dos.writeInt (sortedPositionTexts [0].position);
        dos.writeUTF (sortedPositionTexts [0].text);
        if (useShort) {
            int bp = sortedPositionTexts [0].position;
            for (int i = 1; i < sortedPositionTexts.length; i ++) {
                int currentStart = sortedPositionTexts [i].position;
                int diff = currentStart - bp - 32768;
                dos.writeShort ((short) (diff));
                dos.writeUTF (sortedPositionTexts [i].text);
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositionTexts [0].position;
            for (int i = 1; i < sortedPositionTexts.length; i ++) {
                int currentStart = sortedPositionTexts [i].position;
                int diff = currentStart - bp;
                dos.writeInt (diff);
                dos.writeUTF (sortedPositionTexts [i].text);
                bp = currentStart;
            }
        }
        out.closeEntry ();
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (out);
        USeqUtilities.safeClose (dos);
    }
}


public static void zip (File zipFile, List < File > filesToZip, boolean useAbsolutePath, String removePrefix) throws IOException {
    byte [] buffer = new byte [BUFFER];
    zipFile.createNewFile ();
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    out.setLevel (Deflater.DEFAULT_COMPRESSION);
    for (File file : filesToZip) {
        String name = file.getName ();
        if (useAbsolutePath) {
            name = file.getAbsolutePath ();
            if (removePrefix != null) {
                name = name.replace (removePrefix, "");
            }
        }
        FileInputStream in = new FileInputStream (file);
        try {
            out.putNextEntry (new ZipEntry (name));
            System.out.println (name);
            int len;
            while ((len = in.read (buffer)) > 0) {
                out.write (buffer, 0, len);
            }
            out.closeEntry ();
        } catch (Exception ex) {
            Log.exception (ex);
            try {
                out.closeEntry ();
            } catch (Exception ex2) {
            }
        } finally {
            in.close ();
        }
    }
    out.close ();
}


-----Function Pair=185=-----==

protected boolean loadFromXMLZip (File base) {
    setDisableCommits (true);
    log.info ("Trying to load from zip");
    File file = new File (base, "gameXml.zip");
    if (! file.exists ()) {
        return loadFromXMLFiles (base);
    }
    else {
        log.info ("Restoring sessions from zip");
        XStream xs = getXStream ();
        JDBMMapConverter cnv = new JDBMMapConverter (xs.getClassMapper (), "class", dm);
        xs.registerConverter (cnv);
        try {
            synchronized (maps) {
                FileInputStream fin = new FileInputStream (file);
                ZipInputStream zin = new ZipInputStream (fin);
                InputStreamReader reader = new InputStreamReader (zin);
                ZipEntry entry = null;
                String name = null;
                setDisableMapCaching (true);
                while ((entry = zin.getNextEntry ()) != null) {
                    name = entry.getName ();
                    name = name.substring (0, name.length () - 4);
                    long start = System.currentTimeMillis ();
                    cnv.setMap (getMap (name, false));
                    xs.fromXML (reader);
                    log.debug ("Read in " + (System.currentTimeMillis () - start) + " ms");
                    maps.clear ();
                }
                setDisableMapCaching (false);
            }
            setDisableCommits (false);
            return true;
        } catch (IOException ex) {
            log.error ("Unable to load xml from zip", ex);
        }
    }
    setDisableCommits (false);
    setDisableMapCaching (false);
    return false;
}


public static String unzipEntryToFile (ZipInputStream zin, ZipEntry entry, String location) throws IOException {
    final String filename;
    if (location == null) {
        filename = entry.getName ();
    }
    else {
        if (location.endsWith (File.separator)) filename = location + entry.getName ();
        else filename = location + File.separator + entry.getName ();
    }
    if (true || DEBUG.IO) {
        String msg = "Unzipping to " + filename + " from entry " + entry;
        Log.info (msg);
    }
    final File newFile = createFile (filename);
    final FileOutputStream out = new FileOutputStream (newFile);
    byte [] b = new byte [1024];
    int len = 0;
    int wrote = 0;
    while ((len = zin.read (b)) != - 1) {
        wrote += len;
        out.write (b, 0, len);
    }
    out.close ();
    if (DEBUG.IO) {
        Log.debug ("    Unzipped " + filename + "; wrote=" + wrote + "; size=" + entry.getSize ());
    }
    return filename;
}


-----Function Pair=186=-----==

public static JobContainer decode (byte [] raw) {
    JobContainer jc = null;
    PluginManager pManager = Client.getPluginManager ();
    if (raw != null) {
        try {
            ByteArrayInputStream bis = new ByteArrayInputStream (raw);
            ZipInputStream zipIn = new ZipInputStream (bis);
            zipIn.getNextEntry ();
            PluginObjectInputStream ois = new PluginObjectInputStream (zipIn, pManager);
            jc = (JobContainer) ois.readObject ();
            ois.close ();
        } catch (ClassNotFoundException e) {
            logger.log (Level.WARNING, "Plugin not available.", e);
        } catch (InvalidClassException e) {
            logger.log (Level.WARNING, "Job contains incompatible class.", e);
        } catch (Exception e) {
            logger.log (Level.WARNING, "Could not decode job.", e);
        }
    }
    return jc;
}


private int readCurrentTaskProgress () {
    File file = new File (FileManager.getCurrentDir () + "/temp/taskprogress.txt");
    int progress = 0;
    try {
        FileInputStream fstream = new FileInputStream (FileManager.getCurrentDir () + "/temp/taskprogress.txt");
        DataInputStream in = new DataInputStream (fstream);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String strLine;
        while ((strLine = br.readLine ()) != null) {
            progress = Integer.parseInt (strLine);
        }
        in.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return progress;
}


-----Function Pair=187=-----==

private void extractEntries (String [] entryNames, String [] fileNames, boolean overWrite) {
    try {
        ZipInputStream zin = new ZipInputStream (new FileInputStream (selfFile));
        ZipEntry entry;
        while ((entry = zin.getNextEntry ()) != null) {
            int index = getContainEntry (entry.getName (), entryNames);
            if ((index != - 1) && (overWrite || ! FileUtil.isFileExist (fileNames [index]))) {
                byte [] buf = new byte [4096];
                BufferedInputStream bin = new BufferedInputStream (zin);
                FileUtil.makeDirectory (fileNames [index]);
                BufferedOutputStream bout = new BufferedOutputStream (new FileOutputStream (fileNames [index]));
                while (bin.read (buf, 0, 1) != - 1) {
                    bout.write (buf, 0, 1);
                }
                bout.close ();
                bin.close ();
            }
            zin.closeEntry ();
        }
        zin.close ();
    } catch (IOException e) {
        logger.error (e.getLocalizedMessage ());
    }
}


void attackAvatar (int create_guards) {
    if (armageddon) return;
    int tx = mainActor.getTileX (), ty = mainActor.getTileY ();
    Tile loc = new Tile (tx + 128, ty + 128, mainActor.getLift ());
    int gshape = getGuardShape (tx, ty);
    if (gshape >= 0) {
        while (create_guards -- > 0) {
            MonsterActor guard = MonsterActor.create (gshape, loc);
            guard.setTarget (mainActor, true);
            guard.approachAnother (mainActor, false);
        }
    }
    Vector < GameObject > npcs = new Vector < GameObject > ();
    mainActor.findNearbyActors (npcs, EConst.c_any_shapenum, 20, 0x28);
    for (GameObject each : npcs) {
        Actor npc = (Actor) each;
        if ((gshape < 0 || npc.getShapeNum () == gshape || ! (npc instanceof MonsterActor)) && ! npc.getFlag (GameObject.in_party)) npc.setTarget (mainActor, true);
    }
}


-----Function Pair=188=-----==

private void copyZip (ZipInputStream zin, ZipOutputStream out, List < String > files) throws IOException {
    java.util.zip.ZipEntry zentry;
    if (! alreadyWrittenFiles.containsKey (out)) {
        alreadyWrittenFiles.put (out, new HashSet < String > ());
    }
    HashSet < String > currentSet = alreadyWrittenFiles.get (out);
    while ((zentry = zin.getNextEntry ()) != null) {
        String currentName = zentry.getName ();
        String testName = currentName.replace ('/', '.');
        testName = testName.replace ('\\', '.');
        if (files != null) {
            Iterator < String > i = files.iterator ();
            boolean founded = false;
            while (i.hasNext ()) {
                String doInclude = i.next ();
                if (testName.matches (doInclude)) {
                    founded = true;
                    break;
                }
            }
            if (! founded) {
                continue;
            }
        }
        if (currentSet.contains (currentName)) {
            continue;
        }
        try {
            ZipEntry newEntry = new ZipEntry (currentName);
            long fileTime = zentry.getTime ();
            if (fileTime != - 1) {
                newEntry.setTime (fileTime);
            }
            out.putNextEntry (newEntry);
            copyStream (zin, out);
            out.closeEntry ();
            zin.closeEntry ();
            currentSet.add (currentName);
        } catch (ZipException x) {
        }
    }
}


public static Memento loadMemento (InputStream in) throws Exception {
    Memento m = new Memento ();
    ZipInputStream zin = new ZipInputStream (in);
    ZipEntry ze = null;
    LogDataListPersistance listPersistance = null;
    int version = 0;
    while ((ze = zin.getNextEntry ()) != null) {
        if (ze.getName ().equalsIgnoreCase (ENTRY_INFO)) {
            Properties p = new Properties ();
            p.load (zin);
            m.setAddIndex (Integer.parseInt (p.getProperty (INFO_ADD_INDEX)));
            m.setShift (Integer.parseInt (p.getProperty (INFO_SHIFT)));
            m.setName (p.getProperty (INFO_NAME));
            version = Integer.parseInt (p.getProperty (INFO_VERSION));
            if (p.getProperty (INFO_VISIBLE_COLUMNS, "").length () > 0) {
                Iterable < String > split = Splitter.on (",").split (p.getProperty (INFO_VISIBLE_COLUMNS));
                for (String string : split) {
                    m.getVisibleColumns ().add (Integer.parseInt (string));
                }
            }
        }
        else if (ze.getName ().equalsIgnoreCase (ENTRY_MARKS)) {
            Properties p = new Properties ();
            p.load (zin);
            for (Object key : p.keySet ()) {
                m.getMarks ().put (Integer.parseInt (key.toString ()), Boolean.parseBoolean (p.getProperty (key.toString ())));
            }
        }
        else if (ze.getName ().equalsIgnoreCase (ENTRY_NOTES)) {
            Properties p = new Properties ();
            p.load (zin);
            for (Object key : p.keySet ()) {
                m.getNotes ().put (Integer.parseInt (key.toString ()), new Note (p.getProperty (key.toString ())));
            }
        }
        else if (ze.getName ().equalsIgnoreCase (ENTRY_LOGS)) {
            if (version == 1) {
                listPersistance = persistanceVer1;
            }
            else if (version == 2) {
                listPersistance = persistanceVer2;
            }
            else if (version > 2) {
                throw new Exception ("Logs saved with newer version, check for update.");
            }
            List < LogData > loadLogsList = listPersistance.loadLogsList (zin);
            ArrayList < LogData > list = new ArrayList < LogData > (loadLogsList.size ());
            list.addAll (loadLogsList);
            m.setList (list);
        }
        else if (ze.getName ().equalsIgnoreCase (ENTRY_MARKS_COLORS)) {
            Properties p = new Properties ();
            p.load (zin);
            for (Object key : p.keySet ()) {
                m.getMarksColor ().put (Integer.parseInt (key.toString ()), MarkerColors.valueOf (p.getProperty (key.toString ())));
            }
        }
    }
    return m;
}


-----Function Pair=189=-----==

public void init (ServletConfig config) throws ServletException {
    super.init (config);
    try {
        String keyStorePath = getInitParameter (config, INIT_PARAM_JARSIGNERPATH);
        char [] keyStorePasswd = config.getInitParameter (INIT_PARAM_JARSIGNERPASSWD).toCharArray ();
        String alias = config.getInitParameter (INIT_PARAM_JARSIGNERALIAS);
        application = getInitParameter (INIT_PARAM_APPLICATION);
        uRLPrefix = ("/htmf/" + application + "/").length ();
        KeyStore ks = KeyStore.getInstance ("JKS");
        ks.load (new FileInputStream (keyStorePath), keyStorePasswd);
        if (! ks.containsAlias (alias)) {
            log.error ("Error alias '" + alias + "' doesn't exist in jar signer keystore: " + keyStorePath);
        }
        jarSigner = new JarSigner (ks, alias, keyStorePasswd);
    } catch (Exception e) {
        log.error ("Error configuring GenHTMFPackageServlet, message: " + e.getMessage (), e);
    }
}


public boolean marshall (PackagePart part, OutputStream os) throws OpenXML4JException {
    if (! (os instanceof ZipOutputStream)) {
        logger.error ("Unexpected class " + os.getClass ().getName ());
        throw new OpenXML4JException ("ZipOutputStream expected !");
    }
    ZipOutputStream zos = (ZipOutputStream) os;
    ZipEntry partEntry = new ZipEntry (ZipHelper.getZipItemNameFromOPCName (part.getPartName ().getURI ().getPath ()));
    try {
        zos.putNextEntry (partEntry);
        InputStream ins = part.getInputStream ();
        byte [] buff = new byte [ZipHelper.READ_WRITE_FILE_BUFFER_SIZE];
        while (ins.available () > 0) {
            int resultRead = ins.read (buff);
            if (resultRead == - 1) {
                break;
            }
            else {
                zos.write (buff, 0, resultRead);
            }
        }
        zos.closeEntry ();
    } catch (IOException ioe) {
        logger.error ("Cannot write: " + part.getPartName () + ": in ZIP", ioe);
        return false;
    }
    if (part.hasRelationships ()) {
        PackagePartName relationshipPartName = PackagingURIHelper.getRelationshipPartName (part.getPartName ());
        marshallRelationshipPart (part.getRelationships (), relationshipPartName, zos);
    }
    return true;
}


-----Function Pair=190=-----==

public static void decompress (String fos, File dest) throws IOException {
    FileOutputStream fout = new FileOutputStream (dest);
    FileInputStream in = new FileInputStream (fos);
    ZipInputStream zin = new ZipInputStream (in);
    ZipEntry zen = zin.getNextEntry ();
    byte [] tab = new byte [4096];
    int lu = - 1;
    do {
        lu = zin.read (tab);
        if (lu > 0) fout.write (tab, 0, lu);
    }
    while (lu > 0);
    fout.flush ();
    zin.closeEntry ();
    zin.close ();
    fout.close ();
    fout.close ();
    in.close ();
}


public static void unzip (InputStream is, File destDir) throws FileNotFoundException, IOException {
    BufferedOutputStream dest = null;
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (is));
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        if (entry.isDirectory ()) {
            (new File (destDir, entry.getName ())).mkdirs ();
        }
        else {
            File f = new File (destDir, entry.getName ());
            f.getParentFile ().mkdirs ();
            int count;
            byte data [] = new byte [BUFFER];
            FileOutputStream fos = new FileOutputStream (f);
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
        }
    }
    zis.close ();
}


-----Function Pair=191=-----==

public static int selectSaleNumber (String message, Thing seller, Thing buyer, int max) {
    Thing [] things = seller.getItems ();
    Item.tryIdentify (seller, things);
    InventoryScreen is = Game.getQuestapp ().getScreen ().getInventoryScreen ();
    is.setUp (message, buyer, things);
    Game.getQuestapp ().switchScreen (is);
    String line = is.getLine ();
    try {
        if (line.equals ("ESC")) {
            return 0;
        }
        if (line.equals ("") || line.equals ("all")) {
            return max;
        }
        int r = Integer.parseInt (line);
        r = Maths.middle (0, r, max);
        return r;
    } catch (Exception e) {
        Game.warn ("Invalid number in Game.getNumber(...)");
    }
    return 0;
}


public void callGuards (Actor witness) {
    if (armageddon || inDungeon > 0) return;
    if (witness != null || (witness = findWitness (new Actor [1])) != null) witness.say (ItemNames.first_call_guards, ItemNames.last_call_guards);
    int gshape = getGuardShape (mainActor.getTileX (), mainActor.getTileY ());
    if (gshape < 0) {
        attackAvatar (0);
        return;
    }
    Tile actloc = new Tile (), dest = new Tile ();
    mainActor.getTile (actloc);
    dest.set (actloc.tx + 128, actloc.ty + 128, actloc.tz);
    MonsterActor guard = MonsterActor.create (gshape, dest);
    if (! MapChunk.findSpot (actloc, 5, guard.getShapeNum (), guard.getFrameNum (), 1)) {
        int dir = EUtil.getDirection (dest.ty - actloc.ty, actloc.tx - dest.tx);
        byte frames [] = new byte [2];
        frames [0] = (byte) guard.getDirFramenum (dir, Actor.standing);
        frames [1] = (byte) guard.getDirFramenum (dir, 3);
        ActorAction action = new ActorAction.Sequence (new ActorAction.Frames (frames, 2), new ActorAction.Usecode (0x625, guard, UsecodeMachine.double_click));
        Schedule.setActionSequence (guard, dest, action, true, 0);
    }
}


-----Function Pair=192=-----==

public static final String decompress (byte [] compressed) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    ByteArrayInputStream in = new ByteArrayInputStream (compressed);
    ZipInputStream zin = new ZipInputStream (in);
    ZipEntry entry = zin.getNextEntry ();
    byte [] buffer = new byte [1024];
    int offset = - 1;
    while ((offset = zin.read (buffer)) != - 1) {
        out.write (buffer, 0, offset);
    }
    String decompressed = out.toString ();
    out.close ();
    zin.close ();
    return decompressed;
}


public static int getLastLineWith (File fileName, String textToFind) throws IOException {
    String line;
    FileInputStream fis = new FileInputStream (fileName);
    BufferedReader reader = new BufferedReader (new InputStreamReader (fis));
    int lineNumber = 0;
    int toRet = - 1;
    while ((line = reader.readLine ()) != null) {
        if (Pattern.compile (textToFind).matcher (line).find ()) {
            toRet = lineNumber;
        }
        lineNumber ++;
    }
    reader.close ();
    return toRet;
}


-----Function Pair=193=-----==

public void testGetJarEntry () throws Exception {
    Support_Resources.copyFile (resources, null, JAR1);
    JarFile jarFile = new JarFile (new File (resources, JAR1));
    assertEquals ("Error in returned entry", 311, jarFile.getEntry (JAR1_ENTRY1).getSize ());
    jarFile.close ();
    String jarDirUrl = Support_Resources.getResourceURL ("/../internalres/signedjars");
    Vector < String > signedJars = new Vector < String > ();
    try {
        InputStream is = new URL (jarDirUrl + "/jarlist.txt").openStream ();
        while (is.available () > 0) {
            StringBuilder linebuff = new StringBuilder (80);
            done : while (true) {
                int nextByte = is.read ();
                switch (nextByte) {
                    case - 1 :
                        break done;
                    case (byte) '\r' :
                        if (linebuff.length () == 0) {
                        }
                        break done;
                    case (byte) '\n' :
                        if (linebuff.length () == 0) {
                        }
                        break done;
                    default :
                        linebuff.append ((char) nextByte);
                }
            }
            if (linebuff.length () == 0) {
                break;
            }
            String line = linebuff.toString ();
            signedJars.add (line);
        }
        is.close ();
    } catch (IOException e) {
    }
    for (int i = 0; i < signedJars.size (); i ++) {
        String jarName = signedJars.get (i);
        try {
            File file = Support_Resources.getExternalLocalFile (jarDirUrl + "/" + jarName);
            jarFile = new JarFile (file, true);
            boolean foundCerts = false;
            Enumeration < JarEntry > e = jarFile.entries ();
            while (e.hasMoreElements ()) {
                JarEntry entry = e.nextElement ();
                InputStream is = jarFile.getInputStream (entry);
                is.skip (100000);
                is.close ();
                Certificate [] certs = entry.getCertificates ();
                if (certs != null && certs.length > 0) {
                    foundCerts = true;
                    break;
                }
            }
            assertTrue ("No certificates found during signed jar test for jar \"" + jarName + "\"", foundCerts);
        } catch (IOException e) {
            fail ("Exception during signed jar test for jar \"" + jarName + "\": " + e.toString ());
        }
    }
}


public String serializeLexicon () throws Exception {
    URL url = this.getClass ().getResource ("lex.dic");
    String path = url.getPath ();
    String jar_path = path.substring (path.indexOf ("/") + 1, path.indexOf ("!"));
    String internal_package = path.substring (path.indexOf ("!/") + 2, path.lastIndexOf ("/"));
    ZipInputStream in = new ZipInputStream (new FileInputStream (new File (jar_path)));
    String new_version = jar_path.substring (0, jar_path.indexOf (".jar")) + ".zip";
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (new File (new_version)));
    ZipEntry entry = null;
    while ((entry = in.getNextEntry ()) != null) {
        if (entry.getName ().indexOf (ApelonAdditonFileName) != - 1) continue;
        out.putNextEntry (entry);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
    }
    if (apelonAdditions != null) {
        out.putNextEntry (new ZipEntry (internal_package + "/" + ApelonAdditonFileName));
        ByteArrayOutputStream bout = new ByteArrayOutputStream ();
        ObjectOutputStream os = new ObjectOutputStream (bout);
        os.writeObject (apelonAdditions);
        out.write (bout.toByteArray (), 0, bout.size ());
        os.close ();
    }
    out.closeEntry ();
    out.close ();
    return new_version;
}


-----Function Pair=194=-----==

private static void saveElementSetHead (ElementSet set, String path) throws IOException {
    FileWriter f_out = new FileWriter (path);
    ListIterator < SetElement > iterator = set.getInList ().listIterator ();
    SetElement cur;
    f_out.write ("Set name:\n");
    f_out.write (set.getName () + "\n");
    f_out.write ("Set size:\n");
    f_out.write (set.getInList ().size () + "\n");
    f_out.write ("---------SetElements---------\n");
    while (iterator.hasNext ()) {
        cur = iterator.next ();
        f_out.write (cur.name + "\n");
        f_out.write (cur.ID + "\n");
        f_out.write (cur.imgPath + "\n");
        f_out.write (cur.a_segment + "\n");
        f_out.write (cur.bodyHeight + "\n");
        f_out.write ("=>------****------<=\n");
    }
    f_out.write ("------------END--------------\n");
    f_out.close ();
}


public static final File unGZip (final GZIPInputStream in, final File outFile) {
    BufferedOutputStream out = null;
    try {
        final byte data [] = new byte [10240];
        out = new BufferedOutputStream (new FileOutputStream (outFile));
        int count;
        while ((count = in.read (data)) != - 1) out.write (data, 0, count);
        out.flush ();
        return outFile;
    } catch (final IOException e) {
        e.printStackTrace ();
        return null;
    } finally {
        closeIO (in);
    }
}


-----Function Pair=195=-----==

private static String fromEscape (String s) {
    StringBuffer res = new StringBuffer ();
    for (int i = 0; i < s.length (); i ++) {
        char ch = s.charAt (i);
        if (ch == '\\' && i + 1 >= s.length ()) {
            res.append (ch);
            break;
        }
        if (ch != '\\' || ch == '\\' && s.charAt (i + 1) != 'u') res.append (ch);
        else {
            res.append ((char) Integer.parseInt (s.substring (i + 2, i + 6), 16));
            i += 5;
        }
    }
    return res.toString ();
}


private boolean writeAditionalEntry (ZipOutputStream zipOut, ExportFileEntry file) throws IOException {
    if (! StringUtils.hasValue (file.getHref ())) {
        logger.severe ("Missing href for additional export entry " + "when exporting file " + dest);
        return false;
    }
    if (! StringUtils.hasValue (file.getFilename ())) {
        logger.severe ("Missing filename for additional export entry " + "when exporting file " + dest);
        return false;
    }
    byte [] data;
    String uri = getAdditionalEntryUri (file);
    try {
        data = ctx.getWebServer ().getRequest (uri, true);
    } catch (IOException ioe) {
        logger.severe ("Encountered exception when exporting " + uri + " for export file " + dest);
        ioe.printStackTrace ();
        return false;
    }
    zipOut.putNextEntry (new ZipEntry (file.getFilename ()));
    zipOut.write (data);
    zipOut.closeEntry ();
    return true;
}


-----Function Pair=196=-----==

public static void zipTo (File dir, File destFile) {
    FileOutputStream ops = null;
    ZipOutputStream zos = null;
    try {
        ops = new FileOutputStream (destFile);
        zos = new ZipOutputStream (ops);
        zipDir (dir, zos, "");
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (zos != null) zos.close ();
            else if (ops != null) ops.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public static void save (File file, Workspace workspace) {
    if (file != null) {
        try {
            FileOutputStream ostream = new FileOutputStream (file);
            try {
                WorkspaceSerializer serializer = new WorkspaceSerializer (workspace);
                serializer.serialize (ostream);
                workspace.setWorkspaceChanged (false);
            } finally {
                ostream.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=197=-----==

private void GetSiteImageFtps (ZipFile file) throws Exception {
    java.util.Enumeration files = file.entries ();
    while (files.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) files.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().endsWith (".iftp")) {
                InputStream in = file.getInputStream (entry);
                java.io.InputStreamReader r = new InputStreamReader (in, "UTF-8");
                java.io.BufferedReader br = new BufferedReader (r);
                String host_name = null;
                String s = br.readLine ();
                if (s != null) host_name = s.trim ();
                String host_remotedir = null;
                s = br.readLine ();
                if (s != null) host_remotedir = s.trim ();
                String host_remoteport = null;
                s = br.readLine ();
                if (s != null) host_remoteport = s.trim ();
                int host_port = 21;
                try {
                    host_port = (int) Float.parseFloat (host_remoteport);
                } catch (Exception e1) {
                }
                String host_username = null;
                s = br.readLine ();
                if (s != null) host_username = s.trim ();
                String host_userpassword = null;
                s = br.readLine ();
                if (s != null) host_userpassword = s.trim ();
                AddFtp4Image (host_name, host_remotedir, host_port, host_username, host_userpassword);
                try {
                    br.close ();
                } catch (Exception e1) {
                }
            }
        }
    }
}


private byte [] showCapPathPage (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CapturePaths.html");
    template.replaceAll ("$title", "Capture path and file name setup");
    StringBuffer buff = new StringBuffer ();
    String [] paths = store.getCapturePaths ();
    DllWrapper wrapper = new DllWrapper ();
    NumberFormat nf = NumberFormat.getInstance ();
    for (int x = 0; x < paths.length; x ++) {
        buff.append ("<tr>");
        File capPath = new File (paths [x]);
        if (capPath.exists () == false) {
            buff.append ("<td nowrap>");
            buff.append ("<img border='0' alt='Does Not Exist' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
            buff.append (paths [x] + " </td>");
            buff.append ("<td nowrap> (No details available) </td>");
        }
        else {
            buff.append ("<td nowrap>" + capPath.getCanonicalPath () + " </td>");
            long freeSpace = wrapper.getFreeSpace (capPath.getCanonicalPath ());
            freeSpace /= (1024 * 1024);
            buff.append ("<td nowrap> Free: " + nf.format (freeSpace) + " MB</td>");
        }
        buff.append ("<td nowrap width='50px'> ");
        if (paths.length > 1) {
            buff.append (" <a href='/servlet/SystemDataRes?action=33&id=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
            if (x > 0) buff.append ("<a href='/servlet/SystemDataRes?action=34&id=" + x + "&amount=-1'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
            else buff.append ("<img border='0' alt='' src='/images/blank.gif' align='absmiddle' width='7' height='7'> ");
            if (x < paths.length - 1) buff.append ("<a href='/servlet/SystemDataRes?action=34&id=" + x + "&amount=1'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
            else buff.append ("<img border='0' alt='' src='/images/blank.gif' align='absmiddle' width='7' height='7'> ");
        }
        buff.append (" </td>\n");
        buff.append ("</tr>");
    }
    template.replaceAll ("$capturePaths", buff.toString ());
    template.replaceAll ("$minSpaceSoft", store.getProperty ("capture.minspacesoft"));
    template.replaceAll ("$minSpaceHard", store.getProperty ("capture.minspacehard"));
    if ("1".equals (store.getProperty ("capture.deletetofreespace"))) {
        template.replaceAll ("$DeleteToFreeSpace", "checked");
    }
    else {
        template.replaceAll ("$DeleteToFreeSpace", "");
    }
    String autoType = store.getProperty ("capture.autoselectmethod");
    buff = new StringBuffer ();
    if (autoType.equals ("0")) buff.append ("<option value='0' selected>Most Free Space</option>");
    else buff.append ("<option value='0'>Most Free Space</option>");
    if (autoType.equals ("1")) buff.append ("<option value='1' selected>First With Enough Space</option>");
    else buff.append ("<option value='1'>First With Enough Space</option>");
    template.replaceAll ("$AutoSelectType", buff.toString ());
    String includeThis = store.getProperty ("capture.includecalculatedusage");
    if ("1".equals (includeThis)) {
        template.replaceAll ("$IncludeThisCapture", "checked");
    }
    else {
        template.replaceAll ("$IncludeThisCapture", "");
    }
    String avDataRate = store.getProperty ("capture.averagedatarate").trim ();
    template.replaceAll ("$AverageDataRate", avDataRate);
    String [] patterns = store.getNamePatterns ();
    buff = new StringBuffer ();
    for (int x = 0; x < patterns.length; x ++) {
        buff.append ("<tr>");
        buff.append ("<td>" + patterns [x] + " </td>");
        buff.append ("<td> " + testPattern (patterns [x]) + " </td>");
        buff.append ("<td nowrap width='50px'> ");
        buff.append (" <a href='/servlet/SystemDataRes?action=28&id=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        buff.append ("<a href='/servlet/SystemDataRes?action=30&id=" + x + "&amount=-1'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        buff.append ("<a href='/servlet/SystemDataRes?action=30&id=" + x + "&amount=1'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        buff.append (" </td>\n");
        buff.append ("</tr>");
    }
    template.replaceAll ("$fileNamePatterns", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=198=-----==

public static boolean copyFileStream (final File _fileFrom, final File _fileTo, final boolean _append) {
    boolean r = true;
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new FileInputStream (_fileFrom);
        out = new FileOutputStream (_fileTo, _append);
        return copyStream (in, out, false, false);
    } catch (final IOException _e1) {
        r = false;
    } finally {
        IOException io = null;
        if (in != null) {
            io = close (in);
            if (io != null) {
                r = false;
            }
        }
        if (out != null) {
            io = close (out);
            if (io != null) {
                r = false;
            }
        }
    }
    return r;
}


public static boolean zip (File [] filesToZip, File zipFile) {
    byte [] buf = new byte [2048];
    ZipOutputStream out = null;
    FileInputStream in = null;
    try {
        out = new ZipOutputStream (new FileOutputStream (zipFile));
        for (int i = 0; i < filesToZip.length; i ++) {
            in = new FileInputStream (filesToZip [i]);
            out.putNextEntry (new ZipEntry (filesToZip [i].getName ()));
            int len;
            while ((len = in.read (buf)) != - 1) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
        System.err.println ("Can't zip()");
        e.printStackTrace ();
        safeClose (out);
        safeClose (in);
        return false;
    }
    return true;
}


-----Function Pair=199=-----==

protected Element openExportFile () throws IOException, SAXException {
    setExportZipStream (new ZipOutputStream (new FileOutputStream (getExportFileName ())));
    CmsXmlSaxWriter saxHandler = new CmsXmlSaxWriter (new StringWriter (4096), OpenCms.getSystemInfo ().getDefaultEncoding ());
    saxHandler.setEscapeXml (true);
    saxHandler.setEscapeUnknownChars (true);
    setSaxWriter (new SAXWriter (saxHandler, saxHandler));
    Document doc = DocumentHelper.createDocument ();
    saxHandler.startDocument ();
    if (m_parameters.isXmlValidation ()) {
        saxHandler.startDTD (getExportNodeName (), null, CmsConfigurationManager.DEFAULT_DTD_PREFIX + CmsImportVersion7.DTD_FILENAME);
        saxHandler.endDTD ();
    }
    String exportNodeName = getExportNodeName ();
    Element exportNode = doc.addElement (exportNodeName);
    getSaxWriter ().writeOpen (exportNode);
    Element info = exportNode.addElement (CmsImportExportManager.N_INFO);
    info.addElement (CmsImportExportManager.N_CREATOR).addText (getCms ().getRequestContext ().currentUser ().getName ());
    info.addElement (CmsImportExportManager.N_OC_VERSION).addText (OpenCms.getSystemInfo ().getVersionNumber ());
    info.addElement (CmsImportExportManager.N_DATE).addText (CmsDateUtil.getHeaderDate (System.currentTimeMillis ()));
    info.addElement (CmsImportExportManager.N_INFO_PROJECT).addText (getCms ().getRequestContext ().currentProject ().getName ());
    info.addElement (CmsImportExportManager.N_VERSION).addText (CmsImportExportManager.EXPORT_VERSION);
    digestElement (exportNode, info);
    return exportNode;
}


public static boolean copyFileChannel (final File _fileFrom, final File _fileTo, final boolean _append) {
    FileChannel srcChannel = null;
    FileChannel dstChannel = null;
    try {
        srcChannel = new FileInputStream (_fileFrom).getChannel ();
        dstChannel = new FileOutputStream (_fileTo, _append).getChannel ();
        if (_append) {
            dstChannel.transferFrom (srcChannel, dstChannel.size (), srcChannel.size ());
        }
        else {
            dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());
        }
        srcChannel.close ();
        dstChannel.close ();
    } catch (final IOException e) {
        return false;
    } finally {
        try {
            if (srcChannel != null) {
                srcChannel.close ();
            }
        } catch (final IOException _evt) {
            FuLog.error (_evt);
        }
        try {
            if (dstChannel != null) {
                dstChannel.close ();
            }
        } catch (final IOException _evt) {
            FuLog.error (_evt);
        }
    }
    return true;
}


-----Function Pair=200=-----==

public static Object readObjectFromFile (String file) throws ClassNotFoundException, IOException {
    ObjectInputStream ois = null;
    try {
        ois = new ObjectInputStream (new FileInputStream (file));
        return ois.readObject ();
    } catch (IOException e) {
        throw e;
    } finally {
        try {
            if (ois != null) {
                ois.close ();
            }
        } catch (IOException e) {
        }
    }
}


public void test_listFiles_1 () throws Exception {
    IResourcesProvider provider = getTestModuleResourceProvider ();
    try {
        {
            List < String > files = provider.listFiles ("test");
            assertThat (files).contains ("Module.gwt.xml", "client/Module.java");
            assertFalse (files.contains ("client/Module.class"));
        }
        {
            List < String > files = provider.listFiles ("com/google/gwt/xml");
            assertThat (files).contains ("XML.gwt.xml", "client/");
        }
    } finally {
        provider.dispose ();
    }
}


-----Function Pair=201=-----==

private static void copyMoveFolderRecursive (File src, File dest, boolean move) throws IOException {
    File [] fs = Utils.listFilesForFolder (src);
    File f;
    for (int i = 0; i < fs.length; i ++) {
        f = fs [i];
        if (! f.canRead ()) {
            throw new IOException ("no read access to " + f.getAbsolutePath ());
        }
        if (f.isFile ()) {
            copyFile (f, new File (dest, f.getName ()));
        }
        else if (f.isDirectory ()) {
            File destFolder = new File (dest, f.getName ());
            if (! destFolder.exists ()) {
                destFolder.mkdir ();
            }
            copyMoveFolderRecursive (f, destFolder, move);
        }
        if (move && f.canWrite ()) {
            f.delete ();
        }
    }
}


public void UpdateTopicVars (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_vars where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        Hashtable vars = t.GetVars ();
        if (vars != null && ! vars.isEmpty ()) {
            sql = "insert into topic_vars(topid,varname,value) values(?,?,?)";
            pstmt = inCtxt.GetConnection ().prepareStatement (sql);
            Enumeration vars_elements = vars.elements ();
            while (vars_elements.hasMoreElements ()) {
                Topic.Var var = (Topic.Var) vars_elements.nextElement ();
                pstmt.setString (1, t.GetId ());
                pstmt.setString (2, var.name);
                pstmt.setString (3, var.value);
                pstmt.executeUpdate ();
            }
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=202=-----==

private void compressFile (File file, String path) throws IOException {
    if (! file.isDirectory ()) {
        byte [] buf = new byte [BUFFER_SIZE];
        int len;
        FileInputStream in = new FileInputStream (file);
        zos.putNextEntry (new ZipEntry (path + "/" + file.getName ()));
        while ((len = in.read (buf)) > 0) {
            zos.write (buf, 0, len);
        }
        in.close ();
        return;
    }
    if (file.list () == null) {
        return;
    }
    for (String fileName : file.list ()) {
        File f = new File (file.getAbsolutePath () + File.separator + fileName);
        compressFile (f, path + File.separator + file.getName ());
        isCompressed ++;
        progressDialog.setProgress ((isCompressed * 100) / fileCount);
    }
}


protected static void loadHistory (Element root) {
    try {
        int m = 0;
        Element hElement = (Element) root.getElementsByTagName ("History").item (0);
        if (hElement != null) {
            NodeList nList = hElement.getElementsByTagName ("Projects");
            for (int n = 0; n < nList.getLength (); n ++) {
                Element aElement = (Element) nList.item (n);
                NodeList aList = aElement.getElementsByTagName ("*");
                for (int x = 0; x < aList.getLength (); x ++) {
                    projectNames.addElement (aList.item (x).getFirstChild ().getNodeValue ());
                    m ++;
                    if (m == maxHistory) return;
                }
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=203=-----==

public boolean update (TurtleEggs turtleEggs) throws MalformedURLException, IOException {
    URL u = new URL (config.get ("updateURL"));
    URLConnection uc = u.openConnection ();
    boolean ret = false;
    logger.log (Level.INFO, "update request.");
    uc.setDoOutput (true);
    OutputStreamWriter osw = new OutputStreamWriter (uc.getOutputStream (), "UTF-8");
    osw.write ("user=" + config.get ("username") + "&passwd=" + config.get ("password"));
    osw.write ("&version=" + config.get ("version"));
    osw.write ("&id=" + turtleEggs.getID ());
    osw.write ("&layers=" + tile.getLayer ());
    osw.write ("&z=" + tile.getZ ());
    osw.write ("&x=" + tile.getX () + "&y=" + tile.getY ());
    osw.flush ();
    BufferedReader rd = new BufferedReader (new InputStreamReader (uc.getInputStream (), "UTF-8"));
    String line = rd.readLine ();
    if (line == null) {
        logger.log (Level.INFO, "no answer");
        ret = false;
    }
    else {
        logger.log (Level.INFO, "answer: " + line);
        while ((line = rd.readLine ()) != null) {
            logger.log (Level.INFO, line);
        }
        ret = true;
    }
    osw.close ();
    rd.close ();
    return ret;
}


public void testImport () throws Exception {
    Init.importEverything ();
    String filename = Framework.onlyInstance ().getAppHomeDir () + "sts-sql/example.stz";
    ZipOutputStream zo = new ZipOutputStream (new FileOutputStream (filename));
    StringWriter swt;
    byte [] data;
    swt = new StringWriter ();
    ExportCSVRegattaWizard erw = new ExportCSVRegattaWizard (new JFrame ());
    erw.doExport (swt);
    data = swt.toString ().getBytes ();
    zo.putNextEntry (new ZipEntry ("regatta.csv"));
    zo.write (data);
    swt = new StringWriter ();
    ExportCSVEntriesWizard eew = new ExportCSVEntriesWizard (new JFrame ());
    eew.doExport (swt);
    data = swt.toString ().getBytes ();
    zo.putNextEntry (new ZipEntry ("entries.csv"));
    zo.write (data);
    swt = new StringWriter ();
    ExportCSVRaceDataWizard edw = new ExportCSVRaceDataWizard (new JFrame ());
    edw.doExport (swt);
    data = swt.toString ().getBytes ();
    zo.putNextEntry (new ZipEntry ("race-data.csv"));
    zo.write (data);
    zo.close ();
}


-----Function Pair=204=-----==

private void onDel () {
    if (contents != null) {
        int selRow = contents.getSelectedRow ();
        if (selRow > - 1) {
            String keyToRemove = contents.getValueAt (selRow, 0).toString ();
            langFile.deleteEntry (keyToRemove);
            refreshTableContents ();
            unsaved = true;
            int numOfRows = contents.getRowCount ();
            if (selRow < numOfRows) {
                contents.changeSelection (selRow, 0, true, false);
            }
            else {
                if (numOfRows > 0) contents.changeSelection (numOfRows - 1, 0, true, false);
            }
        }
    }
}


public void exportFile (TranslationFile file) {
    try {
        currentEntryFileName = zipPrefix + "/" + file.getComponentPath () + file.getFileName ();
        tempFile = File.createTempFile ("MTT_", null);
        tempFile.deleteOnExit ();
        tempos = new FileOutputStream (tempFile);
        if (currentEntryFileName.endsWith (".properties")) {
            setupWritePropertiesFile ();
        }
        else if (currentEntryFileName.endsWith (".dtd")) {
            setupWriteDTDFile ();
        }
        else if (currentEntryFileName.endsWith (".rdf")) {
            createRDFFile (file);
        }
        else {
        }
    } catch (Exception e) {
        System.out.println ("Error in exporting file");
        System.exit (1);
    }
}


-----Function Pair=205=-----==

private void createFile (String createFilePath, String contents) {
    try {
        File file = new File (createFilePath);
        boolean success = file.createNewFile ();
        if (success) {
            BufferedWriter out = new BufferedWriter (new FileWriter (createFilePath, true));
            out.write (contents);
            out.close ();
        }
        else {
            (new File (createFilePath)).delete ();
            createFile (createFilePath, contents);
        }
    } catch (IOException e) {
        System.out.println ("Could not create file: (debug: createFilePath() " + createFilePath + ")");
        System.out.println ("Do you have write permission for this location?");
        System.exit (1);
    }
}


private byte [] updatePathSettings (HTTPurl urlData) throws Exception {
    int minSpace = 500;
    try {
        minSpace = Integer.parseInt (urlData.getParameter ("minSpace").trim ());
    } catch (Exception e) {
    }
    store.setServerProperty ("Capture.minSpace", new Integer (minSpace).toString ());
    store.setServerProperty ("Capture.AutoSelectMethod", urlData.getParameter ("AutoSelectType").trim ());
    String include = urlData.getParameter ("IncludeThisCapture");
    if ("true".equalsIgnoreCase (include)) {
        store.setServerProperty ("Capture.IncludeCalculatedUsage", "1");
    }
    else {
        store.setServerProperty ("Capture.IncludeCalculatedUsage", "0");
    }
    int avgData = 7000000;
    try {
        avgData = Integer.parseInt (urlData.getParameter ("AverageDataRate").trim ());
    } catch (Exception e) {
    }
    store.setServerProperty ("Capture.AverageDataRate", new Integer (avgData).toString ());
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/SystemDataRes?action=27\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=206=-----==

protected Cipher getCryptCipher (int l_cryptMode) throws IOException {
    if (false == this.loggedIn && false == this.login ()) {
        throw new IOException (resMap.getString ("message.userCanceledLogin.text"));
    }
    String password = this.systemSetup.getPassword ();
    Cipher cipher = null;
    try {
        SecretKeyFactory factory = SecretKeyFactory.getInstance ("PBKDF2WithHmacSHA1");
        KeySpec spec = new PBEKeySpec (password.toCharArray (), CIPHER_SALT.getBytes (), 1024, 128);
        SecretKey tmp = factory.generateSecret (spec);
        SecretKey secret = new SecretKeySpec (tmp.getEncoded (), "AES");
        cipher = Cipher.getInstance ("AES");
        cipher.init (l_cryptMode, secret);
    } catch (Exception ex) {
        throw new IOException (resMap.getString ("message.couldNotInitializeEncryptor.text"));
    }
    return cipher;
}


public Map getSecurityDefinitionSelectionMap () {
    Map securityMap = new LinkedHashMap ();
    List availableRoles = Application.getInstance ().getAllRoles ();
    for (Iterator iter = getSecurityDefinitionList ().iterator (); iter.hasNext ();) {
        SecurityDefinition def = (SecurityDefinition) iter.next ();
        String allowedRoles = def.getAllowedRoles ();
        if (allowedRoles == null) allowedRoles = "";
        Map roleMap = new LinkedHashMap ();
        for (Iterator roleiter = availableRoles.iterator (); roleiter.hasNext ();) {
            String role = (String) roleiter.next ();
            if (allowedRoles.indexOf (role) != - 1 || "APP_ADMINISTRATOR".equals (role)) {
                roleMap.put (role, Boolean.TRUE);
            }
            else {
                roleMap.put (role, Boolean.FALSE);
            }
        }
        securityMap.put (def, roleMap);
    }
    return securityMap;
}


-----Function Pair=207=-----=1=

protected void zipDirectory (File dir, File zipfile) throws IOException, IllegalArgumentException {
    if (! dir.isDirectory ()) throw new IllegalArgumentException ("Compress: not a directory:  " + dir);
    String [] entries = dir.list ();
    byte [] buffer = new byte [4096];
    int bytes_read;
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipfile));
    for (int i = 0; i < entries.length; i ++) {
        File f = new File (dir, entries [i]);
        if (f.isDirectory ()) continue;
        FileInputStream in = new FileInputStream (f);
        ZipEntry entry = new ZipEntry (f.getPath ());
        out.putNextEntry (entry);
        while ((bytes_read = in.read (buffer)) != - 1) out.write (buffer, 0, bytes_read);
        in.close ();
    }
    out.close ();
}


public static boolean copiaSeguridad (File destino) {
    try {
        if (! destino.toString ().endsWith (".ignotus")) {
            destino = new File (destino.toString () + ".ignotus");
        }
        FileOutputStream dest = new FileOutputStream (destino);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        File datos = new File (DATOS);
        for (File arch : datos.listFiles ()) {
            if (arch.getName ().endsWith (".lck")) {
                continue;
            }
            ZipEntry entry = new ZipEntry (arch.getName ());
            out.putNextEntry (entry);
            FileInputStream fi = new FileInputStream (arch);
            BufferedInputStream origin = new BufferedInputStream (fi, BUFFER);
            int count;
            byte data [] = new byte [BUFFER];
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (IOException ex) {
        Logger.getLogger (Conexion.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return true;
}


-----Function Pair=208=-----==

public void expandSet (HashSet jars) throws IOException {
    HashSet foundEntries = new HashSet ();
    for (Iterator iterator = jars.iterator (); iterator.hasNext ();) {
        JarFile jar = getJarFile (iterator.next ());
        Manifest manifest = jar.getManifest ();
        Attributes attributes = manifest.getMainAttributes ();
        String classpath = (String) attributes.get (Attributes.Name.CLASS_PATH);
        if (classpath != null) {
            StringTokenizer tokenizer = new StringTokenizer (classpath);
            while (tokenizer.hasMoreTokens ()) {
                String entry = tokenizer.nextToken ();
                foundEntries.add (entry);
            }
        }
    }
    jars.addAll (foundEntries);
}


private void addTask () {
    if (ui.tabs_tasks.currentIndex () == 0) {
        Boolean customflag = false;
        Algorithm algorithm = null;
        if (ui.tab_algorithm.currentIndex () == 0) {
            String alg = ui.select_algorithm.currentText ();
            algorithm = new SortingAlgorithm (alg, alg);
        }
        else {
            customflag = true;
            String alg = ui.txt_classname.toPlainText ();
            String customtype = text2CustomType (ui.custom_type.currentText ()) + "";
            System.out.println ("Customtype: " + customtype);
            algorithm = new CustomAlgorithm (alg, alg, customtype);
        }
        int arrayType = text2ArrayType (ui.select_arraytype.currentText ());
        int startsize = ui.spin_startsize.value ();
        int maxsize = ui.spin_maxsize.value ();
        int stepsize = ui.spin_stepsize.value ();
        System.out.println (startsize);
        AlgorithmTask task = new AlgorithmTask (algorithm, startsize, maxsize, stepsize, arrayType);
        ceo.getTaskHolder ().addTask (task);
        ui.tasklist.addRow (new String [] {task.getAlgorithm ().getClassName (), task.getArrayType () + "", "" + startsize, "" + maxsize, "" + stepsize});
        if (! customflag) {
            ui.tasklist.setDefaultAlgorithm (ui.tasklist.rowCount () - 1);
        }
    }
    else if (ui.tabs_tasks.currentIndex () == 1) {
        int startsize = ui.spin_startsize_function.value ();
        int maxsize = ui.spin_maxsize_function.value ();
        int stepsize = ui.spin_stepsize_function.value ();
        Function task = new Function (ui.txt_function.text (), startsize, stepsize, maxsize);
        ceo.getTaskHolder ().addTask (task);
        ui.tasklist.addRow (new String [] {task.getExpression (), "", startsize + "", "" + maxsize, "" + stepsize});
        ui.tasklist.setFunction (ui.tasklist.rowCount () - 1);
    }
}


-----Function Pair=209=-----=1=

public static void zipDir (File zipDir, ZipOutputStream zos, String path) {
    try {
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                zipDir (f, zos, path + f.getName () + "/");
            }
            else {
                FileInputStream fis = new FileInputStream (f);
                ZipEntry anEntry = new ZipEntry (path + f.getName ());
                zos.putNextEntry (anEntry);
                while ((bytesIn = fis.read (readBuffer)) != - 1) {
                    zos.write (readBuffer, 0, bytesIn);
                }
                fis.close ();
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private static final void toZip (ZipOutputStream out, File file, String path) throws IOException {
    if (file.isFile ()) {
        ZipEntry entry = new ZipEntry (path + file.getName ());
        out.putNextEntry (entry);
        BufferedInputStream origin = null;
        byte data [] = new byte [BUFFER];
        FileInputStream fi = new FileInputStream (file);
        origin = new BufferedInputStream (fi, BUFFER);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    else {
        File [] files = file.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            toZip (out, files [i], path + file.getName () + "/");
        }
    }
}


-----Function Pair=210=-----==

private void createZipFile (String profileName, ArrayList < String > fileList, String zipFileName) throws Exception {
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));
    FileInputStream in = null;
    try {
        for (String s : fileList) {
            byte [] tmpBuf = new byte [1024];
            in = new FileInputStream (s);
            String zipEntryName = cleanZipEntry (profileName, s);
            out.putNextEntry (new ZipEntry (zipEntryName));
            int len;
            while ((len = in.read (tmpBuf)) > 0) {
                out.write (tmpBuf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (Exception e) {
        MiscUtils.stackTrace2String (e);
        throw e;
    } finally {
        if (out != null) out.close ();
        if (in != null) in.close ();
    }
}


public static void gzCompress (File sourceFile) throws Exception {
    final int BUFFER_SIZE = 100000;
    if (sourceFile.getName ().endsWith (".gz")) {
    }
    else {
        File targetFile = new File (sourceFile.getAbsolutePath () + ".gz");
        FileInputStream fis = new FileInputStream (sourceFile);
        FileOutputStream fos = new FileOutputStream (targetFile);
        GZIPOutputStream gos = new GZIPOutputStream (new BufferedOutputStream (fos));
        BufferedInputStream bis = new BufferedInputStream (fis, BUFFER_SIZE);
        int count;
        byte data [] = new byte [BUFFER_SIZE];
        while ((count = bis.read (data, 0, BUFFER_SIZE)) != - 1) {
            gos.write (data, 0, count);
        }
        bis.close ();
        gos.close ();
    }
}


-----Function Pair=211=-----==

public static VectorEntity importFromFile (DBConnection dbcon, File file) throws Exception {
    ZipFile zipfile = new ZipFile (file);
    Enumeration entries = zipfile.entries ();
    VectorEntity entities = new VectorEntity ();
    if (entries.hasMoreElements ()) {
        ZipEntry entry = null;
        do {
            entry = entry = (ZipEntry) entries.nextElement ();
            File temp = File.createTempFile ("entity", "zip");
            Utils.readWrite (zipfile.getInputStream (entry), new FileOutputStream (temp));
            Properties prop = new Properties ();
            prop.load (new FileInputStream (temp));
            String enrty_name = entry.getName ();
            Entity entity = (Entity) (Class.forName (entry.getName ().substring (0, entry.getName ().lastIndexOf ("."))).newInstance ().getClass ().getConstructor (new Class [] {dbcon.getClass ()}).newInstance (new Object [] {dbcon}));
            entity.copyFromProperties (prop, new VectorField ());
            entities.add (entity);
            temp.delete ();
        }
        while (entries.hasMoreElements ());
    }
    return entities;
}


private String htmlDropMenu (HashMap < String, String > values, String name, String selected, String onChangeMessage) {
    String onChange = "";
    if (onChangeMessage.length () > 0) onChange = "onChange='alert(\"" + onChangeMessage + "\");'";
    String data = "<SELECT NAME='" + name + "'" + onChange + ">\n";
    String [] keys = (String []) values.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    for (int x = 0; x < keys.length; x ++) {
        String marker = "";
        if (keys [x].equals (selected)) marker = " selected";
        String value = (String) values.get (keys [x]);
        data += "<OPTION VALUE='" + keys [x] + "'" + marker + ">" + value + "</OPTION>\n";
    }
    data += "</SELECT>\n";
    return data;
}


-----Function Pair=212=-----==

String openingTag (Node n) {
    if (n.getNodeType () == Node.TEXT_NODE) return n.getTextContent ();
    String ret = "<" + n.getNodeName ();
    NamedNodeMap nnm = n.getAttributes ();
    if (nnm != null) {
        for (int i = 0; i < nnm.getLength (); i ++) {
            ret += " ";
            Node atr = nnm.item (i);
            if (atr.getUserData ("class") != null && atr.getNodeName ().equals ("style")) {
                ret += "class=\"" + atr.getUserData ("class") + "\"";
            }
            else {
                if (atr.getNodeName () != null) ret += atr.getNodeName ();
                String val = atr.getNodeValue ();
                if (val != null && val.trim ().length () > 0) {
                    ret += "=";
                    if (! val.startsWith ("\"")) val = "\"" + val;
                    if (! val.endsWith ("\"")) val = val + "\"";
                    ret += val;
                }
            }
        }
    }
    ret += ">";
    return ret;
}


File createJar (String name, String...entries) throws IOException {
    File jar = new File (name);
    OutputStream out = new FileOutputStream (jar);
    try {
        JarOutputStream jos = new JarOutputStream (out);
        for (String e : entries) {
            jos.putNextEntry (new ZipEntry (e));
            jos.write (e.getBytes ());
        }
        jos.close ();
    } finally {
        out.close ();
    }
    return jar;
}


-----Function Pair=213=-----==

private String detectProxy () {
    try {
        Vector ret = new Vector ();
        Class PluginProxyHandler = Class.forName ("sun.plugin.protocol.PluginProxyHandler");
        Method getDefaultProxyHandler = PluginProxyHandler.getMethod ("getDefaultProxyHandler", new Class [] {});
        Object proxyHandler = getDefaultProxyHandler.invoke (null, new Object [] {});
        Class ProxyHandler = Class.forName ("sun.plugin.protocol.ProxyHandler");
        Method getProxyInfo = ProxyHandler.getMethod ("getProxyInfo", new Class [] {URL.class});
        Object proxyInfo = getProxyInfo.invoke (proxyHandler, new Object [] {new URL ("http://localhost/Emanate/")});
        Class ProxyInfo = Class.forName ("sun.plugin.protocol.ProxyInfo");
        if (((Boolean) ProxyInfo.getMethod ("isProxyUsed", new Class [] {}).invoke (proxyInfo, new Object [] {})).booleanValue ()) return "http_proxy=" + (String) ProxyInfo.getMethod ("getProxy", new Class [] {}).invoke (proxyInfo, new Object [] {}) + ":" + ((Integer) ProxyInfo.getMethod ("getPort", new Class [] {}).invoke (proxyInfo, new Object [] {})).intValue ();
        if (((Boolean) ProxyInfo.getMethod ("isSocksUsed", new Class [] {}).invoke (proxyInfo, new Object [] {})).booleanValue ()) return "socks_proxy=" + (String) ProxyInfo.getMethod ("getSocksProxy", new Class [] {}).invoke (proxyInfo, new Object [] {}) + ":" + ((Integer) ProxyInfo.getMethod ("getSocksPort", new Class [] {}).invoke (proxyInfo, new Object [] {})).intValue ();
        return null;
    } catch (Throwable e) {
        log ("exception while querying sun.plugin.protocol.PluginProxyHandler: " + e);
        return null;
    }
}


public static void zippaInUnaCartella (String strPathOrigine, String strPathDestinazione, String strNomeFileZip, LinkedList < String > lNomi) throws Exception {
    try {
        File f = new File (strPathOrigine);
        File fList [] = f.listFiles ();
        FileOutputStream dest = new FileOutputStream (strPathDestinazione + "/" + strNomeFileZip);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        for (int i = 0; i < fList.length; i ++) {
            if (fList [i].isFile ()) {
                if (lNomi.contains (fList [i].getName ())) {
                    aggFile (out, strPathOrigine, fList [i].getName ());
                }
            }
        }
        out.close ();
        out = null;
        dest.close ();
        dest = null;
    } catch (Exception e) {
        new Exception ("\n zippaInUnaCartella  : " + e.getMessage ());
    }
}


-----Function Pair=214=-----==

public void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    try {
        logger.info (".doGet");
        if (null == request.getSession ().getAttribute (Constants.USER_KEY) || null == request.getParameter ("confID")) {
            logger.error ("user session not found or conf not specified.");
            return;
        }
        String strConfID = request.getParameter ("confID");
        if (! customerOwnsMeeting (getCustomerID (request), strConfID)) {
            throw new Exception ("Error: customer does not own meeting");
        }
        String strRecordingRoot = System.getProperty (PlaybackConstants.RECORDINGS_DIR_PROPERTY, PlaybackConstants.RECORDINGS_DIR_DEFAULT);
        File fileRecordingDir = new File (strRecordingRoot + "/" + strConfID);
        response.setContentType ("application/zip");
        response.setHeader ("Content-Disposition", "attachment; filename=" + PlaybackConstants.getArchiveForConf (strConfID));
        response.setHeader ("Pragma", "public");
        response.setHeader ("Cache-Control", "max-age=0");
        response.setHeader ("Cache-Control", "no-cache");
        response.setHeader ("Pragma", "no-cache");
        response.setDateHeader ("Expires", 0);
        File fileArchive = new File (fileRecordingDir.getAbsolutePath () + "/" + PlaybackConstants.getArchiveForConf (strConfID));
        logger.info ("length: " + fileArchive.length ());
        response.setContentLength ((int) fileArchive.length ());
        BufferedInputStream bis = new BufferedInputStream (new FileInputStream (fileArchive));
        OutputStream os = response.getOutputStream ();
        logger.info ("response.getOutputStream():" + os);
        IOUtil.copyStream (bis, os);
        os.flush ();
        os.close ();
        bis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void callGuards (Actor witness) {
    if (armageddon || inDungeon > 0) return;
    if (witness != null || (witness = findWitness (new Actor [1])) != null) witness.say (ItemNames.first_call_guards, ItemNames.last_call_guards);
    int gshape = getGuardShape (mainActor.getTileX (), mainActor.getTileY ());
    if (gshape < 0) {
        attackAvatar (0);
        return;
    }
    Tile actloc = new Tile (), dest = new Tile ();
    mainActor.getTile (actloc);
    dest.set (actloc.tx + 128, actloc.ty + 128, actloc.tz);
    MonsterActor guard = MonsterActor.create (gshape, dest);
    if (! MapChunk.findSpot (actloc, 5, guard.getShapeNum (), guard.getFrameNum (), 1)) {
        int dir = EUtil.getDirection (dest.ty - actloc.ty, actloc.tx - dest.tx);
        byte frames [] = new byte [2];
        frames [0] = (byte) guard.getDirFramenum (dir, Actor.standing);
        frames [1] = (byte) guard.getDirFramenum (dir, 3);
        ActorAction action = new ActorAction.Sequence (new ActorAction.Frames (frames, 2), new ActorAction.Usecode (0x625, guard, UsecodeMachine.double_click));
        Schedule.setActionSequence (guard, dest, action, true, 0);
    }
}


-----Function Pair=215=-----==

private void registerSubscription (String convID, String aclM) throws SQLException {
    Connection conn = getConnectionWrapper ().getConnection ();
    try {
        PreparedStatements pss = getPreparedStatements ();
        String base64Str = new String (Base64.encodeBase64 (aclM.getBytes ("US-ASCII")), "US-ASCII");
        pss.stm_insSubscription.setString (1, convID);
        pss.stm_insSubscription.setString (2, base64Str);
        pss.stm_insSubscription.execute ();
        conn.commit ();
    } catch (SQLException sqle) {
        try {
            conn.rollback ();
        } catch (SQLException se) {
            logger.log (Logger.SEVERE, "Rollback for incomplete subscription failed.", se);
        }
        throw sqle;
    } catch (Exception e) {
        logger.log (Logger.SEVERE, "Error encoding subscription message in Base64.", e);
        throw new SQLException ("Error encoding subscription message in Base64. " + e.getMessage ());
    }
}


private void newGroupPublicKeyNonRecursive (MembershipListObject ml) throws ContentEncodingException, IOException, InvalidKeyException, NoSuchAlgorithmException {
    PrincipalKeyDirectory oldPrivateKeyDirectory = privateKeyDirectory (_groupManager.getAccessManager ());
    oldPrivateKeyDirectory.waitForNoUpdates (SystemConfiguration.MEDIUM_TIMEOUT);
    Key oldPrivateKeyWrappingKey = oldPrivateKeyDirectory.getUnwrappedKey (null);
    if (null == oldPrivateKeyWrappingKey) {
        throw new AccessDeniedException ("Cannot update group membership, do not have access rights to private key for group " + friendlyName ());
    }
    else {
        stopPrivateKeyDirectoryEnumeration ();
    }
    Key privateKeyWrappingKey = createGroupPublicKey (ml);
    oldPrivateKeyDirectory.addSupersededByBlock (oldPrivateKeyWrappingKey, publicKeyName (), null, privateKeyWrappingKey);
    Link lr = new Link (_groupPublicKey.getVersionedName (), new LinkAuthenticator (new PublisherID (_handle.keyManager ().getDefaultKeyID ())));
    LinkObject precededByBlock = new LinkObject (PrincipalKeyDirectory.getPreviousKeyBlockName (publicKeyName ()), lr, SaveType.REPOSITORY, _handle);
    precededByBlock.save ();
}


-----Function Pair=216=-----==

public static < T > void shuffle3 (T [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        T tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public static String isNull (String s) {
    boolean nullValue = false;
    if (s == null) return "true";
    if (s.length () >= 4) {
        String str = s;
        do {
            boolean nullTest1 = str.indexOf ("&#0;") == 0;
            if (nullTest1) {
                if (str.length () > 4) str = str.substring (4);
                else str = new String ();
            }
            boolean nullTest2 = str.indexOf ("&#x0;") == 0;
            if (nullTest2) {
                if (str.length () > 5) str = str.substring (5);
                else str = new String ();
            }
            nullValue = nullTest1 || nullTest2;
        }
        while ((str.length () > 0) && nullValue);
    }
    else {
        byte v [] = s.getBytes ();
        if (v.length > 0) {
            nullValue = true;
            for (int i = 0; i < v.length; i ++) nullValue = nullValue && (v [i] == 0);
        }
    }
    return (nullValue ? "true" : "false");
}


-----Function Pair=217=-----==

public static Date getDateFormat (String date, int i) throws Exception {
    SimpleDateFormat simpledateformat = new SimpleDateFormat ();
    switch (i) {
        case 1 :
            simpledateformat.applyPattern ("yyyy-MM-dd");
            break;
        case 2 :
            simpledateformat.applyPattern ("yyyy-M-d");
            break;
        case 3 :
            simpledateformat.applyPattern ("yy-MM-dd");
            break;
        case 4 :
            simpledateformat.applyPattern ("yy-M-d");
            break;
        case 5 :
            simpledateformat.applyPattern ("yyyy-MM-dd HH:mm:ss");
            break;
        case 6 :
            simpledateformat.applyPattern ("yyyy-M-d H:m:s");
            break;
        case 7 :
            simpledateformat.applyPattern ("yy-MM-dd HH:mm:ss");
            break;
        case 8 :
            simpledateformat.applyPattern ("yy-M-d H:m:s");
            break;
        case 9 :
            simpledateformat.applyPattern ("yyyy");
            break;
        case 10 :
            simpledateformat.applyPattern ("yyyy-MM");
            break;
        case 11 :
            simpledateformat.applyPattern ("yyyyMMdd");
            break;
        case 12 :
            simpledateformat.applyPattern ("yyyyMM");
            break;
    }
    return simpledateformat.parse (date);
}


public static int [] getRightTimes (boolean isTime) {
    Calendar rightTime = Calendar.getInstance ();
    int time [];
    if (isTime) {
        time = new int [6];
        time [0] = rightTime.get (Calendar.YEAR);
        time [1] = rightTime.get (Calendar.MONTH) + 1;
        time [2] = rightTime.get (Calendar.DATE);
        time [3] = rightTime.get (Calendar.HOUR);
        time [4] = rightTime.get (Calendar.MINUTE);
        time [5] = rightTime.get (Calendar.SECOND);
    }
    else {
        time = new int [3];
        time [0] = rightTime.get (Calendar.YEAR);
        time [1] = rightTime.get (Calendar.MONTH) + 1;
        time [2] = rightTime.get (Calendar.DATE);
    }
    return time;
}


-----Function Pair=218=-----==

public void saveAs () {
    JFileChooser saveDialog = new JFileChooser (XMLFile);
    saveDialog.setFileFilter (new FileFilter () {
        public boolean accept (File f) {
            if (f != null) {
                if (f.isDirectory ()) {
                    return true;
                }
                String extention = getExtension (f);
                if (extention != null && extention.compareTo (new String ("xml")) == 0) {
                    return true;
                }
            }
            return false;
        } public String getDescription () {
            return new String ("XML Documents (.xml)");
        } private String getExtension (File f) {
            if (f != null) {
                String filename = f.getName ();
                int i = filename.lastIndexOf ('.');
                if (i > 0 && i < filename.length () - 1) {
                    return filename.substring (i + 1).toLowerCase ();
                }
            }
            return null;
        }
    }
    );
    int returnVal = saveDialog.showOpenDialog (view);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        DOMSerializer serializer = new DOMSerializer ((Boolean.valueOf (getProperty ("format.output"))).booleanValue ());
        try {
            File newFile = saveDialog.getSelectedFile ();
            serializer.serialize (document, newFile);
            jsXe.openXMLDocument (view, newFile);
        } catch (IOException ioe) {
            JOptionPane.showMessageDialog (view, ioe, "Write Error", JOptionPane.WARNING_MESSAGE);
        }
    }
}


private String getAnnotation (final Class < ? extends TestCase > testClass, final String testName, final String annotationName) {
    try {
        Method testMethod = testClass.getMethod (testName, (Class []) null);
        Annotation [] annotations = testMethod.getAnnotations ();
        for (Annotation annot : annotations) {
            if (annot.annotationType ().getName ().equals (annotationName)) {
                String annotStr = annot.toString ();
                String knownFailure = null;
                if (annotStr.contains ("(value=")) {
                    knownFailure = annotStr.substring (annotStr.indexOf ("=") + 1, annotStr.length () - 1);
                }
                if (knownFailure == null) {
                    knownFailure = "true";
                }
                return knownFailure;
            }
        }
    } catch (java.lang.NoSuchMethodException e) {
    }
    return null;
}


-----Function Pair=219=-----==

public static String readLine (InputStream input) {
    String result = "";
    int c;
    try {
        while ((c = input.read ()) != '\n') if (c == - 1) return null;
        result += (char) c;
        while ((c = input.read ()) != '\r') {
            if (c == - 1) return null;
            else result += (char) c;
        }
        result += "\r";
    } catch (IOException x) {
        return null;
    }
    return result;
}


private void initResult () {
    try {
        for (int i = 0; i < NUM_TRANSFORMATIONS; i ++) {
            switch (RESULT_FLAVOR) {
                case STREAM :
                    OutputStream outStream = new FileOutputStream (FILE_OUT_BASE + "thread_" + m_thrdNum + "_transformation_" + i + FILE_OUT_EXT);
                    m_outResult [i] = new StreamResult (outStream);
                    break;
                case SAX :
                    DefaultHandler defaultHandler = new DefaultHandler ();
                    m_outResult [i] = new SAXResult (defaultHandler);
                    break;
                case DOM :
                    m_outResult [i] = new DOMResult ();
                    break;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=220=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=221=-----==

public void doListInstruction (String command, String [] args) {
    int count;
    int addr = - 1;
    try {
        switch (args.length) {
            case 0 :
                addr = user.reg.currentIP ();
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            case 1 :
                addr = parseHex32 (args [0]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            default :
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, count));
                break;
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad address: " + args [0]);
    }
}


public void doThread (String command, String [] args) {
    int threadID, threadPointer;
    try {
        switch (args.length) {
            case 0 :
                threadID = user.reg.threadPointerToIndex (user.reg.hardwareTP ());
                jdp_console.writeOutput ("context of executing thread: " + threadID);
                user.reg.setContextThreadID (threadID);
                break;
            case 1 :
                if (args [0].equalsIgnoreCase ("off")) {
                    user.reg.setContextThreadID (0);
                }
                else {
                    threadID = Integer.parseInt (args [0]);
                    user.reg.setContextThreadID (threadID);
                }
                break;
            default :
                printHelp (command);
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("invalid thread ID");
    } catch (Exception e1) {
        jdp_console.writeOutput (e1.getMessage ());
    }
}


-----Function Pair=222=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=223=-----==

public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=224=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=225=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=226=-----==

public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


-----Function Pair=227=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=228=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=229=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


-----Function Pair=230=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=231=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=232=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=233=-----==

public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=234=-----==

public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=235=-----==

public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


-----Function Pair=236=-----==

public void test82 () throws Exception {
    StringBuilder holder = new StringBuilder (200010);
    for (int i = 0; i < 100000; i ++) {
        holder.append ("a,");
    }
    holder.append ("a");
    CsvReader reader = CsvReader.parse (holder.toString ());
    try {
        reader.readRecord ();
    } catch (Exception ex) {
        assertException (new IOException ("Maximum column count of 100,000 exceeded in record 0. Set the SafetySwitch property to false if you're expecting more than 100,000 columns per record to avoid this error."), ex);
    }
    reader.close ();
}


public void test82 () throws Exception {
    StringBuilder holder = new StringBuilder (200010);
    for (int i = 0; i < 100000; i ++) {
        holder.append ("a,");
    }
    holder.append ("a");
    CsvReader reader = CsvReader.parse (holder.toString ());
    try {
        reader.readRecord ();
    } catch (Exception ex) {
        assertException (new IOException ("Maximum column count of 100,000 exceeded in record 0. Set the SafetySwitch property to false if you're expecting more than 100,000 columns per record to avoid this error."), ex);
    }
    reader.close ();
}


-----Function Pair=237=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=238=-----==

public static void main (String args []) {
    if (args.length != 2) {
        String u = "Usage: java -cp . UpgradeRomizedProperties <infile> <outfile>";
        System.out.println (u);
        System.exit (0);
    }
    Runtime rt = Runtime.getRuntime ();
    String cmd = "javac -d " + System.getProperty ("user.dir") + " " + args [0];
    int exitCode;
    try {
        Process p = rt.exec (cmd);
        exitCode = p.waitFor ();
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    Hashtable rp = new Hashtable ();
    Object [] argz = {rp};
    try {
        String cn = "com.sun.midp.chameleon.skins.resources.RomizedProperties";
        Class clazz = Class.forName (cn);
        Method loadProperties;
        loadProperties = clazz.getMethod ("load", new Class [] {Hashtable.class});
        loadProperties.invoke (null, argz);
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    Converter converter = new Converter (SkinProperty.properties, rp);
    converter.convert ();
    try {
        FileOutputStream fout = new FileOutputStream (args [1]);
        OutputStreamWriter w = new OutputStreamWriter (fout);
        writer = new PrintWriter (w);
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    printHeader ();
    printSkinProperties ();
    printFooter ();
    writer.close ();
    reportUnknownProperties (converter.unknownProps);
    reportMissingProperties (converter.missingProps);
}


public static void main (String [] args) {
    try {
        EventHeap eh = null;
        String svcName = "foobar";
        String [] svcIFs = new String [] {"amiba.samples.C"};
        String mySvcIF = "amiba.samples.A";
        ProxyManagerImpl pm = new ProxyManagerImpl ();
        pm.init ("repository.pdom", "HTTP", "http://iw-file.stanford.edu:8080/servlet/gd");
        System.out.println ("Initted proxy manager");
        System.out.println ("Requesting a proxy ..");
        SProxy spxy = pm.getSProxy (mySvcIF, svcIFs);
        System.out.println ("Obtained a proxy, instantiating ..");
        Proxy pxy = spxy.instantiate ();
        pxy.init (eh, svcName);
        pxy.setDModel (new ADModel ());
        Stub tester = pxy.getTester ();
        System.out.println ("Invoking a(17) in test mode .. \n\n");
        Method ameth = A.class.getDeclaredMethod ("a", new Class [] {Integer.TYPE});
        DegradeOptions d = tester.test (ameth, new Object [] {new Integer (17)});
        if (d == null) {
            System.out.println ("\n\n17 not supported! No degradation choices ..");
        }
        else if (d.fullySupported ()) {
            System.out.println ("\n\n17 supported!");
        }
        else {
            System.out.println ("\n\n17 not supported!");
            Vector v = d.getDegradedCalls ();
            if (v == null || v.size () == 0) {
                System.out.println ("No degraded call supported!");
            }
            else {
                System.out.println ("Degradation choices:");
                for (int i = 0; i < v.size (); i ++) {
                    System.out.println (Arrays.asList ((Object []) v.elementAt (i)));
                }
            }
        }
        System.out.println ("Invoking a(16) in regular mode .. ");
        A a = (A) pxy.getInvoker ();
        System.out.println (a.a (16));
        System.exit (1);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=239=-----==

public void logout () {
    int size = applications.size ();
    String applicationnames [] = new String [size];
    Enumeration e = applications.keys ();
    int n = 0;
    while (e.hasMoreElements ()) {
        applicationnames [n] = (String) e.nextElement ();
        n ++;
    }
    for (int t = 0; t < size; t ++) {
        if (! applicationnames [t].equals ("system")) {
            StringTokenizer temppi = new StringTokenizer (applicationnames [t]);
            stop (temppi.nextToken (), temppi.nextToken ());
        }
    }
    si.disconnect ();
}


public static void main (String [] args) {
    final String version = System.getProperty ("java.version");
    if (version.startsWith ("1.0") || version.startsWith ("1.1") || version.startsWith ("1.2")) {
        System.err.println ("");
        System.err.print ("J requires Java 1.3 or later.");
        System.err.println (" (Java 1.4.1 is recommended.)");
        System.err.println ("");
        System.exit (1);
    }
    try {
        Class c = Class.forName ("org.armedbear.j.Editor");
        Class [] parameterTypes = new Class [1];
        parameterTypes [0] = String [].class;
        Method method = c.getMethod ("main", parameterTypes);
        Object [] parameters = new Object [1];
        parameters [0] = args;
        method.invoke (null, parameters);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=240=-----==

public static void main (String [] args) {
    MuServer s = new MuServer ();
    new mucode.util.Launcher (s).launch (args, 1);
    ClassSpace shared = s.getSharedClassSpace ();
    try {
        System.out.println ("I need " + CLASSNAME + ".class to proceed with execution.");
        System.out.println ("I'll look on my host, until it comes...");
        Thread.sleep (1000);
        while (! shared.containsClass (CLASSNAME)) {
            Thread.sleep (3000);
            System.out.println ("Waiting for the class ...");
        }
        System.out.println ("Class " + CLASSNAME + " is now in my shared class space.");
        Class c = shared.getClass (CLASSNAME);
        c.getMethod ("perform", null).invoke (c.newInstance (), null);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=241=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=242=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=243=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=244=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=245=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=246=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=247=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=248=-----==

public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


-----Function Pair=249=-----==

public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=250=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=251=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


-----Function Pair=252=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=253=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=254=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


-----Function Pair=255=-----==

public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=256=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=257=-----==

public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test138 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=258=-----=1=

private boolean mouseSecure () throws Exception {
    if (! mouseSecurity) {
        return true;
    }
    Class mouseInfoClass;
    Class pointerInfoClass;
    try {
        mouseInfoClass = Class.forName ("java.awt.MouseInfo");
        pointerInfoClass = Class.forName ("java.awt.PointerInfo");
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        return true;
    }
    Method getPointerInfo = mouseInfoClass.getMethod ("getPointerInfo", new Class [0]);
    Method getLocation = pointerInfoClass.getMethod ("getLocation", new Class [0]);
    Object pointer = null;
    try {
        pointer = getPointerInfo.invoke (pointerInfoClass, new Object [0]);
    } catch (java.lang.reflect.InvocationTargetException e) {
        e.getTargetException ().printStackTrace ();
    }
    Point mousePosition = (Point) (getLocation.invoke (pointer, new Object [0]));
    return mousePosition.x >= docScreenX && mousePosition.x <= docScreenXMax && mousePosition.y >= docScreenY && mousePosition.y <= docScreenYMax;
}


public static void main (String [] argv) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, (Object []) noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


-----Function Pair=259=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=260=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


-----Function Pair=261=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=262=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=263=-----==

public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=264=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=265=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=266=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=267=-----==

public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=268=-----==

public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=269=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=270=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=271=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=272=-----==

private void initComponents () {
    setBorder (new LineBorder (Color.black, 1, false));
    setLayout (new FormLayout (new ColumnSpec [] {ColumnSpec.decode ("30px"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("120px"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("49dlu"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("230px"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("120px"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("77px"), FormFactory.RELATED_GAP_COLSPEC, ColumnSpec.decode ("66dlu")}, new RowSpec [] {FormFactory.DEFAULT_ROWSPEC, FormFactory.RELATED_GAP_ROWSPEC, RowSpec.decode ("30dlu"), FormFactory.DEFAULT_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.RELATED_GAP_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.RELATED_GAP_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.RELATED_GAP_ROWSPEC, FormFactory.DEFAULT_ROWSPEC, FormFactory.RELATED_GAP_ROWSPEC}));
    checkBox = new JCheckBox ();
    checkBox.setVisible (edit);
    add (checkBox, new CellConstraints (1, 1, 1, 13));
    final JLabel logoLabel = new JLabel ();
    logoLabel.setIcon (UIHelper.getImage (AdminInterfacesFactory.getCALogoSelector ().getLogo (currentCAStatusAnalyser.getCAInfoVO ())));
    add (logoLabel, new CellConstraints (3, 3));
    final JLabel cANameLabel = new JLabel ();
    cANameLabel.setText (currentCAStatusAnalyser.getCAInfoVO ().getCAName ());
    cANameLabel.setFont (UIHelper.getFont ("Label.font.bold"));
    add (cANameLabel, new CellConstraints (5, 3, 7, 1));
    final JLabel subjectLabel = new JLabel ();
    subjectLabel.setText (UIHelper.getText ("adminca.subject") + ":");
    add (subjectLabel, new CellConstraints (3, 4));
    final JLabel issuerLabel = new JLabel ();
    issuerLabel.setText (UIHelper.getText ("adminca.issuer") + ":");
    add (issuerLabel, new CellConstraints (3, 5));
    final JLabel caIdLabel = new JLabel ();
    caIdLabel.setText (UIHelper.getText ("adminca.caid") + ":");
    add (caIdLabel, new CellConstraints (3, 7));
    final JLabel subjectField = new JLabel ();
    subjectField.setText (currentCAStatusAnalyser.getSubject ());
    add (subjectField, new CellConstraints (5, 4, 9, 1));
    final JLabel issuerField = new JLabel ();
    issuerField.setText (currentCAStatusAnalyser.getIssuer ());
    add (issuerField, new CellConstraints (5, 5, 9, 1));
    final JLabel caIdField = new JLabel ();
    caIdField.setText ("" + currentCAStatusAnalyser.getCAInfoVO ().getCAId ());
    add (caIdField, new CellConstraints (5, 7, 3, 1));
    final JLabel cAStatuslabel = new JLabel ();
    cAStatuslabel.setText (UIHelper.getText ("adminstatus.status") + ":");
    add (cAStatuslabel, new CellConstraints (3, 8));
    cAStatusField = new JLabel ();
    cAStatusField.setText (AdminUIUtils.getCAStatusTranslated (currentCAStatusAnalyser.getCAInfoVO ().getCAStatus ()));
    add (cAStatusField, new CellConstraints (5, 8, 3, 1));
    final JLabel cATokenStatuslabel = new JLabel ();
    cATokenStatuslabel.setText (UIHelper.getText ("adminstatus.catokenstatus") + ":");
    add (cATokenStatuslabel, new CellConstraints (3, 10));
    final CATokenStatusTablePanel tokenStatusTablePanel = new CATokenStatusTablePanel (cAId);
    add (tokenStatusTablePanel, new CellConstraints (3, 11, 9, 1));
    final JLabel validFromLabel = new JLabel ();
    validFromLabel.setText (UIHelper.getText ("adminca.validfrom") + ":");
    add (validFromLabel, new CellConstraints (9, 7));
    final JLabel validToLabel = new JLabel ();
    validToLabel.setText (UIHelper.getText ("adminca.validto") + ":");
    add (validToLabel, new CellConstraints (9, 8));
    final JButton viewCACertButton = new JButton ();
    viewCACertButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent e) {
            OpenOrSaveCertDialog d = new OpenOrSaveCertDialog (currentCAStatusAnalyser.getCACertificate (), (Window) SwingUtilities.getRoot (thisPanel));
            d.setLocationRelativeTo (SwingUtilities.getRootPane (thisPanel));
            d.setVisible (true);
        }
    }
    );
    viewCACertButton.setIcon (UIHelper.getImage ("cert_view.gif"));
    viewCACertButton.setText (UIHelper.getText ("investigatecard.viewcert"));
    viewCACertButton.setVisible (CommonUtils.isDesktopSupported ());
    viewCACertButton.setEnabled (currentCAStatusAnalyser.getCACertificate () != null);
    add (viewCACertButton, new CellConstraints (7, 13));
    final JLabel validFromField = new JLabel ();
    validFromField.setText (currentCAStatusAnalyser.getCACertificate ().getNotBefore ().toString ());
    add (validFromField, new CellConstraints (11, 7, 3, 1));
    final JLabel validToField = new JLabel ();
    validToField.setText (currentCAStatusAnalyser.getCACertificate ().getNotAfter ().toString ());
    add (validToField, new CellConstraints (11, 8, 3, 1));
    final JButton getCRLButton = new JButton ();
    getCRLButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent e) {
            try {
                X509CRL crl = AdminInterfacesFactory.getCAManager ().getLastCRL (currentCAStatusAnalyser.getCAInfoVO ().getCAId ());
                if (crl == null) {
                    displayEmtpyCRLWarning ();
                }
                else {
                    OpenOrSaveCRLDialog d = new OpenOrSaveCRLDialog (crl, (Window) SwingUtilities.getRoot (thisPanel));
                    d.setLocationRelativeTo (SwingUtilities.getRootPane (thisPanel));
                    d.setVisible (true);
                }
            } catch (IOException e1) {
                LocalLog.getLogger ().log (Level.SEVERE, "Error occured when fetching CRL : " + e1.getMessage (), e1);
                AdminUIUtils.showErrorMsg ("adminca.errorfetchingcrl", thisPanel);
            } catch (AuthorizationDeniedException_Exception e1) {
                LocalLog.getLogger ().log (Level.SEVERE, "Error occured when fetching CRL : " + e1.getMessage (), e1);
                AdminUIUtils.showErrorMsg ("adminca.errorfetchingcrl", thisPanel);
            }
        }
    }
    );
    getCRLButton.setIcon (UIHelper.getImage ("crl.gif"));
    getCRLButton.setText (UIHelper.getText ("adminca.fetchcrl"));
    add (getCRLButton, new CellConstraints (9, 13, 3, 1, CellConstraints.FILL, CellConstraints.FILL));
}


private void initComponents () {
    javax.swing.JLabel appTitleLabel = new javax.swing.JLabel ();
    javax.swing.JLabel appDescLabel = new javax.swing.JLabel ();
    closeButton = new javax.swing.JButton ();
    javax.swing.JLabel versionLabel = new javax.swing.JLabel ();
    javax.swing.JLabel vendorLabel = new javax.swing.JLabel ();
    javax.swing.JLabel homepageLabel = new javax.swing.JLabel ();
    javax.swing.JLabel licenseLabel = new javax.swing.JLabel ();
    javax.swing.JLabel appLicenseLabel = new javax.swing.JLabel ();
    javax.swing.JLabel appVersionLabel = new javax.swing.JLabel ();
    javax.swing.JLabel appVendorLabel = new javax.swing.JLabel ();
    javax.swing.JLabel appHomepageLabel = new javax.swing.JLabel ();
    parserLabel = new javax.swing.JLabel ();
    parserLabelText = new javax.swing.JLabel ();
    jSeparator1 = new javax.swing.JSeparator ();
    parserlicenseLabel = new javax.swing.JLabel ();
    javax.swing.JLabel parserLicenceText = new javax.swing.JLabel ();
    setDefaultCloseOperation (javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
    java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle ("solowiki/resources/SoloWikiAboutBox");
    setTitle (bundle.getString ("title"));
    setLocationByPlatform (true);
    setResizable (false);
    appTitleLabel.setFont (appTitleLabel.getFont ().deriveFont (appTitleLabel.getFont ().getStyle () | java.awt.Font.BOLD, appTitleLabel.getFont ().getSize () + 4));
    java.util.ResourceBundle bundle1 = java.util.ResourceBundle.getBundle ("solowiki/resources/SoloWikiApp");
    appTitleLabel.setText (bundle1.getString ("Application.name"));
    appDescLabel.setText (bundle.getString ("appDescLabel.text"));
    closeButton.setText (bundle.getString ("closeAboutBox.Action.text"));
    closeButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            closeButton (evt);
        }
    }
    );
    versionLabel.setFont (versionLabel.getFont ().deriveFont (versionLabel.getFont ().getStyle () | java.awt.Font.BOLD));
    versionLabel.setText (bundle.getString ("versionLabel.text"));
    vendorLabel.setFont (vendorLabel.getFont ().deriveFont (vendorLabel.getFont ().getStyle () | java.awt.Font.BOLD));
    vendorLabel.setText (bundle.getString ("vendorLabel.text"));
    homepageLabel.setFont (homepageLabel.getFont ().deriveFont (homepageLabel.getFont ().getStyle () | java.awt.Font.BOLD));
    homepageLabel.setText (bundle.getString ("homepageLabel.text"));
    licenseLabel.setFont (licenseLabel.getFont ().deriveFont (licenseLabel.getFont ().getStyle () | java.awt.Font.BOLD));
    licenseLabel.setText (bundle.getString ("licenseLabel.text"));
    appLicenseLabel.setText (bundle.getString ("appLicenseLabel.text"));
    appLicenseLabel.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (java.awt.event.MouseEvent evt) {
            openWebsite (evt);
        }
    }
    );
    appVersionLabel.setText (bundle1.getString ("Application.version"));
    appVendorLabel.setText (bundle1.getString ("Application.vendor"));
    appHomepageLabel.setText (bundle1.getString ("Application.homepage"));
    appHomepageLabel.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (java.awt.event.MouseEvent evt) {
            openWebsite (evt);
        }
    }
    );
    parserLabel.setFont (new java.awt.Font ("Tahoma", 1, 11));
    parserLabel.setText (bundle.getString ("parserlabel"));
    parserLabelText.setText (bundle.getString ("parserlabel.text"));
    parserLabelText.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (java.awt.event.MouseEvent evt) {
            openWebsite (evt);
        }
    }
    );
    parserlicenseLabel.setFont (new java.awt.Font ("Tahoma", 1, 11));
    parserlicenseLabel.setText (bundle.getString ("licenseLabel.text"));
    parserLicenceText.setText (bundle.getString ("parserLicenseLabel.text"));
    parserLicenceText.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (java.awt.event.MouseEvent evt) {
            openWebsite (evt);
        }
    }
    );
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout (getContentPane ());
    getContentPane ().setLayout (layout);
    layout.setHorizontalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (layout.createSequentialGroup ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (layout.createSequentialGroup ().addContainerGap ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (appTitleLabel).addComponent (appDescLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 289, Short.MAX_VALUE).addGroup (layout.createSequentialGroup ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (versionLabel).addComponent (vendorLabel).addComponent (homepageLabel).addComponent (licenseLabel)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (appVersionLabel).addComponent (appVendorLabel).addComponent (appLicenseLabel).addComponent (appHomepageLabel)).addGap (16, 16, 16)))).addGroup (layout.createSequentialGroup ().addGap (120, 120, 120).addComponent (closeButton)).addGroup (layout.createSequentialGroup ().addContainerGap ().addComponent (jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 289, Short.MAX_VALUE)).addGroup (layout.createSequentialGroup ().addContainerGap ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (parserLabel).addComponent (parserlicenseLabel)).addGap (23, 23, 23).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (parserLicenceText).addComponent (parserLabelText)))).addContainerGap ()));
    layout.setVerticalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (layout.createSequentialGroup ().addContainerGap ().addComponent (appTitleLabel).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent (appDescLabel).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (versionLabel).addComponent (appVersionLabel)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (vendorLabel).addComponent (appVendorLabel)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (homepageLabel).addComponent (appHomepageLabel)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (licenseLabel).addComponent (appLicenseLabel)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent (jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (parserLabel).addComponent (parserLabelText)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (parserlicenseLabel).addComponent (parserLicenceText)).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (closeButton).addContainerGap ()));
    pack ();
}


-----Function Pair=273=-----==

public static Object [] getArgsWithVarArgs (Method m, Object [] args) {
    Class < ? > [] params = m.getParameterTypes ();
    int nParams = params.length;
    boolean hasVarArgs = nParams > 0 && params [nParams - 1].isArray ();
    if (! hasVarArgs) return args;
    Object [] ret = new Object [params.length];
    System.arraycopy (args, 0, ret, 0, nParams - 1);
    int nVarArgs = args.length - (nParams - 1);
    Object varArgs = Array.newInstance (params [nParams - 1].getComponentType (), nVarArgs);
    for (int i = 0; i < nVarArgs; i ++) {
        Array.set (varArgs, i, args [nParams - 1 + i]);
    }
    ret [nParams - 1] = varArgs;
    return ret;
}


private static Object invokeMethod (Method m, Object target, Object [] args) throws Exception {
    try {
        return m.invoke (target, args);
    } catch (IllegalAccessException ex) {
        String mName = m.getName ();
        Class [] pTypes = m.getParameterTypes ();
        Class currClass = target.getClass ();
        while (currClass != null) {
            try {
                Method meth = currClass.getMethod (mName, pTypes);
                if (! meth.equals (m)) {
                    return meth.invoke (target, args);
                }
            } catch (NoSuchMethodException ex2) {
            } catch (IllegalAccessException ex2) {
            }
            Class [] ifaceList = currClass.getInterfaces ();
            for (int i = 0; i < ifaceList.length; i ++) {
                try {
                    Method meth = ifaceList [i].getMethod (mName, pTypes);
                    return meth.invoke (target, args);
                } catch (NoSuchMethodException ex2) {
                } catch (IllegalAccessException ex2) {
                }
            }
            currClass = currClass.getSuperclass ();
        }
        throw ex;
    }
}


-----Function Pair=274=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=275=-----==

public Object [] getValues (String fieldName) throws NoSuchFieldException {
    Field field = (Field) form.getFields ().get (fieldName);
    if (field == null) {
        throw new NoSuchFieldException ("No field named '" + fieldName + "'");
    }
    Object [] values = parseAndValidate (field, input.get (fieldName));
    if (field.getValueClass ().isPrimitive ()) {
        if (values != null) {
            for (int i = 0; i < values.length; i ++) {
                if (values [i] == null) {
                    values [i] = DynaBeanUtils.getNullValueForPrimitive (field.getValueClass ());
                }
            }
        }
    }
    return values;
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=276=-----==

private int getNestedPropertySeparatorIndex (String propertyPath, boolean last) {
    boolean inKey = false;
    int i = (last ? propertyPath.length () - 1 : 0);
    while ((last && i >= 0) || i < propertyPath.length ()) {
        switch (propertyPath.charAt (i)) {
            case PROPERTY_KEY_PREFIX_CHAR :
            case PROPERTY_KEY_SUFFIX_CHAR :
                inKey = ! inKey;
                break;
            case NESTED_PROPERTY_SEPARATOR_CHAR :
                if (! inKey) {
                    return i;
                }
        }
        if (last) i --;
        else i ++;
    }
    return - 1;
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=277=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=278=-----==

public static void recursiveDelete (File file, boolean childrenOnly, FileFilter filter) {
    if (file.isDirectory ()) {
        File [] children = file.listFiles ();
        if (children != null) {
            for (int i = 0; i < children.length; i ++) {
                recursiveDelete (children [i], false, filter);
            }
        }
        if (childrenOnly) {
            return;
        }
    }
    if (filter == null || filter.accept (file)) {
        file.delete ();
    }
}


public static < T > T [] concat (@NotNull
final T []...a) {
    int ns = 0;
    for (final T [] anA : a) {
        if (anA != null) {
            ns += anA.length;
        }
    }
    final T [] na = (T []) Array.newInstance (a [0].getClass ().getComponentType (), ns);
    int np = 0;
    for (final T [] anA : a) {
        System.arraycopy (anA, 0, na, np, anA.length);
        np += anA.length;
    }
    assert ns == np;
    return na;
}


-----Function Pair=279=-----=1=

public void encodePassword (File fromFile, File toFile, char [] password) {
    PBEKeySpec pbeKeySpec;
    PBEParameterSpec pbeParamSpec;
    SecretKeyFactory keyFac;
    SecretKey pbeKey;
    Cipher pbeCipher = null;
    byte [] salt = {(byte) 0xc7, (byte) 0x73, (byte) 0x21, (byte) 0x8c, (byte) 0x7e, (byte) 0xc8, (byte) 0xee, (byte) 0x99};
    int count = 20;
    pbeParamSpec = new PBEParameterSpec (salt, count);
    pbeKeySpec = new PBEKeySpec (password);
    try {
        keyFac = SecretKeyFactory.getInstance ("PBEWithMD5AndDES");
        pbeKey = keyFac.generateSecret (pbeKeySpec);
        pbeCipher = Cipher.getInstance ("PBEWithMD5AndDES");
        pbeCipher.init (Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);
    } catch (Exception e) {
        e.printStackTrace ();
        return;
    }
    InputStream in = null;
    OutputStream out = null;
    try {
        in = new BufferedInputStream (new FileInputStream (fromFile));
        out = new CipherOutputStream (new BufferedOutputStream (new FileOutputStream (toFile)), pbeCipher);
        byte [] rbuffer = new byte [2056];
        int rcount = in.read (rbuffer);
        while (rcount > 0) {
            out.write (rbuffer, 0, rcount);
            rcount = in.read (rbuffer);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (IOException ioe) {
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException ioe) {
            }
        }
    }
    System.out.println ("Success: " + toFile.getName () + " generated.");
}


public void doPost (HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws ServletException, IOException {
    try {
        httpServletResponse.setStatus (200);
        for (int i = 0; i < APJP_REMOTE_HTTPS_SERVER_RESPONSE_PROPERTY_KEY.length; i = i + 1) {
            if (APJP_REMOTE_HTTPS_SERVER_RESPONSE_PROPERTY_KEY [i].equalsIgnoreCase ("") == false) {
                httpServletResponse.addHeader (APJP_REMOTE_HTTPS_SERVER_RESPONSE_PROPERTY_KEY [i], APJP_REMOTE_HTTPS_SERVER_RESPONSE_PROPERTY_VALUE [i]);
            }
        }
        SecretKeySpec secretKeySpec = new SecretKeySpec (APJP_KEY.getBytes (), "ARCFOUR");
        Cipher inputStreamCipher = Cipher.getInstance ("ARCFOUR");
        inputStreamCipher.init (Cipher.DECRYPT_MODE, secretKeySpec);
        CipherInputStream httpRequestInputStream = new CipherInputStream (httpServletRequest.getInputStream (), inputStreamCipher);
        Cipher outputStreamCipher = Cipher.getInstance ("ARCFOUR");
        outputStreamCipher.init (Cipher.ENCRYPT_MODE, secretKeySpec);
        CipherOutputStream httpResponseOutputStream = new CipherOutputStream (httpServletResponse.getOutputStream (), outputStreamCipher);
        HTTPRequestMessage httpRequestMessage1 = new HTTPRequestMessage (httpRequestInputStream);
        httpRequestMessage1.read ();
        HTTPSRequest httpsRequest1 = new HTTPSRequest (httpRequestMessage1);
        httpsRequest1.open ();
        try {
            HTTPResponseMessage httpResponseMessage1 = httpsRequest1.getHTTPResponseMessage ();
            HTTPMessageHeader [] httpResponseMessage1Headers1 = httpResponseMessage1.getHTTPMessageHeaders ();
            HTTPMessageHeader httpResponseMessage1Header1 = httpResponseMessage1Headers1 [0];
            String httpResponseMessage1Header1Key1 = httpResponseMessage1Header1.getKey ();
            String httpResponseMessage1Header1Value1 = httpResponseMessage1Header1.getValue ();
            httpResponseOutputStream.write ((httpResponseMessage1Header1Value1 + "\r\n").getBytes ());
            for (int i = 1; i < httpResponseMessage1Headers1.length; i = i + 1) {
                httpResponseMessage1Header1 = httpResponseMessage1Headers1 [i];
                httpResponseMessage1Header1Key1 = httpResponseMessage1Header1.getKey ();
                httpResponseMessage1Header1Value1 = httpResponseMessage1Header1.getValue ();
                httpResponseOutputStream.write ((httpResponseMessage1Header1Key1 + ": " + httpResponseMessage1Header1Value1 + "\r\n").getBytes ());
            }
            httpResponseOutputStream.write (("\r\n").getBytes ());
            httpResponseMessage1.read (httpResponseOutputStream);
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                httpsRequest1.close ();
            } catch (Exception e) {
            }
        }
    } catch (Exception e) {
        logger.log (Level.INFO, "EXCEPTION", e);
        httpServletResponse.setStatus (500);
    }
}


-----Function Pair=280=-----=1=

public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


public static void WritePrivateKey (PrivateKey keys, String pwd) {
    try {
        byte key [] = pwd.getBytes ();
        DESKeySpec desKeySpec = new DESKeySpec (key);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance ("DES");
        SecretKey secretKey = keyFactory.generateSecret (desKeySpec);
        Cipher desCipher = Cipher.getInstance ("DES/ECB/PKCS5Padding");
        desCipher.init (Cipher.ENCRYPT_MODE, secretKey);
        FileOutputStream fos = new FileOutputStream ("privateKey.data");
        BufferedOutputStream bos = new BufferedOutputStream (fos);
        CipherOutputStream cos = new CipherOutputStream (bos, desCipher);
        ObjectOutputStream oos = new ObjectOutputStream (cos);
        oos.writeObject (keys);
        oos.flush ();
        oos.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (InvalidKeyException e) {
        e.printStackTrace ();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace ();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace ();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=281=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=282=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=283=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=284=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=285=-----==

private void createShadowBorder () {
    fBackgroundImage = new BufferedImage (getWidth () + SHADOW_WIDTH, getHeight () + SHADOW_WIDTH, BufferedImage.TYPE_INT_ARGB);
    Graphics2D g2 = (Graphics2D) fBackgroundImage.getGraphics ();
    try {
        Robot robot = new Robot (getGraphicsConfiguration ().getDevice ());
        BufferedImage capture = robot.createScreenCapture (new Rectangle (getX (), getY (), getWidth () + SHADOW_WIDTH, getHeight () + SHADOW_WIDTH));
        g2.drawImage (capture, null, 0, 0);
    } catch (AWTException e) {
        e.printStackTrace ();
    }
    BufferedImage shadow = new BufferedImage (getWidth () + SHADOW_WIDTH, getHeight () + SHADOW_WIDTH, BufferedImage.TYPE_INT_ARGB);
    Graphics graphics = shadow.getGraphics ();
    graphics.setColor (new Color (0.0f, 0.0f, 0.0f, 0.3f));
    graphics.fillRect (SHADOW_WIDTH / 2, SHADOW_WIDTH / 2, getWidth (), getHeight ());
    g2.drawImage (shadow, getBlurOp (SHADOW_WIDTH / 2), 0, 0);
    if (fImage != null) {
        g2.drawImage (fImage, 0, 0, null);
    }
}


public static void type (String text) {
    int saveAutoDelayForKeys = autoDelayForKeys;
    autoDelayForKeys = 0;
    char [] c = nlOrTab (text).toCharArray ();
    for (int i = 0; i < c.length; i ++) {
        int key = c [i];
        if (key >= 'a' && key <= 'z') keyPress (key - 'a' + 'A');
        else if (key >= 'A' && key <= 'Z') shiftKeyPress (key);
        else if (key >= '0' && key <= '9') keyPress (key);
        else {
            switch (key) {
                case '\n' :
                    keyPress (KeyEvent.VK_ENTER);
                    break;
                case '\t' :
                    keyPress (KeyEvent.VK_TAB);
                    break;
                case '`' :
                    keyPress (KeyEvent.VK_BACK_QUOTE);
                    break;
                case '-' :
                    keyPress (KeyEvent.VK_MINUS);
                    break;
                case '=' :
                    keyPress (KeyEvent.VK_EQUALS);
                    break;
                case '[' :
                    keyPress (KeyEvent.VK_OPEN_BRACKET);
                    break;
                case ']' :
                    keyPress (KeyEvent.VK_CLOSE_BRACKET);
                    break;
                case '\\' :
                    keyPress (KeyEvent.VK_BACK_SLASH);
                    break;
                case ';' :
                    keyPress (KeyEvent.VK_SEMICOLON);
                    break;
                case '\'' :
                    keyPress (KeyEvent.VK_QUOTE);
                    break;
                case ',' :
                    keyPress (KeyEvent.VK_COMMA);
                    break;
                case '.' :
                    keyPress (KeyEvent.VK_PERIOD);
                    break;
                case '/' :
                    keyPress (KeyEvent.VK_SLASH);
                    break;
                case ' ' :
                    keyPress (KeyEvent.VK_SPACE);
                    break;
                case '~' :
                    shiftKeyPress (KeyEvent.VK_BACK_QUOTE);
                    break;
                case '!' :
                    shiftKeyPress (KeyEvent.VK_1);
                    break;
                case '@' :
                    shiftKeyPress (KeyEvent.VK_2);
                    break;
                case '#' :
                    shiftKeyPress (KeyEvent.VK_3);
                    break;
                case '$' :
                    shiftKeyPress (KeyEvent.VK_4);
                    break;
                case '%' :
                    shiftKeyPress (KeyEvent.VK_5);
                    break;
                case '^' :
                    shiftKeyPress (KeyEvent.VK_6);
                    break;
                case '&' :
                    shiftKeyPress (KeyEvent.VK_7);
                    break;
                case '*' :
                    shiftKeyPress (KeyEvent.VK_8);
                    break;
                case '(' :
                    shiftKeyPress (KeyEvent.VK_9);
                    break;
                case ')' :
                    shiftKeyPress (KeyEvent.VK_0);
                    break;
                case '_' :
                    shiftKeyPress (KeyEvent.VK_MINUS);
                    break;
                case '+' :
                    shiftKeyPress (KeyEvent.VK_EQUALS);
                    break;
                case '{' :
                    shiftKeyPress (KeyEvent.VK_OPEN_BRACKET);
                    break;
                case '}' :
                    shiftKeyPress (KeyEvent.VK_CLOSE_BRACKET);
                    break;
                case '|' :
                    shiftKeyPress (KeyEvent.VK_BACK_SLASH);
                    break;
                case ':' :
                    shiftKeyPress (KeyEvent.VK_SEMICOLON);
                    break;
                case '"' :
                    shiftKeyPress (KeyEvent.VK_QUOTE);
                    break;
                case '<' :
                    shiftKeyPress (KeyEvent.VK_COMMA);
                    break;
                case '>' :
                    shiftKeyPress (KeyEvent.VK_PERIOD);
                    break;
                case '?' :
                    shiftKeyPress (KeyEvent.VK_SLASH);
                    break;
            }
        }
        if (autoDelayForType > 0) sleep (autoDelayForType);
    }
    autoDelayForKeys = saveAutoDelayForKeys;
    delayForKeys ();
}


-----Function Pair=286=-----==

private int funcaoObjetivo (short [] sequencia) {
    result = new int [n] [m];
    for (int i = 0; i < n; i ++) {
        short k = sequencia [i];
        for (int j = 0; j < m; j ++) {
            if (i == 0 && j == 0) {
                result [i] [j] = tempo [k] [j];
            }
            else if (j == 0 && i > 0) {
                result [i] [j] = tempo [k] [j] + result [i - 1] [j];
            }
            else if (i == 0 && j > 0) {
                result [i] [j] = tempo [k] [j] + result [i] [j - 1];
            }
            else {
                if (result [i - 1] [j] >= result [i] [j - 1]) result [i] [j] = tempo [k] [j] + result [i - 1] [j];
                else result [i] [j] = tempo [k] [j] + result [i] [j - 1];
            }
        }
    }
    return result [n - 1] [m - 1];
}


public void checkValidity () {
    try {
        int genomeLength = m_world.getNumberOfCities ();
        int tgraphNodes = m_world.getTotalGraphNodes ();
        boolean isIn [] = new boolean [genomeLength];
        for (int i = 0; i < genomeLength; i ++) {
            isIn [i] = false;
        }
        for (int i = 0; i < genomeLength; i ++) {
            int codonName = m_cityList [i].get ();
            if ((codonName < 0) || (codonName > (tgraphNodes - 1))) {
                System.out.println ("\r\n" + "TravellerChromosome.isValid(); invalid Codon in genome: " + m_cityList [i].toString ());
                complain ();
                return;
            }
            else {
                isIn [i] = true;
            }
        }
        for (int i = 0; i < genomeLength; i ++) {
            if (isIn [i] == false) {
                System.out.println ("\r\n" + "TravellerChromosome.isValid(); city " + i + " missing in genome.");
                complain ();
                return;
            }
        }
    } catch (Exception e) {
        System.out.println ("TravellerChromosome.isValid() threw!");
        System.out.println ("And did it for a chromosome created by " + m_originator);
    }
}


-----Function Pair=287=-----==

protected void sendStatsRequest () throws IOException {
    UDPPacket packet_to_send = null;
    synchronized (this) {
        Iterator it = transmit_unack_packets.iterator ();
        while (it.hasNext ()) {
            UDPPacket packet = (UDPPacket) it.next ();
            if (packet.getCommand () == UDPPacket.COMMAND_STAT_REQUEST) {
                if (total_tick_count - packet.getSendTickCount () >= MIN_RETRANSMIT_TICKS) {
                    if (manager.trace ()) {
                        trace (packet.getConnection (), "retransStatsRequest:" + packet.getString ());
                    }
                    packet_to_send = packet;
                    break;
                }
                else {
                    return;
                }
            }
        }
        if (packet_to_send == null) {
            byte [] header_bytes = new byte [256];
            ByteBuffer header = ByteBuffer.wrap (header_bytes);
            long unack_in_sequence_count = current_receive_unack_in_sequence_count;
            int [] sequences = writeHeaderStart (header, UDPPacket.COMMAND_STAT_REQUEST, UDPPacket.FLAG_NONE);
            int size = writeHeaderEnd (header, true);
            byte [] packet_bytes = new byte [size];
            System.arraycopy (header_bytes, 0, packet_bytes, 0, size);
            packet_to_send = new UDPPacket (lead_connection, sequences, UDPPacket.COMMAND_STAT_REQUEST, packet_bytes, unack_in_sequence_count);
            transmit_unack_packets.add (packet_to_send);
            if (manager.trace ()) {
                trace (lead_connection, "sendStatsRequest");
            }
        }
    }
    send (packet_to_send);
}


public static String getElementByName (String element, String name) {
    String output = "";
    try {
        String xquery = "document('" + settingsDB + "/vo_description.xml')/OBSERVATORY/DATA_SECTIONS/SECTION/" + element + "[ ../NAME = '" + name + "']/text()";
        XQueryService service = (XQueryService) CollectionsManager.getService (settingsDB, true, "XQueryService");
        ResourceSet result = service.query (xquery);
        for (int i = 0; i < result.getSize (); i ++) {
            XMLResource resource = (XMLResource) result.getResource (i);
            String res = resource.getContent ().toString ();
            output = res;
        }
    } catch (Exception e) {
        log.error ("Error getting element by name: " + e);
        e.printStackTrace ();
    }
    return output;
}


-----Function Pair=288=-----==

protected void setUp () throws Exception {
    super.setUp ();
    context = new ContextStack ();
    List < String > randomStrings = new ArrayList < String > ();
    Random random = new Random ();
    for (int i = 0, num = random.nextInt (100); i < num; ++ i) {
        int minChar = 32, maxChar = 126;
        int stringSize = random.nextInt (30);
        StringBuilder buf = new StringBuilder ();
        for (int j = 0; j < stringSize; ++ j) {
            int charId = minChar + random.nextInt (maxChar - minChar);
            buf.append ((char) charId);
        }
        randomStrings.add (buf.toString ());
    }
    context.put ("name", "Tom");
    context.put ("randomStrings", randomStrings);
    context.put ("intArray", intArray);
    context.put ("intList", TemplateUtils.objectToCollection (intArray));
    context.put ("doubleArray", doubleArray);
    context.put ("doubleList", TemplateUtils.objectToCollection (doubleArray));
}


public static void main (String args []) {
    try {
        DB.Initialize ();
        Random r = new Random ();
        StudentInfo [] s = StudentModel.getStudents ();
        Club [] c = ClubModel.getClubs ();
        if (false) {
            for (Club b : c) {
                if (b.rank.equals ("-1")) {
                    b.rank = "" + r.nextInt (11);
                    System.out.println (b.name + ": -1 -> " + b.rank + "  " + DB.Update ("UPDATE Club SET rank='" + b.rank + "' WHERE club_id=" + b.id));
                }
                int rank = Integer.parseInt (b.rank);
                String q = "20101";
                double moneyz [] = {200, 300, 500, 600, 800, 1000, 2000, 4000, 6000, 8000, 10000};
                System.out.println ("Budget: " + moneyz [rank] + "   " + DB.Update ("INSERT INTO Budget (`club_id`, `quarter_id`, `used`, `available`) VALUES ( " + b.id + ", " + q + ", 0, " + moneyz [rank] + " )") + "   " + b.name);
            }
        }
        int max_club = 3;
        if (false) {
            for (StudentInfo i : s) {
                int num = r.nextInt (max_club + 1);
                num -= ClubModel.getClubsOfMember (i.uid).length;
                for (int k = 0; k < num; k ++) {
                    int join = r.nextInt (c.length);
                    System.out.println (i.uid + " -> " + c [join].name + "   " + ClubModel.addMember (i, c [join]));
                }
            }
        }
    } catch (DBError de) {
    }
}


-----Function Pair=289=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=290=-----==

public static boolean doCreateOrUpdate (Object object) {
    try {
        session = currentSession ();
        beginTransaction ();
        session.saveOrUpdate (object);
        endTransaction ();
    } catch (ConstraintViolationException e) {
        rollbackTransaction ();
        return false;
    } catch (Exception e) {
        rollbackTransaction ();
        e.printStackTrace ();
        return false;
    } finally {
        closeHibernateSession ();
    }
    return true;
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=291=-----==

public Vector upSync (BigDecimal owner, boolean fullSync) throws SQLException {
    Vector exts = new Vector ();
    try {
        boolean foundone = false;
        con = allocateConnection (tableName);
        if (fullSync) {
            ps = con.prepareStatement ("select * from  cont_Contact where owner=? order by syncstatus");
            ps.setBigDecimal (1, owner);
        }
        else {
            ps = con.prepareStatement ("select * from  cont_Contact where owner=? and syncstatus>? order by syncstatus");
            ps.setBigDecimal (1, owner);
            ps.setInt (2, RESET);
        }
        rs = con.executeQuery (ps, null);
        while (rs.next ()) {
            exts.addElement (new ExternalContactDO (rs));
            foundone = true;
        }
        if (foundone) {
            PreparedStatement delfc = con.prepareStatement ("delete from cont_Contact_Group_Rel " + "where externalcontact in " + "(select OId from cont_Contact where owner=? " + "and syncstatus=?)");
            PreparedStatement delx = con.prepareStatement ("delete from cont_Contact where owner=? and syncstatus=?");
            PreparedStatement update = con.prepareStatement ("update cont_Contact set syncstatus=?,dirtybits=? " + "where owner=?");
            delfc.setBigDecimal (1, owner);
            delfc.setInt (2, DELETE);
            delx.setBigDecimal (1, owner);
            delx.setInt (2, DELETE);
            update.setInt (1, RESET);
            update.setInt (2, RESET);
            update.setBigDecimal (3, owner);
            con.reset ();
            con.executeUpdate (delfc, null);
            con.reset ();
            con.executeUpdate (delx, null);
            con.reset ();
            con.executeUpdate (update, null);
        }
    } catch (SQLException e) {
        if (DEBUG) logError ("", e);
        throw e;
    } finally {
        release ();
    }
    return exts;
}


public void initCopied (Vector values, Vector cvalues, Vector changed, String handleNull, boolean db2ObjectServerSupport, String revname) {
    Enumeration attribs = getAttributes ().elements ();
    DBMetaAttribute attrib = null;
    String colname, v;
    int i = 0;
    if (! db2ObjectServerSupport) return;
    while (attribs.hasMoreElements ()) {
        attrib = (DBMetaAttribute) (attribs.nextElement ());
        if (attrib.getType () == DBMetaAttribute.INT_TYPE) {
            colname = attrib.getName ().toUpperCase ();
            if (colname.compareTo ("OBJECTID") == 0) {
                try {
                    v = getNextObjectId ();
                    cvalues.setElementAt (v, i);
                    changed.setElementAt (new Boolean (true), i);
                } catch (SQLException e) {
                    System.err.println ("DBMetaObject.createEmptyValues: Error creating next serial value!");
                    System.err.println (e);
                }
            }
            else if (colname.compareTo (revname) == 0) {
                cvalues.setElementAt ("1", i);
                changed.setElementAt (new Boolean (true), i);
            }
        }
        i ++;
    }
}


-----Function Pair=292=-----==

public static void saveCustomTitles (String usrlogin, String tabid, String [] custom_titles) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        int seq = 0;
        for (int i = 0; i < custom_titles.length; i ++) {
            seq ++;
            r.clear ();
            r.add ("module_custom_title", custom_titles [i]);
            r.update ("user_login", usrlogin);
            r.update ("tab_id", tabid);
            r.update ("sequence", seq);
            sql = r.getSQLUpdate ("user_module_template");
            stmt.executeUpdate (sql);
        }
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


protected static void executePostHibernateStartUpSQL (final ServletConfig config, final Lifecycle lc) {
    Session s = lc.getHibernateDatasourceDirectly ().createNewSession ();
    Transaction tx = null;
    Level oldLevel = Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").getLevel ();
    try {
        Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").setLevel (Level.OFF);
        for (Element statement : (List < Element >) config.getPostHibernateStartUpSQL ().getChildren ("statement")) {
            boolean ignoreErrors = false;
            String sql = statement.getText ().trim ();
            if (statement.getAttributeValue ("ignoreErrors").equalsIgnoreCase ("true")) {
                ignoreErrors = true;
            }
            try {
                tx = s.beginTransaction ();
                s.createSQLQuery (sql).executeUpdate ();
                tx.commit ();
            } catch (Exception e) {
                if (tx != null) {
                    tx.rollback ();
                }
                if (! ignoreErrors) {
                    LOGGER.warn (sql + System.getProperty ("line.separator") + e.getLocalizedMessage ());
                }
            }
        }
    } catch (Exception e) {
        throw new PulseException ("Error: " + e.getLocalizedMessage (), e);
    } finally {
        s.close ();
        Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").setLevel (oldLevel);
    }
}


-----Function Pair=293=-----==

public void insert () {
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        conn.setAutoCommit (false);
        String sql = "insert into companysales(salename,comid,saletel,salemail," + "remark) values(?,?,?,?,?)";
        conn.prepare (sql);
        conn.setString (1, getSalename ());
        conn.setInt (2, getComid ());
        conn.setString (3, getSaletel ());
        conn.setString (4, getSalemail ());
        conn.setString (5, getRemark ());
        conn.executeUpdate ();
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


private Map < String, Object > getParametersMap (Entity obj) {
    Map < String, Object > parameters = new HashMap < String, Object > ();
    if (obj instanceof Application) {
        parameters.put ("id", ((Application) obj).getId ());
    }
    else if (obj instanceof Research) {
        parameters.put ("id", ((Research) obj).getId ());
    }
    else if (obj instanceof Production) {
        parameters.put ("id", ((Production) obj).getId ());
    }
    else if (obj instanceof Viscosity) {
        parameters.put ("id", ((Viscosity) obj).getId ());
    }
    else if (obj instanceof Strength) {
        parameters.put ("id", ((Strength) obj).getId ());
    }
    else if (obj instanceof Test) {
        parameters.put ("id", ((Test) obj).getId ());
    }
    return parameters;
}


-----Function Pair=294=-----==

public RestServiceResult update (RestServiceResult serviceResult, List listWordsComleteE2, Long nCompleteId) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_COMPLETE2_WORD);
        query.setParameter (1, new Long (nCompleteId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        if (listWordsComleteE2 != null) {
            for (int i = 0; i < listWordsComleteE2.size (); i ++) {
                CoWordsCompleteE2 coWordsCompleteE2 = (CoWordsCompleteE2) listWordsComleteE2.get (i);
                serviceResult = this.create (serviceResult, coWordsCompleteE2);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar las palabras: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult listGroupForExercise (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises1);
    List < ToExercise1Group > list = new ArrayList < ToExercise1Group > ();
    Set < ToExercise1Group > set = coExercises1.getToExercise1Groups ();
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("exercise1group.search.notFound"));
    }
    else {
        list.addAll (set);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.search.success"), arrayParam));
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


-----Function Pair=295=-----==

public void testMetaData0046 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0046 (" + "   i integer identity, " + "   a integer not null, " + "   b integer null ) ");
    int count = stmt.executeUpdate ("insert into #t0046 (a, b) values (-2, -3)");
    assertEquals (count, 1);
    ResultSet rs = stmt.executeQuery ("select i, a, b, 17 c from #t0046");
    assertNotNull (rs);
    ResultSetMetaData md = rs.getMetaData ();
    assertNotNull (md);
    assertTrue (md.isAutoIncrement (1));
    assertTrue (! md.isAutoIncrement (2));
    assertTrue (! md.isAutoIncrement (3));
    assertTrue (! md.isAutoIncrement (4));
    assertTrue (md.isReadOnly (1));
    assertTrue (! md.isReadOnly (2));
    assertTrue (! md.isReadOnly (3));
    assertEquals (md.isNullable (1), java.sql.ResultSetMetaData.columnNoNulls);
    assertEquals (md.isNullable (2), java.sql.ResultSetMetaData.columnNoNulls);
    assertEquals (md.isNullable (3), java.sql.ResultSetMetaData.columnNullable);
    rs.close ();
    stmt.close ();
}


public List < String > getReferenceColumn (String pTableName) {
    List < String > tOut = new ArrayList < String > ();
    ResultSet tRS = null;
    try {
        tRS = getConnection ().getMetaData ().getImportedKeys (loginInfo.getSchema (), SCHEMA_PATTERN, pTableName);
        while (tRS.next ()) {
            String tTable = tRS.getString ("FKCOLUMN_NAME");
            if (! tOut.contains (tTable)) {
                tOut.add (tTable);
            }
        }
    } catch (Exception e) {
        LOG.error ("", e);
    } finally {
        close (tRS);
    }
    return tOut;
}


-----Function Pair=296=-----==

public void addThreads (List < Threads > threadsList) {
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        for (Threads threads : threadsList) {
            session.save (threads);
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    }
}


public static com.bifrostbridge.testinfrastructure.model.User getSystemAccount () {
    if (DAOTestUtils.sysAccount != null) {
        return DAOTestUtils.sysAccount;
    }
    com.bifrostbridge.testinfrastructure.model.User system = DAOTestUtils.retrieve ("system");
    if (system == null) {
        com.bifrostbridge.testinfrastructure.model.User user = new com.bifrostbridge.testinfrastructure.model.Administrator ("system", com.bifrostbridge.testinfrastructure.model.Roles.ADMIN, SystemUtils.generatePasswordHash ("system"), "System Administrator");
        DAOTestUtils.create (user);
        com.bifrostbridge.testinfrastructure.model.User test = DAOTestUtils.retrieve ("system");
        if (test == null) {
            System.out.println ("****** SAVE WAS NOT SUCCESSFUL");
        }
    }
    DAOTestUtils.sysAccount = system;
    return system;
}


-----Function Pair=297=-----==

private void updateFilesTable () {
    String qry = "INSERT INTO files (id, file, finished) VALUES (?, ?, 0)";
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement (qry);
        for (MediaFileAPI.MediaFile mf : Butler.SageApi.mediaFileAPI.GetMediaFiles ()) {
            for (File f : mf.GetSegmentFiles ()) {
                pstmt.setString (2, f.getAbsolutePath ());
                pstmt.setString (1, Integer.toString (mf.GetMediaFileID ()));
                pstmt.executeUpdate ();
            }
        }
    } catch (SQLException e) {
        LOG.error ("SQL error", e);
        throw new RuntimeException (e);
    } finally {
        try {
            if (pstmt != null) pstmt.close ();
        } catch (SQLException e) {
            LOG.error ("SQL error", e);
            throw new RuntimeException (e);
        }
    }
    return;
}


private void ChangePassword (Connection conn, String uid, String pass) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement ("update users set password=? where id=?");
        pstmt.setString (1, pass);
        pstmt.setString (2, uid);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=298=-----==

String readLog (final String mediaId, final String taskId, final String objType) {
    PreparedStatement stmt = readLog;
    StringWriter log = new StringWriter ();
    try {
        stmt.setString (1, mediaId);
        stmt.setString (2, taskId);
        stmt.setString (3, objType);
        ResultSet rs = stmt.executeQuery ();
        while (rs.next ()) log.write (rs.getString (1) + "\n");
        rs.close ();
    } catch (SQLException e) {
        LOG.error ("SQL error", e);
        throw new RuntimeException (e);
    }
    if (! mediaId.equals ("-1")) return StringEscapeUtils.escapeHtml (log.toString ());
    else return log.toString ();
}


public static int getTotalPhotoSize (int sid, int album_id) {
    if (sid < 1) return - 1;
    StringBuffer hql = new StringBuffer ("SELECT SUM(p.photoInfo.size) FROM PhotoBean AS p WHERE p.site.id=?");
    if (album_id > 0) hql.append (" AND p.album.id=?");
    Session ssn = getSession ();
    Query q = ssn.createQuery (hql.toString ());
    q.setInteger (0, sid);
    if (album_id > 0) q.setInteger (1, album_id);
    try {
        Number size = (Number) q.uniqueResult ();
        return (size != null) ? size.intValue () : 0;
    } finally {
        hql = null;
    }
}


-----Function Pair=299=-----==

String getSetting (String name, String defaultValue) {
    PreparedStatement pstmt = getSetting;
    ResultSet rs = null;
    try {
        pstmt.setString (1, name);
        rs = pstmt.executeQuery ();
        if (rs.next ()) return rs.getString (1);
        return defaultValue;
    } catch (SQLException e) {
        LOG.error ("SQL error", e);
        throw new RuntimeException (e);
    } finally {
        try {
            if (rs != null) rs.close ();
        } catch (SQLException e) {
            LOG.error ("SQL error", e);
            throw new RuntimeException (e);
        }
    }
}


public SymptomListDocument getDSMGroupList () {
    SymptomListDocument doc = null;
    ResultSet rsGroup = null;
    PreparedStatement psGroup = null;
    try {
        helper = new DBHelper ();
        doc = SymptomListDocument.Factory.newInstance ();
        psGroup = helper.prepareStatement (SQL.getDSMGroupList ());
        rsGroup = psGroup.executeQuery ();
        doc.addNewSymptomList ();
        while (rsGroup.next ()) {
            doc.getSymptomList ().addNewSymptom ().setDsm (rsGroup.getString ("GROUPDESCRIPTION"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsGroup != null) {
                rsGroup.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (SQLException ee) {
            ee.printStackTrace ();
        }
    }
    return doc;
}


-----Function Pair=300=-----==

private Vector getAllParentGroupIds () throws SQLException {
    Vector groups = new Vector ();
    HashSet filter_out = new HashSet ();
    sql_get_parent_group_ids_stmt_.setInt (1, user_id_);
    ResultSet rs = sql_get_parent_group_ids_stmt_.executeQuery ();
    if (rs != null) {
        while (rs.next ()) {
            int pos = groups.size ();
            addAllParentGroups (groups, new Integer (rs.getInt (1)), filter_out);
            for (; pos < groups.size (); pos ++) filter_out.add (groups.elementAt (pos));
        }
        rs.close ();
    }
    return (groups);
}


public void testFloat1 () throws Exception {
    float value = 2.2f;
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #testFloat1 (data decimal(28,10))");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #testFloat1 (data) values (?)");
    pstmt.setFloat (1, value);
    assertTrue (pstmt.executeUpdate () == 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #testFloat1");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertTrue (value == rs.getFloat (1));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


-----Function Pair=301=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public Integer save (Smilies s) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.save (s);
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
        return 0;
    }
    return 1;
}


-----Function Pair=302=-----==

public HolidaysType findById (Integer holidaysId) throws SelectException, DBConnectionException {
    HolidaysType holidays = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (HolidaysDAO.TABLE_NAME + " holy"));
    tablesFrom.add (new SQLWord (HolidaysTypeDAO.TABLE_NAME + " holyt"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("holy.HOLIDAYS_TYPE_ID", new SQLWord ("holyt.HOLIDAYS_TYPE_ID"));
    critWhere.addCriterion ("holy.HOLIDAYS_ID", holidaysId);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                holidays = new HolidaysType ();
                holidays.setId (result.getInt ("HOLIDAYS_TYPE_ID"));
                holidays.setName (result.getString ("HOLIDAYS_TYPE_NAME"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return holidays;
}


public int getUseridForgivenName (String username) throws Exception {
    int id = 0;
    Session session = null;
    Transaction tx = null;
    Users us = new Users ();
    try {
        setUp ();
        session = HibernateUtil.getSessionFactory ().openSession ();
        tx = session.beginTransaction ();
        List tmpUsers = this.session.createCriteria (Users.class).add (Restrictions.eq ("user_name", username)).list ();
        for (Iterator iter = tmpUsers.iterator (); iter.hasNext ();) {
            us = (Users) iter.next ();
            if (tmpUsers.size () == 1) {
                id = us.getId ().intValue ();
            }
            tx.commit ();
            session.close ();
        }
    } catch (Exception e) {
        logger.error ("EXCEPTION While update user", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
    return id;
}


-----Function Pair=303=-----==

private String findNamespaceID (String column, String value) throws SQLException {
    String statement = getDAO ().getStatement (TABLE_KEY, "GET_NAMESPACE");
    statement += (" " + getDAO ().getStatement (TABLE_KEY, "FIND_NAMESPACE_BY_" + column.toUpperCase ()));
    statement += ("'" + value + "'");
    ResultSet res = findNamespaceSt.executeQuery (statement);
    int id = - 1;
    while (res.next ()) {
        id = res.getInt (1);
    }
    String idString = "";
    if (id != - 1) {
        idString = Integer.toString (id);
    }
    return idString;
}


public Integer [] getExtendingNamespaces (int namespaceId, DTSPermission permit) throws SQLException, XMLException {
    getExtendStmt.setInt (1, namespaceId);
    ResultSet rs = getExtendStmt.executeQuery ();
    ArrayList al = new ArrayList ();
    if (rs != null) {
        while (rs.next ()) {
            int nid = rs.getInt (1);
            al.add (new Integer (nid));
        }
        rs.close ();
    }
    Integer [] na = new Integer [al.size ()];
    na = (Integer []) al.toArray (na);
    return na;
}


-----Function Pair=304=-----==

public HolidaysType findByName (String name) throws SelectException, DBConnectionException {
    HolidaysType holiType = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to get statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("HOLIDAYS_TYPE_NAME", name);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                holiType = new HolidaysType ();
                holiType.setId (result.getInt ("HOLIDAYS_TYPE_ID"));
                holiType.setName (result.getString ("HOLIDAYS_TYPE_NAME"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return holiType;
}


public int deleteFutureTransaction (long id) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "delete from FutureTransaction R where R.id=?";
        Query q = s.createQuery (query);
        q.setLong (0, id);
        int ret = q.executeUpdate ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=305=-----==

public RestServiceResult listThemesForCourse (RestServiceResult serviceResult, int nRowStart, int nMaxResults, Long nCourse) {
    CoCourse coCourse = new CoCourseDAO ().findById (nCourse);
    EntityManagerHelper.refresh (coCourse);
    Set < ToThemes > set = coCourse.getToThemeses ();
    List < ToThemes > list = new ArrayList < ToThemes > (set);
    if (list.size () == 0) {
        serviceResult.setNumResult (0);
        serviceResult.setMessage (bundle.getString ("theme.list.notFound"));
    }
    else {
        Object [] array = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("theme.list.success"), array));
        serviceResult.setNumResult (list.size ());
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


StringBuilder getPart (String schemaName, String fileName, boolean up) throws IOException {
    InputStream in = Migration.class.getResourceAsStream (fileName);
    BufferedReader reader = new BufferedReader (new InputStreamReader (in));
    StringBuilder buff = new StringBuilder ();
    boolean dividerRiched = false;
    while (true) {
        String line = line = reader.readLine ();
        if (line == null) break;
        if ("-----".equals (line)) {
            dividerRiched = true;
            continue;
        }
        if ((up && ! dividerRiched) || (! up && dividerRiched)) {
            buff.append (line.replace ("${schema_name}", schemaName));
            buff.append ("\n");
        }
    }
    return buff;
}


-----Function Pair=306=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoTest coTest) {
    CoTestDAO coTestDAO = new CoTestDAO ();
    try {
        coTest.setTestId (getSequence ("sq_co_test"));
        EntityManagerHelper.beginTransaction ();
        coTestDAO.save (coTest);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coTest);
        log.info ("Prueba " + coTest.getTestName () + " creada con �xito...");
        Object [] arrayParam = {coTest.getTestName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("test.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la prueba: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("test.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void test20_badSmtp () throws Exception {
    Db db = DbConnection.defaultCieDbRW ();
    try {
        db.begin ();
        oldSmtp = Config.getProperty (db, "com.entelience.mail.MailHelper.hostName", "localhost");
        oldSupport = Config.getProperty (db, "com.entelience.esis.feature.SupportNotifier", false);
        Config.setProperty (db, "com.entelience.mail.MailHelper.hostName", "127.0.10.1", 1);
        Config.setProperty (db, "com.entelience.esis.feature.SupportNotifier", "true", 1);
        PreparedStatement pst = db.prepareStatement ("DELETE FROM t_client_errors");
        db.executeUpdate (pst);
        db.commit ();
    } catch (Exception e) {
        db.rollback ();
    } finally {
        db.safeClose ();
    }
}


-----Function Pair=307=-----==

private void cloneUserHistory (Long nTestOldId, Long nTestNew) {
    try {
        log.info ("CLONACION HISTORIAL DE PRUEBAS X USUARIO");
        CoTest coTest = new CoTestDAO ().findById (nTestOldId);
        EntityManagerHelper.refresh (coTest);
        Set < CoTestUserHistory > setUserHistoryOld = coTest.getCoTestUserHistories ();
        CoTest coTestNew = new CoTestDAO ().findById (nTestNew);
        for (CoTestUserHistory coTestUserHistory : setUserHistoryOld) {
            MaUser maUser = coTestUserHistory.getMaUser ();
            CoTestUserHistory testUserHistory = new CoTestUserHistoryDAO ().findById (new CoTestUserHistoryId (coTestNew.getTestId (), maUser.getUserId ()));
            log.info ("Resultado de la consulta => " + testUserHistory);
            if (testUserHistory == null) {
                log.info ("Agregando HistorialxUnidades: Usuario '" + maUser.getUserId () + "' - prueba '" + coTestNew.getTestId () + "'");
                addUserHistory (maUser, coTestNew);
            }
            else {
                log.info ("El usuario '" + maUser.getUserId () + "' tiene la prueba '" + coTestNew.getTestId () + "'");
            }
        }
        log.info ("Ok...Termina clonaci�n de Historial de usuarios en PRUEBAS");
    } catch (PersistenceException e) {
        e.printStackTrace ();
    }
}


String getMetaValue (Connection conn, String id, String host, Integer prop, int type) throws SQLException {
    PreparedStatement stmt = null;
    try {
        stmt = conn.prepareStatement ("SELECT meta.value FROM meta " + "WHERE meta.host = ? " + "AND meta.type = ? " + "AND meta.id = ? " + "AND meta.prop " + (prop == null ? "IS NULL" : "= ?"));
        Integer hostIndex = representer.lookUpInternalRep (host);
        stmt.setInt (1, hostIndex);
        stmt.setInt (2, type);
        stmt.setString (3, id);
        if (prop != null) {
            stmt.setInt (4, prop);
        }
        ResultSet rs = stmt.executeQuery ();
        return rs.next () ? rs.getString (1) : null;
    } finally {
        StorageUtils.close (stmt);
    }
}


-----Function Pair=308=-----==

private String getNamespaceType (int namespaceId) throws SQLException {
    String namespaceType = "";
    if (getNspType == null) {
        String getNspTypeQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_NAMESPACE_TYPE);
        getNspType = this.conn.prepareStatement (getNspTypeQuery);
    }
    ResultSet rs = null;
    try {
        getNspType.setInt (1, namespaceId);
        rs = getNspType.executeQuery ();
        while (rs.next ()) {
            namespaceType = rs.getString (1);
        }
        rs.close ();
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
    return namespaceType;
}


public boolean actualizarEstadoEliminacion (int idTorneo) {
    int intResult = 0;
    String sql = "UPDATE torneo " + " SET  terminado = 3 WHERE idTorneo= " + idTorneo;
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        intResult = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (intResult > 0);
}


-----Function Pair=309=-----==

private int getLinkedNamespace (int extNamespaceId) throws SQLException {
    int baseNamespace = - 1;
    if (getLinkNsp == null) {
        String getLinkNspQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_LINK_NAMESPACE);
        getLinkNsp = this.conn.prepareStatement (getLinkNspQuery);
    }
    ResultSet rs = null;
    try {
        getLinkNsp.setInt (1, extNamespaceId);
        rs = getLinkNsp.executeQuery ();
        while (rs.next ()) {
            baseNamespace = rs.getInt (1);
        }
        rs.close ();
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
    return baseNamespace;
}


public int deleteFavourites (long id) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "delete from Favourites R where R.id=?";
        Query q = s.createQuery (query);
        q.setLong (0, id);
        int ret = q.executeUpdate ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=310=-----==

public void test07_bad_login () throws Exception {
    logOut ();
    Call call = (Call) SoapTestCase.service.createCall ();
    call.setTargetEndpointAddress (getEndPoint () + "Authentication");
    call.setOperationName ("extLogIn");
    call.setOperationStyle ("rpc");
    String passwd = md5sum ("esis");
    String login = "fakeUseresis";
    call.addParameter ("login", XMLType.XSD_STRING, ParameterMode.IN);
    call.addParameter ("passwd", XMLType.XSD_STRING, ParameterMode.IN);
    QName qn = new QName ("urn:com.entelience.soap.soapAuthentication", "ExtendedAuthentication");
    call.registerTypeMapping (com.entelience.objects.ExtendedAuthentication.class, qn, new BeanSerializerFactory (com.entelience.objects.ExtendedAuthentication.class, qn), new BeanDeserializerFactory (com.entelience.objects.ExtendedAuthentication.class, qn));
    call.setReturnType (qn);
    ExtendedAuthentication extAuth = null;
    try {
        extAuth = (ExtendedAuthentication) call.invoke (new Object [] {login, passwd});
    } catch (Exception e) {
    }
    assertTrue (extAuth == null);
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=311=-----==

public void delete (long locationRegistryId) {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction transaction = session.beginTransaction ();
    try {
        org.hibernate.Query query = session.createQuery (" delete " + " from  " + " LocationRegistry lr WHERE lr.id = ? ");
        query.setLong (0, locationRegistryId);
        query.executeUpdate ();
        transaction.commit ();
    } catch (HibernateException e) {
        transaction.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}


public boolean mailRead (int pmid) {
    boolean result = false;
    try {
        PreparedStatement pstmt = getCon ().prepareStatement ("update mail set stat=? where pmid = ? ");
        pstmt.setString (1, "read");
        pstmt.setInt (2, pmid);
        int num = pstmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return result;
}


-----Function Pair=312=-----==

public < T > void remove (T obj) throws RuntimeException {
    EntityManager em = getEntityManager ();
    if (em != null) {
        EntityTransaction et = em.getTransaction ();
        try {
            if (et.isActive () == false) {
                et.begin ();
            }
            em.remove (em.merge (obj));
            if (et.isActive ()) {
                et.commit ();
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            em.close ();
            throw new RuntimeException (exception);
        }
        em.close ();
    }
}


public boolean insertValidating (Validating validating) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (validating);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=313=-----==

public boolean deleteOnlineTime (Onlinetime onlinetime) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.delete (onlinetime);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public void removeAllHandlers (String event) {
    String qry = "DELETE FROM listeners WHERE event = '" + event + "'";
    Statement stmt = null;
    try {
        stmt = conn.createStatement ();
        logQry (qry);
        stmt.executeUpdate (qry);
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
    } finally {
        if (stmt != null) try {
            stmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


-----Function Pair=314=-----==

protected Object retrieveOneValue (String sql, int columnIndex) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("querying " + sql + "...");
    }
    Connection connection = null;
    try {
        connection = dataSource.getConnection ();
        Statement statement = connection.createStatement ();
        ResultSet rs = statement.executeQuery (sql);
        if (! rs.next ()) {
            return null;
        }
        else {
            return rs.getObject (columnIndex);
        }
    } catch (SQLException e) {
        LOG.error ("Error while calling retrieve(): " + e, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


public Collection list () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Word, SenseNumber, GrammarString, ObjectId " + "from Dictionary order by Word";
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                DictionaryEntry entry = new DictionaryEntry (rs.getString (1), rs.getInt (2), rs.getString (3), rs.getString (4));
                list.add (entry);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=315=-----==

public RestServiceResult listTechnicalForHability (RestServiceResult serviceResult, Long nHabilityId) {
    CoHability coHability = new CoHabilityDAO ().findById (nHabilityId);
    EntityManagerHelper.refresh (coHability);
    if (coHability == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("technical.search.notFound"));
    }
    else {
        List < CoTechnical > list = new ArrayList < CoTechnical > (coHability.getCoTechnicals ());
        Object [] arrayParam = {list.size (), coHability.getHabilityName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("technical.listTechnicalForHability.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


public void executeUpdateTransaction (List queries) throws SQLException {
    assert connection != null;
    boolean autoCommit = connection.getAutoCommit ();
    connection.setAutoCommit (false);
    try {
        Iterator iterator = queries.iterator ();
        while (iterator.hasNext ()) {
            String query = (String) iterator.next ();
            Statement statement = connection.createStatement ();
            statement.executeUpdate (query);
        }
        connection.commit ();
        connection.setAutoCommit (autoCommit);
    } catch (SQLException e) {
        connection.rollback ();
        throw new SQLException (e.getMessage ());
    }
}


-----Function Pair=316=-----==

private boolean checkDatabase () {
    boolean success = true;
    if (software != HSQLDB_SOFTWARE) {
        try {
            DatabaseMetaData meta = connection.getMetaData ();
            {
                ResultSet RS = meta.getCatalogs ();
                String traverseDatabaseName;
                boolean foundDatabase = false;
                while (RS.next ()) {
                    traverseDatabaseName = RS.getString (1);
                    if (traverseDatabaseName.equals (database)) {
                        foundDatabase = true;
                        break;
                    }
                }
                if (! foundDatabase) {
                    DesktopManager.showErrorMessage (Locale.getString ("CANT_FIND_DATABASE", database));
                    return false;
                }
            }
        } catch (SQLException e) {
            DesktopManager.showErrorMessage (Locale.getString ("ERROR_TALKING_TO_DATABASE", e.getMessage ()));
            return false;
        }
    }
    return success;
}


public static int deleteRegistrationByEmail (String email) throws Exception {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query query = session.createQuery ("delete from Registration where email = :email");
        query.setString ("email", email);
        int rowCount = query.executeUpdate ();
        tx.commit ();
        return rowCount;
    } catch (Exception ex) {
        if (tx != null) {
            tx.rollback ();
        }
        throw ex;
    }
}


-----Function Pair=317=-----==

private void loadStatements (InputStream is) throws IOException {
    BufferedReader br = null;
    try {
        br = new BufferedReader (new InputStreamReader (is));
        String line = null;
        StringBuffer statement = new StringBuffer ();
        while ((line = br.readLine ()) != null) {
            if (line.trim ().equalsIgnoreCase (BATCH_DELIMITER)) {
                statements.add (statement.toString ());
                statement = new StringBuffer ();
            }
            else if (line.trim ().length () != 0) {
                statement.append (line);
            }
        }
    } finally {
        is.close ();
        if (br != null) {
            br.close ();
        }
    }
}


public Search getSearchParams () {
    Search search = null;
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + SEARCH_TABLE + " o where o.type =:type");
        query.setString ("type", ParamType.ADMIN.getType ());
        search = (Search) query.uniqueResult ();
        transaction.commit ();
    } catch (RuntimeException e) {
        if (transaction != null && transaction.isActive ()) {
            try {
                transaction.rollback ();
            } catch (HibernateException e1) {
                logger.debug ("Error rolling back transaction");
            }
            throw e;
        }
    }
    return search;
}


-----Function Pair=318=-----==

public Collection list () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select a.LinkName, a.LinkType, b.Description from ClassLinkTypes a, ClassLinkTypeTypes b " + "where a.LinkType = b.LinkType order by LinkName";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                ClassLinkType type = new ClassLinkType (rs.getString (1), rs.getInt (2), rs.getString (3));
                list.add (type);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


private boolean existsIndex (EboContext ctx, String schemaName, String indexName) throws SQLException {
    Connection cn = null;
    ResultSet rslt = null;
    PreparedStatement pstm = null;
    try {
        cn = ctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("select count(*) from USER_INDEXES where INDEX_NAME=? and TABLE_OWNER = ?");
        pstm.setString (1, indexName.toUpperCase ());
        pstm.setString (2, schemaName.toUpperCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            if (rslt.getInt (1) > 0) {
                return true;
            }
        }
        return false;
    } catch (SQLException e) {
        throw (e);
    } finally {
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
}


-----Function Pair=319=-----==

public void removeAllHandlers (String event) {
    String qry = "DELETE FROM listeners WHERE event = '" + event + "'";
    Statement stmt = null;
    try {
        stmt = conn.createStatement ();
        logQry (qry);
        stmt.executeUpdate (qry);
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
    } finally {
        if (stmt != null) try {
            stmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=320=-----==

public List < Map < String, Object > > prepareCallForList (String sql, Object obj []) {
    if (debug) System.out.println (sql);
    Connection connection = null;
    connection = this.getConnection ();
    CallableStatement cstmt = null;
    try {
        if (connection != null && ! connection.isClosed ()) {
            cstmt = connection.prepareCall (sql);
            for (int i = 0; i < obj.length; i ++) {
                cstmt.setString (i + 1, obj [i].toString ());
            }
            cstmt.executeQuery ();
            if (cstmt.getMoreResults ()) {
                return this.resultSetToMapList (cstmt.getResultSet ());
            }
            return this.resultSetToMapList (cstmt.getResultSet ());
        }
    } catch (SQLException e) {
        log.error ("执行查询语句错误！", e);
        System.out.println (sql);
        System.out.println ("执行查询语句错误！");
    } finally {
        try {
            cstmt.close ();
            connection.close ();
        } catch (SQLException e) {
            log.error ("未能正确关闭数据库连接！", e);
            System.out.println ("未能正确关闭数据库连接！");
        }
    }
    return null;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        address1.setPerson (person);
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        address2.setPerson (person);
        person.getAddresses ().add (address2);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=321=-----==

public StudentsGroup store (StudentsGroup obj) throws InsertException, DBConnectionException, XmlIOException {
    if (obj.getGroupType ().getId () == null || obj.getYearOfStudy ().getId () == null) {
        throw new InsertException ("Missing GroupType FK and YearOfStudy FK");
    }
    else {
        Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
        List < Object > values = new ArrayList < Object > ();
        values.add (0);
        values.add (obj.getGroupType ().getId ());
        values.add (obj.getYearOfStudy ().getId ());
        values.add (obj.getName ());
        values.add (obj.getNbStudents ());
        try {
            stmt.executeUpdate (new InsertQuery (StudentsGroupDAO.TABLE_NAME, values).toString ());
            Criteria critWhere = new Criteria ();
            critWhere.addCriterion ("YEAR_STUDY_ID", obj.getName ());
            critWhere.addCriterion ("STUDENT_GROUP_NAME", obj.getName ());
            List < SQLWord > listSelect = new ArrayList < SQLWord > ();
            listSelect.add (new SQLWord ("STUDENT_GROUP_ID"));
            ResultSet result = stmt.executeQuery (new SelectQuery (StudentsGroupDAO.TABLE_NAME, listSelect, critWhere).toString ());
            if (result != null) {
                while (result.next ()) obj.setId (result.getInt (1));
            }
            else {
                throw new SelectException (TABLE_NAME + " Can't retieve record");
            }
            stmt.getConnection ().commit ();
            stmt.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
            try {
                stmt.getConnection ().rollback ();
            } catch (SQLException e1) {
                throw new DBConnectionException ("Rollback Exception :", e1);
            }
            throw new InsertException (TABLE_NAME + " Insert Exception :", e);
        }
    }
    return obj;
}


public void addShares (Set sharees_, PXPerson sharer_) {
    if ((sharees_ != null) && (sharees_.size () > 0) && (sharer_ != null)) {
        Transaction transaction = null;
        try {
            Session session = PXObjectStore.getInstance ().getThreadSession ();
            Iterator shareeIterator = sharees_.iterator ();
            transaction = session.beginTransaction ();
            while (shareeIterator.hasNext ()) {
                PXIdentity sharee = (PXIdentity) shareeIterator.next ();
                this.addShare (sharee, sharer_);
            }
            transaction.commit ();
        } catch (Exception e) {
            LOG.debug (null, e);
            if (transaction != null) {
                try {
                    transaction.rollback ();
                } catch (Exception f) {
                    LOG.warn (f);
                }
            }
        }
    }
}


-----Function Pair=322=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


private void jbInit () throws Exception {
    iniciarFrame ();
    this.setSize (new Dimension (492, 530));
    this.setVersion ("2006-02-06");
    statusBar = new StatusBar (this);
    conecta ();
    Vector v = new Vector ();
    cLabel10.setText ("Fecha Traspaso");
    cLabel10.setBounds (new Rectangle (4, 95, 91, 15));
    avc_fecalbE.setBounds (new Rectangle (90, 93, 75, 19));
    Bacecab.setMargin (new Insets (0, 0, 0, 0));
    jt.setMaximumSize (new Dimension (1, 252));
    numIndE.setEnabled (false);
    kilosE.setEnabled (false);
    jt.setMinimumSize (new Dimension (1, 252));
    jt.setPreferredSize (new Dimension (1, 252));
    jt.setPuntoDeScroll (50);
    Pdatos.setMaximumSize (new Dimension (490, 121));
    Pdatos.setMinimumSize (new Dimension (490, 121));
    Pdatos.setPreferredSize (new Dimension (490, 121));
    Baceptar.setMaximumSize (new Dimension (95, 26));
    Baceptar.setMinimumSize (new Dimension (95, 26));
    Baceptar.setPreferredSize (new Dimension (95, 26));
    Bcancela.setMaximumSize (new Dimension (95, 26));
    Bcancela.setMinimumSize (new Dimension (95, 26));
    Bcancela.setPreferredSize (new Dimension (95, 26));
    cPanel2.setBorder (BorderFactory.createLineBorder (Color.black));
    cPanel2.setMaximumSize (new Dimension (60, 60));
    cPanel2.setMinimumSize (new Dimension (30, 30));
    cPanel2.setPreferredSize (new Dimension (30, 30));
    cPanel2.setQuery (false);
    cPanel2.setLayout (null);
    cLabel11.setText ("N.Unidades");
    cLabel11.setBounds (new Rectangle (1, 4, 73, 17));
    numIndE.setText ("999");
    numIndE.setBounds (new Rectangle (73, 4, 30, 17));
    Kilos.setText ("Kilos");
    Kilos.setBounds (new Rectangle (116, 4, 39, 17));
    kilosE.setText ("---,--#.99");
    kilosE.setBounds (new Rectangle (160, 4, 63, 17));
    v.add ("Indiv");
    v.add ("Peso");
    v.add ("Unid.");
    v.add ("Inserta");
    jt.setCabecera (v);
    jt.setAnchoColumna (new int [] {30, 50, 40, 60});
    jt.setAlinearColumna (new int [] {2, 2, 2, 1});
    jt.setFormatoColumna (3, "BSN");
    jt.resetRenderer (3);
    jt.setAjustarGrid (true);
    pro_serieE.setMayusc (true);
    pro_serieE.setAutoNext (true);
    pro_serieE.setMayusc (true);
    eje_numeE.setAutoNext (true);
    emp_codiE.setAutoNext (true);
    pro_numlotE.setAutoNext (true);
    pro_indiiE.setAutoNext (true);
    pro_indiiE1.setAutoNext (true);
    pro_serieE.setText ("A");
    pro_serieE.setBounds (new Rectangle (264, 71, 17, 17));
    Pdatos.add (pro_codiE, null);
    Pdatos.add (cLabel1, null);
    Pdatos.add (alm_codioE, null);
    Pdatos.add (cLabel2, null);
    Pdatos.add (alm_codifE, null);
    Pdatos.add (cLabel3, null);
    Pdatos.add (cLabel4, null);
    Pdatos.add (eje_numeE, null);
    Pdatos.add (cLabel5, null);
    Pdatos.add (emp_codiE, null);
    Pdatos.add (cLabel6, null);
    Pdatos.add (cLabel7, null);
    Pdatos.add (pro_numlotE, null);
    Pdatos.add (pro_serieE, null);
    Pdatos.add (cLabel10, null);
    Pdatos.add (avc_fecalbE, null);
    Pdatos.add (Bacecab, null);
    Pdatos.add (pro_indiiE1, null);
    Pdatos.add (cLabel8, null);
    Pdatos.add (pro_indiiE, null);
    Pdatos.add (cLabel9, null);
    cPanel1.setLayout (gridBagLayout1);
    cLabel1.setToolTipText ("");
    cLabel1.setText ("Almacen Origen");
    cLabel1.setBounds (new Rectangle (26, 6, 93, 17));
    cLabel2.setText ("Almacen Final");
    cLabel2.setBounds (new Rectangle (26, 28, 85, 17));
    alm_codioE.setBounds (new Rectangle (120, 6, 288, 17));
    alm_codifE.setBounds (new Rectangle (118, 28, 289, 17));
    pro_codiE.setAncTexto (50);
    pro_codiE.setBounds (new Rectangle (54, 49, 408, 18));
    cLabel3.setText ("Producto");
    cLabel3.setBounds (new Rectangle (2, 48, 51, 19));
    cLabel4.setText ("Ejercicio");
    cLabel4.setBounds (new Rectangle (46, 70, 51, 17));
    eje_numeE.setBounds (new Rectangle (102, 70, 33, 17));
    cLabel5.setText ("Empresa");
    cLabel5.setBounds (new Rectangle (144, 70, 55, 17));
    emp_codiE.setBounds (new Rectangle (204, 70, 21, 17));
    cLabel6.setText ("Serie");
    cLabel6.setBounds (new Rectangle (234, 70, 33, 17));
    cLabel7.setText ("Numero Lote");
    cLabel7.setBounds (new Rectangle (325, 70, 73, 17));
    pro_numlotE.setBounds (new Rectangle (405, 70, 36, 17));
    cLabel8.setText ("De individuo");
    cLabel8.setBounds (new Rectangle (168, 94, 71, 16));
    pro_indiiE.setBounds (new Rectangle (240, 94, 37, 17));
    cLabel9.setBounds (new Rectangle (282, 94, 67, 17));
    cLabel9.setText ("A individuo");
    pro_indiiE1.setBounds (new Rectangle (350, 94, 37, 17));
    Bacecab.setBounds (new Rectangle (390, 90, 77, 22));
    Bacecab.setBorderPainted (true);
    Pdatos.setBorder (BorderFactory.createLoweredBevelBorder ());
    Pdatos.setLayout (null);
    this.getContentPane ().add (cPanel1, BorderLayout.CENTER);
    this.getContentPane ().add (statusBar, BorderLayout.SOUTH);
    cPanel1.add (Pdatos, new GridBagConstraints (0, 0, 3, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (1, 2, 0, 1), 0, 0));
    cPanel1.add (jt, new GridBagConstraints (0, 1, 3, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets (0, 2, 0, 1), 0, 0));
    cPanel1.add (Bcancela, new GridBagConstraints (2, 3, 1, 1, 0.0, 0.0, GridBagConstraints.EAST, GridBagConstraints.NONE, new Insets (0, 0, 5, 30), 0, 0));
    cPanel1.add (Baceptar, new GridBagConstraints (0, 3, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (0, 30, 5, 0), 0, 1));
    cPanel1.add (cPanel2, new GridBagConstraints (1, 2, 1, 1, 1.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets (0, 0, 0, 0), 0, 0));
    cPanel2.add (numIndE, null);
    cPanel2.add (cLabel11, null);
    cPanel2.add (Kilos, null);
    cPanel2.add (kilosE, null);
}


-----Function Pair=323=-----==

void setSetting (String var, String val) {
    boolean autoCommit = true;
    try {
        autoCommit = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        settingsRmQry.setString (1, var);
        settingsRmQry.executeUpdate ();
        settingsInsQry.setString (1, var);
        settingsInsQry.setString (2, val);
        settingsInsQry.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            LOG.error (SQL_ERROR, e1);
        }
        LOG.error (SQL_ERROR, e);
    } finally {
        try {
            conn.setAutoCommit (autoCommit);
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


public static int getRandomID (int type) {
    int min = 0, max = 0;
    switch (type) {
        case TELLER :
            max = ntellers * tps - 1;
            break;
        case BRANCH :
            max = nbranches * tps - 1;
            break;
        case ACCOUNT :
            max = naccounts * tps - 1;
            break;
    }
    return (getRandomInt (min, max));
}


-----Function Pair=324=-----==

public List < String > resolveLanguageTextInBulk (List < Long > textId, String languageId) {
    if (textId == null) return null;
    List < String > results = new ArrayList < String > (textId.size ());
    if (languageId == null) languageId = defaultLanguageId;
    Session session = HibernateUtil.getDefaultSessionFactory ().getCurrentSession ();
    boolean commit = false;
    Transaction t = session.getTransaction ();
    if (! t.isActive ()) {
        commit = true;
        t.begin ();
    }
    try {
        String inList = null;
        for (Long tid : textId) {
            if (inList == null) inList = tid.toString ();
            else inList += "," + tid.toString ();
        }
        SQLQuery q = session.createSQLQuery ("SELECT text_id, language_id, text FROM " + translationTable + " WHERE text_id IN (" + inList + ") AND (language_id = '" + languageId + "' OR language_id = '" + defaultLanguageId + "');");
        Map < Long, String > mapping = new HashMap < Long, String > ();
        q.setFlushMode (FlushMode.MANUAL);
        q.addScalar ("text_id", Hibernate.LONG);
        q.addScalar ("language_id", Hibernate.STRING);
        q.addScalar ("text", Hibernate.STRING);
        List < Object [] > rs = q.list ();
        for (Object [] row : rs) {
            if (languageId.equals (row [1])) mapping.put ((Long) row [0], (String) row [2]);
            else if (! mapping.containsKey (row [0])) mapping.put ((Long) row [0], (String) row [2]);
        }
        for (Long tid : textId) {
            results.add (mapping.get (tid));
        }
        if (commit) t.commit ();
    } catch (HibernateException e) {
        e.printStackTrace ();
        if (commit) t.rollback ();
        return null;
    }
    return results;
}


public List getSlowSyncCommands (int messageSize, String pluginId) {
    try {
        List commands = new ArrayList ();
        String app = SyncContext.getInstance ().getApp ();
        List < MobileBean > allRecords = this.gateway.readAllRecords (pluginId);
        for (int i = 0; i < allRecords.size (); i ++) {
            MobileBean record = allRecords.get (i);
            commands.add (this.getCommand (record, messageSize, ServerSyncEngine.OPERATION_ADD));
            this.conflictEngine.startOptimisticLock (app, pluginId, record);
        }
        List deletedEntries = this.getChangeLog (SyncContext.getInstance ().getDeviceId (), pluginId, SyncContext.getInstance ().getApp (), ServerSyncEngine.OPERATION_DELETE);
        if (deletedEntries != null) {
            for (int entryCtr = 0; entryCtr < deletedEntries.size (); entryCtr ++) {
                ChangeLogEntry entry = (ChangeLogEntry) deletedEntries.get (entryCtr);
                Delete delete = new Delete ();
                Item item = new Item ();
                item.setData (this.gateway.marshalId (entry.getRecordId ()));
                delete.getItems ().add (item);
                commands.add (delete);
            }
        }
        return commands;
    } catch (Exception e) {
        throw new SyncException (e);
    }
}


-----Function Pair=325=-----==

protected void executeQuery (Connection connection, DataQuery query, ISelection selection) throws DataServiceException {
    try {
        if (DataAccessManager.getManager ().getAccessLevel (query.getEntityDescriptor ()) == DataAccessManager.NONE) throw new SecurityException ("No read access for " + query.getEntityDescriptor () + " entities!");
        PreparedStatement statement = mSQLToolKit.buildSelectStatement (query.getEntityDescriptor (), query.getQualifier (), connection);
        ResultSet set = statement.executeQuery ();
        IEntity entity;
        while (set.next ()) {
            entity = query.getEntityDescriptor ().createEntity ();
            this.readResultSetRow (set, entity, true);
            entity.setStatusFlag (IEntity.PERSISTENT);
            entity.clearStatusFlag (IEntity.DIRTY | IEntity.EMPTY);
            if (DataAccessManager.getManager ().hasReadAccess (entity)) selection.addEntity (entity);
        }
        set.close ();
    } catch (SQLException e) {
        throw new DataServiceException ("Select command failed", e);
    }
}


public List findByExample (Object instance, String order, String dir) throws Exception {
    try {
        Criteria criteria = getSession ().createCriteria (instance.getClass ().getName ());
        if (Constants.ORDER_ASC.equals (dir)) {
            criteria.addOrder (Order.asc (order));
        }
        else {
            criteria.addOrder (Order.desc (order));
        }
        Example example = Example.create (instance).excludeZeroes ().ignoreCase ().enableLike ();
        List results = criteria.add (example).list ();
        return results;
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=326=-----==

public void incluir (Local local) throws Exception {
    Connection connection = criaConexao (false);
    String sql = "insert into local select nextval('local_idlocal_seq') as idlocal, ? as numlocal,  ? as nome, ? as idbairro";
    PreparedStatement stmt = null;
    try {
        stmt = connection.prepareStatement (sql);
        stmt.setInt (1, local.getNumeroLocal ());
        stmt.setString (2, local.getNome ());
        stmt.setInt (3, local.getBairro ().getIdBairro ());
        int retorno = stmt.executeUpdate ();
        if (retorno == 0) {
            connection.rollback ();
            throw new SQLException ("Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!");
        }
        connection.commit ();
    } catch (SQLException e) {
        connection.rollback ();
        throw e;
    } finally {
        try {
            stmt.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
}


public static final boolean hasAlert (long accountId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select count(*) from Alert R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, accountId);
        Integer count = (Integer) q.uniqueResult ();
        return count > 0;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=327=-----=1=

public void deletePortletName (PortletNameBean portletNameBean) {
    DatabaseAdapter dbDyn = null;
    PreparedStatement ps = null;
    try {
        dbDyn = DatabaseAdapter.getInstance ();
        if (portletNameBean.getPortletId () == null) throw new IllegalArgumentException ("portletNameId is null");
        String sql = "delete from  WM_PORTAL_PORTLET_NAME " + "where  ID_SITE_CTX_TYPE=?";
        ps = dbDyn.prepareStatement (sql);
        RsetTools.setLong (ps, 1, portletNameBean.getPortletId ());
        int i1 = ps.executeUpdate ();
        if (log.isDebugEnabled ()) log.debug ("Count of deleted records - " + i1);
        dbDyn.commit ();
    } catch (Exception e) {
        try {
            dbDyn.rollback ();
        } catch (Exception e001) {
        }
        String es = "Error delete portlet name";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (dbDyn, ps);
        dbDyn = null;
        ps = null;
    }
}


public void updateRole (AuthSession authSession, RoleBean roleBean) {
    DatabaseAdapter dbDyn = null;
    PreparedStatement ps = null;
    try {
        dbDyn = DatabaseAdapter.getInstance ();
        String sql = "update WM_AUTH_ACCESS_GROUP " + "set    NAME_ACCESS_GROUP=? " + "WHERE  ID_ACCESS_GROUP=? ";
        ps = dbDyn.prepareStatement (sql);
        ps.setString (1, roleBean.getName ());
        ps.setLong (2, roleBean.getRoleId ());
        int i1 = ps.executeUpdate ();
        if (log.isDebugEnabled ()) log.debug ("Count of updated record - " + i1);
        dbDyn.commit ();
    } catch (Exception e) {
        try {
            if (dbDyn != null) dbDyn.rollback ();
        } catch (Exception e001) {
        }
        String es = "Error save role";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (dbDyn, ps);
        dbDyn = null;
        ps = null;
    }
}


-----Function Pair=328=-----==

public void store (TopicArea topicArea) throws SQLException {
    String insertQuery = "insert into fs.topic_area (id, forum, name, uid, charset) values (?, ?, ?, ?, ?)";
    String updateQuery = "update fs.topic_area set forum = ?, name = ?, uid = ?, charset = ? where id = ?";
    ensureConnection ();
    PreparedStatement statement = null;
    ResultSet keys = null;
    Savepoint savepoint = null;
    try {
        savepoint = m_connection.setSavepoint ();
        if (! hasInDatabase (topicArea)) {
            statement = m_connection.prepareStatement (insertQuery);
            if (topicArea.getDatabaseID () == null) statement.setNull (1, Types.NUMERIC);
            else statement.setLong (1, topicArea.getDatabaseID ());
            statement.setString (2, topicArea.getForum ().getName ());
            statement.setString (3, topicArea.getName ());
            statement.setString (4, topicArea.getIdentifier ());
            statement.setString (5, topicArea.getCharset ());
            int count = statement.executeUpdate ();
            if (0 == count) throw new SQLException ("Nothing updated.");
            if (topicArea.getDatabaseID () == null) {
                keys = statement.getGeneratedKeys ();
                if (keys.next ()) topicArea.setDatabaseID (keys.getLong (1));
                else throw new SQLException ("No key found.");
            }
        }
        else {
            statement = m_connection.prepareStatement (updateQuery);
            statement.setLong (5, topicArea.getDatabaseID ());
            statement.setString (1, topicArea.getForum ().getName ());
            statement.setString (2, topicArea.getName ());
            statement.setString (3, topicArea.getIdentifier ());
            statement.setString (4, topicArea.getCharset ());
            int count = statement.executeUpdate ();
            if (0 == count) throw new SQLException ("Nothing updated.");
        }
        m_connection.commit ();
    } catch (SQLException e) {
        m_connection.rollback (savepoint);
        throw e;
    } finally {
        if (null != keys) {
            try {
                keys.close ();
            } catch (SQLException _) {
            }
        }
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


public void insertProfile () throws ClassNotFoundException, SQLException {
    Connection connection = null;
    PreparedStatement ps1 = null;
    PreparedStatement ps2 = null;
    PreparedStatement ps3 = null;
    try {
        Class.forName ("com.mysql.jdbc.Driver");
        connection = DriverManager.getConnection (this.url);
        connection.setAutoCommit (false);
        String query1 = "INSERT INTO customers(name,password) VALUES(?,?)";
        ps1 = connection.prepareStatement (query1);
        ps1.setString (1, this.name);
        ps1.setString (2, this.password);
        String query2 = "INSERT INTO customer_roles(name,role_name) VALUES(?,?)";
        ps2 = connection.prepareStatement (query2);
        ps2.setString (1, this.name);
        ps2.setString (2, "user");
        String query3 = "INSERT INTO customers_profile(name,first_name,middle_name,last_name,address1,address2,city,post_box,email,country)" + "VALUES(?,?,?,?,?,?,?,?,?,?)";
        ps3 = connection.prepareStatement (query3);
        ps3.setString (1, this.name);
        ps3.setString (2, this.firstName);
        ps3.setString (3, this.middleName);
        ps3.setString (4, this.lastName);
        ps3.setString (5, this.address1);
        ps3.setString (6, this.address2);
        ps3.setString (7, this.city);
        ps3.setString (8, this.postBox);
        ps3.setString (9, this.email);
        ps3.setString (10, this.country);
        ps1.executeUpdate ();
        ps2.executeUpdate ();
        ps3.executeUpdate ();
        connection.commit ();
    } catch (Exception ex) {
        connection.rollback ();
    } finally {
        try {
            this.connection.close ();
        } catch (Exception ex) {
        }
        try {
            ps1.close ();
        } catch (Exception ex) {
        }
        try {
            ps2.close ();
        } catch (Exception ex) {
        }
        try {
            ps3.close ();
        } catch (Exception ex) {
        }
    }
}


-----Function Pair=329=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public List < Transaction > getChildTransactions (long uid, long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Transaction R where R.initiatorId=? and R.parentTxId=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setLong (1, txId);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=330=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query with parameter ***");
        querywithparameter (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=331=-----==

public UserWorkloadReportDocument getUserWorkloadReport (String userWorkloadReportDocument) {
    DBHelper helper = null;
    ResultSet rsReport = null;
    UserWorkloadReportDocument in = null, out = null;
    try {
        helper = new DBHelper ();
        in = UserWorkloadReportDocument.Factory.parse (userWorkloadReportDocument);
        PreparedStatement psReport = helper.prepareStatement (SQL.getUserWorkloadReport ());
        psReport.setLong (1, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getDateFrom ());
        psReport.setLong (2, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getDateTo ());
        psReport.setString (3, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getHospitalno ());
        psReport.setLong (4, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getDateFrom ());
        psReport.setLong (5, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getDateTo ());
        psReport.setString (6, in.getUserWorkloadReport ().getUserWorkloadReportArray (0).getHospitalno ());
        rsReport = psReport.executeQuery ();
        out = UserWorkloadReportDocument.Factory.newInstance ();
        out.addNewUserWorkloadReport ();
        while (rsReport.next ()) {
            UserWorkloadReport uu = out.getUserWorkloadReport ().addNewUserWorkloadReport ();
            uu.setType (rsReport.getString ("TYPE"));
            uu.setTitle (rsReport.getString ("TITLE"));
            uu.setName (rsReport.getString ("NAME"));
            uu.setSurname (rsReport.getString ("SURNAME"));
            uu.setCount (new BigInteger (String.valueOf (rsReport.getInt ("COUNT"))));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsReport != null) {
                rsReport.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return out;
}


private Vector getCourseList () throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        {
            r.clear ();
            r.add ("course_id");
            r.add ("course_code");
            r.add ("course_name");
            sql = r.getSQLSelect ("study_course");
            ResultSet rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("id", rs.getString ("course_id"));
                h.put ("code", rs.getString ("course_code"));
                h.put ("name", rs.getString ("course_name"));
                list.addElement (h);
            }
            return list;
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=332=-----==

public String [] [] getWorktypes (String lang) throws SQLException {
    Statement stmt = conn.createStatement ();
    ResultSet rset = stmt.executeQuery ("SELECT COUNT(*) FROM funcs;");
    rset.next ();
    int nOfF = rset.getInt ("COUNT(*)");
    String [] [] result = new String [nOfF] [2];
    rset = stmt.executeQuery ("SELECT number, " + lang + " FROM funcs;");
    int i = 0;
    while (rset.next ()) {
        int number = rset.getInt ("number");
        result [i] [0] = (number < 10 ? " " : "") + number;
        result [i] [1] = rset.getString (lang);
        i ++;
    }
    return result;
}


public int getUseridForgivenName (String username) throws Exception {
    int id = 0;
    Session session = null;
    Transaction tx = null;
    Users us = new Users ();
    try {
        setUp ();
        session = HibernateUtil.getSessionFactory ().openSession ();
        tx = session.beginTransaction ();
        List tmpUsers = this.session.createCriteria (Users.class).add (Restrictions.eq ("user_name", username)).list ();
        for (Iterator iter = tmpUsers.iterator (); iter.hasNext ();) {
            us = (Users) iter.next ();
            if (tmpUsers.size () == 1) {
                id = us.getId ().intValue ();
            }
            tx.commit ();
            session.close ();
        }
    } catch (Exception e) {
        logger.error ("EXCEPTION While update user", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
    return id;
}


-----Function Pair=333=-----==

public void setup () throws SQLException {
    logger = Logger.getMyLogger (this.getClass ().getName ());
    try {
        localIPAddress = InetAddress.getLocalHost ().getHostAddress ();
    } catch (Exception e) {
        localIPAddress = "localhost";
    }
    ConnectionWrapper wrapper = getConnectionWrapper ();
    Connection conn = wrapper.getConnection ();
    try {
        conn.setAutoCommit (false);
    } catch (Exception e) {
        if (logger.isLoggable (Logger.WARNING)) {
            logger.log (Logger.WARNING, "Disabling auto-commit failed.");
        }
    }
    if (cleanTables) {
        dropDFTables ();
    }
    createDFTables ();
    tablesReady = true;
    PreparedStatements ps = new PreparedStatements (conn);
    wrapper.setInfo (ps);
    clean ();
}


public Boolean isCandidatoAtividade (IUsuario usuario, Atividade atividade) throws SQLException {
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Atividade_has_recurso_humano where usuario_idusuario = " + usuario.getIdUsuario ();
        usuario = null;
        ResultSet rs = stmt.executeQuery (sqlSelect);
        while (rs.next ()) {
            return true;
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return false;
}


-----Function Pair=334=-----==

public Long removeAllEntities () {
    long numberOfEntitiesRemoved = 0;
    final EntityManager entityManager = getEntityManager ();
    EntityTransaction tx = null;
    try {
        synchronized (this) {
            tx = entityManager.getTransaction ();
            if (! tx.isActive ()) {
                tx.begin ();
            }
        }
        final Query query = entityManager.createQuery ("delete from java.lang.Object");
        numberOfEntitiesRemoved = query.executeUpdate ();
        tx.commit ();
    } catch (Exception e) {
        if (tx != null && tx.isActive ()) {
            tx.rollback ();
        }
        log.error ("Removal of entities failed", e);
    }
    log.debug (numberOfEntitiesRemoved + " entities removed");
    return numberOfEntitiesRemoved;
}


public void setSuspended (String jobid) {
    Session session = sessionFactory.openSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query update = session.createQuery ("update Task task " + "set task.suspended = :suspended" + " where task.jobid = :jobid");
        update.setParameter ("suspended", "yes");
        update.setParameter ("jobid", jobid);
        update.executeUpdate ();
        session.flush ();
        session.clear ();
        tx.commit ();
    } catch (RuntimeException e) {
        tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
}


-----Function Pair=335=-----==

static void startThreads (Connection con) throws Exception {
    TestMultiThread.con = con;
    con.setAutoCommit (false);
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #TEST (id int identity primary key, data varchar(255))");
    for (int i = 0; i < ROWS_MAX; i ++) {
        stmt.executeUpdate ("INSERT INTO #TEST (data) VALUES('This is line " + i + "')");
    }
    stmt.close ();
    con.commit ();
    live = THREAD_MAX;
    for (int i = 0; i < THREAD_MAX; i ++) {
        new TestMultiThread (i).start ();
    }
    while (live > 0) {
        sleep (1);
    }
    if (error != null) {
        throw error;
    }
}


public void update (Department obj) throws UpdateException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria newCrit = new Criteria ();
    newCrit.addCriterion ("DEPARTMENT_NAME", obj.getName ());
    newCrit.addCriterion ("DEPARTMENT_DESCRIPTION", obj.getDescription ());
    newCrit.addCriterion ("DEPARTMENT_ACRONYM", obj.getAcronym ());
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("DEPARTMENT_ID", obj.getId ());
    try {
        stmt.executeUpdate (new UpdateQuery (DepartmentDAO.TABLE_NAME, newCrit, critWhere).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new UpdateException (TABLE_NAME + " Update exception", e);
    }
}


-----Function Pair=336=-----==

public int hashCode (String rank) throws FidoDatabaseException, ClassificationNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Pattern, GrammarString, ObjectId, Description " + "from WordClassifications where Rank = " + rank;
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            if (rs.next () == false) throw new ClassificationNotFoundException (rank);
            list.add (rs.getString (1));
            list.add (rs.getString (2));
            list.add (rs.getString (3));
            list.add (rs.getString (4));
            return list.hashCode ();
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


private Retailer create () throws SQLException, IOException {
    Connection conn = null;
    Statement st = null;
    String query = null;
    ResultSet rs = null;
    try {
        conn = dataSource.getConnection ();
        st = conn.createStatement ();
        query = "insert into " + DB.Tbl.ret + "(" + col.title + "," + col.addDate + "," + col.authorId + ") " + "values('" + title + "',now()," + user.getId () + ")";
        st.executeUpdate (query, new String [] {col.id});
        rs = st.getGeneratedKeys ();
        if (! rs.next ()) {
            throw new SQLException ("Не удается получить generated key 'id' в таблице retailers.");
        }
        int genId = rs.getInt (1);
        rs.close ();
        saveDescr (genId);
        conn.commit ();
        Retailer ret = new Retailer ();
        ret.setId (genId);
        ret.setTitle (title);
        ret.setDescr (descr);
        RetailerViewer.getInstance ().somethingUpdated ();
        return ret;
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (Exception e1) {
        }
        throw e;
    } finally {
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            st.close ();
        } catch (Exception e) {
        }
        try {
            conn.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=337=-----==

private final void loadOntologies (String descrId, DFAgentDescription dfd, Map allOntologies) throws SQLException {
    if (allOntologies != null) {
        List ontos = (List) allOntologies.get (descrId);
        if (ontos != null) {
            Iterator it = ontos.iterator ();
            while (it.hasNext ()) {
                dfd.addOntologies ((String) it.next ());
            }
        }
    }
    else {
        PreparedStatements pss = getPreparedStatements ();
        pss.stm_selOntologies.setString (1, descrId);
        ResultSet rs = pss.stm_selOntologies.executeQuery ();
        while (rs.next ()) {
            dfd.addOntologies (rs.getString (ONTOLOGY));
        }
        closeResultSet (rs);
    }
}


public List getChatRooms () {
    DBConnection con = null;
    List Rooms = new ArrayList ();
    try {
        con = DBServiceManager.allocateConnection ();
        String query = "SELECT cafe_Chat_Category_id, cafe_Chat_Category_icon, " + "cafe_chatroom_name, cafe_chatroom_stringid, cafe_chatroom_category, " + "cafe_chatroom_id " + "FROM cafe_Chat_Category, cafe_Chatroom " + "WHERE cafe_Chat_Category_id = cafe_chatroom_category ";
        PreparedStatement ps = con.prepareStatement (query);
        ResultSet rs = ps.executeQuery ();
        boolean more = rs.next ();
        while (more) {
            AdminChatObject ao = new AdminChatObject ();
            ao.setcafe_chat_category_id (rs.getInt ("cafe_Chat_Category_id"));
            ao.setcafe_chatroom_category (rs.getInt ("cafe_chatroom_category"));
            ao.setchatRoomName (rs.getString ("cafe_chatroom_name"));
            ao.setcafe_Chat_Category_icon (rs.getString ("cafe_Chat_Category_icon"));
            ao.setcafe_chatroom_id (rs.getInt ("cafe_chatroom_id"));
            ao.setcafe_chatroom_stringid (rs.getString ("cafe_chatroom_stringid"));
            Rooms.add (ao);
            more = rs.next ();
        }
    } catch (SQLException e) {
    } finally {
        if (con != null) con.release ();
    }
    return Rooms;
}


-----Function Pair=338=-----==

public List getObjectList (Query query) {
    Session session = getSession ();
    List results = null;
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        results = query.list ();
        tx.commit ();
        tx = null;
    } catch (HibernateException e) {
        if (tx != null) tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
    return results;
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=339=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        Person jesse = null;
        Person anne = null;
        for (Person person : collection) {
            if ("Jesse".equals (person.getFirstName ())) {
                jesse = person;
            }
            else if ("Anne".equals (person.getFirstName ())) {
                anne = person;
            }
        }
        anne.getFriends ().add (jesse);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void updatewithlockexception (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager1 = entityManagerFactory.createEntityManager ();
    EntityManager entityManager2 = entityManagerFactory.createEntityManager ();
    try {
        entityManager1.getTransaction ().begin ();
        entityManager2.getTransaction ().begin ();
        Query query1 = entityManager1.createQuery ("SELECT p FROM Person p");
        query1.setHint (QueryHints.PESSIMISTIC_LOCK, PessimisticLock.LockNoWait);
        Query query2 = entityManager2.createQuery ("SELECT p FROM Person p");
        query2.setHint (QueryHints.PESSIMISTIC_LOCK, PessimisticLock.LockNoWait);
        Collection < Person > collection1 = (Collection < Person >) query1.getResultList ();
        for (Person person : collection1) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        Collection < Person > collection2 = (Collection < Person >) query2.getResultList ();
        for (Person person : collection2) {
            person.setFirstName (person.getFirstName () + "-1");
        }
    } catch (DatabaseException e) {
    } finally {
        if (! entityManager1.getTransaction ().getRollbackOnly ()) {
            entityManager1.getTransaction ().commit ();
        }
        if (! entityManager2.getTransaction ().getRollbackOnly ()) {
            entityManager2.getTransaction ().commit ();
        }
        if (entityManager1.getTransaction ().isActive ()) {
            entityManager1.getTransaction ().rollback ();
        }
        if (entityManager2.getTransaction ().isActive ()) {
            entityManager2.getTransaction ().rollback ();
        }
        entityManager1.close ();
        entityManager2.close ();
    }
}


-----Function Pair=340=-----==

public Map < String, Client > loadClientsByPhone (String phone) throws MyHibernateException {
    Session session = HibernateUtil.getCurrentSession ();
    Map < String, Client > map = new HashMap < String, Client > ();
    List < Client > clients = null;
    Transaction transaction = null;
    try {
        transaction = session.beginTransaction ();
        clients = clientDAO.loadClientsByPhone (session, phone);
        transaction.commit ();
    } catch (RuntimeException ex) {
        if (transaction != null) {
            transaction.rollback ();
        }
        if (ex instanceof HibernateException) {
            throw new MyHibernateException ((HibernateException) ex);
        }
        throw ex;
    } finally {
        if (session != null && session.isOpen ()) {
            session.close ();
        }
    }
    for (Client client : clients) {
        map.put (client.getName (), client);
    }
    return map;
}


public RestServiceResult searchByExercises (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixExercises1.search.notFound"));
    }
    else {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_MATRIX_EXERCISES1, CoMatrixExercises1.class);
        query.setParameter (1, nExerciseId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        List < CoMatrixExercises1 > list = query.getResultList ();
        if (list.size () > 0) {
            Object [] arrayParam = {list.size ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises1.search.success"), arrayParam));
            serviceResult.setObjResult (list);
            serviceResult.setNumResult (list.size ());
        }
        else {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("matrixExercises1.search.notFound"));
        }
    }
    return serviceResult;
}


-----Function Pair=341=-----==

public user getAddress (String name) {
    user myuser = new user ();
    try {
        PreparedStatement stmt = con.prepareStatement ("Select * from user where uname= ?");
        stmt.setString (1, name);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                myuser.setUid (rs.getInt ("uid"));
                myuser.setUname (rs.getString ("uname"));
                myuser.setUemail (rs.getString ("uemail"));
                myuser.setUaddr (rs.getString ("uaddr"));
                myuser.setUcontact (rs.getString ("ucontact"));
            }
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return myuser;
}


public void update (ClassRoom obj) throws DBConnectionException, XmlIOException, UpdateException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria newCrit = new Criteria ();
    newCrit.addCriterion ("CLASSROOM_NAME", obj.getName ());
    newCrit.addCriterion ("CLASSROOM_CAPACITY", obj.getCapacity ());
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("CLASSROOM_ID", obj.getId ());
    try {
        stmt.executeUpdate (new UpdateQuery (TABLE_NAME, newCrit, critWhere).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new UpdateException (TABLE_NAME + " Update exception", e);
    }
}


-----Function Pair=342=-----==

public static void querywithfetchplan (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        ReadAllQuery raq = (ReadAllQuery) ((JpaQuery) query).getDatabaseQuery ();
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends"));
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("friends").anyOfAllowingNone ("friends"));
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getFriends ()) {
                System.out.println ("\twith friend: " + person1);
                for (Person person2 : person1.getFriends ()) {
                    System.out.println ("\t\twith friend: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


public static PhotoOutlineBean getPrevPhoto (SiteBean site, SessionUserObject user, int album_id, int photo_id) {
    if (site == null) return null;
    boolean is_owner = site.isOwner (user);
    StringBuffer hql = new StringBuffer ("FROM PhotoOutlineBean AS p WHERE p.status=:photo_status AND p.site.id=:site AND p.id<:photo");
    if (! is_owner) {
        hql.append (" AND p.album.type=:album_type");
    }
    if (album_id > 0) {
        hql.append (" AND p.album.id=:album");
    }
    hql.append (" ORDER BY p.id DESC");
    Session ssn = getSession ();
    try {
        Query q = ssn.createQuery (hql.toString ());
        q.setInteger ("photo_status", PhotoBean.STATUS_NORMAL);
        q.setInteger ("site", site.getId ());
        q.setInteger ("photo", photo_id);
        if (album_id > 0) q.setInteger ("album", album_id);
        if (! is_owner) q.setInteger ("album_type", AlbumBean.TYPE_PUBLIC);
        q.setMaxResults (1);
        return (PhotoOutlineBean) q.uniqueResult ();
    } finally {
        hql = null;
    }
}


-----Function Pair=343=-----==

public void sendRequest (Message message, WCAChannel destination) throws NotFoundException, SQLException {
    createPropertyTable (destination);
    System.out.println ("message = " + message.getTimestamp ());
    Map < String, Property > properties = _propertiesMap.get (destination);
    StringBuffer propertiesTuple = new StringBuffer ();
    propertiesTuple.append ("'").append (message.getID ().toString ()).append ("'");
    for (Property property : properties.values ()) {
        Object value = "";
        try {
            value = "REFACTORED AWAY";
        } catch (Exception e) {
            _logger.error (e);
            e.printStackTrace ();
        }
        propertiesTuple.append (",'").append (value).append ("'");
    }
    Session session = HibernateUtil.getSessionFactory ().openSession ();
    Connection con = session.connection ();
    Statement statement = con.createStatement ();
    System.out.print ("Tablename = " + getTableName (destination) + " : ");
    System.out.println ("propertiesTuple = " + propertiesTuple);
    statement.executeUpdate (insertRow.format (new Object [] {getTableName (destination), propertiesTuple}));
    con.commit ();
    session.close ();
}


public int add (String word, String grammarString, int objectId) throws FidoDatabaseException, GrammarLinkNotFoundException, GrammarParseException, ObjectNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            BooleanTree tmp = GrammarExpressions.parseExpression (grammarString);
            ObjectTable ot = new ObjectTable ();
            if (ot.contains (objectId) == false) throw new ObjectNotFoundException (objectId);
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            int row = max (stmt, word);
            String sql = "insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) " + "values ('" + word + "', " + row + ", '" + grammarString + "', " + objectId + ")";
            stmt.executeUpdate (sql);
            return row;
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=344=-----==

public int current () {
    int sequenceValue = - 1;
    try {
        Select select = dbi.getSelect ();
        select.setTableName (sequenceTable);
        select.column ("SEQUENCE_VALUE");
        Search search = new Search ();
        search.addAttributeCriteria (sequenceTable, "SEQUENCE_NAME", Search.EQUAL, sequenceName);
        select.where (search);
        ResultSet result = dbi.getConnection ().createStatement ().executeQuery (select.toString ());
        if (result.next ()) {
            sequenceValue = result.getInt ("SEQUENCE_VALUE");
        }
    } catch (SQLException sqle) {
        System.err.println ("SQLException occurred in current(): " + sqle.getMessage ());
    }
    return sequenceValue;
}


public event retrieveByEvent_id (int event_id) {
    event e = null;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("Select * from event where event_id = ?");
        stmt.setInt (1, event_id);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                e = new event (rs.getString ("event_name"), rs.getString ("event_date"), rs.getString ("event_time"), rs.getString ("status"), rs.getString ("event_descritpion"), rs.getString ("group_name"));
            }
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return e;
}


-----Function Pair=345=-----==

public boolean deleteEvent (int event_id) {
    boolean result = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("delete from event where event_id=?");
        stmt.setInt (1, event_id);
        int num = stmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return result;
}


public void updateStatusTimedOut (long alarmId) throws HibernateException {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Alarm al = (Alarm) session.get (Alarm.class, alarmId);
        al.setStatus (2);
        session.update (al);
        tx.commit ();
    } catch (HibernateException e) {
        tx.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}


-----Function Pair=346=-----==

public void saveRecordMap (String source, String target, Map recordMap) {
    if (recordMap != null) {
        Set guids = recordMap.keySet ();
        Session session = this.hibernateManager.getSessionFactory ().getCurrentSession ();
        Transaction tx = session.beginTransaction ();
        try {
            for (Iterator itr = guids.iterator (); itr.hasNext ();) {
                Object guid = itr.next ();
                Object luid = recordMap.get (guid);
                RecordMap entry = new RecordMap ();
                entry.setGuid (guid);
                entry.setLuid (luid);
                entry.setSource (source);
                entry.setTarget (target);
                session.save (entry);
            }
            tx.commit ();
        } catch (Exception e) {
            tx.rollback ();
            throw new SyncException (e);
        }
    }
}


private void updateClobs (Connection cn, ResultSet node, ArrayList clobs) throws SQLException, IOException {
    final String static_query = " WHERE \"SCHEMA\"=? AND TABLENAME=? AND OBJECTNAME=? AND OBJECTTYPE=?  ";
    StringBuffer sb = new StringBuffer ("SELECT ");
    for (short i = 0; i < clobs.size (); i ++) {
        if (i > 0) {
            sb.append (',');
        }
        sb.append ("\"").append (node.getMetaData ().getColumnName (((Integer) clobs.get (i)).intValue ())).append ("\"");
    }
    sb.append (" FROM NGTDIC ").append (static_query);
    PreparedStatement clobpstm = cn.prepareStatement (sb.toString ());
    clobpstm.setString (1, node.getString ("SCHEMA"));
    clobpstm.setString (2, node.getString ("TABLENAME"));
    clobpstm.setString (3, node.getString ("OBJECTNAME"));
    clobpstm.setString (4, node.getString ("OBJECTTYPE"));
    ResultSet clobrslt = clobpstm.executeQuery ();
    if (clobrslt.next ()) {
        for (byte y = 0; y < clobs.size (); y ++) {
            Clob clob = clobrslt.getClob (y + 1);
            clob.truncate (0);
            String strclob = node.getString (((Integer) clobs.get (y)).intValue ());
            clob.setString (1, strclob);
        }
        clobrslt.close ();
        clobpstm.close ();
    }
}


-----Function Pair=347=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nCheckListFormId) {
    MaParagraphCheckList maSingleParagraphCheckList = new MaParagraphCheckListDAO ().findById (nCheckListFormId);
    if (maSingleParagraphCheckList == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("checkList.search.notFound"));
    }
    else {
        List < MaParagraphCheckList > list = new ArrayList < MaParagraphCheckList > ();
        EntityManagerHelper.refresh (maSingleParagraphCheckList);
        list.add (maSingleParagraphCheckList);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nSingleTextFormId) {
    MaSingleTextForm maSingleTextForm = new MaSingleTextFormDAO ().findById (nSingleTextFormId);
    if (maSingleTextForm == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("singleTextForm.search.notFound"));
    }
    else {
        List < MaSingleTextForm > list = new ArrayList < MaSingleTextForm > ();
        EntityManagerHelper.refresh (maSingleTextForm);
        list.add (maSingleTextForm);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("singleTextForm.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=348=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT g FROM Group g");
        Collection < Group > collection = (Collection < Group >) query.getResultList ();
        for (Group group : collection) {
            System.out.println ("found: " + group);
            for (User user : group.getUsers ()) {
                System.out.println ("  with: " + user);
            }
        }
    } finally {
        entityManager.close ();
    }
}


public RestServiceResult update (RestServiceResult serviceResult, List listWordsComleteE3, Long nCompleteId) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_COMPLETE3_WORD);
        query.setParameter (1, new Long (nCompleteId));
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        if (listWordsComleteE3 != null) {
            for (int i = 0; i < listWordsComleteE3.size (); i ++) {
                CoWordsCompleteE3 coWordsCompleteE3 = (CoWordsCompleteE3) listWordsComleteE3.get (i);
                serviceResult = this.create (serviceResult, coWordsCompleteE3);
            }
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar las palabras: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=349=-----==

private static void insertanddetach (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    Group group = new Group ();
    try {
        entityManager.getTransaction ().begin ();
        User user1 = new User ();
        user1.setId (0);
        user1.setName ("root");
        User user2 = new User ();
        user2.setId (1000);
        user2.setName ("joanna");
        group.setId (100);
        group.setName ("mysql");
        group.getUsers ().add (user1);
        group.getUsers ().add (user2);
        entityManager.persist (group);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
    detachedGroup = group;
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=350=-----==

public boolean findByFindPorperty (Words words) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Words as w where w.find like :find");
        query.setString ("find", words.getFind ());
        List list = query.list ();
        tr.commit ();
        if (list.size () > 0) {
            return true;
        }
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
            tr = null;
        }
        he.printStackTrace ();
    }
    return false;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=351=-----==

public ResultSet executeQuery (String query, int resultSetType, int resultSetConcurrency) throws WatermillDbConnectionException {
    try {
        Statement stm = getConnection ().createStatement (resultSetType, resultSetConcurrency);
        logger.debug (query);
        Chrono.setMode (Chrono.QUERY_MODE);
        if (stm.execute (query)) {
            java.sql.ResultSet rs = stm.getResultSet ();
            Chrono.setMode (Chrono.CPU_MODE);
            return rs;
        }
        else {
            Chrono.setMode (Chrono.CPU_MODE);
            return null;
        }
    } catch (SQLException e) {
        Chrono.setMode (Chrono.CPU_MODE);
        throw new WatermillDbConnectionException (e.getMessage ());
    }
}


public User getUser (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from User R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        User u = (User) q.uniqueResult ();
        s.getTransaction ().commit ();
        return u;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=352=-----==

public User findUser (String userId) throws HamboFatalException {
    DBConnection con = null;
    User user = null;
    try {
        con = DBServiceManager.allocateConnection ();
        String sql = "select " + TABLE_COLUMNS + "  from user_UserAccount where userid=?";
        PreparedStatement ps = con.prepareStatement (sql);
        ps.setString (1, userId);
        ResultSet rs = con.executeQuery (ps, null);
        if (rs.next ()) user = buildUser (rs);
    } catch (SQLException ex) {
        throw new HamboFatalException (MSG_SQL_FAILED, ex);
    } finally {
        if (con != null) {
            con.release ();
        }
    }
    return user;
}


private static String getPeriodRootId (String program_code) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("period_root_id");
        r.add ("program_code", program_code);
        sql = r.getSQLSelect ("program");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) return rs.getString ("period_root_id");
        else return "";
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=353=-----==

public static void criteriaquery (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        CriteriaBuilder cb = entityManagerFactory.getCriteriaBuilder ();
        CriteriaQuery < Person > query = cb.createQuery (Person.class);
        Root < Person > personR = query.from (Person.class);
        Predicate genderP = cb.equal (personR.get ("gender"), cb.literal (Gender.UNKNOWN));
        query.select (personR).where (genderP);
        Collection < Person > collection = entityManager.createQuery (query).getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
        }
    } finally {
        entityManager.close ();
    }
}


private void generateShipments_complete (ProcessInfo pi) {
    tabbedPane.setSelectedIndex (1);
    ProcessInfoUtil.setLogFromDB (pi);
    StringBuffer iText = new StringBuffer ();
    iText.append ("<b>").append (pi.getSummary ()).append ("</b><br>(").append (Msg.getMsg (Env.getCtx (), "InOutGenerateInfo")).append (")<br>").append (pi.getLogInfo (true));
    info.setText (iText.toString ());
    int [] ids = pi.getIDs ();
    if (ids == null || ids.length == 0) return;
    log.config ("PrintItems=" + ids.length);
    confirmPanelGen.getOKButton ().setEnabled (false);
    if (ADialog.ask (m_WindowNo, this, "PrintShipments")) {
        setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
        int retValue = ADialogDialog.A_CANCEL;
        do {
            for (int i = 0; i < ids.length; i ++) {
                int M_InOut_ID = ids [i];
                ReportCtl.startDocumentPrint (ReportEngine.SHIPMENT, M_InOut_ID, this, Env.getWindowNo (this), true);
            }
            ADialogDialog d = new ADialogDialog (m_frame, Env.getHeader (Env.getCtx (), m_WindowNo), Msg.getMsg (Env.getCtx (), "PrintoutOK?"), JOptionPane.QUESTION_MESSAGE);
            retValue = d.getReturnCode ();
        }
        while (retValue == ADialogDialog.A_CANCEL);
        setCursor (Cursor.getDefaultCursor ());
    }
    confirmPanelGen.getOKButton ().setEnabled (true);
}


-----Function Pair=354=-----==

public static void excluirMidia (final Connection con, final int cod) {
    try {
        con.setAutoCommit (false);
        Statement smt = con.createStatement ();
        ResultSet desc = smt.executeQuery ("SELECT codDescricao FROM midia WHERE " + "codMidia=" + cod);
        desc.next ();
        int codDesc = desc.getInt (1);
        smt.executeUpdate ("DELETE FROM midia WHERE codMidia=" + cod);
        smt.executeUpdate ("DELETE FROM descricao WHERE codDescricao=" + codDesc);
        con.commit ();
    } catch (SQLException e) {
        System.err.print (e.getMessage ());
    } finally {
        try {
            con.setAutoCommit (true);
        } catch (SQLException e2) {
            System.err.print (e2.getMessage ());
        }
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=355=-----==

public void batchAddAudioItemsToPlaylist (List < String > itemIds, String playlistId) throws ItemNotFoundException {
    AudioPlaylistDAO playlistDAO = factory.getAudioPlaylistDAO ();
    AudioItemDAO audioDAO = factory.getAudioItemDAO ();
    Transaction t = playlistDAO.beginTransaction ();
    try {
        HibernateAudioPlaylist playlist = transactionGetByID (playlistId, playlistDAO);
        for (String audioId : itemIds) {
            HibernateAudioItem item = transactionGetByID (audioId, audioDAO);
            playlist.addItem (item);
        }
        playlistDAO.update (playlist);
        playlistDAO.commitTransaction ();
    } catch (Exception e) {
        t.rollback ();
        logger.error ("Error adding items to playlist:", e);
        throw new ItemNotFoundException ("Couldnt find an id for playlist");
    }
}


public static void querywithfetchplan (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        ReadAllQuery raq = (ReadAllQuery) ((JpaQuery) query).getDatabaseQuery ();
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("subordinates"));
        raq.addJoinedAttribute (raq.getExpressionBuilder ().anyOfAllowingNone ("subordinates").anyOfAllowingNone ("subordinates"));
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getSubordinates ()) {
                System.out.println ("\twith subordinate: " + person1);
                for (Person person2 : person1.getSubordinates ()) {
                    System.out.println ("\t\twith subordinate: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=356=-----==

public List getDistinct () {
    Session sessao = getSession ().getCurrentSession ();
    Transaction transacao = sessao.beginTransaction ();
    List resultados = new ArrayList < Object > ();
    try {
        Criteria criteria = sessao.createCriteria (Reading.class);
        criteria.setProjection (Projections.distinct (Projections.projectionList ().add (Projections.property ("oid")).add (Projections.property ("variableName")).add (Projections.property ("task"))));
        resultados = criteria.list ();
        transacao.commit ();
    } catch (Exception e) {
        e.printStackTrace ();
        transacao.rollback ();
    }
    return resultados;
}


public final void saveOrUpdateAll (final Collection < ? extends T > objects) throws CannotConnectToDatabaseException {
    if (objects != null && ! objects.isEmpty ()) {
        final Session s = this.currentSession ();
        Transaction tx = null;
        try {
            tx = s.beginTransaction ();
            for (T obj : objects) {
                s.saveOrUpdate (obj);
            }
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (HibernateException he) {
            tx.rollback ();
            LOGGER.error ("Failed to save or update entities - transaction was rolled back.", he);
            throw he;
        } finally {
            s.close ();
        }
    }
}


-----Function Pair=357=-----==

public AcUser getSeller (Integer projectId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select p.viewer from " + AcDataProject.class.getName () + " p ");
        hqlSB.append (" where p.data.id = '" + projectId + "' and");
        hqlSB.append (" p.isSeller = true");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        if (! queryObject.iterate ().hasNext ()) {
            return null;
        }
        tx.commit ();
        return (AcUser) queryObject.iterate ().next ();
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public void alterarQuestaoMultiplaEscolha (QuestaoMultiplaEscolha q) throws SQLException {
    PreparedStatement stmt = null;
    String sql = "UPDATE multipla_escolha SET texto=?, gabarito=? WHERE id_questao=?";
    try {
        for (Alternativa alternativa : q.getAlternativa ()) {
            stmt = conexao.prepareStatement (sql);
            stmt.setString (1, alternativa.getTexto ());
            stmt.setBoolean (2, alternativa.getGabarito ());
            stmt.setInt (3, q.getIdQuestao ());
            stmt.executeUpdate ();
            conexao.commit ();
        }
    } catch (SQLException e) {
        conexao.rollback ();
        throw e;
    }
}


-----Function Pair=358=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=359=-----==

protected void executeUpdate (Connection connection, IEntity entity, Qualifier qualifier) throws DataServiceException {
    String sql = null;
    try {
        this.checkEntityAsStorable (entity);
        if (! entity.isDirty ()) {
            Log.printWarning (this, "Ignored update of non-dirty entity: " + entity);
            return;
        }
        sql = mSQLToolKit.buildUpdateCommand (entity, qualifier);
        Statement statement = connection.createStatement ();
        Log.print (this, "Performing Update: " + sql);
        int count = statement.executeUpdate (sql);
        if (count != 1) throw new DataServiceException ("Multiple update commands are dissabled, affect count " + count + " caused rejection.");
    } catch (SQLException e) {
        throw new DataServiceException ("Update command failed", e, sql);
    }
}


private static String findRelateKey (DbTableType table, String tableName) throws Exception {
    DbTableType relateTable = DatabaseManager.getTableFromStructure (dbSchema, tableName);
    if (relateTable == null) throw new Exception ("Target relate table '" + tableName + "' not found");
    DbTableType mainTable = table;
    System.out.println ("main - " + mainTable.getName () + ", relate - " + relateTable.getName ());
    for (int i = 0; i < mainTable.getImportedKeysCount (); i ++) {
        DbImportedPKColumnType fk = mainTable.getImportedKeys (i);
        System.out.println ("fk " + fk.getFkName () + ", " + fk.getFkTableName () + "." + fk.getFkColumnName () + "->" + fk.getPkTableName () + "." + fk.getPkColumnName ());
        if (fk.getPkTableName ().equals (relateTable.getName ())) return "get" + StringTools.capitalizeString (fk.getFkColumnName ()) + "()";
    }
    System.out.println ("main - " + relateTable.getName () + ", relate - " + mainTable.getName ());
    for (int i = 0; i < relateTable.getImportedKeysCount (); i ++) {
        DbImportedPKColumnType fk = relateTable.getImportedKeys (i);
        System.out.println ("fk " + fk.getFkName () + ", " + fk.getFkTableName () + "." + fk.getFkColumnName () + "->" + fk.getPkTableName () + "." + fk.getPkColumnName ());
        if (fk.getPkTableName ().equals (mainTable.getName ())) return "get" + StringTools.capitalizeString (fk.getFkColumnName ()) + "()";
    }
    throw new Exception ("relation for table '" + tableName + "' not found");
}


-----Function Pair=360=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setUniquePersonNumber ("1234-567");
        person.setUpnIssuer ("FRO-TX");
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void delete (Subject obj) throws DeleteException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria critDel = new Criteria ();
    critDel.addCriterion ("SUBJECT_ID", obj.getId ());
    try {
        stmt.executeUpdate (new DeleteQuery (TABLE_NAME, critDel).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new DeleteException (TABLE_NAME + " Deletion exception :", e);
    }
}


-----Function Pair=361=-----==

public static void delete (String name) {
    Session session = sessionFactory.openSession ();
    session.getTransaction ().begin ();
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        String hql = "delete from de.anhquan.demo.hibernate.helloworld.Order where name = :name";
        Query query = session.createQuery (hql);
        query.setParameter ("name", name);
        int row = query.executeUpdate ();
        if (row == 0) {
            System.out.println ("Doesn't deleted any row!");
        }
        else {
            System.out.println ("Deleted Row: " + row);
        }
        tx.commit ();
    } catch (RuntimeException e) {
        if (tx != null && tx.isActive ()) {
            try {
                tx.rollback ();
            } catch (HibernateException e1) {
                System.out.println ("Error rolling back transaction");
            }
            throw e;
        }
    }
}


public void testLoader2 () throws Exception {
    ClusterDescription cd = new ClusterDescription ();
    cd.setRootDescription (getClassDescription (Person.class));
    cd.setPathExpressions (new String [] {"root", "root.privatAdressen"});
    ClusterLoader clusterLoader = new ClusterLoader (getSchemaMapping (), cd);
    LoaderContext loaderContext = new LoaderContext (modificationTracker);
    List < Modifiable > result = (List < Modifiable >) clusterLoader.load (connection, loaderContext, ClusterLoaderConditionProvider.Default);
    Assert.assertEquals (result.size (), 2);
    Person aim = (Person) result.get (0);
    aim.getPrivatAdressen ().remove (0);
    aim.setName ("markus");
    Persistor p = new Persistor (getSchemaMapping (), idGenerator, modificationTracker);
    try {
        p.persist ();
        connection.commit ();
    } catch (Exception e) {
        connection.rollback ();
        throw e;
    }
}


-----Function Pair=362=-----==

public RestServiceResult update (RestServiceResult serviceResult, MaPostag maPostag) {
    MaPostagDAO maPostagDAO = new MaPostagDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        maPostagDAO.update (maPostag);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maPostag);
        Object [] args = {maPostag.getTag ()};
        if (bundle != null) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("postag.update.success"), args));
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el postag: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("postag.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public static int setStageFile (String messageID) throws Exception {
    log.debug ("Getting a New Stage File for message: " + messageID);
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Stage stageFile = new Stage ();
    stageFile.setMessageid (messageID);
    try {
        session.saveOrUpdate (stageFile);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception ("Error Getting a Stage File ID: " + e.getCause ().getMessage ());
    }
    return stageFile.getFileId ();
}


-----Function Pair=363=-----==

private void doAdd () {
    long start = new java.util.Date ().getTime ();
    boolean refsonly = Options.getCommandLineOption ("-refsonly", root.options ());
    boolean norefs = Options.getCommandLineOption ("-norefs", root.options ());
    if (! refsonly) {
        int apiId = Options.getCommandLineOption ("-api", root.options (), - 1);
        if (apiId == - 1) {
            log.error ("Failed to resolve api in db");
            return;
        }
        try {
            API api = API.makeAPIFor (conn, apiId);
            if (api == null || root.specifiedPackages ().length == 0) {
                log.error ("No api to add (or 0 packages)..exiting.");
                return;
            }
            populateAPI (api);
        } catch (SQLException ex) {
            log.error ("Failed to load api (id " + apiId + ") from db..");
            log.error ("SQLException: " + ex.getMessage ());
            return;
        }
    }
    long addtime = new java.util.Date ().getTime () - start;
    log.traceln ("Add Time: " + addtime / 1000 + " seconds");
    if (! norefs) {
        updateInternalRefs ();
    }
    long reftime = new java.util.Date ().getTime () - start - addtime;
    log.traceln ("Ref. Time: " + reftime / 1000 + " seconds");
    try {
        conn.commit ();
    } catch (SQLException ex) {
        log.error ("jdbc commit failed");
        DBUtils.logSQLException (ex);
    }
    log.traceln ("done");
}


public String [] getTimeToExpirationLock (String uuid) throws DatabaseException {
    PreparedStatement selectSt = null;
    String timeToExpirationLock = null;
    try {
        selectSt = getConnection ().prepareStatement (SELECT_TIME_TO_EXPIRATION_LOCK);
        selectSt.setString (1, uuid);
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            timeToExpirationLock = rs.getString ("timeToExpLock");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    String [] parsedExpTime = new String [3];
    if (timeToExpirationLock.contains (" day")) {
        String [] splitedByDays = timeToExpirationLock.split (timeToExpirationLock.contains (" days ") ? " days " : " day ");
        parsedExpTime [0] = splitedByDays [0];
        parsedExpTime [1] = splitedByDays [1];
    }
    else {
        parsedExpTime [0] = "0";
        parsedExpTime [1] = timeToExpirationLock;
    }
    String [] splitedByColon = parsedExpTime [1].split (":");
    parsedExpTime [1] = splitedByColon [0];
    parsedExpTime [2] = splitedByColon [1];
    return parsedExpTime;
}


-----Function Pair=364=-----==

public AcDataCustomer getAcDataCustomer (Integer customerId, Integer userId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + AcDataCustomer.class.getName () + " where data.id = '" + customerId + "' and viewer.id = '" + userId + "'";
        Query queryObject = getSession ().createQuery (queryString);
        List < AcDataCustomer > rtn = queryObject.list ();
        tx.commit ();
        return rtn.size () <= 0 ? null : rtn.get (0);
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public List < Usergroups > findUsergroupInCredits (int Credits, short groupid) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Usergroups as u where u.type='member' and ((" + Credits + " >= u.creditshigher and u.creditslower > " + Credits + ") or (u.groupid = " + groupid + "))");
        List < Usergroups > list = query.list ();
        tr.commit ();
        return list;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=365=-----==

private synchronized boolean readTrackListing () {
    Connection conn = null;
    boolean retVal = false;
    try {
        PoolManager pm = PoolManager.getInstance ();
        TrackStore trackStore = TrackStoreFactory.getTrackStore ();
        conn = pm.getConnection (JukeXTrackStore.DB_NAME);
        PreparedStatement ps = conn.prepareStatement ("SELECT trackid,position FROM PlaylistEntry WHERE playlistid=? ORDER BY position");
        ps.setLong (1, this.id);
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            this.add (trackStore.getTrack (rs.getLong (1)));
        }
        ps.close ();
        retVal = true;
    } catch (SQLException se) {
        log.error ("Failed due to an exception reading a Track listing into a playlist", se);
    } catch (Exception e) {
        log.warn ("Encountered exception while reading track listing: ", e);
    } finally {
        try {
            conn.close ();
        } catch (SQLException ignore) {
        }
    }
    return retVal;
}


public String borrar (List < Producto > producto) throws Exception {
    Session session = getSession ();
    Transaction trans = session.beginTransaction ();
    String noBorrados = new String ();
    List < Compra > pd;
    System.out.print ("**************************Guardando en el Manager*********************************************  ");
    try {
        for (Producto p : producto) {
            pd = new ArrayList < Compra > (session.createQuery ("select comp from Compra comp where comp.codProducto =:c").setParameter ("c", p).list ());
            System.out.print ("Resultado del query -----------> ");
            if (pd.size () == 0) {
                System.out.println ("Borrando a " + p.getNombre () + "\n");
                session.createQuery ("delete from Producto where codigo =:cod").setParameter ("cod", p.getCodigo ()).executeUpdate ();
            }
            else {
                noBorrados = noBorrados + p.getNombre () + "\n";
                System.out.println ("No se puede borrar\n");
            }
        }
        System.out.print ("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
        trans.commit ();
        return noBorrados;
    } catch (Exception ex) {
        ex.printStackTrace ();
        trans.rollback ();
        throw ex;
    }
}


-----Function Pair=366=-----==

public long getSCSJobCount (String applicationID, int jobStatus, int jobType, String serverName) throws GridBrokerException {
    long count = 0;
    String query = "SELECT count(job) FROM SCSJob as job " + "WHERE job.application.id = '" + applicationID + "'";
    if (jobStatus != JobStatus.STATUS_ANY) {
        query += " AND job.status=" + jobStatus;
    }
    if (jobType != JobType.TYPE_ANY) {
        query += " AND job.type=" + jobType;
    }
    if (serverName != Constants.ANY_SERVER && serverName.length () > 0) {
        query += " AND job.service.name = '" + serverName + "'";
    }
    Object result = getUniqueResult (query);
    count = ((Integer) result).longValue ();
    return count;
}


public static void test_regular_form (PrintWriter out) {
    try {
        clearTables ();
        LanguageMorphologyTable languageTable = new LanguageMorphologyTable ();
        languageTable.add ("English", "plural", "*", "*s");
        Collection recog = languageTable.recognize ("English", "dogs");
        if (recog.size () != 1) throw new Exception ("Recognizing 'dogs' produced " + recog.size () + ", not 1 result");
        Iterator it = recog.iterator ();
        MorphologyRecognizeMatch match = (MorphologyRecognizeMatch) it.next ();
        if (match.getRootString ().equals ("dog") == false) throw new Exception ("Recognizing 'dogs' produced '" + match.getRootString () + "', not 'dog'");
        Vector expTags = new Vector ();
        expTags.add ("plural");
        if (expTags.containsAll (match.getMorphologyTags ()) == false) throw new Exception ("Tags vectors did not match");
        String surface = languageTable.generate ("English", "plural", "dog");
        if (surface.equals ("dogs") == false) throw new Exception ("Generating plural of 'dog' produced '" + surface + "', not 'dogs'");
        testPassed (out);
    } catch (Exception e) {
        testFailed (e, out);
    }
}


-----Function Pair=367=-----==

private boolean classMigrator (Connection conn, String className) throws MigrationException {
    className = className.replace ("-", "");
    try {
        Class migratorClass = Class.forName (className);
        Migrator migrator;
        try {
            migrator = (Migrator) migratorClass.newInstance ();
        } catch (InstantiationException e) {
            throw new MigrationException ("Failure constructing migrator: " + className, e);
        } catch (IllegalAccessException e) {
            throw new MigrationException ("Migrator constructor not accessible: " + className, e);
        }
        logger.info ("Using class: " + className);
        migrator.migrate (conn);
        return true;
    } catch (ClassNotFoundException e) {
    }
    return false;
}


public String getDescription (String uuid) throws DatabaseException {
    PreparedStatement selectSt = null;
    String description = null;
    try {
        selectSt = getConnection ().prepareStatement (SELECT_LOCK_DESCRIPTION);
        selectSt.setString (1, uuid);
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            description = rs.getString ("description");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    return description;
}


-----Function Pair=368=-----==

private int tagsTemplate (StringBuffer querySQL, List < String > tagsName) throws Exception {
    int num = - 1;
    querySQL.append (" where t.tagname in (:tagnames)");
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery (querySQL.toString ());
        query.setParameterList ("tagnames", tagsName, new org.hibernate.type.StringType ());
        num += query.executeUpdate ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
            tr = null;
        }
        he.printStackTrace ();
    }
    return num;
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=369=-----==

public void delete (E obj) {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        obj = em.merge (obj);
        em.remove (obj);
        tx.commit ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


public void testPrepareFailWarning () throws SQLException {
    try {
        PreparedStatement pstmt = con.prepareStatement ("CREATE VIEW prepFailWarning AS SELECT 1 AS value");
        pstmt.execute ();
        assertNotNull (con.getWarnings ());
        pstmt.close ();
        Statement stmt = con.createStatement ();
        ResultSet rs = stmt.executeQuery ("SELECT * FROM prepFailWarning");
        assertTrue (rs.next ());
        assertEquals (1, rs.getInt (1));
        assertFalse (rs.next ());
        rs.close ();
        stmt.close ();
    } finally {
        Statement stmt = con.createStatement ();
        stmt.execute ("DROP VIEW prepFailWarning");
        stmt.close ();
    }
}


-----Function Pair=370=-----==

public List < E > findAll () {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    List < E > list = new ArrayList < E > ();
    try {
        tx.begin ();
        String query = "select o from " + clazz.getSimpleName () + " o";
        Query q = em.createQuery (query);
        list = q.getResultList ();
        tx.commit ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
    return list;
}


public static int deleteRegistrationByEmail (String email) throws Exception {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query query = session.createQuery ("delete from Registration where email = :email");
        query.setString ("email", email);
        int rowCount = query.executeUpdate ();
        tx.commit ();
        return rowCount;
    } catch (Exception ex) {
        if (tx != null) {
            tx.rollback ();
        }
        throw ex;
    }
}


-----Function Pair=371=-----==

public static Any getDocTypes (Connection con, Any values, Any retValue) throws SQLException {
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocTypes");
    PreparedStatement stmt = con.prepareStatement (sSql);
    ResultSet rSet = stmt.executeQuery ();
    ArrayList < HashMap > arMaps = new ArrayList < HashMap > ();
    while (rSet.next ()) {
        HashMap map = new HashMap ();
        map.put ("ID", rSet.getString ("IDOCTID"));
        map.put ("NAME", rSet.getString ("CTYPNAME"));
        map.put ("AUTONUM", rSet.getString ("CAUTONUM"));
        arMaps.add (map);
    }
    rSet.close ();
    stmt.close ();
    retValue.insert_Value (arMaps.toArray (new HashMap [arMaps.size ()]));
    return retValue;
}


public Integer executeQuery (String query, Object...parametros) {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    int num = 0, position = 1;
    try {
        tx.begin ();
        Query q = em.createQuery (query);
        for (Object parametro : parametros) {
            q.setParameter (position ++, parametro);
        }
        num = q.executeUpdate ();
        tx.commit ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
        return num;
    }
}


-----Function Pair=372=-----==

public List < E > getObjectFromQuery (String query, Object...parametros) {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    int position = 1;
    List < E > array = new ArrayList < E > ();
    try {
        tx.begin ();
        Query q = em.createQuery (query);
        for (Object parametro : parametros) {
            q.setParameter (position ++, parametro);
        }
        tx.commit ();
        array = q.getResultList ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
    return array;
}


public static void saveCustomTitles (String usrlogin, String tabid, String [] custom_titles) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        int seq = 0;
        for (int i = 0; i < custom_titles.length; i ++) {
            seq ++;
            r.clear ();
            r.add ("module_custom_title", custom_titles [i]);
            r.update ("user_login", usrlogin);
            r.update ("tab_id", tabid);
            r.update ("sequence", seq);
            sql = r.getSQLUpdate ("user_module_template");
            stmt.executeUpdate (sql);
        }
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=373=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=374=-----==

public List getTransactions (String host, String scope, int count) throws Exception {
    Session session = null;
    try {
        session = sessionFactory.openSession ();
        Query query = session.createQuery ("from RlxTransaction r where r.host = ? and r.scope = ? order by r.timestamp desc");
        query.setString (0, host);
        query.setString (1, scope);
        query.setMaxResults (count);
        List list = query.list ();
        Hibernate.initialize (list);
        return list;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


public List getVariableList (String host, String scopePattern, String name) throws Exception {
    Session session = null;
    try {
        session = sessionFactory.openSession ();
        Query query = session.createQuery ("from RlxVariable v where v.host = ? and v.scope like ? and v.name = ? order by v.scope, v.name");
        query.setString (0, host);
        query.setString (1, scopePattern);
        query.setString (2, name);
        List list = query.list ();
        Hibernate.initialize (list);
        return list;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


-----Function Pair=375=-----==

public Subject findBySubjectID (Integer subjectID) throws SelectException, DBConnectionException {
    Subject subject = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("SUBJECT_ID", subjectID);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                subject = new Subject ();
                subject.setName (result.getString ("SUBJECT_NAME"));
                subject.setDescription (result.getString ("SUBJECT_DESCRIPTION"));
                subject.setId (result.getInt ("SUBJECT_ID"));
                subject.setCoeff (result.getFloat ("SUBJECT_COEFFICIENT"));
                subject.setAlias (result.getString ("SUBJECT_ALIAS"));
                subject.setTeachingUnit (null);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return subject;
}


private static void initRenderParameters (Map parameterMap, ActionResponse actionResponse) {
    log.debug ("Start initRenderParameters()");
    if (! parameterMap.entrySet ().isEmpty ()) {
        log.debug ("Request parameter");
        Map < String, String [] > map = parameterMap;
        for (Map.Entry < String, String [] > entry : map.entrySet ()) {
            if ((entry.getKey ()).equals (MemberConstants.MEMBER_ACTION_PARAM)) {
                actionResponse.setRenderParameter (MemberConstants.MEMBER_ACTION_PARAM, ContentTypeActionType.INDEX.toString ());
            }
            else if ((entry.getKey ()).equals (MemberConstants.MEMBER_SUBACTION_PARAM)) {
            }
            else {
                for (String v : entry.getValue ()) {
                    actionResponse.setRenderParameter (entry.getKey (), v);
                }
            }
            if (log.isDebugEnabled ()) {
                log.debug ("    key: " + entry.getKey () + ", value: " + StringTools.arrayToString (entry.getValue ()));
            }
        }
    }
    else {
        log.debug ("Parameters for render request not found");
    }
}


-----Function Pair=376=-----==

public RestServiceResult createExerciseS1Material (RestServiceResult serviceResult, String sArrayMaterialId, CoExercises1 coExercises1) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_EXERCITES1_MATERIAL);
        query.setParameter (1, coExercises1.getExerciseId ());
        query.executeUpdate ();
        StringTokenizer stringTokenizer = new StringTokenizer (sArrayMaterialId, ",");
        while (stringTokenizer.hasMoreTokens ()) {
            long nMaterialId = Long.parseLong (stringTokenizer.nextToken ());
            query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_EXERCITES1_MATERIAL);
            query.setParameter (1, coExercises1.getExerciseId ());
            query.setParameter (2, nMaterialId);
            query.executeUpdate ();
        }
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coExercises1.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la asociaci�n - Ejercicio- Material: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.create.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


public static void querywithparameter (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query1 = entityManager.createQuery ("SELECT p FROM Person p WHERE p.sex = :sex");
        query1.setParameter ("sex", Sex.MALE);
        Collection < Person > collection1 = (Collection < Person >) query1.getResultList ();
        for (Person person : collection1) {
            System.out.println ("Of sex 'male': " + person);
        }
        Query query2 = entityManager.createQuery ("SELECT p FROM Person p WHERE p.creditRating < :creditRating");
        query2.setParameter ("creditRating", CreditRating.BBB);
        Collection < Person > collection2 = (Collection < Person >) query2.getResultList ();
        for (Person person : collection2) {
            System.out.println ("Of good credit rating: " + person);
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=377=-----==

protected synchronized void removeAll (String deleteFrom) throws HelpDeskException {
    Session session = openSession ();
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        Query queryDelete = session.createQuery ("delete from " + deleteFrom);
        queryDelete.executeUpdate ();
        tx.commit ();
    } catch (Exception e) {
        if (tx != null) tx.rollback ();
        throw new HelpDeskException (MsgErros.OPER_NAO_REALIZADA.msg ("Limpeza de cadastro", e.getMessage ()));
    } finally {
        session.flush ();
        session.close ();
    }
}


public void testBasicQuery () {
    try {
        EntityManager em = getEM ();
        EntityTransaction tx = em.getTransaction ();
        try {
            tx.begin ();
            Person p = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
            em.persist (p);
            List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T").getResultList ();
            assertEquals (1, result.size ());
            tx.rollback ();
        } finally {
            if (tx.isActive ()) {
                tx.rollback ();
            }
            em.close ();
        }
    } finally {
        clean (Person.class);
    }
}


-----Function Pair=378=-----==

public List < SchemaTable > getRefTable (SchemaTable pTableName) {
    List < SchemaTable > tOut = new ArrayList < SchemaTable > ();
    ResultSet tRS = null;
    try {
        tRS = getConnection ().getMetaData ().getImportedKeys (pTableName.getSchema (), SCHEMA_PATTERN, pTableName.getTable ());
        while (tRS.next ()) {
            SchemaTable tTable = new SchemaTable (tRS.getString ("PKTABLE_CAT"), tRS.getString ("PKTABLE_NAME"));
            if (! tOut.contains (tTable)) {
                tOut.add (tTable);
            }
        }
    } catch (Exception e) {
        LOG.error ("", e);
    } finally {
        close (tRS);
    }
    return tOut;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=379=-----==

private void checkDupDoc (String typeOfDoc, Connection con) throws SQLException, Exception {
    String check = "SELECT * from " + typeOfDoc + " doc, courses c " + "WHERE doc.courseid = c.courseid AND " + "doc.admin = c.admin AND doc.title = ?";
    PreparedStatement prepStatement = con.prepareStatement (check);
    prepStatement.setString (1, this.getTitle ().trim ());
    ResultSet rs = prepStatement.executeQuery ();
    int resultsCounter = 0;
    while (rs.next ()) {
        resultsCounter ++;
    }
    prepStatement.close ();
    if (resultsCounter == 0) {
    }
    else {
        foundDupDocument = true;
        throw new Exception ();
    }
}


public static void querywithparameter (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query1 = entityManager.createQuery ("SELECT p FROM Person p WHERE p.sex = :sex");
        query1.setParameter ("sex", Sex.MALE);
        Collection < Person > collection1 = (Collection < Person >) query1.getResultList ();
        for (Person person : collection1) {
            System.out.println ("Of sex 'male': " + person);
        }
        Query query2 = entityManager.createQuery ("SELECT p FROM Person p WHERE p.creditRating < :creditRating");
        query2.setParameter ("creditRating", CreditRating.BBB);
        Collection < Person > collection2 = (Collection < Person >) query2.getResultList ();
        for (Person person : collection2) {
            System.out.println ("Of good credit rating: " + person);
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=380=-----==

public void executeDDL (String dml, String schema) throws SQLException {
    dml += "\n";
    CallableStatement csm = null;
    if ((dml != null) && (dml.length () != 0)) {
        try {
            Connection cn = getRepositoryConnection (p_ctx.getApplication (), schema, 1);
            csm = cn.prepareCall (dml);
            csm.execute ();
            log (dml, "OK");
        } catch (SQLException e) {
            log (dml, e.getClass ().getName () + ":" + e.getErrorCode () + " - " + e.getMessage ());
            int error = e.getErrorCode ();
            if (e.getErrorCode () == 2261) {
            }
            else {
                throw new SQLException (MessageLocalizer.getMessage ("ERROR_EXECUTING_DDL") + ":" + e.getMessage () + "\n" + MessageLocalizer.getMessage ("DDL_STATEMENT_WAS") + ":\n" + dml);
            }
        } catch (Exception e) {
            throw new SQLException (MessageLocalizer.getMessage ("ERROR_EXECUTING_DDL") + ":" + e.getMessage () + "\n" + MessageLocalizer.getMessage ("DDL_STATEMENT_WAS") + ":\n" + dml);
        } finally {
            if (csm != null) csm.close ();
        }
    }
}


public void deleteRoleAction (Integer roleId, String [] actionIds) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String delStr = null;
        for (int i = 0; i < actionIds.length; i ++) {
            delStr = "delete from " + AcRoleAction.class.getName () + " where acRole.id = '" + roleId + "' and acAction.id = '" + actionIds [i] + "'";
            Query queryObject = getSession ().createQuery (delStr);
            queryObject.executeUpdate ();
        }
        tx.commit ();
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=381=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        TypedQuery < Person > query = entityManager.createQuery ("SELECT p FROM Person p", Person.class);
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setWeight (Double.NaN);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static void queryByEnum (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p WHERE p.homeState = :homestate");
        query.setParameter ("homestate", State.CT);
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        System.out.println ("From State.CT ...");
        for (Person person : collection) {
            System.out.println ("found: " + person);
        }
        query = entityManager.createQuery ("SELECT p FROM Person p WHERE p.income >= :income");
        query.setParameter ("income", IncomeGroup.average);
        collection = (Collection < Person >) query.getResultList ();
        System.out.println ("With income of at least average ...");
        for (Person person : collection) {
            System.out.println ("found: " + person);
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=382=-----==

public List getLockList (String virtualWiki) throws Exception {
    List all = new ArrayList ();
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        PreparedStatement stmt = conn.prepareStatement (STATEMENT_GET_LOCK_LIST);
        stmt.setString (1, virtualWiki);
        ResultSet rs = stmt.executeQuery ();
        while (rs.next ()) {
            TopicLock lock = new TopicLock (rs.getString ("virtualWiki"), rs.getString ("topic"), rs.getTimestamp ("lockat"), rs.getString ("sessionkey"));
            all.add (lock);
        }
        rs.close ();
        stmt.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return all;
}


public final T get (final Serializable serialId, final LockMode lockMode) throws CannotConnectToDatabaseException {
    if (serialId == null) {
        return null;
    }
    final String entityName = this.getEntityName ();
    final Session s = this.currentSession ();
    Transaction tx = null;
    T ret = null;
    try {
        tx = s.beginTransaction ();
        ret = (T) s.get (entityName, serialId, lockMode);
        s.clear ();
        tx.commit ();
    } catch (HibernateException he) {
        tx.rollback ();
        LOGGER.error ("Failed to get entity - transaction was rolled back.", he);
        throw he;
    } finally {
        s.close ();
    }
    return ret;
}


-----Function Pair=383=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=384=-----==

public static Vector getRoles () {
    String sql = "select name, description from role order by name";
    Db database = null;
    Vector list = new Vector ();
    try {
        Role obj = null;
        database = new Db ();
        Statement stmt = database.getStatement ();
        ResultSet rs = stmt.executeQuery (sql);
        while (rs.next ()) {
            obj = new Role ();
            obj.setName (rs.getString ("name"));
            obj.setDescription (rs.getString ("description"));
            list.addElement (obj);
        }
    } catch (DbException dbex) {
        System.out.println ("PrepareTemplateTab.getRoles(): DbException : " + dbex.getMessage ());
    } catch (SQLException ex) {
        System.out.println ("PrepareTemplateTab.getRoles(): SQLException : " + ex.getMessage ());
    } finally {
        if (database != null) database.close ();
    }
    return list;
}


public List < Cliente > listar () throws Exception {
    Connection connection = criaConexao (false);
    String sql = "select * from cliente cl , cidade ci where cl.cod_cidade = ci.cod_cidade order by nome";
    PreparedStatement stmt = null;
    ResultSet rs = null;
    Cliente cliente = null;
    Cidade cidade = null;
    List < Cliente > listaCliente = new ArrayList < Cliente > ();
    try {
        stmt = connection.prepareStatement (sql);
        rs = stmt.executeQuery ();
        while (rs.next ()) {
            cliente = new Cliente ();
            cliente.setId (rs.getLong ("cod_cliente"));
            cliente.setNome (rs.getString ("nome"));
            cliente.setSexo (rs.getString ("sexo"));
            cidade = new Cidade ();
            cidade.setCodCidade (rs.getInt ("cod_cidade"));
            cidade.setNome (rs.getString ("nome_cidade"));
            cliente.setCidade (cidade);
            listaCliente.add (cliente);
        }
    } catch (SQLException e) {
        throw e;
    } finally {
        try {
            stmt.close ();
            rs.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
    return listaCliente;
}


-----Function Pair=385=-----==

public void testRollingBack () throws Throwable {
    Session s = openSession ();
    Transaction tx = s.beginTransaction ();
    int testLength = 3;
    Long lastId = null;
    for (int i = 0; i < testLength; i ++) {
        Car car = new Car ();
        car.setColor ("color " + i);
        s.save (car);
        lastId = car.getId ();
    }
    tx.rollback ();
    s.close ();
    s = openSession ();
    tx = s.beginTransaction ();
    Car car = new Car ();
    car.setColor ("blue");
    s.save (car);
    s.flush ();
    tx.commit ();
    s.close ();
    assertEquals ("id generation was rolled back", lastId.longValue () + 1, car.getId ().longValue ());
    s = openSession ();
    tx = s.beginTransaction ();
    s.createQuery ("delete Car").executeUpdate ();
    tx.commit ();
    s.close ();
}


public static void addNodeConnector (String nodeName, String connector, int priority) throws Exception {
    log.debug ("Adding Node Connector: " + nodeName);
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Nodeconnector nodeTable = new Nodeconnector ();
    nodeTable.setNode (new Node (nodeName));
    nodeTable.setConnector (new Connector (connector, null, null));
    nodeTable.setPriority (priority);
    try {
        session.saveOrUpdate (nodeTable);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception ("Error Adding Node \"" + nodeName + "\": " + e.getCause ().getMessage ());
    }
    return;
}


-----Function Pair=386=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        LOGGER.info ("*** insert ***");
        insert (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** update ***");
        update (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


-----Function Pair=387=-----==

public int executeBulkOperation (String bulkQuery, Object [] parameters) throws GenericPersistenceException {
    EntityManager em = null;
    try {
        em = EMFactory.getEntityManagerFactory (this.puName).createEntityManager ();
        em.getTransaction ().begin ();
        Query query = em.createQuery (bulkQuery);
        if (parameters != null) for (int count = 0; count < parameters.length; count ++) query.setParameter ((count + 1), parameters [count]);
        int rows = query.executeUpdate ();
        em.getTransaction ().commit ();
        return rows;
    } catch (Exception ex) {
        if (em != null) if (em.getTransaction ().isActive ()) em.getTransaction ().rollback ();
        throw (GenericPersistenceException) this.createGenericPersistenceException (ex).initCause (ex);
    } finally {
        if (em != null) em.close ();
    }
}


public int getAtendente (Integer Matempr) {
    StringBuffer sql = new StringBuffer ();
    StringBuffer where = new StringBuffer ();
    int iRet = 0;
    try {
        sql.append ("select codatend from ATATENDENTE  ");
        sql.append (" where  matempr = " + Matempr);
        PreparedStatement ps = getConn ().prepareStatement (sql.toString ());
        ResultSet rs = ps.executeQuery ();
        if (rs.next ()) {
            iRet = rs.getInt ("Codatend");
            return iRet;
        }
        rs.close ();
        ps.close ();
        getConn ().commit ();
    } catch (SQLException err) {
        err.printStackTrace ();
    }
    return iRet;
}


-----Function Pair=388=-----==

public Program updateProgramPath (int id, String sourcePath) throws AdaptationException {
    Program program = null;
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "UPDATE Programs SET " + "sourcePath = '" + sourcePath + "' " + "WHERE id = " + id;
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        statement.executeUpdate (query);
        query = "SELECT * from Programs WHERE id = " + id;
        resultSet = statement.executeQuery (query);
        if (! resultSet.next ()) {
            connection.rollback ();
            String msg = "Attempt to update program failed.";
            log.error (msg);
            throw new AdaptationException (msg);
        }
        program = getProgram (resultSet);
        connection.commit ();
    } catch (SQLException ex) {
        try {
            connection.rollback ();
        } catch (Exception e) {
        }
        String msg = "SQLException in updateProgramPath";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return program;
}


public String findFirst (String sql, int columnIndex) {
    String result = null;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Transaction tran = null;
    try {
        Session session = SessionFactory.getSession ();
        tran = session.beginTransaction ();
        conn = session.connection ();
        pstmt = conn.prepareStatement (sql);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            result = rs.getString (columnIndex);
        }
        tran.commit ();
    } catch (SQLException e) {
        tran.rollback ();
        e.printStackTrace ();
    } finally {
        try {
            if (tran != null) {
                tran = null;
            }
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return result;
}


-----Function Pair=389=-----==

public boolean getAuthorization (Identifier item, String partner, Value value, String...properties) throws GeneralFault {
    if (partner == null) {
        return true;
    }
    int needed = PropertyRight.convert (value);
    GetAuthorizationHelper helper = new GetAuthorizationHelper (item, partner);
    try {
        for (String property : properties) {
            int auth = helper.getAuthorization (property);
            if (! PropertyRight.contains (auth, needed, true)) {
                return false;
            }
        }
        return true;
    } finally {
        helper.finish ();
    }
}


List getTableMetadata (String tableType) throws PXObjectStoreException {
    List getTableMetadata = null;
    try {
        Session aSession = this.createSession ();
        LOG.debug ("aSession: " + aSession);
        if (aSession != null) {
            Connection aConnection = aSession.connection ();
            if (aConnection != null) {
                DatabaseMetaData aMetaData = aConnection.getMetaData ();
                String [] someTableTypes = null;
                if (tableType != null) {
                    someTableTypes = new String [] {tableType};
                }
                ResultSet someTables = aMetaData.getTables (null, null, null, someTableTypes);
                getTableMetadata = PXSqlUtility.asDictionaries (someTables);
                LOG.debug ("getTableMetadata: " + getTableMetadata);
            }
            aSession.close ();
        }
    } catch (HibernateException e) {
        throw new PXObjectStoreException (e);
    } catch (SQLException e) {
        throw new PXObjectStoreException (e);
    }
    return getTableMetadata;
}


-----Function Pair=390=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public Set < Job > getNotFinishedJobs () {
    Set < Job > jobs = new HashSet < Job > ();
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + JOB_TABLE + " o where " + "o.status != :finished AND " + "o.status != :errors AND " + "o.status != :canceled");
        query.setString ("finished", JobStatus.FINISHED.getStatus ());
        query.setString ("errors", JobStatus.ERRORS.getStatus ());
        query.setString ("canceled", JobStatus.CANCELED.getStatus ());
        List jobList = query.list ();
        for (Object o : jobList) {
            jobs.add ((Job) o);
        }
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return jobs;
}


-----Function Pair=391=-----==

public boolean newComment (Usuario user, String codigoProducto, String codigoComentario, String fechaHora, String comentario) {
    Connection conexion = null;
    PreparedStatement insert = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        insert = conexion.prepareStatement ("INSERT INTO " + nameBD + ".Comentarios VALUES (?,?,?,?,?,?)");
        insert.setString (1, codigoComentario);
        insert.setString (2, fechaHora);
        insert.setString (3, codigoProducto);
        insert.setString (4, user.getMail ());
        insert.setString (5, user.getNombre ());
        insert.setString (6, comentario);
        int filasAfectadas = insert.executeUpdate ();
        if (filasAfectadas == 1) {
            exito = true;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error añadiendo nuevo comentario", ex);
    } finally {
        cerrarConexionYStatement (conexion, insert);
    }
    return exito;
}


public ConcernDomain createConcernDomain (String name, String description, String shortName, String kind, IConcernListener changeListener) {
    Concern rootConcern = getOrCreateRootConcern (name, changeListener);
    if (rootConcern == null) return null;
    List < Object > params = new ArrayList < Object > ();
    params.add (rootConcern.getId ());
    params.add (name);
    params.add (shortName);
    params.add (description);
    params.add (kind);
    try {
        PreparedStatement statement = createPreparedStatement (CONCERN_DOMAIN_SQL, params);
        statement.executeUpdate ();
        statement.close ();
        con.commit ();
        return getConcernDomain (name, changeListener);
    } catch (SQLException e) {
        rollback ();
        if (e.getMessage ().indexOf ("Violation of unique constraint") >= 0) {
            ProblemManager.reportException (e, "Failed to create concern domain. Concern domain '" + name + "' already exists.");
        }
        else {
            ProblemManager.reportException (e, "Failed to create concern domain '" + name + "'.");
        }
        return null;
    }
}


-----Function Pair=392=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert and detach ***");
        insertanddetach (entityManagerFactory);
        System.out.println ("*** change ***");
        change ();
        System.out.println ("*** attach ***");
        attach (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** attach ***");
        attach (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query with fetchplan ***");
        querywithfetchplan (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=393=-----==

public final void delete (final T obj) throws CannotConnectToDatabaseException {
    if (obj == null) {
        return;
    }
    final Session s = this.currentSession ();
    Transaction tx = null;
    try {
        tx = s.beginTransaction ();
        s.delete (obj);
        s.flush ();
        s.clear ();
        tx.commit ();
    } catch (HibernateException he) {
        tx.rollback ();
        LOGGER.error ("Failed to delete given entity - transaction was rolled back.", he);
        throw he;
    } finally {
        s.close ();
    }
}


public int getCurrval (String sequence) throws SQLException {
    int result;
    try {
        pstmt_currVal.setString (1, sequence);
        rs_currVal = pstmt_currVal.executeQuery ();
        if (rs_currVal.next ()) {
            result = rs_currVal.getInt (1);
        }
        else {
            throw new SQLException (sequence + " not found");
        }
    } catch (SQLException sqle) {
        throw sqle;
    }
    return result;
}


-----Function Pair=394=-----==

public void testClobG () {
    try {
        String ddl1 = "create procedure PUBLIC.PROC_A(out p1 clob, out p2 int) READS SQL DATA BEGIN ATOMIC SET p1 = 'dafsdfasdfaefafeajfiwejifpjajsidojfakmvkamsdjfadpsjfoajsdifjaos'; SET p2 = 0; end";
        String dml0 = "call PUBLIC.PROC_A(?, ?)";
        statement.execute (ddl1);
        CallableStatement ps = connection.prepareCall (dml0);
        ps.registerOutParameter (1, java.sql.Types.CLOB);
        ps.registerOutParameter (2, java.sql.Types.INTEGER);
        ps.execute ();
        String string = ps.getClob (1).getSubString (1, 10);
        System.out.println (string);
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}


public PortfolioEntry getPortfolioEntry (long id) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from PortfolioEntry R where R.id=?";
        Query q = s.createQuery (query);
        q.setLong (0, id);
        return (PortfolioEntry) q.uniqueResult ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=395=-----==

private StringBuffer getInsertSql (List allProps, String table) {
    StringBuffer insertSql = new StringBuffer ();
    insertSql.append ("insert into ").append (table).append ("(");
    log.info ("正在生成服务和参数关联SQL:");
    for (Iterator itCol = allProps.iterator (); itCol.hasNext ();) {
        DOBOProperty property = (DOBOProperty) itCol.next ();
        insertSql.append (property.getColName ());
        if (itCol.hasNext ()) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    insertSql.append (" values(");
    for (int i = 0; i < allProps.size (); i ++) {
        insertSql.append ("?");
        if (i < allProps.size () - 1) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    return insertSql;
}


public boolean eliminar (int codExam) {
    Transaction tx = null;
    Session session = HibernateUtil.currentSession ();
    boolean eliminado = false;
    try {
        tx = session.beginTransaction ();
        Examen examen = (Examen) session.get (Examen.class, codExam);
        Asignatura asignatura = (Asignatura) session.get (Asignatura.class, examen.getAsignatura ().getCodAsig ());
        asignatura.getExamenes ().remove (examen);
        session.delete (examen);
        tx.commit ();
        eliminado = true;
    } catch (Exception e) {
        try {
            tx.rollback ();
            e.printStackTrace ();
        } catch (Exception e2) {
            e2.printStackTrace ();
        }
    } finally {
        HibernateUtil.closeSession ();
    }
    return eliminado;
}


-----Function Pair=396=-----==

public boolean isParent (long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select count(R) from TT R where R.parentTxId=?";
        Query q = s.createQuery (query);
        q.setLong (0, txId);
        List l = q.list ();
        return l.size () != 0;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


protected void downgradeHistory (Collection < String > versions) {
    Assert.notEmpty (versions);
    try {
        Connection connection = this.database.getDefaultConnection ();
        PreparedStatement statement = connection.prepareStatement ("UPDATE " + this.logTableName + " SET RESULT = 'DOWNGRADED' WHERE TYPE = 'B' AND TARGET = ? AND RESULT = 'COMPLETE'");
        boolean commit = false;
        try {
            for (String version : versions) {
                statement.setString (1, version);
                int modified = statement.executeUpdate ();
                Assert.isTrue (modified <= 1, "Expecting not more than 1 record to be updated, not " + modified);
            }
            commit = true;
        } finally {
            statement.close ();
            if (commit) connection.commit ();
            else connection.rollback ();
        }
    } catch (SQLException e) {
        throw new SystemException (e);
    }
}


-----Function Pair=397=-----==

private void addItemByBarcode (String bc) {
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    if (bc != null) {
        try {
            conn = dbMan.getPOSConnection ();
            stmt = conn.createStatement ();
            if (stmt.execute ("select ibItemID, ibType from " + strPOSPrefix + "item_barcodes where ibBarcode = '" + bc + "'")) {
                rs = stmt.getResultSet ();
                while (rs.next ()) {
                    if (rs.getString ("ibType").compareTo ("1") == 0) {
                        OrderItem item = getItemByID (rs.getInt ("ibItemID"));
                        if (item != null) {
                            addItemToOrder (item);
                        }
                    }
                    else if (rs.getString ("ibType").compareTo ("2") == 0) {
                        System.out.println ("Adding Batch items via barcode scan is not yet supported!");
                    }
                }
            }
        } catch (SQLException sqlEx) {
            System.err.println ("SQLException: " + sqlEx.getMessage ());
            System.err.println ("SQLState: " + sqlEx.getSQLState ());
            System.err.println ("VendorError: " + sqlEx.getErrorCode ());
        } catch (Exception e) {
            System.err.println ("Exception: " + e.getMessage ());
            System.err.println (e);
        } finally {
            if (rs != null) {
                try {
                    rs.close ();
                } catch (SQLException sqlEx) {
                    rs = null;
                }
                if (stmt != null) {
                    try {
                        stmt.close ();
                    } catch (SQLException sqlEx) {
                        stmt = null;
                    }
                }
            }
        }
    }
}


public int addCliente (Cliente cli) throws errorConexionBD, errorSQL {
    System.out.println ("GestorCliente.addCliente()");
    String sql;
    PreparedStatement pstmt = null;
    int nuevoId = 0;
    try {
        gd.begin ();
        sql = "INSERT INTO persona(nif, nombre, apellido1, apellido2, " + "direccion, poblacion,telefono, movil, email, fecha_baja)" + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setString (1, cli.getNif ());
        pstmt.setString (2, cli.getNombre ());
        pstmt.setString (3, cli.getApellido1 ());
        pstmt.setString (4, cli.getApellido2 ());
        pstmt.setString (5, cli.getDireccion ());
        pstmt.setString (6, cli.getPoblacion ());
        pstmt.setString (7, cli.getTelefono ());
        pstmt.setString (8, cli.getMovil ());
        pstmt.setString (9, cli.getEmail ());
        pstmt.setDate (10, (java.sql.Date) cli.getFechaBaja ());
        ResultSet rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        pstmt.close ();
        rs.close ();
        sql = "INSERT INTO cliente (cod_cliente, tarjeta_credito, puntos)" + "VALUES (?,?,?) RETURNING cod_cliente";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, nuevoId);
        pstmt.setString (2, cli.getTarjetaCredito ());
        pstmt.setInt (3, 0);
        gd.commit ();
        System.out.println ("commit");
        rs = pstmt.executeQuery ();
        rs.close ();
        pstmt.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorCliente.addCliente()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=398=-----==

public boolean contains (int id) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            return contains (stmt, id);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


private void updateChangeCreditDeposit () {
    String strChange = "N/A";
    if (mBuf.getBufferTotal () > order.getOrderTotal ()) {
        Double dblElig = order.getOrderTotal () - mBuf.getCredit ();
        if (dblElig < 0) dblElig = 0d;
        Double dblDiff = mBuf.getCash () - dblElig;
        if (dblDiff >= 0d) {
            strChange = money.format (dblDiff);
        }
    }
    if (blDepositCredit) {
        gui.setDepositChange (strChange);
    }
    else {
        gui.setNoDepositChange (strChange);
    }
}


-----Function Pair=399=-----==

public static Book getBook (int i_id) {
    Book book = null;
    Connection con = null;
    try {
        con = getConnection ();
        PreparedStatement statement = con.prepareStatement ("SELECT * FROM item,author WHERE item.i_a_id = author.a_id AND i_id = ?");
        statement.setInt (1, i_id);
        ResultSet rs = statement.executeQuery ();
        rs.next ();
        book = new Book (rs);
        rs.close ();
        statement.close ();
        con.commit ();
        returnConnection (con);
    } catch (java.lang.Exception ex) {
        try {
            con.rollback ();
            ex.printStackTrace ();
        } catch (Exception se) {
            System.err.println ("Transaction rollback failed.");
        }
    }
    return book;
}


public static int deleteContract (String likePatten) {
    Connection conn = null;
    PreparedStatement psmt = null;
    StringBuffer SQL = new StringBuffer (200);
    int deleted = 0;
    SQL.append (" DELETE FROM JHF_ALIVE_CONTRACT ").append (" WHERE   ORDER_ID LIKE  ? ");
    try {
        conn = JdbcConnectionPool.mainConnection ();
        conn.setAutoCommit (false);
        conn.setReadOnly (false);
        psmt = conn.prepareStatement (SQL.toString ());
        psmt.setString (1, "%" + likePatten + "%");
        deleted = psmt.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        if (null != conn) {
            try {
                conn.rollback ();
            } catch (SQLException e1) {
                System.out.println (" error when roll back !");
            }
        }
    } finally {
        try {
            if (null != psmt) {
                psmt.close ();
                psmt = null;
            }
            if (null != conn) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            System.out.println (" error  when psmt close or conn close .");
        }
    }
    return deleted;
}


-----Function Pair=400=-----=1=

public static int deleteExecution (String likePatten) {
    Connection conn = null;
    PreparedStatement psmt = null;
    StringBuffer SQL = new StringBuffer (200);
    int deleted = 0;
    SQL.append (" DELETE FROM JHF_EXCEPTION ").append (" WHERE   ORDER_ID LIKE  ? ");
    try {
        conn = JdbcConnectionPool.mainConnection ();
        conn.setAutoCommit (false);
        conn.setReadOnly (false);
        psmt = conn.prepareStatement (SQL.toString ());
        psmt.setString (1, "%" + likePatten + "%");
        deleted = psmt.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        if (null != conn) {
            try {
                conn.rollback ();
            } catch (SQLException e1) {
                System.out.println (" error when roll back !");
            }
        }
    } finally {
        try {
            if (null != psmt) {
                psmt.close ();
                psmt = null;
            }
            if (null != conn) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            System.out.println (" error  when psmt close or conn close .");
        }
    }
    return deleted;
}


public static int deleteOrderStatusHis (String likePatten) {
    Connection conn = null;
    PreparedStatement psmt = null;
    StringBuffer SQL = new StringBuffer (200);
    int deleted = 0;
    SQL.append (" DELETE FROM JHF_ORDER_STATUS_HISTORY ").append (" WHERE   ORDER_ID LIKE  ? ");
    try {
        conn = JdbcConnectionPool.mainConnection ();
        conn.setAutoCommit (false);
        conn.setReadOnly (false);
        psmt = conn.prepareStatement (SQL.toString ());
        psmt.setString (1, "%" + likePatten + "%");
        deleted = psmt.executeUpdate ();
        conn.commit ();
    } catch (SQLException e) {
        if (null != conn) {
            try {
                conn.rollback ();
            } catch (SQLException e1) {
                System.out.println (" error when roll back !");
            }
        }
    } finally {
        try {
            if (null != psmt) {
                psmt.close ();
                psmt = null;
            }
            if (null != conn) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            System.out.println (" error  when psmt close or conn close .");
        }
    }
    return deleted;
}


