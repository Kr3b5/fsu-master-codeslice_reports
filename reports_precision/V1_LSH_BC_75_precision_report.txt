Found 10/400 pairs as clones in the BCB
-----Function Pair=1=-----==

private void init () {
    JPanel holder = new JPanel ();
    holder.setLayout (new BorderLayout ());
    final ComboBoxSelectorPanel vp = new ComboBoxSelectorPanel ();
    IDataGrid grid = scatter2D.getDataSource ();
    int numcols = grid.getNumCols ();
    ArrayList < Integer > validcols = new ArrayList < Integer > ();
    validcols.addAll (grid.getColumnIndicesMatching (Double.class));
    validcols.addAll (grid.getColumnIndicesMatching (Integer.class));
    Collections.sort (validcols);
    vp.addVariable ("Number");
    Vector < IColumn > v = grid.getColumns ();
    for (int i = 0; i < validcols.size (); i ++) {
        vp.addVariable (v.get (validcols.get (i)).getLabel ());
    }
    int [] vars = scatter2D.usedGridVariables;
    if (vars.length == 2) {
        vp.addBox ("X-Axis", vars [0] + 1);
        vp.addBox ("Y-Axis", vars [1] + 1);
    }
    else {
        vp.addBox ("X-Axis");
        vp.addBox ("Y-Axis", vars [0] + 1);
    }
    JPanel buttonsPanel = new JPanel ();
    buttonsPanel.setLayout (new BorderLayout ());
    JButton cancelBtn = new JButton ("Cancel");
    cancelBtn.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            dispose ();
        }
    }
    );
    JButton applyBtn = new JButton ("Apply");
    applyBtn.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            Vector < Integer > v = new Vector < Integer > ();
            int dim = 0;
            Vector < Integer > validCols = new Vector < Integer > ();
            validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Double.class));
            validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Integer.class));
            Collections.sort (validCols);
            for (Integer in : vp.getSelectedIndices ()) {
                if (in > 0) dim ++;
                in --;
                v.add (validCols.get (in));
            }
            System.out.println ("v :");
            for (Integer vint : v) {
                System.out.print (vint + " ");
            }
            if (dim == 0) {
                JOptionPane.showMessageDialog (null, "Select at least one Variable please.");
            }
            else if (dim == 1) {
                scatter2D.clearPlot ();
                scatter2D.resetLegendEntries ();
                System.out.println ("1Dim : v.get(1) = " + v.get (1));
                scatter2D.setDataSource (scatter2D.getDataSource (), v.get (1));
                scatter2D.repaint ();
            }
            else if (dim == 2) {
                scatter2D.clearPlot ();
                scatter2D.resetLegendEntries ();
                System.out.println ("2Dim : v.get(0) = " + v.get (0) + "v.get(1) = " + v.get (1));
                scatter2D.setDataSource (scatter2D.getDataSource (), v.get (0), v.get (1));
                scatter2D.repaint ();
            }
        }
    }
    );
    buttonsPanel.add (cancelBtn, BorderLayout.WEST);
    buttonsPanel.add (applyBtn, BorderLayout.EAST);
    holder.add (vp, BorderLayout.CENTER);
    holder.add (buttonsPanel, BorderLayout.SOUTH);
    setContentPane (holder);
    this.setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
    pack ();
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.FilesystemDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.FilesystemDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            Filesystem model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, FilesystemEditPart.MODEL_ID, FilesystemDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (filesystem.diagram.part.FilesystemDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (filesystem.diagram.part.FilesystemDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                FilesystemDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        FilesystemDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=2=-----==

public void execute (IFile erdFile, RootModel root, GraphicalViewer viewer) {
    ScalableRootEditPart rootEditPart = (ScalableRootEditPart) viewer.getRootEditPart ();
    double zoom = rootEditPart.getZoomManager ().getZoom ();
    try {
        FileDialog dialog = new FileDialog (Display.getCurrent ().getActiveShell (), SWT.SAVE);
        dialog.setFileName (PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getActivePage ().getActiveEditor ().getTitle () + ".jpg");
        String file = dialog.open ();
        if (file != null) {
            IFigure figure = rootEditPart.getLayer (LayerConstants.PRINTABLE_LAYERS);
            Rectangle rectangle = figure.getBounds ();
            Image image = new Image (Display.getDefault (), rectangle.width + 50, rectangle.height + 50);
            GC gc = new GC (image);
            SWTGraphics graphics = new SWTGraphics (gc);
            figure.paint (graphics);
            ImageLoader loader = new ImageLoader ();
            loader.data = new ImageData [] {image.getImageData ()};
            if (file.endsWith (".bmp")) {
                loader.save (file, SWT.IMAGE_BMP);
            }
            else if (file.endsWith (".gif")) {
                loader.save (file, SWT.IMAGE_GIF);
            }
            else if (file.endsWith (".jpg") || file.endsWith (".jpeg")) {
                loader.save (file, SWT.IMAGE_JPEG);
            }
            else if (file.endsWith (".png")) {
                loader.save (file, SWT.IMAGE_PNG);
            }
            else if (file.endsWith (".tiff")) {
                loader.save (file, SWT.IMAGE_TIFF);
            }
            else {
                file = file + ".bmp";
                loader.save (file, SWT.IMAGE_BMP);
            }
            image.dispose ();
            gc.dispose ();
        }
    } catch (Exception ex) {
    } finally {
        rootEditPart.getZoomManager ().setZoom (zoom);
    }
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=3=-----==

private void validate () {
    final IFile file = ((IFileEditorInput) this.getEditorInput ()).getFile ();
    if (this.diagram.getDiagramContents ().getSettings ().isSuspendValidator ()) {
        try {
            file.deleteMarkers (null, true, IResource.DEPTH_INFINITE);
        } catch (CoreException e) {
            Activator.showExceptionDialog (e);
        }
    }
    else {
        IWorkspaceRunnable editorMarker = new IWorkspaceRunnable () {
            public void run (IProgressMonitor monitor) throws CoreException {
                ERDiagramEditor editor = (ERDiagramEditor) getActiveEditor ();
                file.deleteMarkers (null, true, IResource.DEPTH_INFINITE);
                editor.clearMarkedObject ();
                Validator validator = new Validator ();
                List < ValidateResult > errorList = validator.validate (diagram);
                for (ValidateResult error : errorList) {
                    IMarker marker = file.createMarker (IMarker.PROBLEM);
                    marker.setAttribute (IMarker.MESSAGE, error.getMessage ());
                    marker.setAttribute (IMarker.TRANSIENT, true);
                    marker.setAttribute (IMarker.LOCATION, error.getLocation ());
                    marker.setAttribute (IMarker.SEVERITY, error.getSeverity ());
                    editor.setMarkedObject (marker, error.getObject ());
                }
                List < ValidateResult > todoList = validateTodo ();
                for (ValidateResult todo : todoList) {
                    IMarker marker = file.createMarker (IMarker.TASK);
                    marker.setAttribute (IMarker.MESSAGE, todo.getMessage ());
                    marker.setAttribute (IMarker.TRANSIENT, true);
                    marker.setAttribute (IMarker.LOCATION, todo.getLocation ());
                    marker.setAttribute (IMarker.SEVERITY, todo.getSeverity ());
                    editor.setMarkedObject (marker, todo.getObject ());
                }
            }
        }
        ;
        try {
            ResourcesPlugin.getWorkspace ().run (editorMarker, null);
        } catch (CoreException e) {
            Activator.showExceptionDialog (e);
        }
    }
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=4=-----==

private void createTab3 (TabLayoutPanel p) {
    org.eclipse.swt.widgets.Canvas canvas = new org.eclipse.swt.widgets.Canvas ();
    LightweightSystem lws = new LightweightSystem (canvas);
    p.add (canvas.getWidget (), "UML2 Sample");
    Figure contents = new Figure ();
    XYLayout contentsLayout = new XYLayout ();
    contents.setLayoutManager (contentsLayout);
    Image image1 = new Image (null, Images.INSTANCE.icon_class ());
    Image image2 = new Image (null, Images.INSTANCE.icon_field ());
    Image image3 = new Image (null, Images.INSTANCE.icon_method ());
    Font classFont = new Font (null, "Arial", 12, SWT.BOLD);
    Label classLabel1 = new Label ("Table", image1);
    classLabel1.setFont (classFont);
    Label classLabel2 = new Label ("Table2", image1);
    classLabel2.setFont (classFont);
    final UMLClassFigure classFigure = new UMLClassFigure (classLabel1);
    final UMLClassFigure classFigure2 = new UMLClassFigure (classLabel2);
    Label attribute1 = new Label ("columns: Column[]", image2);
    Label attribute2 = new Label ("rows: Row[]", image2);
    Label attribute3 = new Label ("columnID: int", image2);
    Label attribute4 = new Label ("items: List", image2);
    classFigure.getAttributesCompartment ().add (attribute1);
    classFigure.getAttributesCompartment ().add (attribute2);
    classFigure2.getAttributesCompartment ().add (attribute3);
    classFigure2.getAttributesCompartment ().add (attribute4);
    Label method1 = new Label ("getColumns(): Column[]", image3);
    Label method2 = new Label ("getRows(): Row[]", image3);
    Label method3 = new Label ("getColumnID(): int", image3);
    Label method4 = new Label ("getItems(): List", image3);
    classFigure.getMethodsCompartment ().add (method1);
    classFigure.getMethodsCompartment ().add (method2);
    classFigure2.getMethodsCompartment ().add (method3);
    classFigure2.getMethodsCompartment ().add (method4);
    contentsLayout.setConstraint (classFigure, new Rectangle (10, 10, - 1, - 1));
    contentsLayout.setConstraint (classFigure2, new Rectangle (200, 200, - 1, - 1));
    PolylineConnection c = new PolylineConnection ();
    ChopboxAnchor sourceAnchor = new ChopboxAnchor (classFigure);
    ChopboxAnchor targetAnchor = new ChopboxAnchor (classFigure2);
    c.setSourceAnchor (sourceAnchor);
    c.setTargetAnchor (targetAnchor);
    PolygonDecoration decoration = new PolygonDecoration ();
    PointList decorationPointList = new PointList ();
    decorationPointList.addPoint (0, 0);
    decorationPointList.addPoint (- 2, 2);
    decorationPointList.addPoint (- 4, 0);
    decorationPointList.addPoint (- 2, - 2);
    decoration.setTemplate (decorationPointList);
    c.setSourceDecoration (decoration);
    ConnectionEndpointLocator targetEndpointLocator = new ConnectionEndpointLocator (c, true);
    targetEndpointLocator.setVDistance (15);
    Label targetMultiplicityLabel = new Label ("1..*");
    c.add (targetMultiplicityLabel, targetEndpointLocator);
    ConnectionEndpointLocator sourceEndpointLocator = new ConnectionEndpointLocator (c, false);
    sourceEndpointLocator.setVDistance (15);
    Label sourceMultiplicityLabel = new Label ("1");
    c.add (sourceMultiplicityLabel, sourceEndpointLocator);
    ConnectionEndpointLocator relationshipLocator = new ConnectionEndpointLocator (c, true);
    relationshipLocator.setUDistance (10);
    relationshipLocator.setVDistance (- 20);
    Label relationshipLabel = new Label ("contains");
    c.add (relationshipLabel, relationshipLocator);
    contents.add (classFigure);
    contents.add (classFigure2);
    contents.add (c);
    lws.setContents (contents);
    canvas.setSize (500, 300);
}


protected void configureGraphicalViewer () {
    super.configureGraphicalViewer ();
    ScrollingGraphicalViewer viewer = (ScrollingGraphicalViewer) getGraphicalViewer ();
    ScalableFreeformRootEditPart root = new ScalableFreeformRootEditPart ();
    List zoomLevels = new ArrayList (3);
    zoomLevels.add (ZoomManager.FIT_ALL);
    zoomLevels.add (ZoomManager.FIT_WIDTH);
    zoomLevels.add (ZoomManager.FIT_HEIGHT);
    root.getZoomManager ().setZoomLevelContributions (zoomLevels);
    IAction zoomIn = new ZoomInAction (root.getZoomManager ());
    IAction zoomOut = new ZoomOutAction (root.getZoomManager ());
    getActionRegistry ().registerAction (zoomIn);
    getActionRegistry ().registerAction (zoomOut);
    getSite ().getKeyBindingService ().registerAction (zoomIn);
    getSite ().getKeyBindingService ().registerAction (zoomOut);
    viewer.setRootEditPart (root);
    viewer.setEditPartFactory (new GraphicalPartFactory ());
    ContextMenuProvider provider = new LogicContextMenuProvider (viewer, getActionRegistry ());
    viewer.setContextMenu (provider);
    getSite ().registerContextMenu ("org.eclipse.gef.examples.logic.editor.contextmenu", provider, viewer);
    viewer.setKeyHandler (new GraphicalViewerKeyHandler (viewer).setParent (getCommonKeyHandler ()));
    loadProperties ();
    IAction showRulers = new ToggleRulerVisibilityAction (getGraphicalViewer ());
    getActionRegistry ().registerAction (showRulers);
    IAction snapAction = new ToggleSnapToGeometryAction (getGraphicalViewer ());
    getActionRegistry ().registerAction (snapAction);
    IAction showGrid = new ToggleGridAction (getGraphicalViewer ());
    getActionRegistry ().registerAction (showGrid);
    Listener listener = new Listener () {
        public void handleEvent (Event event) {
            handleActivationChanged (event);
        }
    }
    ;
    getGraphicalControl ().addListener (SWT.Activate, listener);
    getGraphicalControl ().addListener (SWT.Deactivate, listener);
}


-----Function Pair=5=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


public static void uploadPromptFile (Prompt prompt, File f) throws Exception {
    if (! f.exists ()) {
        throw new FileNotFoundException ("Couldn't find actionpak file " + f);
    }
    Date lm = new Date (f.lastModified ());
    String promptName = prompt.getName ();
    String pid = prompt.getProject () == null ? null : prompt.getProject ().getName ();
    if (prompt.getExtension () != null) promptName += "." + prompt.getExtension ();
    if (pid != null) promptName = pid + "/" + promptName;
    String promptFileName = prompt.getName () + '.' + prompt.getExtension ();
    boolean promptNeedsUpdate = SafiServerRemoteManager.getInstance ().promptNeedsUpdate (pid, promptFileName, lm);
    if (! promptNeedsUpdate) {
        promptNeedsUpdate = MessageDialog.openConfirm (getActiveShell (), "Newer File Exists", "A newer prompt file by this name already exists on the server.  Do you still want to overwrite?");
    }
    if (promptNeedsUpdate) {
        byte [] data = new byte [(int) f.length ()];
        FileInputStream fis = new FileInputStream (f);
        BufferedInputStream bis = new BufferedInputStream (fis);
        bis.read (data);
        bis.close ();
        SafiServerRemoteManager.getInstance ().transferPrompt (pid, promptFileName, data);
        promptCache.remove (prompt.getId ());
    }
}


-----Function Pair=6=-----==

public static Rectangle getDiagramExtents (GraphicalViewer diagramViewer) {
    FreeformGraphicalRootEditPart rootEditPart = (FreeformGraphicalRootEditPart) diagramViewer.getRootEditPart ();
    if (! hasChildFigures (rootEditPart)) {
        return new Rectangle (100, 100, 100, 100);
    }
    IFigure figure = rootEditPart.getLayer (LayerConstants.PRINTABLE_LAYERS);
    Rectangle extents = figure.getBounds ().getCopy ();
    IFigure primaryLayer = rootEditPart.getLayer (LayerConstants.PRIMARY_LAYER);
    Rectangle rect = new Rectangle (primaryLayer.getBounds ().width, primaryLayer.getBounds ().height, primaryLayer.getBounds ().x, primaryLayer.getBounds ().y);
    for (Object child : primaryLayer.getChildren ()) {
        if (child instanceof FreeformLayer) {
            for (Object o : ((Figure) child).getChildren ()) {
                getDiagramExtents ((IFigure) o, rect);
            }
        }
    }
    IFigure connectionLayer = rootEditPart.getLayer (LayerConstants.CONNECTION_LAYER);
    Rectangle rect2 = new Rectangle (connectionLayer.getBounds ().width, connectionLayer.getBounds ().height, connectionLayer.getBounds ().x, connectionLayer.getBounds ().y);
    for (Object child : connectionLayer.getChildren ()) {
        if (child instanceof IFigure) {
            getDiagramExtents ((IFigure) child, rect2);
        }
    }
    rect.x = Math.min (rect.x, rect2.x);
    rect.y = Math.min (rect.y, rect2.y);
    rect.width = Math.max (rect.width, rect2.width);
    rect.height = Math.max (rect.height, rect2.height);
    extents.x = Math.max (extents.x, rect.x);
    extents.y = Math.max (extents.y, rect.y);
    extents.width = Math.min (extents.width, rect.width - extents.x);
    extents.height = Math.min (extents.height, rect.height - extents.y);
    int BORDER_WIDTH = 10;
    extents.x -= BORDER_WIDTH;
    extents.y -= BORDER_WIDTH;
    extents.width += BORDER_WIDTH * 2;
    extents.height += BORDER_WIDTH * 2;
    return extents;
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=7=-----==

public void run () {
    Thread me = Thread.currentThread ();
    while (thread == me && ! isShowing () || getSize ().width == 0) {
        try {
            thread.sleep (500);
        } catch (InterruptedException e) {
            return;
        }
    }
    while (thread == me && isShowing ()) {
        repaint ();
        try {
            thread.sleep (sleepAmount);
        } catch (InterruptedException e) {
            break;
        }
    }
    thread = null;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=8=-----==

public static float medianElement (float [] array, int size) {
    float [] tmpArray = new float [size];
    System.arraycopy (array, 0, tmpArray, 0, size);
    boolean changed = true;
    while (changed) {
        changed = false;
        for (int i = 0; i < size - 1; i ++) {
            if (tmpArray [i] > tmpArray [i + 1]) {
                changed = true;
                float tmp = tmpArray [i];
                tmpArray [i] = tmpArray [i + 1];
                tmpArray [i + 1] = tmp;
            }
        }
    }
    return tmpArray [size / 2];
}


public void jitterShift () {
    int negativ = 0;
    for (TaskResult task : taur) {
        if (task != null) {
            if (task.getT0 () >= 0.0) {
                task.setT1 (task.getT0 ());
            }
            else {
                if (task.getT0 () + task.j >= 0.0) {
                    task.setT1 (0.0);
                }
                else {
                    task.setT1 (task.getT0 ());
                    negativ ++;
                }
            }
            task.o = task.getT1 ();
        }
    }
    if (negativ > 0) {
        TaskResult [] tau2 = taur;
        taur = new TaskResult [taur.length - negativ];
        for (int i = 0, j = 0; i < tau2.length; i ++) {
            if (tau2 [i].getT1 () >= 0) {
                taur [j] = tau2 [i];
                j ++;
            }
        }
        tau = taur;
    }
    int ir = 0;
    while (taur [taur.length - 1 - ir].getT1 () > tmax) {
        ir ++;
    }
    if (ir > 0) {
        TaskResult [] tau2 = taur;
        taur = new TaskResult [tau2.length - ir];
        for (int i = 0; i < tau2.length - ir; i ++) {
            taur [i] = tau2 [i];
        }
        tau = taur;
    }
}


-----Function Pair=9=-----==

void validateExamples (Vector < DataPoint > xvec, int i1, int i2) {
    if (dis.dcs == Suite.DCS.Uncommitted) {
        throw new AssertionError ("How come I have not commiitted discr before training?");
    }
    else if (dis.dcs == Suite.DCS.Fixed || dis.dcs == Suite.DCS.Bounded) {
    }
    else if (dis.dcs == Suite.DCS.Unbounded) {
        throw new UnsupportedOperationException ("No learner currently supported discrimination class structure DCS3, a.k.a. " + dis.dcs);
    }
    else {
        throw new AssertionError ("Unknonw DCS type: " + dis.dcs);
    }
    if (! isFallback) return;
    for (int i = i1; i < i2; i ++) {
        DataPoint x = xvec.elementAt (i);
        Discrimination.Cla labC = x.claForDisc (dis);
        if (labC != dis.getDefaultCla ()) {
            throw new IllegalArgumentException ("DataPoint " + x + " carries a non-default class label " + labC + " for the fallback discrimination, which is prohibited");
        }
    }
}


private void sortMasters () {
    masterCounter = 0;
    for (int i = 0; i < maxID; i ++) {
        if (users [i].getMasterPoints () > 0) {
            masterHandleList [masterCounter] = users [i].getHandle ();
            masterPointsList [masterCounter] = users [i].getMasterPoints ();
            masterCounter = masterCounter + 1;
        }
    }
    for (int i = masterCounter; -- i >= 0;) {
        for (int j = 0; j < i; j ++) {
            if (masterPointsList [j] > masterPointsList [j + 1]) {
                int tempp = masterPointsList [j];
                String temppstring = masterHandleList [j];
                masterPointsList [j] = masterPointsList [j + 1];
                masterHandleList [j] = masterHandleList [j + 1];
                masterPointsList [j + 1] = tempp;
                masterHandleList [j + 1] = temppstring;
            }
        }
    }
}


-----Function Pair=10=-----==

public NewInterpolationExploration () {
    super (true);
    currentTextSize = TEXT_SIZE;
    currentMathSize = MATH_SIZE;
    currentLabelFont = LABEL_FONT;
    currentFieldFont = FIELD_FONT;
    graphicsPanel = new ClickableMathPainterPanel ();
    graphicsPanel.addMathPainterPanelListener (this);
    contentSettingsPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Content Settings", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    contentSettingsPanel.setLayout (contentSettingsPanelLayout);
    plotLabelLbl.setFont (LABEL_FONT);
    plotLabelTFd.setFont (FIELD_FONT);
    scalingLbl.setFont (LABEL_FONT);
    scalingTFd.setFont (FIELD_FONT);
    plotColorBtn.setButtonFont (LABEL_FONT);
    dataColorBtn.setButtonFont (LABEL_FONT);
    degreeLbl.setFont (LABEL_FONT);
    lagrangianCBx.setFont (LABEL_FONT);
    addPointRBtn.setFont (LABEL_FONT);
    deletePointRBtn.setFont (LABEL_FONT);
    lagrangianCBx.setFont (LABEL_FONT);
    xNMeshLbl.setFont (LABEL_FONT);
    localStylesBtn.setFont (LABEL_FONT);
    degreeTFd.setFont (FIELD_FONT);
    xNMeshTFd.setFont (FIELD_FONT);
    degreeTFd.setEditable (! lagrangian);
    degreeTFd.addKeyListener (this);
    xNMeshTFd.addKeyListener (this);
    plotLabelTFd.addKeyListener (this);
    scalingTFd.addKeyListener (this);
    lagrangianCBx.addItemListener (this);
    localStylesBtn.addActionListener (this);
    addPointRBtn.addActionListener (this);
    deletePointRBtn.addActionListener (this);
    clickActionBGp.add (addPointRBtn);
    clickActionBGp.add (deletePointRBtn);
    contentSettingsPanelLayout.add (degreeLbl, contentSettingsPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (degreeTFd, contentSettingsPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (lagrangianCBx, contentSettingsPanel, 2, 0, 2, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (addPointRBtn, contentSettingsPanel, 0, 1, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (deletePointRBtn, contentSettingsPanel, 2, 1, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (xNMeshLbl, contentSettingsPanel, 0, 2, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (xNMeshTFd, contentSettingsPanel, 1, 2, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (localStylesBtn, contentSettingsPanel, 1, 3, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Visual Settings", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    windowSettingsPanel.setLayout (windowSettingsPanelLayout);
    windowXMinLbl.setFont (LABEL_FONT);
    windowXMaxLbl.setFont (LABEL_FONT);
    windowYMinLbl.setFont (LABEL_FONT);
    windowYMaxLbl.setFont (LABEL_FONT);
    globalStylesBtn.setFont (LABEL_FONT);
    windowXMinTFd.setFont (FIELD_FONT);
    windowXMaxTFd.setFont (FIELD_FONT);
    windowYMinTFd.setFont (FIELD_FONT);
    windowYMaxTFd.setFont (FIELD_FONT);
    windowSettingsPanelLayout.add (windowXMinLbl, windowSettingsPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowXMinTFd, windowSettingsPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowXMaxLbl, windowSettingsPanel, 2, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowXMaxTFd, windowSettingsPanel, 3, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowYMinLbl, windowSettingsPanel, 0, 1, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowYMinTFd, windowSettingsPanel, 1, 1, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowYMaxLbl, windowSettingsPanel, 2, 1, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowYMaxTFd, windowSettingsPanel, 3, 1, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (globalStylesBtn, windowSettingsPanel, 1, 2, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowXMinTFd.addKeyListener (this);
    windowXMaxTFd.addKeyListener (this);
    windowYMinTFd.addKeyListener (this);
    windowYMaxTFd.addKeyListener (this);
    globalStylesBtn.addActionListener (this);
    controlPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Controls", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    controlPanel.setLayout (controlPanelLayout);
    drawCurvesBtn.setFont (LABEL_FONT);
    eraseCurvesBtn.setFont (LABEL_FONT);
    autoscaleBtn.setFont (LABEL_FONT);
    controlPanelLayout.add (drawCurvesBtn, controlPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    controlPanelLayout.add (eraseCurvesBtn, controlPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    controlPanelLayout.add (autoscaleBtn, controlPanel, 2, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    drawCurvesBtn.addActionListener (this);
    eraseCurvesBtn.addActionListener (this);
    autoscaleBtn.addActionListener (this);
    this.setLayout (mainPanelLayout);
    mainPanelLayout.add (contentSettingsPanel, this, 0, 0, 1, 1, 10, 100, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (windowSettingsPanel, this, 0, 1, 1, 1, 10, 10, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (graphicsPanel, this, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (controlPanel, this, 1, 1, 1, 1, 100, 10, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    textPlusBtn.setFont (LABEL_FONT);
    textMinusBtn.setFont (LABEL_FONT);
    textPlusBtn.addActionListener (this);
    textMinusBtn.addActionListener (this);
}


public void visitAssignop (JCAssignOp tree) {
    OperatorSymbol operator = (OperatorSymbol) tree.operator;
    Item l;
    if (operator.opcode == string_add) {
        makeStringBuffer (tree.pos ());
        l = genExpr (tree.lhs, tree.lhs.type);
        if (l.width () > 0) {
            code.emitop0 (dup_x1 + 3 * (l.width () - 1));
        }
        l.load ();
        appendString (tree.lhs);
        appendStrings (tree.rhs);
        bufferToString (tree.pos ());
    }
    else {
        l = genExpr (tree.lhs, tree.lhs.type);
        if ((tree.getTag () == JCTree.PLUS_ASG || tree.getTag () == JCTree.MINUS_ASG) && l instanceof LocalItem && tree.lhs.type.tag <= INT && tree.rhs.type.tag <= INT && tree.rhs.type.constValue () != null) {
            int ival = ((Number) tree.rhs.type.constValue ()).intValue ();
            if (tree.getTag () == JCTree.MINUS_ASG) ival = - ival;
            ((LocalItem) l).incr (ival);
            result = l;
            return;
        }
        l.duplicate ();
        l.coerce (operator.type.getParameterTypes ().head).load ();
        completeBinop (tree.lhs, tree.rhs, operator).coerce (tree.lhs.type);
    }
    result = items.makeAssignItem (l);
}


-----Function Pair=11=-----==

public static void bubbleSort (int [] array) {
    for (int i = 0; i < array.length - 1; i ++) {
        for (int j = 0; j < array.length - i - 1; j ++) {
            if (array [j] > array [j + 1]) {
                int temp = array [j];
                array [j] = array [j + 1];
                array [j + 1] = temp;
            }
        }
        System.out.println ("��" + (i + 1) + "������");
        for (int k = 0; k < array.length; k ++) {
            System.out.print (array [k] + " ");
        }
        System.out.println ();
    }
}


private static void f (int i, byte [] key, byte [] a, byte [] x) {
    byte [] e = new byte [64];
    byte [] ikey = new byte [64];
    byte [] y = new byte [64];
    System.arraycopy (a, 0, e, 0, e.length);
    transpose (e, EP, 48);
    for (int j = rots [i]; j > 0; j --) {
        rotate (key);
    }
    System.arraycopy (key, 0, ikey, 0, ikey.length);
    transpose (ikey, KeyTr2, 48);
    for (int j = 0; j < 48; j ++) {
        y [j] = (byte) (e [j] ^ ikey [j]);
    }
    for (int j = 0; j < 8; j ++) {
        int k = j + 1;
        int r = 32 * y [6 * k - 6] + 8 * y [6 * k - 5] + 4 * y [6 * k - 4] + 2 * y [6 * k - 3] + y [6 * k - 2] + 16 * y [6 * k - 1];
        int xb = s_boxes [j] [r];
        x [4 * k - 4] = (byte) ((xb>> 3) & 1);
        x [4 * k - 3] = (byte) ((xb>> 2) & 1);
        x [4 * k - 2] = (byte) ((xb>> 1) & 1);
        x [4 * k - 1] = (byte) (xb & 1);
    }
    transpose (x, ptr, 32);
}


-----Function Pair=12=-----==

public WordsEnumerator (IRebus rebus, RebusEnumerator enumerator) {
    AbstractWord [] words = new AbstractWord [rebus.getVisibleWords ().size ()];
    int k = 0;
    for (VisibleWord word : rebus.getVisibleWords ()) {
        words [k ++] = word.getElement ();
    }
    for (int j = 0; j < words.length; j ++) {
        for (int i = 0; i < words.length - 1; i ++) {
            if (words [i].compareTo (words [i + 1]) == - 1) {
                AbstractWord w = words [i];
                words [i] = words [i + 1];
                words [i + 1] = w;
            }
        }
    }
    myEnumerator = enumerator;
    myRebus = rebus;
    myWords = words;
    myHelpers = new EnumHelper [words.length];
}


public void parseURL (final String [] newArgs, final boolean allowDownload, final boolean modifySelected, final int modifyRow) {
    Thread praseThread = new Thread (new Runnable () {
        public void run () {
            Common.urlIsUnknown = false;
            if (newArgs == null || newArgs [0].equals ("")) {
                if (! allowDownload) {
                    stateBar.setText ("  沒有輸入網址 !!");
                }
                else {
                    if (Common.missionCount > 0) {
                        Flag.parseUrlFlag = false;
                        startDownloadList (false);
                    }
                    else {
                        stateBar.setText ("  沒有下載任務也沒有輸入網址 !!");
                    }
                }
            }
            else if (! Common.isLegalURL (newArgs [0])) {
                stateBar.setText ("  網址錯誤，請輸入正確的網址 !!");
            }
            else {
                stateBar.setText ("  解析網址中");
                if (Common.withGUI ()) {
                    trayIcon.setToolTip ("解析網址中");
                }
                Flag.allowDownloadFlag = false;
                Run.isAlive = true;
                String [] tempArgs = Common.getCopiedStrings (newArgs);
                mainRun = new Run (tempArgs, RunModeEnum.PARSE_MODE);
                mainRun.start ();
                String title = "";
                try {
                    mainRun.join ();
                } catch (InterruptedException ex) {
                    ex.printStackTrace ();
                }
                title = mainRun.getTitle ();
                Common.debugPrintln ("選擇集數前解析得到的title：" + title);
                if (Common.urlIsUnknown) {
                    stateBar.setText ("  無法解析此網址 !!");
                }
                else if (Common.isMainPage) {
                    runChoiceFrame (modifySelected, modifyRow, title, tempArgs [0]);
                    if (allowDownload) {
                        Flag.parseUrlFlag = false;
                        startDownloadList (true);
                    }
                }
                else {
                    if (! allowDownload) {
                        stateBar.setText ("  單集頁面無法加入下載佇列 !!");
                    }
                    else {
                        stateBar.setText ("  正在下載單一集數");
                        Flag.parseUrlFlag = false;
                        startDownloadURL (tempArgs);
                    }
                }
            }
            Flag.parseUrlFlag = false;
        }
    }
    );
    praseThread.start ();
}


-----Function Pair=13=-----==

public void actionPerformed (ActionEvent ae) {
    if (ae.getSource () == localStylesBtn) {
        plotStyleFrame = new JFrame ("Plot Style Settings");
        plotStylePanel = new JPanel ();
        plotStylePanel.setLayout (stylePanelLayout);
        stylePanelLayout.add (plotLabelLbl, plotStylePanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (plotLabelTFd, plotStylePanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (scalingLbl, plotStylePanel, 0, 1, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (scalingTFd, plotStylePanel, 1, 1, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (plotColorBtn, plotStylePanel, 0, 3, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (dataColorBtn, plotStylePanel, 0, 4, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
        plotStyleFrame.getContentPane ().setLayout (new GridLayout (1, 0));
        plotStyleFrame.add (plotStylePanel);
        plotStyleFrame.setSize (300, 300);
        plotStyleFrame.setVisible (true);
    }
    else if (ae.getSource () == addPointRBtn || ae.getSource () == deletePointRBtn) {
        clickAction = ! clickAction;
    }
    else if (ae.getSource () == eraseCurvesBtn) {
        graphicsPanel.clearCompletely ();
        initializeGraphics ();
        drawGraphPaper ();
        graphicsPanel.setBase ();
        graphicsPanel.update ();
    }
    else if (ae.getSource () == drawCurvesBtn) {
        draw ();
    }
    else if (ae.getSource () == globalStylesBtn) {
        styleFrame = new JFrame ("Global Style Settings");
        stylePanel = new JPanel ();
        stylePanel.setLayout (stylePanelLayout);
        stylePanelLayout.add (textPlusBtn, stylePanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.CENTER);
        stylePanelLayout.add (textMinusBtn, stylePanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.CENTER);
        styleFrame.getContentPane ().setLayout (new GridLayout (1, 0));
        styleFrame.add (stylePanel);
        styleFrame.setSize (300, 300);
        styleFrame.setVisible (true);
    }
    else if (ae.getSource () == textPlusBtn) {
        currentTextSize ++;
        currentMathSize ++;
        updateFonts ();
    }
    else if (ae.getSource () == textMinusBtn) {
        currentTextSize --;
        currentMathSize --;
        updateFonts ();
    }
    else if (ae.getSource () == autoscaleBtn) {
        System.out.println ("autoscale button pressed");
        double newYMin = 1.1 * yMin - 0.1 * yMax;
        double newYMax = 1.1 * yMax - 0.1 * yMin;
        newYMin = Math.round (1000.0 * newYMin) / 1000.0;
        newYMax = Math.round (1000.0 * newYMax) / 1000.0;
        windowYMinTFd.setText ("" + newYMin);
        windowYMaxTFd.setText ("" + newYMax);
        draw ();
    }
    else {
        try {
            draw ();
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
}


public OrdersTO doTrade () throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    if (currTime < PERIODO) {
        novo_dia (preco, dias);
        return createOrdemTO (0, preco, true);
    }
    else {
        double m = media (dias);
        int v;
        if (Trend.trend (dias) > 0 && dias [PERIODO - 1] < m) v = VOLUME;
        else if (Trend.trend (dias) < 0 && m < dias [PERIODO - 1]) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, dias);
        return createOrdemTO (Math.abs (v), preco, true);
    }
}


-----Function Pair=14=-----==

private void createUI () {
    lookAndFeels.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
    lookAndFeels.setVisibleRowCount (Math.max (5, Math.min (lookAndFeels.getModel ().getSize (), 10)));
    JScrollPane scrollPane = new JScrollPane (lookAndFeels);
    scrollPane.setVerticalScrollBarPolicy (JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setHorizontalScrollBarPolicy (JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    JPanel restartPanel = new JPanel (new GridLayout (2, 1, 5, 5));
    restartPanel.add (new JLabel ("You must restart Tonic to apply"));
    restartPanel.add (new JLabel ("the new Look and Feel"));
    setLayout (new BorderLayout (10, 10));
    add (scrollPane, BorderLayout.CENTER);
    add (restartPanel, BorderLayout.SOUTH);
    lookAndFeels.addListSelectionListener (new ListSelectionListener () {
        public void valueChanged (ListSelectionEvent evt) {
            fireStateChanged ();
        }
    }
    );
}


public void doSetPreference (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    if (args.length == 0) {
        ret.append ("Current preferences: \n");
        ret.append ("  integer = " + integerPreference + "\n");
        ret.append ("  stack = " + stackPreference + "\n");
        ret.append ("  fpr = " + fprPreference + "\n");
        jdp_console.writeOutput (ret.toString ());
    }
    else if (args [0].equals ("int")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) integerPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) integerPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("stack")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) stackPreference = 'x';
        else if (args [1].equals ("decimal") || args [1].equals ("dec") || args [1].equals ("d")) stackPreference = 'd';
        else printHelp (command);
        return;
    }
    else if (args [0].equals ("fpr")) {
        if (args [1].equals ("hexadecimal") || args [1].equals ("hex") || args [1].equals ("x")) fprPreference = 'x';
        else if (args [1].equals ("float") || args [1].equals ("f")) fprPreference = 'f';
        else printHelp (command);
        return;
    }
    else {
        printHelp (command);
    }
}


-----Function Pair=15=-----==

private int readEOL (boolean isFirstEOL) {
    if (fillBits == 0) {
        int next12Bits = nextNBits (12);
        if (isFirstEOL && next12Bits == 0) {
            if (nextNBits (4) == 1) {
                fillBits = 1;
                return 1;
            }
        }
        if (next12Bits != 1) {
            throw new RuntimeException ("Scanline must begin with EOL code word.");
        }
    }
    else if (fillBits == 1) {
        int bitsLeft = 8 - bitPointer;
        if (nextNBits (bitsLeft) != 0) {
            throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
        }
        if (bitsLeft < 4) {
            if (nextNBits (8) != 0) {
                throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
            }
        }
        int n;
        while ((n = nextNBits (8)) != 1) {
            if (n != 0) {
                throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
            }
        }
    }
    if (oneD == 0) {
        return 1;
    }
    else {
        return nextLesserThan8Bits (1);
    }
}


private byte [] Encrypt (int [] timeData, int flag, int [] [] keyarray) {
    int i;
    byte [] encrypt = new byte [8];
    int flags = flag;
    int [] M = new int [64];
    int [] MIP_1 = new int [64];
    for (i = 0; i < 64; i ++) {
        M [i] = timeData [IP [i] - 1];
    }
    if (flags == 1) {
        for (i = 0; i < 16; i ++) {
            LoopF (M, i, flags, keyarray);
        }
    }
    else if (flags == 0) {
        for (i = 15; i > - 1; i --) {
            LoopF (M, i, flags, keyarray);
        }
    }
    for (i = 0; i < 64; i ++) {
        MIP_1 [i] = M [IP_1 [i] - 1];
    }
    GetEncryptResultOfByteArray (MIP_1, encrypt);
    return encrypt;
}


-----Function Pair=16=-----==

protected int [] getNumericInputAttributeIndices () {
    int [] indices = store.getInputAttributesIndices ();
    for (int i = 0; i < indices.length; i ++) {
        if (store.getAttributeType (i) != PreprocessingStorage.DataType.NUMERIC) {
            logger.warn ("Implemented outlier detection methods can not work on non-numeric game.data :(. Skipping attribute " + store.getAttributeName (i));
            int [] newIndices = new int [indices.length - 1];
            for (int j = 0; j < newIndices.length; j ++) {
                if (j < i) newIndices [j] = indices [j];
                else newIndices [j] = indices [j + 1];
            }
            indices = newIndices;
            i --;
        }
    }
    return indices;
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    in = new LineNumberReader (new FileReader (file_name));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=17=-----==

public void setFileWidth (int multiplier, char digitCode) {
    int widthCode = - 1;
    switch (digitCode) {
        case 'Y' :
            widthCode = TimeUtil.YEAR;
            break;
        case 'm' :
            widthCode = TimeUtil.MONTH;
            break;
        case 'd' :
            widthCode = TimeUtil.DAY;
            break;
        case 'H' :
            widthCode = TimeUtil.HOUR;
            break;
        case 'M' :
            widthCode = TimeUtil.MINUTE;
            break;
        case 'S' :
            widthCode = TimeUtil.SECOND;
            break;
        default :
            throw new IllegalArgumentException ("bad digit code: " + digitCode + ", must be Y,m,d,H,M,or S");
    }
    this.timeWidthMultiplier = multiplier;
    this.timeWidth = widthCode;
}


void RefreshHintWindow () {
    ito = cursorPos;
    while (true) {
        if (ito == inputLine.length ()) break;
        if (! LispTokenizer.IsAlpha (inputLine.charAt (ito))) break;
        ito ++;
    }
    if (ito > 0) {
        int c = inputLine.charAt (ito - 1);
        if (c == ',' || c == ')') {
            int braces = - 1;
            if (c == ')') {
                ito --;
                braces = - 2;
            }
            while (braces != 0) {
                if (ito <= 0) break;
                if (inputLine.charAt (ito - 1) == '(') braces ++;
                if (inputLine.charAt (ito - 1) == ')') braces --;
                ito --;
            }
        }
    }
    if (ito > 0) {
        if (inputLine.charAt (ito - 1) == '(') {
            ito --;
        }
    }
    if (ito == 0) {
        while (true) {
            if (ito == cursorPos) break;
            if (! LispTokenizer.IsAlpha (inputLine.charAt (ito))) break;
            ito ++;
        }
    }
    int ifrom = ito;
    while (true) {
        if (ifrom == 0) break;
        char c = inputLine.charAt (ifrom - 1);
        if (! LispTokenizer.IsAlpha (c) && ! LispTokenizer.IsDigit (c)) break;
        ifrom --;
    }
    while (ifrom < ito && LispTokenizer.IsDigit (inputLine.charAt (ifrom))) ifrom ++;
    matchToInsert = "";
    lastMatchedWord = "";
    if (ito > ifrom) {
        lastMatchedWord = inputLine.substring (ifrom, ito);
    }
    hintWindow = null;
    if (lastMatchedWord.length () > 0) {
        int nr = lastMatchedWord.length ();
        int maxHintLines = 18;
        String texts [] = new String [maxHintLines + 1];
        int nrHintLines = 0;
        int i;
        for (i = 0; i < the_hints.nrHintTexts; i ++) {
            if (nrHintLines == maxHintLines) break;
            if (nr <= (the_hints.hintTexts [i].base).length () && lastMatchedWord.equals (the_hints.hintTexts [i].base.substring (0, nr))) {
                boolean add = true;
                if (nrHintLines > 0) {
                    if (texts [nrHintLines - 1].equals (the_hints.hintTexts [i].base)) add = false;
                }
                if (add) {
                    texts [nrHintLines ++] = the_hints.hintTexts [i].base;
                }
                if (nrHintLines == 1 && ito != cursorPos && lastMatchedWord.equals (the_hints.hintTexts [i].base)) {
                    break;
                }
            }
        }
        if (nrHintLines == maxHintLines) {
            texts [nrHintLines ++] = "...";
        }
        if (nrHintLines == 1) {
            if (lastMatchedWord.length () < texts [0].length ()) {
                matchToInsert = texts [0].substring (lastMatchedWord.length (), texts [0].length ());
            }
            hintWindow = TryToHint (texts [0], texts [0].length ());
        }
        else if (nrHintLines > 1) {
            hintWindow = CreateHints (12);
            hintWindow.iAllowSelection = true;
            for (i = 0; i < nrHintLines; i ++) {
                AddHintLine (hintWindow, texts [i], "");
            }
        }
    }
}


-----Function Pair=18=-----==

public void fillFromImage (final float [] [] [] fa, final ViewPointConversion tp) {
    assert fa != null;
    assert tp != null;
    if (m_data != null) {
        switch (tp) {
            case CoronalToSagittal :
                {
                    int w = getWidth ();
                    int h = getHeight ();
                    assert w == fa.length;
                    assert h == fa [0].length;
                    int aw = fa [0] [0].length;
                    int pos = aw - getIndex () - 1;
                    assert 0 <= pos && pos < aw;
                    for (int y = 0, i = 0; y < h; y ++) {
                        for (int x = 0; x < w; x ++, i ++) {
                            m_data [i] = fa [x] [y] [pos];
                        }
                    }
                }
                break;
            case SagittalToCoronal :
                {
                    int w = getWidth ();
                    int h = getHeight ();
                    assert w == fa.length;
                    assert h == fa [0].length;
                    int pos = getIndex ();
                    assert 0 <= pos && pos < fa [0] [0].length;
                    for (int y = 0, i = 0; y < h; y ++) {
                        for (int x = w - 1; x >= 0; x --, i ++) {
                            m_data [i] = fa [x] [y] [pos];
                        }
                    }
                }
                break;
            case CoronalToAxial :
                {
                    int w = getWidth ();
                    int h = getHeight ();
                    assert w == fa [0] [0].length;
                    assert h == fa.length;
                    int zLast = h - 1;
                    int idx = getIndex ();
                    assert 0 <= idx && idx < fa [0].length;
                    for (int y = 0, z = zLast, dst = 0; y < h; y ++, z --, dst += w) {
                        System.arraycopy (fa [z] [idx], 0, m_data, dst, w);
                    }
                }
                break;
            case AxialToCoronal :
                {
                    int w = getWidth ();
                    int h = getHeight ();
                    assert w == fa [0] [0].length;
                    assert h == fa.length;
                    int ah = fa [0].length;
                    int idx = ah - getIndex () - 1;
                    assert 0 <= idx && idx < fa [0].length;
                    for (int y = 0, z = 0, dst = 0; y < h; y ++, z ++, dst += w) {
                        System.arraycopy (fa [z] [idx], 0, m_data, dst, w);
                    }
                }
                break;
            case SagittalToAxial :
                {
                    int w = getWidth ();
                    int h = getHeight ();
                    assert w == fa.length;
                    assert h == fa [0] [0].length;
                    int pos = getIndex ();
                    int ah = fa [0].length;
                    assert 0 <= pos && pos < ah;
                    for (int x = h - 1, i = 0; x >= 0; x --) {
                        for (int z = w - 1; z >= 0; z --, i ++) {
                            m_data [i] = fa [z] [pos] [x];
                        }
                    }
                }
                break;
        }
    }
}


public HashMap getOccurrenceTypes () {
    Collection occurstypes;
    HashMap retur = new HashMap ();
    occurDetails = new HashMap ();
    ClassInstanceIndexIF tindex = (ClassInstanceIndexIF) tm.getIndex ("net.ontopia.topicmaps.core.index.ClassInstanceIndexIF");
    occurstypes = tindex.getOccurrenceTypes ();
    Iterator ito = occurstypes.iterator ();
    while (ito.hasNext ()) {
        TopicIF t_temp = (TopicIF) ito.next ();
        Collection c_temp = tindex.getOccurrences (t_temp);
        if (! c_temp.isEmpty () && t_temp != null) {
            retur.put (ts.toString (t_temp), new Integer (c_temp.size ()));
            occurDetails.put (ts.toString (t_temp), t_temp);
        }
    }
    return retur;
}


-----Function Pair=19=-----==

private static final int partition (int [] list, int p, int r) {
    int i = p - 1;
    int tmp, x = list [r];
    for (int j = p; j < r; j ++) {
        if (x > list [j]) {
            i ++;
            tmp = list [i];
            list [i] = list [j];
            list [j] = tmp;
        }
    }
    i ++;
    tmp = list [i];
    list [i] = list [r];
    list [r] = tmp;
    return i;
}


public static final String escapeForXML (String string) {
    if (string == null || string.length () == 0) {
        return string;
    }
    char [] sArray = string.toCharArray ();
    StringBuffer buf = new StringBuffer (sArray.length);
    char ch;
    for (int i = 0; i < sArray.length; i ++) {
        ch = sArray [i];
        if (ch == '<') {
            buf.append ("&lt;");
        }
        else if (ch == '&') {
            buf.append ("&amp;");
        }
        else if (ch == '"') {
            buf.append ("&quot;");
        }
        else {
            buf.append (ch);
        }
    }
    return buf.toString ();
}


-----Function Pair=20=-----==

public static void main (String args []) {
    SocialGolfer example = new SocialGolfer ();
    example.setup (3, 2, 2);
    example.model ();
    example.search ();
    example.setup (2, 5, 4);
    example.model ();
    example.search ();
    example.setup (2, 6, 4);
    example.model ();
    example.search ();
    example.setup (2, 7, 4);
    example.model ();
    example.search ();
    example.setup (3, 5, 4);
    example.model ();
    example.search ();
    example.setup (3, 6, 4);
    example.model ();
    example.search ();
    example.setup (3, 7, 4);
    example.model ();
    example.search ();
    example.setup (4, 5, 4);
    example.model ();
    example.search ();
    example.setup (4, 6, 5);
    example.model ();
    example.search ();
    example.setup (4, 7, 4);
    example.model ();
    example.search ();
    example.setup (4, 9, 4);
    example.model ();
    example.search ();
    example.setup (5, 5, 3);
    example.model ();
    example.search ();
    example.setup (5, 7, 4);
    example.model ();
    example.search ();
    example.setup (5, 8, 3);
    example.model ();
    example.search ();
    example.setup (6, 6, 3);
    example.model ();
    example.search ();
    example.setup (5, 3, 2);
    example.model ();
    example.search ();
    example.setup (4, 3, 3);
    example.model ();
    example.search ();
}


public void run (String arg) {
    ImagePlus imp = WindowManager.getCurrentImage ();
    if (imp == null) {
        IJ.showMessage ("Image required");
        return;
    }
    final CustomWindow cw = new CustomWindow ();
    cw.init (imp);
    final Frame f = new Frame ("Interactive Surface Plot (" + version + ") ");
    f.setLocation (300, 150);
    f.addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            cw.cleanup ();
            f.dispose ();
        }
    }
    );
    f.add (cw);
    f.pack ();
    f.setResizable (false);
    Insets ins = f.getInsets ();
    cw.totalSize.height = CustomWindow.H + ins.bottom + ins.top + 65;
    cw.totalSize.width = CustomWindow.WR + ins.left + ins.right;
    f.setSize (cw.totalSize);
    f.setVisible (true);
    cw.requestFocus ();
    cw.addKeyListener (new KeyAdapter () {
        public void keyPressed (KeyEvent e) {
            if (e.isShiftDown ()) shift = true;
        } public void keyReleased (KeyEvent e) {
            if (! e.isShiftDown ()) shift = false;
        }
    }
    );
}


-----Function Pair=21=-----==

public void decode2D (byte [] buffer, byte [] compData, int startX, int height, long tiffT4Options) {
    this.data = compData;
    compression = 3;
    bitPointer = 0;
    bytePointer = 0;
    int scanlineStride = (w + 7) / 8;
    int a0;
    int a1;
    int b1;
    int b2;
    int [] b = new int [2];
    int entry;
    int code;
    int bits;
    boolean isWhite;
    int currIndex = 0;
    int [] temp;
    oneD = (int) (tiffT4Options & 0x01);
    fillBits = (int) ((tiffT4Options & 0x04)>> 2);
    if (readEOL (true) != 1) {
        throw new RuntimeException ("First scanline must be 1D encoded.");
    }
    int lineOffset = 0;
    int bitOffset;
    decodeNextScanline (buffer, lineOffset, startX);
    lineOffset += scanlineStride;
    for (int lines = 1; lines < height; lines ++) {
        if (readEOL (false) == 0) {
            temp = prevChangingElems;
            prevChangingElems = currChangingElems;
            currChangingElems = temp;
            currIndex = 0;
            a0 = - 1;
            isWhite = true;
            bitOffset = startX;
            lastChangingElement = 0;
            while (bitOffset < w) {
                getNextChangingElement (a0, isWhite, b);
                b1 = b [0];
                b2 = b [1];
                entry = nextLesserThan8Bits (7);
                entry = (int) (twoDCodes [entry] & 0xff);
                code = (entry & 0x78)>>> 3;
                bits = entry & 0x07;
                if (code == 0) {
                    if (! isWhite) {
                        setToBlack (buffer, lineOffset, bitOffset, b2 - bitOffset);
                    }
                    bitOffset = a0 = b2;
                    updatePointer (7 - bits);
                }
                else if (code == 1) {
                    updatePointer (7 - bits);
                    int number;
                    if (isWhite) {
                        number = decodeWhiteCodeWord ();
                        bitOffset += number;
                        currChangingElems [currIndex ++] = bitOffset;
                        number = decodeBlackCodeWord ();
                        setToBlack (buffer, lineOffset, bitOffset, number);
                        bitOffset += number;
                        currChangingElems [currIndex ++] = bitOffset;
                    }
                    else {
                        number = decodeBlackCodeWord ();
                        setToBlack (buffer, lineOffset, bitOffset, number);
                        bitOffset += number;
                        currChangingElems [currIndex ++] = bitOffset;
                        number = decodeWhiteCodeWord ();
                        bitOffset += number;
                        currChangingElems [currIndex ++] = bitOffset;
                    }
                    a0 = bitOffset;
                }
                else if (code <= 8) {
                    a1 = b1 + (code - 5);
                    currChangingElems [currIndex ++] = a1;
                    if (! isWhite) {
                        setToBlack (buffer, lineOffset, bitOffset, a1 - bitOffset);
                    }
                    bitOffset = a0 = a1;
                    isWhite = ! isWhite;
                    updatePointer (7 - bits);
                }
                else {
                    throw new RuntimeException ("Invalid code encountered while decoding 2D group 3 compressed data.");
                }
            }
            currChangingElems [currIndex ++] = bitOffset;
            changingElemSize = currIndex;
        }
        else {
            decodeNextScanline (buffer, lineOffset, startX);
        }
        lineOffset += scanlineStride;
    }
}


public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
        Platform.printbp ();
    }
}


-----Function Pair=22=-----==

private void btnIntegrationComputeActionPerformed (java.awt.event.ActionEvent evt) {
    Frazione a = calcolaEspressione (txtIntegrationFrom.getText ());
    txtIntegrationFrom.setText ("" + a);
    Frazione b = calcolaEspressione (txtIntegrationTo.getText ());
    txtIntegrationTo.setText ("" + b);
    Frazione result = new Frazione (0);
    long nanoTime = 0l;
    double eps = Math.pow (10.0, - 12.0);
    switch (comboAlgorithm.getSelectedIndex ()) {
        case 0 :
            metodoSimpson : {
                appendToBuffer ("Integrating (Metodo Cavalieri-Simpson) <a href=\"#copyFormula:" + f () + "\">" + f () + "</a>");
                nanoTime = System.nanoTime ();
                Frazione h = b.subtract (a).divideBy (2);
                Frazione s1 = f (a).add (f (b));
                Frazione s2 = new Frazione (0.0);
                Frazione s4 = f (a.add (h));
                int n = 2;
                Frazione sNuovo = h.multiplyBy (s1.multiplyBy (s4.multiplyBy (4))).divideBy (3);
                Frazione sVecchio = sNuovo;
                do {
                    sVecchio = sNuovo;
                    n = 2 * n;
                    h = h.divideBy (2);
                    s2 = s2.add (s4);
                    s4 = new Frazione (0);
                    int j = 1;
                    do {
                        s4 = s4.add (f (a.add (h.multiplyBy (j))));
                        j = j + 2;
                    }
                    while (j <= n);
                    sNuovo = h.multiplyBy (s1.add (s2.multiplyBy (2).add (s4.multiplyBy (4)))).divideBy (3);
                }
                while (FMath.abs (sNuovo.subtract (sVecchio)).doubleValue () > eps);
                nanoTime = System.nanoTime () - nanoTime;
                result = sNuovo;
            }
            break;
        case 1 :
            appendToBuffer ("Integrating (Regola punto medio) <a href=\"#copyFormula:" + f () + "\">" + f () + "</a>");
            break;
        case 2 :
            appendToBuffer ("Integrating (Metodo romberg) <a href=\"#copyFormula:" + f () + "\">" + f () + "</a>");
            nanoTime = System.nanoTime ();
            metodoRomberg : {
                int precisione = Integer.parseInt (txtIntegrationN.getText ());
                Frazione [] t = new Frazione [precisione];
                Frazione h = b.subtract (a);
                Frazione s = f (a).add (f (b)).divideBy (2);
                t [0] = s.multiplyBy (h);
                int n = 1;
                int i = 1;
                Frazione vecchioValore = new Frazione (0);
                Frazione vhj = new Frazione (0.0);
                do {
                    n = n * 2;
                    h = h.divideBy (2);
                    int j = 1;
                    do {
                        s = s.add (f (a.add (h.multiplyBy (j))));
                        j = j + 2;
                    }
                    while (j <= n);
                    t [i] = s.multiplyBy (h);
                    vhj = new Frazione (1);
                    for (int k = i - 1; k >= 0; k --) {
                        vhj = vhj.multiplyBy (4);
                        vecchioValore = t [k];
                        t [k] = t [k + 1].add (t [k + 1].subtract (vecchioValore).divideBy (vhj.subtract (1)));
                    }
                    i = i + 1;
                }
                while (FMath.abs (vecchioValore.subtract (t [0])).doubleValue () > eps && i <= precisione - 1);
                nanoTime = System.nanoTime () - nanoTime;
                if (i > 15) {
                    JOptionPane.showMessageDialog (this, "Non è stata ottenuta la precisione voluta");
                }
                result = t [0];
            }
            break;
        case 3 :
            {
                metodoTrapezi : {
                    appendToBuffer ("Integrating (Metodo trapezi) <a href=\"#copyFormula:" + f () + "\">" + f () + "</a>");
                    nanoTime = System.nanoTime ();
                    int n = 1;
                    Frazione h = b.subtract (a);
                    Frazione T = h.multiplyBy (f (a).add (f (b))).divideBy (2);
                    Frazione M = new Frazione (0);
                    do {
                        M = new Frazione (0);
                        for (int i = 0; i < n - 1; i ++) {
                            M = M.add (f (a.add (h.multiplyBy (i + 0.5d))));
                        }
                        M = M.multiplyBy (h);
                        T = T.add (M).divideBy (2);
                        h = h.divideBy (2);
                        n = 2 * n;
                    }
                    while (FMath.abs (T.subtract (M)).doubleValue () > eps);
                    nanoTime = System.nanoTime () - nanoTime;
                    result = T;
                }
            }
            break;
        case 4 :
            {
                appendToBuffer ("Integrating (Metodo trapezi-b) <a href=\"#copyFormula:" + f () + "\">" + f () + "</a>");
                nanoTime = System.nanoTime ();
                int n = 1;
                Frazione h = b.subtract (a).divideBy (n);
                Frazione somma = f (a);
                for (int i = 1; i < n - 1; i ++) {
                    somma = somma.add (f (a.add (h.multiplyBy (i))).multiplyBy (2));
                }
                somma = somma.add (f (b));
                somma = somma.multiplyBy (h.divideBy (2));
                nanoTime = System.nanoTime () - nanoTime;
                result = somma;
            }
            break;
    }
    appendToBuffer ("from a=" + a + " to b=" + b);
    int i = 0;
    final String [] unit = {"nanoseconds", "microseconds", "milliseconds", "seconds"};
    double dNanoTime = (double) nanoTime;
    while (dNanoTime > 1000 && i < 3) {
        dNanoTime /= 1000;
        i ++;
    }
    appendToBuffer ("=> <a href=\"#copyValue:" + result + "\">" + result + "</a> in ~" + round (dNanoTime, 2) + " " + unit [i]);
    txtFx.setText ("" + result);
}


private void jar (String options, File jarFile, File [] files) throws IOException {
    Process p = null;
    Vector argsv = new Vector ();
    argsv.add (getJavaBinPath () + File.separator + "jar");
    if (options != null && ! options.equals ("")) argsv.add (options);
    argsv.add (jarFile.getName ());
    for (int i = 0; i < files.length; i ++) argsv.add (files [i].getName ());
    String [] args = new String [argsv.size ()];
    for (int i = 0; i < args.length; i ++) args [i] = (String) argsv.get (i);
    try {
        p = Runtime.getRuntime ().exec (args);
        p.waitFor ();
    } catch (Exception rte) {
        throw new IOException ("Runtime exception: check if you have installed the JDK and run java from the JDK\n" + "Exception message: " + rte.getMessage ());
    }
    printCmdOutput (p, "jar");
    if (p.exitValue () != 0) throw new RuntimeException ("  abnormal exit");
}


-----Function Pair=23=-----==

private void printStatistics (final OctTree octTree) {
    System.out.println ("Number of nodes: " + nodes.size ());
    double attrSum = 0.0;
    for (Node node : nodes) {
        for (Edge edge : attrEdges.get (node)) {
            attrSum += edge.weight;
        }
    }
    System.out.println ("Overall attraction: " + attrSum);
    double meanAttrEnergy = 0.0;
    for (Node node : nodes) meanAttrEnergy += getAttractionEnergy (node);
    meanAttrEnergy = (attrExponent == 0.0) ? Math.exp (meanAttrEnergy / attrSum) : Math.pow (meanAttrEnergy * attrExponent / attrSum, 1.0 / attrExponent);
    System.out.println ("Weighted mean of attraction energy: " + meanAttrEnergy);
    double repuSum = 0.0, repuSquareSum = 0.0;
    for (Node node : nodes) {
        repuSum += node.weight;
        repuSquareSum += node.weight * node.weight;
    }
    repuSum = repuSum * repuSum - repuSquareSum;
    System.out.println ("Overall repulsion: " + repuSum);
    double meanRepuEnergy = 0.0;
    for (Node node : nodes) meanRepuEnergy += getRepulsionEnergy (node, octTree);
    meanRepuEnergy /= repuFactor;
    meanRepuEnergy = (repuExponent == 0.0) ? Math.exp (- meanRepuEnergy / repuSum) : Math.pow (- meanRepuEnergy * repuExponent / repuSum, 1.0 / repuExponent);
    System.out.println ("Weighted mean of repulsion energy: " + meanRepuEnergy);
    System.out.println ("Mean attraction / mean repulsion: " + meanAttrEnergy / meanRepuEnergy);
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=24=-----==

public static boolean isSorted (int [] array, int offset, int len, boolean largest_first) {
    if (len < 2) return true;
    int last = array [offset ++];
    if (largest_first) {
        for (int i = 1; i < len; i ++) {
            int tmp = array [offset ++];
            if (tmp > last) return false;
            else last = tmp;
        }
    }
    else {
        for (int i = 1; i < len; i ++) {
            int tmp = array [offset ++];
            if (tmp < last) return false;
            else last = tmp;
        }
    }
    return true;
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=25=-----==

public String getColumnName (int columnIndex) {
    switch (columnIndex) {
        case DOC_NAME_COLUMN :
            return "Document";
        case ANNOTATION_SET_NAME_COLUMN :
            return "AnnotationSet";
        case LEFT_CONTEXT_COLUMN :
            return "Left Context";
        case PATTERN_COLUMN :
            return "Pattern";
        case RIGHT_CONTEXT_COLUMN :
            return "Right Context";
        default :
            return "?";
    }
}


private boolean [] getPatternUsage () {
    Track track;
    int size;
    int value;
    boolean skip;
    boolean patNotFree [] = new boolean [Pattern.MAX_PATTERNS];
    for (int i = 0; i < numberOfTunes; i ++) {
        for (int j = 0; j < 3; j ++) {
            track = tracks [i] [j];
            size = track.getSize ();
            skip = false;
            for (int k = 0; k < size - 2; k ++) {
                if (skip) {
                    skip = false;
                    continue;
                }
                value = track.getValueAt (k);
                if (value == Track.PATTERN_REP) {
                    skip = true;
                    continue;
                }
                if (value > Track.PATTERN_REP) continue;
                patNotFree [value] = true;
            }
        }
    }
    return patNotFree;
}


-----Function Pair=26=-----==

private float [] coefUnexpansion (float [] filt, int origSize) throws ErrorException {
    float [] recovered = new float [origSize];
    if (filt == null) {
        throw new ErrorException ("The filtered array is null!");
    }
    if (filt.length != 6) {
        throw new ErrorException ("The filtered array does not have size of 6");
    }
    switch (origSize) {
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
            for (int i = 0; i < origSize; i ++) {
                recovered [i] = filt [i];
            }
            break;
        default :
            throw new ErrorException ("The array original length is out of the range 1 - 5");
    }
    return (recovered);
}


public Object execute (final Object target, final ExecutionTargetOperation [] [] operations, final int [] indexes) {
    if (target == null) {
        throw new IllegalArgumentException ("Cannot iterate on null: the \"map if not null\"" + "operation allows any element of the iterated structure to be null, but " + "not the structure being iterated itself.");
    }
    try {
        switch (this.structure) {
            case ARRAY :
                final Object [] arrayTarget = (Object []) target;
                final Object [] arrayResult = (Object []) Array.newInstance (this.arrayComponentClass, arrayTarget.length);
                for (int i = 0, z = arrayTarget.length; i < z; i ++) {
                    arrayResult [i] = (arrayTarget [i] == null ? null : this.executable.execute (arrayTarget [i], new ExecCtxImpl (addIndex (indexes, i, false))));
                }
                return arrayResult;
            case LIST :
                final List < ? > listTarget = (List < ? >) target;
                final List < Object > listResult = new ArrayList < Object > ();
                int iList = 0;
                for (final Object element : listTarget) {
                    listResult.add ((element == null ? null : this.executable.execute (element, new ExecCtxImpl (addIndex (indexes, iList, false)))));
                    iList ++;
                }
                return listResult;
            case SET :
                final Set < ? > setTarget = (Set < ? >) target;
                final Set < Object > setResult = new LinkedHashSet < Object > ();
                int iSet = 0;
                for (final Object element : setTarget) {
                    setResult.add ((element == null ? null : this.executable.execute (element, new ExecCtxImpl (addIndex (indexes, iSet, false)))));
                    iSet ++;
                }
                return setResult;
            default :
                throw new IllegalStateException ("Unsupported structure: " + this.structure);
        }
    } catch (ExecutionException e) {
        throw e;
    } catch (Throwable t) {
        throw new ExecutionException (t);
    }
}


-----Function Pair=27=-----==

public static double [] normalRandomVariable (double [] mean, double [] [] cov) {
    int size = mean.length;
    double result [] = new double [size];
    double cholesky [] [] = new CholeskyDecomposition (new Matrix (cov)).getL ().getArray ();
    double z [] = new double [size];
    for (int i = 0; i < size; i ++) {
        double a = generator.nextGaussian ();
        z [i] = a;
    }
    for (int i = 0; i < size; i ++) {
        result [i] = mean [i];
        for (int j = 0; j <= i; j ++) result [i] += cholesky [i] [j] * z [j];
    }
    return result;
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=28=-----==

static void backward_filter (short [] p, int pidx, int b, int e, int z, int s) {
    final int s3 = 3 * s;
    if ((z < b) || (z > e)) {
        logError ("(_IWCoeff::backward_filter) Out of bounds [b<=z<=e]");
    }
    int n = z;
    int bb;
    int cc;
    int aa = bb = cc = 0;
    int dd = ((n + s) >= e) ? 0 : ((int) (p [pidx + n + s]));
    for (; (n + s3) < e; n = (n + s3) - s) {
        aa = bb;
        bb = cc;
        cc = dd;
        dd = p [pidx + n + s3];
        p [pidx + n] -= (((9 * (bb + cc)) - (aa + dd)) + 16)>> 5;
    }
    for (; n < e; n = n + s + s) {
        aa = bb;
        bb = cc;
        cc = dd;
        dd = 0;
        p [pidx + n] -= (((9 * (bb + cc)) - (aa + dd)) + 16)>> 5;
    }
    n = z + s;
    aa = 0;
    bb = p [(pidx + n) - s];
    cc = ((n + s) >= e) ? 0 : ((int) (p [pidx + n + s]));
    dd = ((n + s3) >= e) ? 0 : ((int) (p [pidx + n + s3]));
    if (n < e) {
        int x = bb;
        if ((n + s) < e) {
            x = (bb + cc + 1)>> 1;
        }
        p [pidx + n] += x;
        n = n + s + s;
    }
    for (; (n + s3) < e; n = (n + s3) - s) {
        aa = bb;
        bb = cc;
        cc = dd;
        dd = p [pidx + n + s3];
        int x = (((9 * (bb + cc)) - (aa + dd)) + 8)>> 4;
        p [pidx + n] += x;
    }
    if ((n + s) < e) {
        aa = bb;
        bb = cc;
        cc = dd;
        dd = 0;
        int x = (bb + cc + 1)>> 1;
        p [pidx + n] += x;
        n = n + s + s;
    }
    if (n < e) {
        aa = bb;
        bb = cc;
        cc = dd;
        dd = 0;
        int x = bb;
        p [pidx + n] += x;
    }
}


public InternalNodeArrayMap split () {
    InternalNodeArrayMap newMap = new InternalNodeArrayMap (keys.length);
    final int mid = currentSize / 2;
    int count = 0;
    newMap.nodes [0] = nodes [mid + 1];
    for (int i = mid + 1; i < currentSize; i ++) {
        newMap.keys [count] = keys [i];
        newMap.nodes [++ count] = nodes [i + 1];
    }
    for (int i = mid; i < currentSize; i ++) {
        nodes [i + 1] = null;
    }
    newMap.currentSize = currentSize - mid - 1;
    currentSize = mid;
    return newMap;
}


-----Function Pair=29=-----==

public String [] getOptions () {
    String [] options = new String [13];
    int current = 0;
    if (getKFused ()) {
        options [current ++] = "-K";
    }
    if (getDebug ()) {
        options [current ++] = "-D";
    }
    options [current ++] = "-I";
    options [current ++] = "" + (getDocumentAtt () + 1);
    options [current ++] = "-J";
    options [current ++] = "" + (getKeyphrasesAtt () + 1);
    options [current ++] = "-M";
    options [current ++] = "" + (getMaxPhraseLength ());
    options [current ++] = "-L";
    options [current ++] = "" + (getMinPhraseLength ());
    options [current ++] = "-O";
    options [current ++] = "" + (getMinNumOccur ());
    if (getDisallowInternalPeriods ()) {
        options [current ++] = "-P";
    }
    while (current < options.length) {
        options [current ++] = "";
    }
    return options;
}


public String elementsSearch () {
    int index = 0;
    for (int i1 = 0; i1 < 6; i1 ++) {
        for (int i2 = 0; i2 < 5; i2 ++) {
            if (index < 5) {
                if (initialMatrix [i1] [i2] > 0) {
                    finalMatrix [index] = initialMatrix [i1] [i2];
                    index ++;
                }
            }
            else break;
        }
    }
    int temp;
    for (int i = 0; i < finalMatrix.length; i ++) {
        for (int j = 0; j < finalMatrix.length - 1; j ++) {
            if (finalMatrix [j] < finalMatrix [j + 1]) {
                temp = finalMatrix [j];
                finalMatrix [j] = finalMatrix [j + 1];
                finalMatrix [j + 1] = temp;
            }
        }
    }
    String result = "";
    for (int k : finalMatrix) result += k + " ";
    return result;
}


-----Function Pair=30=-----==

private void setToBlack (byte [] buffer, int lineOffset, int bitOffset, int numBits) {
    int bitNum = (8 * lineOffset) + bitOffset;
    int lastBit = bitNum + numBits;
    int byteNum = bitNum>> 3;
    int shift = bitNum & 0x7;
    if (shift > 0) {
        int maskVal = 1 << (7 - shift);
        byte val = buffer [byteNum];
        while ((maskVal > 0) && (bitNum < lastBit)) {
            val |= maskVal;
            maskVal>>= 1;
            ++ bitNum;
        }
        buffer [byteNum] = val;
    }
    byteNum = bitNum>> 3;
    while (bitNum < (lastBit - 7)) {
        buffer [byteNum ++] = (byte) 255;
        bitNum += 8;
    }
    while (bitNum < lastBit) {
        byteNum = bitNum>> 3;
        buffer [byteNum] |= (1 << (7 - (bitNum & 0x7)));
        ++ bitNum;
    }
}


public void writeExternal (ObjectOutput out) throws IOException {
    out.writeInt (rows);
    out.writeInt (columns);
    out.writeInt (nonzero);
    out.writeByte (META_MARKER);
    int k = 0, i = 0;
    while (k < nonzero) {
        for (int j = rowPointers [i]; j < rowPointers [i + 1]; j ++, k ++) {
            out.writeInt (i);
            out.writeInt (columnIndices [j]);
            out.writeDouble (values [j]);
            out.writeByte (ELEMENT_MARKER);
        }
        i ++;
    }
}


-----Function Pair=31=-----==

public static void sort (Object [] arr, int start, int end) {
    if (end - start <= 2) {
        if (end - start == 2 && arr [start].toString ().compareTo (arr [start + 1].toString ()) > 0) {
            Object tmp = arr [start];
            arr [start] = arr [start + 1];
            arr [start + 1] = tmp;
        }
        return;
    }
    if (end - start == 3) {
        sort (arr, start, start + 2);
        sort (arr, start + 1, start + 3);
        sort (arr, start, start + 2);
        return;
    }
    int middle = (start + end) / 2;
    sort (arr, start, middle);
    sort (arr, middle, end);
    Object [] tmp = new Object [end - start];
    int i0 = start;
    int i1 = middle;
    for (int i = 0; i < tmp.length; i ++) {
        if (i0 == middle) {
            tmp [i] = arr [i1 ++];
        }
        else if (i1 == end || arr [i0].toString ().compareTo (arr [i1].toString ()) < 0) {
            tmp [i] = arr [i0 ++];
        }
        else {
            tmp [i] = arr [i1 ++];
        }
    }
    System.arraycopy (tmp, 0, arr, start, tmp.length);
}


private static double [] createSdOfDerivation (double [] diffOut) {
    double [] sds = new double [diffOut.length];
    for (int i = 0; i < diffOut.length; i ++) {
        double [] tmp = new double [SD_CALC_SIZE_NR];
        for (int j = 0; (j < tmp.length); j ++) {
            if (i + j < diffOut.length) {
                tmp [j] = diffOut [i + j];
            }
            else {
                tmp [j] = 0;
            }
        }
        sds [i] = sd (tmp);
    }
    return sds;
}


-----Function Pair=32=-----==

public static void main (String [] argv) {
    CmdlineUtils.initializeLogging ();
    CmdlineOptions options = new CmdlineOptions ("StatisticsPrinter", argv);
    CmdlineUtils.registerLoggingOptions (options);
    try {
        options.parse ();
    } catch (CmdlineOptions.OptionsException e) {
        System.err.println ("Error: " + e.getMessage ());
        System.exit (1);
    }
    String [] args = options.getArguments ();
    if (args.length < 1) {
        System.err.println ("Error: Illegal number of arguments.");
        usage ();
        System.exit (1);
    }
    try {
        TopicMapIF tm = ImportExportUtils.getReader (args [0]).read ();
        if (tm == null) throw new OntopiaRuntimeException ("No topic maps found.");
        StatisticsPrinter statsprinter = new StatisticsPrinter (tm);
        statsprinter.topicStats ();
    } catch (Exception e) {
        System.err.println ("ERROR: " + e.getMessage ());
        System.exit (1);
    }
}


public final Value apply (Value v1) throws ContinuationException {
    switch (id) {
        case NULLQ :
            return truth (v1 == EMPTYLIST);
        case CAR :
            return truePair (v1).car ();
        case CDR :
            return truePair (v1).cdr ();
        case PAIRQ :
            return truth (v1 instanceof Pair && v1 != EMPTYLIST);
        case IMMUTABLEPAIRQ :
            return truth ((v1 instanceof ImmutablePair) && ((ImmutablePair) v1).isImmutable ());
        case IMMUTABLEVECTORQ :
            return truth (v1 instanceof ImmutableVector);
        case ADD :
        case MUL :
            return num (v1);
        case SUB :
            return num (v1).negate ();
        case DIV :
            return Quantity.ONE.div (num (v1));
        case SIN :
            return num (v1).sin ();
        case COS :
            return num (v1).cos ();
        case TAN :
            return num (v1).tan ();
        case ASIN :
            return num (v1).asin ();
        case ACOS :
            return num (v1).acos ();
        case ATAN :
            return num (v1).atan ();
        case LOG :
            return num (v1).log ();
        case EXP :
            return num (v1).exp ();
        case SQRT :
            return num (v1).sqrt ();
        case NUMBERQ :
            return truth (v1 instanceof Quantity);
        case VECTORQ :
            return truth (v1 instanceof SchemeVector);
        case SYMBOLQ :
            return truth (v1 instanceof Symbol);
        case SYNTOKENQ :
            return truth (v1 instanceof sisc.compiler.Syntax);
        case CHARACTERQ :
            return truth (v1 instanceof SchemeCharacter);
        case STRINGQ :
            return truth (v1 instanceof SchemeString);
        case BOOLEANQ :
            return truth (v1 instanceof SchemeBoolean);
        case VOIDQ :
            return truth (v1 == VOID);
        case ENVIRONMENTQ :
            return truth (v1 instanceof SymbolicEnvironment);
        case PROCEDUREQ :
            return truth (v1 instanceof Procedure);
        case INTEGERQ :
            return numQuery (v1, Quantity.INTEGER);
        case COMPLEXQ :
            return numQuery (v1, Quantity.IMAGINARY);
        case EXACTQ :
            return numQuery (v1, Quantity.EXACT);
        case INEXACTQ :
            return numQuery (v1, Quantity.INEXACT);
        case PARAMETERQ :
            return truth (v1 instanceof Parameter);
        case GENSYMQ :
            return truth (symbol (v1).symval.startsWith (GENSYM_MAGIC_PREFIX));
        case SYMBOL2STRING :
            return new ImmutableString (symbol (v1).symval);
        case SYNTOKEN2STRING :
            return new ImmutableString (((sisc.compiler.Syntax) v1).toString ());
        case STRING2SYMBOL :
            return Symbol.intern (string (v1));
        case CHAR2INTEGER :
            return Quantity.valueOf (character (v1));
        case LIST2VECTOR :
            return new SchemeVector (Util.pairToValues (pair (v1)));
        case VECTOR2LIST :
            Value [] vals = vec (v1).vals;
            return valArrayToList (vals, 0, vals.length);
        case EXACT2INEXACT :
            return num (v1).toInexact ();
        case INEXACT2EXACT :
            return num (v1).toExact ();
        case FLOOR :
            return num (v1).floor ();
        case CEILING :
            return num (v1).ceiling ();
        case ROUND :
            return num (v1).round ();
        case TRUNCATE :
            return num (v1).truncate ();
        case INTEGER2CHAR :
            return new SchemeCharacter ((char) num (v1).indexValue ());
        case VECTORFINDLASTUNIQUE :
            return Quantity.valueOf (vec (v1).findEnd ());
        case BOX :
            return new Box (v1);
        case UNBOX :
            return box (v1).val;
        case BOXQ :
            return truth (v1 instanceof Box);
        case LENGTH :
            return Quantity.valueOf (length (pair (v1)));
        case STRINGLENGTH :
            return Quantity.valueOf (str (v1).length ());
        case VECTORLENGTH :
            return Quantity.valueOf (vec (v1).vals.length);
        case CIRCULARQ :
            return truth (new CircularityDetector ().isCircular (v1));
        case MAKEPARAM :
            return new SchemeParameter (v1);
        case MAKENATIVEPARAM :
            return new NativeParameter (string (v1));
        case MAKESTRING :
            return new SchemeString (new char [num (v1).indexValue ()]);
        case MAKEVECTOR :
            return new SchemeVector (num (v1).indexValue ());
        case MAKEIMMUTABLEVECTOR :
            return new ImmutableVector (num (v1).indexValue (), false);
        case NUMERATOR :
            return num (v1).numerator ();
        case DENOMINATOR :
            return num (v1).denominator ();
        case REALPART :
            return num (v1).realpart ();
        case IMAGPART :
            return num (v1).imagpart ();
        case STRING2UNINTERNEDSYMBOL :
            return Symbol.getUnique (string (v1));
        case MAKECHILDENVIRONMENT :
            SymbolicEnvironment env = env (v1);
            MemorySymEnv ae = new MemorySymEnv (env);
            sisc.compiler.Compiler.addSpecialForms (ae);
            return ae;
        case NULLENVIRONMENT :
            switch (num (v1).indexValue ()) {
                case 5 :
                    ae = new MemorySymEnv ();
                    sisc.compiler.Compiler.addSpecialForms (ae);
                    return ae;
                case 0 :
                    return new MemorySymEnv ();
                default :
                    throwPrimException (liMessage (SISCB, "unsupportedstandardver"));
                    return VOID;
            }
        case NLNAME :
            return Symbol.get (nlib (v1).getLibraryName ());
        case NLVERSION :
            return Quantity.valueOf (nlib (v1).getLibraryVersion ());
        case SLEEP :
            try {
                Thread.sleep (num (v1).longValue ());
            } catch (InterruptedException ie) {
            }
            return VOID;
        case STRINGAPPEND :
            return str (v1).copy ();
        case LIST :
            return new Pair (v1, EMPTYLIST);
        case HASHCODE :
            return Quantity.valueOf (v1.hashCode ());
        default :
            throwArgSizeException ();
            return VOID;
    }
}


-----Function Pair=33=-----==

private RdpPacket_Localised receive (int [] type) throws IOException, RdesktopException, CryptoException, OrderException {
    int length = 0;
    if ((this.stream == null) || (this.next_packet >= this.stream.getEnd ())) {
        this.stream = SecureLayer.receive ();
        if (stream == null) return null;
        this.next_packet = this.stream.getPosition ();
    }
    else {
        this.stream.setPosition (this.next_packet);
    }
    length = this.stream.getLittleEndian16 ();
    if (length == 0x8000) {
        logger.warn ("32k packet keepalive fix");
        next_packet += 8;
        type [0] = 0;
        return stream;
    }
    type [0] = this.stream.getLittleEndian16 () & 0xf;
    if (stream.getPosition () != stream.getEnd ()) {
        stream.incrementPosition (2);
    }
    this.next_packet += length;
    return stream;
}


public static Object financialPrice (Object [] args, XelContext ctx) {
    Date settle = UtilFns.stringToDate (args [0].toString ());
    Date maturi = UtilFns.stringToDate (args [1].toString ());
    if (settle.after (maturi)) {
        throw new SSErrorXelException (SSError.NUM);
    }
    double rate = CommonFns.toNumber (args [2]).doubleValue ();
    double yld = CommonFns.toNumber (args [3]).doubleValue ();
    double redemption = CommonFns.toNumber (args [4]).doubleValue ();
    if (! (yld > 0 || rate > 0 || redemption > 0)) {
        throw new SSErrorXelException (SSError.NUM);
    }
    int freq = 1;
    try {
        freq = CommonFns.toNumber (args [5]).intValue ();
    } catch (ClassCastException e) {
        throw new SSErrorXelException (SSError.NUM);
    }
    if (freq != 1 && freq != 2 && freq != 4) {
        throw new SSErrorXelException (SSError.NUM);
    }
    int basis = 0;
    if (args.length == 7) {
        try {
            basis = basis (CommonFns.toNumber (args [6]).intValue ());
        } catch (ClassCastException e) {
            basis = 0;
        }
    }
    return new Double (price (settle, maturi, rate, yld, redemption, freq, basis));
}


-----Function Pair=34=-----==

public String getAdjustedString (String text) {
    String [] tokens = text.toLowerCase ().split ("\\s+");
    for (int i = 0; i < tokens.length - 1; i ++) {
        if (tokens [i + 1].equals ("$")) {
            try {
                Double.parseDouble (tokens [i]);
                String num = tokens [i];
                tokens [i] = tokens [i + 1];
                tokens [i + 1] = num;
                i ++;
            } catch (NumberFormatException e) {
            }
        }
    }
    List < String > splitTokens = new ArrayList < String > (tokens.length * 2);
    for (String token : tokens) {
        String [] tokenSplits = token.replace ("-", " - ").split ("[_ ]");
        for (String s : tokenSplits) splitTokens.add (s);
    }
    StringBuffer retval = new StringBuffer ();
    for (int i = 0; i < splitTokens.size () - 1; i ++) {
        retval.append (splitTokens.get (i));
        retval.append (' ');
    }
    retval.append (splitTokens.get (splitTokens.size () - 1));
    return retval.toString ();
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=35=-----==

protected void receiveConfInvite (YMSG9Packet pkt) {
    try {
        YahooConference yc = getOrCreateConference (pkt);
        String [] users = pkt.getValues ("52");
        SessionConferenceEvent se = new SessionConferenceEvent (this, pkt.getValue ("1"), pkt.getValue ("50"), pkt.getValue ("58"), yc, userStore.toUserArray (users));
        yc.addUsers (users);
        yc.addUser (se.getFrom ());
        if (! yc.isClosed ()) new FireEvent ().fire (se, SERVICE_CONFINVITE);
        synchronized (yc) {
            Vector v = yc.inviteReceived ();
            for (int i = 0; i < v.size (); i ++) ipThread.process ((YMSG9Packet) v.elementAt (i));
        }
    } catch (Exception e) {
        throw new YMSG9BadFormatException ("conference invite", false, e);
    }
}


private static Element setupAsStyled (String str, String className, String cssText, int wrappedWidth) {
    init ();
    cssText = wrapCSS (cssText);
    Object e = containers;
    Element f = null;
    String g = null;
    if (wrappedWidth > 0) {
        g = "+" + className + "|" + cssText;
    }
    else {
        g = "~" + className + "|" + cssText;
    }
    {
        e = g;
    }
    if (f != null) {
        clearChildren (f);
    }
    else {
        f = document.createElement ("DIV");
        invisibleContainer.appendChild (f);
        CSSStyle x = f.style;
        f.className = className;
        x.cssText = cssText;
        if (wrappedWidth > 0) {
            x.whiteSpace = "normal";
        }
        else {
            x.whiteSpace = "nowrap";
        }
        x.overflow = "visible";
        {
            g = e.toString ();
        }
    }
    if (wrappedWidth > 0) {
        f.style.width = wrappedWidth + "px";
    }
    Element [] childNodes = invisibleContainer.childNodes;
    for (int i = 0; i < childNodes.length; i ++) {
        CSSStyle s = childNodes [i].style;
        if (childNodes [i] != f) {
            if (s.display != "none") {
                oldDisplays [i] = s.display;
                s.display = "none";
            }
        }
        else {
            if (oldDisplays [i] != null) {
                s.display = oldDisplays [i];
            }
        }
    }
    insertText (f, str);
    return f;
}


-----Function Pair=36=-----==

protected void receiveConfInvite (YMSG9Packet pkt) {
    try {
        YahooConference yc = getOrCreateConference (pkt);
        String [] users = pkt.getValues ("52");
        SessionConferenceEvent se = new SessionConferenceEvent (this, pkt.getValue ("1"), pkt.getValue ("50"), pkt.getValue ("58"), yc, userStore.toUserArray (users));
        yc.addUsers (users);
        yc.addUser (se.getFrom ());
        if (! yc.isClosed ()) new FireEvent ().fire (se, SERVICE_CONFINVITE);
        synchronized (yc) {
            Vector v = yc.inviteReceived ();
            for (int i = 0; i < v.size (); i ++) ipThread.process ((YMSG9Packet) v.elementAt (i));
        }
    } catch (Exception e) {
        throw new YMSG9BadFormatException ("conference invite", false, e);
    }
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=37=-----==

private static void sanityCheck () {
    int errors = 0;
    String osName = (String) java.security.AccessController.doPrivileged (new java.security.PrivilegedAction () {
        public Object run () {
            return System.getProperty ("os.name");
        }
    }
    );
    for (int ii = 1; ii < table_filenames.length; ii ++) {
        if (table_filenames [ii] == - 1) {
            System.out.println ("\n Warning: " + "<filename." + getString (table_componentFontNameIDs [ii]) + "> entry is missing!!!");
            if (! osName.contains ("Linux")) {
                errors ++;
            }
        }
    }
    for (int ii = 0; ii < table_scriptIDs.length; ii ++) {
        short fid = table_scriptFonts [ii];
        if (fid == 0) {
            System.out.println ("\n Error: <allfonts." + getString (table_scriptIDs [ii]) + "> entry is missing!!!");
            errors ++;
            continue;
        }
        else if (fid < 0) {
            fid = (short) - fid;
            for (int iii = 0; iii < NUM_FONTS; iii ++) {
                for (int iij = 0; iij < NUM_STYLES; iij ++) {
                    int jj = iii * NUM_STYLES + iij;
                    short ffid = table_scriptFonts [fid + jj];
                    if (ffid == 0) {
                        System.out.println ("\n Error: <" + getFontName (iii) + "." + getStyleName (iij) + "." + getString (table_scriptIDs [ii]) + "> entry is missing!!!");
                        errors ++;
                    }
                }
            }
        }
    }
    if ("SunOS".equals (osName)) {
        for (int ii = 0; ii < table_awtfontpaths.length; ii ++) {
            if (table_awtfontpaths [ii] == 0) {
                String script = getString (table_scriptIDs [ii]);
                if (script.contains ("lucida") || script.contains ("dingbats") || script.contains ("symbol")) {
                    continue;
                }
                System.out.println ("\nError: " + "<awtfontpath." + script + "> entry is missing!!!");
                errors ++;
            }
        }
    }
    if (errors != 0) {
        System.out.println ("!!THERE ARE " + errors + " ERROR(S) IN " + "THE FONTCONFIG FILE, PLEASE CHECK ITS CONTENT!!\n");
        System.exit (1);
    }
}


public static void main (String [] args) {
    int [] a = new int [1000000];
    for (int i = 0; i < a.length; i ++) {
        a [i] = i;
    }
    long start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findBinary (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
    start = System.currentTimeMillis ();
    for (int i = 0; i < 100000; i ++) {
        findLinear (a, i);
    }
    System.out.println (System.currentTimeMillis () - start);
}


-----Function Pair=38=-----==

public static final void qmf_decomp (final float [] xx, final float [] aa, final float [] y1, final float [] y2, final int N, final int M, final float [] mem) {
    int i, j, k, M2;
    int x2;
    qmf_decomp_a = Bits.newOrZeroFloatArray (qmf_decomp_a, M);
    qmf_decomp_x = Bits.newOrZeroFloatArray (qmf_decomp_x, N + M - 1);
    x2 = M - 1;
    M2 = M>> 1;
    for (i = 0; i < M; i ++) qmf_decomp_a [M - i - 1] = aa [i];
    for (i = 0; i < M - 1; i ++) qmf_decomp_x [i] = mem [M - i - 2];
    for (i = 0; i < N; i ++) qmf_decomp_x [i + M - 1] = xx [i];
    for (i = 0, k = 0; i < N; i += 2, k ++) {
        y1 [k] = 0;
        y2 [k] = 0;
        for (j = 0; j < M2; j ++) {
            y1 [k] += qmf_decomp_a [j] * (qmf_decomp_x [i + j] + qmf_decomp_x [x2 + i - j]);
            y2 [k] -= qmf_decomp_a [j] * (qmf_decomp_x [i + j] - qmf_decomp_x [x2 + i - j]);
            j ++;
            y1 [k] += qmf_decomp_a [j] * (qmf_decomp_x [i + j] + qmf_decomp_x [x2 + i - j]);
            y2 [k] += qmf_decomp_a [j] * (qmf_decomp_x [i + j] - qmf_decomp_x [x2 + i - j]);
        }
    }
    for (i = 0; i < M - 1; i ++) mem [i] = xx [N - i - 1];
}


public static float [] [] FilterMA (float [] [] expressiondata, Vector [] geneids, Vector remaingenes, Vector removedgenes) {
    for (int lin = 0; lin < expressiondata.length; lin ++) {
        int contz = 0;
        for (int col = 0; col < expressiondata [0].length; col ++) {
            if (expressiondata [lin] [col] == 0) {
                contz ++;
            }
        }
        if (contz < 1) {
            remaingenes.add (lin);
        }
        else {
            removedgenes.add (geneids [0].get (lin));
            System.out.println ("Gene " + (String) geneids [0].get (lin) + " was removed by filter.");
        }
    }
    System.out.println (removedgenes.size () + " removed genes.");
    float [] [] filtereddata = new float [remaingenes.size ()] [expressiondata [0].length];
    for (int i = 0; i < remaingenes.size (); i ++) {
        int lin = (Integer) remaingenes.get (i);
        for (int col = 0; col < expressiondata [0].length; col ++) {
            filtereddata [i] [col] = expressiondata [lin] [col];
        }
    }
    return (filtereddata);
}


-----Function Pair=39=-----==

protected void receiveMessage (YMSG9Packet pkt) {
    try {
        if (! pkt.exists ("14")) {
            return;
        }
        else if (pkt.status == STATUS_NOTINOFFICE) {
            int i = 0;
            String s = pkt.getNthValue ("31", i);
            while (s != null) {
                SessionEvent se = new SessionEvent (this, pkt.getNthValue ("5", i), pkt.getNthValue ("4", i), pkt.getNthValue ("14", i), pkt.getNthValue ("15", i));
                new FireEvent ().fire (se, SERVICE_X_OFFLINE);
                i ++;
                s = pkt.getNthValue ("31", i);
            }
        }
        else {
            SessionEvent se = new SessionEvent (this, pkt.getValue ("5"), pkt.getValue ("4"), pkt.getValue ("14"));
            if (se.getMessage ().equalsIgnoreCase (BUZZ)) new FireEvent ().fire (se, SERVICE_X_BUZZ);
            else new FireEvent ().fire (se, SERVICE_MESSAGE);
        }
    } catch (Exception e) {
        throw new YMSG9BadFormatException ("message", false, e);
    }
}


public void read_longlong_array (long [] val, int off, int len) {
    if (0 == len) {
        return;
    }
    alignment (8);
    m_tmp_len.value = len * 8;
    int rd;
    while (m_tmp_len.value > 0) {
        rd = next (m_tmp_buf, m_tmp_off, m_tmp_len);
        for (int i = 0; i < rd - 7; i += 8, ++ off) {
            val [off] = (((long) (m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << (long) (m_swap ? 0 : 56)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 1] & 0xFF) << (long) (m_swap ? 8 : 48)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 2] & 0xFF) << (long) (m_swap ? 16 : 40)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 3] & 0xFF) << (long) (m_swap ? 24 : 32)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 4] & 0xFF) << (long) (m_swap ? 32 : 24)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 5] & 0xFF) << (long) (m_swap ? 40 : 16)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 6] & 0xFF) << (long) (m_swap ? 48 : 8)) | ((long) (m_tmp_buf.value [m_tmp_off.value + i + 7] & 0xFF) << (long) (m_swap ? 56 : 0)));
        }
        if (rd % 8 != 0) {
            val [off] = 0L;
            int rcvd = rd % 8;
            rd -= rd % 8;
            int s = 0;
            for (; s < rcvd; ++ s) {
                val [off] = val [off] | ((long) (m_tmp_buf.value [m_tmp_off.value + rd + s] & 0xFF) << (long) (m_swap ? (8 * s) : (56 - 8 * s)));
            }
            int tmp = m_tmp_len.value - (8 - s);
            while (s < 8) {
                m_tmp_len.value = 8 - s;
                rd = next (m_tmp_buf, m_tmp_off, m_tmp_len);
                for (int i = 0; i < rd; ++ i, ++ s) {
                    val [off] = val [off] | ((long) (m_tmp_buf.value [m_tmp_off.value + i] & 0xFF) << (long) (m_swap ? (8 * s) : (56 - 8 * s)));
                }
            }
            m_tmp_len.value = tmp;
        }
    }
    postread (len * 8);
}


-----Function Pair=40=-----==

public static String fromHexDottedString (String hexOctetString, boolean toAscii) {
    if (hexOctetString == null) {
        return null;
    }
    if (hexOctetString.length () == 0) {
        return "";
    }
    int [] arr = toArray (hexOctetString, 16);
    if (arr == null) {
        return null;
    }
    String str = "";
    for (int i = 0; i < arr.length; i ++) {
        if (toAscii) {
            str += (char) arr [i];
        }
        else {
            str += toHexString (arr [i]);
        }
    }
    return str;
}


public OrderTO doTradeByPaper (int index, String idPaper) throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    int volume = quote.getVolume ();
    if (currTime < PERIODO) {
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, 0, preco, true);
    }
    else {
        double m = media (dias [index]);
        int v;
        if (Trend.trend (dias [index]) > 0 && dias [index] [PERIODO - 1] < m) v = VOLUME;
        else if (Trend.trend (dias [index]) < 0 && m < dias [index] [PERIODO - 1]) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, Math.abs (v), preco, true);
    }
}


-----Function Pair=41=-----==

public void reverseOrientation () {
    MeshVertex swapVert;
    float swapSmooth;
    int i, j;
    for (i = 0; i < usize / 2; i ++) {
        for (j = 0; j < vsize; j ++) {
            swapVert = vertex [i + usize * j];
            vertex [i + usize * j] = vertex [usize - 1 - i + usize * j];
            vertex [usize - 1 - i + usize * j] = swapVert;
        }
        swapSmooth = usmoothness [i];
        usmoothness [i] = usmoothness [usize - 1 - i];
        usmoothness [usize - 1 - i] = swapSmooth;
    }
    cachedMesh = null;
}


public void run () {
    while (autoShow && pathPos < Game.path.size () - 1) {
        g = new Game (Game.path.get (++ pathPos));
        try {
            SwingUtilities.invokeLater (new Runnable () {
                public void run () {
                    update ();
                }
            }
            );
            Thread.sleep (200);
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
}


-----Function Pair=42=-----==

protected void process_colour_pointer_pdu (RdpPacket_Localised data) throws RdesktopException {
    logger.debug ("Rdp.RDP_POINTER_COLOR");
    int x = 0, y = 0, width = 0, height = 0, cache_idx = 0, masklen = 0, datalen = 0;
    byte [] mask = null, pixel = null;
    cache_idx = data.getLittleEndian16 ();
    x = data.getLittleEndian16 ();
    y = data.getLittleEndian16 ();
    width = data.getLittleEndian16 ();
    height = data.getLittleEndian16 ();
    masklen = data.getLittleEndian16 ();
    datalen = data.getLittleEndian16 ();
    mask = new byte [masklen];
    pixel = new byte [datalen];
    data.copyToByteArray (pixel, 0, data.getPosition (), datalen);
    data.incrementPosition (datalen);
    data.copyToByteArray (mask, 0, data.getPosition (), masklen);
    data.incrementPosition (masklen);
}


public void doPrintClassCommand (String command, String [] args) {
    if (args.length == 0) return;
    try {
        int addr = parseHex32 (args [0]);
        jdp_console.writeOutput (user.bmap.addressToClassString (addr));
    } catch (NumberFormatException e) {
        try {
            jdp_console.writeOutput (args [0] + " = " + user.bmap.staticToString (args [0]));
        } catch (BmapNotFoundException e1) {
            jdp_console.writeOutput (e1.getMessage ());
        }
    } catch (memoryException e1) {
        jdp_console.writeOutput (args [0] + " is not a valid object address");
    }
}


-----Function Pair=43=-----==

public static int [] sortDescending (double input []) {
    int [] order = new int [input.length];
    for (int i = 0; i < order.length; i ++) order [i] = i;
    for (int i = input.length; -- i >= 0;) {
        for (int j = 0; j < i; j ++) {
            if (input [j] < input [j + 1]) {
                double mem = input [j];
                input [j] = input [j + 1];
                input [j + 1] = mem;
                int id = order [j];
                order [j] = order [j + 1];
                order [j + 1] = id;
            }
        }
    }
    return order;
}


private int evalFactor (StreamTokenizer st) throws IOException {
    int tok = st.nextToken ();
    switch (tok) {
        case StreamTokenizer.TT_NUMBER :
            return (int) st.nval;
        case '-' :
            return - evalFactor (st);
        case '~' :
            return ~ evalFactor (st);
        case '(' :
            int val = evalExpr (st);
            if (st.nextToken () != ')') throw new IOException ("Mismatched parentheses");
            return val;
        case StreamTokenizer.TT_WORD :
            if (st.sval.equals ("@LENGTH")) return evalLength (st);
            else throw new IOException ("Invalid token");
        default :
            throw new IOException ("Invalid token");
    }
}


-----Function Pair=44=-----==

private byte [] transformMasterKey (byte [] pKeySeed, byte [] pKey, int rounds) {
    System.out.println ("transformMasterKey, rounds=" + rounds);
    System.out.println ("transformMasterKey, pkey=" + new String (Hex.encode (pKey)));
    byte [] newKey = new byte [pKey.length];
    int i;
    BufferedBlockCipher cipher = new BufferedBlockCipher (new AESEngine ());
    cipher.init (true, new KeyParameter (pKeySeed));
    int procent = 10;
    int step = 5;
    int roundsByStep = rounds * step / ((90 - procent));
    int count = 0;
    newKey = pKey;
    for (i = 0; i < rounds; i ++) {
        cipher.processBytes (newKey, 0, newKey.length, newKey, 0);
        if (++ count == roundsByStep) {
            count = 0;
            setProgress (procent += step, null);
        }
    }
    SHA256Digest md = new SHA256Digest ();
    md.update (newKey, 0, newKey.length);
    md.doFinal (newKey, 0);
    return newKey;
}


public void addRandomRows (final int count) {
    Row r;
    for (int i = 0; i < count; i ++) {
        r = new Row (MebisScreen.ROWS - 1, MebisScreen.COLS);
        for (int z = 0; z < r.blocks.length; z ++) {
            int rr = BaseApp.rand (6);
            if (rr != 0) {
                rr = BaseApp.rand (7);
                final int color = Brick.colors [rr];
                r.blocks [z] = new Block (color, z, MebisScreen.ROWS - 1);
            }
        }
        for (int y = 0; y < MebisScreen.ROWS - 1; y ++) {
            rows [y] = rows [y + 1];
        }
        rows [MebisScreen.ROWS - 1] = r;
    }
}


-----Function Pair=45=-----==

public void bind (ServiceClass serviceClass, Object implementor, boolean doAddToSupportedTypes, boolean registerServiceClass) throws DPWSException {
    if (registerServiceClass) this.serviceClass = serviceClass;
    if (serviceClass == null) return;
    List portTypeInfos = serviceClass.getPortTypeInfos ();
    if (portTypeInfos == null) return;
    if (implementor != null) {
        if (implementor.getClass ().getSuperclass ().equals (eu.more.core.internal.MOREService.class)) {
            eu.more.core.internal.MOREService moresrv = (eu.more.core.internal.MOREService) implementor;
            if (moresrv.isproxy) {
                for (int i = 0; i < portTypeInfos.size (); i ++) {
                    PortTypeInfo pti = (PortTypeInfo) portTypeInfos.get (i);
                    String interName = pti.getServerInterface ().getName ();
                    for (int j = 0; j < portTypeInfos.size (); j ++) {
                        PortTypeInfo portTypeInfo = (PortTypeInfo) portTypeInfos.get (j);
                        Class serverInterface = portTypeInfo.getServerInterface ();
                        if (fillInformation (serverInterface, interName, portTypeInfo, implementor, false, doAddToSupportedTypes)) break;
                        Class handlerInterface = portTypeInfo.getHandlerInterface ();
                        if (fillInformation (handlerInterface, interName, portTypeInfo, implementor, true, doAddToSupportedTypes)) break;
                    }
                }
            }
        }
        Class [] inters = implementor.getClass ().getInterfaces ();
        for (int i = 0; i < inters.length; i ++) {
            String interName = inters [i].getName ();
            for (int j = 0; j < portTypeInfos.size (); j ++) {
                PortTypeInfo portTypeInfo = (PortTypeInfo) portTypeInfos.get (j);
                Class serverInterface = portTypeInfo.getServerInterface ();
                if (fillInformation (serverInterface, interName, portTypeInfo, implementor, false, doAddToSupportedTypes)) break;
                Class handlerInterface = portTypeInfo.getHandlerInterface ();
                if (fillInformation (handlerInterface, interName, portTypeInfo, implementor, true, doAddToSupportedTypes)) break;
            }
        }
    }
}


private void processHide (final String [] part) {
    if (part.length < 2) {
        usage (HIDE);
        return;
    }
    String name = part [1];
    if (name.equalsIgnoreCase (ALL)) {
        cp.hideAll ();
    }
    else {
        Agent person;
        try {
            person = (Agent) control.getWorld ().getPersonByName (name);
        } catch (AgentNotFoundException e) {
            sendError ("Who's " + name + "?");
            return;
        }
        cp.hide (person);
    }
}


-----Function Pair=46=-----==

private void _refresh () {
    l_date.setText (datefmt.format (selectedDate.getTime ()));
    l_month.setText (months [selectedDate.get (Calendar.MONTH)]);
    _computeFirstDay ();
    clipMin = clipMax = clipAllMin = clipAllMax = false;
    b_lmonth.setEnabled (true);
    b_rmonth.setEnabled (true);
    if (minDate != null) {
        int y = selectedDate.get (Calendar.YEAR);
        int y0 = minDate.get (Calendar.YEAR);
        int m = selectedDate.get (Calendar.MONTH);
        int m0 = minDate.get (Calendar.MONTH);
        if (y == y0) {
            b_lmonth.setEnabled (m > m0);
            if (m == m0) {
                clipMin = true;
                int d0 = minDate.get (Calendar.DATE);
                if (selectedDay < d0) {
                    selectedDate.set (Calendar.DATE, selectedDay = d0);
                }
            }
        }
        clipAllMin = ((m < m0) || (y < y0));
    }
    if (maxDate != null) {
        int y = selectedDate.get (Calendar.YEAR);
        int y1 = maxDate.get (Calendar.YEAR);
        int m = selectedDate.get (Calendar.MONTH);
        int m1 = maxDate.get (Calendar.MONTH);
        if (y == y1) {
            b_rmonth.setEnabled (m < m1);
            if (m == m1) {
                clipMax = true;
                int d1 = maxDate.get (Calendar.DATE);
                if (selectedDay > d1) {
                    selectedDate.set (Calendar.DATE, selectedDay = d1);
                }
            }
        }
        clipAllMax = ((m > m1) || (y > y1));
    }
    calendarPane.repaint ();
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=47=-----==

public void makeMove () {
    if (! canMakeMove) {
        throw new IllegalStateException ("No more moves can be made!");
    }
    if (elements [movingPtr] > elements [movingPtr + 1]) {
        int tmp = elements [movingPtr];
        elements [movingPtr] = elements [movingPtr + 1];
        elements [movingPtr + 1] = tmp;
        v.swap (movingPtr, movingPtr + 1);
    }
    movingPtr ++;
    if (movingPtr == rightPtr) {
        movingPtr = 0;
        -- rightPtr;
        if (0 == rightPtr) {
            canMakeMove = false;
        }
    }
}


public synchronized void dots () {
    for (int i = pixels.length - 1; i >= 0; i --) {
        pixels [i] = 0;
        pixelsZ [i] = 1000;
    }
    for (int row = 0; row < 255; row ++) {
        for (int col = 0; col < 255; col ++) {
            int i = row * 256 + col;
            PlotVal p0 = plotList [i];
            if (p0 != null) {
                tr.transform (p0);
                int x = tr.X, y = tr.Y, z = tr.Z;
                int c0 = (lutNr == ORIGINAL) ? p0.color : getLutColor (p0);
                if ((x & ~ 511) == 0 && (y & ~ 511) == 0) {
                    int pos = (y << 9) | x;
                    if (z < pixelsZ [pos]) {
                        pixelsZ [pos] = z;
                        if (light > 0) {
                            tr.x = p0.dx;
                            tr.y = p0.dy;
                            tr.z = p0.dz;
                            tr.xyzPos_ ();
                            float l = light * (- tr.X / (float) p0.len) + 1;
                            int r = (int) Math.min (255, l * ((c0>> 16) & 0xff));
                            int g = (int) Math.min (255, l * ((c0>> 8) & 0xff));
                            int b = (int) Math.min (255, l * (c0 & 0xff));
                            pixels [pos] = 0xff000000 | (r << 16) | (g << 8) | b;
                        }
                        else pixels [pos] = c0;
                    }
                }
            }
        }
    }
    image = Toolkit.getDefaultToolkit ().createImage (source);
    imageRegion.setImage (image);
}


-----Function Pair=48=-----==

public static void main (String args []) {
    File aFile = new File ("deneme.xml");
    Document document = XmlRoutines.parse (aFile);
    System.out.println (getGlobalElementNumberInXSD (document));
    final JFrame rootSelect = new JFrame ("XmlStylist");
    rootSelect.setSize (300, 300);
    JDialog.setDefaultLookAndFeelDecorated (true);
    rootSelect.setResizable (true);
    JPanel rootSelectPane = new JPanel (new SpringLayout ());
    rootSelect.setContentPane (rootSelectPane);
    DefaultTreeModel model = new DefaultTreeModel (createXSRoot (aFile, new XStance ()));
    model.reload ();
    final JTree tree = new JTree (model);
    tree.setSelectionPath (selectionPath);
    tree.setCellRenderer (new XStanceCellRenderer (new XStance ()));
    tree.setRootVisible (true);
    JScrollPane treePane = new JScrollPane (tree);
    rootSelect.getContentPane ().add (treePane);
    rootSelect.setVisible (true);
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=49=-----==

static void testRijndael_JCE () {
    byte [] aKey = new byte [32];
    byte [] aTest = new byte [16];
    byte [] aRef = new byte [16];
    int [] aRef_int = {0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89};
    int i;
    for (i = 0; i < 32; i ++) {
        aKey [i] = (byte) i;
    }
    for (i = 0; i < 16; i ++) {
        aTest [i] = (byte) ((i << 4) | i);
        aRef [i] = (byte) aRef_int [i];
    }
    try {
        BufferedBlockCipher cipher = new BufferedBlockCipher (new AESEngine ());
        cipher.init (true, new KeyParameter (aKey));
        cipher.processBytes (aTest, 0, aTest.length, aTest, 0);
    } catch (Exception ex) {
        ex.printStackTrace ();
        throw new RuntimeException ("JCE failed test");
    }
    if (Util.compare (aTest, aRef) == false) throw new RuntimeException ("JCE failed test");
}


int getImageFormatTypeIntValue (boolean powerOfTwoData) {
    int iftValue = - 1;
    switch (imageFormatType) {
        case TYPE_BYTE_BGR :
            iftValue = TYPE_BYTE_BGR;
            break;
        case TYPE_BYTE_RGB :
            iftValue = TYPE_BYTE_RGB;
            break;
        case TYPE_BYTE_ABGR :
            iftValue = TYPE_BYTE_ABGR;
            break;
        case TYPE_BYTE_RGBA :
            if ((imageDataPowerOfTwo != null) && (powerOfTwoData)) {
                iftValue = TYPE_BYTE_ABGR;
            }
            else {
                iftValue = TYPE_BYTE_RGBA;
            }
            break;
        case TYPE_BYTE_LA :
            iftValue = TYPE_BYTE_LA;
            break;
        case TYPE_BYTE_GRAY :
            iftValue = TYPE_BYTE_GRAY;
            break;
        case TYPE_USHORT_GRAY :
            iftValue = TYPE_USHORT_GRAY;
            break;
        case TYPE_INT_BGR :
            iftValue = TYPE_INT_BGR;
            break;
        case TYPE_INT_RGB :
            iftValue = TYPE_INT_RGB;
            break;
        case TYPE_INT_ARGB :
            iftValue = TYPE_INT_ARGB;
            break;
        default :
            throw new AssertionError ();
    }
    return iftValue;
}


-----Function Pair=50=-----==

protected static void fixRoots (float coeffBuf [], int coeffNum) {
    int i, j, coeffNum2;
    float rootsRe, rootsIm, f1;
    coeffNum2 = coeffNum << 1;
    float [] a = new float [coeffNum2 + 2];
    float [] roots = new float [coeffNum2];
    float [] cmplxRes = new float [2];
    a [coeffNum2] = 1.0f;
    a [coeffNum2 + 1] = 0.0f;
    for (i = 0, j = coeffNum2; j > 0;) {
        a [-- j] = 0.0f;
        a [-- j] = - coeffBuf [i ++];
    }
    zRoots (a, coeffNum, roots, true);
    for (j = 0; j < coeffNum2; j += 2) {
        f1 = complexAbs (roots [j], roots [j + 1]);
        if (f1 > 1.0f) {
            complexDiv (1.0f, 0.0f, roots [j], - roots [j + 1], cmplxRes);
            roots [j] = cmplxRes [0];
            roots [j + 1] = cmplxRes [1];
        }
    }
    a [0] = - roots [0];
    a [1] = - roots [1];
    a [2] = 1.0f;
    a [3] = 0.0f;
    for (j = 2; j < coeffNum2; j += 2) {
        a [j + 2] = 1.0f;
        a [j + 3] = 0.0f;
        rootsRe = roots [j];
        rootsIm = roots [j + 1];
        for (i = j; i >= 2; i -= 2) {
            a [i] = a [i - 2] - (rootsRe * a [i] - rootsIm * a [i + 1]);
            a [i + 1] = a [i - 1] - (rootsIm * a [i] + rootsRe * a [i + 1]);
        }
        a [0] = - rootsRe * a [0] + rootsIm * a [1];
        a [1] = - rootsIm * a [0] - rootsRe * a [1];
    }
    for (i = coeffNum, j = 0; j < coeffNum2; j += 2) {
        coeffBuf [-- i] = - a [j];
    }
}


public void getMaxPrime (int n) {
    int primeMax = 2;
    if (n <= 2) {
        System.out.println ("First prime number is " + primeMax);
    }
    else {
        boolean [] primes = new boolean [n + 1];
        Arrays.fill (primes, 2, n + 1, true);
        for (int i = 2; i * i <= n; i ++) {
            if (primes [i]) {
                for (int k = i * i; k <= n; k += i) {
                    primes [k] = false;
                }
            }
        }
        for (int i = n; i >= 0; i --) {
            if (primes [i] == true) {
                primeMax = i;
                System.out.println ("Max prime number (<=" + n + ") is " + primeMax);
                break;
            }
        }
    }
}


-----Function Pair=51=-----==

public Object execute (String method, Vector params) throws Exception {
    if (method.startsWith ("jb.")) {
        method = method.substring (3);
    }
    Utils.writeArguments (monitor, Level.DEBUG, "> " + method, params);
    try {
        Object ret = null;
        if ("call".equals (method)) {
            Object proxyId = params.elementAt (0);
            String methodName = (String) params.elementAt (1);
            ret = bridgeServer.call (proxyId, methodName, cdr (params, 2));
        }
        else if ("new".equals (method)) {
            String fqcn = (String) params.elementAt (0);
            ret = pid2str (bridgeServer.jnew (fqcn, cdr (params)));
        }
        else if ("superCall".equals (method)) {
            Object proxyId = params.elementAt (0);
            String methodName = (String) params.elementAt (1);
            ret = bridgeServer.superCall (proxyId, methodName, cdr (params, 2));
        }
        else if ("classname".equals (method)) {
            ret = bridgeServer.inspectClassname (params.elementAt (0));
        }
        else if ("static".equals (method)) {
            String fqcn = (String) params.elementAt (0);
            ret = bridgeServer.getStaticClass (fqcn);
        }
        else if ("ref".equals (method)) {
            Object proxyId = params.elementAt (0);
            String fieldName = (String) params.elementAt (1);
            ret = bridgeServer.ref (proxyId, fieldName);
        }
        else if ("set".equals (method)) {
            Object proxyId = params.elementAt (0);
            String fieldName = (String) params.elementAt (1);
            Object val = params.elementAt (2);
            bridgeServer.set (proxyId, fieldName, val);
        }
        else if ("sessionCall".equals (method)) {
            Object sid = params.elementAt (0);
            final String nestedMethod = (String) params.elementAt (1);
            final Vector args = new Vector ();
            args.addAll (Arrays.asList (cdr (params, 2)));
            ISessionProcedure sp = new ISessionProcedure () {
                public String getTitle () {
                    return nestedMethod;
                } public Object exec () throws Exception {
                    return execute (nestedMethod, args);
                }
            }
            ;
            ret = bridgeServer.sessionCall (sid, sp);
        }
        else if ("extend".equals (method)) {
            String fqcn = (String) params.elementAt (0);
            ret = pid2str (bridgeServer.jextend (fqcn, cdr (params)));
        }
        else if ("classinfo".equals (method)) {
            String fqcn = (String) params.elementAt (0);
            ret = bridgeServer.getClassInfo (fqcn);
        }
        else if ("impl".equals (method)) {
            Object proxyId = params.elementAt (0);
            String name = (String) params.elementAt (1);
            Boolean flag = (Boolean) params.elementAt (2);
            bridgeServer.setImplementFlag (proxyId, name, flag);
        }
        else if ("import".equals (method)) {
            String lines = (String) params.elementAt (0);
            bridgeServer.jimport (lines);
        }
        else if ("unlink".equals (method)) {
            Object proxyId = params.elementAt (0);
            bridgeServer.unlink (proxyId);
        }
        else if ("addClassLoader".equals (method)) {
            Object proxyId = params.elementAt (0);
            bridgeServer.addClassLoader (proxyId);
        }
        else if ("removeClassLoader".equals (method)) {
            Object proxyId = params.elementAt (0);
            bridgeServer.removeClassLoader (proxyId);
        }
        else if ("exit".equals (method)) {
            bridgeServer.exit ();
            ret = "EXIT";
        }
        else if ("allObjects".equals (method)) {
            ret = bridgeServer.getAllObjectKeys ();
        }
        else if ("dump".equals (method)) {
            bridgeServer.dumpObjects ();
            ret = "DUMP";
        }
        else {
            throw new RuntimeException ("Not supported method. " + method);
        }
        if (ret == null) {
            return NULL_SYMBOL;
        }
        return ret;
    } catch (Exception e) {
        Throwable t = e.getCause ();
        if (t == null) {
            t = e;
        }
        monitor.debug ("Exporting exception : " + t.getClass ().getName ());
        StringWriter sw = new StringWriter ();
        e.printStackTrace (new PrintWriter (sw));
        sw.flush ();
        String [] res = {EXCEPTION_SYMBOL, t.getClass ().getName (), t.getMessage (), sw.toString ()};
        return StringUtil.conbine (res, EXCEPTION_SEP);
    }
}


public void doClearBreakpoint (String command, String [] args) {
    if (args.length == 0) {
        user.bpset.clearBreakpoint ();
        jdp_console.writeOutput ("breakpoint cleared");
    }
    else if (args [0].equals ("all")) {
        user.bpset.clearAllBreakpoint ();
        jdp_console.writeOutput ("all breakpoints cleared");
    }
    else {
        try {
            int addr = parseHex32 (args [0]);
            breakpoint bp = user.bpset.lookup (addr);
            if (bp != null) {
                user.bpset.clearBreakpoint (bp);
                jdp_console.writeOutput ("breakpoint cleared");
            }
            else jdp_console.writeOutput ("no breakpoint at " + args [0]);
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("Clear breakpoint: please specify hex address");
        }
    }
}


-----Function Pair=52=-----==

private void readObject (java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
    byte version = in.readByte ();
    switch (version) {
        case 1 :
            {
                parent = (Node) in.readObject ();
                number = in.readInt ();
                sequence = (byte []) in.readObject ();
                Object partial = (double [] [] []) in.readObject ();
                length = in.readDouble ();
                lengthSE = in.readDouble ();
                height = in.readDouble ();
                in.readDouble ();
                identifier = (Identifier) in.readObject ();
                child = (Node []) in.readObject ();
                break;
            }
        case 2 :
            {
                parent = (Node) in.readObject ();
                number = in.readInt ();
                sequence = (byte []) in.readObject ();
                length = in.readDouble ();
                lengthSE = in.readDouble ();
                height = in.readDouble ();
                identifier = (Identifier) in.readObject ();
                child = (Node []) in.readObject ();
                break;
            }
        default :
            {
                parent = (Node) in.readObject ();
                number = in.readInt ();
                sequence = (byte []) in.readObject ();
                length = in.readDouble ();
                lengthSE = in.readDouble ();
                height = in.readDouble ();
                identifier = (Identifier) in.readObject ();
                child = (Node []) in.readObject ();
                attributes = (Hashtable) in.readObject ();
            }
    }
}


synchronized void updateMirrorObject (int component, Object value) {
    Object user;
    if (((component & IMAGE_CHANGED) != 0) || ((component & SUBIMAGE_CHANGED) != 0)) {
        synchronized (userList) {
            for (int i = userList.size () - 1; i >= 0; i --) {
                user = userList.get (i);
                if (user != null) {
                    if (user instanceof TextureRetained) {
                        ((TextureRetained) user).notifyImageComponentImageChanged (this, (ImageComponentUpdateInfo) value);
                    }
                    else if (user instanceof RasterRetained) {
                        ((RasterRetained) user).notifyImageComponentImageChanged (this, (ImageComponentUpdateInfo) value);
                    }
                    else if (user instanceof BackgroundRetained) {
                        ((BackgroundRetained) user).notifyImageComponentImageChanged (this, (ImageComponentUpdateInfo) value);
                    }
                }
            }
        }
    }
}


-----Function Pair=53=-----==

private Object [] vector2array (Vector v) {
    if (v.size () == 0) return new Object [0];
    Object f = v.get (0);
    Class c = f.getClass ();
    if (c.equals (String.class) && (((String) f).indexOf (TYPED_ARRAY_SYMBOL) == 0)) {
        return (String []) v.toArray (new String [v.size ()]);
    }
    for (int i = 1; i < v.size (); i ++) {
        Class s = v.get (i).getClass ();
        if (s != c) {
            Utils.writeArray (monitor, Level.DEBUG, new Object [] {" Transformed array: ", c.getName (), ", ", s.getName (), " ..."});
            return v.toArray ();
        }
    }
    monitor.debug (" Transformed array: " + c.getName ());
    return v.toArray ((Object []) Array.newInstance (c, v.size ()));
}


public boolean updatePixels (ProcessorData [] params) {
    if (isRunning () || params == null) {
        return false;
    }
    for (ProcessorData param : params) {
        if (param.name.equals (REDID)) {
            redRatio = param.selection;
        }
        else if (param.name.equals (GREENID)) {
            greenRatio = param.selection;
        }
        else if (param.name.equals (BLUEID)) {
            blueRatio = param.selection;
        }
        else if (param.name.equals (Contrast.CONTRAST)) {
            contrast = param.selection / 100.f;
        }
        else if (param.name.equals (Contrast.BRIGHTNESS)) {
            brightness = param.selection / 100.f;
        }
    }
    setUpLuts ();
    setupBCLut (rgbmean);
    return true;
}


-----Function Pair=54=-----==

public void init (VerwaltungClient verClient) {
    this.setLayout (new BorderLayout ());
    pnl1 = new JPanel ();
    pnl1.setLayout (new FlowLayout ());
    pnl1.add (new JLabel (Localization.getInstance ().getString ("GameOver")));
    pnl1.setBounds (10, 10, 200, 10);
    pnl2 = new JPanel ();
    int a_punkte [];
    int punkte = 0;
    String name;
    String [] a_namen;
    a_punkte = verClient.getA_spielEndpunkte ();
    a_namen = verClient.getA_Spielernamen ();
    zeilen = new Object [a_punkte.length] [2];
    for (int i = 0; i < a_punkte.length; i ++) {
        for (int j = 0; j < a_punkte.length - 1 - i; j ++) {
            if (a_punkte [j] < a_punkte [j + 1]) {
                punkte = a_punkte [j];
                a_punkte [j] = a_punkte [j + 1];
                a_punkte [j + 1] = punkte;
                name = a_namen [j];
                a_namen [j] = a_namen [j + 1];
                a_namen [j + 1] = name;
            }
        }
    }
    for (int i = 0; i < a_punkte.length; i ++) {
        zeilen [i] [0] = a_namen [i];
        zeilen [i] [1] = new String ("" + a_punkte [i]);
    }
    tabelle = new JTable (zeilen, spalten);
    tabelle.setEnabled (false);
    pane = new JScrollPane (tabelle);
    pnl2.add (pane);
    pnl3 = new JPanel ();
    JButton btn = new JButton (Localization.getInstance ().getString ("OK"));
    btn.addActionListener (this);
    pnl3.add (btn);
    this.add (BorderLayout.CENTER, pnl2);
    this.add (BorderLayout.NORTH, pnl1);
    this.add (BorderLayout.SOUTH, pnl3);
    this.pack ();
    this.setResizable (false);
    this.setVisible (true);
}


public static void main (String [] args) throws EprogException {
    int [] [] a = new int [3] [4];
    int temp = 0;
    float [] [] matrix = new float [3] [4];
    float [] [] matrix1 = new float [3] [4];
    float ausgabex1 = 0;
    float ausgabex2 = 0;
    float ausgabex3 = 0;
    float umrechnungsFaktor = 0;
    boolean fehler = false;
    for (int i = 0; i < a.length; i ++) {
        for (int j = 0; j < a.length + 1; j ++) {
            try {
                temp = readInt ();
            } catch (EprogException e) {
                fehler = true;
            }
            if ((temp < 21) && (temp > - 21)) {
                a [i] [j] = temp;
            }
            else {
                print ("FALSCHE EINGABE");
                System.exit (0);
            }
        }
    }
    for (int j = 0; j < 2; j ++) {
        if (a [0] [0] == 0) {
            int puffer [] = new int [4];
            for (int i = 0; i < 4; i ++) {
                puffer [i] = a [j + 1] [i];
                a [j + 1] [i] = a [0] [i];
                a [0] [i] = puffer [i];
            }
        }
    }
    if (a [0] [0] == 0) {
        println ("FALSCHE EINGABE");
        System.exit (0);
    }
    for (int index = 0; index < a.length; index ++) {
        if (a [index] [index] == 0) {
            println ("FALSCHE EINGABE");
            System.exit (0);
        }
    }
    if (fehler == false) {
        for (int index = 0; index < a [1].length; index ++) {
            matrix [0] [index] = a [0] [index];
            matrix [1] [index] = a [1] [index] - (a [1] [0] / (float) a [0] [0]) * a [0] [index];
            matrix [2] [index] = a [2] [index] - (a [2] [0] / (float) a [0] [0]) * a [0] [index];
        }
        for (int index = 0; index < matrix.length; index ++) {
            if (matrix [index] [index] == 0) {
                println ("FALSCHE EINGABE");
                System.exit (0);
            }
        }
        umrechnungsFaktor = (matrix [2] [1] - (matrix [2] [0] / matrix [0] [0]) * matrix [0] [1]) / (matrix [1] [1] - (matrix [1] [0] / matrix [0] [0]) * matrix [0] [1]);
        for (int index = 0; index < matrix [1].length; index ++) {
            matrix1 [0] [index] = matrix [0] [index];
            matrix1 [1] [index] = matrix [1] [index];
            matrix1 [2] [index] = (matrix [2] [index]) - umrechnungsFaktor * matrix [1] [index];
        }
        ausgabex3 = matrix1 [2] [3] / matrix1 [2] [2];
        ausgabex2 = (matrix1 [1] [3] - (ausgabex3 * matrix1 [1] [2])) / matrix1 [1] [1];
        ausgabex1 = (matrix1 [0] [3] - (ausgabex2 * matrix1 [0] [1]) - (ausgabex3 * matrix [0] [2])) / matrix1 [0] [0];
        for (int index = 0; index < matrix1.length; index ++) {
            if (matrix1 [index] [index] == 0) {
                println ("FALSCHE EINGABE");
                System.exit (0);
            }
        }
        printFixed (ausgabex1);
        print (" ");
        printFixed (ausgabex2);
        print (" ");
        printFixed (ausgabex3);
    }
    else {
        println ("?");
    }
}


-----Function Pair=55=-----==

public static void main (String args []) {
    int i, j, l;
    short NUMNUMBERS = 256;
    short numbers [] = new short [NUMNUMBERS];
    Darjeeling.print ("START");
    for (l = 0; l < 100; l ++) {
        for (i = 0; i < NUMNUMBERS; i ++) numbers [i] = (short) (NUMNUMBERS - 1 - i);
        for (i = 0; i < NUMNUMBERS; i ++) {
            for (j = 0; j < NUMNUMBERS - i - 1; j ++) if (numbers [j] > numbers [j + 1]) {
                short temp = numbers [j];
                numbers [j] = numbers [j + 1];
                numbers [j + 1] = temp;
            }
        }
    }
    Darjeeling.print ("END");
}


private static int varCountField (String name) {
    String shortname;
    int dot, numfield;
    shortname = name;
    numfield = 0;
    while (true) {
        dot = shortname.indexOf ('.');
        if (dot != - 1) {
            numfield ++;
            shortname = shortname.substring (dot + 1);
        }
        else {
            break;
        }
    }
    return numfield;
}


-----Function Pair=56=-----==

public double scalarProduct (final DoubleMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawScalarProduct (m);
        case TRIDIAGONAL :
            return rawScalarProductTridiagonal (m);
        default :
            int mRow = numRows;
            if (mRow == m.rows () && mRow == m.columns ()) {
                double ans = 0.0;
                ans += diag [0] * m.getElement (0, 0);
                ans += udiag [0] * m.getElement (0, 1);
                mRow --;
                for (int i = 1; i < mRow; i ++) {
                    ans += ldiag [i] * m.getElement (i, i - 1);
                    ans += diag [i] * m.getElement (i, i);
                    ans += udiag [i] * m.getElement (i, i + 1);
                }
                ans += ldiag [mRow] * m.getElement (mRow, mRow - 1);
                ans += diag [mRow] * m.getElement (mRow, mRow);
                return ans;
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


private int get_audio_common (final LameGlobalFlags gfp, final int buffer [] [], final short buffer16 [] []) {
    int num_channels = gfp.num_channels;
    int insamp [] = new int [2 * 1152];
    short buf_tmp16 [] [] = new short [2] [1152];
    int samples_read;
    int framesize;
    int samples_to_read;
    int remaining, tmp_num_samples;
    samples_to_read = framesize = gfp.framesize;
    assert (framesize <= 1152);
    tmp_num_samples = gfp.num_samples;
    if (count_samples_carefully) {
        remaining = tmp_num_samples - Math.min (tmp_num_samples, num_samples_read);
        if (remaining < framesize && 0 != tmp_num_samples) samples_to_read = remaining;
    }
    if (is_mpeg_file_format (parse.input_format)) {
        if (buffer != null) samples_read = read_samples_mp3 (gfp, musicin, buf_tmp16);
        else samples_read = read_samples_mp3 (gfp, musicin, buffer16);
        if (samples_read < 0) {
            return samples_read;
        }
    }
    else {
        samples_read = read_samples_pcm (musicin, insamp, num_channels * samples_to_read);
        if (samples_read < 0) {
            return samples_read;
        }
        int p = samples_read;
        samples_read /= num_channels;
        if (buffer != null) {
            if (num_channels == 2) {
                for (int i = samples_read; -- i >= 0;) {
                    buffer [1] [i] = insamp [-- p];
                    buffer [0] [i] = insamp [-- p];
                }
            }
            else if (num_channels == 1) {
                Arrays.fill (buffer [1], 0, samples_read, 0);
                for (int i = samples_read; -- i >= 0;) {
                    buffer [0] [i] = insamp [-- p];
                }
            }
            else assert (false);
        }
        else {
            if (num_channels == 2) {
                for (int i = samples_read; -- i >= 0;) {
                    buffer16 [1] [i] = (short) ((insamp [-- p]>> 16) & 0xffff);
                    buffer16 [0] [i] = (short) ((insamp [-- p]>> 16) & 0xffff);
                }
            }
            else if (num_channels == 1) {
                Arrays.fill (buffer16 [1], 0, samples_read, (short) 0);
                for (int i = samples_read; -- i >= 0;) {
                    buffer16 [0] [i] = (short) ((insamp [-- p]>> 16) & 0xffff);
                }
            }
            else assert (false);
        }
    }
    if (is_mpeg_file_format (parse.input_format)) {
        if (buffer != null) {
            for (int i = samples_read; -- i >= 0;) buffer [0] [i] = (buf_tmp16 [0] [i] & 0xffff) << 16;
            if (num_channels == 2) {
                for (int i = samples_read; -- i >= 0;) buffer [1] [i] = (buf_tmp16 [1] [i] & 0xffff) << 16;
            }
            else if (num_channels == 1) {
                Arrays.fill (buffer [1], 0, samples_read, 0);
            }
            else assert (false);
        }
    }
    if (tmp_num_samples != Integer.MAX_VALUE) num_samples_read += samples_read;
    return samples_read;
}


-----Function Pair=57=-----==

private double rawScalarProductTridiagonal (final DoubleMatrix m) {
    int mRow = numRows;
    if (mRow == m.numRows) {
        double ans = 0.0;
        ans += diag [0] * m.matrix [1] [0];
        ans += udiag [0] * m.matrix [2] [0];
        mRow --;
        for (int i = 1; i < mRow; i ++) {
            ans += ldiag [i] * m.matrix [0] [i];
            ans += diag [i] * m.matrix [1] [i];
            ans += udiag [i] * m.matrix [2] [i];
        }
        ans += ldiag [mRow] * m.matrix [0] [mRow];
        ans += diag [mRow] * m.matrix [1] [mRow];
        return ans;
    }
    else throw new MatrixDimensionException ("Matrices are different sizes.");
}


private boolean evalCond (StreamTokenizer st) throws IOException {
    int val = evalExpr (st);
    int token = st.nextToken ();
    switch (token) {
        case '>' :
            if (st.nextToken () == '=') return val >= evalExpr (st);
            else {
                st.pushBack ();
                return val > evalExpr (st);
            }
        case '<' :
            if (st.nextToken () == '=') return val <= evalExpr (st);
            else {
                st.pushBack ();
                return val < evalExpr (st);
            }
        case '=' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val == evalExpr (st);
        case '!' :
            if (st.nextToken () != '=') throw new IOException ("Invalid token");
            return val != evalExpr (st);
        default :
            throw new IOException ("Invalid token");
    }
}


-----Function Pair=58=-----==

public void run (String [] args) {
    initLog4J (args);
    if (args.length < 1) {
        printGlobalUsage ();
    }
    String commandName = args [0];
    String [] newArgs = new String [args.length - 1];
    for (int i = 0; i < args.length - 1; i ++) {
        newArgs [i] = args [i + 1];
    }
    CommandProcessor commandProcessor = null;
    try {
        commandProcessor = new CommandProcessor (commandName);
        commandProcessor.init (newArgs);
        String result = commandProcessor.execute ();
        System.out.println (result);
        System.exit (0);
    } catch (HelpRequiredException e) {
        commandProcessor.getCommand ().printUsage ();
        System.exit (0);
    } catch (IllegalArgumentException e) {
        System.err.println ("[ERROR] : " + e.getMessage ());
        if ((commandProcessor != null) && (commandProcessor.getCommand () != null)) {
            commandProcessor.getCommand ().printUsage ();
        }
        else {
            printGlobalUsage ();
        }
        System.exit (1);
    } catch (IOException e) {
        System.err.println ("Could not establish connection to VM via JMX : ");
        e.printStackTrace (System.err);
        System.exit (2);
    } catch (Throwable t) {
        System.err.println ("There occurred a very unexpected error:");
        t.printStackTrace ();
        System.exit (3);
    }
}


public static Range getNextRangeWithLessOrEqualGrowth (final int [] population, final int startIndex, final double maxGrowth) {
    boolean scanning = false;
    final Range r1 = new Range ();
    for (int i = startIndex; i < population.length; i ++) {
        if (i == population.length - 1) {
            r1.end = i;
            break;
        }
        if (population [i + 1] - population [i] > maxGrowth) {
            if (scanning) {
                r1.end = i;
                break;
            }
        }
        else if (! scanning) {
            scanning = true;
            r1.start = i;
        }
    }
    if (! scanning || r1.end - r1.start <= 2) {
        return null;
    }
    return r1;
}


-----Function Pair=59=-----==

public void doPrintClassCommand (String command, String [] args) {
    if (args.length == 0) return;
    try {
        int addr = parseHex32 (args [0]);
        jdp_console.writeOutput (user.bmap.addressToClassString (addr));
    } catch (NumberFormatException e) {
        try {
            jdp_console.writeOutput (args [0] + " = " + user.bmap.staticToString (args [0]));
        } catch (BmapNotFoundException e1) {
            jdp_console.writeOutput (e1.getMessage ());
        }
    } catch (memoryException e1) {
        jdp_console.writeOutput (args [0] + " is not a valid object address");
    }
}


public boolean keyUp (Event evt, int key) {
    if (key < 1000) {
        byte msg [] = {(byte) key};
        try {
            sOut.write (msg);
        } catch (Exception e) {
        }
    }
    else {
        byte msg2 [] = {};
        switch (key) {
            case 1004 :
                msg2 = ansiUp;
                break;
            case 1005 :
                msg2 = ansiDown;
                break;
            case 1006 :
                msg2 = ansiLeft;
                break;
            case 1007 :
                msg2 = ansiRight;
                break;
            default :
                System.out.println ("key...");
                System.out.println (key);
        }
        try {
            sOut.write (msg2);
        } catch (Exception e) {
        }
    }
    return (true);
}


-----Function Pair=60=-----=1=

void bubbleSort (int [] a) {
    int i = 0;
    int j = a.length - 1;
    int aux = 0;
    int stop = 0;
    while (stop == 0) {
        stop = 1;
        i = 0;
        while (i < j) {
            if (a [i] > a [i + 1]) {
                aux = a [i];
                a [i] = a [i + 1];
                a [i + 1] = aux;
                stop = 0;
            }
            i = i + 1;
        }
        j = j - 1;
    }
}


public RobotList < Float > sort_decr_Float (RobotList < Float > list, String field) {
    int length = list.size ();
    Index_value [] distri = new Index_value [length];
    for (int i = 0; i < length; i ++) {
        distri [i] = new Index_value (i, list.get (i));
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (distri [i].value < distri [i + 1].value) {
                Index_value a = distri [i];
                distri [i] = distri [i + 1];
                distri [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Float > sol = new RobotList < Float > (Float.class);
    for (int i = 0; i < length; i ++) {
        sol.addLast (new Float (distri [i].value));
    }
    return sol;
}


-----Function Pair=61=-----==

private void initOgg (String file) {
    try {
        {
            PhysicalOggStream os = null;
            AudioFormat audioFormat = null;
            ByteArrayOutputStream baos = new ByteArrayOutputStream (10240);
            URL url = CIO.getResourceURL (file);
            if (url != null) {
                os = new UncachedUrlStream (url);
            }
            else {
                File of = new File (file);
                if (of.exists ()) {
                    os = new FileStream (new RandomAccessFile (of, "r"));
                }
            }
            if (os == null) {
                System.err.println ("can not create sound : " + file);
            }
            for (Object los : os.getLogicalStreams ()) {
                LogicalOggStream loStream = (LogicalOggStream) los;
                VorbisStream vStream = new VorbisStream (loStream);
                IdentificationHeader vStreamHdr = vStream.getIdentificationHeader ();
                audioFormat = new AudioFormat ((float) vStreamHdr.getSampleRate (), 16, vStreamHdr.getChannels (), true, true);
                try {
                    byte t = 0;
                    byte [] data = new byte [2];
                    while (true) {
                        vStream.readPcm (data, 0, data.length);
                        t = data [0];
                        data [0] = data [1];
                        data [1] = t;
                        baos.write (data);
                    }
                } catch (EndOfOggStreamException e) {
                }
                vStream.close ();
                loStream.close ();
            }
            os.close ();
            if (audioFormat.getChannels () == 1) format [0] = AL.AL_FORMAT_MONO16;
            else format [0] = AL.AL_FORMAT_STEREO16;
            data [0] = ByteBuffer.wrap (baos.toByteArray ());
            size [0] = baos.size ();
            freq [0] = (int) audioFormat.getFrameRate ();
            System.out.println (audioFormat + " size = " + baos.size () + " : " + file);
        }
        {
            int [] buffer = new int [1];
            al.alGenBuffers (1, buffer, 0);
            if (al.alGetError () != AL.AL_NO_ERROR) {
                System.err.println ("Error generating OpenAL buffers : " + file);
                return;
            }
            al.alBufferData (buffer [0], format [0], data [0], size [0], freq [0]);
            if (al.alGetError () != AL.AL_NO_ERROR) {
                System.err.println ("Error bind WAV file : " + file);
                return;
            }
            this.buffer = buffer;
        }
    } catch (Exception err) {
        err.printStackTrace ();
    }
}


private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=62=-----==

void processTemplateRegion (Vector region) throws IOException {
    String inLine = (String) region.elementAt (0);
    int command = getTemplateCommand (inLine);
    switch (command) {
        case FOREACH :
            processForeachRegion (region);
            break;
        case LOOP :
            processLoopRegion (region);
            break;
        case COUNT :
            processCountRegion (region);
            break;
        case SPLIT :
            processSplitRegion (region);
            break;
        case JOIN :
            processJoinRegion (region);
            break;
        case LET :
            processLetRegion (region);
            break;
        case EVAL :
            processEvalRegion (region);
            break;
        case IF :
            processCondRegion (region);
            break;
        case INCLUDE :
            processIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
}


private void smoothingFilter (int width, int height, int rad) {
    int size = 2 * rad + 1;
    float [] k = getBlurKernel (2 * rad + 1);
    for (int y = 0; y < height; y ++) {
        for (int x = 0; x < width; x ++) {
            int i = y * width + x;
            if (plotList [i] != null) {
                float sum = 0;
                float n = 0;
                for (int dy = - rad, ky = 0; dy <= rad; dy ++, ky += size) {
                    int y_ = Math.max (Math.min (y + dy, height - 1), 0);
                    int offset = y_ * width;
                    for (int dx = - rad, kx = 0; dx <= rad; dx ++, kx ++) {
                        int x_ = Math.max (Math.min (x + dx, width - 1), 0);
                        int j = offset + x_;
                        if (plotList [j] != null) {
                            float f = k [ky + kx];
                            sum += f * plotList [j].lum;
                            n += f;
                        }
                    }
                }
                plotList [i].z = (int) (sum / n - 128);
            }
        }
    }
}


-----Function Pair=63=-----==

private static String PositiveIntegerToHanStr (String NumStr) {
    String RMBStr = "";
    boolean lastzero = false;
    boolean hasvalue = false;
    int len, n;
    len = NumStr.length ();
    if (len > 15) return "��ֵ���!";
    for (int i = len - 1; i >= 0; i --) {
        if (NumStr.charAt (len - i - 1) == ' ') continue;
        n = NumStr.charAt (len - i - 1) - '0';
        if (n < 0 || n > 9) return "���뺬�������ַ�!";
        if (n != 0) {
            if (lastzero) RMBStr += HanDigiStr [0];
            if (! (n == 1 && (i % 4) == 1 && i == len - 1)) RMBStr += HanDigiStr [n];
            RMBStr += HanDiviStr [i];
            hasvalue = true;
        }
        else {
            if ((i % 8) == 0 || ((i % 8) == 4 && hasvalue)) RMBStr += HanDiviStr [i];
        }
        if (i % 8 == 0) hasvalue = false;
        lastzero = (n == 0) && (i % 4 != 0);
    }
    if (RMBStr.length () == 0) return HanDigiStr [0];
    return RMBStr;
}


public void actionPerformed (ActionEvent e) {
    int ID = gui.getItemID (e);
    int i, j, k;
    int [] rows;
    BatchObject [] dup;
    Transferable t;
    BatchObject bObj;
    switch (ID) {
        case GG_CMDOPEN :
            if (batchTable.getSelectedRowCount () != 1) break;
            bObj = (BatchObject) batchVector.get (batchTable.getSelectedRow ());
            if (bObj.command != BatchObject.CMD_MODULE) break;
            DocumentFrame procWin;
            try {
                procWin = getProcInstance (bObj, null);
                procWin.fillGUI ();
                procWin.setVisible (true);
            } catch (Exception e1) {
                GUIUtil.displayError (getComponent (), e1, getTitle ());
            }
            break;
        case GG_CMDADD :
            i = batchTable.getSelectedRow () + 1;
            i = i == 0 ? batchVector.size () : i;
            batchTable.clearSelection ();
            batchVector.add (i, new BatchObject ());
            batchTM.fireTableRowsInserted (i, i);
            batchTable.setRowSelectionInterval (i, i);
            break;
        case GG_CMDCUT :
        case GG_CMDCOPY :
            rows = batchTable.getSelectedRows ();
            if (rows.length > 0) {
                dup = new BatchObject [rows.length];
                for (i = 0; i < rows.length; i ++) {
                    dup [i] = new BatchObject ((BatchObject) batchVector.get (rows [i]));
                }
                AbstractApplication.getApplication ().getClipboard ().setContents (new BatchObjectArray (dup), cbo);
                if (ID == GG_CMDCUT) {
                    for (boolean finished = false; ! finished;) {
                        for (i = 0, j = - 1, k = - 1; i < rows.length; i ++) {
                            if (rows [i] > j) {
                                j = rows [i];
                                k = i;
                            }
                        }
                        if (j >= 0) {
                            batchVector.remove (j);
                            rows [k] = - 1;
                            batchTM.fireTableRowsDeleted (j, j);
                        }
                        else {
                            finished = true;
                        }
                    }
                }
            }
            break;
        case GG_CMDPASTE :
            i = batchTable.getSelectedRow () + 1;
            i = i == 0 ? batchVector.size () : i;
            try {
                t = AbstractApplication.getApplication ().getClipboard ().getContents (enc_this);
                if (t != null) {
                    if (t.isDataFlavorSupported (BatchObjectArray.flavor)) {
                        dup = (BatchObject []) t.getTransferData (BatchObjectArray.flavor);
                        if (dup.length > 0) {
                            batchTable.clearSelection ();
                            for (j = 0, k = i; j < dup.length; j ++, k ++) {
                                batchVector.add (k, dup [j]);
                            }
                            batchTM.fireTableRowsInserted (i, k - 1);
                            batchTable.setRowSelectionInterval (i, k - 1);
                        }
                    }
                }
            } catch (IllegalStateException e97) {
            } catch (IOException e98) {
            } catch (UnsupportedFlavorException e99) {
            }
            break;
    }
}


-----Function Pair=64=-----==

void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


public void visitSelect (JCFieldAccess tree) {
    Symbol sym = tree.sym;
    if (tree.name == names._class) {
        assert target.hasClassLiterals ();
        code.emitop2 (ldc2, makeRef (tree.pos (), tree.selected.type));
        result = items.makeStackItem (pt);
        return;
    }
    Symbol ssym = TreeInfo.symbol (tree.selected);
    boolean selectSuper = ssym != null && (ssym.kind == TYP || ssym.name == names._super);
    boolean accessSuper = isAccessSuper (env.enclMethod);
    Item base = (selectSuper) ? items.makeSuperItem () : genExpr (tree.selected, tree.selected.type);
    if (sym.kind == VAR && ((VarSymbol) sym).getConstValue () != null) {
        if ((sym.flags () & STATIC) != 0) {
            if (! selectSuper && (ssym == null || ssym.kind != TYP)) base = base.load ();
            base.drop ();
        }
        else {
            base.load ();
            genNullCheck (tree.selected.pos ());
        }
        result = items.makeImmediateItem (sym.type, ((VarSymbol) sym).getConstValue ());
    }
    else {
        if (! accessSuper) sym = binaryQualifier (sym, tree.selected.type);
        if ((sym.flags () & STATIC) != 0) {
            if (! selectSuper && (ssym == null || ssym.kind != TYP)) base = base.load ();
            base.drop ();
            result = items.makeStaticItem (sym);
        }
        else {
            base.load ();
            if (sym == syms.lengthVar) {
                code.emitop0 (arraylength);
                result = items.makeStackItem (syms.intType);
            }
            else {
                result = items.makeMemberItem (sym, (sym.flags () & PRIVATE) != 0 || selectSuper || accessSuper);
            }
        }
    }
}


-----Function Pair=65=-----==

private void update () {
    int count = getLogsCount ();
    int max = data.start + visibleLogs;
    if (max > count) max = count;
    countLabel.setText ("" + (data.start + 1) + " - " + max + " of " + count);
    int i = 0;
    for (; i < visibleLogs; ++ i) {
        if (data.start + i >= getLogsCount ()) break;
        table.setWidget (i + 1, 0, selects [i]);
        if (data == null || data.lines.length <= i || data.lines [i] == null) {
            int realCol = 1;
            for (int n = 1; n < navBarColumn; n ++) {
                if (visibleColumns [n - 1]) {
                    table.setText (i + 1, realCol, "");
                    realCol ++;
                }
            }
        }
        else {
            String color = "";
            if (data.lines [i].level.startsWith ("F")) color = "log-debug";
            else if (data.lines [i].level.startsWith ("I")) color = "log-info";
            else if (data.lines [i].level.startsWith ("W")) color = "log-warn";
            else {
                color = "log-err";
            }
            int realCol = 1;
            if (visibleColumns [Column.LEVEL.ordinal]) table.setText (i + 1, realCol ++, data.lines [i].level.toString ().substring (0, 1));
            if (visibleColumns [Column.DATE.ordinal]) {
                String date = data.lines [i].dateFormatted;
                if (date.length () != 17) table.setHTML (i + 1, realCol ++, date);
                else {
                    String yearmonth = date.substring (0, 9);
                    String dayhourmin = date.substring (9, 14);
                    String secs = date.substring (14);
                    String html = "<font style='font-size: smaller;'>" + yearmonth + "</font>" + dayhourmin + "<font style='font-size: smaller;'>" + secs + "</font>";
                    table.setHTML (i + 1, realCol ++, html);
                }
            }
            if (visibleColumns [Column.URI.ordinal]) {
                String uri = data.lines [i].uri;
                boolean regular = true;
                if (! uri.startsWith ("//")) regular = false;
                else {
                    int first = uri.indexOf ("/", 2);
                    if (first < 0) regular = false;
                    else {
                        int second = uri.indexOf ("/", first + 1);
                        if (second < 0) regular = false;
                        else {
                            String begin = uri.substring (0, second);
                            String end = uri.substring (second);
                            String html = "<font style='font-size: smaller;'>" + begin + "</font>" + end;
                            table.setHTML (i + 1, realCol ++, html);
                        }
                    }
                }
                if (! regular) table.setText (i + 1, realCol ++, uri);
            }
            if (visibleColumns [Column.LOGGERNAME.ordinal]) table.setText (i + 1, realCol ++, data.lines [i].loggerName);
            if (visibleColumns [Column.CLASSMETHOD.ordinal]) table.setText (i + 1, realCol ++, data.lines [i].className + "::" + data.lines [i].methodName);
            if (visibleColumns [Column.MESSAGE.ordinal]) {
                String message = data.lines [i].message;
                int secondlineat = message.indexOf ("<br />");
                if (secondlineat > 0) {
                    HorizontalPanel hp = new HorizontalPanel ();
                    hp.setWidth ("100%");
                    HTML begin = new HTML (message.substring (0, secondlineat));
                    begin.addStyleName (color);
                    hp.add (begin);
                    HTML more = new HTML ("<a href='javascript:;'>...</a>");
                    hp.add (more);
                    hp.setCellHorizontalAlignment (more, HasHorizontalAlignment.ALIGN_RIGHT);
                    final VerticalPanel vp = new VerticalPanel ();
                    vp.setWidth ("100%");
                    vp.add (hp);
                    final HTML rest = new HTML (message.substring (secondlineat + 6));
                    rest.addStyleName (color);
                    more.addClickListener (new ClickListener () {
                        public void onClick (Widget sender) {
                            if (vp.getWidgetCount () == 1) vp.add (rest);
                            else vp.remove (1);
                        }
                    }
                    );
                    table.setWidget (i + 1, realCol ++, vp);
                }
                else table.setHTML (i + 1, realCol ++, message);
            }
            if (visibleColumns [Column.ACK.ordinal]) table.setText (i + 1, realCol ++, "");
            table.getRowFormatter ().removeStyleName (i + 1, "log-debug");
            table.getRowFormatter ().removeStyleName (i + 1, "log-info");
            table.getRowFormatter ().removeStyleName (i + 1, "log-warn");
            table.getRowFormatter ().removeStyleName (i + 1, "log-err");
            if (visibleColumns [Column.ACK.ordinal]) {
                if (! data.lines [i].acked) {
                    table.getFlexCellFormatter ().setColSpan (i + 1, realCol - 2, 2);
                    final long id = data.lines [i].id;
                    HTML ack = new HTML ("<a href='javascript:;'>Acknowledge</a>;");
                    ack.addClickListener (new ClickListener () {
                        public void onClick (Widget arg0) {
                            AsyncCallback cb = new AsyncCallback () {
                                public void onFailure (Throwable arg0) {
                                } public void onSuccess (Object arg0) {
                                    getData (0);
                                }
                            }
                            ;
                            weblog.ack (id, cb);
                        }
                    }
                    );
                    ack.addStyleName ("log-ack");
                    table.setWidget (i + 1, realCol - 1, ack);
                }
                else {
                    table.setText (i + 1, realCol - 1, "");
                    table.removeCell (i + 1, realCol - 1);
                    table.getFlexCellFormatter ().setColSpan (i + 1, realCol - 2, 3);
                }
            }
            table.getRowFormatter ().addStyleName (i + 1, color);
        }
    }
    for (; i < visibleLogs; ++ i) {
        table.setHTML (i + 1, 0, "&nbsp;");
        table.setHTML (i + 1, 1, "&nbsp;");
        table.setHTML (i + 1, 2, "&nbsp;");
        table.setHTML (i + 1, 3, "&nbsp;");
        table.setHTML (i + 1, 4, "&nbsp;");
    }
}


public static void main (String [] args) {
    long [] arr;
    arr = new long [100];
    int nElems = 0;
    int j;
    long searchKey;
    arr [0] = 77;
    arr [1] = 99;
    arr [2] = 44;
    arr [3] = 55;
    arr [4] = 22;
    arr [5] = 88;
    arr [6] = 11;
    arr [7] = 00;
    arr [8] = 66;
    arr [9] = 33;
    nElems = 10;
    for (j = 0; j < nElems; j ++) {
        System.out.print (arr [j] + " ");
    }
    System.out.println ("");
    searchKey = 66;
    for (j = 0; j < nElems; j ++) {
        if (arr [j] == searchKey) {
            break;
        }
    }
    if (j == nElems) {
        System.out.print (j);
        System.out.println ("can't find " + searchKey);
    }
    else {
        System.out.println ("find " + searchKey);
    }
    searchKey = 55;
    for (j = 0; j < nElems; j ++) {
        if (arr [j] == searchKey) {
            break;
        }
    }
    for (int k = j; k < nElems; k ++) {
        arr [k] = arr [k + 1];
    }
    nElems --;
    for (j = 0; j < nElems; j ++) {
        System.out.print (arr [j] + " ");
    }
    System.out.println ("");
}


-----Function Pair=66=-----==

public void doListInstruction (String command, String [] args) {
    int count;
    int addr = - 1;
    try {
        switch (args.length) {
            case 0 :
                addr = user.reg.currentIP ();
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            case 1 :
                addr = parseHex32 (args [0]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            default :
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, count));
                break;
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad address: " + args [0]);
    }
}


public void alignment (int size) {
    if (m_pending_value_reopen) {
        m_pending_value_reopen = false;
        int len = peek_long ();
        if (! ((len >= 0x7fffff00) && (len <= 0x7fffffff))) {
            begin_value_chunk (read_long ());
        }
    }
    if (size > 1) {
        int tmp = m_index % size;
        if (tmp != 0) {
            force_skip (size - tmp);
        }
    }
}


-----Function Pair=67=-----==

public static void main (String [] args) throws IOException {
    final int caracteres = 100;
    int i, j, k, contador, acumulado = 0;
    int contadorV = 0, contadorL = 0, contadorD = 0;
    char entradaC [];
    boolean romano = false;
    int valores [] = new int [caracteres];
    String entrada;
    InputStreamReader teclado;
    BufferedReader bufferLectura;
    teclado = new InputStreamReader (System.in);
    bufferLectura = new BufferedReader (teclado);
    do {
        System.out.print ("Introduzca el Número Romano: ");
        entrada = bufferLectura.readLine ().toUpperCase ();
        contador = 0;
        entradaC = new char [entrada.length ()];
        for (i = 0; i < entrada.length (); i ++) {
            entradaC [i] = entrada.charAt (i);
            if (entradaC [i] == 'I' || entradaC [i] == 'V' || entradaC [i] == 'X' || entradaC [i] == 'L' || entradaC [i] == 'C' || entradaC [i] == 'D' || entradaC [i] == 'M') {
                contador ++;
            }
            if (contador == entrada.length ()) romano = true;
        }
        for (i = 3; i < entrada.length (); i ++) {
            if (entradaC [i] == entradaC [i - 1] && entradaC [i - 1] == entradaC [i - 2] && entradaC [i - 2] == entradaC [i - 3]) {
                romano = false;
                System.out.println ("\tERORR: No puedes poner más de 3 Símbolos iguales seguidos");
            }
        }
        for (i = 0; i < entrada.length (); i ++) {
            if (entradaC [i] == 'V') contadorV ++;
            if (entradaC [i] == 'L') contadorL ++;
            if (entradaC [i] == 'D') contadorD ++;
        }
        if (contadorV <= 1 || contadorL <= 1 || contadorD <= 1);
        else if (contadorV > 1 || contadorL > 1 || contadorD > 1) {
            romano = false;
            System.out.println ("\tERROR: Aparece más de una vez V ó L ó D");
            contadorV = 0;
            contadorL = 0;
            contadorD = 0;
        }
    }
    while (romano != true);
    for (i = 0; i < contador; i ++) {
        if (entradaC [i] == 'I') valores [i] = 1;
        else if (entradaC [i] == 'V') valores [i] = 5;
        else if (entradaC [i] == 'X') valores [i] = 10;
        else if (entradaC [i] == 'C') valores [i] = 100;
        else if (entradaC [i] == 'L') valores [i] = 50;
        else if (entradaC [i] == 'D') valores [i] = 500;
        else if (entradaC [i] == 'M') valores [i] = 1000;
    }
    for (i = 0; i <= contador;) {
        if (valores [i] < valores [i + 1]) {
            valores [i + 1] = valores [i + 1] - valores [i];
            valores [i] = 0;
        }
        else if (valores [i] == valores [i + 1] && valores [i] != 0) {
            valores [i + 1] = valores [i + 1] + valores [i];
            valores [i] = 0;
        }
        else if (valores [i] == 0) i ++;
        else i ++;
        for (k = 0; k <= contador; k ++) for (j = 0; j <= contador; j ++) {
            if (valores [j] == 0) {
                valores [j] = valores [j + 1];
                valores [j + 1] = 0;
            }
        }
    }
    for (i = 0; i <= contador; i ++) {
        acumulado += valores [i];
    }
    System.out.println ();
    System.out.print ("El Número Romano ");
    for (i = 0; i < contador; i ++) System.out.print (entradaC [i]);
    System.out.println ();
    System.out.print ("Tiene un valor de " + acumulado);
}


void processTemplateRegion (Vector region) throws IOException {
    String inLine = (String) region.elementAt (0);
    int command = getTemplateCommand (inLine);
    switch (command) {
        case FOREACH :
            processForeachRegion (region);
            break;
        case LOOP :
            processLoopRegion (region);
            break;
        case COUNT :
            processCountRegion (region);
            break;
        case SPLIT :
            processSplitRegion (region);
            break;
        case JOIN :
            processJoinRegion (region);
            break;
        case LET :
            processLetRegion (region);
            break;
        case EVAL :
            processEvalRegion (region);
            break;
        case IF :
            processCondRegion (region);
            break;
        case INCLUDE :
            processIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
}


-----Function Pair=68=-----==

public synchronized void listen () {
    try {
        if (initialized) {
            Logger.logDebug (className + " " + id + ": listen aborted - already initialized");
            return;
        }
        else {
            initialized = true;
        }
        try {
            node.getEventOut ("SystemOut").advise (this, "SystemOut");
        } catch (Exception e) {
        }
        try {
            systemIn = (EventInMFString) node.getEventIn ("SystemIn");
        } catch (Exception e) {
        }
        if (node != null && node.getType ().equals ("Background")) {
            if (applet.bg != null) {
                try {
                    ((EventInMFFloat) applet.bg.getEventIn ("set_groundAngle")).setValue (((EventOutMFFloat) node.getEventOut ("groundAngle_changed")).getValue ());
                    ((EventInMFFloat) applet.bg.getEventIn ("set_skyAngle")).setValue (((EventOutMFFloat) node.getEventOut ("skyAngle_changed")).getValue ());
                    ((EventInMFColor) applet.bg.getEventIn ("set_groundColor")).setValue (((EventOutMFColor) node.getEventOut ("groundColor_changed")).getValue ());
                    ((EventInMFColor) applet.bg.getEventIn ("set_skyColor")).setValue (((EventOutMFColor) node.getEventOut ("skyColor_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_backUrl")).setValue (((EventOutMFString) node.getEventOut ("backUrl_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_bottomUrl")).setValue (((EventOutMFString) node.getEventOut ("bottomUrl_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_frontUrl")).setValue (((EventOutMFString) node.getEventOut ("frontUrl_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_leftUrl")).setValue (((EventOutMFString) node.getEventOut ("leftUrl_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_rightUrl")).setValue (((EventOutMFString) node.getEventOut ("rightUrl_changed")).getValue ());
                    ((EventInMFString) applet.bg.getEventIn ("set_topUrl")).setValue (((EventOutMFString) node.getEventOut ("topUrl_changed")).getValue ());
                } catch (Throwable t) {
                    Logger.logError (t);
                }
            }
        }
        try {
            init = (EventOutMFString) node.getEventOut ("VRObject_Init");
            init.advise (this, "VRObject_Init");
            EventInSFBool online = (EventInSFBool) node.getEventIn ("VRObject_Online");
            online.setValue (true);
        } catch (Exception e) {
        }
        if (systemIn != null && parent != null) {
            systemIn.setValue (new String [] {"init", getClassName () + " " + getId (), parent.getClassName () + " " + parent.getId (), MyUser.myClass + " " + MyUser.myId});
        }
        try {
            EventInSFVec3f parentPos = (EventInSFVec3f) node.getEventIn ("parent_pos");
            float [] tran = {parent.x, parent.y, parent.z};
            parentPos.setValue (tran);
        } catch (Exception e) {
        }
        try {
            EventInSFRotation parentRot = (EventInSFRotation) node.getEventIn ("parent_rot");
            float [] rot = {parent.rotx, parent.roty, parent.rotz, parent.angle};
            parentRot.setValue (rot);
        } catch (Exception e) {
        }
        try {
            inspect = (EventOutSFTime) node.getEventOut ("inspect");
            inspect.advise (this, "inspect");
        } catch (Exception e) {
        }
        if (url != null && url [0].indexOf ('#') > 0) {
            try {
                EventInMFString paramUrl = (EventInMFString) node.getEventIn ("set_url");
                String [] tmp = {url [0].substring (url [0].indexOf ('#') + 1)};
                paramUrl.setValue (tmp);
            } catch (Exception e) {
            }
        }
        if (parent != null && parent.hasBBox ()) {
            try {
                EventInSFVec3f set_bBoxCenter = (EventInSFVec3f) node.getEventIn ("set_bBoxCenter");
                EventInSFVec3f set_bBoxSize = (EventInSFVec3f) node.getEventIn ("set_bBoxSize");
                set_bBoxCenter.setValue (parent.bBoxCenter);
                set_bBoxSize.setValue (parent.bBoxSize);
            } catch (Exception e) {
            }
        }
    } catch (Throwable e) {
        Logger.logDebug (className + " " + id + " passive");
        Logger.logError (e);
    }
}


public void run () {
    try {
        SwingUtilities.invokeAndWait (new Runnable () {
            public void run () {
                solve_b.setEnabled (false);
            }
        }
        );
    } catch (InterruptedException ex) {
        Logger.getLogger (JKlotski.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (InvocationTargetException ex) {
        Logger.getLogger (JKlotski.class.getName ()).log (Level.SEVERE, null, ex);
    }
    boolean solvable = Game.search (g);
    if (solvable) {
        pathPos = 0;
        startPattern = g.toString ();
        next_b.setEnabled (true);
        previous_b.setEnabled (true);
        start_b.setEnabled (true);
        stop_b.setEnabled (true);
        solve_b.setEnabled (true);
        SwingUtilities.invokeLater (new Runnable () {
            public void run () {
                Game.path.addFirst (new Game (startPattern).toString ());
                label.setText ("Solved in " + (Game.path.size () - 1) + " steps.");
            }
        }
        );
    }
    else {
        SwingUtilities.invokeLater (new Runnable () {
            public void run () {
                label.setText ("No solution!");
            }
        }
        );
    }
}


-----Function Pair=69=-----==

void resolveReferences (Session session) {
    if (statement != null) {
        statement.resolve (session);
        checkSQLData (session);
    }
    if (methodName != null && javaMethod == null) {
        boolean [] hasConnection = new boolean [1];
        javaMethod = getMethod (methodName, this, hasConnection, returnsTable);
        if (javaMethod == null) {
            throw Error.error (ErrorCode.X_46103);
        }
        javaMethodWithConnection = hasConnection [0];
        String className = javaMethod.getDeclaringClass ().getName ();
        if (className.equals ("java.lang.Math")) {
            isLibraryRoutine = true;
        }
    }
    setReferences ();
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=70=-----==

void resolveReferences (Session session) {
    if (statement != null) {
        statement.resolve (session);
        checkSQLData (session);
    }
    if (methodName != null && javaMethod == null) {
        boolean [] hasConnection = new boolean [1];
        javaMethod = getMethod (methodName, this, hasConnection, returnsTable);
        if (javaMethod == null) {
            throw Error.error (ErrorCode.X_46103);
        }
        javaMethodWithConnection = hasConnection [0];
        String className = javaMethod.getDeclaringClass ().getName ();
        if (className.equals ("java.lang.Math")) {
            isLibraryRoutine = true;
        }
    }
    setReferences ();
}


public boolean setMessage (byte [] message) {
    messageBody = null;
    if (message.length < 8) {
        return false;
    }
    if (message [0] != startByte0 || message [1] != startByte1 || message [message.length - 2] != endByte0 || message [message.length - 1] != endByte1) {
        return false;
    }
    int payloadlenght = (message [2] << 8) | (message [3] & 0xFF);
    if (message.length != payloadlenght + 8) {
        return false;
    }
    messageID = message [4];
    final int expected_checksum = (message [message.length - 4] << 8) | (message [message.length - 3] & 0xFF);
    messageBody = new byte [payloadlenght - 1];
    int checksum = 0;
    for (int i = 0; i < payloadlenght - 1; i ++) {
        messageBody [i] = message [i + 5];
        checksum += messageBody [i];
        checksum &= 0x7FFF;
    }
    if (checksum != expected_checksum) {
        return false;
    }
    return true;
}


-----Function Pair=71=-----==

private void placeCell (ArrayList someRows, Cell aCell, Point aPosition) {
    int i;
    Row row = null;
    int lColumns = ((Row) someRows.get (0)).columns ();
    int rowCount = aPosition.x + aCell.rowspan () - someRows.size ();
    assumeTableDefaults (aCell);
    if ((aPosition.x + aCell.rowspan ()) > someRows.size ()) {
        for (i = 0; i < rowCount; i ++) {
            row = new Row (lColumns);
            someRows.add (row);
        }
    }
    for (i = aPosition.x + 1; i < (aPosition.x + aCell.rowspan ()); i ++) {
        if (! ((Row) someRows.get (i)).reserve (aPosition.y, aCell.colspan ())) {
            throw new RuntimeException ("addCell - error in reserve");
        }
    }
    row = (Row) someRows.get (aPosition.x);
    row.addElement (aCell, aPosition.y);
}


public static Object financialPricedisc (Object [] args, XelContext ctx) {
    double discount = CommonFns.toNumber (args [2]).doubleValue ();
    double redemption = CommonFns.toNumber (args [3]).doubleValue ();
    if (discount <= 0 || redemption <= 0) {
        throw new SSErrorXelException (SSError.NUM);
    }
    else {
        Date settlement = UtilFns.stringToDate (args [0].toString ());
        Date maturity = UtilFns.stringToDate (args [1].toString ());
        int basis = 0;
        if (args.length == 5) {
            basis = basis (CommonFns.toNumber (args [4]).intValue ());
        }
        int dsm = UtilFns.dsm (settlement, maturity, basis);
        double B = UtilFns.basisToDouble (basis, settlement, maturity, dsm);
        double pricedisc = redemption - discount * redemption * (dsm / B);
        return new Double (pricedisc);
    }
}


-----Function Pair=72=-----==

private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandWord (edu.cmu.sphinx.decoder.linguist.WordState wordState) {
    edu.cmu.sphinx.decoder.linguist.GrammarWord word = wordState.getWord ();
    Pronunciation [] pronunciations = word.getPronunciations ();
    edu.cmu.sphinx.decoder.linguist.SentenceHMMState endWordState = new CombineState (wordState.getParent (), wordState.getWhich ());
    for (int i = 0; i < pronunciations.length; i ++) {
        edu.cmu.sphinx.decoder.linguist.PronunciationState pronunciationState = new edu.cmu.sphinx.decoder.linguist.PronunciationState (wordState, i);
        attachState (wordState, pronunciationState, logMath.getLogOne (), logMath.getLogOne () - logMath.linearToLog (pronunciations.length), logMath.getLogOne ());
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = expandPronunciation (pronunciationState);
        if (pronunciations.length == 1) {
            endWordState = lastState;
        }
        else {
            attachState (lastState, endWordState, logMath.getLogOne (), logMath.getLogOne (), logMath.getLogOne ());
        }
    }
    return endWordState;
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=73=-----==

private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=74=-----==

public OrdersTO doTrade () throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    if (currTime < PERIODO) {
        novo_dia (preco, dias);
        return createOrdemTO (0, preco, true);
    }
    else {
        double m = media (dias);
        int v;
        if (Trend.trend (dias) > 0 && dias [PERIODO - 1] < m) v = VOLUME;
        else if (Trend.trend (dias) < 0 && m < dias [PERIODO - 1]) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, dias);
        return createOrdemTO (Math.abs (v), preco, true);
    }
}


private void readLav (File lav) throws Exception {
    if (singularvalues < 0) throw new Exception ("Corrupt lao file! Couldn't find NSIG line before the singular values!");
    if (numterms <= 0) throw new Exception ("Corrupt lao file! Couldn't find TERMS line before the singular values!");
    if (numdocs <= 0) throw new Exception ("Corrupt lao file! Couldn't find DOCS line before the singular values!");
    FileInputStream reader = new FileInputStream (lav);
    int vVectors = 0;
    int uVectors = 0;
    int currentData = 0;
    int blocksize = 0;
    byte [] headerbuff = new byte [24];
    reader.read (headerbuff);
    rank = (int) arr2long (headerbuff, 0);
    lanczosSteps = arr2long (headerbuff, 8);
    kappa = arr2double (headerbuff, 16);
    byte [] buff = new byte [8];
    while ((blocksize = reader.read (buff)) != - 1) {
        double num = arr2double (buff, 0);
        double exp = 0;
        String expSt = (new DecimalFormat ("0.############E0")).format (num);
        if (expSt.split ("E").length > 1) exp = Double.parseDouble (expSt.split ("E") [1]);
        if (Math.abs (exp) > 10) {
            logger.debug (currentData + " Jumping: " + num);
            for (int i = 0; i < 7; i ++) {
                buff [i] = buff [i + 1];
            }
            buff [7] = (byte) reader.read ();
            num = arr2double (buff, 0);
        }
        int index = currentData % singularvalues;
        int indexU = currentData % numterms;
        if (vVectors < numdocs) v.set (numdocs - vVectors - 1, index, num);
        else if (uVectors < singularvalues) {
            u.set (indexU, singularvalues - uVectors - 1, num);
        }
        if (blocksize != 8) logger.debug ("Some size lost " + blocksize);
        currentData ++;
        if (vVectors < numdocs) {
            if (currentData % singularvalues == 0) {
                vVectors ++;
                if (vVectors == numdocs) currentData = 0;
            }
        }
        else {
            if (currentData % numterms == 0) uVectors ++;
        }
    }
    v = Algebra.DEFAULT.transpose (v);
    logger.debug ("Vectors:" + vVectors);
    reader.close ();
}


-----Function Pair=75=-----==

private void positionHandles () {
    Rectangle bounds = canvas.getBounds ();
    int oldrows = rows;
    bounds.x += INSET;
    bounds.width -= 2 * INSET;
    for (int i = 0; i < index.length; i ++) handlePos [i].x = (int) (bounds.x + index [i] * bounds.width);
    if (clickPoint != null) return;
    rows = 1;
    for (int i = 1; i < index.length; i ++) {
        int row = 0;
        boolean overlap = true;
        while (overlap) {
            overlap = false;
            int j;
            for (j = 0; j < i && (row != handlePos [j].y || handlePos [i].x - handlePos [j].x > HANDLE_SIZE); j ++);
            if (j < i) {
                row ++;
                overlap = true;
            }
        }
        handlePos [i].y = row;
        if (row >= rows) rows = row + 1;
    }
    if (oldrows != rows) pack ();
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=76=-----==

public int wertePunkte (int augenzahl) {
    int erg = 0;
    ueberreizt = false;
    erg = punkteVarianten (erg, augenzahl);
    if (variante == Spielvariante.RAMSCHBOCK && bock == true) {
        erg = erg * 2;
    }
    if (checkVerloren (augenzahl)) {
        erg = erg * (- 2);
    }
    if (variante == Spielvariante.SKAT || variante == Spielvariante.RAMSCHBOCK) {
        if (ueberreizCheck (erg) != 0 && reizwert != 0) {
            erg = ueberreizCheck (erg);
        }
    }
    return erg;
}


public RecentFilesDialog (java.awt.Frame boss) {
    super (boss, rch.getString ("windowTitle"), true);
    props = new java.util.Properties ();
    getFiles ();
    getContentPane ().setLayout (new java.awt.BorderLayout ());
    okBut = new JButton (rch.getString ("okLabel"));
    okBut.addActionListener (this);
    getContentPane ().add ("South", okBut);
    fileList = new JList (files);
    fileList.setSelectedIndex (0);
    fileList.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
    getContentPane ().add ("Center", fileList);
    setLocationRelativeTo (boss);
    pack ();
}


-----Function Pair=77=-----==

public void evalScores (DataPoint x, Suite suite, double [] [] prob) {
    int ndis = suite.disCnt ();
    if (logLik.length < ndis) logLik = Arrays.copyOf (logLik, ndis);
    if (linLik.length < ndis) linLik = Arrays.copyOf (linLik, ndis);
    if (likCnt.length < ndis) likCnt = Arrays.copyOf (likCnt, ndis);
    for (int i = 0; i < ndis; i ++) {
        int r = suite.getDisc (i).claCount ();
        if (i == size ()) {
            ScoreEntry [] q = new ScoreEntry [r];
            for (int j = 0; j < r; j ++) q [j] = new ScoreEntry ();
            add (q);
        }
        else if (elementAt (i).length < r) {
            int r0 = elementAt (i).length;
            ScoreEntry [] q = Arrays.copyOf (elementAt (i), r);
            for (int j = r0; j < r; j ++) q [j] = new ScoreEntry ();
            set (i, q);
        }
    }
    Discrimination.Cla [] chosen = x.interpretScores (prob, suite);
    if (Suite.verbosity > 1) System.out.print ("Classifier assigned " + x.getName () + " to:");
    for (int did = 0; did < chosen.length; did ++) {
        ScoreEntry [] q = elementAt (did);
        if (chosen [did] == null) continue;
        int cpos = chosen [did].getPos ();
        q [cpos].chosenCnt ++;
        Discrimination dis = suite.getDisc (did);
        Discrimination.Cla trueC = x.claForDisc (dis);
        boolean correct = (chosen [did] == trueC);
        if (correct) {
            q [cpos].tpCnt ++;
        }
        if (Suite.verbosity > 1) System.out.print (" " + chosen [did] + (correct ? " (C)" : " (I);"));
    }
    for (Discrimination.Cla c : x.getClasses (suite)) {
        elementAt (suite.getDid (c)) [c.getPos ()].oracleCnt ++;
    }
    if (Suite.verbosity > 1) System.out.println ();
}


public void processMessage (int ch, int cmd, int data1, int data2) {
    synchronized (synth.control_mutex) {
        activity ();
    }
    if (cmd == 0xF0) {
        int status = cmd | ch;
        switch (status) {
            case ShortMessage.ACTIVE_SENSING :
                synchronized (synth.control_mutex) {
                    active_sensing_on = true;
                }
                break;
            default :
                break;
        }
        return;
    }
    SoftChannel [] channels = synth.channels;
    if (ch >= channels.length) return;
    SoftChannel softchannel = channels [ch];
    switch (cmd) {
        case ShortMessage.NOTE_ON :
            if (delay_midievent != 0) softchannel.noteOn (data1, data2, delay_midievent);
            else softchannel.noteOn (data1, data2);
            break;
        case ShortMessage.NOTE_OFF :
            softchannel.noteOff (data1, data2);
            break;
        case ShortMessage.POLY_PRESSURE :
            softchannel.setPolyPressure (data1, data2);
            break;
        case ShortMessage.CONTROL_CHANGE :
            softchannel.controlChange (data1, data2);
            break;
        case ShortMessage.PROGRAM_CHANGE :
            softchannel.programChange (data1);
            break;
        case ShortMessage.CHANNEL_PRESSURE :
            softchannel.setChannelPressure (data1);
            break;
        case ShortMessage.PITCH_BEND :
            softchannel.setPitchBend (data1 + data2 * 128);
            break;
        default :
            break;
    }
}


-----Function Pair=78=-----==

void removeGroupedInstance (String groupName, MudObject instance) {
    MudObject [] instances = (MudObject []) groupedInstances.get (groupName);
    if (instances != null) {
        if (instances.length == 1) {
            if (instances [0].equals (instance)) {
                groupedInstances.remove (groupName);
            }
        }
        else {
            int removalIndex = - 1;
            for (int i = 0; i < instances.length; i ++) {
                if (instances [i].equals (instance)) {
                    removalIndex = i;
                    break;
                }
            }
            if (removalIndex >= 0) {
                MudObject [] trimmedInstances = new MudObject [instances.length - 1];
                for (int i = 0; i < removalIndex; i ++) {
                    trimmedInstances [i] = instances [i];
                }
                for (int i = removalIndex; i < trimmedInstances.length; i ++) {
                    trimmedInstances [i] = instances [i + 1];
                }
                groupedInstances.put (groupName, trimmedInstances);
            }
        }
    }
}


public void read (byte [] bytes) {
    if (m_error != 0) return;
    for (int i = 0; i < bytes.length; i ++) {
        shiftFrame (bytes [i]);
        if (! isHeaderLeading ()) continue;
        Date recDate = new Date ();
        Vector framedata = new Vector (m_format.length ());
        int framepos = m_header.length;
        for (int j = 0; j < m_format.length (); j ++) {
            switch (m_format.charAt (j)) {
                case CHAR_8BIT_SIGNED :
                    framedata.add (new Character ((char) m_frame [framepos ++]));
                    break;
                case SHORT_16BIT_LITTLE_ENDIAN_SIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Short ((short) (a | (b << 8))));
                        break;
                    }
                case SHORT_16BIT_BIG_ENDIAN_SIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Short ((short) (b | (a << 8))));
                        break;
                    }
                case INT_32BIT_LITTLE_ENDIAN_SIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short c = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short d = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Integer (a | (b << 8) | (c << 16) | (d << 24)));
                        break;
                    }
                case INT_32BIT_BIG_ENDIAN_SIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short c = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short d = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Integer (d | (c << 8) | (b << 16) | (a << 24)));
                        break;
                    }
                case CHAR_8BIT_UNSIGNED :
                    framedata.add (new Character ((char) m_frame [framepos ++]));
                    break;
                case SHORT_16BIT_LITTLE_ENDIAN_UNSIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Short ((short) (a | (b << 8))));
                        break;
                    }
                case SHORT_16BIT_BIG_ENDIAN_UNSIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Short ((short) (b | (a << 8))));
                        break;
                    }
                case INT_32BIT_LITTLE_ENDIAN_UNSIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short c = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short d = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Integer (a | (b << 8) | (c << 16) | (d << 24)));
                        break;
                    }
                case INT_32BIT_BIG_ENDIAN_UNSIGNED :
                    {
                        short a = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short b = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short c = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        short d = (short) ((short) 0xFF & (short) m_frame [framepos ++]);
                        framedata.add (new Integer (d | (c << 8) | (b << 16) | (a << 24)));
                        break;
                    }
                default :
                    System.out.println ("PANIC: Encountered unknown symbol in frame format. Exiting");
                    System.exit (- 1);
            }
        }
        BTDataPacket dp = new BTDataPacket (recDate, framedata, m_sensorname, m_channels);
        setChanged ();
        notifyObservers (dp);
    }
}


-----Function Pair=79=-----==

public Client () {
    try {
        listeners = new HashSet < SGSClientListener > ();
        properties = new Hashtable < String, Object > ();
        setProperty (KEY_LOCALE, Locale.getDefault ());
        setProperty (KEY_LAF, UIManager.getCrossPlatformLookAndFeelClassName ());
        setProperty (KEY_SUPPORTED_LAF, new String [] {UIManager.getCrossPlatformLookAndFeelClassName (), UIManager.getSystemLookAndFeelClassName (), "com.sun.java.swing.plaf.motif.MotifLookAndFeel"});
        setProperty (KEY_UDP_LOGGED_IN, Boolean.FALSE);
        setProperty (KEY_SGS_LOGGED_IN, Boolean.FALSE);
        setProperty (KEY_IS_LOGGING_IN, Boolean.FALSE);
        setProperty (KEY_IS_QUERYING_CHANNEL, Boolean.FALSE);
        setProperty (KEY_IS_ENTERING_CHANNEL, Boolean.FALSE);
        Properties convs = new Properties ();
        convs.load (Client.class.getResourceAsStream (CONV_PROPS));
        Converter.getInstance ().load (convs);
        Properties procs = new Properties ();
        procs.load (Client.class.getResourceAsStream (PROC_PROPS));
        Processor.getInstance ().load (procs);
        udpSocket = new DatagramSocket ();
        info (logger, "datagram socket bound", udpSocket.getLocalSocketAddress ());
        networkSystem = new NetworkSystem (this);
        simpleClient = new SimpleClient (networkSystem.getSGSListener ());
        Manager man = Manager.getInstance ();
        properties.put (KEY_MIC, man.getMic ("Pcm", man.getAnyTargetDataLine ()));
        properties.put (KEY_ENC, man.getEncoder ("Speex"));
    } catch (Exception ex) {
        throwing (logger, "SGSClient", "(init)", ex, udpSocket);
    }
}


public void mouseClicked (MouseEvent e) {
    if (connect_btn.getLabel ().equals ("connect")) {
        listener.connect ();
        listener.login ();
        if (listener.getConnected ()) {
            connect_btn.setLabel ("disconnect");
            disconnected = false;
        }
    }
    else {
        textout.append ("\nDisconnecting..");
        listener.disconnect ();
        if (! listener.getConnected ()) {
            connect_btn.setLabel ("connect");
            disconnected = true;
            memberslist.removeAll ();
        }
    }
}


-----Function Pair=80=-----==

public int download () {
    FTPClient client = null;
    URL url = null;
    try {
        client = new FTPClient ();
        url = new URL (ratingsUrl);
        if (log.isDebugEnabled ()) log.debug ("Downloading " + url);
        client.connect (url.getHost ());
        int reply = client.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            if (log.isErrorEnabled ()) log.error ("Connection to " + url + " refused");
            return RESULT_CONNECTION_REFUSED;
        }
        if (log.isDebugEnabled ()) log.debug ("Logging in  l:" + getUserName () + " p:" + getPassword ());
        client.login (getUserName (), getPassword ());
        client.changeWorkingDirectory (url.getPath ());
        FTPFile [] files = client.listFiles (url.getPath ());
        if ((files == null) || (files.length != 1)) throw new FileNotFoundException ("No remote file");
        FTPFile remote = files [0];
        if (log.isDebugEnabled ()) log.debug ("Remote file data: " + remote);
        File local = new File (getOutputFile ());
        if (local.exists ()) {
            if ((local.lastModified () == remote.getTimestamp ().getTimeInMillis ())) {
                if (log.isDebugEnabled ()) log.debug ("File " + local.getAbsolutePath () + " is not changed on the server");
                return RESULT_NO_NEW_FILE;
            }
        }
        if (log.isDebugEnabled ()) log.debug ("Setting binary transfer modes");
        client.mode (FTPClient.BINARY_FILE_TYPE);
        client.setFileType (FTPClient.BINARY_FILE_TYPE);
        OutputStream fos = new FileOutputStream (local);
        boolean result = client.retrieveFile (url.getPath (), fos);
        if (log.isDebugEnabled ()) log.debug ("The transfer result is :" + result);
        fos.flush ();
        fos.close ();
        local.setLastModified (remote.getTimestamp ().getTimeInMillis ());
        if (result) uncompress ();
        if (result) return RESULT_OK;
        else return RESULT_TRANSFER_ERROR;
    } catch (MalformedURLException e) {
        return RESULT_ERROR;
    } catch (SocketException e) {
        return RESULT_ERROR;
    } catch (FileNotFoundException e) {
        return RESULT_ERROR;
    } catch (IOException e) {
        return RESULT_ERROR;
    } finally {
        if (client != null) {
            try {
                if (log.isDebugEnabled ()) log.debug ("Logging out");
                client.logout ();
            } catch (Exception e) {
            }
            try {
                if (log.isDebugEnabled ()) log.debug ("Disconnecting");
                client.disconnect ();
            } catch (Exception e) {
            }
        }
    }
}


private Document getMetaDocument () {
    final String METADATA_ELEMENT = "metadata";
    final String COLLECTION_ELEMENT = "collection";
    final String MEDIATYPE_ELEMENT = "mediatype";
    final String TITLE_ELEMENT = "title";
    final String DESCRIPTION_ELEMENT = "description";
    final String LICENSE_URL_ELEMENT = "licenseurl";
    final String UPLOAD_APPLICATION_ELEMENT = "upload_application";
    final String APPID_ATTR = "appid";
    final String APPID_ATTR_VALUE = "LimeWire";
    final String VERSION_ATTR = "version";
    final String UPLOADER_ELEMENT = "uploader";
    final String IDENTIFIER_ELEMENT = "identifier";
    final String TYPE_ELEMENT = "type";
    try {
        final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
        final DocumentBuilder db = dbf.newDocumentBuilder ();
        final Document document = db.newDocument ();
        final Element metadataElement = document.createElement (METADATA_ELEMENT);
        document.appendChild (metadataElement);
        final Element collectionElement = document.createElement (COLLECTION_ELEMENT);
        metadataElement.appendChild (collectionElement);
        collectionElement.appendChild (document.createTextNode (Archives.getCollectionString (getCollection ())));
        final Element mediatypeElement = document.createElement (MEDIATYPE_ELEMENT);
        metadataElement.appendChild (mediatypeElement);
        mediatypeElement.appendChild (document.createTextNode (Archives.getMediaString (getMedia ())));
        final Element typeElement = document.createElement (TYPE_ELEMENT);
        metadataElement.appendChild (typeElement);
        typeElement.appendChild (document.createTextNode (Archives.getTypeString (getType ())));
        final Element titleElement = document.createElement (TITLE_ELEMENT);
        metadataElement.appendChild (titleElement);
        titleElement.appendChild (document.createTextNode (getTitle ()));
        final Element descriptionElement = document.createElement (DESCRIPTION_ELEMENT);
        metadataElement.appendChild (descriptionElement);
        descriptionElement.appendChild (document.createTextNode (getDescription ()));
        final Element identifierElement = document.createElement (IDENTIFIER_ELEMENT);
        metadataElement.appendChild (identifierElement);
        identifierElement.appendChild (document.createTextNode (getIdentifier ()));
        final Element uploadApplicationElement = document.createElement (UPLOAD_APPLICATION_ELEMENT);
        metadataElement.appendChild (uploadApplicationElement);
        uploadApplicationElement.setAttribute (APPID_ATTR, APPID_ATTR_VALUE);
        uploadApplicationElement.setAttribute (VERSION_ATTR, CommonUtils.getLimeWireVersion ());
        final Element uploaderElement = document.createElement (UPLOADER_ELEMENT);
        metadataElement.appendChild (uploaderElement);
        uploaderElement.appendChild (document.createTextNode (getUsername ()));
        final Iterator filesIterator = getFiles ().iterator ();
        if (filesIterator.hasNext ()) {
            final ArchiveFile firstFile = (ArchiveFile) filesIterator.next ();
            final String licenseUrl = firstFile.getLicenseUrl ();
            if (licenseUrl != null) {
                final Element licenseUrlElement = document.createElement (LICENSE_URL_ELEMENT);
                metadataElement.appendChild (licenseUrlElement);
                licenseUrlElement.appendChild (document.createTextNode (licenseUrl));
            }
        }
        final Map userFields = getFields ();
        for (final Iterator i = userFields.keySet ().iterator (); i.hasNext ();) {
            final Object field = i.next ();
            final Object value = userFields.get (field);
            if (field instanceof String) {
                final Element e = document.createElement ((String) field);
                metadataElement.appendChild (e);
                if (value != null && value instanceof String) {
                    e.appendChild (document.createTextNode ((String) value));
                }
            }
        }
        return document;
    } catch (final ParserConfigurationException e) {
        final IllegalStateException ise = new IllegalStateException ();
        ise.initCause (e);
        throw ise;
    }
}


-----Function Pair=81=-----==

public Object construct () {
    try {
        listModel.removeAllElements ();
        results.repaint ();
        int listCount = 0;
        textPages.clear ();
        textRectangles.clear ();
        itemFoundCount = 0;
        decode_pdf.setFoundTextAreas (null);
        String textToFind = searchText.getText ();
        PdfPageData pageSize = decode_pdf.getPdfPageData ();
        int x1, y1, x2, y2;
        int startPage = 1;
        int endPage = commonValues.getPageCount () + 1;
        if (! searchAll.isSelected ()) {
            startPage = commonValues.getCurrentPage ();
            endPage = startPage + 1;
        }
        for (int i = startPage; i < endPage; i ++) {
            if (Thread.interrupted ()) throw new InterruptedException ();
            PdfGroupingAlgorithms currentGrouping = null;
            try {
                if (i == commonValues.getCurrentPage ()) currentGrouping = decode_pdf.getGroupingObject ();
                else {
                    decode_pdf.decodePageInBackground (i);
                    currentGrouping = decode_pdf.getBackgroundGroupingObject ();
                }
                currentGrouping.generateTeasers ();
                x1 = pageSize.getMediaBoxX (i);
                x2 = pageSize.getMediaBoxWidth (i);
                y1 = pageSize.getMediaBoxY (i);
                y2 = pageSize.getMediaBoxHeight (i);
                float [] co_ords = currentGrouping.findTextInRectangle (x1, y2, x2 + x1, y1, i, textToFind, false, true);
                float [] endPoints = currentGrouping.getEndPoints ();
                final String [] teasers = currentGrouping.getTeasers ();
                if (Thread.interrupted ()) throw new InterruptedException ();
                if ((co_ords != null) && (teasers != null)) {
                    itemFoundCount = itemFoundCount + teasers.length;
                    int count = co_ords.length, next = 0;
                    for (int ii = 0; ii < count; ii = ii + 2) {
                        int wx1 = (int) co_ords [ii];
                        int wy1 = (int) co_ords [ii + 1];
                        int wx2 = (int) endPoints [ii];
                        int wy2 = (int) endPoints [ii + 1];
                        final String tease = teasers [ii / 2];
                        Runnable setTextRun = new Runnable () {
                            public void run () {
                                listModel.addElement (tease);
                            }
                        }
                        ;
                        SwingUtilities.invokeAndWait (setTextRun);
                        Integer key = new Integer (listCount);
                        listCount ++;
                        textRectangles.put (key, new Rectangle (wx1, wy2, wx2 - wx1, wy1 - wy2));
                        textPages.put (key, new Integer (i));
                        next ++;
                    }
                }
                if ((co_ords != null) | ((i % 16) == 0)) {
                    searchCount.setText (Messages.getMessage ("PdfViewerSearch.ItemsFound") + " " + itemFoundCount + " " + Messages.getMessage ("PdfViewerSearch.Scanning") + i);
                    searchCount.invalidate ();
                    searchCount.repaint ();
                }
            } catch (PdfException e1) {
            }
        }
        searchCount.setText (Messages.getMessage ("PdfViewerSearch.ItemsFound") + " " + itemFoundCount + "  " + Messages.getMessage ("PdfViewerSearch.Done"));
        results.invalidate ();
        results.repaint ();
        isSearch = false;
        searchButton.setText (Messages.getMessage ("PdfViewerSearch.Button"));
    } catch (Exception e) {
    }
    return null;
}


public ResourcePanel () {
    setLayout (new BorderLayout (0, 0));
    JScrollPane scrollPane = new JScrollPane ();
    add (scrollPane, BorderLayout.CENTER);
    table = new JTable ();
    table.setModel (new ResourceList ());
    scrollPane.setViewportView (table);
    SMTSingleton.getSingletonInstance ().getCurrentSearch ().getTasks ().registerTaskListListener (this);
    JMenuBar menuBar = new JMenuBar ();
    add (menuBar, BorderLayout.NORTH);
    JMenu mnNewMenu = new JMenu ("Resources");
    menuBar.add (mnNewMenu);
    mnNewMenu.setMnemonic (KeyEvent.VK_R);
    JMenuItem mntmPrintTaskAssignments = new JMenuItem ("Print Operational Planning Worksheet (ICS 215)");
    mntmPrintTaskAssignments.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            Document document = new Document ();
            if ("A4".equals (SMTSingleton.getSingletonInstance ().getProperties ().getProperties ().get (SMTProperties.KEY_PAPERSIZE))) {
                document.setPageSize (PageSize.A4);
            }
            else {
                document.setPageSize (PageSize.LETTER);
            }
            try {
                String filename = "OperationalPlanningWorksheet_ICS-215.pdf";
                PdfWriter.getInstance (document, new FileOutputStream (filename));
                document.open ();
                ResourceList tasks = ((ResourceList) table.getModel ());
                tasks.writeToPdf (document);
                log.debug ("Printing: " + filename);
                document.close ();
            } catch (FileNotFoundException ex) {
                ex.printStackTrace ();
            } catch (DocumentException ex) {
                ex.printStackTrace ();
            }
        }
    }
    );
    mnNewMenu.add (mntmPrintTaskAssignments);
}


-----Function Pair=82=-----==

public static File toFile (URL url) {
    if (url == null || ! url.getProtocol ().equals ("file")) {
        return null;
    }
    else {
        String filename = url.getFile ().replace ('/', File.separatorChar);
        int pos = 0;
        while ((pos = filename.indexOf ('%', pos)) >= 0) {
            if (pos + 2 < filename.length ()) {
                String hexStr = filename.substring (pos + 1, pos + 3);
                char ch = (char) Integer.parseInt (hexStr, 16);
                filename = filename.substring (0, pos) + ch + filename.substring (pos + 3);
            }
        }
        return new File (filename);
    }
}


public static byte [] readFile (File file) throws Exception {
    if (! file.exists ()) {
        throw new FileNotFoundException ("File not found " + file.getName ());
    }
    long originalFileSize = file.length ();
    if (originalFileSize > Integer.MAX_VALUE) {
        throw new Exception ("The method supports files with maxsize of Integer.MAX_VALUE");
    }
    int fileSize = (int) originalFileSize;
    if (fileSize == 0) {
        return new byte [0];
    }
    FileInputStream fis = new FileInputStream (file);
    byte [] fileContent;
    try {
        fileContent = new byte [fileSize];
        fis.read (fileContent);
    } finally {
        fis.close ();
    }
    return fileContent;
}


-----Function Pair=83=-----==

public static void transformRedBookFiles () throws IOException {
    start = System.currentTimeMillis ();
    FileHandler handler = new FileHandler (PatiConstants.LOG_FILE_LOC + "RedbookTransformationErrorLog.log");
    LOG.addHandler (handler);
    LOG.setLevel (Level.FINE);
    XMLTransformation st = new XMLTransformation ();
    try {
        File folder = new File (PatiConstants.REDBOOK_OUTPUT_FOLDER);
        File [] listOfFiles = folder.listFiles (new FilenameFilter () {
            @Override
            public boolean accept (File dir, String name) {
                return name.matches ("\\d*");
            }
        }
        );
        for (File parentFolder : listOfFiles) {
            File subFolder = new File (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
            File [] listOfXMLFiles = subFolder.listFiles (new FilenameFilter () {
                @Override
                public boolean accept (File dir, String name) {
                    return name.endsWith (".xml");
                }
            }
            );
            for (File file : listOfXMLFiles) {
                String fileString = RedBookRenameFiles.fileToString (file);
                if (fileString.contains ("us-sequence-listing.dtd")) {
                    LOG.fine ("Sequence Listing XML File: " + file.getName ());
                    SL_COUNTER ++;
                }
                else if (fileString.contains (PatiConstants.DTD_V15)) {
                    COUNTER ++;
                    File sources = new File (PatiConstants.DTD_V15_RESOURCES);
                    copyTransformationResources (sources, subFolder);
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_CLAIMS_DTD_V15_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_CLM.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_ABST_DTD_V15_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_ABST.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_SPEC_DTD_V15_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_SPEC.xml"));
                    deleteTransformationResources (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
                    PASS_COUNTER ++;
                    PartNumberHandler.parsePartListNode (file.getAbsolutePath ().replace (".xml", "_SPEC.xml"));
                }
                else if (fileString.contains (PatiConstants.DTD_V16)) {
                    COUNTER ++;
                    File sources = new File (PatiConstants.DTD_V16_RESOURCES);
                    copyTransformationResources (sources, subFolder);
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_CLAIMS_DTD_V16_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_CLM.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_ABST_DTD_V16_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_ABST.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_SPEC_DTD_V16_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_SPEC.xml"));
                    deleteTransformationResources (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
                    PASS_COUNTER ++;
                    PartNumberHandler.parsePartListNode (file.getAbsolutePath ().replace (".xml", "_SPEC.xml"));
                }
                else if (fileString.contains (PatiConstants.DTD_V40)) {
                    COUNTER ++;
                    File sources = new File (PatiConstants.DTD_V40_RESOURCES);
                    copyTransformationResources (sources, subFolder);
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_CLAIMS_DTD_V40_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_CLM.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_ABST_DTD_V40_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_ABST.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_SPEC_DTD_V40_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_SPEC.xml"));
                    deleteTransformationResources (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
                    PASS_COUNTER ++;
                    PartNumberHandler.parsePartListNode (file.getAbsolutePath ().replace (".xml", "_SPEC.xml"));
                    ClaimDependencyHandler.addClaimDependencyAttribute (file.getAbsolutePath ().replace (".xml", "_CLM.xml"));
                }
                else if (fileString.contains (PatiConstants.DTD_V41)) {
                    COUNTER ++;
                    File sources = new File (PatiConstants.DTD_V41_RESOURCES);
                    copyTransformationResources (sources, subFolder);
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_CLAIMS_DTD_V41_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_CLM.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_ABST_DTD_V41_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_ABST.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_SPEC_DTD_V41_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_SPEC.xml"));
                    deleteTransformationResources (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
                    PASS_COUNTER ++;
                    PartNumberHandler.parsePartListNode (file.getAbsolutePath ().replace (".xml", "_SPEC.xml"));
                    ClaimDependencyHandler.addClaimDependencyAttribute (file.getAbsolutePath ().replace (".xml", "_CLM.xml"));
                }
                else if (fileString.contains (PatiConstants.DTD_V42)) {
                    COUNTER ++;
                    File sources = new File (PatiConstants.DTD_V42_RESOURCES);
                    copyTransformationResources (sources, subFolder);
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_CLAIMS_DTD_V42_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_CLM.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_ABST_DTD_V42_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_ABST.xml"));
                    st.transform (file.getAbsolutePath (), PatiConstants.IN_SPEC_DTD_V42_XSL, PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName () + "\\" + file.getName ().replace (".xml", "_SPEC.xml"));
                    deleteTransformationResources (PatiConstants.REDBOOK_OUTPUT_FOLDER + parentFolder.getName ());
                    PASS_COUNTER ++;
                    PartNumberHandler.parsePartListNode (file.getAbsolutePath ().replace (".xml", "_SPEC.xml"));
                    ClaimDependencyHandler.addClaimDependencyAttribute (file.getAbsolutePath ().replace (".xml", "_CLM.xml"));
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        FAIL_COUNTER ++;
    }
    LOG.fine (MessageFormat.format ("Generated {0} XML Documents", COUNTER * 3));
    LOG.fine (MessageFormat.format ("Applications processed: {0}", COUNTER));
    LOG.fine (MessageFormat.format ("Sequence listing counter: {0}", SL_COUNTER));
    LOG.fine (MessageFormat.format ("Application passed: {0}", PASS_COUNTER));
    LOG.fine (MessageFormat.format ("Applicaiton failed: {0}", FAIL_COUNTER));
    end = System.currentTimeMillis ();
    total = end - start;
    LOG.info ("Time taken to generate XML's is :" + total);
}


public boolean delFile (String filePathAndName) {
    boolean bea = false;
    try {
        String filePath = filePathAndName;
        File myDelFile = new File (filePath);
        if (myDelFile.exists ()) {
            myDelFile.delete ();
            bea = true;
        }
        else {
            bea = false;
            message = (filePathAndName + "ɾ���ļ���������");
        }
    } catch (Exception e) {
        message = e.toString ();
    }
    return bea;
}


-----Function Pair=84=-----==

public int getAllDataSize () {
    int size = 0;
    size += 4;
    int notesCount = 0;
    for (int i = 0; i < files.size (); i ++) {
        FileDescriptor fd = (FileDescriptor) files.elementAt (i);
        byte [] data = fd.toByteArray ();
        size += 4 + data.length;
        if (! fd.isDirectory) {
            notesCount ++;
        }
    }
    size += 4;
    for (int i = 0; i < files.size (); i ++) {
        FileDescriptor fd = (FileDescriptor) files.elementAt (i);
        if (fd.isDirectory) {
            continue;
        }
        Note note = MyNotes.fs.getNote (fd.id);
        if (note != null) {
            byte [] data = note.toByteArray ();
            size += 4 + data.length;
        }
    }
    return size;
}


private static List < String > getPathList (File f) {
    List < String > l = new ArrayList < String > ();
    File r;
    try {
        r = f.getCanonicalFile ();
        while (r != null) {
            l.add (r.getName ());
            r = r.getParentFile ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
        l = null;
    }
    return l;
}


-----Function Pair=85=-----==

private final void componentMouseClicked (final MouseEvent e) {
    final int index = this.rowAtPoint (e.getPoint ());
    final Object sobject = getSelectedValue ();
    if ((sobject == null) || ! (sobject instanceof DiskObject)) {
        clearSelection ();
        return;
    }
    final DiskObject selectedObject = (DiskObject) sobject;
    final File selectedFile = selectedObject.getFile ();
    if (SwingUtilities.isLeftMouseButton (e) && (e.getClickCount () == 2)) {
        if (JIUtility.isSupportedImage (selectedObject.getSuffix ())) {
            try {
                final OrderedDiskObjectList imageList = ((JIFileTableModel) getModel ()).getDiskObjectList ();
                imageList.setCurrentIndex (index);
                new JIViewer (imageList);
            } catch (final Exception de) {
                de.printStackTrace ();
                JOptionPane.showMessageDialog (this, de.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
        else if (selectedObject.getFile ().isDirectory ()) {
            JIExplorer.instance ().getJDirTree ().setSelectedDir (selectedObject);
        }
        e.consume ();
    }
}


private void initRelease () {
    if (release == null && reference != null) {
        File configDir = FileUtil.confirmDir (configFileDirPath, true);
        File releaseConfigFile = RemoteFileManager.getRemoteFile (reference, configDir, creds);
        if (logger.isDebugEnabled ()) logger.debug ("get release config :" + releaseConfigFile);
        if (releaseConfigFile.isFile ()) {
            try {
                SAXReader reader = new SAXReader ();
                Document doc = reader.read (releaseConfigFile);
                Element release = doc.getRootElement ();
                String releaseBaseURL = release.attributeValue ("base-url");
                releaseBaseURL = FileUtil.correctURIDirPath (releaseBaseURL);
                if (releaseBaseURL != null) this.baseURI = this.baseURI.resolve (releaseBaseURL);
                setReleaseElement (release);
            } catch (Exception e) {
                logger.error (e);
            }
        }
    }
}


-----Function Pair=86=-----==

public static boolean recursiveDelete (File file) {
    boolean success = true;
    if (file != null && file.exists ()) {
        if (file.isDirectory ()) {
            File [] files = file.listFiles ();
            if (files != null) {
                for (File child : files) {
                    recursiveDelete (child);
                }
            }
        }
        success = file.delete ();
    }
    return success;
}


public static File createZip (File srcFolder, File destFolder, String zipName, boolean compress) {
    Zip64File zipFile = null;
    if (! srcFolder.isDirectory ()) {
        log.severe ("[createZip] The File object you have passed is NOT a folder! Nothing has been done, sorry.");
        return null;
    }
    if (zipName == null) {
        zipName = srcFolder.getName ();
        log.info ("[createZip] No zipName specified, using folder name instead: " + zipName);
    }
    try {
        File newZip = new File (destFolder, zipName);
        zipFile = new Zip64File (newZip);
        List < String > listOfFiles = listAllFilesAndFolders (srcFolder, new ArrayList < String > ());
        if (listOfFiles.size () == 0) {
            log.info ("[createZip] Found no files to put in the zip. Created empty Zip file anyway...");
            zipFile.close ();
            return new File (zipFile.getDiskFile ().getFileName ());
        }
        log.info ("[createZip] Working on zipFile: " + zipFile.getDiskFile ().getFileName ());
        log.info ("[createZip] Normalizing paths...");
        List < String > normalizedPaths = normalizePaths (srcFolder);
        for (int i = 0; i < normalizedPaths.size (); i ++) {
            String currentZipEntryPath = normalizedPaths.get (i);
            FileEntry entry = new FileEntry (currentZipEntryPath);
            File currentFile = new File (listOfFiles.get (i));
            writeEntry (zipFile, entry, currentFile, compress);
        }
        log.info ("[createZip] All Files written to zip file: " + zipFile.getDiskFile ().getFileName ());
        zipFile.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return new File (zipFile.getDiskFile ().getFileName ());
}


-----Function Pair=87=-----==

public void actionPerformed (ActionEvent evt) {
    if (! isAnnotationEditorReady ()) {
        return;
    }
    annotationEditor.setEditingEnabled (false);
    boolean found = false;
    int start = - 1;
    int end = - 1;
    nextMatchStartsFrom = getOwner ().getTextComponent ().getCaretPosition ();
    while (matcher.find (nextMatchStartsFrom) && ! found) {
        start = (matcher.groupCount () > 0) ? matcher.start (1) : matcher.start ();
        end = (matcher.groupCount () > 0) ? matcher.end (1) : matcher.end ();
        found = false;
        if (searchHighlightsChk.isSelected ()) {
            javax.swing.text.Highlighter.Highlight [] highlights = getOwner ().getTextComponent ().getHighlighter ().getHighlights ();
            for (javax.swing.text.Highlighter.Highlight h : highlights) {
                if (h.getStartOffset () <= start && h.getEndOffset () >= end) {
                    found = true;
                    break;
                }
            }
        }
        else {
            found = true;
        }
        nextMatchStartsFrom = end;
    }
    if (found) {
        Vector < Integer > v = new Vector < Integer > (2);
        v.add (start);
        v.add (end);
        matchedIndexes.add (v);
        getOwner ().getTextComponent ().select (start, end);
        annotationEditor.placeDialog (start, end);
        findPreviousAction.setEnabled (true);
    }
    else {
        findNextAction.setEnabled (false);
        annotateMatchAction.setEnabled (false);
    }
}


public void setMethod (String name, String content) {
    content = modContentForIds (content);
    boolean found = false;
    for (Method m : methods) {
        if (m.name.equals (name)) {
            m.content = content;
            found = true;
        }
    }
    if (! found) {
        Method m = new Method ();
        m.name = name;
        m.content = content;
        methods.add (m);
        int idx = 1;
        for (Method d : methods) {
            d.id = idx;
            idx ++;
        }
        setMethod ("start", getDefaultRunner ());
    }
}


-----Function Pair=88=-----==

public void actionPerformed (ActionEvent evt) {
    if (! isAnnotationEditorReady ()) {
        return;
    }
    annotationEditor.setEditingEnabled (false);
    matchedIndexes.removeLast ();
    Vector < Integer > v;
    if (matchedIndexes.size () == 1) {
        findPreviousAction.setEnabled (false);
    }
    v = matchedIndexes.getLast ();
    int start = v.firstElement ();
    int end = v.lastElement ();
    getOwner ().getTextComponent ().select (start, end);
    annotationEditor.placeDialog (start, end);
    nextMatchStartsFrom = start;
    findNextAction.setEnabled (true);
    annotateMatchAction.setEnabled (true);
}


public void actionPerformed (ActionEvent ae) {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            thisInstance.setEnabled (false);
            try {
                searcher.next (((Number) numberOfResultsSpinner.getValue ()).intValue ());
            } catch (Exception e) {
                e.printStackTrace ();
                thisInstance.setEnabled (true);
            }
            processFinished ();
            pageOfResults ++;
            titleResults.setText ("Results - Page " + pageOfResults);
            thisInstance.setEnabled (true);
        }
    }
    );
}


-----Function Pair=89=-----==

private static JFreeChart createPieChart () {
    JFreeChart chart = ChartFactory.createPieChart (null, null, false, true, false);
    chart.setBackgroundPaint (Color.white);
    PiePlot plot = (PiePlot) chart.getPlot ();
    plot.setBackgroundPaint (null);
    plot.setInsets (RectangleInsets.ZERO_INSETS);
    plot.setInteriorGap (0.06);
    plot.setStartAngle (0.0);
    plot.setLabelGenerator (null);
    plot.setBaseSectionOutlinePaint (Color.white);
    plot.setBaseSectionOutlineStroke (new BasicStroke (1.2f, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND));
    plot.setOutlineVisible (false);
    plot.setLabelBackgroundPaint (null);
    plot.setLabelOutlinePaint (null);
    plot.setLabelShadowPaint (null);
    plot.setLabelPadding (RectangleInsets.ZERO_INSETS);
    plot.setLabelFont (new Font ("Dialog", Font.PLAIN, 12));
    plot.setLabelPaint (Color.gray);
    plot.setToolTipGenerator (new StandardPieToolTipGenerator ("{2}"));
    return chart;
}


public String getValidURL () {
    StringBuffer buffer = new StringBuffer ();
    buffer.append (jdbcProtocol);
    String val = getValue (descriptors [0].getName ());
    if ((descriptors [0].isRequired ()) || (val != null)) {
        buffer.append ("//");
        if (val != null) {
            buffer.append (val);
            val = getValue (descriptors [1].getName ());
            if ((descriptors [1].isRequired ()) || (val != null)) {
                buffer.append (":");
                if (val != null) buffer.append (val);
            }
            buffer.append ("/");
        }
    }
    val = getValue (descriptors [2].getName ());
    if (val != null) {
        buffer.append (val);
    }
    else {
        buffer.append ("???");
    }
    if (options.length () > 0) {
        buffer.append ("?");
        buffer.append (options);
    }
    return buffer.toString ();
}


-----Function Pair=90=-----==

private static void makeHeadings (List headings, StringBuffer toc, int parentLevel, String parentPrefix) {
    int cnt = 0;
    int currentLevel = - 1;
    String prefix = "";
    while (headings.size () > 0) {
        Object [] pair = (Object []) headings.get (0);
        int level = ((Integer) pair [0]).intValue ();
        if ((level > currentLevel) && (currentLevel >= 0)) {
            makeHeadings (headings, toc, currentLevel, prefix);
            continue;
        }
        else if (level < currentLevel) {
            if (parentLevel >= 0) {
                return;
            }
        }
        headings.remove (0);
        cnt ++;
        String label = (String) pair [1];
        if (parentPrefix.length () > 0) {
            prefix = parentPrefix + "." + cnt;
        }
        else {
            prefix = "" + cnt;
        }
        toc.append (StringUtil.repeat ("&nbsp;&nbsp;", level - 1));
        toc.append ("<a href=\"#" + label + "\">");
        toc.append (prefix);
        toc.append (HtmlUtil.space (1));
        toc.append (label);
        toc.append ("</a><br>\n");
        currentLevel = level;
    }
}


public static SubtitleFile parseSubtitleFile (String fileName) throws Exception {
    SubtitleParser sp = null;
    String input = FileIO.file2string (fileName);
    if (Utils.fileType (fileName) == 0) {
        sp = new SrtParser ();
        return sp.parse (input);
    }
    if (Utils.fileType (fileName) == 1) {
        sp = new SubParser ();
        return sp.parse (input);
    }
    if (Utils.fileType (fileName) == 2) {
        throw new Exception ("Invalid File Extension.");
    }
    return null;
}


-----Function Pair=91=-----==

public RestfulQuery validate (Database db) throws SQLException {
    DatabaseMetaInfo dbmi = db.getDatabaseMetaInfo ();
    for (int i = tables.size () - 1; i > - 1; i --) {
        final String table = tables.get (0);
        if (! dbmi.containsTable (table)) {
            tables.remove (i);
            if (i != 0) {
                joinOperations.remove (i - 1);
            }
            else {
                joinOperations.remove (0);
            }
        }
    }
    if (tables.isEmpty ()) {
        final SqlExceptionState state = SqlExceptionState.TABLES_DO_NOT_EXIST;
        throw new SQLException ("The request you made contains no valid tables.", state.name (), state.code ());
    }
    for (int i = columns.size () - 1; i > - 1; i --) {
        final String table = columns.get (i).getTable ();
        final String column = columns.get (i).getName ();
        final ResultSetMetaInfo rsmi = db.getResultSetMetaInfo (table);
        if (! dbmi.containsTable (table) || ! rsmi.containsColumn (column)) {
            columns.remove (i);
        }
    }
    if (columns.isEmpty ()) {
        if (boundedColumns.size () > 0) {
            final SqlExceptionState state = SqlExceptionState.COLUMNS_DO_NOT_EXIST;
            throw new SQLException ("The request you made contains no valid columns.", state.name (), state.code ());
        }
        else {
            for (int i = 0; i < tables.size (); i ++) {
                final String table = tables.get (i);
                final ResultSetMetaInfo rsmi = db.getResultSetMetaInfo (table);
                for (int j = 1; j <= rsmi.getColumnCount (); j ++) {
                    columns.add (new Column (table, rsmi.getColumn (j)));
                }
            }
        }
    }
    for (int i = filters.size () - 1; i > - 1; i --) {
        final String table = filters.get (i).getTable ();
        final String column = filters.get (i).getColumn ();
        final ResultSetMetaInfo rsmi = db.getResultSetMetaInfo (table);
        if (! dbmi.containsTable (table) || ! rsmi.containsColumn (column)) {
            filters.remove (i);
        }
    }
    for (int i = filterBoundaries.size () - 1; i > - 1; i --) {
        final String table = filterBoundaries.get (i).getTable ();
        final String column = filterBoundaries.get (i).getColumn ();
        final ResultSetMetaInfo rsmi = db.getResultSetMetaInfo (table);
        if (! dbmi.containsTable (table) || ! rsmi.containsColumn (column)) {
            filterBoundaries.remove (i);
        }
    }
    for (int i = orders.size () - 1; i > - 1; i --) {
        final String table = orders.get (i).getTable ();
        final String column = orders.get (i).getColumn ();
        final ResultSetMetaInfo rsmi = db.getResultSetMetaInfo (table);
        if (! dbmi.containsTable (table) || ! rsmi.containsColumn (column)) {
            orders.remove (i);
        }
    }
    return this;
}


public ArrayList < String [] > getLinkList () {
    if (! isNice ()) {
        return null;
    }
    StringBuilder tempcont = getContents ();
    if (tempcont == null) {
        return null;
    }
    long times = System.currentTimeMillis ();
    Pattern regexLink = Pattern.compile ("([^.<>]*)<\\s*[Aa]\\s+[^>]*[Hh][Rr][Ee][Ff]\\s*=([^>]*)>([^<>]*)<\\s*/\\s*[Aa]\\s*>([^.<>]*)");
    Pattern regexBase = Pattern.compile ("<\\s*[Bb][Aa][Ss][Ee]\\s+[^>]*[Hh][Rr][Ee][Ff]\\s*=\\s*[\"']?([^\"' >]+)[\"' >]");
    Matcher matcher;
    Matcher baseMatcher;
    matcher = regexLink.matcher (tempcont);
    ArrayList < String [] > temp_list = new ArrayList < String [] > ();
    int lastend = - 1;
    int streak = 0;
    int current = - 1;
    while (matcher.find ()) {
        String linkText = matcher.group (3);
        String linkAddr = getURLfromLink (matcher.group (2));
        String linkPre = matcher.group (1);
        String linkPost = matcher.group (4);
        if (matcher.start () == lastend) {
            linkPre = (temp_list.get (current)) [2] + (temp_list.get (current)) [1] + (temp_list.get (current)) [3];
            streak ++;
            for (int i = 0; i < streak; i ++) {
                String [] rewrite = temp_list.get (current - i);
                rewrite [3] += linkText + linkPost;
                temp_list.set (current - i, rewrite);
            }
        }
        else if (streak > 0) {
            String [] rewrite = temp_list.get (current);
            rewrite [3] += linkText + linkPost;
            temp_list.set (current, rewrite);
            streak = 0;
        }
        else {
            streak = 0;
        }
        current ++;
        lastend = matcher.end ();
        temp_list.add (new String [] {linkAddr, linkText, linkPre, linkPost});
    }
    String base = "none";
    baseMatcher = regexBase.matcher (tempcont);
    while (baseMatcher.find ()) {
        base = getURLfromLink (baseMatcher.group (1));
    }
    if (base.equals ("none")) {
        base = getAddress ();
    }
    URL baseURL = url;
    try {
        int delim = 0;
        for (delim = base.length () - 1; delim >= 0; delim --) {
            if (base.charAt (delim) == '/') {
                break;
            }
        }
        base = base.substring (0, delim);
        baseURL = new URL (base);
    } catch (Exception e) {
    }
    URL tester;
    String url2;
    addressList = new ArrayList < String [] > ();
    times = System.currentTimeMillis () - times;
    System.out.println ("  It took " + times + " millis to get link list from " + tempcont.length () + " characters");
    times = System.currentTimeMillis ();
    for (String [] urlInfo : temp_list) {
        if (urlInfo [0].length () >= 10 && urlInfo [0].substring (0, 10).equals ("javascript")) {
            continue;
        }
        if (urlInfo [0].length () == 0) {
            continue;
        }
        if (urlInfo [0].charAt (0) == '#') {
            continue;
        }
        if (urlInfo [0].length () > 0 && urlInfo [0].charAt (0) == '/') {
            url2 = noPath (baseURL.getProtocol (), baseURL.getHost (), baseURL.getPort ()) + noDirPath (urlInfo [0]);
        }
        else {
            url2 = urlInfo [0];
        }
        try {
            tester = new URL (url2);
            addressList.add (new String [] {tester.toString (), urlInfo [1], urlInfo [2], urlInfo [3]});
        } catch (MalformedURLException e1) {
            try {
                while (url2.length () > 0 && url2.charAt (0) == '/') {
                    url2 = url2.substring (1);
                }
                tester = new URL (noDirPath (baseURL.toExternalForm ()) + "/" + url2);
                addressList.add (new String [] {tester.toString (), urlInfo [1], urlInfo [2], urlInfo [3]});
            } catch (MalformedURLException e2) {
            }
        }
    }
    times = System.currentTimeMillis () - times;
    if (verbose) System.out.println ("It took " + times + " millis to populate link list from " + addressList.size () + " links in the list");
    return addressList;
}


-----Function Pair=92=-----==

public Component getTableCellRendererComponent (JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
    if (! value.equals ("remove")) {
        setIcon (null);
        setEnabled (false);
        return this;
    }
    setIcon (MainFrame.getIcon ("delete.gif"));
    setEnabled (true);
    if (isSelected && hasFocus) {
        setSelected (true);
        for (int row2 = row + 1; row2 < numShortcuts; row2 ++) {
            for (int col2 = 0; col2 < columnNames.length; col2 ++) {
                shortcuts [row2 - 1] [col2] = shortcuts [row2] [col2];
                if (row2 == numShortcuts - 1) {
                    shortcuts [row2] [col2] = null;
                }
            }
        }
        numShortcuts --;
        ((FeatureManagerTableModel) table.getModel ()).fireTableStructureChanged ();
    }
    return this;
}


private String parseAttribs (String string) {
    Pattern pattern = Pattern.compile ("(?s)(?i)(\\w+)=\"(.*?)\"");
    Matcher matcher = pattern.matcher (string);
    int lastend = 0;
    String output = "";
    while (matcher.find ()) {
        output += string.substring (lastend, matcher.start ());
        output += "<span class=\"texattrib\">";
        output += matcher.group (1) + "=";
        output += "</span>";
        output += "<span class=\"texvalue\">\"" + matcher.group (2) + "\"</span>";
        lastend = matcher.end ();
    }
    output += string.substring (lastend);
    return output;
}


-----Function Pair=93=-----==

public static String typeName (Datafield datafield) {
    DataType type = datafield.getDatatype ();
    switch (type.getValue ()) {
        case DataType.TEXT :
        case DataType.BLOCK :
        case DataType.CONTROL :
            return "String";
        case DataType.NUMERIC :
            if (datafield.getLineOrDecimalSize () > 0) return "BigDecimal";
            return "Integer";
        case DataType.DATE :
            return "Date";
        case DataType.STREAM :
            return "IStream";
        default :
            return "Object";
    }
}


protected LD getLD (Element ldElem) {
    if (ldElem != null && ldElem.getName ().equals ("LD")) {
        List content = ldElem.getChildren ();
        int size = content.size ();
        if (size > 0) {
            Hashtable < Integer, Rung > hashTable = new Hashtable < Integer, Rung > (size);
            Iterator iterator = content.iterator ();
            int count = 0;
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Rung rung = getRung (currentElement);
                hashTable.put (new Integer (count), rung);
                count ++;
            }
            LD ld = new LD (hashTable);
            return ld;
        }
        else {
            System.err.println ("Invalid child element size in getLD()");
            if (this.console != null) {
                console.setText ("Invalid child element size in getLD()");
            }
            return null;
        }
    }
    else {
        System.err.println ("Invalid element input in getLD()");
        if (this.console != null) {
            console.setText ("Invalid element input in getLD()");
        }
        return null;
    }
}


-----Function Pair=94=-----==

public Collection getAllUsers () throws DAOException {
    ArrayList users = new ArrayList ();
    try {
        StringBuffer sql = new StringBuffer ();
        this.acquire ();
        sql.append ("SELECT u.id ");
        sql.append (",u.login ");
        sql.append (",u.password ");
        sql.append (",p.Id ");
        sql.append (",p.Name ");
        sql.append (",p.First_Name ");
        sql.append (",p.Nick_Name ");
        sql.append (",p.Email ");
        sql.append (",p.Title ");
        sql.append (",p.Url ");
        sql.append (",p.Salutation ");
        sql.append (",p.Position ");
        sql.append (",p.Department ");
        sql.append (",p.Disability ");
        sql.append ("FROM ").append (DatabaseTableConstants.USER_TABLE).append (" u, ");
        sql.append (DatabaseTableConstants.PERSON_TABLE).append (" p ");
        sql.append ("WHERE u.Person_Id = p.Id");
        Statement statement = getConnection ().createStatement ();
        ResultSet result = statement.executeQuery (sql.toString ());
        while (result.next ()) {
            UserVo user = new UserVo ();
            PersonVo person = new PersonVo ();
            user.setId (new Integer (result.getInt (1)));
            user.setLogin (result.getString (2));
            user.setPassword (result.getString (3));
            person.setId (new Integer (result.getInt (4)));
            person.setName (result.getString (5));
            person.setFirstName (result.getString (6));
            person.setNickName (result.getString (7));
            person.setEmail (result.getString (8));
            person.setTitle (result.getString (9));
            person.setUrl (result.getString (10));
            person.setSalutation (result.getString (11));
            person.setPosition (result.getString (12));
            person.setDepartment (result.getString (13));
            person.setDisability (result.getString (14));
            user.setPerson (person);
            users.add (user);
        }
        statement.close ();
        result.close ();
    } catch (Exception e) {
        throw new DAOException ();
    } finally {
        try {
            this.release ();
        } catch (Exception e) {
            System.out.println ("Exception releasing connection !" + e.toString ());
        }
    }
    return users;
}


public Collection getCoursesByKeywordAndState (String keywords, Integer state) throws DAOException {
    ArrayList courses = new ArrayList ();
    boolean hasKeywords = false;
    try {
        StringBuffer sql = new StringBuffer ();
        this.acquire ();
        sql.append ("SELECT id ");
        sql.append ("FROM ").append (COURSE_TABLE);
        if (null != keywords && ! keywords.equals ("") && ! keywords.equals ("*") && ! keywords.startsWith ("&") && ! keywords.endsWith ("&") && ! keywords.startsWith (" ") && ! keywords.endsWith (" ")) {
            sql.append (" WHERE");
            hasKeywords = true;
            keywords = keywords.replace ('*', '%');
            Pattern p = Pattern.compile ("&");
            Matcher m = p.matcher (keywords);
            if (m.find ()) {
                String keyAnf = keywords.substring (0, m.start ()).trim ();
                String gross = keyAnf.substring (0, 1).toUpperCase () + keyAnf.substring (1, keyAnf.length ());
                String klein = keyAnf.substring (0, 1).toLowerCase () + keyAnf.substring (1, keyAnf.length ());
                if (keyAnf.length () >= 1) {
                    sql.append (" (Keywords like '").append (gross).append ("%'");
                    sql.append (" OR Title like '").append (gross).append ("%'");
                    sql.append (" OR Description like '").append (gross).append ("%'");
                    sql.append (" OR Keywords like '").append (klein).append ("%'");
                    sql.append (" OR Title like '").append (klein).append ("%'");
                    sql.append (" OR Description like '").append (klein).append ("%'");
                }
                else {
                    sql.append (" (Keywords like '%'");
                    sql.append (" OR Title like '%'");
                    sql.append (" OR Description like '%'");
                }
                keywords = keywords.substring (m.end (), keywords.length ()).trim ();
                m = p.matcher (keywords);
                while (m.find ()) {
                    keyAnf = keywords.substring (0, m.start ()).trim ();
                    if (keyAnf.length () >= 1) {
                        gross = keyAnf.substring (0, 1).toUpperCase () + keyAnf.substring (1, keyAnf.length ());
                        klein = keyAnf.substring (0, 1).toLowerCase () + keyAnf.substring (1, keyAnf.length ());
                        sql.append (" OR Keywords like '").append (gross).append ("%'");
                        sql.append (" OR Title like '").append (gross).append ("%'");
                        sql.append (" OR Description like '").append (gross).append ("%'");
                        sql.append (" OR Keywords like '").append (klein).append ("%'");
                        sql.append (" OR Title like '").append (klein).append ("%'");
                        sql.append (" OR Description like '").append (klein).append ("%'");
                    }
                    else {
                        sql.append (" OR Keywords like '%'");
                        sql.append (" OR Title like '%'");
                        sql.append (" OR Description like '%'");
                    }
                    keywords = keywords.substring (m.end (), keywords.length ()).trim ();
                    m = p.matcher (keywords);
                }
                if (keywords.length () >= 1) {
                    gross = keywords.substring (0, 1).toUpperCase () + keywords.substring (1, keywords.length ());
                    klein = keywords.substring (0, 1).toLowerCase () + keywords.substring (1, keywords.length ());
                    sql.append (" OR Keywords like '").append (gross).append ("%'");
                    sql.append (" OR Title like '").append (gross).append ("%'");
                    sql.append (" OR Description like '").append (gross).append ("%'");
                    sql.append (" OR Keywords like '").append (klein).append ("%'");
                    sql.append (" OR Title like '").append (klein).append ("%'");
                    sql.append (" OR Description like '").append (klein).append ("%')");
                }
                else {
                    sql.append (" OR Keywords like '%'");
                    sql.append (" OR Title like '%'");
                    sql.append (" OR Description like '%'");
                }
            }
            else {
                String gross = keywords.substring (0, 1).toUpperCase () + keywords.substring (1, keywords.length ());
                String klein = keywords.substring (0, 1).toLowerCase () + keywords.substring (1, keywords.length ());
                if (keywords.length () >= 1) {
                    sql.append (" (Keywords like '").append (gross).append ("%'");
                    sql.append (" OR Title like '").append (gross).append ("%'");
                    sql.append (" OR Description like '").append (gross).append ("%'");
                    sql.append (" OR Keywords like '").append (klein).append ("%'");
                    sql.append (" OR Title like '").append (klein).append ("%'");
                    sql.append (" OR Description like '").append (klein).append ("%')");
                }
                else {
                    sql.append (" (Keywords like '%'");
                    sql.append (" OR Title like '%'");
                    sql.append (" OR Description like '%'");
                }
            }
        }
        if (state != null) {
            if (! state.equals (new Integer (3))) {
                if (! hasKeywords) {
                    sql.append (" WHERE");
                }
                else {
                    sql.append (" AND");
                }
                sql.append (" Object_State = ").append (state);
            }
        }
        Statement statement = getConnection ().createStatement ();
        ResultSet result = statement.executeQuery (sql.toString ());
        while (result.next ()) {
            Integer id = new Integer (result.getInt (1));
            courses.add (id);
        }
        statement.close ();
        result.close ();
    } catch (SQLException e) {
        throw new DAOException ();
    } finally {
        try {
            this.release ();
        } catch (Exception e) {
            System.out.println ("Exception releasing connection !" + e.toString ());
        }
    }
    return courses;
}


-----Function Pair=95=-----=1=

public RealMatrix getR () {
    if (cachedR == null) {
        final int n = qrt.length;
        final int m = qrt [0].length;
        double [] [] ra = new double [m] [n];
        for (int row = FastMath.min (m, n) - 1; row >= 0; row --) {
            ra [row] [row] = rDiag [row];
            for (int col = row + 1; col < n; col ++) {
                ra [row] [col] = qrt [col] [row];
            }
        }
        cachedR = MatrixUtils.createRealMatrix (ra);
    }
    return cachedR;
}


public StudentDistanceMatrix (StudentDistance [] [] matrix) {
    int size = matrix.length;
    distanceMatrix = new StudentDistance [size] [size];
    for (int i = 0; i < size; i ++) {
        for (int j = i + 1; j < size; j ++) {
            if (matrix [i] [j] == null) throw new IllegalArgumentException ("Null element in matrix (" + i + "," + j + ")");
            else {
                distanceMatrix [i] [j] = matrix [i] [j];
                distanceMatrix [j] [i] = matrix [i] [j];
            }
        }
    }
    nameList = new ArrayList < String > ();
    nameList.add (matrix [0] [1].getNameA ());
    for (int j = 0 + 1; j < size; j ++) {
        nameList.add (matrix [0] [j].getNameB ());
    }
}


-----Function Pair=96=-----==

public static void readFile (String file) {
    try {
        BufferedReader inr = new BufferedReader (new FileReader (file));
        String str;
        int lineCount = 0;
        boolean gotData = false;
        ArrayList < Double [] > theData = new ArrayList < Double [] > ();
        while ((str = inr.readLine ()) != null) {
            lineCount ++;
            str = str.trim ();
            if (str.startsWith ("#") || str.startsWith ("%") || str.length () == 0) {
                continue;
            }
            if ("data".equals (str)) {
                gotData = true;
                continue;
            }
            if (gotData) {
                String [] dataRowStr = str.split ("[\\s,]+");
                int len = dataRowStr.length;
                Double [] dataRow = new Double [len];
                for (int i = 0; i < len; i ++) {
                    dataRow [i] = Double.parseDouble (dataRowStr [i]);
                }
                theData.add (dataRow);
            }
            else {
                if (str.contains (":")) {
                    String row [] = str.split (":\\s*");
                    if ("return_type".equals (row [0])) {
                        returnType = row [1];
                    }
                    else if ("presentation".equals (row [0])) {
                        presentation = row [1];
                    }
                    else if ("num_input_variables".equals (row [0])) {
                        numInputVariables = Integer.parseInt (row [1]);
                    }
                    else if ("num_rows".equals (row [0])) {
                        numRows = Integer.parseInt (row [1]);
                    }
                    else if ("terminal_range".equals (row [0])) {
                        String [] ranges = row [1].split ("\\s+");
                        lowerRange = Double.parseDouble (ranges [0]);
                        upperRange = Double.parseDouble (ranges [1]);
                    }
                    else if ("terminal_wholenumbers".equals (row [0])) {
                        terminalWholeNumbers = Boolean.parseBoolean (row [1]);
                    }
                    else if ("max_init_depth".equals (row [0])) {
                        maxInitDepth = Integer.parseInt (row [1]);
                    }
                    else if ("min_init_depth".equals (row [0])) {
                        minInitDepth = Integer.parseInt (row [1]);
                    }
                    else if ("program_creation_max_tries".equals (row [0])) {
                        programCreationMaxTries = Integer.parseInt (row [1]);
                    }
                    else if ("population_size".equals (row [0])) {
                        populationSize = Integer.parseInt (row [1]);
                    }
                    else if ("max_crossover_depth".equals (row [0])) {
                        maxCrossoverDepth = Integer.parseInt (row [1]);
                    }
                    else if ("function_prob".equals (row [0])) {
                        functionProb = Double.parseDouble (row [1]);
                    }
                    else if ("reproduction_prob".equals (row [0])) {
                        reproductionProb = Float.parseFloat (row [1]);
                    }
                    else if ("mutation_prob".equals (row [0])) {
                        mutationProb = Float.parseFloat (row [1]);
                    }
                    else if ("crossover_prob".equals (row [0])) {
                        crossoverProb = Double.parseDouble (row [1]);
                    }
                    else if ("dynamize_arity_prob".equals (row [0])) {
                        dynamizeArityProb = Float.parseFloat (row [1]);
                    }
                    else if ("new_chroms_percent".equals (row [0])) {
                        newChromsPercent = Double.parseDouble (row [1]);
                    }
                    else if ("num_evolutions".equals (row [0])) {
                        numEvolutions = Integer.parseInt (row [1]);
                    }
                    else if ("max_nodes".equals (row [0])) {
                        maxNodes = Integer.parseInt (row [1]);
                    }
                    else if ("bump".equals (row [0])) {
                        bumpPerfect = Boolean.parseBoolean (row [1]);
                    }
                    else if ("bump_value".equals (row [0])) {
                        bumpValue = Double.parseDouble (row [1]);
                    }
                    else if ("functions".equals (row [0])) {
                        functions = row [1].split ("[\\s,]+");
                    }
                    else if ("adf_functions".equals (row [0])) {
                        adfFunctions = row [1].split ("[\\s,]+");
                    }
                    else if ("variable_names".equals (row [0])) {
                        variableNames = row [1].split ("[\\s,]+");
                    }
                    else if ("output_variable".equals (row [0])) {
                        outputVariable = Integer.parseInt (row [1]);
                    }
                    else if ("ignore_variables".equals (row [0])) {
                        String [] ignoreVariablesS = row [1].split ("[\\s,]+");
                        ignoreVariables = new int [ignoreVariablesS.length];
                        for (int i = 0; i < ignoreVariablesS.length; i ++) {
                            ignoreVariables [i] = Integer.parseInt (ignoreVariablesS [i]);
                        }
                    }
                    else if ("constant".equals (row [0])) {
                        Double constant = Double.parseDouble (row [1]);
                        constants.add (constant);
                    }
                    else if ("adf_arity".equals (row [0])) {
                        adfArity = Integer.parseInt (row [1]);
                        System.out.println ("ADF arity " + adfArity);
                        if (adfArity > 0) {
                            useADF = true;
                        }
                    }
                    else if ("adf_type".equals (row [0])) {
                        adfType = row [1];
                    }
                    else if ("tournament_selector_size".equals (row [0])) {
                        tournamentSelectorSize = Integer.parseInt (row [1]);
                    }
                    else if ("scale_error".equals (row [0])) {
                        scaleError = Double.parseDouble (row [1]);
                    }
                    else if ("stop_criteria".equals (row [0])) {
                        stopCriteria = Double.parseDouble (row [1]);
                    }
                    else if ("show_population".equals (row [0])) {
                        showPopulation = Boolean.parseBoolean (row [1]);
                    }
                    else if ("show_similiar".equals (row [0])) {
                        showSimiliar = Boolean.parseBoolean (row [1]);
                    }
                    else {
                        System.out.println ("Unknown keyword: " + row [0] + " on line " + lineCount);
                        System.exit (1);
                    }
                }
            }
        }
        inr.close ();
        int r = theData.size ();
        int c = theData.get (0).length;
        int numIgnore = 0;
        if (ignoreVariables != null) {
            numIgnore = ignoreVariables.length;
        }
        Double [] [] dataTmp = new Double [r] [c];
        for (int i = 0; i < r; i ++) {
            Double [] this_row = theData.get (i);
            for (int j = 0; j < c; j ++) {
                dataTmp [i] [j] = this_row [j];
            }
        }
        data = transposeMatrix (dataTmp);
    } catch (IOException e) {
        System.out.println (e);
        System.exit (1);
    }
}


public static IDataGrid [] split (IDataGrid data, double [] splitWeights) throws Exception {
    if (data == null) return null;
    int numSplits = splitWeights.length;
    IDataGrid [] samples = new IDataGrid [numSplits];
    int [] sizes = new int [splitWeights.length];
    int [] offsets = new int [splitWeights.length];
    int i = 0, offset = 0;
    double sum = 0;
    log.debug ("splitting dataset with " + data.getNumRows () + " rows into " + splitWeights.length + " samples");
    for (i = 0; i < sizes.length; i ++) {
        sum += splitWeights [i];
        offsets [i] = offset;
        sizes [i] = (int) Math.round (data.getNumRows () * splitWeights [i]);
        log.debug ("Partition #" + i + " with size " + (i < sizes.length - 1 ? sizes [i] : data.getNumRows () - sizes [i] * i) + ", offset " + offsets [i]);
        offset += sizes [i];
        Vector < IColumn > cols = (Vector < IColumn >) data.getColumns ().clone ();
        samples [i] = new DataGrid ();
        samples [i].setColumns (cols);
    }
    NumberFormat fmt = NumberFormat.getInstance ();
    fmt.setMaximumFractionDigits (2);
    log.debug ("sum of weights: " + fmt.format (sum));
    if (! fmt.format (sum).equals (fmt.format (1.0))) throw new Exception ("Cannot Split dataset, Sum of weight != " + fmt.format (1.0) + " Sum==" + fmt.format (sum));
    int j = 0;
    log.debug ("fill new sample #" + j + " at row 0");
    for (i = 0; i < data.getNumRows (); i ++) {
        if (offsets [j] + sizes [j] <= i && j < sizes.length - 1) {
            log.debug ("sizes.length:" + sizes.length);
            j ++;
            log.debug ("fill new sample #" + j + " at row " + i);
        }
        try {
            samples [j].addRow (data.getRow (i));
        } catch (IndexOutOfBoundsException e) {
            e.printStackTrace ();
        } catch (TypeMismatchException e) {
            e.printStackTrace ();
        }
    }
    return samples;
}


-----Function Pair=97=-----==

void testAndCorrectNumerics () {
    if (getCountIter () > 1 || (getCountIter () == 1 && state >= 3)) if (fit.fitness [0].val == fit.fitness [Math.min (sp.getLambda () - 1, sp.getLambda () / 2 + 1) - 1].val) {
        warning ("flat fitness landscape, consider reformulation of fitness, step-size increased");
        sigma *= Math.exp (0.2 + sp.getCs () / sp.getDamps ());
    }
    double fac = 1;
    if (math.max (diagD) < 1e-6) fac = 1./ math.max (diagD);
    else if (math.min (diagD) > 1e4) fac = 1./ math.min (diagD);
    if (fac != 1.) {
        sigma /= fac;
        for (int i = 0; i < N; ++ i) {
            pc [i] *= fac;
            diagD [i] *= fac;
            for (int j = 0; j <= i; ++ j) C [i] [j] *= fac * fac;
        }
    }
}


public void blendSurface (MeshGesture average, MeshGesture p [], double weight []) {
    super.blendSurface (average, p, weight);
    SplineMeshKeyframe avg = (SplineMeshKeyframe) average;
    for (int i = 0; i < weight.length; i ++) {
        SplineMeshKeyframe key = (SplineMeshKeyframe) p [i];
        for (int j = 0; j < usmoothness.length; j ++) avg.usmoothness [j] += weight [i] * (key.usmoothness [j] - usmoothness [j]);
        for (int j = 0; j < vsmoothness.length; j ++) avg.vsmoothness [j] += weight [i] * (key.vsmoothness [j] - vsmoothness [j]);
    }
    for (int i = 0; i < avg.usmoothness.length; i ++) {
        if (avg.usmoothness [i] < 0.0) avg.usmoothness [i] = 0.0f;
        if (avg.usmoothness [i] > 1.0) avg.usmoothness [i] = 1.0f;
    }
    for (int i = 0; i < avg.vsmoothness.length; i ++) {
        if (avg.vsmoothness [i] < 0.0) avg.vsmoothness [i] = 0.0f;
        if (avg.vsmoothness [i] > 1.0) avg.vsmoothness [i] = 1.0f;
    }
}


-----Function Pair=98=-----==

public DoubleMatrix subtract (final DoubleMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawSubtract (m);
        default :
            if (numRows == m.rows () && numCols == m.columns ()) {
                final double array [] [] = new double [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    array [i] [0] = matrix [i] [0] - m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) array [i] [j] = matrix [i] [j] - m.getElement (i, j);
                }
                return new DoubleSquareMatrix (array);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


-----Function Pair=99=-----==

private Instances setOutputFormatOriginal () throws Exception {
    FastVector attributes = new FastVector ();
    for (int i = 0; i < m_numAttribs; i ++) {
        String att = m_trainInstances.attribute (i).name ();
        attributes.addElement (new Attribute (att));
    }
    if (m_hasClass) {
        attributes.addElement (m_trainCopy.classAttribute ().copy ());
    }
    Instances outputFormat = new Instances (m_trainCopy.relationName () + "->PC->original space", attributes, 0);
    if (m_hasClass) {
        outputFormat.setClassIndex (outputFormat.numAttributes () - 1);
    }
    return outputFormat;
}


public static final void Compute_EFI (List D, int numIntervalos, int numClases, int numCortes, int [] [] acumulados) {
    int [] acum = new int [acumulados [0].length];
    for (int i = 0; i < acum.length; i ++) {
        for (int c = 0; c < numClases; c ++) acum [i] += acumulados [c] [i];
        if (i > 0) acum [i] += acum [i - 1];
    }
    long total = acum [acum.length - 1];
    int pos_act = 0;
    for (int vuelta = 1; vuelta < numIntervalos; vuelta ++) {
        double t;
        t = vuelta * ((double) total) / numIntervalos;
        long valor = (int) t;
        do {
            pos_act ++;
        }
        while (acum [pos_act] < valor);
        D.add (new Integer (pos_act + 1));
        pos_act --;
    }
}


-----Function Pair=100=-----==

public boolean isSkewSymmetric () throws IllegalArgumentException {
    if (! this.isQuadratic ()) {
        throw new IllegalArgumentException ("Matrix must be quadratic");
    }
    else {
        for (int ni = 0; ni < this.N; ni ++) {
            for (int mi = 0; mi < this.M; mi ++) {
                if (mi == ni) {
                    continue;
                }
                else if (this.Data [mi] [ni] != - this.Data [ni] [mi]) {
                    return false;
                }
            }
        }
        return true;
    }
}


private boolean nextPossibleNoise (int [] possibleNoise, int [] lowPossibleNoise, int [] hihPossibleNoise) {
    boolean possible = false;
    if (possibleNoise [0] == - 2) {
        for (int i = 0; i < possibleNoise.length; i ++) {
            if (hihPossibleNoise [i] != - 1) {
                possibleNoise [i] = lowPossibleNoise [i];
                possible = true;
            }
        }
    }
    else {
        for (int i = possibleNoise.length - 1; i >= 0; i --) {
            if (hihPossibleNoise [i] != - 1) {
                possibleNoise [i] ++;
                if (possibleNoise [i] <= hihPossibleNoise [i]) {
                    i = - 1;
                    possible = true;
                }
                else {
                    possibleNoise [i] = lowPossibleNoise [i];
                }
            }
        }
    }
    return possible;
}


-----Function Pair=101=-----==

public void initQuantumJpegChromin () {
    int quality = QUALITY;
    if (quality < 50) {
        quality = 5000 / quality;
    }
    else {
        quality = 200 - quality * 2;
    }
    for (int i = 0; i < NJPEG; i ++) {
        for (int j = 0; j < NJPEG; j ++) {
            if (quality != 0) {
                Quantum [i] [j] = (JPEG_CHROMIN_QUANT_TBL [i] [j] * quality + 50) / 100;
            }
            else {
                Quantum [i] [j] = JPEG_CHROMIN_QUANT_TBL [i] [j];
            }
        }
    }
}


private List < Taxon > readTaxaBlock () throws ImportException, IOException {
    taxonCount = 0;
    readDataBlockHeader ("TAXLABELS", NexusBlock.TAXA);
    if (taxonCount == 0) {
        throw new ImportException.MissingFieldException ("NTAXA");
    }
    List < Taxon > taxa = new ArrayList < Taxon > ();
    do {
        String name = helper.readToken (";");
        if (name.equals ("")) {
            throw new ImportException.UnknownTaxonException ("Expected nonempty taxon name, got empty string");
        }
        Taxon taxon = Taxon.getTaxon (name);
        taxa.add (taxon);
        parseAndClearMetaComments (taxon, helper);
    }
    while (helper.getLastDelimiter () != ';');
    if (taxa.size () != taxonCount) {
        throw new ImportException.BadFormatException ("Number of taxa doesn't match NTAXA field");
    }
    findEndBlock ();
    return taxa;
}


-----Function Pair=102=-----==

public static final float [] [] getElevation_8 (boolean withSnow) {
    int len = 8;
    float [] [] elev_8 = new float [3] [len];
    elev_8 [0] [0] = 0.0f;
    elev_8 [1] [0] = (float) 162 / 255.0f;
    elev_8 [2] [0] = (float) 119 / 255.0f;
    elev_8 [0] [1] = (float) 70 / 255.0f;
    elev_8 [1] [1] = (float) 170 / 255.0f;
    elev_8 [2] [1] = (float) 130 / 255.0f;
    elev_8 [0] [2] = (float) 145 / 255.0f;
    elev_8 [1] [2] = (float) 192 / 255.0f;
    elev_8 [2] [2] = (float) 146 / 255.0f;
    elev_8 [0] [3] = (float) 241 / 255.0f;
    elev_8 [1] [3] = (float) 226 / 255.0f;
    elev_8 [2] [3] = (float) 174 / 255.0f;
    elev_8 [0] [4] = (float) 228 / 255.0f;
    elev_8 [1] [4] = (float) 202 / 255.0f;
    elev_8 [2] [4] = (float) 143 / 255.0f;
    elev_8 [0] [5] = (float) 203 / 255.0f;
    elev_8 [1] [5] = (float) 172 / 255.0f;
    elev_8 [2] [5] = (float) 107 / 255.0f;
    elev_8 [0] [6] = (float) 179 / 255.0f;
    elev_8 [1] [6] = (float) 140 / 255.0f;
    elev_8 [2] [6] = (float) 66 / 255.0f;
    if (withSnow) {
        elev_8 [0] [7] = (float) 1.0f;
        elev_8 [1] [7] = (float) 1.0f;
        elev_8 [2] [7] = (float) 1.0f;
    }
    else {
        elev_8 [0] [7] = (float) 160 / 255.0f;
        elev_8 [1] [7] = (float) 130 / 255.0f;
        elev_8 [2] [7] = (float) 62 / 255.0f;
    }
    return elev_8;
}


public void mouseDragged (MouseEvent e) {
    if (lastPressedButtonWas != MouseEvent.BUTTON1) {
        return;
    }
    int w = getWidth () - rightMargin;
    double diff_x_dat = zoomMaxComp1 - zoomMinComp1;
    double diff_x_scr = w;
    double xpos = zoomMinComp1 + diff_x_dat * e.getX () / diff_x_scr;
    int h = getHeight ();
    double diff_y_dat = zoomMaxComp2 - zoomMinComp2;
    double diff_y_scr = h;
    double ypos = (zoomMinComp2 + diff_y_dat * (double) (h - e.getY ()) / diff_y_scr);
    if (selectionFirstClickComp1 == - 1) {
        selectionFirstClickComp1 = xpos;
        selectionFirstClickComp2 = ypos;
    }
    else {
        selectionLastClickComp1 = xpos;
        selectionLastClickComp2 = ypos;
        if (selectionLastClickComp1 < zoomMinComp1) {
            selectionLastClickComp1 = zoomMinComp1;
        }
        if (selectionLastClickComp1 > (zoomMaxComp1)) {
            selectionLastClickComp1 = zoomMaxComp1;
        }
        if (selectionLastClickComp2 < zoomMinComp2) {
            selectionLastClickComp2 = zoomMinComp2;
        }
        if (selectionLastClickComp2 > zoomMaxComp2) {
            selectionLastClickComp2 = zoomMaxComp2;
        }
        if (selectionLastClickComp1 > selectionFirstClickComp1) {
            mouseAreaStartComp1 = selectionFirstClickComp1;
            mouseAreaEndComp1 = selectionLastClickComp1;
        }
        else {
            mouseAreaStartComp1 = selectionLastClickComp1;
            mouseAreaEndComp1 = selectionFirstClickComp1;
        }
        if (selectionLastClickComp2 > selectionFirstClickComp2) {
            mouseAreaStartComp2 = selectionFirstClickComp2;
            mouseAreaEndComp2 = selectionLastClickComp2;
        }
        else {
            mouseAreaStartComp2 = selectionLastClickComp2;
            mouseAreaEndComp2 = selectionFirstClickComp2;
        }
        zoomToSelectionMenuItem.setEnabled (true);
        repaint ();
    }
    statBar.setStatusText ("");
}


-----Function Pair=103=-----==

public void resize (int rows, int columns) {
    if (rows < 0 || columns < 0) throw new IllegalArgumentException ();
    if (this.rows == rows && this.columns == columns) return;
    if (this.rows >= rows && this.columns >= columns) {
        this.rows = rows;
        this.columns = columns;
        return;
    }
    double newSelf [] [] = new double [rows] [columns];
    for (int i = 0; i < this.rows; i ++) {
        System.arraycopy (self [i], 0, newSelf [i], 0, this.columns);
    }
    this.rows = rows;
    this.columns = columns;
    self = newSelf;
}


public static double [] [] getMinor (double [] [] mat, int row, int col) {
    int dim = mat [0].length - 1;
    double [] [] minor = new double [dim] [dim];
    int minor_row = 0;
    int minor_col = 0;
    for (int a = 0; a <= dim; a ++) {
        if ((row - 1) != a) {
            for (int b = 0; b <= dim; b ++) {
                if ((col - 1) != b) {
                    minor [minor_row] [minor_col] = mat [a] [b];
                    minor_col ++;
                }
            }
            minor_row ++;
            minor_col = 0;
        }
    }
    return minor;
}


-----Function Pair=104=-----==

public Instances transformedData (Instances data) throws Exception {
    if (m_eigenvalues == null) {
        throw new Exception ("Principal components hasn't been built yet");
    }
    Instances output = null;
    if (m_transBackToOriginal) {
        output = new Instances (m_originalSpaceFormat);
    }
    else {
        output = new Instances (m_transformedFormat);
    }
    for (int i = 0; i < data.numInstances (); i ++) {
        Instance converted = convertInstance (data.instance (i));
        output.add (converted);
    }
    return output;
}


public static void main (String [] argv) {
    PrintStream out = System.out;
    try {
        if (argv.length == 0) {
            System.out.println (" Syntax: java HCL infile.dat ");
            System.out.println (" Input file format: ");
            System.out.println (" Line 1: integer no. rows, no. cols.");
            System.out.println (" Successive lines: matrix values, floating");
            System.out.println (" Read in row-wise");
            System.exit (1);
        }
        String filname = argv [0];
        System.out.println (" Input file name: " + filname);
        FileInputStream is = new FileInputStream (filname);
        BufferedReader bis = new BufferedReader (new InputStreamReader (is));
        StreamTokenizer st = new StreamTokenizer (bis);
        st.nextToken ();
        int nrow = (int) st.nval;
        st.nextToken ();
        int ncol = (int) st.nval;
        System.out.println (" No. of rows, nrow = " + nrow);
        System.out.println (" No. of cols, ncol = " + ncol);
        double [] [] indat = new double [nrow] [ncol];
        double inval;
        System.out.println (" Input data sample follows as a check, first 4 values.");
        for (int i = 0; i < nrow; i ++) {
            for (int j = 0; j < ncol; j ++) {
                st.nextToken ();
                inval = (double) st.nval;
                indat [i] [j] = inval;
                if (i < 2 && j < 2) {
                    System.out.println (" value = " + inval);
                }
            }
        }
        System.out.println ();
        int [] [] clusters = new int [nrow] [nrow];
        int [] nn = new int [nrow];
        int [] flag = new int [nrow];
        double [] nndiss = new double [nrow];
        double [] clcard = new double [nrow];
        double [] mass = new double [nrow];
        double [] cpoids = new double [ncol];
        int minobs;
        double mindist;
        int ncl;
        ncl = nrow;
        for (int i = 0; i < nrow; i ++) {
            flag [i] = 1;
            clcard [i] = 1.0;
            mass [i] = 1.0;
        }
        for (int j = 0; j < ncol; j ++) {
            cpoids [j] = 0.0;
        }
        double [] [] diss = new double [nrow] [nrow];
        diss = dissim (nrow, ncol, mass, indat);
        System.out.println ("Dissimilarity matrix for analysis:");
        printMatrix (nrow, nrow, diss, 4, 10);
        getNNs (nrow, flag, diss, nn, nndiss);
        int clust1 = 0;
        int clust2 = 0;
        int cl1 = 0;
        int cl2 = 0;
        clustMat (nrow, clusters, clust1, clust2, ncl);
        do {
            minobs = - 1;
            mindist = MAXVAL;
            for (int i = 0; i < nrow; i ++) {
                if (flag [i] == 1) {
                    if (nndiss [i] < mindist) {
                        mindist = nndiss [i];
                        minobs = i;
                    }
                }
            }
            if (minobs < nn [minobs]) {
                clust1 = minobs + 1;
                clust2 = nn [minobs];
            }
            if (minobs > nn [minobs]) {
                clust2 = minobs + 1;
                clust1 = nn [minobs];
            }
            System.out.println (" clus#1: " + clust1 + ";  clus#2: " + clust2 + ";  new card: " + (clcard [clust1 - 1] + clcard [clust2 - 1]) + "; # clus left: " + ncl + "; mindiss: " + mindist);
            ncl = ncl - 1;
            clustMat (nrow, clusters, clust1, clust2, ncl);
            cl1 = clust1 - 1;
            cl2 = clust2 - 1;
            for (int i = 0; i < nrow; i ++) {
                if ((i != cl1) && (i != cl2) && (flag [i] == 1)) {
                    diss [cl1] [i] = (mass [cl1] + mass [i]) / (mass [cl1] + mass [cl2] + mass [i]) * diss [cl1] [i] + (mass [cl2] + mass [i]) / (mass [cl1] + mass [cl2] + mass [i]) * diss [cl2] [i] - (mass [i]) / (mass [cl1] + mass [cl2] + mass [i]) * diss [cl1] [cl2];
                    diss [i] [cl1] = diss [cl1] [i];
                }
            }
            clcard [cl1] = clcard [cl1] + clcard [cl2];
            mass [cl1] = mass [cl1] + mass [cl2];
            for (int i = 0; i < nrow; i ++) {
                diss [cl2] [i] = MAXVAL;
                diss [i] [cl2] = diss [cl2] [i];
                flag [cl2] = 0;
                nndiss [cl2] = MAXVAL;
                mass [cl2] = 0;
            }
            getNNs (nrow, flag, diss, nn, nndiss);
        }
        while (ncl > 1);
        int [] [] tclusters = new int [nrow] [nrow];
        for (int i1 = 0; i1 < nrow; i1 ++) {
            for (int i2 = 0; i2 < nrow; i2 ++) {
                tclusters [i2] [i1] = clusters [i1] [i2];
            }
        }
        printMatrix (nrow, nrow, tclusters, 4, 4);
    } catch (IOException e) {
        out.println ("error: " + e);
        System.exit (1);
    }
}


-----Function Pair=105=-----==

private Instances setOutputFormatOriginal () throws Exception {
    FastVector attributes = new FastVector ();
    for (int i = 0; i < m_numAttribs; i ++) {
        String att = m_trainInstances.attribute (i).name ();
        attributes.addElement (new Attribute (att));
    }
    if (m_hasClass) {
        attributes.addElement (m_trainHeader.classAttribute ().copy ());
    }
    Instances outputFormat = new Instances (m_trainHeader.relationName () + "->PC->original space", attributes, 0);
    if (m_hasClass) {
        outputFormat.setClassIndex (outputFormat.numAttributes () - 1);
    }
    return outputFormat;
}


public static double logPdf (Matrix W, Matrix Sinv, double df, int dim, double logNormalizationConstant) {
    double logDensity = 0;
    try {
        if (! W.isPD ()) return Double.NEGATIVE_INFINITY;
        final double det = W.determinant ();
        if (det <= 0) {
            return Double.NEGATIVE_INFINITY;
        }
        logDensity = Math.log (det);
        logDensity *= 0.5;
        logDensity *= df - dim - 1;
        if (Sinv != null) {
            Matrix product = Sinv.product (W);
            for (int i = 0; i < dim; i ++) logDensity -= 0.5 * product.component (i, i);
        }
    } catch (IllegalDimension illegalDimension) {
        illegalDimension.printStackTrace ();
    }
    logDensity += logNormalizationConstant;
    return logDensity;
}


-----Function Pair=106=-----==

public static double [] [] dissim (int nrow, int ncol, double [] mass, double [] [] A) {
    double [] [] Adiss = new double [nrow] [nrow];
    for (int i1 = 0; i1 < nrow; i1 ++) {
        for (int i2 = 0; i2 < nrow; i2 ++) {
            Adiss [i1] [i2] = 0.0;
        }
    }
    for (int i1 = 0; i1 < nrow; i1 ++) {
        for (int i2 = 0; i2 < i1; i2 ++) {
            for (int j = 0; j < ncol; j ++) {
                Adiss [i1] [i2] += 0.5 * Math.pow (A [i1] [j] - A [i2] [j], 2.0);
            }
            Adiss [i2] [i1] = Adiss [i1] [i2];
        }
    }
    return Adiss;
}


public static LImage drawClipImage (final LImage image, int objectWidth, int objectHeight, int x1, int y1, int x2, int y2, Config config) {
    if (image == null) {
        return null;
    }
    if (objectWidth > image.getWidth ()) {
        objectWidth = image.getWidth ();
    }
    if (objectHeight > image.getHeight ()) {
        objectHeight = image.getHeight ();
    }
    Bitmap bitmap = Bitmap.createBitmap (objectWidth, objectHeight, config);
    canvas.setBitmap (bitmap);
    canvas.drawBitmap (image.getBitmap (), new Rect (x1, y1, x2, y2), new Rect (0, 0, objectWidth, objectHeight), null);
    if (objectWidth == objectHeight && objectWidth <= 48 && objectHeight <= 48) {
        return filterBitmapTo565 (bitmap, objectWidth, objectHeight);
    }
    return new LImage (bitmap);
}


-----Function Pair=107=-----==

protected JFreeChart createChart (XYDataset dataset) {
    JFreeChart chart = ChartFactory.createXYLineChart (chartTitle, domainLabel, rangeLabel, dataset, PlotOrientation.HORIZONTAL, ! legendPanelOn, true, false);
    chart.setBackgroundPaint (Color.white);
    XYPlot plot = (XYPlot) chart.getPlot ();
    plot.setBackgroundPaint (Color.lightGray);
    plot.setAxisOffset (new RectangleInsets (5.0, 5.0, 5.0, 5.0));
    plot.setDomainGridlinePaint (Color.white);
    plot.setRangeGridlinePaint (Color.white);
    XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) plot.getRenderer ();
    renderer.setBaseShapesVisible (true);
    renderer.setBaseShapesFilled (true);
    NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis ();
    rangeAxis.setStandardTickUnits (NumberAxis.createIntegerTickUnits ());
    return chart;
}


public float Determinant () {
    float [] [] matrix = this.matrix;
    if (INFO) {
        System.out.println ("Getting Determinant...");
    }
    int tms = matrix.length;
    float det = 1;
    matrix = UpperTriangle (matrix);
    for (int i = 0; i < tms; i ++) {
        det = det * matrix [i] [i];
    }
    det = det * iDF;
    if (INFO) {
        System.out.println ("Determinant: " + det);
    }
    return det;
}


-----Function Pair=108=-----==

public static int [] getUniqueItems (int [] data) {
    int [] uniqueItems = null;
    try {
        Set < Integer > classes = new HashSet < Integer > ();
        for (int i = 0; i < data.length; i ++) {
            classes.add (data [i]);
        }
        uniqueItems = new int [classes.size ()];
        Iterator < Integer > classesIt = classes.iterator ();
        int i = 0;
        while (classesIt.hasNext ()) {
            uniqueItems [i ++] = classesIt.next ().intValue ();
        }
    } catch (Exception e) {
        logger.severe (e.getCause ().toString () + " : " + e.toString () + " : " + e.getMessage ());
        e.printStackTrace ();
        uniqueItems = new int [0];
    }
    return uniqueItems;
}


public static void main (String [] argv) {
    WishartDistribution wd = new WishartDistribution (2, new double [] [] {{500.0}});
    GammaDistribution gd = new GammaDistribution (1.0 / 1000.0, 1000.0);
    double [] x = new double [] {1.0};
    System.out.println ("Wishart, df=2, scale = 500, PDF(1.0): " + wd.logPdf (x));
    System.out.println ("Gamma, shape = 1/1000, scale = 1000, PDF(1.0): " + gd.logPdf (x [0]));
    wd = new WishartDistribution (4, new double [] [] {{5.0}});
    gd = new GammaDistribution (2.0, 10.0);
    x = new double [] {1.0};
    System.out.println ("Wishart, df=4, scale = 5, PDF(1.0): " + wd.logPdf (x));
    System.out.println ("Gamma, shape = 1/1000, scale = 10, PDF(1.0): " + gd.logPdf (x [0]));
    wd = new WishartDistribution (1);
    x = new double [] {0.1};
    System.out.println ("Wishart, uninformative, PDF(0.1): " + wd.logPdf (x));
    x = new double [] {1.0};
    System.out.println ("Wishart, uninformative, PDF(1.0): " + wd.logPdf (x));
    x = new double [] {10.0};
    System.out.println ("Wishart, uninformative, PDF(10.0): " + wd.logPdf (x));
    testBivariateMethod ();
}


-----Function Pair=109=-----==

public ZnMatrix taylor (int exponent) {
    if (! isSquare ()) {
        throw new ArithmeticException ("Matrix is not square.");
    }
    ZnMatrix m = null;
    if (exponent < 0) {
        exponent *= - 1;
        m = inverse ();
    }
    else {
        m = this;
    }
    ZnMatrix n = new ZnMatrix (rows, columns, modulus);
    n.setToUnitMatrix ();
    for (int i = 1, fac = 1; i <= exponent; i ++, fac *= i) {
        n = n.sum (m.power (i)).scaled (NumberTheory.divideMod (1, fac, modulus));
    }
    return n;
}


public static IDataGrid doubleArrayToGrid (double [] [] da) {
    IDataGrid grid = new DataGrid ();
    int rows = da.length;
    int cols = da [0].length;
    IColumn col;
    for (int j = 0; j < cols; j ++) {
        col = new Column ();
        col.setType (Double.class);
        col.setLabel (Integer.toString (j));
        grid.addColumn (col);
    }
    IDataRow row;
    try {
        for (int i = 0; i < rows; i ++) {
            row = new DataRow ();
            row.setColumns (grid.getColumns ());
            for (int j = 0; j < cols; j ++) {
                row.setPoint (j, Double.valueOf (da [i] [j]));
            }
            grid.addRow (row);
        }
    } catch (IndexOutOfBoundsException e) {
        e.printStackTrace ();
    } catch (TypeMismatchException e) {
        e.printStackTrace ();
    }
    return grid;
}


-----Function Pair=110=-----=1=

public LiferaySQL (String sql) {
    System.out.println (sql);
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        Properties props = new Properties ();
        try {
            props.load (new FileInputStream (new File ("db.properties")));
        } catch (IOException ioe) {
            ioe.printStackTrace ();
            return;
        }
        String driver = props.getProperty ("driver");
        String url = props.getProperty ("url");
        String user = props.getProperty ("user");
        String password = props.getProperty ("password");
        Class.forName (driver);
        con = DriverManager.getConnection (url, user, password);
        con.setAutoCommit (false);
        File sqlFile = new File (sql);
        if (sqlFile.exists ()) {
            StringBuffer sb = new StringBuffer ();
            BufferedReader br = new BufferedReader (new FileReader (sqlFile));
            String line = null;
            while ((line = br.readLine ()) != null) {
                if (! line.startsWith ("--")) {
                    sb.append (line);
                }
            }
            br.close ();
            StringTokenizer st = new StringTokenizer (sb.toString (), ";");
            while (st.hasMoreTokens ()) {
                line = st.nextToken ();
                System.out.println (line + ";");
                ps = con.prepareStatement (line);
                ps.executeUpdate ();
            }
        }
        else if (sql.toLowerCase ().startsWith ("insert ") || sql.toLowerCase ().startsWith ("update ")) {
            ps = con.prepareStatement (sql);
            ps.executeUpdate (sql);
        }
        else {
            ps = con.prepareStatement (sql);
            rs = ps.executeQuery (sql);
            ResultSetMetaData rsmd = rs.getMetaData ();
            int [] width = new int [rsmd.getColumnCount () + 1];
            StringBuffer sb = new StringBuffer ();
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                width [i] = rsmd.getColumnLabel (i).length ();
            }
            List results = new ArrayList ();
            while (rs.next ()) {
                String [] rowResult = new String [rsmd.getColumnCount () + 1];
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    Object obj = rs.getObject (i);
                    if (obj != null) {
                        rowResult [i] = obj.toString ();
                        int objWidth = obj.toString ().length ();
                        if (width [i] < objWidth) {
                            width [i] = objWidth;
                        }
                    }
                    else {
                        rowResult [i] = "";
                    }
                }
                results.add (rowResult);
            }
            _printLine (rsmd, width, sb);
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                String label = rsmd.getColumnLabel (i);
                sb.append ("| ").append (label);
                for (int j = 0; j <= width [i] - label.length (); j ++) {
                    sb.append (" ");
                }
            }
            sb.append ("|\n");
            _printLine (rsmd, width, sb);
            Iterator itr = results.iterator ();
            while (itr.hasNext ()) {
                String [] rowResult = (String []) itr.next ();
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    String s = rowResult [i];
                    sb.append ("| ").append (s);
                    for (int j = 0; j <= width [i] - s.length (); j ++) {
                        sb.append (" ");
                    }
                }
                sb.append ("|\n");
            }
            _printLine (rsmd, width, sb);
            System.out.println (sb.toString ());
        }
        con.commit ();
    } catch (SQLException sqle) {
        while (sqle != null) {
            sqle.printStackTrace ();
            sqle = sqle.getNextException ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        _cleanUp (con, ps, rs);
    }
}


public LiferaySQL (String sql) {
    System.out.println (sql);
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        Properties props = new Properties ();
        try {
            props.load (new FileInputStream (new File ("db.properties")));
        } catch (IOException ioe) {
            ioe.printStackTrace ();
            return;
        }
        String driver = props.getProperty ("driver");
        String url = props.getProperty ("url");
        String user = props.getProperty ("user");
        String password = props.getProperty ("password");
        Class.forName (driver);
        con = DriverManager.getConnection (url, user, password);
        con.setAutoCommit (false);
        File sqlFile = new File (sql);
        if (sqlFile.exists ()) {
            StringBuffer sb = new StringBuffer ();
            BufferedReader br = new BufferedReader (new FileReader (sqlFile));
            String line = null;
            while ((line = br.readLine ()) != null) {
                if (! line.startsWith ("--")) {
                    sb.append (line);
                }
            }
            br.close ();
            StringTokenizer st = new StringTokenizer (sb.toString (), ";");
            while (st.hasMoreTokens ()) {
                line = st.nextToken ();
                System.out.println (line + ";");
                ps = con.prepareStatement (line);
                ps.executeUpdate ();
            }
        }
        else if (sql.toLowerCase ().startsWith ("insert ") || sql.toLowerCase ().startsWith ("update ")) {
            ps = con.prepareStatement (sql);
            ps.executeUpdate (sql);
        }
        else {
            ps = con.prepareStatement (sql);
            rs = ps.executeQuery (sql);
            ResultSetMetaData rsmd = rs.getMetaData ();
            int [] width = new int [rsmd.getColumnCount () + 1];
            StringBuffer sb = new StringBuffer ();
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                width [i] = rsmd.getColumnLabel (i).length ();
            }
            List results = new ArrayList ();
            while (rs.next ()) {
                String [] rowResult = new String [rsmd.getColumnCount () + 1];
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    Object obj = rs.getObject (i);
                    if (obj != null) {
                        rowResult [i] = obj.toString ();
                        int objWidth = obj.toString ().length ();
                        if (width [i] < objWidth) {
                            width [i] = objWidth;
                        }
                    }
                    else {
                        rowResult [i] = "";
                    }
                }
                results.add (rowResult);
            }
            _printLine (rsmd, width, sb);
            for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                String label = rsmd.getColumnLabel (i);
                sb.append ("| ").append (label);
                for (int j = 0; j <= width [i] - label.length (); j ++) {
                    sb.append (" ");
                }
            }
            sb.append ("|\n");
            _printLine (rsmd, width, sb);
            Iterator itr = results.iterator ();
            while (itr.hasNext ()) {
                String [] rowResult = (String []) itr.next ();
                for (int i = 1; i <= rsmd.getColumnCount (); i ++) {
                    String s = rowResult [i];
                    sb.append ("| ").append (s);
                    for (int j = 0; j <= width [i] - s.length (); j ++) {
                        sb.append (" ");
                    }
                }
                sb.append ("|\n");
            }
            _printLine (rsmd, width, sb);
            System.out.println (sb.toString ());
        }
        con.commit ();
    } catch (SQLException sqle) {
        while (sqle != null) {
            sqle.printStackTrace ();
            sqle = sqle.getNextException ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        _cleanUp (con, ps, rs);
    }
}


-----Function Pair=111=-----==

byte addAnswer (Message response, Name name, int type, int dclass, int iterations, int flags) {
    SetResponse sr;
    byte rcode = Rcode.NOERROR;
    if (iterations > 6) return Rcode.NOERROR;
    if (type == Type.SIG) {
        type = Type.ANY;
        flags |= FLAG_SIGONLY;
    }
    Zone zone = findBestZone (name);
    if (zone != null) sr = zone.findRecords (name, type);
    else {
        Cache cache = getCache (dclass);
        sr = cache.lookupRecords (name, type, Credibility.NORMAL);
    }
    if (sr.isUnknown ()) {
        addCacheNS (response, getCache (dclass), name);
    }
    if (sr.isNXDOMAIN ()) {
        response.getHeader ().setRcode (Rcode.NXDOMAIN);
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        rcode = Rcode.NXDOMAIN;
    }
    else if (sr.isNXRRSET ()) {
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
    }
    else if (sr.isDelegation ()) {
        RRset nsRecords = sr.getNS ();
        addRRset (nsRecords.getName (), response, nsRecords, Section.AUTHORITY, flags);
    }
    else if (sr.isCNAME ()) {
        RRset rrset = new RRset ();
        CNAMERecord cname = sr.getCNAME ();
        rrset.addRR (cname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, cname.getTarget (), type, dclass, iterations + 1, flags);
    }
    else if (sr.isDNAME ()) {
        RRset rrset = new RRset ();
        DNAMERecord dname = sr.getDNAME ();
        rrset.addRR (dname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        Name newname;
        try {
            newname = name.fromDNAME (dname);
        } catch (NameTooLongException e) {
            return Rcode.YXDOMAIN;
        }
        rrset = new RRset ();
        rrset.addRR (new CNAMERecord (name, dclass, 0, newname));
        addRRset (name, response, rrset, Section.ANSWER, flags);
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, newname, type, dclass, iterations + 1, flags);
    }
    else if (sr.isSuccessful ()) {
        RRset [] rrsets = sr.answers ();
        for (int i = 0; i < rrsets.length; i ++) addRRset (name, response, rrsets [i], Section.ANSWER, flags);
        if (zone != null) {
            addNS (response, zone, flags);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        else addCacheNS (response, getCache (dclass), name);
    }
    return rcode;
}


private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=112=-----==

public static void ReadConfig () {
    try {
        String tmp;
        BufferedReader config = new BufferedReader (new FileReader ("JavaNZB.config"));
        tmp = config.readLine ();
        JavaNZB.hellaQueueDir = tmp.substring (9, tmp.length ());
        tmp = config.readLine ();
        JavaNZB.newzbinUsr = tmp.substring (16, tmp.length ());
        tmp = config.readLine ();
        JavaNZB.newzbinPass = tmp.substring (16, tmp.length ());
        config.close ();
    } catch (IOException e) {
        System.out.println ("IO Exception from config file");
    }
}


byte [] generateReply (Message query, byte [] in, int length, Socket s) throws IOException {
    Header header;
    boolean badversion;
    int maxLength;
    boolean sigonly;
    SetResponse sr;
    int flags = 0;
    header = query.getHeader ();
    if (header.getFlag (Flags.QR)) return null;
    if (header.getRcode () != Rcode.NOERROR) return errorMessage (query, Rcode.FORMERR);
    if (header.getOpcode () != Opcode.QUERY) return errorMessage (query, Rcode.NOTIMP);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (tsig == null || tsig.verify (query, in, length, null) != Rcode.NOERROR) return formerrMessage (in);
    }
    OPTRecord queryOPT = query.getOPT ();
    if (queryOPT != null && queryOPT.getVersion () > 0) badversion = true;
    if (s != null) maxLength = 65535;
    else if (queryOPT != null) maxLength = Math.max (queryOPT.getPayloadSize (), 512);
    else maxLength = 512;
    if (queryOPT != null && (queryOPT.getFlags () & ExtendedFlags.DO) != 0) flags = FLAG_DNSSECOK;
    Message response = new Message (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.QR);
    if (query.getHeader ().getFlag (Flags.RD)) response.getHeader ().setFlag (Flags.RD);
    response.addRecord (queryRecord, Section.QUESTION);
    Name name = queryRecord.getName ();
    int type = queryRecord.getType ();
    int dclass = queryRecord.getDClass ();
    if (type == Type.AXFR && s != null) return doAXFR (name, query, tsig, queryTSIG, s);
    if (! Type.isRR (type) && type != Type.ANY) return errorMessage (query, Rcode.NOTIMP);
    byte rcode = addAnswer (response, name, type, dclass, 0, flags);
    if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage (query, rcode);
    addAdditional (response, flags);
    if (queryOPT != null) {
        int optflags = (flags == FLAG_DNSSECOK) ? ExtendedFlags.DO : 0;
        OPTRecord opt = new OPTRecord ((short) 4096, rcode, (byte) 0, optflags);
        response.addRecord (opt, Section.ADDITIONAL);
    }
    response.setTSIG (tsig, Rcode.NOERROR, queryTSIG);
    return response.toWire (maxLength);
}


-----Function Pair=113=-----==

void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


private void readFromCommandline () {
    BufferedReader l_input = new BufferedReader (new InputStreamReader (System.in));
    String l_message = new String ();
    String l_tempString = new String ();
    int l_targetPlayer = - 1;
    while (m_commandLineReading) {
        System.out.print ("\nType help for help \n>");
        try {
            l_message = l_input.readLine ();
        } catch (Exception ex) {
            logger.severe ("Exception caught in JaisTeam::readFromCommandline:" + ex.getMessage ());
        }
        if (l_message.equalsIgnoreCase ("Exit") || l_message.equalsIgnoreCase ("E")) {
            m_commandLineReading = false;
            for (ListIterator it = m_playerList.listIterator (); it.hasNext ();) {
                Jais l_tempJais = (Jais) it.next ();
                l_tempJais.quit ();
            }
        }
        else if (l_message.equalsIgnoreCase ("help")) System.out.println ("\nCommands are:" + "\n[Playernumber] visualization [ON | OFF]" + "\n[Playernumber] reconnect" + "\n[Playernumber] exit for kicking one player" + "\n\"Exit\" for exiting the game");
        else {
            StringTokenizer l_tokenizer = new StringTokenizer (l_message);
            try {
                l_targetPlayer = Integer.parseInt (l_tokenizer.nextToken ());
                if (! (l_targetPlayer > 0 && l_targetPlayer <= m_numberOfPlayers)) System.out.println ("No such Player! (1..n)");
                else {
                    l_tempString = "";
                    while (l_tokenizer.hasMoreTokens ()) l_tempString += " " + l_tokenizer.nextToken ();
                    ((Jais) m_playerList.get (l_targetPlayer - 1)).parseKbInfo (l_tempString);
                    logger.finest ("Parsed \"" + l_tempString + "\" to Player " + l_targetPlayer + "\n");
                }
            } catch (Exception ex) {
                System.out.println ("Didn't understand your command. Please retry (" + ex + ")\n");
            }
        }
    }
}


-----Function Pair=114=-----==

public static void main (String [] args) {
    if (args.length > 1) {
        System.out.println ("usage: jnamed [conf]");
        System.exit (0);
    }
    jnamed s;
    try {
        String conf;
        if (args.length == 1) conf = args [0];
        else conf = "jnamed.conf";
        s = new jnamed (conf);
    } catch (IOException e) {
        System.out.println (e);
    } catch (ZoneTransferException e) {
        System.out.println (e);
    }
}


void setIndexes () {
    String tmpl = "", tkn;
    if (NAGIOS_VERSION == 1) {
        tmpl = getNagiosParameter ("xpdfile_service_perfdata_template");
    }
    else {
        tmpl = getNagiosParameter ("service_perfdata_file_template");
    }
    StringTokenizer tokens = new StringTokenizer (tmpl, "\\t");
    COUNT_INDEXES = tokens.countTokens ();
    for (int i = 0; i < COUNT_INDEXES; i ++) {
        tkn = tokens.nextToken ();
        if (tkn.equals ("$TIMET$")) {
            TIME_INDEX = i;
        }
        if (tkn.equals ("$HOSTNAME$")) {
            HOST_INDEX = i;
        }
        if (tkn.equals ("$SERVICEDESC$")) {
            SVC_INDEX = i;
        }
        if (tkn.equals ("$SERVICEPERFDATA$") || tkn.equals ("$PERFDATA$")) {
            PERF_INDEX = i;
        }
    }
}


-----Function Pair=115=-----==

public static void RL_set_random_seed (int rsk) throws IOException {
    try {
        file.write ("RLsetrandom\n");
        file.flush ();
        file.write (rsk + "\n");
        file.flush ();
        buf = br.readLine ();
        while (buf == null) buf = br.readLine ();
        if (! (buf.trim ()).equals ("done")) RL_cleanup ();
    } catch (Throwable e) {
        System.err.println ("ERROR: in RL_set_random_seed!");
        System.err.println ("Random key types may be invalid. RL-Framework supports \nInt, \nDouble, \nInt Array, \nDouble Array \nfor Random key type when using pipe communication. \nExiting...\n");
        e.printStackTrace ();
    }
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=116=-----==

String getNagiosParameter (String sToken) {
    String retval = "", line;
    StringBuffer config = parseConfig (NAG_CONFIG);
    BufferedReader br = new BufferedReader (new StringReader (config.toString ()));
    try {
        while (((line = br.readLine ()) != null) && (retval == "")) {
            StringTokenizer tokens = new StringTokenizer (line, "=");
            while (tokens.hasMoreTokens ()) {
                if (tokens.nextToken ().trim ().equals (sToken)) {
                    retval = tokens.nextToken ().trim ();
                    break;
                }
            }
        }
    } catch (Exception ex) {
        System.out.println (ex);
    }
    return (retval);
}


public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (r, section);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (r2, section);
            }
            return removed;
        }
    }
    return removed;
}


-----Function Pair=117=-----==

public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (section, r);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (section, r2);
            }
            return removed;
        }
    }
    return removed;
}


public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (r, section);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (r2, section);
            }
            return removed;
        }
    }
    return removed;
}


-----Function Pair=118=-----==

public static void copyFile (File source, File destination) {
    if (! source.exists ()) {
        return;
    }
    if ((destination.getParentFile () != null) && (! destination.getParentFile ().exists ())) {
        destination.getParentFile ().mkdirs ();
    }
    try {
        FileChannel srcChannel = new FileInputStream (source).getChannel ();
        FileChannel dstChannel = new FileOutputStream (destination).getChannel ();
        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());
        srcChannel.close ();
        dstChannel.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


public static boolean saveBufferToStream (ByteBuffer buffer, OutputStream fos) throws IOException {
    if (buffer == null) {
        String message = Logging.getMessage ("nullValue.BufferNull");
        Logging.logger ().severe (message);
        throw new IllegalArgumentException (message);
    }
    if (fos == null) {
        String message = Logging.getMessage ("nullValue.FileIsNull");
        Logging.logger ().severe (message);
        throw new IllegalArgumentException (message);
    }
    WritableByteChannel channel;
    try {
        channel = Channels.newChannel (fos);
        for (buffer.rewind (); buffer.hasRemaining ();) {
            channel.write (buffer);
        }
        fos.flush ();
        return true;
    } finally {
        WWIO.closeStream (fos, null);
    }
}


-----Function Pair=119=-----==

public void testTruncateEndFile () throws Exception {
    File logDir = prepareLogDir ("testTruncateEndFile");
    DiskLog log = openLog (logDir, false, 3000);
    writeEventsToLog (log, 200);
    log.validate ();
    log.release ();
    String [] logFiles = log.getLogFileNames ();
    String lastLogName = logFiles [logFiles.length - 1];
    File lastLog = new File (logDir, lastLogName);
    logger.info ("Deleting last log: " + lastLog.getAbsolutePath ());
    assertTrue ("Delete last log: " + lastLogName, lastLog.delete ());
    DiskLog log2 = openLog (logDir, false, 3000);
    LogConnection conn1 = log2.connect (true);
    conn1.seek (0);
    long maxSeqnoNonBlocking = - 1;
    THLEvent e;
    while ((e = conn1.next (false)) != null) {
        maxSeqnoNonBlocking = e.getSeqno ();
    }
    logger.info ("Non-blocking reads find " + maxSeqnoNonBlocking + " events");
    assertTrue ("Found more than 0 events", maxSeqnoNonBlocking > 0);
    conn1.release ();
    LogConnection conn2 = log2.connect (true);
    conn2.setTimeoutMillis (500);
    conn2.seek (0);
    long maxSeqnoBlocking = - 1;
    try {
        while (maxSeqnoBlocking <= maxSeqnoNonBlocking) {
            e = conn2.next (true);
            maxSeqnoBlocking = e.getSeqno ();
        }
        throw new Exception ("Read failed to time out on missing log file after rotation");
    } catch (LogTimeoutException ex) {
        logger.info ("Read timed out as expected: " + ex.getMessage ());
    }
    logger.info ("Blocking reads find " + maxSeqnoBlocking + " events");
    assertEquals ("Blocking and non-blocking find same number of reads", maxSeqnoNonBlocking, maxSeqnoBlocking);
    conn2.release ();
    long startSeqno = maxSeqnoNonBlocking + 1;
    writeEventsToLog (log2, startSeqno, 300);
    log2.validate ();
    readBackStoredEvents (log2, 0, 300);
    log2.release ();
}


private static void checkTempGames (long cutoff) throws InternalErrorException {
    try {
        File dir = new File (getTemporaryDirectory ());
        File [] games = dir.listFiles ();
        for (int i = 0; i < games.length; i ++) {
            long modtime = games [i].lastModified ();
            if (modtime < cutoff) {
                if (games [i].isDirectory ()) {
                    File [] delfiles = games [i].listFiles ();
                    int errcount = 0;
                    for (int j = 0; j < delfiles.length; j ++) {
                        if (! delfiles [j].delete ()) errcount ++;
                    }
                    if (! games [i].delete ()) errcount ++;
                    if (errcount > 0) {
                        SystemLog.warning ("Unable to delete temporary game " + games [i].getAbsolutePath ());
                    }
                }
                else {
                    if (games [i].getName ().equals (LAST_GAME_FILE_NAME)) games [i].delete ();
                }
            }
        }
    } catch (Exception e) {
        InternalErrorException iee = new InternalErrorException (e);
        throw iee;
    }
}


-----Function Pair=120=-----==

public String [] zoekIdentiekVoorkomen (String inhoud) {
    String [] retString = null;
    if (inhoud == null) {
        System.out.println ("Meegegeven inhoud is null.");
    }
    try {
        IndexSearcher indexSearcher = new IndexSearcher (Settings.getIndexdir ());
        Analyzer analyzer = new StandardAnalyzer ();
        QueryParser qparser = new QueryParser ("fullcontent", analyzer);
        String inhoudQuery = "fullcontent:\"" + inhoud + "\"";
        Query query = qparser.parse (inhoudQuery);
        Hits hits = indexSearcher.search (query);
        retString = new String [hits.length ()];
        String path;
        for (int i = 0; i < hits.length (); i ++) {
            path = hits.doc (i).get ("path");
            retString [i] = path;
        }
        indexSearcher.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    }
    return retString;
}


public void run () {
    while (true) {
        WatchKey key = null;
        try {
            key = watcher.take ();
        } catch (InterruptedException x) {
            org.apache.log4j.Logger fLog = org.apache.log4j.Logger.getLogger ("log.script.scriptwatcher");
            fLog.error ("Key taking intrrupted.", x);
        }
        Path dir = keys.get (key);
        if (dir == null) {
            System.err.println ("Unrecognized key: " + key);
            continue;
        }
        for (WatchEvent < ? > event : key.pollEvents ()) {
            @SuppressWarnings ("unchecked")
            WatchEvent < Path > ev = (WatchEvent < Path >) event;
            Path name = ev.context ();
            Path child = dir.resolve (name);
            File f = child.toFile ();
            updateFile (event, f);
        }
        key.reset ();
    }
}


-----Function Pair=121=-----==

private byte [] setServerProperty (HTTPurl urlData) throws Exception {
    String out = "";
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String [] parameter = urlData.getParameterList ();
    for (int x = 0; x < parameter.length; x ++) {
        if (! parameter [x].equals ("action") && ! parameter [x].equals ("sessionID")) {
            String value = urlData.getParameter (parameter [x]);
            if (value != null) {
                store.setServerProperty (parameter [x], value);
            }
        }
    }
    return out.getBytes ();
}


private byte [] showAutoDelItems (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "AutoDelItems.html");
    HashMap < String, KeepForDetails > items = store.getAutoDelList ();
    String [] key = (String []) items.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        KeepForDetails item = (KeepForDetails) items.get (key [x]);
        out.append ("<tr>\n");
        out.append ("<td>" + item.getCreated ().toString () + "</td>");
        out.append ("<td>" + item.getFileName () + "</td>");
        out.append ("<td>" + item.getKeepFor () + "</td>");
        out.append ("<td><a href='/servlet/" + urlData.getServletClass () + "?action=07&id=" + key [x] + "'>remove</a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$itemList", out.toString ());
    template.replaceAll ("$autoDelLog", store.getAutoDelLog ());
    return template.getPageBytes ();
}


-----Function Pair=122=-----==

private void loadSecretKey (File encryptedSecretKeyFile, char [] password) {
    try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        FileInputStream in = null;
        try {
            in = new FileInputStream (encryptedSecretKeyFile);
            byte [] bytes = new byte [1024];
            int n = 0;
            while ((n = in.read (bytes)) != - 1) {
                baos.write (bytes, 0, n);
            }
        } finally {
            if (in != null) {
                in.close ();
            }
        }
        byte [] encryptedSecretKey = Base64.decodeBase64 (baos.toByteArray ());
        String alias = getKeyStore ().aliases ().nextElement ();
        Key key = getKeyStore ().getKey (alias, password);
        Cipher cipher = Cipher.getInstance (key.getAlgorithm ());
        cipher.init (Cipher.UNWRAP_MODE, key);
        secretKey = (SecretKey) cipher.unwrap (encryptedSecretKey, "DESede", Cipher.SECRET_KEY);
    } catch (Exception ex) {
        throw new RuntimeException ("Could not load secret key from " + encryptedSecretKeyFile.getPath (), ex);
    }
}


public static Map convertDocumentFileToFile (DispatchContext dctx, Map context) {
    XMultiComponentFactory xmulticomponentfactory = null;
    String stringUrl = (String) context.get ("filenameFrom");
    String stringConvertedFile = (String) context.get ("filenameTo");
    String inputMimeType = (String) context.get ("inputMimeType");
    String outputMimeType = (String) context.get ("outputMimeType");
    String oooHost = (String) context.get ("oooHost");
    String oooPort = (String) context.get ("oooPort");
    try {
        xmulticomponentfactory = OpenOfficeWorker.getRemoteServer (oooHost, oooPort);
        File inputFile = new File (stringUrl);
        long fileSize = inputFile.length ();
        FileInputStream fis = new FileInputStream (inputFile);
        ByteArrayOutputStream baos = new ByteArrayOutputStream ((int) fileSize);
        int c;
        while ((c = fis.read ()) != - 1) {
            baos.write (c);
        }
        OpenOfficeByteArrayInputStream oobais = new OpenOfficeByteArrayInputStream (baos.toByteArray ());
        OpenOfficeByteArrayOutputStream oobaos = OpenOfficeWorker.convertOODocByteStreamToByteStream (xmulticomponentfactory, oobais, inputMimeType, outputMimeType);
        FileOutputStream fos = new FileOutputStream (stringConvertedFile);
        fos.write (oobaos.toByteArray ());
        fos.close ();
        fis.close ();
        oobais.close ();
        oobaos.close ();
        Map results = ServiceUtil.returnSuccess ();
        return results;
    } catch (IOException e) {
        Debug.logError (e, "Error in OpenOffice operation: ", module);
        return ServiceUtil.returnError (e.toString ());
    } catch (Exception e) {
        Debug.logError (e, "Error in OpenOffice operation: ", module);
        return ServiceUtil.returnError (e.toString ());
    }
}


-----Function Pair=123=-----==

public static byte [] readFullFile (File file) throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    FileInputStream in = null;
    try {
        in = new FileInputStream (file);
        byte [] buffer = new byte [8192];
        int read = 0;
        while ((read = in.read (buffer)) != - 1) {
            out.write (buffer, 0, read);
        }
        return out.toByteArray ();
    } finally {
        if (in != null) in.close ();
    }
}


private void doConversion () {
    String sOutputFormat;
    if (MIMETypes.LATEX.equals (sTargetMIME)) {
        sOutputFormat = "LaTeX";
    }
    else if (MIMETypes.BIBTEX.equals (sTargetMIME)) {
        sOutputFormat = "BibTeX";
    }
    else {
        sOutputFormat = "xhtml";
    }
    System.out.println ();
    System.out.println ("This is Writer2" + sOutputFormat + ", Version " + ConverterFactory.getVersion () + " (" + ConverterFactory.getDate () + ")");
    System.out.println ();
    System.out.println ("Starting conversion...");
    File source = new File (sSource);
    if (! source.exists ()) {
        System.out.println ("I'm sorry, I can't find " + sSource);
        System.exit (1);
    }
    if (! source.canRead ()) {
        System.out.println ("I'm sorry, I can't read " + sSource);
        System.exit (1);
    }
    boolean bBatch = source.isDirectory ();
    File target;
    if (bBatch) {
        if (sTarget == null) {
            target = source;
        }
        else {
            target = new File (sTarget);
        }
    }
    else {
        if (sTarget == null) {
            target = new File (source.getParent (), Misc.removeExtension (source.getName ()));
        }
        else {
            target = new File (sTarget);
            if (sTarget.endsWith (File.separator)) {
                target = new File (target, Misc.removeExtension (source.getName ()));
            }
        }
    }
    Converter converter = ConverterFactory.createConverter (sTargetMIME);
    if (converter == null) {
        System.out.println ("Failed to create converter for " + sTargetMIME);
        System.exit (1);
    }
    BatchConverter batchCv = null;
    if (bBatch) {
        batchCv = ConverterFactory.createBatchConverter (MIMETypes.XHTML);
        if (batchCv == null) {
            System.out.println ("Failed to create batch converter");
            System.exit (1);
        }
        batchCv.setConverter (converter);
    }
    if (sTemplateFileName != null) {
        try {
            System.out.println ("Reading template " + sTemplateFileName);
            byte [] templateBytes = Misc.inputStreamToByteArray (new FileInputStream (sTemplateFileName));
            converter.readTemplate (new ByteArrayInputStream (templateBytes));
            if (batchCv != null) {
                batchCv.readTemplate (new ByteArrayInputStream (templateBytes));
            }
        } catch (FileNotFoundException e) {
            System.out.println ("--> This file does not exist!");
            System.out.println ("    " + e.getMessage ());
        } catch (IOException e) {
            System.out.println ("--> Failed to read the template file!");
            System.out.println ("    " + e.getMessage ());
        }
    }
    if (sStyleSheetFileName != null) {
        try {
            System.out.println ("Reading style sheet " + sStyleSheetFileName);
            byte [] styleSheetBytes = Misc.inputStreamToByteArray (new FileInputStream (sStyleSheetFileName));
            converter.readStyleSheet (new ByteArrayInputStream (styleSheetBytes));
        } catch (FileNotFoundException e) {
            System.out.println ("--> This file does not exist!");
            System.out.println ("    " + e.getMessage ());
        } catch (IOException e) {
            System.out.println ("--> Failed to read the style sheet file!");
            System.out.println ("    " + e.getMessage ());
        }
    }
    for (String sResource : resources) {
        String sMediaType;
        String sFileName;
        int nSeparator = sResource.indexOf ("::");
        if (nSeparator > - 1) {
            sFileName = sResource.substring (0, nSeparator);
            sMediaType = sResource.substring (nSeparator + 2);
        }
        else {
            sFileName = sResource;
            sMediaType = null;
        }
        System.out.println ("Reading resource file " + sFileName);
        try {
            byte [] resourceBytes = Misc.inputStreamToByteArray (new FileInputStream (sFileName));
            converter.readResource (new ByteArrayInputStream (resourceBytes), sFileName, sMediaType);
        } catch (IOException e) {
            System.out.println ("--> Failed to read the resource file!");
            System.out.println ("    " + e.getMessage ());
        }
    }
    for (int i = 0; i < configFileNames.size (); i ++) {
        String sConfigFileName = (String) configFileNames.get (i);
        if (sConfigFileName.startsWith ("*")) {
            sConfigFileName = sConfigFileName.substring (1);
            System.out.println ("Reading default configuration " + sConfigFileName);
            try {
                converter.getConfig ().readDefaultConfig (sConfigFileName);
            } catch (IllegalArgumentException e) {
                System.err.println ("--> This configuration is unknown!");
                System.out.println ("    " + e.getMessage ());
            }
        }
        else {
            System.out.println ("Reading configuration file " + sConfigFileName);
            try {
                byte [] configBytes = Misc.inputStreamToByteArray (new FileInputStream (sConfigFileName));
                converter.getConfig ().read (new ByteArrayInputStream (configBytes));
                if (bBatch) {
                    batchCv.getConfig ().read (new ByteArrayInputStream (configBytes));
                }
            } catch (IOException e) {
                System.err.println ("--> Failed to read the configuration!");
                System.out.println ("    " + e.getMessage ());
            }
        }
    }
    Enumeration < String > keys = options.keys ();
    while (keys.hasMoreElements ()) {
        String sKey = keys.nextElement ();
        String sValue = (String) options.get (sKey);
        converter.getConfig ().setOption (sKey, sValue);
        if (batchCv != null) {
            batchCv.getConfig ().setOption (sKey, sValue);
        }
    }
    if (bBatch) {
        batchCv.convert (source, target, bRecurse, new BatchHandlerImpl ());
    }
    else {
        System.out.println ("Converting " + source.getPath ());
        ConverterResult dataOut = null;
        try {
            dataOut = converter.convert (source, target.getName ());
        } catch (FileNotFoundException e) {
            System.out.println ("--> The file " + source.getPath () + " does not exist!");
            System.out.println ("    " + e.getMessage ());
            System.exit (1);
        } catch (IOException e) {
            System.out.println ("--> Failed to convert the file " + source.getPath () + "!");
            System.out.println ("    " + e.getMessage ());
            System.exit (1);
        }
        File targetDir = target.getParentFile ();
        if (targetDir != null && ! targetDir.exists ()) {
            targetDir.mkdirs ();
        }
        try {
            dataOut.write (targetDir);
        } catch (IOException e) {
            System.out.println ("--> Error writing out file!");
            System.out.println ("    " + e.getMessage ());
            System.exit (1);
        }
    }
    System.out.println ("Done!");
}


-----Function Pair=124=-----==

public void actionPerformed (ActionEvent actionEvent) {
    Thread trans = new Thread () {
        public void run () {
            Globals.setThinking (true);
            try {
                Thread.sleep (500);
            } catch (Exception e) {
                System.err.println ("DoTransform: " + e);
                e.printStackTrace (System.err);
            }
            txtOutput.setText ("");
            txtOutputHTML.setText ("");
            transform ();
            Globals.setThinking (false);
        }
    }
    ;
    trans.start ();
}


private void uploadFile (HttpURL url, File file, String relative) throws IOException {
    boolean putit = false;
    try {
        if (this.overwrite) {
            putit = true;
        }
        else {
            long remoteLastMod = Utils.getLastModified (getHttpClient (), url);
            long localLastMod = file.lastModified ();
            putit = localLastMod > remoteLastMod;
        }
    } catch (HttpException e) {
        switch (e.getReasonCode ()) {
            case HttpStatus.SC_NOT_FOUND :
                putit = true;
                break;
            default :
                throw Utils.makeBuildException ("Can't get lastmodified!?", e);
        }
    }
    if (putit) {
        log ("Uploading: " + relative, ifVerbose ());
        try {
            String contentType = Mimetypes.getMimeType (file, DEFAULT_CONTENT_TYPE);
            if (this.filterSets.hasFilters ()) {
                InputStreamReader reader = new InputStreamReader (new FileInputStream (file), this.encoding);
                ByteArrayOutputStream out = new ByteArrayOutputStream ();
                LineTokenizer tok = new LineTokenizer ();
                tok.setIncludeDelims (true);
                for (String l = tok.getToken (reader); l != null; l = tok.getToken (reader)) {
                    out.write (this.filterSets.replaceTokens (l).getBytes (this.encoding));
                }
                Utils.putFile (getHttpClient (), url, new ByteArrayInputStream (out.toByteArray ()), contentType, this.locktoken);
            }
            else {
                Utils.putFile (getHttpClient (), url, new FileInputStream (file), contentType, this.locktoken);
            }
            this.countWrittenFiles ++;
        } catch (HttpException e) {
            throw Utils.makeBuildException ("Can't upload " + url, e);
        }
    }
    else {
        countOmittedFiles ++;
        log ("Omitted: " + relative + " (uptodate)", ifVerbose ());
    }
}


-----Function Pair=125=-----==

public static boolean emptyFolder (final File folder) {
    if (! folder.isDirectory ()) {
        return true;
    }
    File [] files = folder.listFiles ();
    boolean result = true;
    for (File file : files) {
        if (file.isDirectory ()) {
            if (emptyFolder (file)) {
                result &= file.delete ();
            }
            else {
                result = false;
            }
        }
        else {
            result &= file.delete ();
        }
    }
    return result;
}


private void compareXML (boolean useW3CSpec, InputStream source, InputStream expected, OutputStream output) throws Exception {
    CanonicalForm cf;
    byte [] buffer;
    int bytesRead;
    ByteArrayOutputStream expectedBytes, outputBytes;
    expectedBytes = new ByteArrayOutputStream ();
    outputBytes = new ByteArrayOutputStream ();
    cf = new CanonicalForm (useW3CSpec);
    cf.transform (source, outputBytes);
    if (output != null) {
        output.write (outputBytes.toByteArray ());
    }
    buffer = new byte [4096];
    while ((bytesRead = expected.read (buffer)) > - 1) {
        expectedBytes.write (buffer, 0, bytesRead);
        buffer = new byte [4096];
    }
    assertEquals (expectedBytes.toByteArray (), outputBytes.toByteArray ());
}


-----Function Pair=126=-----==

private static int bruteforceKzip (String caption, File packFile, File packGzFile, int splitOffset, int splitStep, int steps, int reruns) throws IOException {
    File min = packGzFile;
    File [] dst = new File [steps];
    int minSplit = - 1;
    for (int i = 0; i < dst.length; i ++) {
        dst [i] = new File (packGzFile.getParentFile (), i + "_" + packGzFile.getName ());
        int split = splitOffset + i * splitStep;
        for (int k = 0; k < reruns; k ++) {
            if (kzip_deflopt_gz (caption, packFile, dst [i], split, k != 0)) {
                if (dst [i].length () != 0 && ((min == null || min.length () == 0) || dst [i].length () < min.length ())) {
                    min = dst [i];
                    minSplit = split;
                }
            }
        }
    }
    if (minSplit != - 1) {
        FileUtil.copyFile (min, packGzFile);
    }
    for (int i = 0; i < dst.length; i ++) {
        dst [i].delete ();
    }
    return minSplit;
}


public void actionPerformed (ActionEvent e) {
    JFileChooser fc = new JFileChooser ("");
    fc.setMultiSelectionEnabled (false);
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    int option = 0;
    boolean save = m_data != null;
    if (save) option = fc.showSaveDialog (this);
    else option = fc.showOpenDialog (this);
    if (option != JFileChooser.APPROVE_OPTION) return;
    File file = fc.getSelectedFile ();
    if (file == null) return;
    log.info (file.toString ());
    try {
        if (save) {
            FileOutputStream os = new FileOutputStream (file);
            byte [] buffer = (byte []) m_data;
            os.write (buffer);
            os.flush ();
            os.close ();
            log.config ("Save to " + file + " #" + buffer.length);
        }
        else {
            FileInputStream is = new FileInputStream (file);
            ByteArrayOutputStream os = new ByteArrayOutputStream ();
            byte [] buffer = new byte [1024 * 8];
            int length = - 1;
            while ((length = is.read (buffer)) != - 1) os.write (buffer, 0, length);
            is.close ();
            byte [] data = os.toByteArray ();
            m_data = data;
            log.config ("Load from " + file + " #" + data.length);
            os.close ();
        }
    } catch (Exception ex) {
        log.log (Level.WARNING, "Save=" + save, ex);
    }
    try {
        fireVetoableChange (m_columnName, null, m_data);
    } catch (PropertyVetoException pve) {
    }
}


-----Function Pair=127=-----==

public void saveFile (InputStream is, String folderPath, String filename) {
    File path = new File (folderPath);
    if (! path.exists ()) {
        try {
            path.mkdirs ();
        } catch (Exception e) {
            logger.error ("Can't create directory...:" + path);
        }
    }
    String filepath = path + separator () + filename;
    File file = new File (filepath);
    FileOutputStream os = null;
    try {
        if (! file.exists ()) {
            file.createNewFile ();
        }
        os = new FileOutputStream (filepath);
        int c;
        while ((c = is.read ()) != - 1) {
            os.write (c);
        }
    } catch (IOException e) {
        logger.error (e, e);
    } finally {
        if (os != null) {
            try {
                os.flush ();
                os.close ();
            } catch (Throwable e) {
            }
        }
    }
}


public static String readLine (InputStream is) throws IOException {
    StringBuffer buff = new StringBuffer ();
    int b = 0;
    while ((b = is.read ()) != '\n') {
        if (b != - 1) {
            buff.append ((char) b);
        }
        else {
            break;
        }
    }
    int len = buff.length ();
    if ((len > 0) && (buff.charAt (len - 1) == '\r')) {
        return buff.substring (0, len - 1);
    }
    else {
        return buff.toString ();
    }
}


-----Function Pair=128=-----==

protected long getFolderSize (String folderPath) {
    if (folderPath == null || folderPath.equals ("")) {
        return 0;
    }
    File folder = new File (folderPath);
    if (! folder.exists ()) {
        return 0;
    }
    if (folder.isFile ()) {
        return getFileSize (folder);
    }
    int fileSizeSum = 0;
    File file = null;
    String [] files = folder.list ();
    int length = files.length;
    for (int i = 0; i < length; i ++) {
        file = new File (folderPath + separator () + files [i]);
        if (file.isFile ()) {
            fileSizeSum += getFileSize (file);
        }
        else if (file.isDirectory ()) {
            fileSizeSum += getFolderSize (file.getAbsolutePath ());
        }
    }
    return fileSizeSum;
}


public AddPredicateThreadCheckStrategy (List < String > parameters, SharedData shared, SharedAddData sharedAdd) {
    super (parameters, shared, sharedAdd);
    for (String p : parameters) {
        if (p.toLowerCase ().startsWith (PRED_OUT_DIR_PARAM_PREFIX)) {
            _classOutputDir = new File (p.substring (PRED_OUT_DIR_PARAM_PREFIX.length ()));
        }
        else if (p.toLowerCase ().startsWith (PRED_OUT_PACKAGE_PARAM_PREFIX)) {
            _predicatePackage = p.substring (PRED_OUT_PACKAGE_PARAM_PREFIX.length ());
        }
    }
    ClassFileTools.ClassLocation tcl = ClassFileTools.findClassFile (CombinePredicateTemplate.class.getName (), _sharedData.getClassPath ());
    if (tcl == null) {
        throw new ClassNotFoundWarning (CombinePredicateTemplate.class.getName (), _sharedData.getCurrentClassName ());
    }
    boolean fromJAR = (tcl.getJarFile () != null);
    try {
        tcl.close ();
    } catch (IOException ioe) {
    }
    _templatePredicateClassFile = tcl.getClassFile ();
    String cptName = CombinePredicateTemplate.class.getName ();
    if (_predicatePackage == null) {
        _predicatePackage = cptName.substring (0, cptName.lastIndexOf ('.'));
    }
    if (_classOutputDir == null) {
        if (! fromJAR) {
            File dir = tcl.getFile ().getParentFile ();
            int last = cptName.length ();
            while ((last = cptName.lastIndexOf ('.', last)) >= 0) {
                dir = dir.getParentFile ();
                -- last;
            }
            _classOutputDir = dir;
        }
        else {
            for (String pathStr : _sharedData.getClassPath ()) {
                File path = new File (pathStr);
                if (path.isDirectory ()) {
                    _classOutputDir = path;
                    break;
                }
            }
        }
    }
    if (_classOutputDir != null) {
        if (_predicatePackage.length () > 0) {
            _predicatePackageDir = new File (_classOutputDir, _predicatePackage.replace ('.', '/'));
        }
        else {
            _predicatePackageDir = _classOutputDir;
        }
        Debug.out.println ("Output dir : " + _classOutputDir);
        Debug.out.println ("Package    : " + _predicatePackage);
        Debug.out.println ("Package dir: " + _predicatePackageDir);
        _classOutputDir.mkdirs ();
        _predicatePackageDir.mkdirs ();
    }
    else {
        Debug.out.println ("No directory for auto-generated classes set.");
    }
    _generatedPredicateRecords = new SoftHashMap < String, PredicateAnnotationRecord > ();
}


-----Function Pair=129=-----==

public void storePermissions (ExecutableDesc execDesc, PermissionCollection permCollection) throws PolicyStoreException {
    String fileName = generateFilename (execDesc.getSerialNumber ().getBytes ());
    if (fileName == null) throw new PolicyStoreException ("Can't generate filename for permission.", null);
    logger.info ("Storing file:" + fileName);
    File f = new File (storeDir, fileName);
    BootPolicy.addPermissions (getPermissions (execDesc), permCollection);
    try {
        Document doc = docBuilder.newDocument ();
        Element securityE = doc.createElement ("xito-security");
        Element appE = doc.createElement ("application");
        if (execDesc.getDisplayName () != null) appE.setAttribute ("name", execDesc.getDisplayName ());
        appE.setAttribute ("serial-num", execDesc.getSerialNumber ());
        securityE.appendChild (appE);
        Enumeration perms = permCollection.elements ();
        while (perms.hasMoreElements ()) {
            Permission perm = (Permission) perms.nextElement ();
            appE.appendChild (createPermissionElement (doc, perm));
        }
        FileOutputStream out = new FileOutputStream (f);
        StreamResult result = new StreamResult (out);
        transformer.transform (new DOMSource (securityE), result);
        out.flush ();
        out.close ();
    } catch (Exception exp) {
        throw new PolicyStoreException (exp.toString (), exp);
    }
}


public static boolean uploadFile (File file, String folder, String fileName, long length) {
    boolean ret = false;
    try {
        if (file == null || fileName == null || fileName.equals ("")) {
            return ret;
        }
        if (! createDirectory (folder)) {
            return ret;
        }
        if (length > 0 && file.length () > length) {
            return ret;
        }
        ret = uploadFile (file, folder + SEPRATOR + fileName);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return ret;
}


-----Function Pair=130=-----==

public static void generateKeys2 (int keySize, Path publicKey, Path privateKey) throws NoSuchAlgorithmException, IOException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance ("RSA");
    keyGen.initialize (keySize);
    KeyPair keyPair = keyGen.generateKeyPair ();
    PublicKey pubkey = keyPair.getPublic ();
    PrivateKey privkey = keyPair.getPrivate ();
    Files.createDirectories (publicKey.getParent ());
    Files.createFile (publicKey);
    Files.createDirectories (privateKey.getParent ());
    Files.createFile (privateKey);
    ObjectOutputStream oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (publicKey.toFile ())));
    oout.writeObject (pubkey);
    oout.close ();
    oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (privateKey.toFile ())));
    oout.writeObject (privkey);
    oout.close ();
}


private int getContentUsingThread (URL location, Vector < byte [] > buffs, StringBuffer buff, int format) {
    Thread loaderThread = null;
    LoaderTread loader = null;
    try {
        loader = new LoaderTread (location);
        loaderThread = new Thread (Thread.currentThread ().getThreadGroup (), loader, loader.getClass ().getName ());
        loaderThread.start ();
        while (! loader.isFinished ()) {
            if (loader.isTimedOut (30)) {
                System.out.println ("\nTimout reached : Killing loader Thread");
                if (format == 0) {
                    buff.append ("Timout reached : Killing loader Thread\n");
                }
                else {
                    buff.append ("Timout reached : Killing loader Thread<br>\n");
                }
                loader.kill ();
                loaderThread.interrupt ();
                break;
            }
            Thread.sleep (500);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    loaderThread.interrupt ();
    if (loader.getResponceCode () != 200) {
        if (format == 0) {
            buff.append ("URL Load Error (" + loader.getResponceCode () + ")\n" + loader.getResponceMessage () + "\n");
        }
        else {
            buff.append ("URL Load Error (" + loader.getResponceCode () + ") : <pre>" + loader.getResponceMessage () + "</pre>\n");
        }
        return loader.getResponceCode ();
    }
    if (location.toString ().toUpperCase ().indexOf (".ZIP", location.toString ().length () - 4) > - 1) {
        if (unZip (loader.getDataBytes (), buffs) > 0) return 200;
        else return 404;
    }
    else {
        buffs.add (loader.getDataBytes ());
        return loader.getResponceCode ();
    }
}


-----Function Pair=131=-----==

public void chargeExtractionThematiqueEtSpatiale (IGeometry geom, List < List < String > > themes) {
    if (! this.getPersistant ()) {
        DataSet.LOGGER.warn ("----- ATTENTION : Probleme au chargement du jeu de donnees " + this.getNom ());
        DataSet.LOGGER.warn ("----- Impossible de charger les elements d'un jeu de donnees non persistant");
        return;
    }
    List < String > themeACharger, extraitThemes;
    List < List < String > > populationsACharger;
    List < String > populationsACharger2;
    Iterator < List < String > > itThemes;
    Iterator < String > itPopulationsACharger;
    boolean aCharger;
    for (IDataSet DS : this.getComposants ()) {
        populationsACharger = null;
        if (themes == null) {
            aCharger = true;
        }
        else {
            itThemes = themes.iterator ();
            themeACharger = itThemes.next ();
            if (! itThemes.hasNext ()) {
                aCharger = true;
            }
            else {
                aCharger = false;
                while (itThemes.hasNext ()) {
                    themeACharger = itThemes.next ();
                    if (DS.getNom ().equals (themeACharger.get (0))) {
                        aCharger = true;
                        if (themeACharger.size () == 1) {
                            populationsACharger = null;
                            break;
                        }
                        extraitThemes = new ArrayList < String > (themeACharger);
                        extraitThemes.remove (0);
                        populationsACharger = new ArrayList < List < String > > ();
                        populationsACharger.add (extraitThemes);
                        break;
                    }
                }
            }
        }
        if (aCharger && DS.getPersistant ()) {
            DS.chargeExtractionThematiqueEtSpatiale (geom, populationsACharger);
        }
    }
    if (themes == null) {
        populationsACharger2 = null;
    }
    else {
        itThemes = themes.iterator ();
        populationsACharger2 = itThemes.next ();
    }
    DataSet.LOGGER.info ("###### Chargement des elements du DataSet " + this.getNom ());
    for (IPopulation < ? extends IFeature > pop : this.getPopulations ()) {
        if (populationsACharger2 == null) {
            aCharger = true;
        }
        else {
            aCharger = false;
            itPopulationsACharger = populationsACharger2.iterator ();
            while (itPopulationsACharger.hasNext ()) {
                String nomPopulation = itPopulationsACharger.next ();
                if (pop.getNom ().equals (nomPopulation)) {
                    aCharger = true;
                    break;
                }
            }
        }
        if (aCharger && pop.getPersistant ()) {
            if (geom != null) {
                pop.chargeElementsPartie (geom);
            }
            else {
                pop.chargeElements ();
            }
        }
    }
}


private Socket createSocket (String host, int port, String socketFactory, int connectTimeout) throws Exception {
    Socket socket = null;
    if (socketFactory != null) {
        Class socketFactoryClass = Obj.helper.loadClass (socketFactory);
        Method getDefault = socketFactoryClass.getMethod ("getDefault", new Class [] {});
        Object factory = getDefault.invoke (null, new Object [] {});
        Method createSocket = null;
        if (connectTimeout > 0) {
            try {
                createSocket = socketFactoryClass.getMethod ("createSocket", new Class [] {});
                Method connect = Socket.class.getMethod ("connect", new Class [] {Class.forName ("java.net.SocketAddress"), int.class});
                Object endpoint = createInetSocketAddress (host, port);
                socket = (Socket) createSocket.invoke (factory, new Object [] {});
                if (debug) {
                    System.err.println ("Connection: creating socket with " + "a timeout using supplied socket factory");
                }
                connect.invoke (socket, new Object [] {endpoint, new Integer (connectTimeout)});
            } catch (NoSuchMethodException e) {
            }
        }
        if (socket == null) {
            createSocket = socketFactoryClass.getMethod ("createSocket", new Class [] {String.class, int.class});
            if (debug) {
                System.err.println ("Connection: creating socket using " + "supplied socket factory");
            }
            socket = (Socket) createSocket.invoke (factory, new Object [] {host, new Integer (port)});
        }
    }
    else {
        if (connectTimeout > 0) {
            try {
                Constructor socketCons = Socket.class.getConstructor (new Class [] {});
                Method connect = Socket.class.getMethod ("connect", new Class [] {Class.forName ("java.net.SocketAddress"), int.class});
                Object endpoint = createInetSocketAddress (host, port);
                socket = (Socket) socketCons.newInstance (new Object [] {});
                if (debug) {
                    System.err.println ("Connection: creating socket with " + "a timeout");
                }
                connect.invoke (socket, new Object [] {endpoint, new Integer (connectTimeout)});
            } catch (NoSuchMethodException e) {
            }
        }
        if (socket == null) {
            if (debug) {
                System.err.println ("Connection: creating socket");
            }
            socket = new Socket (host, port);
        }
    }
    return socket;
}


-----Function Pair=132=-----==

public Script loadScript (String name) throws Exception {
    Resource precompiled;
    Resource source;
    Script script = scriptMap.get (name);
    String sfname = name.replaceAll ("::", "/");
    if (script != null) {
        return script;
    }
    System.out.println ("I: Request for " + name + " ...");
    precompiled = locator.getResource (sfname + ".cs");
    source = locator.getResource (sfname + ".ass");
    if (precompiled == null && source == null) {
        throw new LinkerException ("Cannot find script: " + name);
    }
    if (precompiled == null || source.getLastModified () > precompiled.getLastModified ()) {
        byte [] binary;
        DataOutputStream out;
        if (binWriter == null) {
            binWriter = new BinaryWriter ();
        }
        System.out.println ("I: Assembling " + name + " (" + source.getFullName () + ")" + (precompiled != null ? " [Precompiled version out of date]" : "") + ".");
        script = (Script) locator.loadResource (source);
        binary = binWriter.writeScript (binWriter.getLastestKnownVersion (), script);
        new File ("out/" + name).getParentFile ().mkdirs ();
        out = new DataOutputStream (new FileOutputStream ("out/" + name + ".cs"));
        out.write (binary);
        out.close ();
    }
    else {
        System.out.println ("I: Using precompiled " + name + " (" + precompiled.getFullName () + ").");
        script = (Script) locator.loadResource (precompiled);
    }
    if (! script.getName ().equals (sfname)) {
        throw new LinkerException ("Loaded script is called " + script.getName () + " and not " + sfname + "?");
    }
    scriptMap.put (name, script);
    System.out.println ("I: Loaded " + name + ".");
    return script;
}


public int runScript (InputStream stream, String source, boolean convertReturn) throws ParseException, UnsupportedEncodingException, ThrowException {
    InputStream save = mCommandInput;
    mCommandInput = stream;
    ShellParser parser = new ShellParser (new ShellParserReader (mCommandInput, getInputTextEncoding ()), source);
    int ret = 0;
    try {
        while (mExitVal == null && mReturnVal == null) {
            Command c = parser.command_line ();
            if (c == null) break;
            if (mOpts.mVerbose) {
                String s = c.toString (false);
                if (s.length () > 0) {
                    SourceLocation loc = c.getLocation ();
                    if (loc != null) {
                        String sLoc = loc.toString ();
                        mLogger.info (sLoc);
                        printErr ("- " + sLoc);
                        printErr (s);
                    }
                    else printErr ("- " + s);
                }
            }
            ret = exec (c);
        }
    } catch (ThrowException e) {
        throw e;
    } catch (ExitOnErrorException e) {
        ret = e.getValue ();
    } catch (Exception e) {
        printErr (e.getMessage ());
        mLogger.error ("Exception parsing statement", e);
        parser.ReInit (new ShellParserReader (mCommandInput, getInputTextEncoding ()), source);
    } catch (Error e) {
        printErr (e.getMessage ());
        mLogger.error ("Exception parsing statement", e);
        parser.ReInit (new ShellParserReader (mCommandInput, getInputTextEncoding ()), source);
    } finally {
        mCommandInput = save;
    }
    if (mExitVal != null) ret = mExitVal.intValue ();
    else if (convertReturn && mReturnVal != null) {
        try {
            ret = mReturnVal.toBoolean () ? 0 : 1;
        } catch (Exception e) {
            mLogger.error ("Exception converting return value to boolean", e);
            ret = - 1;
        }
        mReturnVal = null;
    }
    return ret;
}


-----Function Pair=133=-----==

private void mouseifyAttribute (JDObject jdObj) {
    jdObj.addMouseListener (new JDMouseAdapter () {
        public void mousePressed (JDMouseEvent e) {
            attributeClicked (e);
        } public void mouseEntered (JDMouseEvent e) {
            attDisplayToolTip (e);
        } public void mouseExited (JDMouseEvent e) {
            attRemoveToolTip ();
        }
    }
    );
}


public Boolean call () throws ComponentInvocationException {
    Constructor < ? extends AbstractComponent > constructor;
    try {
        constructor = processClass.getConstructor (HashMap.class);
    } catch (SecurityException e1) {
        throw new ComponentInvocationException ("The process to be executed could not be invoked.");
    } catch (NoSuchMethodException e1) {
        throw new ComponentInvocationException ("The constructor of the process to be executed could not be found.");
    }
    for (int i = 0; i < this.invokeCount; i ++) {
        IComponent proc;
        try {
            proc = constructor.newInstance (this.spaces);
        } catch (InstantiationException e) {
            throw new ComponentInvocationException ("The process to be executed could not be instantiated.");
        } catch (IllegalAccessException e) {
            throw new ComponentInvocationException ("The process to be executed is illegally accessed.");
        } catch (InvocationTargetException e) {
            throw new ComponentInvocationException ("The process to be executed could not be invoked.");
        }
        proc.call ();
    }
    return true;
}


-----Function Pair=134=-----==

private Class getOMGContainerFromJar (JarFile jar, URLClassLoader urlLoader) {
    boolean found = false;
    Enumeration entries = jar.entries ();
    while (entries.hasMoreElements () && ! found) {
        ZipEntry zipEntry = (ZipEntry) entries.nextElement ();
        String name = zipEntry.getName ();
        if (! name.toLowerCase ().endsWith (".class")) {
            continue;
        }
        try {
            int end = name.indexOf (".class");
            String className = name.substring (0, end).replace ('/', '.');
            Class c = urlLoader.loadClass (className);
            if (className.equals ("com.pallas.unicore.client.plugins.script.ScriptContainer")) {
                return c;
            }
            Class test = c;
            while (! test.getName ().equals ("java.lang.Object")) {
                Class [] interfaces;
                try {
                    interfaces = test.getInterfaces ();
                    for (int j = 0; j < interfaces.length; j ++) {
                        if (interfaces [j].getName ().endsWith ("IChainable")) {
                            return c;
                        }
                    }
                    test = test.getSuperclass ();
                } catch (java.lang.NoClassDefFoundError err) {
                    logger.warning ("error while reading plugins: " + err.getMessage () + ", scanning " + test.getName ());
                }
            }
        } catch (java.lang.NoClassDefFoundError t) {
            logger.warning ("error while reading plugins: " + t.getMessage () + ", scanning " + name);
        } catch (Exception ex) {
            logger.severe ("Error while reading plugins: ");
            ex.printStackTrace ();
        }
    }
    return null;
}


public ExtentManager (Document doc) {
    Element root = (Element) (doc.getElementsByTagName ("ROOT").item (0));
    NodeList extentsList = root.getElementsByTagName ("Extent");
    for (int i = 0; i < extentsList.getLength (); i ++) {
        Element ext_elem = (Element) extentsList.item (i);
        if (ext_elem.hasAttribute ("class_name")) {
            try {
                Class extent_class = Class.forName (ext_elem.getAttribute ("class_name"));
                Class param_types [] = {org.w3c.dom.Document.class, org.w3c.dom.Element.class};
                Constructor constructor = extent_class.getConstructor (param_types);
                Object params [] = {doc, ext_elem};
                Extent extent = (Extent) constructor.newInstance (params);
                this.add (extent);
            } catch (Exception cnfe) {
                this.add (new Extent (doc, (Element) extentsList.item (i)));
            }
        }
        else {
            this.add (new Extent (doc, (Element) extentsList.item (i)));
        }
    }
}


-----Function Pair=135=-----=1=

public Object stringToValue (String str, ItsNatFormattedTextField comp) throws ParseException {
    Class vc = getValueClass (comp);
    if (vc != null) {
        Constructor cons;
        try {
            cons = vc.getConstructor (new Class [] {String.class});
        } catch (NoSuchMethodException nsme) {
            cons = null;
        }
        if (cons != null) {
            try {
                return cons.newInstance (new Object [] {str});
            } catch (Exception ex) {
                throw new ParseException ("Error creating instance", 0);
            }
        }
    }
    return str;
}


public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println ("caught ClassNotFoundException");
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


-----Function Pair=136=-----==

public Object values (String name) throws ArgsParserException {
    Object res;
    Option opt;
    Class type;
    opt = getOption (name);
    if (opt.array_) {
        return convert ((Collection) opt.value_);
    }
    type = (Class) prim_.get (opt.value_.getClass ());
    if (type == null) {
        type = opt.value_.getClass ();
    }
    res = Array.newInstance (type, 1);
    Array.set (res, 0, opt.value_);
    return res;
}


private static void deserialize (GameLogic logic, ByteArrayReader bar) throws Exception {
    ServerEventCommand sec;
    byte sid;
    int len;
    Class sec_class = null;
    Class [] constr_arg_classes = {bar.getClass ()};
    Object [] constr_arg = {bar};
    while (bar.available () > 0) {
        try {
            sec_class = null;
            sec = null;
            sid = bar.readByte ();
            len = bar.readInt ();
            for (int index = 0; index < COMMAND_CLASSES.length; index ++) {
                sec_class = Class.forName (COMMAND_PACKAGE + "." + COMMAND_CLASSES [index]);
                if (sec_class.getField ("SID").getByte (null) == sid) {
                    break;
                }
            }
            if (sec_class != null) {
                sec = (ServerEventCommand) sec_class.getConstructor (constr_arg_classes).newInstance (constr_arg);
                if (logic != null) {
                    sec.action (logic);
                }
            }
            else {
                bar.skip (len);
            }
        } catch (Exception e) {
            Log.error (DESERIALIZE_ERROR + "\n" + e + "\n");
        }
    }
}


-----Function Pair=137=-----==

public List < Field > allDeclaredFieldsByReflection (final Class classForField) {
    Field [] fields;
    Class currentClass = classForField;
    final List < Field > list = new LinkedList < Field > ();
    while (currentClass != null && ! Enum.class.equals (currentClass)) {
        fields = currentClass.getDeclaredFields ();
        for (Field field : fields) {
            if (toPersist (field)) {
                list.add (field);
            }
            else if (_log.isDebugEnabled ()) {
                _log.debug ("not persisted => not writed " + field.getName ());
            }
        }
        currentClass = currentClass.getSuperclass ();
    }
    return list;
}


public static Class < ? > getModelClass (ModelType type, String className) throws WrongConfigurationException {
    String modelName = type.name ();
    modelName = modelName.substring (0, 1).toLowerCase () + modelName.substring (1) + "s";
    Class < ? > result = null;
    try {
        String name = "";
        if (className.contains (".")) {
            name = className;
        }
        else if (className.contains (":")) {
            String [] parts = className.split (":", 2);
            name = Configuration.userProjectsPath + "." + parts [0] + ".models." + modelName + "." + parts [1];
        }
        else {
            name = Configuration.defaultProjectPath + ".models." + modelName + "." + className;
        }
        result = Class.forName (name);
    } catch (ClassNotFoundException e) {
        throw new WrongConfigurationException (e, "Cannot generate class for the " + modelName + ". The class " + className + " cannot be found. (" + e.getMessage () + ")");
    }
    return result;
}


-----Function Pair=138=-----==

public static final Map < String, Object > requestMapRevalue (Class < ? > c, Map < String, String > requestMap, boolean map2Object) {
    Map < String, Object > map = new HashMap < String, Object > ();
    try {
        Iterator < String > it = requestMap.keySet ().iterator ();
        Object instance = c.newInstance ();
        log.debug ("--[requetMapRevalue]-- newInstance=" + instance);
        while (it.hasNext ()) {
            String key = it.next ();
            String strV = requestMap.get (key);
            map = getPropertyMap (map, instance, key, strV, map2Object);
        }
    } catch (Throwable e) {
        log.error ("requestMapRevalue error", e);
    }
    return map;
}


public DaoException translate (String sql, SQLException e, DatabaseInformation dbInfo) {
    DaoException ret = null;
    SqlType type = getSqlType (sql);
    if (secondLevelTranslators.containsKey (dbInfo.getType ())) {
        SQLExceptionTranslator translator = secondLevelTranslators.get (dbInfo.getType ());
        ret = translator.translate (sql, e, dbInfo);
        if (ret != null) {
            return ret;
        }
    }
    ret = retrieveExceptionFromTable (e, type);
    if (ret != null) {
        return ret;
    }
    ret = new DaoException (e);
    return ret;
}


-----Function Pair=139=-----==

public void run () {
    try {
        while (! quit) {
            final int c = is.read ();
            if (c > - 1) {
                if (c == ACK) {
                    if (state == ACK_PENDING) synchronized (lock) {
                        state = OK;
                        lock.notify ();
                    }
                }
                else if (c == START) readFrame ();
                else if (c == START_FIXED) readShortFrame ();
                else logger.trace ("received unexpected start byte 0x" + Integer.toHexString (c) + " - ignored");
            }
        }
    } catch (final IOException e) {
        if (! quit) close (false, "receiver communication failure");
    }
}


public synchronized void startServer () {
    if (serverSocketClass == null) {
        System.err.println ("Server mode not supported: need Foundation Profile or higher");
        return;
    }
    if (isServerMode) {
        if (isVerbose) {
            System.err.println ("Server already started on port " + port);
        }
        return;
    }
    isServerMode = true;
    if (port == 0) {
        port = DEFAULT_PORT;
        if (isVerbose) {
            System.out.println ("port not set.  Using default port: " + port);
        }
    }
    try {
        Class [] argsTypes = new Class [1];
        argsTypes [0] = Integer.TYPE;
        Constructor ct = serverSocketClass.getConstructor (argsTypes);
        Object [] argsList = new Object [1];
        argsList [0] = new Integer (port);
        serverSocket = ct.newInstance (argsList);
        server = new CVMSHServer (this, serverSocketClass, serverSocket, port);
        Thread serverThread = new Thread (server);
        serverThread.start ();
    } catch (InvocationTargetException e) {
        System.err.println ("ERROR: Cannot start server on port " + port);
        return;
    } catch (Exception e) {
        System.err.println ("ERROR: Unexpected exception while " + "creating server: " + e);
        return;
    }
}


-----Function Pair=140=-----==

public void actionPerformed (ActionEvent arg0) {
    Object [] constructorArgs = {collapsedGraph};
    Class < ? extends Layout > layoutC = (Class < ? extends Layout >) jcb.getSelectedItem ();
    try {
        Constructor < ? extends Layout > constructor = layoutC.getConstructor (new Class [] {Graph.class});
        Object o = constructor.newInstance (constructorArgs);
        Layout l = (Layout) o;
        l.setInitializer (vv.getGraphLayout ());
        l.setSize (vv.getSize ());
        layout = l;
        LayoutTransition lt = new LayoutTransition (vv, vv.getGraphLayout (), l);
        Animator animator = new Animator (lt);
        animator.start ();
        vv.getRenderContext ().getMultiLayerTransformer ().setToIdentity ();
        vv.repaint ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void actionPerformed (ActionEvent e) {
    if (aboutBox == null) {
        JPanel panel = new AboutPanel (swingset);
        panel.setLayout (new BorderLayout ());
        aboutBox = new JDialog (swingset.getFrame (), getString ("AboutBox.title"), false);
        aboutBox.setResizable (false);
        aboutBox.getContentPane ().add (panel, BorderLayout.CENTER);
        JPanel buttonpanel = new JPanel ();
        buttonpanel.setOpaque (false);
        JButton button = (JButton) buttonpanel.add (new JButton (getString ("AboutBox.ok_button_text")));
        panel.add (buttonpanel, BorderLayout.SOUTH);
        button.addActionListener (new OkAction (aboutBox));
    }
    aboutBox.pack ();
    Point p = swingset.getLocationOnScreen ();
    aboutBox.setLocation (p.x + 10, p.y + 10);
    aboutBox.show ();
}


-----Function Pair=141=-----==

public String execute (String command, String path) throws RemoteException, Exception {
    String [] cmd = command.split (" ");
    if (cmd.length == 0) throw new RemoteException ("No command given");
    String [] env = new String [] {};
    File workDir = null;
    if (path == null || new File (path).exists () == false) workDir = new File (AgentApi.getAPI ().getDirectory ());
    else workDir = new File (path);
    Process p = Runtime.getRuntime ().exec (cmd, env, workDir);
    StreamGobbler stdout = new StreamGobbler (p.getInputStream ());
    StreamGobbler stderr = new StreamGobbler (p.getErrorStream ());
    stdout.start ();
    stderr.start ();
    int exitVal = p.waitFor ();
    stdout.join (2000);
    stderr.join (2000);
    String result = stdout.sb.toString ();
    if (exitVal != 0) {
        result += "\n\nEXITCODE: " + exitVal + "\n";
    }
    if (stderr.sb.length () > 0) {
        result += "\n\nSTDERR:\n" + stderr.sb.toString ();
    }
    return result.toString ();
}


public boolean validateMethodSetFullFileName () throws Exception {
    String testRoot = TEST_MethodSetFullFileName;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set (NAME_FileNameRoot, PREFIX_RESULT + testRoot + DOT + TXT);
    sReferencePS.set (NAME_FullFileName, PREFIX_RESULT + testRoot + DOT + TXT);
    sReferencePS.set (NAME_FileNamePrefix, EMPTY);
    sReferencePS.set (NAME_FileNameSuffix, EMPTY);
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS);
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=142=-----==

public void outputError (int code, String value) {
    String statusExplanation;
    statusExplanation = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\"><HTML><HEAD><TITLE>Error " + code + "</TITLE></HEAD><BODY>";
    switch (code) {
        case 404 :
            statusExplanation += "<H1>Not Found</H1>The requested URL " + value + " was not found on this server.";
            break;
        case 400 :
            statusExplanation += "<H1>Bad Request</H1>Your browser sent a request that this server could not understand.<P>Client sent HTTP/1.1 request without hostname (see RFC2068 section 9, and 14.23)";
            break;
        case 501 :
            statusExplanation += "<H1>Method Not Implemented</H1>" + value + " not supported.<P>Invalid method in request " + value + ".";
            break;
        case 505 :
            statusExplanation += "<H1>HTTP Version Not Supported</H1>Your browser uses an HTTP version this server cannot serve. Please upgrade your browser to a version that uses at least HTTP/1.0.";
            break;
        case 601 :
            statusExplanation += "<H1>Protocol Not Implemented</H1>Your browser sent a request using a protocol that is not implemented. <P>Client used protocol " + value + ".";
            break;
    }
    statusExplanation += giveOutputFooter () + "</BODY></HTML>";
    this.outputStatusLine (code);
    this.outputStdHeaders ();
    SimpleDateFormat temp = new SimpleDateFormat ("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
    temp.setTimeZone (new SimpleTimeZone (0, "GMT"));
    String dateStr = temp.format (new Date ());
    this.outputHeader ("Last-Modified: " + dateStr);
    this.outputHeader ("Content-type: " + Misc.getContentType ("error.htm"));
    this.outputHeader ("Content-length: " + statusExplanation.length ());
    this.outputConnectionHeader ();
    this.outputHeader ("");
    if (this.sendBody == true) this.outputSomething (statusExplanation);
    this.outputFlush ();
}


static void runPreprocessor (String name, String base, String cc, Vector macros, Vector values, Vector includes, Hashtable typelibTable, Hashtable cdslibTable, String workspace) throws java.lang.Exception {
    String command;
    if (argEcl.nt && ! cc.equals ("gcc")) {
        command = cc + Const.CPRE_OPT_NT;
    }
    else if (argEcl.linux || cc == "gcc") {
        command = cc + Const.CPRE_OPT_LINUX;
    }
    else {
        command = cc + Const.CPRE_OPT_UX;
    }
    for (int i = 0; i < includes.size (); i ++) {
        String include = (String) includes.elementAt (i);
        if (include != null && include.length () != 0) {
            if (argEcl.nt && ! cc.equals ("gcc")) {
                include = include.replace ('/', '\\');
                command = command + " /I" + include;
            }
            else {
                include = include.replace ('\\', '/');
                command = command + " -I" + include;
            }
        }
    }
    Enumeration libs = typelibTable.keys ();
    while (libs.hasMoreElements ()) {
        String type = (String) libs.nextElement ();
        if (type.equals ("*")) continue;
        if (workspace == null) {
            System.err.println ("Error: -TYPELIB specified without the workspace pathname");
            printUsage (false);
        }
        String lib = (String) typelibTable.get (type);
        String dir = (String) cdslibTable.get (lib);
        if (dir == null) {
            System.err.println ("Error: library " + lib + " is not in the cds.lib file");
            System.exit (- 1);
        }
        if (argEcl.nt && ! cc.equals ("gcc")) dir = dir.replace ('/', '\\');
        else dir = dir.replace ('\\', '/');
        if (argEcl.nt && ! cc.equals ("gcc")) {
            command = command + " /I" + dir + "\\" + type + "\\type_definition";
        }
        else {
            command = command + " -I" + dir + "/" + type + "/type_definition";
        }
    }
    for (int i = 0; i < macros.size (); i ++) {
        String macro = (String) macros.elementAt (i);
        String value = (String) values.elementAt (i);
        if (macro != null && macro.length () != 0) {
            if (argEcl.nt && ! cc.equals ("gcc")) {
                command = command + " /D" + macro;
            }
            else {
                command = command + " -D" + macro;
            }
            if (value != null && value.length () != 0) {
                command = command + "=" + value;
            }
        }
    }
    if (argEcl.linux || cc.equals ("gcc")) {
        command = command + " -x c ";
    }
    else {
        command = command + " ";
    }
    command = command + name;
    runCommand (command, base + ".i", null);
}


-----Function Pair=143=-----==

public static void main (String [] args) {
    try {
        Process_3 p3 = new Process_3 ();
        Thread t = new Thread (p3);
        t.start ();
        synchronized (p3) {
            while (p3.p == null) p3.wait ();
        }
        InputStream is = p3.p.getInputStream ();
        InputStreamReader isr = new InputStreamReader (is);
        BufferedReader br = new BufferedReader (isr);
        String result = br.readLine ();
        if (! "Goodbye World".equals (result)) {
            System.out.println ("bad 1");
            return;
        }
        result = br.readLine ();
        if (result != null) {
            System.out.println ("bad 2");
            return;
        }
        int c = p3.p.waitFor ();
        System.out.println (c == 0 ? "ok" : "bad 3");
    } catch (Exception ex) {
        System.out.println (ex.toString ());
    }
}


private byte [] remTunerFromList (HTTPurl urlData) throws Exception {
    int tunerIndex = - 1;
    try {
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount ()) {
                devList.remDevice (tunerIndex);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=144=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public boolean checkForProg (String [] Prog) {
    int i = 0;
    int j = 0;
    String build_list = "";
    String [] uninstalled = new String [Prog.length];
    while (true) {
        try {
            while (i < Prog.length) {
                Process p = Runtime.getRuntime ().exec (Prog [i]);
                p.destroy ();
                i ++;
            }
            for (i = 0; i < uninstalled.length; i ++) {
                if (uninstalled [i] != null) build_list += uninstalled [i] + "\n";
            }
            if (uninstalled [0] == null) return true;
            else MessageBox ("The following programs are not installed or not in " + "your path!\n" + build_list, 0);
            return false;
        } catch (IOException ioe) {
            uninstalled [j] = Prog [i];
            i ++;
            j ++;
        }
    }
}


-----Function Pair=145=-----==

public void execute () throws BuildException {
    try {
        for (Iterator < Resource > i = classFiles.iterator (); i.hasNext ();) {
            final Resource classFile = i.next ();
            InputStream inputStream = classFile.getInputStream ();
            ClassReader reader = new ClassReader (inputStream);
            MethodIndexer indexer = new MethodIndexer ();
            reader.accept (indexer, 0);
        }
        File [] files = dir.listFiles (new FilenameFilter () {
            public boolean accept (File dir, String name) {
                return name.endsWith (".log");
            }
        }
        );
        if (files == null) throw new BuildException ("Log directory specified in dir parameter does not exist");
        if (files.length == 0) throw new BuildException ("No logs found in directory specified in dir parameter");
        for (int i = 0; i < files.length; i ++) {
            try {
                Reader reader = new FileReader (files [i]);
                String log;
                {
                    StringBuffer sbuf = new StringBuffer ();
                    char [] cbuf = new char [1024];
                    for (int read = reader.read (cbuf); read > 0; read = reader.read (cbuf)) sbuf.append (cbuf, 0, read);
                    log = sbuf.toString ();
                }
                for (Iterator < Method > m = methods.iterator (); m.hasNext ();) log = m.next ().expand (log);
                getProject ().setProperty ("net.yura.tools.stacktrace", log);
            } catch (IOException e) {
                log ("Cannot read log " + files [i].getName (), e, 0);
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


protected void closePool (Map < String, Map < SockIO, Long > > pool) {
    for (Iterator < String > i = pool.keySet ().iterator (); i.hasNext ();) {
        String host = i.next ();
        Map < SockIO, Long > sockets = pool.get (host);
        for (Iterator < SockIO > j = sockets.keySet ().iterator (); j.hasNext ();) {
            SockIO socket = j.next ();
            try {
                socket.trueClose ();
            } catch (IOException ioe) {
                log.error ("++++ failed to trueClose socket: " + socket.toString () + " for host: " + host);
            }
            j.remove ();
            socket = null;
        }
    }
}


-----Function Pair=146=-----==

protected void processJarFile (final File file, final Set classNames) throws Exception {
    File tempFile = File.createTempFile (file.getName (), null, new File (file.getAbsoluteFile ().getParent ()));
    try {
        FileOutputStream fout = new FileOutputStream (tempFile, false);
        try {
            final ZipOutputStream out = new ZipOutputStream (fout);
            ZipEntryHandler transformer = new ZipEntryHandler () {
                public void handleEntry (ZipEntry entry, byte [] byteCode) throws Exception {
                    logger.debug ("starting zip entry : " + entry.toString ());
                    if (! entry.isDirectory ()) {
                        DataInputStream din = new DataInputStream (new ByteArrayInputStream (byteCode));
                        if (din.readInt () == CLASS_MAGIC) {
                            ClassDescriptor descriptor = getClassDescriptor (byteCode);
                            ClassTransformer transformer = getClassTransformer (descriptor, classNames);
                            if (transformer == null) {
                                logger.debug ("no transformer for zip entry :  " + entry.toString ());
                            }
                            else {
                                logger.info ("processing class : " + descriptor.getName () + ";  entry = " + file.getAbsolutePath ());
                                byteCode = transformer.transform (getClass ().getClassLoader (), descriptor.getName (), null, null, descriptor.getBytes ());
                            }
                        }
                        else {
                            logger.debug ("ignoring zip entry : " + entry.toString ());
                        }
                    }
                    ZipEntry outEntry = new ZipEntry (entry.getName ());
                    outEntry.setMethod (entry.getMethod ());
                    outEntry.setComment (entry.getComment ());
                    outEntry.setSize (byteCode.length);
                    if (outEntry.getMethod () == ZipEntry.STORED) {
                        CRC32 crc = new CRC32 ();
                        crc.update (byteCode);
                        outEntry.setCrc (crc.getValue ());
                        outEntry.setCompressedSize (byteCode.length);
                    }
                    out.putNextEntry (outEntry);
                    out.write (byteCode);
                    out.closeEntry ();
                }
            }
            ;
            ZipFileProcessor processor = new ZipFileProcessor (transformer);
            processor.process (file);
            out.close ();
        } finally {
            fout.close ();
        }
        if (file.delete ()) {
            File newFile = new File (tempFile.getAbsolutePath ());
            if (! newFile.renameTo (file)) {
                throw new IOException ("can not rename " + tempFile + " to " + file);
            }
        }
        else {
            throw new IOException ("can not delete " + file);
        }
    } finally {
        if (! tempFile.delete ()) {
            logger.info ("Unable to cleanup temporary jar file : " + tempFile.getAbsolutePath ());
        }
    }
}


private void chunkedDiff (List < Difference > diffs, ChunkPrinter chunkPrinter) {
    Iterator < Difference > it = diffs.iterator ();
    Difference lookahead = it.hasNext () ? it.next () : null;
    while (lookahead != null) {
        List < Difference > agg = new ArrayList < Difference > ();
        agg.add (lookahead);
        for (;;) {
            int afterDeletion = (lookahead.getDeletedEnd () == Difference.NONE ? lookahead.getDeletedStart () : lookahead.getDeletedEnd () + 1);
            lookahead = it.hasNext () ? it.next () : null;
            if (lookahead == null) break;
            if (lookahead.getDeletedStart () - afterDeletion <= 2 * Diff.this.contextSize) {
                agg.add (lookahead);
            }
            else {
                break;
            }
        }
        chunkPrinter.print (agg);
    }
}


-----Function Pair=147=-----==

private void initGUI () {
    try {
        addWindowListener (new WindowAdapter () {
            public void windowClosing (WindowEvent event) {
                System.exit (0);
            }
        }
        );
        setTitle ("Run Defuddle Transform");
        myPanel = new JPanel ();
        GridBagLayout myPanelLayout = new GridBagLayout ();
        myPanelLayout.rowWeights = (new double [] {0.10000000000000001D, 0.10000000000000001D, 0.10000000000000001D, 0.10000000000000001D});
        myPanelLayout.rowHeights = (new int [] {7, 7, 7, 7});
        myPanelLayout.columnWeights = (new double [] {0.10000000000000001D, 0.10000000000000001D, 0.10000000000000001D, 0.10000000000000001D});
        myPanelLayout.columnWidths = (new int [] {7, 7, 7, 7});
        myPanel.setLayout (myPanelLayout);
        getContentPane ().add (myPanel, "Center");
        translateButton = new JButton ();
        myPanel.add (translateButton, new GridBagConstraints (1, 3, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        translateButton.setText ("Translate");
        translateButton.setPreferredSize (new Dimension (108, 22));
        translateButton.addActionListener (translateActionListener);
        dataFile = new JTextField ();
        myPanel.add (dataFile, new GridBagConstraints (1, 0, 1, 1, 0.0D, 0.0D, 10, 2, new Insets (0, 0, 0, 0), 0, 0));
        dfdlSchema = new JTextField ();
        myPanel.add (dfdlSchema, new GridBagConstraints (1, 1, 1, 1, 0.0D, 0.0D, 10, 2, new Insets (0, 0, 0, 0), 0, 0));
        dataBrowse = new JButton ();
        myPanel.add (dataBrowse, new GridBagConstraints (2, 0, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        dataBrowse.setText ("Browse");
        dataBrowse.addActionListener (dataFileActionListener);
        dfdlschemabrowse = new JButton ();
        myPanel.add (dfdlschemabrowse, new GridBagConstraints (2, 1, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        dfdlschemabrowse.setText ("Browse");
        dfdlschemabrowse.addActionListener (dfdlFileActionListener);
        xsltFile = new JTextField ();
        myPanel.add (xsltFile, new GridBagConstraints (1, 2, 1, 1, 0.0D, 0.0D, 10, 2, new Insets (0, 0, 0, 0), 0, 0));
        xsltfileBrowse = new JButton ();
        myPanel.add (xsltfileBrowse, new GridBagConstraints (2, 2, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        xsltfileBrowse.setText ("Browse");
        xsltfileBrowse.addActionListener (xsltFileActionListener);
        datalabel = new JLabel ();
        myPanel.add (datalabel, new GridBagConstraints (0, 0, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        datalabel.setText ("Data:");
        dfdllabel = new JLabel ();
        myPanel.add (dfdllabel, new GridBagConstraints (0, 1, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        dfdllabel.setText ("DFDL Schema:");
        xsltlabel = new JLabel ();
        myPanel.add (xsltlabel, new GridBagConstraints (0, 2, 1, 1, 0.0D, 0.0D, 10, 0, new Insets (0, 0, 0, 0), 0, 0));
        xsltlabel.setText ("XSLT(optional):");
        setDefaultCloseOperation (2);
        pack ();
        setSize (400, 300);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void setGMN (String str, boolean gmncode) {
    m_gmnscore.close ();
    int err = gmncode ? m_gmnscore.ParseString (str) : m_gmnscore.ParseFile (str);
    if (err != guido.guidoNoErr) {
        String msg = gmncode ? new String ("Error reading string:\n") + guido.GetErrorString (err) : new String ("Error opening ") + str + ":\n" + guido.GetErrorString (err);
        if (err == guido.guidoErrParse) {
            if (guido.xml2gmn () && ! gmncode) {
                System.out.println ("try xml 2 guido conversion:");
                String gmn = guido.xml2gmn (str);
                setGMN (gmn, true);
                return;
            }
            msg += " line " + guido.GetParseErrorLine ();
        }
        JOptionPane.showMessageDialog (this, msg);
        m_gmnscore = null;
    }
    else {
        err = m_gmnscore.AR2GR ();
        if (err != guido.guidoNoErr) {
            JOptionPane.showMessageDialog (this, "Error converting AR to GR " + str + ":\n" + guido.GetErrorString (err));
            m_gmnscore = null;
        }
        else {
            m_gmnscore.ResizePageToMusic ();
            repaint ();
        }
    }
}


-----Function Pair=148=-----==

protected void setNewOptions () {
    xecl.Vcc_strCellname = pnl1_txtCellname.getText ();
    xecl.Vcc_strLibname = pnl1_txtLibname.getText ();
    xecl.Vcc_strWorkspace = pnl1_txtWorkspace.getText ();
    xecl.Vcc_strTypelibfile = pnl1_txtTypelibfile.getText ();
    xecl.Vcc_strMainmodule = pnl3_txtMainmodule.getText ();
    xecl.Vcc_strDfttypelib = pnl1_txtDfttypelib.getText ();
    if (! pnl1_txtCellname.getText ().equals ("")) xecl.tabOptionEcl [Const.VCCCELL] = true;
    else xecl.tabOptionEcl [Const.VCCCELL] = false;
    if (! pnl1_txtLibname.getText ().equals ("")) xecl.tabOptionEcl [Const.VCCLIB] = true;
    else xecl.tabOptionEcl [Const.VCCLIB] = false;
    if (! pnl1_txtWorkspace.getText ().equals ("")) xecl.tabOptionEcl [Const.WORKSPACE] = true;
    else xecl.tabOptionEcl [Const.WORKSPACE] = false;
    if (! pnl1_txtTypelibfile.getText ().equals ("")) xecl.tabOptionEcl [Const.TYPELIBFILE] = true;
    else xecl.tabOptionEcl [Const.TYPELIBFILE] = false;
    if (! pnl3_txtMainmodule.getText ().equals ("")) xecl.tabOptionEcl [Const.MAINMODULE] = true;
    else xecl.tabOptionEcl [Const.MAINMODULE] = false;
    if (! pnl1_txtDfttypelib.getText ().equals ("")) xecl.tabOptionEcl [Const.DEFAULTTYPELIB] = true;
    else xecl.tabOptionEcl [Const.DEFAULTTYPELIB] = false;
    if (pnl1_chkImporttypes.isSelected ()) xecl.tabOptionEcl [Const.IMPORTTYPES] = true;
    else xecl.tabOptionEcl [Const.IMPORTTYPES] = false;
}


public boolean XMLToTree (Node root, String xml) {
    org.w3c.dom.Document doc;
    try {
        DOMParser parser = new DOMParser ();
        parser.parse (xml);
        doc = parser.getDocument ();
    } catch (Exception e) {
        System.out.println ("Exception parsing XML string.");
        e.printStackTrace ();
        return false;
    }
    org.w3c.dom.Element e = doc.getDocumentElement ();
    if (e != null) {
        addDaughters (tree.root (), e);
    }
    return true;
}


-----Function Pair=149=-----==

public void initGUI () {
    try {
        jPanelLeft = new JPanel ();
        jLabelName = new JLabel ();
        jTextName = new JTextField ();
        jScrollPane = new JScrollPane ();
        jListColors = new JList ();
        jPanelRight = new JPanel ();
        jLabelRed = new JLabel ();
        jTextRed = new JTextField ();
        jLabelGreen = new JLabel ();
        jTextGreen = new JTextField ();
        jLabelBlue = new JLabel ();
        jTextBlue = new JTextField ();
        jCheckTransparent = new JCheckBox ();
        jPanelColor = new JPanel ();
        BoxLayout thisLayout = new BoxLayout (this.getContentPane (), 0);
        this.getContentPane ().setLayout (thisLayout);
        this.setDefaultCloseOperation (0);
        this.setResizable (false);
        this.setTitle ("Coushe v0.3.0");
        this.setUndecorated (false);
        this.setMaximizedBounds (new java.awt.Rectangle (0, 0, 600, 500));
        this.getContentPane ().setSize (new java.awt.Dimension (457, 399));
        this.setLocation (new java.awt.Point (410, 400));
        this.addWindowListener (new WindowAdapter () {
            public void windowClosing (WindowEvent evt) {
                SwingAppWindowClosing (evt);
            }
        }
        );
        FlowLayout jPanelLeftLayout = new FlowLayout ();
        jPanelLeft.setLayout (jPanelLeftLayout);
        jPanelLeftLayout.setAlignment (0);
        jPanelLeftLayout.setHgap (5);
        jPanelLeftLayout.setVgap (5);
        jPanelLeft.setVisible (true);
        jPanelLeft.setPreferredSize (new java.awt.Dimension (250, 372));
        jPanelLeft.setBorder (new EmptyBorder (new Insets (0, 0, 0, 0)));
        jPanelLeft.setLocation (new java.awt.Point (1, 1));
        jPanelLeft.setBounds (new java.awt.Rectangle (0, 0, 267, 372));
        jPanelLeft.setIgnoreRepaint (false);
        this.getContentPane ().add (jPanelLeft);
        jLabelName.setLayout (null);
        jLabelName.setText ("Color scheme name:");
        jLabelName.setVisible (true);
        jLabelName.setPreferredSize (new java.awt.Dimension (224, 16));
        jLabelName.setBounds (new java.awt.Rectangle (5, 5, 224, 16));
        jPanelLeft.add (jLabelName);
        jTextName.setText ("jTextName");
        jTextName.setVisible (true);
        jTextName.setPreferredSize (new java.awt.Dimension (136, 20));
        jTextName.setBounds (new java.awt.Rectangle (127, 5, 136, 20));
        jPanelLeft.add (jTextName);
        jScrollPane.setHorizontalScrollBarPolicy (30);
        jScrollPane.setVisible (true);
        jScrollPane.setPreferredSize (new java.awt.Dimension (228, 293));
        jScrollPane.setBounds (new java.awt.Rectangle (5, 51, 228, 293));
        jPanelLeft.add (jScrollPane);
        jListColors.setLayout (null);
        jListColors.setVisible (true);
        jScrollPane.add (jListColors);
        jScrollPane.setViewportView (jListColors);
        jListColors.addListSelectionListener (new ListSelectionListener () {
            public void valueChanged (ListSelectionEvent evt) {
                jListColorsValueChanged (evt);
            }
        }
        );
        FlowLayout jPanelRightLayout = new FlowLayout ();
        jPanelRight.setLayout (jPanelRightLayout);
        jPanelRightLayout.setAlignment (1);
        jPanelRightLayout.setHgap (5);
        jPanelRightLayout.setVgap (5);
        jPanelRight.setVisible (true);
        jPanelRight.setForeground (new java.awt.Color (0, 0, 0));
        jPanelRight.setPreferredSize (new java.awt.Dimension (165, 372));
        jPanelRight.setBorder (new EmptyBorder (new Insets (0, 0, 0, 0)));
        jPanelRight.setBounds (new java.awt.Rectangle (267, 0, 182, 372));
        this.getContentPane ().add (jPanelRight);
        jLabelRed.setLayout (null);
        jLabelRed.setText ("Red:");
        jLabelRed.setVisible (true);
        jLabelRed.setPreferredSize (new java.awt.Dimension (60, 20));
        jPanelRight.add (jLabelRed);
        jTextRed.setText ("");
        jTextRed.setVisible (true);
        jTextRed.setPreferredSize (new java.awt.Dimension (60, 20));
        jPanelRight.add (jTextRed);
        jTextRed.addFocusListener (new FocusAdapter () {
            public void focusLost (FocusEvent evt) {
                jTextRedFocusLost (evt);
            }
        }
        );
        jTextRed.addKeyListener (new KeyAdapter () {
            public void keyTyped (KeyEvent evt) {
                jTextRedKeyTyped (evt);
            }
        }
        );
        jLabelGreen.setLayout (null);
        jLabelGreen.setText ("Green:");
        jLabelGreen.setVisible (true);
        jLabelGreen.setPreferredSize (new java.awt.Dimension (60, 20));
        jLabelGreen.setBounds (new java.awt.Rectangle (28, 30, 60, 20));
        jPanelRight.add (jLabelGreen);
        jTextGreen.setText ("");
        jTextGreen.setVisible (true);
        jTextGreen.setPreferredSize (new java.awt.Dimension (60, 20));
        jPanelRight.add (jTextGreen);
        jTextGreen.addFocusListener (new FocusAdapter () {
            public void focusLost (FocusEvent evt) {
                jTextGreenFocusLost (evt);
            }
        }
        );
        jTextGreen.addKeyListener (new KeyAdapter () {
            public void keyTyped (KeyEvent evt) {
                jTextGreenKeyTyped (evt);
            }
        }
        );
        jLabelBlue.setLayout (null);
        jLabelBlue.setText ("Blue:");
        jLabelBlue.setVisible (true);
        jLabelBlue.setPreferredSize (new java.awt.Dimension (60, 20));
        jPanelRight.add (jLabelBlue);
        jTextBlue.setText ("");
        jTextBlue.setVisible (true);
        jTextBlue.setPreferredSize (new java.awt.Dimension (60, 20));
        jTextBlue.setBounds (new java.awt.Rectangle (103, 55, 60, 20));
        jPanelRight.add (jTextBlue);
        jTextBlue.addFocusListener (new FocusAdapter () {
            public void focusLost (FocusEvent evt) {
                jTextBlueFocusLost (evt);
            }
        }
        );
        jTextBlue.addKeyListener (new KeyAdapter () {
            public void keyTyped (KeyEvent evt) {
                jTextBlueKeyTyped (evt);
            }
        }
        );
        jCheckTransparent.setText ("Transparent");
        jCheckTransparent.setVisible (true);
        jPanelRight.add (jCheckTransparent);
        jCheckTransparent.addChangeListener (new ChangeListener () {
            public void stateChanged (ChangeEvent evt) {
                jCheckTransparentStateChanged (evt);
            }
        }
        );
        FlowLayout jPanelColorLayout = new FlowLayout ();
        jPanelColor.setLayout (jPanelColorLayout);
        jPanelColor.setVisible (true);
        jPanelColor.setPreferredSize (new java.awt.Dimension (80, 80));
        jPanelColor.setBorder (new EtchedBorder (1, null, null));
        jPanelRight.add (jPanelColor);
        jMenuBar1 = new JMenuBar ();
        jMenu3 = new JMenu ();
        newFileMenuItem = new JMenuItem ();
        openFileMenuItem = new JMenuItem ();
        saveMenuItem = new JMenuItem ();
        saveAsMenuItem = new JMenuItem ();
        closeFileMenuItem = new JMenuItem ();
        jSeparator2 = new JSeparator ();
        exitMenuItem = new JMenuItem ();
        jMenu5 = new JMenu ();
        helpMenuItem = new JMenuItem ();
        setJMenuBar (jMenuBar1);
        jMenu3.setText ("File");
        jMenu3.setVisible (true);
        jMenuBar1.add (jMenu3);
        newFileMenuItem.setText ("New");
        newFileMenuItem.setVisible (true);
        newFileMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (newFileMenuItem);
        newFileMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                newFileMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                newFileMenuItemMousePressed (evt);
            }
        }
        );
        openFileMenuItem.setText ("Open");
        openFileMenuItem.setVisible (true);
        openFileMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (openFileMenuItem);
        openFileMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                openFileMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                openFileMenuItemMousePressed (evt);
            }
        }
        );
        saveMenuItem.setText ("Save");
        saveMenuItem.setVisible (true);
        saveMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (saveMenuItem);
        saveMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                saveMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                saveMenuItemMousePressed (evt);
            }
        }
        );
        saveAsMenuItem.setText ("Save As ...");
        saveAsMenuItem.setVisible (true);
        saveAsMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (saveAsMenuItem);
        saveAsMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                saveAsMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                saveAsMenuItemMousePressed (evt);
            }
        }
        );
        closeFileMenuItem.setText ("Close");
        closeFileMenuItem.setVisible (true);
        closeFileMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (closeFileMenuItem);
        jSeparator2.setLayout (null);
        jSeparator2.setVisible (true);
        jSeparator2.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (jSeparator2);
        exitMenuItem.setText ("Exit");
        exitMenuItem.setVisible (true);
        exitMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu3.add (exitMenuItem);
        exitMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                exitMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                exitMenuItemMousePressed (evt);
            }
        }
        );
        jMenu5.setText ("Help");
        jMenu5.setVisible (true);
        jMenuBar1.add (jMenu5);
        helpMenuItem.setText ("Help");
        helpMenuItem.setVisible (true);
        helpMenuItem.setBounds (new java.awt.Rectangle (5, 5, 60, 30));
        jMenu5.add (helpMenuItem);
        helpMenuItem.addMouseListener (new MouseAdapter () {
            public void mouseReleased (MouseEvent evt) {
                helpMenuItemMouseReleased (evt);
            } public void mousePressed (MouseEvent evt) {
                helpMenuItemMousePressed (evt);
            }
        }
        );
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private void initComponents () {
    narr = new NarrWriter (narrOut);
    runToHClimb = new javax.swing.JButton ();
    jScrollPane1 = new javax.swing.JScrollPane ();
    log = new javax.swing.JTextArea ();
    npopConf = new javax.swing.JButton ();
    sigmaConf = new javax.swing.JButton ();
    omegaConf = new javax.swing.JButton ();
    driftConf = new javax.swing.JButton ();
    runAll = new javax.swing.JButton ();
    critSelector = new javax.swing.JComboBox ();
    criterion = new javax.swing.JLabel ();
    runAllDemarcs = new javax.swing.JButton ();
    jMenuBar1 = new javax.swing.JMenuBar ();
    fileMenu = new javax.swing.JMenu ();
    openFastaFile = new javax.swing.JMenuItem ();
    openSaveFile = new javax.swing.JMenuItem ();
    saveFile = new javax.swing.JMenuItem ();
    changePCRError = new javax.swing.JMenuItem ();
    exitProgram = new javax.swing.JMenuItem ();
    otherProgMenu = new javax.swing.JMenu ();
    demarcations = new javax.swing.JMenuItem ();
    demarcsAuto = new javax.swing.JMenuItem ();
    execs = new Execs (log);
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent we) {
            printResults ();
            if (narr != null) narr.close ();
            System.exit (0);
        }
    }
    );
    setTitle ("Parameter Solutions");
    runToHClimb.setText ("Run through HillClimbing");
    runToHClimb.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            runToHClimbActionPerformed (evt);
        }
    }
    );
    log.setColumns (20);
    log.setEditable (false);
    log.setRows (5);
    log.setDoubleBuffered (true);
    jScrollPane1.setViewportView (log);
    npopConf.setText ("Run Npop Confidence Interval");
    npopConf.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            npopConfActionPerformed (evt);
        }
    }
    );
    sigmaConf.setText ("Run Sigma Confidence Interval");
    sigmaConf.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            sigmaConfActionPerformed (evt);
        }
    }
    );
    omegaConf.setText ("Run Omega Confidence Interval");
    omegaConf.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            omegaConfActionPerformed (evt);
        }
    }
    );
    driftConf.setText ("Run Drift Confidence Interval");
    driftConf.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            driftConfActionPerformed (evt);
        }
    }
    );
    runAll.setText ("Run Everything (no demarcations)");
    runAll.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            runAllActionPerformed (evt);
        }
    }
    );
    critSelector.setModel (new javax.swing.DefaultComboBoxModel (new String [] {"auto", "5x", "2x", "1.5x", "1.25x", "1.10x", "1.05x"}));
    criterion.setText ("Select Criterion");
    runAllDemarcs.setText ("Run Everything (with demarcations)");
    runAllDemarcs.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            runAllDemarcsActionPerformed (evt);
        }
    }
    );
    fileMenu.setText ("File");
    openFastaFile.setText ("Open Fasta File");
    openFastaFile.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            openFastaFileActionPerformed (evt);
        }
    }
    );
    fileMenu.add (openFastaFile);
    openSaveFile.setText ("Open Saved File");
    openSaveFile.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            openSaveFileActionPerformed (evt);
        }
    }
    );
    fileMenu.add (openSaveFile);
    saveFile.setText ("Save Current Project");
    saveFile.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            saveFileActionPerformed (evt);
        }
    }
    );
    fileMenu.add (saveFile);
    changePCRError.setText ("Modify PCR Error");
    changePCRError.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            changePCRErrorActionPerformed (evt);
        }
    }
    );
    fileMenu.add (changePCRError);
    exitProgram.setText ("Exit");
    exitProgram.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            exitProgramActionPerformed (evt);
        }
    }
    );
    fileMenu.add (exitProgram);
    jMenuBar1.add (fileMenu);
    otherProgMenu.setText ("Other Programs");
    demarcations.setText ("Demarcations");
    demarcations.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            demarcationsActionPerformed (evt);
        }
    }
    );
    otherProgMenu.add (demarcations);
    demarcsAuto.setText ("Demarcations (Auto)");
    demarcsAuto.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            demarcsAutoActionPerformed (evt);
        }
    }
    );
    otherProgMenu.add (demarcsAuto);
    jMenuBar1.add (otherProgMenu);
    setJMenuBar (jMenuBar1);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout (getContentPane ());
    getContentPane ().setLayout (layout);
    layout.setHorizontalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (layout.createSequentialGroup ().addContainerGap ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 483, javax.swing.GroupLayout.PREFERRED_SIZE).addGroup (layout.createSequentialGroup ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING, false).addComponent (runAllDemarcs, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (runAll, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (runToHClimb, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addGroup (layout.createSequentialGroup ().addGap (52, 52, 52).addComponent (critSelector, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap (139, 139, 139)).addGroup (layout.createSequentialGroup ().addGap (44, 44, 44).addComponent (criterion))).addGap (46, 46, 46).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING, false).addComponent (omegaConf, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (sigmaConf, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (npopConf, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (driftConf, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))).addContainerGap (javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)));
    layout.setVerticalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (layout.createSequentialGroup ().addContainerGap ().addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (omegaConf).addComponent (runToHClimb)).addGap (9, 9, 9).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (sigmaConf).addComponent (runAll)).addGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING, false).addGroup (layout.createSequentialGroup ().addGap (15, 15, 15).addComponent (npopConf).addGap (16, 16, 16).addComponent (driftConf)).addGroup (javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup ().addGap (11, 11, 11).addComponent (runAllDemarcs).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE).addComponent (criterion).addGap (18, 18, 18))).addGap (19, 19, 19).addComponent (jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 456, javax.swing.GroupLayout.PREFERRED_SIZE).addGap (40, 40, 40)).addGroup (javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup ().addContainerGap (131, Short.MAX_VALUE).addComponent (critSelector, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE).addGap (507, 507, 507)));
    pack ();
}


-----Function Pair=150=-----==

public static boolean zip (String src, String dest) {
    try {
        File srcFile = new File (src);
        String root = srcFile.getParent ();
        FileOutputStream destFOS = new FileOutputStream ((dest.indexOf (SystemPropertiesEnum.FILE_SEPARATOR.get ()) != - 1) ? dest : root + SystemPropertiesEnum.FILE_SEPARATOR.get () + dest);
        CheckedOutputStream checksum = new CheckedOutputStream (destFOS, new Adler32 ());
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (checksum));
        if (srcFile.isDirectory ()) {
            addFilesInDirToZip (root, srcFile.getAbsolutePath (), out);
        }
        else {
            addFileToZip (root, srcFile, out);
        }
        out.close ();
        return true;
    } catch (Exception e) {
        log.error ("Error zipping files.", e);
    }
    return false;
}


protected void addFileToJar (JarOutputStream jStream, File inputFile, String logicalFilename) throws BuildException {
    FileInputStream iStream = null;
    try {
        if (! addedfiles.contains (logicalFilename)) {
            iStream = new FileInputStream (inputFile);
            ZipEntry zipEntry = new ZipEntry (logicalFilename.replace ('\\', '/'));
            jStream.putNextEntry (zipEntry);
            byte [] byteBuffer = new byte [2 * DEFAULT_BUFFER_SIZE];
            int count = 0;
            do {
                jStream.write (byteBuffer, 0, count);
                count = iStream.read (byteBuffer, 0, byteBuffer.length);
            }
            while (count != - 1);
            addedfiles.add (logicalFilename);
        }
    } catch (IOException ioe) {
        log ("WARNING: IOException while adding entry " + logicalFilename + " to jarfile from " + inputFile.getPath () + " " + ioe.getClass ().getName () + "-" + ioe.getMessage (), Project.MSG_WARN);
    } finally {
        if (iStream != null) {
            try {
                iStream.close ();
            } catch (IOException closeException) {
            }
        }
    }
}


-----Function Pair=151=-----==

public String getDirectory () throws IOException {
    String directory = "";
    String path_filename = getAbsoluteFilename ();
    File file = new File (path_filename);
    if (! file.exists ()) {
        throw new FileNotFoundException (path_filename);
    }
    else if (file.isFile ()) {
        int end = path_filename.lastIndexOf (System.getProperty ("file.separator").charAt (0));
        if (end == - 1) {
            end = 0;
        }
        directory = path_filename.substring (0, end);
    }
    else {
        directory = path_filename;
    }
    return directory;
}


public static final boolean isRegularExpressionMatch (String inInput, String inPattern, boolean inMultiline) {
    boolean outValue = false;
    try {
        RE re = null;
        if (inMultiline) {
            re = new RE (inPattern, RE.REG_DOT_NEWLINE);
        }
        else {
            re = new RE (inPattern);
        }
        outValue = re.isMatch (inInput);
    } catch (REException ree) {
        outValue = false;
    }
    return outValue;
}


-----Function Pair=152=-----==

protected static String getZipEntryName (File directory, File file, boolean pathWithFirstDirectory) throws IOException {
    String ret = file.getPath ();
    String sourcePath = directory.getPath ();
    int ind = ret.indexOf (sourcePath);
    if (ind >= 0) {
        if (pathWithFirstDirectory) {
            sourcePath = sourcePath.replaceAll (directory.getName (), "");
        }
        ret = ret.substring (sourcePath.length ());
    }
    else {
        throw new IOException ("Erreur: getZipEntryName -- ???");
    }
    StringBuffer tmpBuf = new StringBuffer ();
    char tmpChar;
    for (int i = 0; i < ret.length (); i ++) {
        tmpChar = ret.charAt (i);
        if (tmpChar == '\\') {
            tmpBuf.append ('/');
        }
        else {
            tmpBuf.append (tmpChar);
        }
    }
    if (tmpBuf.charAt (0) == '/') {
        return tmpBuf.toString ().substring (1);
    }
    else {
        return tmpBuf.toString ();
    }
}


private String getTaskList (ScheduleItem item) {
    StringBuffer buff = new StringBuffer (1024);
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String selectedTask = store.getProperty ("tasks.deftask");
    if (item != null) {
        selectedTask = item.getPostTask ();
    }
    String [] keys = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    if (selectedTask.length () == 0) buff.append ("<label><input type='radio' name='task' value='none' checked>none</label><br>\n");
    else buff.append ("<label><input type='radio' name='task' value='none'>none</label><br>\n");
    for (int x = 0; x < keys.length; x ++) {
        if (keys [x].equals (selectedTask)) buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "' checked>" + keys [x] + "</label><br>\n");
        else buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "'>" + keys [x] + "</label><br>\n");
    }
    return buff.toString ();
}


-----Function Pair=153=-----==

public void generateText (File input, File output, int width, int height) {
    if (input.isDirectory () && output.isDirectory ()) try {
        File [] dir = input.listFiles ();
        Vector < File > v = new Vector < File > ();
        for (int i = 0; i < dir.length; i ++) try {
            String end = dir [i].toString ().substring (dir [i].toString ().lastIndexOf (".") + 1, dir [i].toString ().length ());
            if (dir [i].isFile () && (end.equalsIgnoreCase ("jpg") || end.equalsIgnoreCase ("jpeg"))) v.addElement (dir [i]);
        } catch (Exception st) {
        }
        System.out.println (v.size () + m.mes.getString ("Generator.28") + input.toString () + m.mes.getString ("Generator.29") + quality + m.mes.getString ("Generator.30") + Options.ls + Options.ls);
        for (int i = 0; i < v.size (); i ++) {
            System.out.print (m.mes.getString ("Generator.10") + v.elementAt (i).getName () + "\t . . . ");
            generateImage (v.elementAt (i), output, true, o.getHmax (), o.getVmax (), m.mes.getString ("Generator.22"));
            System.out.println (m.mes.getString ("Generator.12"));
        }
        System.out.println (Options.ls + v.size () + m.mes.getString ("Generator.46") + Options.ls);
    } catch (Exception ex) {
        System.out.println (ex);
    }
    else if (input.isFile ()) {
        try {
            generateImage (input, output, true, o.getHmax (), o.getVmax (), m.mes.getString ("Generator.22"));
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


public ArrayList < PluginInformation > getPluginInformation () {
    ArrayList < PluginInformation > al = new ArrayList < PluginInformation > ();
    File dir = new File (System.getProperty ("user.dir") + System.getProperty ("file.separator") + "plugins");
    if (StartOssoBook.isDevelopmentMode) {
        try {
            IPlugin plugin = new analysis.Main ();
            PluginInformation info = plugin.getPluginInformation ();
            String command = info.getName ();
            while (plugins.containsKey (command)) {
                command += "1";
            }
            info.setActionCommand (command);
            plugins.put (command, plugin);
            al.add (info);
            System.out.println ("this");
        } catch (Throwable ex) {
            ex.printStackTrace ();
        }
    }
    if (! dir.exists ()) {
        return al;
    }
    for (File file : dir.listFiles ()) {
        try {
            if (file.isDirectory ()) {
                continue;
            }
            Class < IPlugin > clasz = PluginLoader.loadPlugin (file.getName ());
            IPlugin plugin = clasz.newInstance ();
            PluginInformation info = plugin.getPluginInformation ();
            String command = info.getName ();
            while (plugins.containsKey (command)) {
                command += "1";
            }
            info.setActionCommand (command);
            plugins.put (command, plugin);
            al.add (info);
        } catch (InstantiationException ex) {
            Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        } catch (NoSuchMethodError ex) {
            Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
    return al;
}


-----Function Pair=154=-----==

public static boolean unzipFiles (File zipFile, File outputDir) {
    if (zipFile == null || ! zipFile.exists () || zipFile.isDirectory () || ! makeDir (outputDir)) {
        return false;
    }
    ZipInputStream in = null;
    try {
        BufferedOutputStream out = null;
        in = new ZipInputStream (new BufferedInputStream (new FileInputStream (zipFile)));
        ZipEntry entry;
        while ((entry = in.getNextEntry ()) != null) {
            try {
                int count;
                byte data [] = new byte [1000];
                File outputFile = new File (outputDir, entry.getName ());
                out = new BufferedOutputStream (new FileOutputStream (outputFile), 1000);
                while ((count = in.read (data, 0, 1000)) != - 1) {
                    out.write (data, 0, count);
                }
            } finally {
                if (out != null) {
                    out.flush ();
                    out.close ();
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        FileUtil.close (in);
    }
    return true;
}


File createJar (String name, String...entries) throws IOException {
    File jar = new File (name);
    OutputStream out = new FileOutputStream (jar);
    try {
        JarOutputStream jos = new JarOutputStream (out);
        for (String e : entries) {
            jos.putNextEntry (new ZipEntry (e));
            jos.write (e.getBytes ());
        }
        jos.close ();
    } finally {
        out.close ();
    }
    return jar;
}


-----Function Pair=155=-----==

private void zipFiles (List < File > files, HttpServletResponse response) {
    try {
        BufferedInputStream origin = null;
        ZipOutputStream out = new ZipOutputStream (response.getOutputStream ());
        byte data [] = new byte [BUFFER];
        for (int i = 0; i < files.size (); i ++) {
            FileInputStream fi = new FileInputStream (files.get (i));
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (files.get (i).getName ());
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (Exception e) {
        log.error (e);
    }
}


public static boolean zipContainsEntry (final String zipFilename, final String locationWithinZip) {
    ZipFile zipFile = null;
    try {
        zipFile = new ZipFile (zipFilename);
        getZipEntry (zipFile, locationWithinZip);
        return true;
    } catch (IOException e) {
        return false;
    } finally {
        try {
            if (zipFile != null) {
                zipFile.close ();
            }
        } catch (IOException e) {
        }
    }
}


-----Function Pair=156=-----==

private synchronized void drawMySelfHighQuality (Graphics2D g) {
    AffineTransform oldTransform = g.getTransform ();
    if (backgroundColor != null) {
        g.setPaint (backColor);
        g.fillRect (0, 0, size [0], size [1]);
    }
    if (backgroundImage != null) {
        AffineTransform scaledTransform = AffineTransform.getScaleInstance (scaleFactorX, scaleFactorY);
        if (backposition != 0) g.translate (backposition, 0);
        g.transform (scaledTransform);
        origBackImage = CDoxFrame.loadImage (TempFiles.get (backgroundSource));
        if ((scaleFactorX < 0.3f) || (scaleFactorY < 0.3f)) {
            int count = 0;
            int x = origBackImage.getWidth ();
            int widthx = x;
            int height = origBackImage.getHeight ();
            int positionX = 0;
            if (((scaleFactorX < 0.3f) && (scaleFactorX > 0.2f)) || ((scaleFactorY < 0.3f) && (scaleFactorX > 0.2f))) {
                widthx = x / 2;
                count = 2;
            }
            else if (((scaleFactorX <= 0.2f) && (scaleFactorX > 0.1f)) || ((scaleFactorY <= 0.2f) && (scaleFactorX > 0.1f))) {
                widthx = x / 3;
                count = 3;
            }
            else if (((scaleFactorX <= 0.1f) && (scaleFactorX > 0.01f)) || ((scaleFactorY <= 0.1f) && (scaleFactorX > 0.01f))) {
                widthx = x / 4;
                count = 4;
            }
            BufferedImage temp = origBackImage.getSubimage (positionX, 0, widthx, height);
            for (int i = 0; i < count; i ++) {
                AffineTransform at = g.getTransform ();
                g.translate (positionX, 0);
                g.drawImage (temp, 0, 0, null);
                temp = null;
                System.gc ();
                if (i < count - 1) {
                    positionX = (i + 1) * widthx;
                    temp = origBackImage.getSubimage (positionX, 0, widthx, height);
                }
                g.setTransform (at);
            }
        }
        else g.drawImage (origBackImage, 0, 0, null);
        origBackImage = null;
        System.gc ();
        g.setTransform (oldTransform);
    }
    for (int i = 0; i < elements.size (); i ++) {
        Element currentElement = (Element) elements.get (i);
        Point elementPosition = currentElement.getPosition ();
        g.translate (elementPosition.x, elementPosition.y);
        currentElement.createCachedImage ();
        g.transform (currentElement.getPrintableAffineTransform ());
        g.drawImage (currentElement.getBufferedImage (), 0, 0, null);
        g.setTransform (oldTransform);
    }
    paintCoverBorders (g);
}


private File makeJar (String filename, File archive, File license, File readme, byte [] archiveInfos) throws IOException {
    File jar = new File (filename);
    JarOutputStream out = new JarOutputStream (new FileOutputStream (jar));
    copyInternalToJar (out, JAR_FILES_COMMON);
    copyInternalToJar (out, JAR_FILES_JNIREGISTRY);
    copyInternalToJar (out, JAR_FILES_JNISHORTCUT);
    copyInternalToJar (out, JAR_FILES_TEXT_UI);
    copyInternalToJar (out, JAR_FILES_ANSI_UI);
    if (uiMode_.equals ("graphic") == true) {
        copyInternalToJar (out, JAR_FILES_GRAPHIC_UI);
    }
    if (uiMode_.equals ("xtra") == true) {
        copyInternalToJar (out, JAR_FILES_XTRA_UI);
    }
    addToJar (out, new ByteArrayInputStream (archiveInfos), "com/memoire/vainstall/archive_infos", archiveInfos.length);
    addToJar (out, new FileInputStream (archive), "com/memoire/vainstall/archive.zip", archive.length ());
    InputStream licenseStream = new FileInputStream (license);
    String licenseEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.license.encoding");
    if (licenseEncoding == null || licenseEncoding.equals ("") == true) {
        licenseEncoding = new InputStreamReader (licenseStream).getEncoding ();
    }
    InputStreamReader isrLicense = new InputStreamReader (licenseStream, licenseEncoding);
    addToJarEncoded (out, isrLicense, "com/memoire/vainstall/license.txt", license.length ());
    InputStream readmeStream = new FileInputStream (readme);
    String readmeEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.readme.encoding");
    if (readmeEncoding == null || readmeEncoding.equals ("") == true) {
        readmeEncoding = new InputStreamReader (readmeStream).getEncoding ();
    }
    InputStreamReader isrReadme = new InputStreamReader (readmeStream, readmeEncoding);
    addToJarEncoded (out, isrReadme, "com/memoire/vainstall/readme.txt", readme.length ());
    InputStream invaiimage = null;
    try {
        invaiimage = new FileInputStream (new File (image_));
    } catch (Exception exc) {
        image_ = "/" + image_;
        invaiimage = getClass ().getResourceAsStream (image_);
    }
    if (invaiimage == null) {
        invaiimage = getClass ().getResourceAsStream (IMAGE_KEY);
        image_ = "com/memoire/vainstall/resources/banner.gif";
    }
    if (invaiimage != null) {
        addToJar (out, invaiimage, IMAGE_KEY, invaiimage.available ());
    }
    InputStream invailogo = getClass ().getResourceAsStream ("/" + VAILOGO);
    addToJar (out, invailogo, VAILOGO, invailogo.available ());
    invailogo.close ();
    ByteArrayOutputStream poutstream = new ByteArrayOutputStream ();
    installProperties.store (poutstream, VAGlobals.NAME + " " + VAGlobals.VERSION);
    ByteArrayInputStream pinstream = new ByteArrayInputStream (poutstream.toByteArray ());
    addToJar (out, pinstream, "com/memoire/vainstall/resources/vainstall.properties", poutstream.toByteArray ().length);
    out.close ();
    return jar;
}


-----Function Pair=157=-----==

public static void main (String argv []) {
    try {
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream ("./archive/mail.zip");
        CheckedOutputStream checksum = new CheckedOutputStream (dest, new Adler32 ());
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (checksum));
        byte data [] = new byte [BUFFER];
        File f = new File ("./corrig�s");
        String files [] = f.list ();
        for (int i = 0; i < files.length; i ++) {
            System.out.println ("Adding: " + files [i]);
            FileInputStream fi = new FileInputStream (files [i]);
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (files [i]);
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
        System.out.println ("checksum: " + checksum.getChecksum ().getValue ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


private void genOtherFile (Admin admin, String orgId, HashMap < String, ResourceDataVO > resources, String fileName, HttpServletRequest req, HttpServletResponse resp) throws IOException, InvalidKeyException, UnrecoverableKeyException, NoSuchAlgorithmException, SignatureException, CertificateException, KeyStoreException, NoSuchProviderException, CertStoreException, InvalidAlgorithmParameterException, CMSException {
    ResourceDataVO resource = resources.get (fileName);
    if (resource == null) {
        resp.sendError (HttpServletResponse.SC_NOT_FOUND);
    }
    else {
        if (resource.getType ().equals (Constants.RESOURCE_TYPE_CUSTOMCODEJAR)) {
            resp.setContentType ("application/java-archive");
            jarSigner.signJarFile (resource.getData (), resp.getOutputStream ());
            resp.setDateHeader ("Last-Modified", System.currentTimeMillis ());
            resp.setStatus (HttpServletResponse.SC_OK);
        }
        else {
            if (resource.getApplication ().equals (Constants.APPLICATION_ALL) || resource.getApplication ().equals (Constants.APPLICATION_WEBPAGES) || resource.getApplication ().equals (application)) {
                String contentType = getContentType (fileName);
                byte [] resourceData = resource.getData ();
                if (contentType.equals ("text/html")) {
                    String htmlData = new String (resourceData);
                    htmlData = htmlData.replaceAll (HTML_REPLACEVAR_ORGID, orgId);
                    resourceData = htmlData.getBytes ();
                }
                resp.setContentType (contentType);
                resp.setContentLength (resourceData.length);
                resp.getOutputStream ().write (resourceData);
                resp.setDateHeader ("Last-Modified", System.currentTimeMillis ());
                resp.setStatus (HttpServletResponse.SC_OK);
            }
            else {
                resp.sendError (HttpServletResponse.SC_NOT_FOUND);
            }
        }
    }
}


-----Function Pair=158=-----==

private static void buildImageFile (File svgFile, File imageFile) throws IOException {
    if (imageFile.exists () && imageFile.length () > 0 && imageFile.lastModified () > svgFile.lastModified ()) return;
    System.err.println ("working on " + svgFile);
    SVGSignSource source = new SVGSignSource (svgFile);
    if (source.hasNext ()) {
        source.next ();
        ShapeChar shapeChar = source.getCurrentShape ();
        jsesh.hieroglyphs.HieroglyphicBitmapBuilder builder = new jsesh.hieroglyphs.HieroglyphicBitmapBuilder ();
        builder.setSize (56);
        builder.setMaxSize (20);
        builder.setFit (true);
        builder.setTransparent (true);
        BufferedImage b = builder.buildSignBitmap (shapeChar);
        ImageIO.write (b, "png", imageFile);
    }
}


public void run () {
    try {
        File tempFile = File.createTempFile ("ZIPAnywhere", ".tmp");
        zipOutStream = new ZipOutputStream (new FileOutputStream (tempFile));
        if (zipFile.length () != 0) {
            ZipFile newZip = new ZipFile (zipFile);
            for (Enumeration eZip = newZip.entries (); eZip.hasMoreElements ();) {
                ZipEntry entry = (ZipEntry) eZip.nextElement ();
                try {
                    zipOutStream.putNextEntry (entry);
                    InputStream inputStream = newZip.getInputStream (entry);
                    do {
                        int j = inputStream.read (buffer, 0, buffer.length);
                        if (j <= 0) {
                            break;
                        }
                        zipOutStream.write (buffer, 0, j);
                    }
                    while (true);
                    inputStream.close ();
                } catch (IOException e) {
                    continue;
                }
            }
            newZip.close ();
        }
        for (int i = 0; i < files.length; i ++) {
            if (files [i].isDirectory ()) {
                addDir (files [i]);
            }
            else {
                addFile (files [i]);
            }
        }
        zipOutStream.close ();
        String filename = zipFile.getAbsolutePath ().replace (File.separatorChar, '/');
        if (zipFile.exists ()) {
            new File (filename).delete ();
        }
        tempFile.renameTo (new File (filename));
    } catch (Exception exception) {
        exception.printStackTrace ();
    }
}


-----Function Pair=159=-----==

public < T > T readObject (ByteBuffer data, Class < T > c) throws IOException {
    try {
        ZIPCompressedMessage result = new ZIPCompressedMessage ();
        byte [] byteArray = new byte [data.remaining ()];
        data.get (byteArray);
        ZipInputStream in = new ZipInputStream (new ByteArrayInputStream (byteArray));
        in.getNextEntry ();
        ByteArrayOutputStream out = new ByteArrayOutputStream ();
        byte [] tmp = new byte [9012];
        int read;
        while (in.available () > 0 && ((read = in.read (tmp)) > 0)) {
            out.write (tmp, 0, read);
        }
        in.closeEntry ();
        out.flush ();
        in.close ();
        result.setMessage ((Message) Serializer.readClassAndObject (ByteBuffer.wrap (out.toByteArray ())));
        return (T) result;
    } catch (Exception e) {
        e.printStackTrace ();
        throw new IOException (e.toString ());
    }
}


public final void writeUnmodifiedClasses () throws IOException, IllegalStateException {
    passUnmodifiedClasses = false;
    makeOutputJar ();
    for (int i = 0; i < inputs.size (); i ++) {
        Input in = inputs.get (i);
        if (! in.isClass ()) {
            if (in instanceof JarInput) {
                JarInput jin = (JarInput) in;
                ZipEntry entry = jin.getEntry ();
                InputStream s = jin.open ();
                try {
                    ZipEntry newEntry = new ZipEntry (entry.getName ());
                    newEntry.setComment (entry.getComment ());
                    newEntry.setExtra (entry.getExtra ());
                    newEntry.setTime (entry.getTime ());
                    putNextEntry (newEntry);
                    copyStream (s, outputJar);
                    outputJar.closeEntry ();
                } finally {
                    s.close ();
                }
            }
            else {
                throw new Error ("Unknown non-class input: " + in);
            }
        }
        else {
            String name = in.getClassName ();
            if (name == null) {
                BufferedInputStream s = new BufferedInputStream (in.open (), 65536);
                try {
                    Object cl = makeClassFromStream (s);
                    String entryName = toEntryName (getClassName (cl));
                    if (! entryNames.contains (entryName)) {
                        putNextEntry (new ZipEntry (entryName));
                        BufferedOutputStream clOut = new BufferedOutputStream (outputJar);
                        writeClassTo (cl, null, clOut);
                        clOut.flush ();
                        outputJar.closeEntry ();
                    }
                } finally {
                    s.close ();
                }
            }
            else {
                String entryName = toEntryName (name);
                if (! entryNames.contains (entryName)) {
                    BufferedInputStream s = new BufferedInputStream (in.open ());
                    try {
                        putNextEntry (new ZipEntry (entryName));
                        BufferedOutputStream clOut = new BufferedOutputStream (outputJar);
                        copyStream (s, clOut);
                        clOut.flush ();
                        outputJar.closeEntry ();
                    } finally {
                        s.close ();
                    }
                }
            }
        }
    }
}


-----Function Pair=160=-----==

public void actionPerformed (ActionEvent e) {
    if (e.getSource ().equals (jButtonCancel)) {
        this.dispose ();
    }
    if (e.getSource ().equals (jButtonCreate)) {
        String defaultFileName = "PACKAGEDirectory" + File.separator + "preview.zip";
        File fdir = new File (defaultFileName);
        File absDir = new File (fdir.getAbsolutePath ());
        int numberOfQuestions = jQuestionPool.getRowCount ();
        int [] selectedQuestions = new int [numberOfQuestions];
        int row = 0;
        for (int rows = 0; rows < numberOfQuestions; rows ++) {
            if (jQuestionPool.getValueAt (rows, 1) == null) {
                tableModelQ.setValueAt (false, rows, 1);
            }
        }
        for (int rows = 0; rows < numberOfQuestions; rows ++) {
            if ((Boolean) jQuestionPool.getValueAt (rows, 1)) {
                selectedQuestions [row] = rows;
                row ++;
            }
        }
        if (row == 1 || row == 0) {
            JOptionPane.showMessageDialog (null, "Test Mode must be at least 2 Questions", "More Questions", JOptionPane.INFORMATION_MESSAGE);
        }
        else {
            String [] Questions = new String [row];
            for (int j = 0; j < row; j ++) {
                Questions [j] = "Question_" + j;
            }
            ContentPackageBuilder cpBuilder = new ContentPackageBuilder (owner, documentListQuiz, absDir.getParent (), "", selectedQuestions, Questions, row);
            cpBuilder.buildPackage (row);
            String outfile = "PACKAGEDirectory" + File.separator + "htm" + File.separator + "preview.html";
            Previewer myPreviewer = new Previewer (absDir.getAbsolutePath (), outfile, "SAVE");
            myPreviewer.run ();
            JFileChooser jFileChooserSaveTest = new JFileChooser ();
            int returnVal = jFileChooserSaveTest.showSaveDialog (owner);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file = jFileChooserSaveTest.getSelectedFile ();
                String oldPath = file.getAbsolutePath ();
                if (! oldPath.contains (".")) {
                    oldPath = oldPath + ".zip";
                }
                String tmpPath = getZipPath ();
                int posDot = tmpPath.lastIndexOf (".");
                strSource = tmpPath.substring (0, posDot);
                strTarget = oldPath;
                zip ();
                this.dispose ();
            }
        }
    }
    if (e.getSource ().equals (jButtonPreviewQuiz)) {
        String defaultFileName = "PACKAGEDirectory" + File.separator + "preview.zip";
        File fdir = new File (defaultFileName);
        File absDir = new File (fdir.getAbsolutePath ());
        int numberOfQuestions = jQuestionPool.getRowCount ();
        int [] selectedQuestions = new int [numberOfQuestions];
        int row = 0;
        for (int rows = 0; rows < numberOfQuestions; rows ++) {
            if (jQuestionPool.getValueAt (rows, 1) == null) {
                tableModelQ.setValueAt (false, rows, 1);
            }
        }
        for (int rows = 0; rows < numberOfQuestions; rows ++) {
            if ((Boolean) jQuestionPool.getValueAt (rows, 1)) {
                selectedQuestions [row] = rows;
                row ++;
            }
        }
        if (row == 1 || row == 0) {
            JOptionPane.showMessageDialog (null, "Test Mode must be at least 2 Questions", "More Questions", JOptionPane.INFORMATION_MESSAGE);
        }
        else {
            String [] Questions = new String [row];
            for (int j = 0; j < row; j ++) {
                Questions [j] = "Question_" + j;
            }
            ContentPackageBuilder cpBuilder = new ContentPackageBuilder (owner, documentListQuiz, absDir.getParent (), "", selectedQuestions, Questions, row);
            cpBuilder.buildPackage (row);
            String outfile = "PACKAGEDirectory" + File.separator + "htm" + File.separator + "preview.html";
            Previewer myPreviewer = new Previewer (absDir.getAbsolutePath (), outfile);
            myPreviewer.run ();
        }
    }
    if (e.getSource ().equals (jButtonUp)) {
        int rowSelected = jQuestionPool.getSelectedRow ();
        AssessmentItemDoc TempDocList = documentListQuiz.get (rowSelected - 1);
        documentListQuiz.set (rowSelected - 1, documentListQuiz.get (rowSelected));
        documentListQuiz.set (rowSelected, TempDocList);
        tableModelQ.moveRow (rowSelected, rowSelected, rowSelected - 1);
        ListSelectionModel ListSelection2 = jQuestionPool.getSelectionModel ();
        ListSelection2.setSelectionInterval (rowSelected - 1, rowSelected - 1);
        System.out.println ("rowselectedUP : " + rowSelected);
        checkUpDownButtons ();
        System.out.println ("rowselectedUP : " + rowSelected);
    }
    if (e.getSource ().equals (jButtonDown)) {
        int rowSelected = jQuestionPool.getSelectedRow ();
        AssessmentItemDoc TempDocList = documentListQuiz.get (rowSelected + 1);
        documentListQuiz.set (rowSelected + 1, documentListQuiz.get (rowSelected));
        documentListQuiz.set (rowSelected, TempDocList);
        tableModelQ.moveRow (rowSelected, rowSelected, rowSelected + 1);
        ListSelectionModel ListSelection2 = jQuestionPool.getSelectionModel ();
        ListSelection2.setSelectionInterval (rowSelected + 1, rowSelected + 1);
        System.out.println ("rowselectedDOWN : " + rowSelected);
        checkUpDownButtons ();
        System.out.println ("rowselectedDOWN : " + rowSelected);
    }
}


private static int zipRecurs (final File _rootDir, final File _dir, final ZipOutputStream _zos, ProgressionInterface _prog, int nbFiles, int indFile) throws IOException {
    URI root = _rootDir.toURI ();
    for (File f : _dir.listFiles ()) {
        String name = root.relativize (f.toURI ()).getPath ();
        if (f.isDirectory ()) {
            _zos.putNextEntry (new ZipEntry (name.endsWith ("/") ? name : name + "/"));
            _zos.closeEntry ();
            indFile = zipRecurs (_rootDir, f, _zos, _prog, nbFiles, indFile);
        }
        else {
            _zos.putNextEntry (new ZipEntry (name));
            FileInputStream finp = new FileInputStream (f);
            copyStream (finp, _zos, true, false);
            _zos.closeEntry ();
        }
        if (_prog != null) {
            indFile ++;
            _prog.setProgression ((int) ((indFile / (double) nbFiles) * 85) + 10);
        }
    }
    return indFile;
}


-----Function Pair=161=-----==

private String [] runIdentification (DigitalObject digo) throws Exception {
    WorkflowResultItem wfResultItem = new WorkflowResultItem (WorkflowResultItem.SERVICE_ACTION_IDENTIFICATION, System.currentTimeMillis ());
    wfResultItem.addLogInfo ("STEP 2: Identification");
    List < Parameter > parameterList;
    if (this.getServiceCallConfigs (identify) != null) {
        parameterList = this.getServiceCallConfigs (identify).getAllPropertiesAsParameters ();
    }
    else {
        parameterList = new ArrayList < Parameter > ();
    }
    IdentifyResult results = identify.identify (digo, parameterList);
    wfResultItem.setEndTime (System.currentTimeMillis ());
    wfResultItem.setInputDigitalObjectRef (digo.getPermanentUri ());
    wfResultItem.setServiceParameters (parameterList);
    wfResultItem.setServiceEndpoint (identify.describe ().getEndpoint ());
    ServiceReport report = results.getReport ();
    List < URI > types = results.getTypes ();
    wfResultItem.setServiceReport (report);
    if (report.getType () == Type.ERROR) {
        String s = "Service execution failed: " + report.getMessage ();
        wfResultItem.addLogInfo (s);
        throw new Exception (s);
    }
    if (types.size () < 1) {
        String s = "The specified file type is currently not supported by this workflow";
        wfResultItem.addLogInfo (s);
        throw new Exception (s);
    }
    String [] strings = new String [types.size ()];
    int count = 0;
    for (URI uri : types) {
        strings [count] = uri.toASCIIString ();
        wfResultItem.addExtractedInformation (strings [count]);
        count ++;
    }
    return strings;
}


private void writeManifest (Context context, Item item, PackageParameters params, OutputStream out) throws PackageValidationException, CrosswalkException, AuthorizeException, SQLException, IOException {
    try {
        Mets mets = new Mets ();
        mets.setID (gensym ("mets"));
        mets.setOBJID ("hdl:" + item.getHandle ());
        mets.setLABEL ("DSpace Item");
        mets.setPROFILE (getProfile ());
        MetsHdr metsHdr = new MetsHdr ();
        metsHdr.setCREATEDATE (new Date ());
        Agent agent = new Agent ();
        agent.setROLE (Role.CUSTODIAN);
        agent.setTYPE (Type.ORGANIZATION);
        Name name = new Name ();
        name.getContent ().add (new PCData (ConfigurationManager.getProperty ("dspace.name")));
        agent.getContent ().add (name);
        metsHdr.getContent ().add (agent);
        mets.getContent ().add (metsHdr);
        String dmdTypes [] = getDmdTypes (params);
        String dmdGroup = gensym ("dmd_group");
        String dmdId [] = new String [dmdTypes.length];
        for (int i = 0; i < dmdTypes.length; ++ i) {
            dmdId [i] = gensym ("dmd");
            XmlData xmlData = new XmlData ();
            String xwalkName, metsName;
            String parts [] = dmdTypes [i].split (":", 2);
            if (parts.length > 1) {
                metsName = parts [0];
                xwalkName = parts [1];
            }
            else xwalkName = metsName = dmdTypes [i];
            DisseminationCrosswalk xwalk = (DisseminationCrosswalk) PluginManager.getNamedPlugin (DisseminationCrosswalk.class, xwalkName);
            if (xwalk == null) throw new PackageValidationException ("Cannot find " + dmdTypes [i] + " crosswalk plugin!");
            else crosswalkToMets (xwalk, item, xmlData);
            DmdSec dmdSec = new DmdSec ();
            dmdSec.setID (dmdId [i]);
            dmdSec.setGROUPID (dmdGroup);
            MdWrap mdWrap = new MdWrap ();
            setMdType (mdWrap, metsName);
            mdWrap.getContent ().add (xmlData);
            dmdSec.getContent ().add (mdWrap);
            mets.getContent ().add (dmdSec);
        }
        String licenseID = null;
        try {
            AmdSec amdSec = new AmdSec ();
            addRightsMd (context, item, amdSec);
            if (amdSec.getContent ().size () > 0) {
                licenseID = gensym ("license");
                amdSec.setID (licenseID);
                mets.getContent ().add (amdSec);
            }
        } catch (AuthorizeException e) {
            String unauth = (params == null) ? null : params.getProperty ("unauthorized");
            if (! (unauth != null && unauth.equalsIgnoreCase ("skip"))) throw e;
            else log.warn ("Skipping license metadata because of access failure: " + e.toString ());
        }
        FileSec fileSec = new FileSec ();
        String techMdType = getTechMdType (params);
        String parts [] = techMdType.split (":", 2);
        String xwalkName, metsName;
        if (parts.length > 1) {
            metsName = parts [0];
            xwalkName = parts [1];
        }
        else xwalkName = metsName = techMdType;
        DisseminationCrosswalk xwalk = (DisseminationCrosswalk) PluginManager.getNamedPlugin (DisseminationCrosswalk.class, xwalkName);
        if (xwalk == null) throw new PackageValidationException ("Cannot find " + xwalkName + " crosswalk plugin!");
        String primaryBitstreamFileID = null;
        List contentDivs = new ArrayList ();
        String unauth = (params == null) ? null : params.getProperty ("unauthorized");
        Bundle [] bundles = item.getBundles ();
        for (int i = 0; i < bundles.length; i ++) {
            if (PackageUtils.isMetaInfoBundle (bundles [i])) continue;
            if (! AuthorizeManager.authorizeActionBoolean (context, bundles [i], Constants.READ)) {
                if (unauth != null && (unauth.equalsIgnoreCase ("skip"))) continue;
                else throw new AuthorizeException ("Not authorized to read Bundle named \"" + bundles [i].getName () + "\"");
            }
            Bitstream [] bitstreams = bundles [i].getBitstreams ();
            FileGrp fileGrp = new FileGrp ();
            String bName = bundles [i].getName ();
            if ((bName != null) && ! bName.equals ("")) fileGrp.setUSE (bundleToFileGrp (bName));
            int primaryBitstreamID = - 1;
            boolean isContentBundle = false;
            if ((bName != null) && bName.equals ("ORIGINAL")) {
                isContentBundle = true;
                primaryBitstreamID = bundles [i].getPrimaryBitstreamID ();
            }
            for (int bits = 0; bits < bitstreams.length; bits ++) {
                boolean auth = AuthorizeManager.authorizeActionBoolean (context, bitstreams [bits], Constants.READ);
                if (! auth) {
                    if (unauth != null && unauth.equalsIgnoreCase ("skip")) continue;
                    else if (! (unauth != null && unauth.equalsIgnoreCase ("zero"))) throw new AuthorizeException ("Not authorized to read Bitstream, SID=" + String.valueOf (bitstreams [bits].getSequenceID ()));
                }
                String sid = String.valueOf (bitstreams [bits].getSequenceID ());
                edu.harvard.hul.ois.mets.File file = new edu.harvard.hul.ois.mets.File ();
                String xmlIDstart = "bitstream_";
                String fileID = xmlIDstart + sid;
                file.setID (fileID);
                if (bitstreams [bits].getID () == primaryBitstreamID) primaryBitstreamFileID = fileID;
                if (isContentBundle) {
                    Div div = new Div ();
                    div.setID (gensym ("div"));
                    div.setTYPE ("DSpace Content Bitstream");
                    Fptr fptr = new Fptr ();
                    fptr.setFILEID (fileID);
                    div.getContent ().add (fptr);
                    contentDivs.add (div);
                }
                file.setSEQ (bitstreams [bits].getSequenceID ());
                String groupID = "GROUP_" + xmlIDstart + sid;
                if ((bundles [i].getName () != null) && (bundles [i].getName ().equals ("THUMBNAIL") || bundles [i].getName ().startsWith ("TEXT"))) {
                    Bitstream original = findOriginalBitstream (item, bitstreams [bits]);
                    if (original != null) {
                        groupID = "GROUP_" + xmlIDstart + original.getSequenceID ();
                    }
                }
                file.setGROUPID (groupID);
                file.setMIMETYPE (bitstreams [bits].getFormat ().getMIMEType ());
                file.setSIZE (auth ? bitstreams [bits].getSize () : 0);
                String csType = bitstreams [bits].getChecksumAlgorithm ();
                String cs = bitstreams [bits].getChecksum ();
                if (auth && cs != null && csType != null) {
                    try {
                        file.setCHECKSUMTYPE (Checksumtype.parse (csType));
                        file.setCHECKSUM (cs);
                    } catch (MetsException e) {
                        log.warn ("Cannot set bitstream checksum type=" + csType + " in METS.");
                    }
                }
                FLocat flocat = new FLocat ();
                flocat.setLOCTYPE (Loctype.URL);
                flocat.setXlinkHref (makeBitstreamName (bitstreams [bits]));
                String techID = "techMd_for_bitstream_" + bitstreams [bits].getSequenceID ();
                AmdSec fAmdSec = new AmdSec ();
                fAmdSec.setID (techID);
                TechMD techMd = new TechMD ();
                techMd.setID (gensym ("tech"));
                MdWrap mdWrap = new MdWrap ();
                setMdType (mdWrap, metsName);
                XmlData xmlData = new XmlData ();
                mdWrap.getContent ().add (xmlData);
                techMd.getContent ().add (mdWrap);
                fAmdSec.getContent ().add (techMd);
                mets.getContent ().add (fAmdSec);
                crosswalkToMets (xwalk, bitstreams [bits], xmlData);
                file.setADMID (techID);
                file.getContent ().add (flocat);
                fileGrp.getContent ().add (file);
            }
            fileSec.getContent ().add (fileGrp);
        }
        mets.getContent ().add (fileSec);
        StringBuffer dmdIds = new StringBuffer ();
        for (int i = 0; i < dmdId.length; ++ i) dmdIds.append (" " + dmdId [i]);
        StructMap structMap = new StructMap ();
        structMap.setID (gensym ("struct"));
        structMap.setTYPE ("LOGICAL");
        structMap.setLABEL ("DSpace");
        Div div0 = new Div ();
        div0.setID (gensym ("div"));
        div0.setTYPE ("DSpace Item");
        div0.setDMDID (dmdIds.substring (1));
        if (licenseID != null) div0.setADMID (licenseID);
        if (primaryBitstreamFileID != null) {
            Fptr fptr = new Fptr ();
            fptr.setFILEID (primaryBitstreamFileID);
            div0.getContent ().add (fptr);
        }
        div0.getContent ().addAll (contentDivs);
        structMap.getContent ().add (div0);
        addStructMap (context, item, params, mets);
        mets.getContent ().add (structMap);
        mets.validate (new MetsValidator ());
        mets.write (new MetsWriter (out));
    } catch (MetsException e) {
        throw new PackageValidationException (e);
    }
}


-----Function Pair=162=-----==

public static final void unzip (File zip, File extractTo, String fileToUnzip) throws IOException {
    ZipFile archive = new ZipFile (zip);
    Enumeration e = archive.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        if (entry.getName ().equals (fileToUnzip)) {
            File file = new File (extractTo, entry.getName ());
            if (entry.isDirectory () && ! file.exists ()) {
                file.mkdirs ();
            }
            else {
                if (! file.getParentFile ().exists ()) {
                    file.getParentFile ().mkdirs ();
                }
                InputStream in = archive.getInputStream (entry);
                BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
                byte [] buffer = new byte [8192];
                int read;
                while (- 1 != (read = in.read (buffer))) {
                    out.write (buffer, 0, read);
                }
                in.close ();
                out.close ();
            }
        }
    }
}


public void ViewJavaSource (Writer writer) {
    String javaFileName = Config.OUTPATH_ARTICLE_CLASS + "/com/microfly/runtime/" + GetClassName () + ".java";
    File java_file = new File (javaFileName);
    if (! java_file.exists ()) {
        try {
            writer.write (GetClassName () + ".java" + "��û����ɡ�ģ�屣����Զ���ɡ�");
            writer.flush ();
        } catch (Exception e1) {
        }
        return;
    }
    InputStreamReader fr = null;
    try {
        fr = new InputStreamReader (new FileInputStream (java_file), "UTF-8");
        int b;
        while ((b = fr.read ()) != - 1) {
            writer.write (b);
        }
        writer.flush ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error_noexception (e);
    } finally {
        if (fr != null) try {
            fr.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=163=-----==

private ExtrinsicObject saveBCC (Node nd) {
    try {
        String uniqueID;
        String entryType;
        String DEN;
        String definition;
        String objectClassTerm;
        String propertyTerm;
        String businessTerms = null;
        String representation;
        String min;
        String max;
        ExtrinsicObject eo = null;
        NodeList nl;
        nl = nd.getChildNodes ();
        uniqueID = nl.item (1).getTextContent ();
        entryType = nl.item (3).getTextContent ();
        DEN = nl.item (5).getTextContent ();
        definition = nl.item (7).getTextContent ();
        objectClassTerm = nl.item (9).getTextContent ();
        propertyTerm = nl.item (11).getTextContent ();
        representation = nl.item (13).getTextContent ();
        businessTerms = nl.item (15).getTextContent ();
        min = nl.item (17).getTextContent ();
        max = nl.item (19).getTextContent ();
        eo = generateExtrinsicObject (DEN, definition, uniqueID);
        eo.addSlot (generateSlot (SLOT_UNIQUE_ID, uniqueID));
        eo.addSlot (generateSlot (SLOT_ENTRY_TYPE, entryType));
        eo.addSlot (generateSlot (SLOT_OBJECT_CLASS_TERM, objectClassTerm));
        eo.addSlot (generateSlot (SLOT_ASSOCIATED_OBJECT_CLASS_TERM, representation));
        eo.addSlot (generateSlot (SLOT_PROPERTY_TERM, propertyTerm));
        eo.addSlot (generateSlot (SLOT_REPRESENTATION_TERM, representation));
        eo.addSlot (generateSlot (SLOT_BUSINESS_TERMS, businessTerms));
        eo.addSlot (generateSlot (SLOT_MIN_OCCURENCE, min));
        eo.addSlot (generateSlot (SLOT_MAX_OCCURENCE, max));
        String targetObjectName = representation.concat (". Type");
        ExtrinsicObject targetObject = getEObyName (targetObjectName);
        eo.addAssociation (generateAssociation (eo, "Extends", targetObject));
        ((ExtrinsicObjectImpl) eo).setLid (uniqueID);
        addExtrinsicObject (eo);
        return eo;
    } catch (JAXRException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return null;
}


public boolean checkAccess (Map parameters) {
    User usr = (User) parameters.get (WorkBookCommander.USER);
    String command = (String) parameters.get (WorkBookCommander.COMMAND);
    String memeid = (String) parameters.get (WorkBookCommander.ID);
    MemeDocument webdoc = (MemeDocument) parameters.get (WorkBookCommander.WORKBOOK);
    command = command.toLowerCase ();
    if (command.equals ("getworkbookstats")) {
        if (usr.checkAccess ("meme_" + memeid, AclEntry.UPDATE)) {
            return true;
        }
    }
    else if (command.equals ("exportall")) {
        if (((User) usr).isValid ()) {
            return true;
        }
    }
    else if (command.equals ("getcounters")) {
        return true;
    }
    else if (command.equals ("login")) {
        return true;
    }
    else if (command.equals ("getgloballists")) {
        return true;
    }
    return false;
}


-----Function Pair=164=-----==

public void addDir (ZipOutputStream out, String dirname) throws EditorException {
    byte [] buf = new byte [1024];
    File dir = new File (dirname);
    String dName = dir.getName ();
    if (dir.exists ()) {
        try {
            File file = new File (dirname);
            File [] children = file.listFiles ();
            for (int i = 0; i < children.length; i ++) {
                if ((children [i].isFile ()) && (! children [i].getName ().endsWith ("fop.zip"))) {
                    FileInputStream fis = new FileInputStream (children [i]);
                    out.putNextEntry (new ZipEntry (dName + "/" + children [i].getName ()));
                    int len;
                    while ((len = fis.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    fis.close ();
                }
            }
        } catch (IOException e) {
            String msg = "Unable to add a directory to the ZIP output.";
            throw new EditorException (msg, e);
        }
    }
}


public OutputStream getOutputStream (String path) throws IOException {
    if (! tmpFile.exists ()) {
        tmpFile.mkdirs ();
    }
    File explodedFile = getExplodedFile (path);
    dirty = true;
    if (explodedFile.exists ()) {
        return new FileOutputStream (explodedFile);
    }
    else {
        explodedFile.getParentFile ().mkdirs ();
    }
    addedFileSet.add (path);
    removedFileSet.remove (path);
    dirty = true;
    return new FileOutputStream (explodedFile);
}


-----Function Pair=165=-----==

public static File getBaseFile () {
    String relClassLoc = "com/textflex/jarajar/common/LibJarAjar.class";
    URL urlClassDir = ClassLoader.getSystemResource (relClassLoc);
    if (urlClassDir == null) return new File ("/");
    String strClassDir = urlClassDir.getPath ();
    File fileClassDir = new File (urlClassDir.getPath ());
    File baseDir = null;
    if (strClassDir.indexOf (".jar!/" + relClassLoc) != - 1) {
        baseDir = fileClassDir.getParentFile ().getParentFile ().getParentFile ().getParentFile ().getParentFile ().getParentFile ();
    }
    else {
        baseDir = fileClassDir.getParentFile ().getParentFile ().getParentFile ().getParentFile ().getParentFile ();
    }
    String strBaseDir = baseDir.toString ();
    int space = 0;
    while ((space = strBaseDir.indexOf ("%20")) != - 1) {
        if (strBaseDir.length () > space + 3) {
            strBaseDir = strBaseDir.substring (0, space) + " " + strBaseDir.substring (space + 3);
        }
        else {
            strBaseDir = strBaseDir.substring (0, space) + " ";
        }
    }
    baseDir = new File (strBaseDir);
    String basePath = baseDir.getPath ();
    String protocol = "file:";
    int pathStart = basePath.indexOf (protocol);
    if (pathStart != - 1) basePath = basePath.substring (pathStart + protocol.length ());
    baseDir = new File (basePath);
    if (! baseDir.exists ()) {
        baseDir = new File ("\\" + basePath);
    }
    return baseDir;
}


protected Resource [] selectResources (Resource [] orig, ResourceSelector selector) {
    if (orig.length == 0) {
        return orig;
    }
    ArrayList v = new ArrayList (orig.length);
    for (int i = 0; i < orig.length; i ++) {
        if (selector.isSelected (orig [i])) {
            v.add (orig [i]);
        }
    }
    if (v.size () != orig.length) {
        Resource [] r = new Resource [v.size ()];
        return (Resource []) v.toArray (r);
    }
    return orig;
}


-----Function Pair=166=-----==

public static String [] fireQSub (String queue, String commands, String fullPathToTempDir, boolean waitAndClean) {
    String name = "tmp" + Passwords.createRandowWord (6);
    String shell = "#!/bin/sh \n" + "#$ -N " + name + " \n" + "#$ -j oe \n" + "#$ -o " + fullPathToTempDir + " \n" + "#$ -q " + queue + " \n" + "#$ -l nodes=1 \n" + commands + " \n" + "echo \"Finished!\"\n";
    System.out.print (shell);
    File shellFile = new File (fullPathToTempDir, name + ".sh");
    writeString (shell, shellFile);
    try {
        Runtime rt = Runtime.getRuntime ();
        Process p = rt.exec ("qsub " + shellFile);
        System.out.println ("Fired qsub");
        if (waitAndClean == false) return null;
        boolean wait = true;
        File dir = new File (fullPathToTempDir);
        File outputFile = null;
        long counter = 0;
        long milSec = 30000;
        ArrayList dataArrayList = new ArrayList (1000);
        System.out.print ("Waiting");
        while (wait) {
            Thread.sleep (milSec);
            if (outputFile == null) {
                String [] fileNames = dir.list ();
                for (int i = fileNames.length - 1; i >= 0; i --) {
                    if (fileNames [i].startsWith (name + ".o")) {
                        outputFile = new File (fullPathToTempDir, fileNames [i]);
                        System.out.println ("\nFound results file: " + outputFile.getName ());
                        break;
                    }
                }
            }
            if (outputFile != null) {
                String lastLine = "";
                String line;
                dataArrayList.clear ();
                BufferedReader in = new BufferedReader (new FileReader (outputFile));
                while ((line = in.readLine ()) != null) {
                    lastLine = line;
                    dataArrayList.add (line);
                }
                in.close ();
                if (lastLine.startsWith ("Finished!") || lastLine.startsWith ("cd: Too many arguments")) wait = false;
            }
            counter ++;
            System.out.print (".");
            if (counter > 57600000) {
                System.out.println ("\n    Error: shell script failed to return from qsub after " + counter / 60000 + " minutes.\nFind and kill the job: (text Nix, process number is the last digits after the .o in -> " + outputFile.getName ());
                System.exit (1);
            }
        }
        System.out.println ("\nResults are ready!");
        String [] fileNames = dir.list ();
        for (int i = fileNames.length - 1; i >= 0; i --) {
            if (fileNames [i].startsWith (name)) {
                new File (fullPathToTempDir, fileNames [i]).delete ();
                System.out.println ("Deleting-> " + fileNames [i]);
            }
        }
        System.out.println ("Time for run: " + (counter * (milSec / 1000)) + " seconds\n");
        dataArrayList.trimToSize ();
        String [] x = new String [dataArrayList.size ()];
        dataArrayList.toArray (x);
        return x;
    } catch (Exception e) {
        System.out.println ("Problem with fireQSub()");
        e.printStackTrace ();
    }
    return null;
}


private static void processSchedule () {
    Date date = new Date ();
    for (Holiday holiday : Holiday.getHolidays ()) if (holiday.contains (date)) return;
    int pause = 0;
    try {
        pause = Integer.parseInt (OGSserver.getProperty ("Server.Schedule.Pause", "30"));
    } catch (NumberFormatException err) {
        Galaxy.getLogger ().severe ("Bad value for schedule pause");
    }
    List < String > needArchive = new ArrayList < String > ();
    for (String gameName : getGameNames ()) {
        Schedule sch = Schedule.getSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName));
        if (sch.isTimeToArchive (date)) needArchive.add (gameName);
        else if (sch.isTimeToGenerate (date) && ! sch.isDateInsideStopPeriod (date)) {
            if (sch.isTooLateToGenerate (date, pause)) {
                Galaxy.getLogger ().severe ("Game " + gameName + " generation skipped");
                sch.updateNextScheduleDate (sch.getTurn ());
                Schedule.commitSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName), sch);
            }
            else {
                Galaxy galaxy = Galaxy.load (gameName);
                if (galaxy == null) continue;
                if (galaxy.getState () == Galaxy.State.GAME || galaxy.getState () == Galaxy.State.RECRUITING) {
                    sch.updateNextScheduleDate (galaxy.getTurn () + 2);
                    Schedule.commitSchedule (Utils.joinPath (Galaxy.GAMES_DIR, gameName), sch);
                    Galaxy.getLogger ().info ("Generate " + galaxy.getName () + " turn " + (galaxy.getTurn () + 1) + " by schedule");
                    generateGame (galaxy);
                }
            }
        }
    }
    for (String gameName : needArchive) {
        Galaxy galaxy = Galaxy.load (gameName);
        if (galaxy == null) continue;
        if (galaxy.getState () != Galaxy.State.FINAL && galaxy.getState () != Galaxy.State.ARCHIVE) {
            Galaxy.getLogger ().severe ("Game " + galaxy.getName () + " : time to archive, but game state != FINAL, break archiving");
            continue;
        }
        if (! archiveGame (galaxy)) break;
    }
}


-----Function Pair=167=-----==

public static void unzipDir (JarInputStream jis, String destinyDir, boolean importFiles) {
    try {
        final int BUFFER = 2048;
        BufferedOutputStream dest = null;
        JarEntry entry = null;
        while ((entry = jis.getNextJarEntry ()) != null) {
            boolean unzip;
            if (importFiles && isFileToUnzip (entry.getName ()) || ! importFiles) unzip = true;
            else unzip = false;
            if (unzip) {
                int count;
                byte data [] = new byte [BUFFER];
                File newFile = new File (destinyDir, entry.getName ());
                newFile.create ();
                if (! newFile.isDirectory ()) {
                    FileOutputStream fos = new FileOutputStream (newFile);
                    dest = new BufferedOutputStream (fos, BUFFER);
                    while ((count = jis.read (data, 0, BUFFER)) != - 1) {
                        dest.write (data, 0, count);
                    }
                    dest.flush ();
                    dest.close ();
                }
            }
        }
        jis.close ();
    } catch (Exception e) {
    }
}


private void ZipPageTemplates (ZipOutputStream out) throws Exception {
    if (page_templates == null || page_templates.isEmpty ()) return;
    String filename = "TOPIC" + GetId () + ".pts";
    out.putNextEntry (new ZipEntry (filename));
    try {
        ZipWriter writer = new ZipWriter (out);
        for (Object obj : page_templates) {
            PageTemplate pt = (PageTemplate) obj;
            if (pt != null) {
                writer.println (pt.GetId ());
            }
        }
    } finally {
        out.closeEntry ();
    }
}


-----Function Pair=168=-----==

public static HashMap < String, Integer > loadFileIntoHashMapStringInteger (File file) {
    HashMap < String, Integer > names = new HashMap < String, Integer > (1000);
    try {
        BufferedReader in = IO.fetchBufferedReader (file);
        String line;
        String [] keyValue;
        while ((line = in.readLine ()) != null) {
            keyValue = line.split ("\\s+");
            if (keyValue.length != 2 || keyValue [0].startsWith ("#")) continue;
            names.put (keyValue [0].trim (), new Integer (keyValue [1].trim ()));
        }
    } catch (Exception e) {
        System.out.println ("Prob loadFileInttoHash()");
        e.printStackTrace ();
    }
    return names;
}


public void unzipFile (ActionFormEvent event) throws PortletException {
    String userName = (String) ((Map) event.getActionRequest ().getAttribute (PortletRequest.USER_INFO)).get ("user.name");
    String sideParam = event.getAction ().getParameter ("side");
    String fileNumberParam = event.getAction ().getParameter ("fileNumber");
    UserData userData = (UserData) event.getActionRequest ().getPortletSession ().getAttribute ("userData");
    try {
        int fileNumber = Integer.parseInt (fileNumberParam);
        ArrayList < MyFile > resources = (sideParam.equals ("left") ? userData.getLeftFileList () : userData.getRightFileList ());
        String filename = userData.getChrootDir () + userData.getPath (sideParam) + resources.get (fileNumber).getName ();
        FileInputStream fis = new FileInputStream (filename);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry;
        BufferedOutputStream dest = null;
        final int BUFFER = 2048;
        while ((entry = zis.getNextEntry ()) != null) {
            log.debug ("Extracting: " + entry);
            int count;
            byte data [] = new byte [BUFFER];
            FileOutputStream fos = new FileOutputStream (userData.getChrootDir () + userData.getPath (sideParam) + File.separator + entry.getName ());
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
        }
        zis.close ();
        readDirectories (userName, userData);
    } catch (NumberFormatException e) {
        log.error ("Unable to parse fileNumberParam (" + fileNumberParam + ")", e);
    } catch (java.io.IOException e) {
        log.error ("Unzip was unseccessfull");
        event.getActionResponse ().setRenderParameter ("errorMessage", "Unzip was unseccessfull");
    }
}


-----Function Pair=169=-----==

public static Map unzipShapefile (String name, InputStream data, String basepath) {
    try {
        Map output = new HashMap ();
        String id = String.valueOf (System.currentTimeMillis ());
        String outputpath = basepath + id + "/";
        String zipfilename = name.substring (0, name.lastIndexOf ("."));
        outputpath += zipfilename + "/";
        File outputDir = new File (outputpath);
        outputDir.mkdirs ();
        ZipInputStream zis = new ZipInputStream (data);
        ZipEntry ze = null;
        String shpfile = "";
        String type = "";
        while ((ze = zis.getNextEntry ()) != null) {
            System.out.println ("ze.file: " + ze.getName ());
            if (ze.getName ().endsWith (".shp")) {
                shpfile = ze.getName ();
                type = "shp";
            }
            String fname = outputpath + ze.getName ();
            copyInputStream (zis, new BufferedOutputStream (new FileOutputStream (fname)));
            zis.closeEntry ();
        }
        zis.close ();
        output.put ("type", type);
        output.put ("file", outputpath + shpfile);
        return output;
    } catch (Exception e) {
        System.out.println ("unable to load user kml: ");
        e.printStackTrace (System.out);
    }
    return null;
}


public static void unzip2 (String strZipFile, String folder) throws IOException, ArchiveException {
    FileUtil.fileExists (strZipFile, true);
    final InputStream is = new FileInputStream (strZipFile);
    ArchiveInputStream in = new ArchiveStreamFactory ().createArchiveInputStream ("zip", is);
    ZipArchiveEntry entry = null;
    OutputStream out = null;
    while ((entry = (ZipArchiveEntry) in.getNextEntry ()) != null) {
        File zipPath = new File (folder);
        File destinationFilePath = new File (zipPath, entry.getName ());
        destinationFilePath.getParentFile ().mkdirs ();
        if (entry.isDirectory ()) {
            continue;
        }
        else {
            out = new FileOutputStream (new File (folder, entry.getName ()));
            IOUtils.copy (in, out);
            out.close ();
        }
    }
    in.close ();
}


-----Function Pair=170=-----==

private void writeEditFieldCriterion (OutputStreamWriter out, EditFieldMatchingCriterion criterion) throws IOException {
    String fieldName = criterion.getFieldName ();
    String comparedValue = criterion.getComparedValue ();
    out.write ("<editFieldCriterion>");
    out.write ("<fieldName>");
    out.write (criterion.getFieldName ());
    out.write ("</fieldName>");
    out.write ("<operator>");
    FieldOperator operator = criterion.getOperator ();
    String phrase = FieldOperator.getPhraseForOperator (operator);
    phrase = PedroXMLParsingUtility.escapeXml (phrase);
    out.write (phrase);
    out.write ("</operator>");
    out.write ("<comparedValue>");
    out.write (comparedValue);
    out.write ("</comparedValue>");
    out.write ("</editFieldCriterion>");
}


public void onMessage (Message message) {
    ExportMessage msg = (ExportMessage) message;
    VosaoContext.getInstance ().setUser (UserHelper.ADMIN);
    ZipOutStreamTaskAdapter zipOutStreamTaskAdapter = new ZipOutStreamTaskAdapterImpl (getBusiness ());
    if (msg.getCurrentFile () == null) {
        removeExportFile (msg.getFilename ());
        getBusiness ().getSystemService ().getCache ().remove (msg.getFilename ());
    }
    zipOutStreamTaskAdapter.setFileCounter (Integer.valueOf (msg.getFileCounter ()));
    try {
        openStream (zipOutStreamTaskAdapter, msg.getFilename ());
        zipOutStreamTaskAdapter.setStartFile (msg.getCurrentFile ());
        logger.info ("Export " + msg.getExportType () + " " + msg.getCurrentFile () + " " + msg.getFileCounter ());
        if (msg.getExportType ().equals (TYPE_PARAM_THEME)) {
            List < TemplateEntity > templates = getDao ().getTemplateDao ().getById (msg.getIds ());
            List < StructureEntity > structures = getDao ().getStructureDao ().getById (msg.getStructureIds ());
            getImportExportBusiness ().createTemplateExportFile (zipOutStreamTaskAdapter, templates, structures);
        }
        if (msg.getExportType ().equals (TYPE_PARAM_FOLDER)) {
            FolderEntity folder = getDao ().getFolderDao ().getById (msg.getFolderId ());
            getImportExportBusiness ().createExportFile (zipOutStreamTaskAdapter, folder);
        }
        if (msg.getExportType ().equals (TYPE_PARAM_SITE)) {
            getImportExportBusiness ().createSiteExportFile (zipOutStreamTaskAdapter);
        }
        if (msg.getExportType ().equals (TYPE_PARAM_FULL)) {
            getImportExportBusiness ().createFullExportFile (zipOutStreamTaskAdapter);
        }
        if (msg.getExportType ().equals (TYPE_PARAM_RESOURCES)) {
            getImportExportBusiness ().createResourcesExportFile (zipOutStreamTaskAdapter);
        }
        saveZip (zipOutStreamTaskAdapter, msg.getFilename (), true);
        getBusiness ().getFileBusiness ().saveFile ("/tmp/" + msg.getFilename () + ".txt", "OK".getBytes ());
        logger.info ("Export finished. " + zipOutStreamTaskAdapter.getFileCounter ());
    } catch (TaskTimeoutException e) {
        try {
            saveZip (zipOutStreamTaskAdapter, msg.getFilename (), false);
        } catch (Exception e2) {
            e2.printStackTrace ();
        }
        getMessageQueue ().publish (new ExportMessage.Builder ().setFilename (msg.getFilename ()).setCurrentFile (zipOutStreamTaskAdapter.getCurrentFile ()).setFileCounter (zipOutStreamTaskAdapter.getFileCounter ()).setExportType (msg.getExportType ()).create ());
        logger.info ("Added new export task " + zipOutStreamTaskAdapter.getCurrentFile ());
    } catch (Exception e) {
        logger.error (e.toString () + " " + e.getMessage () + "\n" + ExceptionUtils.getFullStackTrace (e));
    }
}


-----Function Pair=171=-----==

private byte [] addUpdateItem (HTTPurl urlData) throws Exception {
    String id = urlData.getParameter ("id");
    ScheduleItem item = null;
    String statusPage = urlData.getParameter ("status");
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
    }
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    String mes = addSchedule (urlData, item);
    if (statusPage != null && statusPage.equals ("1")) {
        StringBuffer buff = new StringBuffer ();
        buff.append ("HTTP/1.0 200\n");
        buff.append ("Content-Type: text/xml\n\n");
        buff.append ("<schedule_add>\n");
        if (mes == null) {
            buff.append ("<status>ADDED</status>\n");
            buff.append ("<message></message>\n");
        }
        else {
            buff.append ("<status>FAILED</status>\n");
            buff.append ("<message>" + mes + "</message>\n");
        }
        buff.append ("</schedule_add>\n");
        return buff.toString ().getBytes ();
    }
    if (mes != null) throw new Exception (mes);
    StringBuffer out = new StringBuffer (4096);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


public static boolean unpackZip (ZipFile zipFile, File dir) throws IOException {
    Enumeration e = zipFile.entries ();
    ZipEntry ze = null;
    String name = null;
    InputStream in = null;
    FileOutputStream out = null;
    int c;
    File fileEnt = null;
    byte [] b = new byte [1024];
    while (e.hasMoreElements ()) {
        ze = (ZipEntry) (e.nextElement ());
        name = ze.getName ().replaceAll (".*/", "");
        if (ze.isDirectory ()) {
            continue;
        }
        fileEnt = new File (dir, name);
        in = zipFile.getInputStream (ze);
        out = new FileOutputStream (fileEnt);
        while ((c = in.read (b)) != - 1) {
            out.write (b, 0, c);
        }
        in.close ();
        out.close ();
    }
    return (true);
}


-----Function Pair=172=-----==

public void parse (File in) throws IOException, BadParseException {
    try {
        ZipFile file = new ZipFile (in);
        ZipEntry manifest = file.getEntry (MANIFEST_FILE);
        if (manifest == null) throw new BadParseException ("Zip file contained no imsmanifest.xml");
        if (manifest.isDirectory ()) throw new BadParseException ("imsmanifest.xml is a directory");
        cp = new ContentPackageImpl ();
        InputStream manifest_stream = file.getInputStream (manifest);
        cp.setRootManifest (parseManifest (cp, manifest_stream));
        manifest_stream.close ();
        PackageDirectoryImpl root = new PackageDirectoryImpl (new Updates (), null, null);
        cp.setRootDirectory (root);
        for (Enumeration e = file.entries (); e.hasMoreElements ();) addFile (root, file, (ZipEntry) e.nextElement ());
    } catch (IOException x) {
        cp = null;
        throw x;
    } catch (BadParseException x) {
        cp = null;
        throw x;
    }
}


private void UpdateTopicPageTemplate (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_pts where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        java.util.List pts = t.GetPageTemplates ();
        if (pts == null || pts.isEmpty ()) return;
        sql = "insert into topic_pts(topid,templateid) values(?,?)";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        for (Object obj : pts) {
            PageTemplate pt = (PageTemplate) obj;
            pstmt.setString (1, t.GetId ());
            pstmt.setString (2, pt.GetId ());
            pstmt.executeUpdate ();
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=173=-----==

public boolean existeArquivo (DadosSeriais dados, String dir) throws BasicException {
    if (dir == null) {
        dir = "";
    }
    dadosSeriais = dados;
    String idArquivo = dados.getIdColeta ().toString ();
    if (dados.getIdResumo () != null) {
        idArquivo += "_" + dados.getIdResumo ().toString ();
    }
    try {
        File file = new File (dir.trim (), "pdump." + idArquivo + ".data.xml.zip");
        return file.exists ();
    } catch (Exception e) {
        throw BasicException.errorHandling ("Erro ao verificar existencia de arquivo de dados", "msgErroVerificarExistenciaArquivoDadosXML", e, log);
    }
}


protected void addObjectToZip (int serializerType, ZipOutputStream zipOutputStream, Object o, String name, String typeName) throws ValidationException, MarshalException, IOException, InfoException {
    ByteArrayInputStream in = null;
    ObjectOutputStream oos;
    int len;
    byte [] buf = new byte [1024];
    if (serializerType == 1) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
        oos = new ObjectOutputStream (outputStream);
        oos.writeObject (o);
        in = new ByteArrayInputStream (outputStream.toByteArray ());
    }
    else if (serializerType == 2) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
        Writer writer = null;
        try {
            String writerClassName;
            String javaVersion = System.getProperty ("java.vm.version");
            if (javaVersion.startsWith ("1.4")) {
                writerClassName = "org.apache.xalan.serialize.WriterToUTF8";
            }
            else {
                writerClassName = "com.sun.org.apache.xml.internal.serializer.WriterToUTF8";
            }
            Class writerClass = Class.forName (writerClassName);
            writer = (Writer) writerClass.getConstructor (new Class [] {OutputStream.class}).newInstance (new Object [] {outputStream});
        } catch (Exception e) {
            throw new InfoException (LanguageTraslator.traslate ("471"), e);
        }
        Marshaller.marshal (o, writer);
        in = new ByteArrayInputStream (outputStream.toByteArray ());
    }
    zipOutputStream.putNextEntry (new ZipEntry (name));
    while ((len = in.read (buf)) > 0) {
        zipOutputStream.write (buf, 0, len);
    }
    getConfiguration ().put (typeName, name);
    zipOutputStream.closeEntry ();
    in.close ();
}


-----Function Pair=174=-----==

private long streamWildcardFiles (FileImport wildImport, String uplDirectory, org.unicore.utility.ZipOutputStream zos) throws FileNotFoundException, IOException {
    long total = 0;
    String filename = wildImport.getSourceName ();
    File file = new File (filename);
    String directoryPath = file.getParent ();
    String pattern = file.getName ();
    File directory = new File (directoryPath);
    GlobFilenameFilter fileFilter = new GlobFilenameFilter (pattern);
    File [] files = directory.listFiles ((FilenameFilter) fileFilter);
    if (files != null) {
        for (int i = 0; i < files.length; i ++) {
            FileImport fileImport = new FileImport (FileStorage.NSPACE_STRING, files [i].getAbsolutePath (), wildImport.getDestinationName ());
            fileImport.setHiddenDestination (wildImport.getHiddenDestination () + fileImport.getDestinationFileSeparator () + fileImport.getSourceCanonicalBasename ());
            total += streamFile (fileImport, uplDirectory, zos);
        }
    }
    return total;
}


public Object GetField (String fieldName) throws NpsException {
    if (fieldName == null || fieldName.length () == 0) return null;
    String key = fieldName.trim ();
    if (key.length () == 0) return null;
    key = key.toUpperCase ();
    if (key.equalsIgnoreCase ("unit_id")) return id;
    if (key.equalsIgnoreCase ("unit_name")) return name;
    if (key.equalsIgnoreCase ("unit_code")) return code;
    if (key.equalsIgnoreCase ("unit_address")) return address;
    if (key.equalsIgnoreCase ("unit_email")) return email;
    if (key.equalsIgnoreCase ("unit_attachman")) return attachman;
    if (key.equalsIgnoreCase ("unit_zipcode")) return zipcode;
    if (key.equalsIgnoreCase ("unit_phonenum")) return phonenum;
    if (key.equalsIgnoreCase ("unit_phone")) return phonenum;
    if (key.equalsIgnoreCase ("unit_mobile")) return mobile;
    return null;
}


-----Function Pair=175=-----==

public Collection < String > getVectorLayers (boolean onlyOneFileAllowed) {
    LinkedList < String > layers = new LinkedList < String > ();
    if (zipFile != null) {
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            ZipEntry ze = (ZipEntry) e.nextElement ();
            String fileName = ze.getName ();
            if (fileIsShp (fileName)) {
                String base = getBase (fileName);
                if (onlyOneFileAllowed) {
                    if (layers.size () > 1) throw new IllegalArgumentException ("Only one shapefile per zip is allowed. " + layers.size () + " shapefiles found.");
                    if (base.equals (getBase (file.getName ()))) {
                        layers.add (base);
                    }
                    else throw new IllegalArgumentException ("Shapefile name (" + base + ") is not equal to ZIP file name (" + file.getName () + ").");
                }
                else {
                    layers.add (base);
                }
            }
        }
    }
    return layers;
}


public void readContentUncompressed (InputStream in) throws IOException {
    cmd = in.read ();
    int length = Packet.read2ByteNumber (in);
    triggers = new TriggerEntry [length];
    for (int i = 0; i < triggers.length; i ++) {
        triggers [i] = new TriggerEntry ();
        triggers [i].setId (Packet.read2ByteNumber (in));
        triggers [i].setTitle (Packet.readString (in));
        triggers [i].setActive (Packet.readBoolean (in));
        triggers [i].setCategory (Packet.readString (in));
        triggers [i].setRegex (Packet.readString (in));
        triggers [i].setQuantity (Packet.read2ByteNumber (in));
        triggers [i].setIgnoreTimer (Packet.read2ByteNumber (in));
        triggers [i].setServerMsgActive (Packet.readBoolean (in));
        triggers [i].setServerMsg (Packet.readString (in));
        triggers [i].setServerMsgSize (in.read ());
        int red = in.read ();
        int green = in.read ();
        int blue = in.read ();
        triggers [i].setServerMsgColor (new Color (red, green, blue));
        triggers [i].setSoundActive (Packet.readBoolean (in));
        triggers [i].setSound (Packet.readString (in));
        triggers [i].setTimerActive (Packet.readBoolean (in));
        triggers [i].setTimerShow1 (Packet.readBoolean (in));
        triggers [i].setTimerShow2 (Packet.readBoolean (in));
        triggers [i].setTimerPeriod (Packet.read2ByteNumber (in));
        triggers [i].setTimerWarning (Packet.read2ByteNumber (in));
        triggers [i].setTimerWarningMsg (Packet.readString (in));
        triggers [i].setTimerWarningMsgSize (in.read ());
        red = in.read ();
        green = in.read ();
        blue = in.read ();
        triggers [i].setTimerWarningMsgColor (new Color (red, green, blue));
        triggers [i].setTimerWarningSound (Packet.readString (in));
        triggers [i].setTimerRemove (Packet.read2ByteNumber (in));
    }
}


-----Function Pair=176=-----==

public void saveSolvers (final Tasks task) throws SQLException, FileNotFoundException, NoSolverBinarySpecifiedException, NoSolverNameSpecifiedException, IOException, NoSuchAlgorithmException, NoConnectionToDBException, JAXBException {
    task.setOperationName ("Saving solvers...");
    int countSolvers = solverTableModel.getSolvers ().size ();
    for (int i = 0; i < countSolvers; i ++) {
        Solver s = solverTableModel.getSolver (i);
        task.setTaskProgress ((float) i / (float) countSolvers);
        task.setStatus ("Saving solver " + s.getName () + " (" + i + " of " + countSolvers + ")");
        Vector < Parameter > params = manageDBParameters.getParametersOfSolver (s);
        SolverDAO.save (s);
        manageDBParameters.rehash (s, params);
    }
    for (Solver s : solverTableModel.getSolvers ()) {
        manageDBParameters.saveParameters (s);
    }
}


private final long addToList (File [] sub_list, ArrayList < File > full_list) {
    long total_size = 0;
    try {
        for (int i = 0; i < sub_list.length; i ++) {
            if (stop || isInterrupted ()) {
                errMsg = "Canceled";
                break;
            }
            File f = sub_list [i];
            if (f != null && f.exists ()) {
                if (f.isFile ()) {
                    total_size += f.length ();
                    full_list.add (f);
                }
                else if (f.isDirectory ()) {
                    long dir_sz = addToList (f.listFiles (), full_list);
                    if (errMsg != null) break;
                    if (dir_sz == 0) full_list.add (f);
                    else total_size += dir_sz;
                }
            }
        }
    } catch (Exception e) {
        Log.e (TAG, "addToList()", e);
        errMsg = "Exception: " + e.getMessage ();
    }
    return total_size;
}


-----Function Pair=177=-----==

public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositionTexts [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositionTexts.length; i ++) {
            int currentStart = sortedPositionTexts [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT + USeqUtilities.TEXT;
    else fileType = USeqUtilities.INT + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedPositionTexts [0].position);
        workingDOS.writeUTF (sortedPositionTexts [0].text);
        if (useShort) {
            int bp = sortedPositionTexts [0].position;
            for (int i = 1; i < sortedPositionTexts.length; i ++) {
                int currentStart = sortedPositionTexts [i].position;
                int diff = currentStart - bp - 32768;
                workingDOS.writeShort ((short) (diff));
                workingDOS.writeUTF (sortedPositionTexts [i].text);
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositionTexts [0].position;
            for (int i = 1; i < sortedPositionTexts.length; i ++) {
                int currentStart = sortedPositionTexts [i].position;
                int diff = currentStart - bp;
                workingDOS.writeInt (diff);
                workingDOS.writeUTF (sortedPositionTexts [i].text);
                bp = currentStart;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


public void prepareWrite (SerializableData data, String folder) throws BasicException {
    String fileId = data.getHarvestId ().toString ();
    if (data.getSummaryId () != null) {
        fileId += "_" + data.getSummaryId ().toString ();
    }
    if (folder == null || folder.trim ().equals ("")) {
        throw this.errorHandling ("Diret�rio Imagem de Dados n�o foi definido.", "msgErroNaoExisteDiretorioImagem", new String [] {});
    }
    try {
        fos = new FileOutputStream (new File (folder.trim (), "pdump." + fileId + ".data.xml.zip"));
    } catch (FileNotFoundException e) {
        throw this.errorHandling ("Erro ao abrir arquivo de dados xml para escrita", "msgErroCriarArquivoDadosXML", e);
    }
    zipOutputStream = new ZipOutputStream (fos);
    zipOutputStream.setLevel (Deflater.DEFAULT_COMPRESSION);
    try {
        zipOutputStream.putNextEntry (new ZipEntry ("pdump." + fileId + ".data.xml"));
        xmlWriter = XMLOutputFactory.newInstance ().createXMLStreamWriter (zipOutputStream, ENCODING);
    } catch (Exception e) {
        throw this.errorHandling ("Erro ao criar entrada em arquivo compactado", "msgErroCriarEntradaZipArquivoDadosXML", e);
    }
    XMLStreamWriter osw = null;
    try {
        xmlWriter = XMLOutputFactory.newInstance ().createXMLStreamWriter (zipOutputStream, ENCODING);
    } catch (Exception e) {
        throw this.errorHandling ("Erro ao criar entrada em arquivo compactado", "msgErroCriarEntradaZipArquivoDadosXML", e);
    }
    SimpleDateFormat dateFormat = new SimpleDateFormat ("yyyy-MM-dd'T'HH:mm:ss");
    if (! data.getTypes ().isEmpty ()) {
        types = new int [data.getTypes ().size ()];
        for (int c = 0; c < data.getTypes ().size (); c ++) {
            String tipo = data.getTypes ().get (c);
            if (tipo.equals (Lit.INTEGER)) {
                types [c] = Type.INTEGER;
            }
            else if (tipo.equals (Lit.DECIMAL)) {
                types [c] = Type.DECIMAL;
            }
            else if (tipo.equals (Lit.DATE)) {
                types [c] = Type.DATE;
            }
            else {
                types [c] = Type.TEXT;
            }
        }
    }
    try {
        xmlWriter.writeStartDocument (ENCODING, "1.0");
        xmlWriter.writeStartElement ("harvest");
        xmlWriter.writeAttribute ("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance");
        xmlWriter.writeAttribute ("xsi:noNamespaceSchemaLocation", "http://www.pCollecta.lcc.ufmg.br/dtd/pCollectaDataDump.xsd");
        xmlWriter.writeStartElement ("id");
        xmlWriter.writeCharacters (fileId);
        xmlWriter.writeEndElement ();
        xmlWriter.writeStartElement ("date");
        xmlWriter.writeCharacters (dateFormat.format (data.getHarvestDate ()));
        xmlWriter.writeEndElement ();
        xmlWriter.writeStartElement ("sql");
        xmlWriter.writeCData (data.getQuery ());
        xmlWriter.writeEndElement ();
        xmlWriter.writeStartElement ("header");
        for (int c = 0; c < data.getHeader ().size (); c ++) {
            xmlWriter.writeStartElement ("name");
            xmlWriter.writeAttribute ("type", data.getTypes ().get (c));
            xmlWriter.writeCharacters (data.getHeader ().get (c));
            xmlWriter.writeEndElement ();
        }
        xmlWriter.writeEndElement ();
        xmlWriter.writeStartElement ("quantity");
        xmlWriter.writeCharacters ("" + data.getQuantity ());
        xmlWriter.writeEndElement ();
        xmlWriter.writeStartElement ("data");
    } catch (XMLStreamException e) {
        throw this.errorHandling ("Erro ao escrever dados em arquivo compactado", "msgErroEscreverArquivoDadosXML", e);
    }
    computeHash = new ComputeHash ();
}


-----Function Pair=178=-----==

public static String [] executeShellScript (String shellScript, File tempDirectory) {
    File shellFile = new File (tempDirectory, "tempFile_" + Passwords.createRandowWord (10) + ".sh");
    String fullPath = IO.getFullPathName (shellFile);
    IO.writeString (shellScript, shellFile);
    String [] cmd = {"chmod", "777", fullPath};
    String [] res = IO.executeCommandLineReturnAll (cmd);
    if (res == null || res.length != 0) {
        shellFile.delete ();
        return null;
    }
    cmd = new String [] {fullPath};
    res = IO.executeCommandLineReturnAll (cmd);
    shellFile.delete ();
    return res;
}


public static void addDefaultArgements (ONDEXPlugin plugin, ONDEXPluginArguments arguments) throws IllegalArguementsException {
    ArgumentDefinition < ? > [] argumentDefinitions = plugin.getArgumentDefinitions ();
    try {
        for (ArgumentDefinition < ? > aDefinition : argumentDefinitions) {
            logger.info (aDefinition.getName ());
            if (arguments.getObjectValueList (aDefinition.getName ()).size () > 0) {
                logger.info ("exists");
            }
            else if (aDefinition.getDefaultValue () != null) {
                logger.info ("No value provided for " + aDefinition.getName () + " using default value of: " + aDefinition.getDefaultValue ());
                createArguement (plugin, arguments, aDefinition.getName (), aDefinition.getDefaultValue ());
            }
            else if (aDefinition.isRequiredArgument ()) {
                throw new IllegalArguementsException ("No value found and no default available" + " for arguement with the name: " + aDefinition.getName () + " in the plugin " + plugin.getClass (), plugin, logger);
            }
            else {
                logger.info ("Not required and no default.");
            }
        }
    } catch (InvalidPluginArgumentException e) {
        throw new IllegalArguementsException ("Unexpected mismatch between annouced deafults " + "and excepted aurguements", plugin, logger);
    }
}


-----Function Pair=179=-----==

private static void iFileUpdate (boolean document, BufferedInputStream in, boObject object, String userBoui, String fileName, File uploadFile, ZipEntry zfile, String [] dirTree, String bridge) throws boRuntimeException, IOException, iFilePermissionDenied {
    BufferedOutputStream out = null;
    iFile file = null;
    if (document) {
        file = getFileFromDocument (object, fileName, bridge);
    }
    else {
        file = object.getAttribute ("file").getValueiFile ();
    }
    if (file != null) {
        if (file.isCheckedOut () && userBoui.equals (file.getCheckOutUser ())) {
            file.setVersionUser (userBoui);
            file.setBinaryStream (in);
            file.checkIn ();
        }
    }
    else {
        if (zfile == null) {
            iFileCreate (object, uploadFile, bridge);
        }
        else {
            iFileCreate (getDocument (object, dirTree, bridge), fileCreate (zfile, in), bridge);
        }
    }
}


private void createUnitsElement (Document document, Element rootElement) throws SQLException {
    Element unitsEle = document.createElement ("units");
    rootElement.appendChild (unitsEle);
    String sql = "select count(*) from unit";
    Statement stm = con.createStatement ();
    ResultSet rs = stm.executeQuery (sql);
    if (rs.next ()) {
        dbSize = rs.getInt (1);
    }
    rs.close ();
    stm.close ();
    sql = "select * from unit order by pid";
    stm = con.createStatement ();
    rs = stm.executeQuery (sql);
    Element ele;
    double unitCounter = 0;
    while (rs.next ()) {
        unitCounter ++;
        int pid = rs.getInt ("pid");
        Element unitEle = document.createElement ("unit");
        unitsEle.appendChild (unitEle);
        unitEle.setAttribute ("unitid", "I" + pid);
        unitEle.setAttribute ("tag", rs.getString ("tag"));
        unitEle.setAttribute ("sex", rs.getString ("sex"));
        String tmp = rs.getString ("groupid");
        if (tmp != null) {
            unitEle.setAttribute ("group", tmp);
        }
        String created = rs.getString ("createdate");
        unitEle.setAttribute ("created", created);
        unitEle.setAttribute ("createdate", created.substring (0, 10));
        String createdBy = rs.getString ("createdBy");
        if (createdBy != null) {
            unitEle.setAttribute ("createdBy", createdBy);
        }
        String modified = rs.getString ("modified");
        if (modified != null) {
            unitEle.setAttribute ("modified", modified);
        }
        String modifiedBy = rs.getString ("modifiedBy");
        if (modifiedBy != null) {
            unitEle.setAttribute ("modifiedBy", modifiedBy);
        }
        tmp = rs.getString ("userrefn");
        if (tmp != null) {
            ele = document.createElement ("userrefn");
            ele.setTextContent (tmp);
            unitEle.appendChild (ele);
        }
        tmp = rs.getString ("sourcetext");
        if (tmp != null) {
            ele = document.createElement ("source");
            ele.setTextContent (tmp);
            unitEle.appendChild (ele);
        }
        tmp = rs.getString ("privatetext");
        if (tmp != null) {
            ele = document.createElement ("privatetext");
            ele.setTextContent (tmp);
            unitEle.appendChild (ele);
        }
        Element nameEle = document.createElement ("name");
        unitEle.appendChild (nameEle);
        Element notices = createNoticesElement (document, pid);
        if (firstPrefix != null) {
            ele = document.createElement ("prefix");
            ele.setTextContent (firstPrefix);
            nameEle.appendChild (ele);
        }
        if (firstGivenname != null) {
            ele = document.createElement ("givenname");
            ele.setTextContent (firstGivenname);
            nameEle.appendChild (ele);
        }
        if (firstSurname != null) {
            ele = document.createElement ("surname");
            ele.setTextContent (firstSurname);
            nameEle.appendChild (ele);
        }
        if (firstPostfix != null) {
            ele = document.createElement ("postfix");
            ele.setTextContent (firstPostfix);
            nameEle.appendChild (ele);
        }
        unitEle.appendChild (nameEle);
        unitEle.appendChild (notices);
        double prossa = unitCounter / dbSize;
        int prose = (int) (prossa * 100);
        setRunnerValue ("" + prose + ";unit");
    }
    rs.close ();
    stm.close ();
}


-----Function Pair=180=-----==

private List < Element > getListOfNodeToInsert (Element textToAppend, TreeMap < String, String > mapOldIdToNewId) {
    ArrayList < Element > listOfNodes = new ArrayList < Element > ();
    for (Iterator j = textToAppend.elementIterator (); j.hasNext ();) {
        Element curNodeToInsert = (Element) j.next ();
        if (isNodeToInsertInOtherDoc (curNodeToInsert)) {
            Element copyNode = (Element) (curNodeToInsert.clone ());
            List < Element > listOfImages = Picture.getListReferenceForImagesAndOle (copyNode);
            if (! listOfImages.isEmpty ()) {
                if (! Picture.addNewReferences (listOfImages, mapOldIdToNewId)) {
                    return null;
                }
            }
            listOfNodes.add (copyNode);
        }
        else {
            if (logger.isDebugEnabled ()) {
                logger.debug ("node ignored for paragraph insertion:" + curNodeToInsert.getName () + " " + curNodeToInsert.getStringValue ());
            }
        }
    }
    return listOfNodes;
}


private void deleteInternal (HTTPurl urlData, HashMap < String, String > headers, OutputStream out) throws Exception {
    String id = urlData.getParameter ("id");
    XmlDoc xmlDoc = new XmlDoc ("schedule_action");
    ScheduleItem item = store.getScheduleItem (id);
    if (item == null) {
        System.out.println ("Schedule Item Not Found (" + id + ")");
        Element error = xmlDoc.createTextElement ("error", "Schedule Item Not Found (" + id + ")");
        xmlDoc.getRoot ().appendChild (error);
        return;
    }
    String errorString = null;
    if (item != null && (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR)) {
        store.removeScheduleItem (id);
        store.saveSchedule (null);
    }
    else {
        errorString = "Can not delete schedule (Wrong State:" + item.getState () + ") ";
    }
    if (errorString != null) {
        Element error = xmlDoc.createTextElement ("error", errorString);
        xmlDoc.getRoot ().appendChild (error);
    }
    else {
        Element message = xmlDoc.createTextElement ("message", "Schedule Deleted");
        xmlDoc.getRoot ().appendChild (message);
    }
    out.write (xmlDoc.getDocBytes ());
}


-----Function Pair=181=-----==

private boolean parseDocumentContent () throws OpenXML4JException {
    PackagePart contentPart = getCorePart ();
    if (contentPart == null) {
        logger.error ("The document has no contents!");
        return false;
    }
    if (logger.isDebugEnabled ()) {
        logger.debug ("reading doc content:" + contentPart.getUri ());
    }
    InputStream inStream = null;
    try {
        inStream = contentPart.getInputStream ();
    } catch (IOException e) {
        logger.error ("error reading the document.xml", e);
        return false;
    }
    try {
        SAXReader reader = new SAXReader ();
        content = reader.read (inStream);
    } catch (DocumentException e) {
        logger.error ("cannot read input", e);
        return false;
    }
    return true;
}


private void buildLearningUnitFslvFile (File selectedFile) {
    File outputFile = selectedFile;
    if (learningUnitViewElementsManager.isOriginalElementsOnly ()) {
        String [] elementIds = learningUnitViewElementsManager.getAllLearningUnitViewElementIds ();
        for (int i = 0; i < elementIds.length; i ++) {
            FSLLearningUnitViewElement element = learningUnitViewElementsManager.getLearningUnitViewElement (elementIds [i], false);
            if (element.getLastModificationDate () == null) {
                element.setLastModificationDate (String.valueOf (new Date ().getTime ()));
                element.setModified (true);
            }
        }
        learningUnitViewElementsManager.setModified (true);
        learningUnitViewManager.saveLearningUnitViewData ();
        if (selectedFile != null) {
            try {
                FileOutputStream os = new FileOutputStream (outputFile);
                ZipOutputStream zipOutputStream = new ZipOutputStream (os);
                File [] files = (new File (learningUnitViewManager.getLearningUnitViewOriginalDataDirectory ().getPath ())).listFiles ();
                buildExportZipFile ("", zipOutputStream, files);
                zipOutputStream.flush ();
                zipOutputStream.finish ();
                zipOutputStream.close ();
                os.close ();
            } catch (Exception exp) {
                exp.printStackTrace ();
            }
        }
    }
}


-----Function Pair=182=-----==

private static void writeToStream (File f, Serializable o) throws PersistenceException {
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream (f);
        XStream xs = new XStream ();
        xs.toXML (o, fos);
    } catch (IOException e) {
        throw new PersistenceException ("Could not write " + o.getClass ().getName () + " to " + f.getAbsolutePath () + ".", e);
    } finally {
        if (fos != null) {
            try {
                fos.close ();
            } catch (IOException e) {
            }
        }
    }
}


public static void zipDir (String dir2zip, ZipOutputStream zos) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (filePath, zos);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            ZipEntry anEntry = new ZipEntry (f.getPath ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
    }
}


-----Function Pair=183=-----==

public void Add2Ftp (Article art, File page) {
    if (article_ftp_hosts == null || article_ftp_hosts.isEmpty ()) return;
    if (art == null) return;
    for (Object obj : article_ftp_hosts) {
        FtpHost ftphost = (FtpHost) obj;
        FtpQueue ftp_queue = new FtpQueue (ftphost);
        ftp_queue = FtpScheduler.GetScheduler ().Add (ftp_queue);
        File local_file = page;
        String str_art_publish_dir = art_publish_dir.getAbsolutePath ();
        str_art_publish_dir = Utils.FixPath (str_art_publish_dir);
        String remote_file = local_file.getAbsolutePath ();
        remote_file = Utils.FixPath (remote_file);
        remote_file = remote_file.replaceFirst (str_art_publish_dir, ftphost.remotedir);
        remote_file = Utils.FixPath (remote_file);
        try {
            ftp_queue.AddTask (local_file, remote_file);
        } catch (NpsException e) {
            com.microfly.util.DefaultLog.error_noexception (e);
            continue;
        }
    }
}


public static String gunzip (String input_file) throws Exception {
    if (input_file.toLowerCase ().endsWith (".gz")) {
        if (Messenger.debug_mode) Messenger.printMsg (Messenger.DEBUG, "Gunzip " + input_file);
        InputStream in = new FileInputStream (input_file);
        String outputfile = input_file.substring (0, input_file.length () - 3);
        OutputStream out = new FileOutputStream (outputfile);
        byte [] buffer = new byte [8192];
        in = new GZIPInputStream (in, buffer.length);
        int count = in.read (buffer);
        while (count > 0) {
            out.write (buffer, 0, count);
            count = in.read (buffer);
        }
        in.close ();
        out.close ();
        return outputfile;
    }
    else {
        return input_file;
    }
}


-----Function Pair=184=-----==

public Matrix loadMatrix (Connection con, ExtentManager extents) throws SQLException {
    Debug.println ("GIEWSAttributesExternalizer.loadMatrix() START");
    Matrix mtrx = null;
    StringBuffer SQL_buf = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        mtrx = new Matrix (extents.size ());
        Key key = new Key (extents.size ());
        for (int i = 0; i < key.size (); i ++) {
            key.set (extents.at (i).size () - 1, i);
        }
        mtrx.addCell (key, 0);
        mtrx.deleteCell (key);
        SQL_buf = new StringBuffer ("select " + columns + "Data_Value, Data_Symbol from ");
        SQL_buf.append (getDataTablename ());
        SQL_buf.append (" where dataset_id = ? ");
        pstmt = con.prepareStatement (SQL_buf.toString ());
        pstmt.setInt (1, getID ());
        rs = pstmt.executeQuery ();
        Key new_key = null;
        while (rs.next ()) {
            for (int i = 0; i < key.size (); i ++) {
                String extent_code = rs.getString (i + 1);
                int extent_index = Key.WILD;
                if (extent_code != null) {
                    extent_index = extents.at (i).getIndexFromCode (extent_code, true);
                }
                key.set (extent_index, i);
                new_key = new Key (key);
            }
            float value = rs.getFloat ("Data_Value");
            char symbol = ' ';
            String symbol_str = rs.getString ("Data_Symbol");
            if (symbol_str != null && ! symbol_str.equals ("")) {
                symbol = symbol_str.charAt (0);
            }
            Cell cell = new Cell (value, symbol);
            mtrx.addCell (new_key, cell);
        }
    } finally {
        try {
            rs.close ();
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    Debug.println ("GIEWSAttributesExternalizer.loadMatrix() END");
    return mtrx;
}


public void saveFileContent (File file, String content) {
    if (file == null) {
        throw new FileSystemException ("File should not be null.");
    }
    if (! file.exists ()) {
        throw new FileSystemException ("filemanager.msg.dir_doesn_exist", "File doesn't exists.");
    }
    if (! file.canRead ()) {
        throw new FileSystemException ("filemanager.msg.unable_to_write", "Unable to save file.");
    }
    if (! file.isFile ()) {
        throw new FileSystemException ("Unable to save file.", "Should not be a directory: " + file);
    }
    if (! file.canWrite ()) {
        throw new FileSystemException ("filemanager.msg.unable_to_write", "Unable to save file.");
    }
    try {
        Writer output = new BufferedWriter (new FileWriter (file));
        try {
            output.write (content);
        } finally {
            output.close ();
        }
    } catch (Exception e) {
        throw new FileSystemException ("filemanager.msg.unable_to_write", "Unable to save file.");
    }
}


-----Function Pair=185=-----==

private File extractUninstallFiles (File _destPath, boolean upgrade, String lastVer) {
    File oldlog = null;
    try {
        boolean oldClassCopied = false;
        File destPath = new File (_destPath, "vai_" + VAGlobals.APP_NAME + "_" + VAGlobals.APP_VERSION);
        if (upgrade) {
            File lastVerPath = new File (_destPath, "vai_" + VAGlobals.APP_NAME + "_" + lastVer);
            if (destPath.equals (lastVerPath)) {
                File bkdir = new File (destPath.getAbsolutePath () + ".bak");
                if (! destPath.renameTo (bkdir)) {
                    throw new IOException (VAGlobals.i18n ("Setup_NotCreateDirectory") + " " + destPath);
                }
                oldlog = new File (bkdir.getAbsolutePath () + System.getProperty ("file.separator") + "uninstall.vai");
                lastVerPath = bkdir;
            }
            else {
                oldlog = new File (lastVerPath.getAbsolutePath () + System.getProperty ("file.separator") + "uninstall.vai");
            }
            if ((! destPath.exists ()) && (! destPath.mkdirs ())) {
                throw new IOException (VAGlobals.i18n ("Setup_NotCreateDirectory") + " " + destPath);
            }
            if (uInfo_.module) oldClassCopied = copyOldSetupClass (lastVerPath, destPath);
        }
        else {
            if ((! destPath.exists ()) && (! destPath.mkdirs ())) {
                throw new IOException (VAGlobals.i18n ("Setup_NotCreateDirectory") + " " + destPath);
            }
        }
        dirty_ = true;
        File [] ls = destPath.listFiles ();
        for (int i = 0; i < ls.length; i ++) {
            if (! oldClassCopied) ls [i].delete ();
            else if (! ls [i].getPath ().equals (destPath.getAbsolutePath () + File.separator + installClassName_ + ".class")) ls [i].delete ();
        }
        byte [] buf = new byte [0];
        int read = 0;
        if (! oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {
            final File outClassFile = new File (destPath.getAbsolutePath () + File.separator + installClassName_ + ".class");
            if (outClassFile.exists () && ! outClassFile.delete ()) {
                ui_.showError (new Exception (VAGlobals.i18n ("Setup_FileNotCreated") + ":\n" + outClassFile.getName ()));
            }
            final FileOutputStream out = new FileOutputStream (outClassFile);
            final FileInputStream in = new FileInputStream (fileWithArchive_);
            if (installClassOffset_ > 0) {
                in.skip (installClassOffset_);
            }
            buf = new byte [0];
            if (installClassSize_ < 0) buf = new byte [(int) jarOffset_];
            else buf = new byte [(int) installClassSize_];
            read = in.read (buf, 0, buf.length);
            out.write (buf, 0, read);
            out.close ();
            in.close ();
        }
        final FileInputStream in = new FileInputStream (fileWithArchive_);
        if (jarOffset_ > 0) {
            in.skip (jarOffset_);
        }
        JarInputStream jar = new JarInputStream (in);
        final File outJarFile = new File (destPath.getAbsolutePath () + File.separator + "install.jar");
        if (outJarFile.exists () && ! outJarFile.delete ()) {
            ui_.showError (new Exception (VAGlobals.i18n ("Setup_FileNotCreated") + ":\n" + outJarFile.getName ()));
        }
        JarOutputStream outJar = new JarOutputStream (new FileOutputStream (outJarFile));
        ZipEntry entry = jar.getNextEntry ();
        final int bufSize = 32768;
        buf = new byte [bufSize];
        while (entry != null) {
            String entryName = entry.getName ();
            if (entryName.equals ("com/memoire/vainstall/resources/vainstall.properties")) {
            }
            else if (entryName.equals (installClassName_ + ".class") && ! oldClassCopied) {
                FileOutputStream out = null;
                try {
                    out = new FileOutputStream (destPath.getAbsolutePath () + File.separator + installClassName_ + ".class");
                    VAGlobals.copyStream (jar, out, buf);
                } catch (IOException e) {
                    throw e;
                } finally {
                    if (out != null) out.close ();
                }
            }
            else if (! entryName.endsWith (".zip")) {
                if (VAGlobals.DEBUG) VAGlobals.printDebug ("jar entry name " + entryName);
                ZipEntry outEntry = new ZipEntry (entryName);
                CRC32 crc = new CRC32 ();
                outJar.putNextEntry (outEntry);
                int size = 0;
                while ((read = jar.read (buf, 0, bufSize)) >= 0) {
                    size += read;
                    if (read == 0) {
                        Thread.yield ();
                    }
                    else {
                        outJar.write (buf, 0, read);
                        crc.update (buf, 0, read);
                    }
                }
                outEntry.setSize (size);
                outEntry.setCrc (crc.getValue ());
                outJar.flush ();
                outJar.closeEntry ();
            }
            jar.closeEntry ();
            entry = jar.getNextEntry ();
        }
        InputStream pin = getClass ().getResourceAsStream ("resources/vainstall.properties");
        Properties prop = new Properties ();
        try {
            prop.load (pin);
        } catch (IOException exc) {
        }
        if (language == null) language = "default";
        prop.setProperty ("vainstall.destination.language", language);
        ZipEntry outEntry = new ZipEntry ("com/memoire/vainstall/resources/vainstall.properties");
        CRC32 crc = new CRC32 ();
        outEntry.setCrc (crc.getValue ());
        outEntry.setSize (prop.size ());
        outJar.putNextEntry (outEntry);
        prop.store (outJar, VAGlobals.NAME + " " + VAGlobals.VERSION);
        outEntry.setCrc (crc.getValue ());
        outJar.closeEntry ();
        jar.close ();
        outJar.close ();
        in.close ();
    } catch (IOException e) {
        String message = e.getLocalizedMessage ();
        message += "\n" + VAGlobals.i18n ("Setup_ErrorUninstallScripts");
        e.printStackTrace ();
        exitOnError (new IOException (message));
    }
    return oldlog;
}


public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


-----Function Pair=186=-----==

public void Delete (NpsContext ctxt) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        List topics = null;
        if (Config.CACHE) {
            topics = GetTopics (ctxt);
        }
        String sql = "delete from topic_pts where templateid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update topic set art_template=null where art_template=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from template where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        for (int i = 0; topics != null && i < topics.size (); i ++) {
            TopicProfile profile = (TopicProfile) topics.get (i);
            Site site = ctxt.GetSite (profile.GetSiteId ());
            if (site == null) continue;
            TopicTree topic_tree = site.GetTopicTree ();
            if (topic_tree == null) continue;
            Topic topic = topic_tree.GetTopic (profile.GetId ());
            if (topic == null) continue;
            if (this instanceof ArticleTemplate) topic.SetArticleTemplate (null);
            else topic.RemovePageTemplate (id);
        }
        DeleteJavaFiles ();
        TemplatePool.GetPool ().remove (this);
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


public void entry (String path) {
    if ('/' != path.charAt (path.length () - 1)) {
        path += "/";
    }
    LinkedList < JarEntry > list = new LinkedList < JarEntry > ();
    for (int i = path.lastIndexOf ('/'); 0 < i; i = path.lastIndexOf ('/', i - 1)) {
        path = path.substring (0, i + 1);
        if (this.existsDirectories.add (path)) {
            JarEntry entry = new JarEntry (path);
            entry.setMethod (ZipEntry.STORED);
            entry.setSize (0);
            entry.setCrc (0);
            list.addLast (entry);
        }
        else {
            break;
        }
    }
    try {
        for (JarEntry je : list) {
            this.stream.putNextEntry (je);
        }
    } catch (Exception e) {
        handle (e);
    }
}


-----Function Pair=187=-----==

public void run () throws VersionException, PermissionException {
    log.log ("Checking version information");
    UpdateInfo info = Utils.verifyVersion (updateJar, applicationDirectory);
    if (info.from.compareTo (info.to) < 0) {
        log.log ("Upgrading from " + info.from + " to " + info.to);
    }
    else {
        log.log ("Downgrading from " + info.from + " back to " + info.to);
    }
    log.log ("Checking write permissions");
    checkPermissions ();
    if (createUninstaller) {
        log.log ("Creating uninstall folder");
        uninstallJar = new File (applicationDirectory, "autooutdate");
        uninstallJar.mkdirs ();
        String verName = info.to.getCleanName () + "_to_" + info.from.getCleanName ();
        uninstallJar = new File (uninstallJar, verName + ".jar");
        log.log ("Creating uninstaller:  " + uninstallJar.getAbsolutePath ());
        try {
            uninstallStream = new CloseNowZipOutputStream (new FileOutputStream (uninstallJar));
        } catch (FileNotFoundException e) {
            throw new UpdateIOException ("Unable to create uninstaller.", e);
        }
    }
    else {
        log.log ("Uninstaller was not requested.");
    }
    deleteThem.clear ();
    deleteThem.addAll (info.deleteFiles);
    deleteSingleFiles ();
    log.log ("Updating " + applicationDirectoryName + " from " + updateJar.getAbsolutePath ());
    while (true) {
        ZipEntry en = null;
        try {
            en = jarInputStream.getNextEntry ();
        } catch (IOException e) {
            throw new UpdateIOException ("Error reading from udpate archive.", e);
        }
        if (en == null) {
            break;
        }
        updateEntry (en);
    }
    deleteWhereNoneAdded ();
    if (createUninstaller) {
        try {
            UpdateInfo uninfo = new UpdateInfo ();
            uninfo.from = info.to;
            uninfo.to = info.from;
            uninfo.setDelete (newEntries);
            uninfo.writeTo (uninstallStream);
            uninstallStream.closeNOW ();
        } catch (IOException e) {
            throw new UpdateIOException ("Error writing to uninstaller.", e);
        }
    }
    finished ();
    log.log (updateJar.getAbsolutePath () + " will be deleted on exit.");
    updateJar.deleteOnExit ();
}


public void run () {
    Init (null);
    File old_file = new File (zipFile.getAbsolutePath () + "_tmp_" + (new Date ()).getSeconds () + ".zip");
    try {
        ZipFile zf = new ZipFile (zipFile);
        int removed = 0, processed = 0, num_entries = zf.size ();
        long total_size = zipFile.length (), bytes_saved = 0;
        final String del = ctx.getString (R.string.deleting_a);
        if (! zipFile.renameTo (old_file)) {
            error ("could not rename the file " + zipFile.getAbsolutePath () + " to " + old_file.getAbsolutePath ());
        }
        else {
            ZipInputStream zin = new ZipInputStream (new FileInputStream (old_file));
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
            byte [] buf = new byte [BLOCK_SIZE];
            ZipEntry entry = zin.getNextEntry ();
            while (entry != null) {
                if (isStopReq ()) break;
                String name = entry.getName ();
                boolean spare_this = true;
                for (ZipEntry z : mList) {
                    if (isStopReq ()) break;
                    String name_to_delete = z.getName ();
                    if (name.startsWith (name_to_delete)) {
                        spare_this = false;
                        removed ++;
                        break;
                    }
                }
                if (spare_this) {
                    int pp = ++ processed * 100 / num_entries;
                    out.putNextEntry (new ZipEntry (name));
                    int len;
                    while ((len = zin.read (buf)) > 0) {
                        if (isStopReq ()) break;
                        out.write (buf, 0, len);
                        bytes_saved += len;
                        sendProgress (del, pp, (int) (bytes_saved * 100 / total_size));
                    }
                }
                entry = zin.getNextEntry ();
            }
            zin.close ();
            try {
                out.close ();
            } catch (Exception e) {
                Log.e (TAG, "DelEngine.run()->out.close()", e);
            }
            if (isStopReq ()) {
                zipFile.delete ();
                old_file.renameTo (zipFile);
                processed = 0;
                error (s (R.string.interrupted));
            }
            else {
                old_file.delete ();
                zip = null;
                sendResult (Utils.getOpReport (ctx, removed, R.string.deleted));
                return;
            }
        }
    } catch (Exception e) {
        error (e.getMessage ());
    }
    sendResult (Utils.getOpReport (ctx, 0, R.string.deleted));
    super.run ();
}


-----Function Pair=188=-----==

void dirSize (String fs, LongNum c, LongNum lm) throws IOException {
    File f = new File (fs);
    String [] flist = f.list ();
    if (flist == null || flist.length < 1) return;
    long lmod = 0;
    for (int i = 0; i < flist.length; i ++) {
        String p = f.getAbsolutePath ();
        if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
        File nf = new File (p + flist [i]);
        if (nf.isDirectory ()) dirSize (p + flist [i], c, lm);
        else {
            if (flist [i].equals ("core") && nf.length () > 1000000) {
                nf.delete ();
                tools.util.LogMgr.debug ("******* DELETED existing core from context dir: " + nf);
            }
            else {
                c.increment (nf.length ());
                lmod = nf.lastModified ();
                if (lmod > lm.value) lm.value = lmod;
            }
        }
    }
}


public byte [] read (String fileName) {
    byte [] buff = new byte [0];
    try {
        FileInputStream fis = new FileInputStream (new File (fileName));
        byte [] buf = new byte [1024];
        int len;
        while ((len = fis.read (buf)) > 0) {
            byte [] buff1 = new byte [buff.length + len];
            System.arraycopy (buff, 0, buff1, 0, buff.length);
            System.arraycopy (buf, 0, buff1, buff.length, len);
            buff = buff1;
        }
        fis.close ();
    } catch (Exception e) {
    }
    return buff;
}


-----Function Pair=189=-----=1=

private boolean writeEntry (File f, JarOutputStream out, int depth) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            i = f.getPath ().length ();
            fPath = f.getPath ();
            for (int a = 0; a <= depth; a ++) {
                i = fPath.lastIndexOf (FILESEPARATOR, i) - 1;
            }
            en = fPath.substring (i + 2, fPath.length ());
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, depth + 1);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


public static void writeEntry (File file, File input) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ARGOUML_EXT);
        temporaryFile.deleteOnExit ();
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        FileInputStream inputStream = new FileInputStream (input);
        ZipEntry entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT);
        output.putNextEntry (new ZipEntry (entry));
        IOUtils.copy (inputStream, output);
        output.closeEntry ();
        inputStream.close ();
        entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + ".argo");
        output.putNextEntry (new ZipEntry (entry));
        output.write (ArgoWriter.getArgoContent (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT).getBytes ());
        output.closeEntry ();
        output.close ();
        temporaryFile.renameTo (file);
    } catch (IOException ioe) {
        throw new PersistenceException (ioe);
    }
}


-----Function Pair=190=-----==

public void test_skipJ () throws Exception {
    zentry = zis.getNextEntry ();
    byte [] rbuf = new byte [(int) zentry.getSize ()];
    zis.skip (2);
    int r = zis.read (rbuf, 0, rbuf.length);
    assertEquals ("Failed to skip data", 10, r);
    zentry = zis.getNextEntry ();
    zentry = zis.getNextEntry ();
    long s = zis.skip (1025);
    assertTrue ("invalid skip: " + s, s == 1025);
    ZipInputStream zis = new ZipInputStream (new ByteArrayInputStream (zipBytes));
    zis.getNextEntry ();
    long skipLen = dataBytes.length / 2;
    assertEquals ("Assert 0: failed valid skip", skipLen, zis.skip (skipLen));
    zis.skip (dataBytes.length);
    assertEquals ("Assert 1: performed invalid skip", 0, zis.skip (1));
    assertEquals ("Assert 2: failed zero len skip", 0, zis.skip (0));
    try {
        zis.skip (- 1);
        fail ("Assert 3: Expected Illegal argument exception");
    } catch (IllegalArgumentException e) {
    }
}


public static boolean archiveFolder (String folderPath, ZipOutputStream zos, String ignoredPathPrefix) {
    try {
        File zipDir = new File (folderPath);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                archiveFolder (filePath, zos, ignoredPathPrefix);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String entryPath = f.getPath ();
            if (entryPath.startsWith (ignoredPathPrefix)) {
                entryPath = entryPath.substring (ignoredPathPrefix.length () + 1);
            }
            ZipEntry anEntry = new ZipEntry (entryPath.replace ('\\', '/'));
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return true;
}


-----Function Pair=191=-----==

private void handleFileStructure (StringBuffer buffer, SelectableEntry entry) {
    buffer.append ("<METS:div LABEL=\"");
    buffer.append (StreamUtility.enc (entry.getShortName ()));
    buffer.append ("\" TYPE=\"file\">");
    buffer.append ("<METS:div LABEL=\"Content\" TYPE=\"content\">");
    buffer.append ("<METS:fptr FILEID=\"");
    buffer.append (StreamUtility.enc (entry.getID ()));
    buffer.append ("\"/>");
    buffer.append ("</METS:div>");
    for (int ctr = 0; ctr < entry.getMetadataCount (); ctr ++) {
        Metadata metadata = entry.getMetadata (ctr);
        buffer.append ("<METS:div LABEL=\"");
        buffer.append (StreamUtility.enc (metadata.getLabel ()));
        buffer.append ("\" TYPE=\"");
        buffer.append (StreamUtility.enc (metadata.getType ()));
        buffer.append ("\">");
        buffer.append ("<METS:fptr FILEID=\"");
        buffer.append (StreamUtility.enc (metadata.getID ()));
        buffer.append ("\"/>");
        buffer.append ("</METS:div>");
    }
    buffer.append ("</METS:div>");
}


public static void main (String [] args) {
    try {
        File src_dir = new File (args [0]);
        File dst_file = new File (src_dir, src_dir.getName () + ".zip");
        Pattern macher = java.util.regex.Pattern.compile (args [1]);
        LinkedHashMap < String, Pair < Integer, Integer > > log = new LinkedHashMap < String, Pair < Integer, Integer > > ();
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            ZipOutputStream zos = new ZipOutputStream (baos);
            zos.setComment ("");
            zos.setLevel (9);
            zos.setMethod (ZipOutputStream.DEFLATED);
            for (File file : src_dir.listFiles ()) {
                if (macher.matcher (file.getName ()).find ()) {
                    byte [] data = CFile.readData (file);
                    ZipEntry e = new ZipEntry (file.getName ());
                    e.setTime (0);
                    zos.putNextEntry (e);
                    zos.write (data);
                    log.put (file.getName (), new Pair < Integer, Integer > (data.length, 0));
                }
            }
            zos.finish ();
            zos.close ();
            CFile.writeData (dst_file, baos.toByteArray ());
            System.out.println ("save to : " + dst_file);
        } catch (Exception err) {
            err.printStackTrace ();
        }
        try {
            byte [] fdata = CFile.readData (dst_file);
            ByteArrayInputStream bais = new ByteArrayInputStream (fdata);
            ZipInputStream zis = new ZipInputStream (bais);
            for (ZipEntry e = zis.getNextEntry (); e != null; e = zis.getNextEntry ()) {
                Pair < Integer, Integer > p = log.get (e.getName ());
                p.setValue (ZipUtil.readBytes (zis).length);
                System.out.println ("check | " + CUtil.snapStringRightSize (e.getName (), 32, ' ') + " | " + CUtil.snapStringRightSize (p.getKey (), 16, ' ') + " | " + p.getValue ());
            }
            zis.close ();
        } catch (Exception err) {
            err.printStackTrace ();
        }
    } catch (Exception err) {
        System.out.println ("useage: Packer <src dir> <regx filter>");
        err.printStackTrace ();
    }
}


-----Function Pair=192=-----==

private void copyDir (File srcRoot, File dir, File destRoot) throws IOException {
    File [] children = dir.listFiles ();
    if (children == null) return;
    for (int ii = 0; ii < children.length; ++ ii) {
        File child = children [ii];
        String relPath = makeRel (srcRoot, child);
        if (checkExceptionList (relPath)) continue;
        if (child.isDirectory ()) {
            File destDir = new File (destRoot, relPath);
            destDir.mkdirs ();
            copyDir (srcRoot, child, destRoot);
        }
        else {
            log (child.toString ());
            File destFile = new File (destRoot, relPath);
            copyFile (child, destFile);
        }
    }
}


public ProgressDialog (Frame _owner, int _steps, String _title, Dimension _size) {
    super (_owner);
    totalSteps = _steps;
    setTitle (_title);
    setSize (_size);
    setModal (false);
    getContentPane ().setLayout (new java.awt.BorderLayout ());
    JPanel progressPanel = new JPanel () {
        public Insets getInsets () {
            return new Insets (15, 10, 5, 10);
        }
    }
    ;
    progressPanel.setLayout (new BoxLayout (progressPanel, BoxLayout.Y_AXIS));
    getContentPane ().add (progressPanel, BorderLayout.CENTER);
    Dimension d = new Dimension (_size.width, 20);
    progressLabel = new JLabel (_title);
    progressLabel.setAlignmentX (CENTER_ALIGNMENT);
    progressLabel.setMaximumSize (d);
    progressLabel.setPreferredSize (d);
    progressPanel.add (progressLabel);
    progressPanel.add (Box.createRigidArea (new Dimension (1, 20)));
    progressBar = new JProgressBar (0, totalSteps);
    progressBar.setStringPainted (true);
    progressLabel.setLabelFor (progressBar);
    progressBar.setAlignmentX (CENTER_ALIGNMENT);
    progressPanel.add (progressBar);
    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    setLocation ((screenSize.width - _size.width) / 2, (screenSize.height - _size.width) / 2);
    getContentPane ().add (progressPanel, BorderLayout.CENTER);
    setCursor (new Cursor (Cursor.WAIT_CURSOR));
    setVisible (true);
}


-----Function Pair=193=-----==

public void actionPerformed (ActionEvent e) {
    window.ui2Engine ();
    String name = context.getJAlbumContext ().getEngine ().getSkin ();
    int answer = JOptionPane.showConfirmDialog (window, "Are you sure you wish to delete the " + name + " skin?", "Delete selected skin", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);
    if (answer != JOptionPane.YES_OPTION) {
        return;
    }
    ChainedDirectory chainedSkinsDir = Config.getConfig ().chainedSkinsDir;
    File skinDir = chainedSkinsDir.getFile (name);
    context.getJAlbumContext ().getEngine ().unloadCurrentSkin ();
    context.getJAlbumContext ().getEngine ().setSkin ("");
    System.out.println ("Skin is " + context.getJAlbumContext ().getEngine ().getSkin ());
    IO.recycle (skinDir);
    window.mainSettingsPanel.scanSkins ();
}


public static void extract (final File destDir, final ZipInfo zipInfo, final IProgressMonitor monitor) throws IOException {
    if (! destDir.exists ()) destDir.mkdirs ();
    for (String key : zipInfo.getEntryKeys ()) {
        ZipEntry entry = zipInfo.getEntry (key);
        InputStream in = zipInfo.getInputStream (entry);
        File entryDest = new File (destDir, entry.getName ());
        entryDest.getParentFile ().mkdirs ();
        if (! entry.isDirectory ()) {
            OutputStream out = new FileOutputStream (new File (destDir, entry.getName ()));
            try {
                IOUtils.copy (in, out);
                out.flush ();
                if (monitor != null) monitor.worked (1);
            } finally {
                IOUtils.closeQuietly (in);
                IOUtils.closeQuietly (out);
            }
        }
    }
    if (monitor != null) monitor.done ();
}


-----Function Pair=194=-----==

private void addAllUploadedFiles (Environment en, ZipOutputStream zipout, int progressStart, int progressLength) throws IOException, FileNotFoundException {
    File uploadPath = en.uploadPath (virtualWiki, "");
    String [] files = uploadPath.list ();
    int bytesRead = 0;
    byte byteArray [] = new byte [4096];
    for (int i = 0; i < files.length; i ++) {
        String fileName = files [i];
        File file = en.uploadPath (virtualWiki, fileName);
        if (file.isDirectory ()) {
            continue;
        }
        progress = Math.min (progressStart + (int) ((double) i * (double) progressLength / files.length), 99);
        logger.fine ("Adding uploaded file " + fileName);
        ZipEntry entry = new ZipEntry (safename (fileName));
        try {
            FileInputStream in = new FileInputStream (file);
            zipout.putNextEntry (entry);
            while (in.available () > 0) {
                bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
                zipout.write (byteArray, 0, bytesRead);
            }
            zipout.closeEntry ();
            zipout.flush ();
        } catch (FileNotFoundException e) {
            logger.log (Level.WARNING, "Could not open file!", e);
        } catch (IOException e) {
            logger.log (Level.WARNING, "IOException!", e);
            try {
                zipout.closeEntry ();
                zipout.flush ();
            } catch (IOException e1) {
            }
        }
    }
}


public boolean writeZipFile (String inputDirPath, String zipOutputFile) {
    try {
        FileOutputStream fos = new FileOutputStream (zipOutputFile);
        ZipOutputStream zos = new ZipOutputStream (fos);
        File f = new File (inputDirPath);
        if (! zipDir (inputDirPath, inputDirPath, zos)) {
            errMsgLog += "Problem zipping directory '" + inputDirPath + "' zipDir() failed.";
            lastErrMsgLog = errMsgLog;
            return (false);
        }
        zos.close ();
        return (true);
    } catch (Exception e) {
        errMsgLog += "Problem zipping directory '" + inputDirPath + "' writeZipFile() failed.";
        lastErrMsgLog = errMsgLog;
        return (false);
    }
}


-----Function Pair=195=-----==

public static void main (String [] args) {
    if (args.length < 2) {
        outputHelp ();
        return;
    }
    String version = null;
    File baseSrcDir = null;
    File dstDir = null;
    boolean verbose = false;
    int i;
    for (i = 0; i < args.length; i ++) {
        String arg = args [i];
        if (arg.startsWith ("-") == false) {
            break;
        }
        if ("-srcdir".equals (arg)) {
            if (baseSrcDir == null && ++ i < args.length) {
                baseSrcDir = new File (args [i]);
                continue;
            }
        }
        else if ("-dstdir".equals (arg)) {
            if (dstDir == null && ++ i < args.length) {
                dstDir = new File (args [i]);
                continue;
            }
        }
        else if ("-version".equals (arg)) {
            if (version == null && ++ i < args.length) {
                version = args [i];
                continue;
            }
        }
        else if ("-verbose".equals (arg)) {
            if (verbose == false) {
                verbose = true;
                continue;
            }
        }
        else if ("-help".equals (arg) == false) {
            System.out.println ("Unrecognised option: " + arg);
        }
        outputHelp ();
        return;
    }
    if (baseSrcDir == null) {
        System.out.println ("Source directory must be specified using -srcdir: " + baseSrcDir);
        return;
    }
    if (baseSrcDir.isDirectory () == false) {
        System.out.println ("Source does not exist or is not a directory: " + baseSrcDir);
        return;
    }
    dstDir = (dstDir != null ? dstDir : baseSrcDir);
    List < String > srcFileNames = Arrays.asList (Arrays.copyOfRange (args, i, args.length));
    if (srcFileNames.isEmpty ()) {
        System.out.println ("Source filenames not specified, using default set");
        System.out.println ("(africa antarctica asia australasia backward etcetera europe northamerica southamerica)");
        srcFileNames = Arrays.asList ("africa", "antarctica", "asia", "australasia", "backward", "etcetera", "europe", "northamerica", "southamerica");
    }
    List < File > srcDirs = new ArrayList < File > ();
    if (version != null) {
        File srcDir = new File (baseSrcDir, version);
        if (srcDir.isDirectory () == false) {
            System.out.println ("Version does not represent a valid source directory : " + srcDir);
            return;
        }
        srcDirs.add (srcDir);
    }
    else {
        File [] dirs = baseSrcDir.listFiles ();
        for (File dir : dirs) {
            if (dir.isDirectory () && dir.getName ().matches ("[12][0-9][0-9][0-9][A-Za-z0-9._-]+")) {
                srcDirs.add (dir);
            }
        }
    }
    if (srcDirs.isEmpty ()) {
        System.out.println ("Source directory contains no valid source folders: " + baseSrcDir);
        return;
    }
    if (dstDir.exists () == false && dstDir.mkdirs () == false) {
        System.out.println ("Destination directory could not be created: " + dstDir);
        return;
    }
    if (dstDir.isDirectory () == false) {
        System.out.println ("Destination is not a directory: " + dstDir);
        return;
    }
    process (srcDirs, srcFileNames, dstDir, verbose);
    System.exit (0);
}


public boolean existeFichero (String rutaFichero) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'existeFichero' ***********");
    boolean estado = false;
    File archivo = new File (rutaFichero);
    boolean existe = archivo.exists ();
    try {
        if (existe == false) {
            archivo.createNewFile ();
            System.out.println ("El Fichero se creo correctamente ...!!!");
        }
        else {
            System.out.println ("El Fichero ya Existe ...!!!");
        }
        estado = true;
    } catch (Exception e) {
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


-----Function Pair=196=-----==

public void setThumbnailWatermarkFile (File thumbnailWatermarkFile) {
    if (thumbnailWatermarkFile != null) {
        Image p = Toolkit.getDefaultToolkit ().createImage (thumbnailWatermarkFile.getAbsolutePath ());
        Container c = new Container ();
        MediaTracker m = new MediaTracker (c);
        m.addImage (p, 0);
        try {
            m.waitForID (0);
        } catch (InterruptedException ex) {
            ex.printStackTrace ();
        }
        if (p.getWidth (null) > 0 && p.getHeight (null) > 0) {
            this.watermarkFile = thumbnailWatermarkFile;
            thumbnailWatermarkImage = p;
        }
    }
}


private void loadDrivingLicense () {
    JFileChooser fileChooser = new JFileChooser ();
    fileChooser.setFileFilter (net.sourceforge.scuba.util.Files.ZIP_FILE_FILTER);
    int choice = fileChooser.showOpenDialog (getContentPane ());
    switch (choice) {
        case JFileChooser.APPROVE_OPTION :
            try {
                if (privateKey != null) {
                    dl = new DrivingLicense (fileChooser.getSelectedFile (), true, new SimpleDocumentSigner (privateKey));
                }
                else {
                    dl = new DrivingLicense (fileChooser.getSelectedFile ());
                }
                propagateDrivingLicenseData ();
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
        default :
            break;
    }
}


-----Function Pair=197=-----==

public static boolean prepareSampleDirectory (File smplDir, boolean dirRequired) throws PackageGenerationException {
    if (smplDir.exists ()) {
        if (! dirRequired) {
            if (! UserMessaging.askYesNo ("<html>This particular package does not require a sample directory but the directory " + smplDir.getName () + " already exists.<br><br>To avoid confusion or a potential conflict, delete this directory before proceeding?</html>", "Potential confusion")) return true;
            File [] contents = smplDir.listFiles ();
            if (contents.length > 0) for (int i = 0; i < contents.length; i ++) if (contents [i].isDirectory ()) throw new PackageGenerationException ("Could not delete the conflicting directory " + smplDir.getName () + "  as it contains sub-directories.");
            for (int i = 0; i < contents.length; i ++) if (! contents [i].delete ()) throw new PackageGenerationException ("Couldn't delete a file in the conflicting sample directory");
            if (! smplDir.delete ()) throw new PackageGenerationException ("Could not delete the conflicting sample directory " + smplDir.getName ());
        }
        else {
            File [] contents = smplDir.listFiles ();
            if (contents.length > 0) for (int i = 0; i < contents.length; i ++) if (contents [i].isDirectory ()) throw new PackageGenerationException ("Directory " + smplDir.getName () + " already exists and contains sub-directories.");
            if (contents.length > 0) {
                if (! UserMessaging.askYesNo ("Directory " + smplDir.getName () + " already exists and contains some files. Delete these and use directory?", "Directory already exists")) return false;
                for (int i = 0; i < contents.length; i ++) if (! contents [i].delete ()) throw new PackageGenerationException ("Couldn't delete a file in the existing sample directory");
            }
            else {
                if (! UserMessaging.askYesNo ("Directory " + smplDir.getName () + " already exists but is empty. Use it?", "Directory already exists")) return false;
            }
        }
    }
    else {
        if (dirRequired && ! smplDir.mkdir ()) throw new PackageGenerationException ("Could not create the sample directory");
    }
    return true;
}


public ModelAndView handleRequest (HttpServletRequest request, HttpServletResponse response) throws Exception {
    IDatabaseConnection connection = null;
    try {
        connection = new DatabaseConnection (dataSource.getConnection ());
        DatabaseConfig _config = connection.getConfig ();
        _config.setProperty (DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new MySqlDataTypeFactory ());
        QueryDataSet partialDataSet = new QueryDataSet (connection);
        partialDataSet.addTable ("OSM_GROUPS");
        partialDataSet.addTable ("OSM_USERS");
        partialDataSet.addTable ("OSM_USER_GROUPS");
        partialDataSet.addTable ("OSM_TAGS");
        partialDataSet.addTable ("OSM_TYPEVENTS_D");
        partialDataSet.addTable ("OSM_EVENT_TEMPLATES");
        partialDataSet.addTable ("OSM_TYPEVENTS_TEMPLATES_D");
        partialDataSet.addTable ("OSM_INTERFACES_D");
        partialDataSet.addTable ("OSM_INTERFACES_TYPINST_D");
        partialDataSet.addTable ("OSM_INTERFACE_USEREVENTS");
        partialDataSet.addTable ("OSM_INTERFACE_PARAMS_D");
        partialDataSet.addTable ("OSM_INSTANCES", "SELECT IDN_INSTANCE,DES_INSTANCE,TYP_INSTANCE,DTI_CREATED,USR_CREATION,0 AS TYP_CRITICITY,'osmiusNow' AS DTI_CRITICITY, 1 AS IND_AVAILABILITY, 'osmiusNow' AS DTI_AVAILABILITY, CONN_INFO, IDN_NODENAME, SNM_COMMUNITY, SNM_PORT FROM OSM_INSTANCES");
        partialDataSet.addTable ("OSM_INSTANCES_POINTS");
        partialDataSet.addTable ("OSM_INSTANCE_TAGS");
        partialDataSet.addTable ("OSM_INSTANCE_INFO");
        partialDataSet.addTable ("OSM_INSTANCE_EVENTS");
        partialDataSet.addTable ("OSM_INSTANCE_DEPENDENCIES");
        partialDataSet.addTable ("OSM_GROUP_INSTANCES", "SELECT IDN_GROUP, IDN_INSTANCE FROM OSM_GROUP_INSTANCES WHERE IDN_GROUP<>'00000000'");
        partialDataSet.addTable ("OSM_MASTERAGENTS");
        partialDataSet.addTable ("OSM_MASTERAGENTS_DISCOVERED");
        partialDataSet.addTable ("OSM_MASTERAGENT_DEFPARAM_D");
        partialDataSet.addTable ("OSM_MASTERAGENT_PARAMETERS");
        partialDataSet.addTable ("OSM_AGENTS");
        partialDataSet.addTable ("OSM_AGENT_PARAMETERS");
        partialDataSet.addTable ("OSM_AGENT_INSTANCES");
        partialDataSet.addTable ("OSM_SCHEDULES");
        partialDataSet.addTable ("OSM_TIMESCHEDULES");
        partialDataSet.addTable ("OSM_RULES");
        partialDataSet.addTable ("OSM_RULES_INSTANCES");
        partialDataSet.addTable ("OSM_SLAS");
        partialDataSet.addTable ("OSM_INTERRUPTIONS");
        partialDataSet.addTable ("OSM_AGGRUPATIONS");
        partialDataSet.addTable ("OSM_SERVICES", "SELECT IDN_SERVICE, DES_SERVICE, 0 AS TYP_CRITICITY, 'osmiusNow' AS DTI_CRITICITY, 1 AS IND_AVAILABILITY, 'osmiusNow' AS DTI_AVAILABILITY, IDN_SCHEDULE,IDN_RESPONSIBLE FROM OSM_SERVICES");
        partialDataSet.addTable ("OSM_SERVICES_POINTS");
        partialDataSet.addTable ("OSM_SERVICE_SLAS");
        partialDataSet.addTable ("OSM_SERVICE_RULES");
        partialDataSet.addTable ("OSM_SERVICE_INTERRUPTIONS");
        partialDataSet.addTable ("OSM_SERVICE_INSTANCES");
        partialDataSet.addTable ("OSM_SERVICE_AGGRUPATIONS");
        partialDataSet.addTable ("OSM_SEQUENCES");
        partialDataSet.addTable ("OSM_INSTANCE_INSTRUCTIONS");
        partialDataSet.addTable ("OSM_INSTRUCTIONS");
        partialDataSet.addTable ("OSM_USERSCRIPTS");
        partialDataSet.addTable ("OSM_USERSCRIPT_TYPPLATFORM");
        partialDataSet.addTable ("OSM_USERSCRIPT_MASTERAGENT");
        partialDataSet.addTable ("OSM_GENDATA");
        partialDataSet.addTable ("OSM_DWH_CFG", "SELECT IND_ACTIVATEROUNDROBIN,NUM_DAYSAGGR_H,NUM_DAYSAGGR_D,NUM_DAYSAGGR_E,IND_BACKUPEVENTS,NUM_DAYSERASE_OTHERS,0 AS IND_STATE,'osmiusNow' AS DTI_INIEXEC,'osmiusNow' AS DTI_FINEXEC,'osmiusNowII' AS DAY_LASTSTATS,'osmiusNowII' AS DAY_LASTAGGR FROM OSM_DWH_CFG");
        partialDataSet.addTable ("OSM_N_TYPNOTIFIWAY_D");
        partialDataSet.addTable ("OSM_N_TYPNOTIFICATIONS_D");
        partialDataSet.addTable ("OSM_N_TYPNOTIFIWAY_USERDATA_D");
        partialDataSet.addTable ("OSM_N_TYPNOTIFICATIONS_DATA_D");
        partialDataSet.addTable ("OSM_N_NOTIFIWAY");
        partialDataSet.addTable ("OSM_N_NOTIFIWAY_SCHEDULE");
        partialDataSet.addTable ("OSM_N_USER_TYPNOTIFIWAY");
        partialDataSet.addTable ("OSM_N_SUBSCRIPTION");
        partialDataSet.addTable ("OSM_N_USER_SUBSCRIPTION");
        partialDataSet.addTable ("OSM_N_SLA_SUBSCRIPTION");
        partialDataSet.addTable ("OSM_N_SERVICE_SUBSCRIPTION");
        partialDataSet.addTable ("OSM_N_INSTANCE_SUBSCRIPTION");
        partialDataSet.addTable ("OSM_N_OUTOFOFFICE");
        partialDataSet.addTable ("OSM_N_GUARD");
        partialDataSet.addTable ("OSM_N_TIMEGUARDS");
        partialDataSet.addTable ("OSM_T_ENTERPRISES");
        partialDataSet.addTable ("OSM_T_TYPEVENTS");
        partialDataSet.addTable ("OSM_T_EVENT_TYPINSTANCES");
        partialDataSet.addTable ("OSM_T_EVENT_TRAPS");
        partialDataSet.addTable ("OSM_T_TRAP_VARSBIND");
        partialDataSet.addTable ("OSM_T_TRAPS_RECEIVED");
        partialDataSet.addTable ("OSM_T_TRAPS_DISCOVERED");
        partialDataSet.addTable ("OSM_T_MASTERAGENT_INSTANCES");
        partialDataSet.addTable ("OSM_T_INSTANCE_EVENTS");
        partialDataSet.addTable ("OSM_PUBLIC_HOLIDAYS");
        partialDataSet.addTable ("OSM_TYP_WIDGETS");
        partialDataSet.addTable ("OSM_TYP_WIDGETS_PARAMS");
        partialDataSet.addTable ("OSM_WIDGETS");
        partialDataSet.addTable ("OSM_WIDGETS_VIEWS");
        partialDataSet.addTable ("OSM_WIDGETS_PARAMS");
        String path = request.getSession ().getServletContext ().getRealPath ("/exports") + File.separator;
        FlatDtdDataSet.write (partialDataSet, new FileOutputStream (path + "osmius.dtd"));
        FlatXmlWriter datasetWriter = new FlatXmlWriter (new FileOutputStream (path + "osmius.xml"));
        datasetWriter.setDocType ("osmius.dtd");
        datasetWriter.write (partialDataSet);
        String [] filenames = new String [] {"osmius.xml", "osmius.dtd", "version"};
        byte [] buf = new byte [1024];
        try {
            String outFilename = path + "osmiusExport.zip";
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
            for (int i = 0; i < filenames.length; i ++) {
                FileInputStream in = new FileInputStream (path + filenames [i]);
                out.putNextEntry (new ZipEntry (filenames [i]));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
            out.close ();
        } catch (IOException e) {
        }
        byte [] content = getBytesFromFile (new File (path + "osmiusExport.zip"));
        response.setContentLength (content.length);
        response.setHeader ("Cache-Control", "no-cache");
        response.setContentType ("application/zip");
        response.setHeader ("Content-Disposition", "attachment; filename=\"osmiusExport.zip\"");
        ServletOutputStream ouputStream = response.getOutputStream ();
        ouputStream.write (content, 0, content.length);
        ouputStream.flush ();
        ouputStream.close ();
        new File (path + "osmius.xml").delete ();
        new File (path + "osmius.dtd").delete ();
        new File (path + "osmiusExport.zip").delete ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (connection != null) {
            try {
                connection.close ();
            } catch (Exception e) {
            }
        }
    }
    return null;
}


-----Function Pair=198=-----==

public boolean renombrarFichero (String rutaFicheroOrigen, String rutaFicheroRenombre) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'renombrarFichero' ***********");
    boolean estado = false;
    File archivo = new File (rutaFicheroOrigen);
    File archivoNEW = new File (rutaFicheroRenombre);
    boolean existe = archivo.exists ();
    try {
        if (existe == true) {
            archivo.renameTo (archivoNEW);
            System.out.println ("El archivo se Renombro ...!!!");
            estado = true;
        }
        else {
            System.out.println ("El archivo no se pudo Renombrar ...!!!");
            estado = false;
        }
    } catch (Exception e) {
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


public void sequence (String file_id, String id, String entry) {
    String input = entry.replaceAll ("\\s", "").replaceAll ("\\p{Blank}", "").trim ();
    String head = ">" + id + "|" + input.length () + LINE_SEPARATOR;
    String fasta = new String ();
    int j = 0;
    for (int i = 0; i < input.length (); i ++) {
        if (j == 80) {
            fasta = fasta + LINE_SEPARATOR;
            j = - 1;
        }
        else {
            fasta = fasta + input.charAt (i);
        }
        j ++;
    }
    fasta = head + fasta;
    create (Config.getTmpPath () + file_id + FileFormat.FASTA.getFileType (), fasta);
    FILE = Config.getWebTmpPath () + file_id + FileFormat.FASTA.getFileType ();
}


-----Function Pair=199=-----==

protected boolean beforeDelete () {
    if (m_items == null) loadLOBData ();
    if (isStoreAttachmentsOnFileSystem) {
        for (int i = 0; i < m_items.size (); i ++) {
            final MAttachmentEntry entry = m_items.get (i);
            final File file = entry.getFile ();
            if (file != null && file.exists ()) {
                if (! file.delete ()) {
                    log.warning ("unable to delete " + file.getAbsolutePath ());
                }
            }
        }
        final File folder = new File (m_attachmentPathRoot + getAttachmentPathSnippet ());
        if (folder.exists ()) {
            if (! folder.delete ()) {
                log.warning ("unable to delete " + folder.getAbsolutePath ());
            }
        }
    }
    return true;
}


public static File checkOrCreate (String path, String description) {
    File file = getBestFile (path);
    if (file.exists ()) {
        return file;
    }
    String _description = description;
    if (_description == null) {
        _description = "file";
    }
    try {
        file.createNewFile ();
    } catch (IOException e) {
        File directory = file.getParentFile ();
        if (directory != null) {
            if (directory.mkdirs ()) {
                try {
                    file.createNewFile ();
                } catch (IOException ee) {
                    throw new UserError (String.format ("Could not create %s \"%s\".", _description, path), new CouldNotCreateFileException (file.getAbsolutePath ()));
                }
            }
            else {
                throw new UserError (String.format ("Could not create %s directory \"%s\".", _description, directory.getAbsolutePath ()), new CouldNotCreateFileException (directory.getAbsolutePath ()));
            }
        }
        else {
            throw new UserError (String.format ("Could not create %s directory for \"%s\".", _description, file.getAbsolutePath ()), new CouldNotCreateFileException (file.getAbsolutePath ()));
        }
    }
    assert file.exists ();
    LOGGER.info (String.format ("Created new %s \"%s\".", _description, file.getAbsolutePath ()));
    return file;
}


-----Function Pair=200=-----==

public void wrapZip (Pagination < E > params, String fileName, HttpServletResponse response) throws ExcelException {
    setResponse (fileName, response);
    Paginable < E > iPageList = queryForPagin (params);
    flushBuffer (response);
    int total = iPageList == null ? 0 : iPageList.getTotalCount ();
    ZipOutputStream zipout = null;
    OutputStream out = null;
    Paginable < E > list = null;
    try {
        out = response.getOutputStream ();
        zipout = new ZipOutputStream (out);
        int pageNum = total / params.getPageSize () + 1;
        for (int i = 1; i <= pageNum; i ++) {
            list = queryForPagin (params);
            flushBuffer (response);
            if (list != null && list.getData () != null && list.getData ().size () > 0) {
                String subName = fileName + "-" + i;
                wrapExcel (fileName, response, zipout, out, list, subName);
            }
        }
        zipout.flush ();
        out.flush ();
        flushBuffer (response);
    } catch (IOException e) {
        throw new ExcelException ("��д�ͻ������ʱ�����쳣", e);
    } finally {
        if (zipout != null) {
            try {
                zipout.close ();
            } catch (IOException e) {
                logger.error ("ѹ�����ر��쳣", e);
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
                logger.error ("response������ر��쳣", e);
            }
        }
        zipout = null;
        out = null;
    }
}


private Thread writeStdOut (Process p, String outputDirName) {
    final File outputDir = new File (outputDirName);
    final InputStreamReader isr = new InputStreamReader (p.getInputStream ());
    final String outfileName = outputDir.getAbsolutePath () + File.separator + "stdout.txt";
    Thread t_input = new Thread () {
        public void run () {
            FileWriter fw;
            try {
                fw = new FileWriter (outfileName);
            } catch (IOException ioe) {
                logger.error (ioe);
                return;
            }
            int bytes = 0;
            char [] buf = new char [256];
            while (! (done && (bytes < 0))) {
                try {
                    bytes = isr.read (buf);
                    if (bytes > 0) {
                        fw.write (buf, 0, bytes);
                        fw.flush ();
                    }
                } catch (IOException ignore) {
                    break;
                }
            }
            try {
                fw.close ();
            } catch (IOException ioe) {
                logger.error (ioe);
                return;
            }
            logger.debug ("Done writing standard output");
        }
    }
    ;
    t_input.start ();
    return t_input;
}


-----Function Pair=201=-----==

private void initializeMyFrame () throws Exception {
    this.getContentPane ().setLayout (new BorderLayout ());
    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    this.setSize (new Dimension (screenSize.width * 19 / 20, screenSize.height * 19 / 20));
    this.setTitle ("TASSEL (Trait Analysis by aSSociation, Evolution, and Linkage)");
    this.addWindowListener (new java.awt.event.WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            this_windowClosing (e);
        }
    }
    );
    filerSave.setDialogType (JFileChooser.SAVE_DIALOG);
    mainPanel.setLayout (new BorderLayout ());
    dataTreeReportPanelsSplitPanel.setOrientation (JSplitPane.VERTICAL_SPLIT);
    optionsPanelPanel.setLayout (new BorderLayout ());
    dataTreePanelPanel.setLayout (new BorderLayout ());
    dataTreePanelPanel.setToolTipText ("Data Tree Panel");
    reportPanel.setLayout (new BorderLayout ());
    reportPanelTextArea.setEditable (false);
    reportPanelTextArea.setToolTipText ("Report Panel");
    mainPanelTextArea.setDoubleBuffered (true);
    mainPanelTextArea.setEditable (false);
    mainPanelTextArea.setFont (new java.awt.Font ("Monospaced", 0, 12));
    mainPanelTextArea.setToolTipText ("Main Panel");
    mainPanelTextArea.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (MouseEvent e) {
            mainTextArea_mouseClicked (e);
        }
    }
    );
    statusBar.setBackground (Color.lightGray);
    statusBar.setBorder (null);
    statusBar.setText ("Program Status");
    modeSelectorsPanel.setLayout (new GridBagLayout ());
    modeSelectorsPanel.setMinimumSize (new Dimension (380, 32));
    modeSelectorsPanel.setPreferredSize (new Dimension (700, 32));
    URL imageURL = TASSELMainFrame.class.getResource ("images/help1.gif");
    ImageIcon helpIcon = null;
    if (imageURL != null) {
        helpIcon = new ImageIcon (imageURL);
    }
    JButton helpButton = new JButton ();
    helpButton.setIcon (helpIcon);
    helpButton.setMargin (new Insets (0, 0, 0, 0));
    helpButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpButton_actionPerformed (e);
        }
    }
    );
    helpButton.setBackground (Color.white);
    helpButton.setMinimumSize (new Dimension (20, 20));
    helpButton.setToolTipText ("Help me!!");
    resultButton.setText ("Results");
    resultButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            resultButton_actionPerformed (e);
        }
    }
    );
    resultButton.setMargin (new Insets (2, 2, 2, 2));
    imageURL = TASSELMainFrame.class.getResource ("images/Results.gif");
    ImageIcon resultsIcon = null;
    if (imageURL != null) {
        resultsIcon = new ImageIcon (imageURL);
    }
    if (resultsIcon != null) {
        resultButton.setIcon (resultsIcon);
    }
    resultButton.setPreferredSize (new Dimension (90, 25));
    resultButton.setMinimumSize (new Dimension (87, 25));
    resultButton.setMaximumSize (new Dimension (90, 25));
    resultButton.setBackground (Color.white);
    wizardButton.setText ("Wizard");
    wizardButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            wizardButton_actionPerformed (e);
        }
    }
    );
    wizardButton.setMargin (new Insets (2, 2, 2, 2));
    wizardButton.setPreferredSize (new Dimension (90, 25));
    wizardButton.setMinimumSize (new Dimension (87, 25));
    wizardButton.setMaximumSize (new Dimension (90, 25));
    wizardButton.setBackground (Color.white);
    saveButton.setMargin (new Insets (0, 0, 0, 0));
    saveButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveButton_actionPerformed (e);
        }
    }
    );
    saveButton.setBackground (Color.white);
    saveButton.setMinimumSize (new Dimension (20, 20));
    saveButton.setToolTipText ("Save selected data to text file");
    imageURL = TASSELMainFrame.class.getResource ("images/save1.gif");
    ImageIcon saveIcon = null;
    if (imageURL != null) {
        saveIcon = new ImageIcon (imageURL);
    }
    if (saveIcon != null) {
        saveButton.setIcon (saveIcon);
    }
    dataButton.setBackground (Color.white);
    dataButton.setMaximumSize (new Dimension (90, 25));
    dataButton.setMinimumSize (new Dimension (87, 25));
    dataButton.setPreferredSize (new Dimension (90, 25));
    imageURL = TASSELMainFrame.class.getResource ("images/DataSeq.gif");
    ImageIcon dataSeqIcon = null;
    if (imageURL != null) {
        dataSeqIcon = new ImageIcon (imageURL);
    }
    if (dataSeqIcon != null) {
        dataButton.setIcon (dataSeqIcon);
    }
    dataButton.setMargin (new Insets (2, 2, 2, 2));
    dataButton.setText ("Data");
    dataButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            dataButton_actionPerformed (e);
        }
    }
    );
    printButton.setBackground (Color.white);
    printButton.setToolTipText ("Print selected datum");
    imageURL = TASSELMainFrame.class.getResource ("images/print1.gif");
    ImageIcon printIcon = null;
    if (imageURL != null) {
        printIcon = new ImageIcon (imageURL);
    }
    if (printIcon != null) {
        printButton.setIcon (printIcon);
    }
    printButton.setMargin (new Insets (0, 0, 0, 0));
    printButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            printButton_actionPerformed (e);
        }
    }
    );
    analysisButton.setText ("Analysis");
    analysisButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            analysisButton_actionPerformed (e);
        }
    }
    );
    analysisButton.setMargin (new Insets (2, 2, 2, 2));
    imageURL = TASSELMainFrame.class.getResource ("images/Analysis.gif");
    ImageIcon analysisIcon = null;
    if (imageURL != null) {
        analysisIcon = new ImageIcon (imageURL);
    }
    if (analysisIcon != null) {
        analysisButton.setIcon (analysisIcon);
    }
    analysisButton.setPreferredSize (new Dimension (90, 25));
    analysisButton.setMinimumSize (new Dimension (87, 25));
    analysisButton.setMaximumSize (new Dimension (90, 25));
    analysisButton.setBackground (Color.white);
    deleteButton.setOpaque (true);
    deleteButton.setForeground (Color.RED);
    deleteButton.setText ("Delete");
    deleteButton.setFont (new java.awt.Font ("Dialog", 1, 12));
    deleteButton.setToolTipText ("Delete Dataset");
    deleteButton.setMargin (new Insets (2, 2, 2, 2));
    deleteButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            theDataTreePanel.deleteSelectedNodes ();
        }
    }
    );
    optionsPanel.setLayout (optionsPanelLayout);
    buttonPanel.setLayout (buttonPanelLayout);
    buttonPanel.setMinimumSize (new Dimension (300, 34));
    buttonPanel.setPreferredSize (new Dimension (300, 34));
    buttonPanelLayout.setHgap (0);
    buttonPanelLayout.setVgap (0);
    optionsPanel.setToolTipText ("Options Panel");
    optionsPanelLayout.setVgap (0);
    mainPopupMenu.setInvoker (this);
    saveMainMenuItem.setText ("Save");
    matchCheckBoxMenuItem.setText ("Match");
    matchCheckBoxMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            matchCheckBoxMenuItem_actionPerformed (e);
        }
    }
    );
    fileMenu.setText ("File");
    toolsMenu.setText ("Tools");
    saveCompleteDataTreeMenuItem.setText ("Save Data Tree");
    saveCompleteDataTreeMenuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveCompleteDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    saveDataTreeAsMenuItem.setText ("Save Data Tree As ...");
    saveDataTreeAsMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    openCompleteDataTreeMenuItem.setText ("Open Data Tree");
    openCompleteDataTreeMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openCompleteDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    openDataMenuItem.setText ("Open Data Tree...");
    openDataMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openDataMenuItem_actionPerformed (e);
        }
    }
    );
    saveAsDataTreeMenuItem.setText ("Save Selected As...");
    saveAsDataTreeMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            ExportPlugin plugin = getExportPlugin ();
            PluginEvent event = new PluginEvent (theDataTreePanel.getSelectedTasselDataSet ());
            ProgressPanel progressPanel = getProgressPanel ();
            ThreadedPluginListener thread = new ThreadedPluginListener (plugin, event);
            thread.start ();
            progressPanel.addPlugin (plugin);
        }
    }
    );
    exitMenuItem.setText ("Exit");
    exitMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            exitMenuItem_actionPerformed (e);
        }
    }
    );
    helpMenu.setText ("Help");
    helpMenuItem.setText ("Help Manual");
    helpMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpButton_actionPerformed (e);
        }
    }
    );
    preferencesMenuItem.setText ("Set Preferences");
    preferencesMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            preferencesMenuItem_actionPerformed (e);
        }
    }
    );
    aboutMenuItem.setText ("About");
    aboutMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpAbout_actionPerformed (e);
        }
    }
    );
    this.getContentPane ().add (dataTreeReportMainPanelsSplitPanel, BorderLayout.CENTER);
    dataTreeReportMainPanelsSplitPanel.add (optionsPanelPanel, JSplitPane.TOP);
    optionsPanelPanel.add (dataTreeReportPanelsSplitPanel, BorderLayout.CENTER);
    dataTreeReportPanelsSplitPanel.add (dataTreePanelPanel, JSplitPane.TOP);
    dataTreePanelPanel.add (theDataTreePanel, BorderLayout.CENTER);
    JSplitPane reportProgress = new JSplitPane (JSplitPane.VERTICAL_SPLIT);
    reportProgress.add (reportPanel, JSplitPane.TOP);
    reportPanel.add (reportPanelScrollPane, BorderLayout.CENTER);
    reportPanelScrollPane.getViewport ().add (reportPanelTextArea, null);
    reportProgress.add (new JScrollPane (myProgressPanel), JSplitPane.BOTTOM);
    dataTreeReportPanelsSplitPanel.add (reportProgress, JSplitPane.BOTTOM);
    dataTreeReportMainPanelsSplitPanel.add (mainPanel, JSplitPane.BOTTOM);
    mainPanel.add (mainDisplayPanel, BorderLayout.CENTER);
    mainDisplayPanel.setLayout (new BorderLayout ());
    mainPanelScrollPane.getViewport ().add (mainPanelTextArea, null);
    mainDisplayPanel.add (mainPanelScrollPane, BorderLayout.CENTER);
    mainPanelScrollPane.getViewport ().add (mainPanelTextArea, null);
    this.getContentPane ().add (statusBar, BorderLayout.SOUTH);
    this.getContentPane ().add (optionsPanel, BorderLayout.NORTH);
    optionsPanel.add (modeSelectorsPanel, null);
    modeSelectorsPanel.add (resultButton, new GridBagConstraints (2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (dataButton, new GridBagConstraints (0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 4, 1, 0), 0, 0));
    modeSelectorsPanel.add (analysisButton, new GridBagConstraints (1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (helpButton, new GridBagConstraints (8, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 2), 0, 0));
    modeSelectorsPanel.add (printButton, new GridBagConstraints (6, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (saveButton, new GridBagConstraints (7, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (deleteButton, new GridBagConstraints (3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 20, 1, 2), 0, 0));
    modeSelectorsPanel.add (wizardButton, new GridBagConstraints (4, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 10, 1, 0), 0, 0));
    modeSelectorsPanel.add (getHeapButton (), new GridBagConstraints (5, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 30, 1, 0), 0, 0));
    optionsPanel.add (buttonPanel, null);
    mainPopupMenu.add (matchCheckBoxMenuItem);
    mainPopupMenu.add (saveMainMenuItem);
    dataTreeReportMainPanelsSplitPanel.setDividerLocation (this.getSize ().width / 4);
    dataTreeReportPanelsSplitPanel.setDividerLocation ((int) (this.getSize ().height / 3.5));
    reportProgress.setDividerLocation ((int) (this.getSize ().height / 3.5));
}


protected void addMenuMapsItems () {
    ButtonGroup group = new ButtonGroup ();
    for (String m : TSP.mapFiles) {
        if (m == null) {
            menuMaps.addSeparator ();
        }
        else {
            JRadioButtonMenuItem menu = new JAntialiasedRadioButtonMenuItem ();
            menu.setText (m);
            if (parent.mapFile.equals (m)) {
                menu.setSelected (true);
            }
            group.add (menu);
            menuMaps.add (menu);
        }
    }
}


-----Function Pair=202=-----==

public static synchronized boolean unzip (String zipFileName, String outputDirectory) {
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (zipFileName);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry;
        int count;
        byte [] data = null;
        if (outputDirectory == null || outputDirectory.trim ().equals ("")) {
            if (zipFileName.lastIndexOf ("\\") != - 1) outputDirectory = zipFileName.substring (0, zipFileName.lastIndexOf ("\\") + 1);
            else outputDirectory = "";
        }
        else outputDirectory = outputDirectory + File.separator;
        while ((entry = zis.getNextEntry ()) != null) {
            System.out.println ("Extracting: " + entry);
            if (entry.isDirectory ()) {
                File dir = new File (entry.getName ());
                if (! dir.exists ()) dir.mkdir ();
            }
            else {
                data = new byte [BUFFER];
                dest = new BufferedOutputStream (new FileOutputStream (outputDirectory + entry.getName ()), BUFFER);
                while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
            }
            zis.close ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
    return true;
}


public static void zip (File [] files, String zipFilename) throws Exception {
    OutputStream os = new BufferedOutputStream (new FileOutputStream (zipFilename));
    ZipOutputStream zos = new ZipOutputStream (os);
    byte data [] = new byte [BUFFER];
    for (int i = 0; i < files.length; i ++) {
        log.debug ("Adding: " + files [i]);
        InputStream is = new BufferedInputStream (new FileInputStream (files [i]), BUFFER);
        ZipEntry entry = new ZipEntry (files [i].getName ());
        zos.putNextEntry (entry);
        int count;
        while ((count = is.read (data, 0, BUFFER)) != - 1) {
            zos.write (data, 0, count);
        }
        is.close ();
    }
    zos.close ();
    log.debug ("Zipped file: " + zipFilename);
}


-----Function Pair=203=-----==

private boolean checkParamInputNamesArrayList (ArrayList list) throws Exception {
    ArrayList listDel = new ArrayList ();
    listDel.addAll (list);
    for (int iPos = 0; iPos < list.size (); iPos ++) {
        String entry = String.valueOf (iPos);
        if (list.indexOf (entry) != - 1) {
            listDel.remove (entry);
        }
        else {
            return true;
        }
    }
    if (listDel.size () > 0) {
        return true;
    }
    else {
        return false;
    }
}


public void homologarConjunto (Component componente) {
    CarpetaTematica carpeta = (CarpetaTematica) componente.getAttribute ("carpeta");
    if (carpeta != null) {
        HashMap parametros = new HashMap ();
        parametros.put ("carpeta", carpeta);
        Window win = (Window) Executions.createComponents ("/recursos/homologar.zul", null, parametros);
        try {
            win.getFellow ("btn_homologar").setAttribute ("carpeta", carpeta);
            win.doModal ();
        } catch (InterruptedException e) {
        }
    }
    else {
        try {
            Messagebox.show (Labels.getLabel ("msg_carpeta_noseleccionado"), Labels.getLabel ("msg_titulo_carpeta_seleccionado"), Messagebox.OK, Messagebox.QUESTION);
        } catch (InterruptedException e) {
        }
    }
}


-----Function Pair=204=-----==

boolean addRoi (Roi roi, boolean promptForName, Color color, int lineWidth) {
    ImagePlus imp = roi == null ? getImage () : WindowManager.getCurrentImage ();
    if (roi == null) {
        if (imp == null) return false;
        roi = imp.getRoi ();
        if (roi == null) {
            error ("The active image does not have a selection.");
            return false;
        }
    }
    if (color == null && roi.getStrokeColor () != null) color = roi.getStrokeColor ();
    else if (color == null && defaultColor != null) color = defaultColor;
    if (lineWidth < 0) {
        int sw = (int) roi.getStrokeWidth ();
        lineWidth = sw > 1 ? sw : defaultLineWidth;
    }
    if (lineWidth > 100) lineWidth = 1;
    int n = list.getItemCount ();
    if (n > 0 && ! IJ.isMacro () && imp != null) {
        String label = list.getItem (n - 1);
        Roi roi2 = (Roi) rois.get (label);
        if (roi2 != null) {
            int slice2 = getSliceNumber (roi2, label);
            if (roi.equals (roi2) && (slice2 == - 1 || slice2 == imp.getCurrentSlice ()) && imp.getID () == prevID && ! Interpreter.isBatchMode ()) return false;
        }
    }
    prevID = imp != null ? imp.getID () : 0;
    String name = roi.getName ();
    if (isStandardName (name)) name = null;
    String label = name != null ? name : getLabel (imp, roi, - 1);
    if (promptForName) label = promptForName (label);
    else label = getUniqueName (label);
    if (label == null) return false;
    list.add (label);
    roi.setName (label);
    roiCopy = (Roi) roi.clone ();
    if (imp != null) {
        Calibration cal = imp.getCalibration ();
        if (cal.xOrigin != 0.0 || cal.yOrigin != 0.0) {
            Rectangle r = roiCopy.getBounds ();
            roiCopy.setLocation (r.x - (int) cal.xOrigin, r.y - (int) cal.yOrigin);
        }
    }
    if (lineWidth > 1) roiCopy.setStrokeWidth (lineWidth);
    if (color != null) roiCopy.setStrokeColor (color);
    rois.put (label, roiCopy);
    updateShowAll ();
    if (record ()) recordAdd (defaultColor, defaultLineWidth);
    return true;
}


private byte [] remTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    tasks.remove (name);
    store.saveTaskList (null);
    return out.getBytes ();
}


-----Function Pair=205=-----==

public static void unzipArchive (File zipArchive, File unzipRootFolder) throws IOException {
    ZipFile zipFile = new ZipFile (zipArchive);
    Enumeration < ? extends ZipEntry > entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = entries.nextElement ();
        if (entry.isDirectory ()) {
            File dir = new File (unzipRootFolder, entry.getName ());
            if (! dir.mkdirs ()) throw new IllegalStateException ("Could not create directory entry, possibly permission issues.");
        }
        else {
            InputStream in = zipFile.getInputStream (entry);
            File file = new File (unzipRootFolder, entry.getName ());
            File dir = new File (file.getParent ());
            if (dir.exists ()) {
                assert (dir.isDirectory ());
            }
            else {
                dir.mkdirs ();
            }
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            int len;
            byte [] buf = new byte [1024 * 5];
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.close ();
        }
    }
    zipFile.close ();
}


public static void extractZipPackage (String fileName, String destinationFolder) throws Exception {
    if (NullStatus.isNull (destinationFolder)) {
        destinationFolder = "";
    }
    new File (destinationFolder).mkdirs ();
    File inputFile = new File (fileName);
    ZipFile zipFile = new ZipFile (inputFile);
    Enumeration < ? extends ZipEntry > oEnum = zipFile.entries ();
    while (oEnum.hasMoreElements ()) {
        ZipEntry zipEntry = oEnum.nextElement ();
        File file = new File (destinationFolder + "/" + zipEntry.getName ());
        if (zipEntry.isDirectory ()) {
            file.mkdirs ();
        }
        else {
            String destinationFolderName = destinationFolder + "/" + zipEntry.getName ();
            destinationFolderName = destinationFolderName.substring (0, destinationFolderName.lastIndexOf ("/"));
            new File (destinationFolderName).mkdirs ();
            FileOutputStream fos = new FileOutputStream (file);
            IOUtils.copy (zipFile.getInputStream (zipEntry), fos);
            fos.close ();
        }
    }
}


-----Function Pair=206=-----==

public void add (ImagePlus imp, Roi roi, int n) {
    if (roi == null) return;
    String label = getLabel (imp, roi, n);
    if (label == null) return;
    list.add (label);
    roi.setName (label);
    roiCopy = (Roi) roi.clone ();
    if (imp != null) {
        Calibration cal = imp.getCalibration ();
        if (cal.xOrigin != 0.0 || cal.yOrigin != 0.0) {
            Rectangle r = roiCopy.getBounds ();
            roiCopy.setLocation (r.x - (int) cal.xOrigin, r.y - (int) cal.yOrigin);
        }
    }
    rois.put (label, roiCopy);
}


protected void addReferencedFilesToZip (String fullPath, String folderId, ZipOutputStream zipOutStream, String workspace, ExportContentData exportContentData) {
    Session session = JCRUtil.currentSession (workspace);
    DirectoryPersister directoryPersister = ManagerRegistry.getDirectoryPersister ();
    DirectoryFolder folder;
    try {
        StringTokenizer st = new StringTokenizer (fullPath, "/");
        int numberofPathElements = st.countTokens ();
        while (numberofPathElements > 1) {
            String currenPathElement = st.nextToken ();
            Node node = session.getNodeByUUID (folderId);
            folder = (DirectoryFolder) directoryPersister.getItemFromNode (node);
            List < DirectoryFolder > folderList = directoryPersister.listFolders (folder);
            for (DirectoryFolder currentFolder : folderList) {
                if (currentFolder.getName ().equals (currenPathElement)) {
                    folderId = currentFolder.getId ();
                    break;
                }
            }
            numberofPathElements --;
        }
        Node targetNode = session.getNodeByUUID (folderId);
        folder = (DirectoryFolder) directoryPersister.getItemFromNode (targetNode);
        List < DirectoryFile > fileList = directoryPersister.listFiles (folder);
        String fileName = st.nextToken ();
        for (DirectoryFile currentFile : fileList) {
            if (currentFile.getName ().equals (fileName)) {
                addReferencedFilesToZip (currentFile, zipOutStream, fullPath.substring (0, fullPath.lastIndexOf ('/') + 1), exportContentData);
                break;
            }
        }
    } catch (RepositoryException e) {
        log.error (e.getMessage ());
        throw new CMSRuntimeException ("Error accessing repository", e);
    } catch (MalformedDirectoryItemException e) {
        log.error (e.getMessage ());
        throw new CMSRuntimeException ("Error accesing directory items in repository", e);
    }
}


-----Function Pair=207=-----==

boolean delete (boolean replacing) {
    int count = list.getItemCount ();
    if (count == 0) return error ("The list is empty.");
    int index [] = list.getSelectedIndexes ();
    if (index.length == 0 || (replacing && count > 1)) {
        String msg = "Delete all items on the list?";
        if (replacing) msg = "Replace items on the list?";
        canceled = false;
        if (! IJ.isMacro () && ! macro) {
            YesNoCancelDialog d = new YesNoCancelDialog (this, "ROI Manager", msg);
            if (d.cancelPressed ()) {
                canceled = true;
                return false;
            }
            if (! d.yesPressed ()) return false;
        }
        index = getAllIndexes ();
    }
    for (int i = count - 1; i >= 0; i --) {
        boolean delete = false;
        for (int j = 0; j < index.length; j ++) {
            if (index [j] == i) delete = true;
        }
        if (delete) {
            rois.remove (list.getItem (i));
            list.remove (i);
        }
    }
    ImagePlus imp = WindowManager.getCurrentImage ();
    if (count > 1 && index.length == 1 && imp != null) imp.killRoi ();
    updateShowAll ();
    if (record ()) Recorder.record ("roiManager", "Delete");
    return true;
}


public void select (ImagePlus imp, int index) {
    int n = list.getItemCount ();
    if (index < 0) {
        for (int i = 0; i < n; i ++) if (list.isSelected (i)) list.deselect (i);
        if (record ()) Recorder.record ("roiManager", "Deselect");
        return;
    }
    if (index >= n) return;
    boolean mm = list.isMultipleMode ();
    if (mm) list.setMultipleMode (false);
    int delay = 1;
    long start = System.currentTimeMillis ();
    while (true) {
        list.select (index);
        if (delay > 1) IJ.wait (delay);
        if (list.isIndexSelected (index)) break;
        for (int i = 0; i < n; i ++) if (list.isSelected (i)) list.deselect (i);
        IJ.wait (delay);
        delay *= 2;
        if (delay > 32) delay = 32;
        if ((System.currentTimeMillis () - start) > 1000L) error ("Failed to select ROI " + index);
    }
    if (imp == null) imp = getImage ();
    restore (imp, index, true);
    if (mm) list.setMultipleMode (true);
}


-----Function Pair=208=-----==

public Map < String, ClassInfo > collect (String [] exlibs, String [] files) throws Exception {
    if (files == null) return Collections.EMPTY_MAP;
    System.out.println ("collecting start");
    ScanLibVisitor scanLibVisitor = new ScanLibVisitor ();
    String rt = findSystemLib ();
    List < String > libs = new ArrayList < String > ();
    libs.add (rt);
    if (exlibs != null) {
        Collections.addAll (libs, exlibs);
    }
    for (String file : libs) {
        System.out.println ("loading lib: " + file);
        ZipFile zip = new ZipFile (file);
        for (Enumeration < ? extends ZipEntry > entries = zip.entries (); entries.hasMoreElements ();) {
            ZipEntry entry = entries.nextElement ();
            if (entry.getName ().endsWith (".class")) {
                new ClassReader (zip.getInputStream (entry)).accept (scanLibVisitor, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
            }
        }
    }
    ClassMapClassVisitor visitor = new ClassMapClassVisitor (scanLibVisitor.getClassMap ());
    for (String file : files) {
        System.out.println ("loading classmap: " + file);
        ZipFile zip = new ZipFile (file);
        for (Enumeration < ? extends ZipEntry > entries = zip.entries (); entries.hasMoreElements ();) {
            ZipEntry entry = entries.nextElement ();
            if (entry.getName ().endsWith (".class")) {
                new ClassReader (zip.getInputStream (entry)).accept (visitor, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
            }
        }
    }
    System.out.println ("collecting end");
    return visitor.getClassMap ();
}


public static Job GetJob (NpsContext ctxt, String id) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Job job = null;
    try {
        String sql = "select a.*,b.name creator_name,c.name site_name,d.name runas_name from job a,users b,site c,users d" + " where a.creator=b.id and a.site=c.id and a.runas=d.id" + " and a.id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (! rs.next ()) return null;
        return GetJob (rs);
    } catch (Exception e) {
        job = null;
        nps.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    return job;
}


-----Function Pair=209=-----==

public static void verifAutorisationLectureFichier (final String pNomFichier, final File pFichier, final int pIdFichier, final boolean pIsFichier) throws UtilisationFichierInterditeException {
    if ("".equals (pNomFichier)) {
        throw new UtilisationFichierInterditeException (java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.ficvide"), pIdFichier);
    }
    if (! pFichier.exists ()) {
        throw new UtilisationFichierInterditeException (java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.fic") + pNomFichier + " " + java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.nexistepas"), pIdFichier);
    }
    if (! pFichier.canRead ()) {
        throw new UtilisationFichierInterditeException (java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.fic") + pNomFichier + " " + java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.lectimposs"), pIdFichier);
    }
    if (pFichier.isFile () && ! pIsFichier) {
        throw new UtilisationFichierInterditeException (pNomFichier + " " + java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.repdemande"), pIdFichier);
    }
    if (pFichier.isDirectory () && pIsFichier) {
        throw new UtilisationFichierInterditeException (pNomFichier + " " + java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.ficdemande"), pIdFichier);
    }
}


private void load () {
    File backFile = null;
    ZipFile zipFile = null;
    Enumeration zippedFiles = null;
    ZipEntry currEntry = null;
    ZipEntry entry = null;
    try {
        String oldName = archiveFile.toString () + ".bak";
        archiveFile.renameTo (new File (oldName));
        backFile = new File (archiveFile.toString () + ".bak");
        zipFile = new ZipFile (backFile.getAbsolutePath ());
        zippedFiles = zipFile.entries ();
        out = new ZipOutputStream (new FileOutputStream (archiveFile));
        long presentTime = Calendar.getInstance ().getTime ().getTime ();
        out.setMethod (out.DEFLATED);
        while (zippedFiles.hasMoreElements ()) {
            currEntry = (ZipEntry) zippedFiles.nextElement ();
            BufferedInputStream reader = new BufferedInputStream (zipFile.getInputStream (currEntry));
            int b;
            out.putNextEntry (new ZipEntry (currEntry.getName ()));
            while ((b = reader.read ()) != - 1) out.write (b);
            reader.close ();
            out.flush ();
            out.closeEntry ();
        }
        zipFile.close ();
    } catch (Exception e) {
        m_logCat.error ("Cannot load zip file", e);
    }
}


-----Function Pair=210=-----==

private void saveComponent (ZipOutputStream zip, HardwareComponent component) throws IOException {
    LOGGING.log (Level.FINE, "snapshot saving {0}", component);
    int i = 0;
    while (true) {
        ZipEntry entry = new ZipEntry (component.getClass ().getName () + "#" + i);
        try {
            zip.putNextEntry (entry);
            break;
        } catch (ZipException e) {
            if (e.getMessage ().matches (".*(duplicate entry).*")) {
                i ++;
            }
            else {
                throw e;
            }
        }
    }
    DataOutputStream dout = new DataOutputStream (zip);
    component.saveState (dout);
    dout.flush ();
    zip.closeEntry ();
}


public void load () {
    Connection connection = null;
    ZipInputStream is = null;
    try {
        connection = dataSource.getConnection ();
        for (int i = 1; i <= 20; i ++) {
            try {
                IVirtualFile storage = this.storageDirectory.getFile (BackupUtil.getRotatedFileName ("backup", "dat", 1));
                if (storage == null) return;
                storage.setIOHandler (new EncryptionIOHandler (provider));
                is = new ZipInputStream (storage.getInputStream ());
                ZipEntry entry = null;
                BufferedReader reader = new BufferedReader (new InputStreamReader (is));
                while ((entry = is.getNextEntry ()) != null) {
                    EncryptedTable found = null;
                    for (EncryptedTable table : getEncryptedTables (connection)) {
                        if (entry.getName ().equals (table.tableName + ".dat")) {
                            found = table;
                            break;
                        }
                    }
                    if (found == null) log.warn ("Could not find table for entry: " + entry.getName ());
                    else {
                        found.load (connection, reader);
                        is.closeEntry ();
                    }
                }
                is.close ();
                return;
            } catch (Exception e) {
                if (is != null) try {
                    is.close ();
                } catch (IOException ee) {
                    ThrowableManagerRegistry.caught (ee);
                }
                log.warn ("Backup " + i + " failed.", e);
                BackupUtil.reverseRotation (this.storageDirectory, "backup", "dat", 20);
            }
        }
        throw new RuntimeException ("Could not restore encrypted memory tables");
    } catch (SQLException e) {
        throw ThrowableManagerRegistry.caught (e);
    } finally {
        if (connection != null) try {
            connection.close ();
        } catch (SQLException e) {
            ThrowableManagerRegistry.caught (e);
        }
        if (is != null) try {
            is.close ();
        } catch (IOException e) {
            ThrowableManagerRegistry.caught (e);
        }
    }
}


-----Function Pair=211=-----==

private X509Certificate createX509Certificate (KeyPair keyPair) throws CertificateEncodingException, InvalidKeyException, IllegalStateException, NoSuchProviderException, NoSuchAlgorithmException, SignatureException {
    Security.addProvider (new org.bouncycastle.jce.provider.BouncyCastleProvider ());
    X509V3CertificateGenerator certGen = new X509V3CertificateGenerator ();
    certGen.setSerialNumber (BigInteger.valueOf (System.currentTimeMillis ()));
    certGen.setIssuerDN (new X509Name ("CN=SelfSignedCertificate"));
    certGen.setNotBefore (new Date (System.currentTimeMillis () - 10000));
    certGen.setNotAfter (new Date (System.currentTimeMillis () + 31536000000L));
    certGen.setSubjectDN (new X509Name ("CN=SelfSignedCertificate"));
    certGen.setPublicKey (keyPair.getPublic ());
    certGen.setSignatureAlgorithm ("SHA256WithRSAEncryption");
    certGen.addExtension (X509Extensions.BasicConstraints, true, new BasicConstraints (false));
    certGen.addExtension (X509Extensions.KeyUsage, true, new KeyUsage (KeyUsage.digitalSignature));
    certGen.addExtension (X509Extensions.SubjectAlternativeName, false, new GeneralNames (new GeneralName (GeneralName.rfc822Name, "selfprotectedagent@deic.uab.cat")));
    return certGen.generate (keyPair.getPrivate (), "BC");
}


private static void processDir (File dir, ZipOutputStream zos, boolean verboseFlag) throws IOException {
    String path = dir.getPath ().replace ('\\', '/') + "/";
    ZipEntry zEntry = new ZipEntry (path);
    if (verboseFlag) {
        System.out.println ("adding: " + path);
    }
    zos.putNextEntry (zEntry);
    File [] filesInDir = dir.listFiles ();
    for (int i = 0; i < filesInDir.length; i ++) {
        File curFile = filesInDir [i];
        if (curFile.isDirectory ()) {
            processDir (curFile, zos, verboseFlag);
        }
        else {
            processFile (curFile, zos, verboseFlag);
        }
    }
    zos.closeEntry ();
}


-----Function Pair=212=-----==

public boolean marshall (PackagePart part, OutputStream os) throws OpenXML4JException {
    if (! (os instanceof ZipOutputStream)) {
        logger.error ("ZipOutputSTream expected!" + os.getClass ().getName ());
        throw new OpenXML4JException ("ZipOutputSTream expected!");
    }
    ZipOutputStream out = (ZipOutputStream) os;
    ZipEntry ctEntry = new ZipEntry (part.getPartName ().getURI ().getPath ());
    try {
        out.putNextEntry (ctEntry);
        if (! StreamHelper.saveXmlInStream (content, out)) {
            return false;
        }
        logger.debug ("recording word doc relationship");
        if (part.hasRelationships ()) {
            ZipPartMarshaller.marshallRelationshipPart (part.getRelationships (), PackagingURIHelper.getRelationshipPartName (part.getPartName ()), out);
        }
        out.closeEntry ();
    } catch (IOException e1) {
        logger.error ("IO problem with " + part.getPartName (), e1);
        return false;
    }
    return true;
}


void addFileToZip (File file, ZipOutputStream zipOutStream) throws FileNotFoundException {
    BufferedInputStream in = new BufferedInputStream (new FileInputStream (file));
    ZipEntry zipEntry = new ZipEntry (file.getName ());
    try {
        try {
            zipOutStream.putNextEntry (zipEntry);
        } catch (ZipException e) {
            log.warn ("File " + file.getName () + " is already at the zip. Ignored");
            zipOutStream.closeEntry ();
            return;
        }
        writeInputStreamIntoOutputStream (in, zipOutStream);
    } catch (IOException e) {
        String errorMessage = "Error adding file " + file.getName ();
        log.error (errorMessage, e);
        throw new CMSRuntimeException (errorMessage, e);
    }
}


-----Function Pair=213=-----=1=

public void zipDir (String dir2zip, ZipOutputStream zos, String rootPath) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        zos.putNextEntry (new ZipEntry (rootPath + "/"));
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                String temp = rootPath + "\\" + f.getName ();
                zipDir (filePath, zos, temp);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            ZipEntry anEntry = new ZipEntry (rootPath + "\\" + f.getName ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
    }
}


public void writeFiles (ZipOutputStream zos, DataOutputStream dos) {
    if (image_file.length () == 0) return;
    try {
        if (image == null) loadImage ();
        int w = image.getWidth (this);
        int h = image.getHeight (this);
        PixelGrabber grabber = new PixelGrabber (image, 0, 0, - 1, - 1, true);
        try {
            grabber.grabPixels ();
        } catch (InterruptedException e) {
            System.out.println (e);
        }
        zos.putNextEntry (new ZipEntry (image_file));
        dos.writeInt (w);
        dos.writeInt (h);
        int a [] = (int []) grabber.getPixels ();
        dos.writeInt (a.length);
        for (int i = 0; i < a.length; i ++) dos.writeInt (a [i]);
        zos.closeEntry ();
    } catch (IOException e) {
        System.out.println (e);
    }
}


-----Function Pair=214=-----==

public void ExplorerView (RenderFormEvent event) throws PortletException {
    String userName = (String) ((Map) event.getRenderRequest ().getAttribute (PortletRequest.USER_INFO)).get ("user.name");
    UserData userData = (UserData) event.getRenderRequest ().getPortletSession ().getAttribute ("userData");
    event.getRenderRequest ().setAttribute ("errorMessage", event.getRenderRequest ().getParameter ("errorMessage"));
    if (userData == null) {
        userData = new UserData ();
        userData.setChrootDir (rootDir + File.separator + userName + File.separator);
        readDirectories (userName, userData);
        event.getRenderRequest ().getPortletSession ().setAttribute ("userData", userData);
    }
    event.getRenderRequest ().setAttribute ("userData", userData);
    if (userData.getState ().equals ("explore")) {
        setNextState (event.getRenderRequest (), VIEW_JSP);
    }
    else {
        editView (event);
    }
}


public static void writeEntry (File file, File input) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ARGOUML_EXT);
        temporaryFile.deleteOnExit ();
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        FileInputStream inputStream = new FileInputStream (input);
        ZipEntry entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT);
        output.putNextEntry (new ZipEntry (entry));
        IOUtils.copy (inputStream, output);
        output.closeEntry ();
        inputStream.close ();
        entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + ".argo");
        output.putNextEntry (new ZipEntry (entry));
        output.write (ArgoWriter.getArgoContent (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT).getBytes ());
        output.closeEntry ();
        output.close ();
        temporaryFile.renameTo (file);
    } catch (IOException ioe) {
        throw new PersistenceException (ioe);
    }
}


-----Function Pair=215=-----==

public static File extract (File source, String filename, File target) {
    if (source.exists () == false || filename == null || filename.trim ().length () < 1 || target == null) return null;
    boolean isDirectory = (filename.lastIndexOf ("/") == filename.length () - 1);
    try {
        Map contents = (Map) jarContents.get (source.getPath ());
        if (contents == null) {
            contents = new HashMap ();
            jarContents.put (source.getPath (), contents);
            ZipInputStream input = new ZipInputStream (new FileInputStream (source));
            ZipEntry zipEntry = null;
            while ((zipEntry = input.getNextEntry ()) != null) {
                if (zipEntry.isDirectory ()) continue;
                contents.put (zipEntry.getName (), zipEntry);
            }
            input.close ();
        }
        if (isDirectory) {
            Iterator it = contents.keySet ().iterator ();
            while (it.hasNext ()) {
                String next = (String) it.next ();
                if (next.startsWith (filename)) {
                    ZipEntry zipEntry = (ZipEntry) contents.get (next);
                    int n = filename.length ();
                    File newTarget = new File (target, zipEntry.getName ().substring (n));
                    extract (source, next, newTarget);
                }
            }
            return target;
        }
        ZipEntry entry = (ZipEntry) contents.get (filename);
        ZipFile input = new ZipFile (source);
        InputStream in = input.getInputStream (entry);
        target.getParentFile ().mkdirs ();
        int bytesRead;
        byte [] buffer = new byte [1024];
        FileOutputStream output = new FileOutputStream (target);
        while ((bytesRead = in.read (buffer)) != - 1) output.write (buffer, 0, bytesRead);
        output.close ();
        input.close ();
        return target;
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return null;
}


public String transformDOCX (String srcFileName, Map map, String destFileName) {
    File file = new File (srcFileName);
    String fileName = file.getName ();
    int pos = fileName.lastIndexOf (".");
    String ext = fileName.substring (pos + 1);
    if (ext.equalsIgnoreCase ("xml")) {
        String templateStr = readDocXmlTemplate (srcFileName);
        String s = replaceContentWidthMap (templateStr, map);
        return s;
    }
    else if (ext.equalsIgnoreCase ("docx")) {
        String templateStr = readDocxTemplate (srcFileName);
        String s = replaceContentWidthMap (templateStr, map);
        generateDocFile (srcFileName, s, destFileName);
    }
    else {
        System.out.println ("error!template must be xml document or .docx word file!");
    }
    return null;
}


-----Function Pair=216=-----==

public void writeInstruments (String filename) {
    ObjectOutputStream out = null;
    ZipOutputStream zipout = null;
    try {
        zipout = new ZipOutputStream (new FileOutputStream (filename));
        zipout.setLevel (0);
        for (String i : shapes.keySet ()) {
            FileShape shape = shapes.importShape (i);
            zipout.putNextEntry (new ZipEntry (shape.getFilename ()));
            shape.saveShapeToOutputStream (zipout);
            zipout.closeEntry ();
        }
        zipout.putNextEntry (new ZipEntry (INSTRUMENT_CONTAINER_NAME));
        out = new ObjectOutputStream (zipout);
        out.writeObject (instrumentContainer);
        out.flush ();
        zipout.closeEntry ();
        zipout.finish ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (zipout != null) {
                out.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


protected Notification setLoaded (boolean isLoaded) {
    boolean oldIsLoaded = this.isLoaded;
    this.isLoaded = isLoaded;
    if (eNotificationRequired ()) {
        Notification notification = new NotificationImpl (Notification.SET, oldIsLoaded, isLoaded) {
            @Override
            public Object getNotifier () {
                return ResourceImpl.this;
            }@Override
            public int getFeatureID (Class < ? > expectedClass) {
                return RESOURCE__IS_LOADED;
            }
        }
        ;
        return notification;
    }
    else {
        return null;
    }
}


-----Function Pair=217=-----==

public static boolean isMonitorAvailable (String host) {
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") called");
    if (! TraceFileMonitor.isMonitoringOn ()) {
        return true;
    }
    String port = "";
    try {
        port = TFPropertyLoader.getInstance ().getPortWithColon ((String) host);
    } catch (Exception ex) {
        System.out.println ("MiscUtil.isMonitorAvailable(" + host + ") - Exception: " + ex.getMessage ());
        ex.printStackTrace ();
        return false;
    }
    System.out.println ("port = " + port);
    if (! MiscUtils.isHostAlive (host, port.substring (1))) {
        return false;
    }
    long timeout = 1000;
    final String hostF = "monp://" + host + port;
    System.out.println ("MiscUtils.isMonitorAvailable(" + host + ") - host with port:" + hostF);
    TimeoutExecutor te = new TimeoutExecutor ();
    Function f = new Function () {
        public Object execute () {
            MonitorConsumer mc = null;
            try {
                mc = new MonitorConsumer (hostF);
                mc.close ();
                mc = null;
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): OK");
            } catch (Exception ex) {
                System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): Exception - " + ex.getMessage ());
                mc = null;
                return TimeoutExecutor.RESULT_AT_TIMEOUT;
            }
            System.out.println ("MiscUtils.isMonitorAvailable(" + hostF + "): true");
            mc = null;
            return new Boolean (true);
        }
    }
    ;
    Object result = null;
    try {
        result = te.executeFunctionWithTimeout (f, timeout);
    } catch (FunctionTimeoutException ftex) {
        System.out.println ("MiscUtils.isMonitorAbailable() - ftex:" + ftex.getMessage ());
        ftex.printStackTrace ();
        return false;
    }
    if (result != TimeoutExecutor.RESULT_AT_TIMEOUT) {
        return true;
    }
    return false;
}


private String getTaskList (ScheduleItem item) {
    StringBuffer buff = new StringBuffer (1024);
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String selectedTask = store.getProperty ("Tasks.DefTask");
    if (item != null) {
        selectedTask = item.getPostTask ();
    }
    String [] keys = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    if (selectedTask.length () == 0) buff.append ("<label><input type='radio' name='task' value='none' checked>none</label><br>\n");
    else buff.append ("<label><input type='radio' name='task' value='none'>none</label><br>\n");
    for (int x = 0; x < keys.length; x ++) {
        if (keys [x].equals (selectedTask)) buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "' checked>" + keys [x] + "</label><br>\n");
        else buff.append ("<label><input type='radio' name='task' value='" + keys [x] + "'>" + keys [x] + "</label><br>\n");
    }
    return buff.toString ();
}


-----Function Pair=218=-----==

public void test_JarOutputStreamLjava_io_OutputStream () throws IOException {
    File fooJar = File.createTempFile ("hyts_", ".jar");
    FileOutputStream fos = new FileOutputStream (fooJar);
    ZipEntry ze = new ZipEntry ("Test");
    try {
        JarOutputStream joutFoo = new JarOutputStream (fos);
        joutFoo.putNextEntry (ze);
        joutFoo.write (33);
    } catch (IOException ee) {
        fail ("IOException is not expected");
    }
    fos.close ();
    fooJar.delete ();
    try {
        JarOutputStream joutFoo = new JarOutputStream (fos);
        joutFoo.putNextEntry (ze);
        fail ("IOException expected");
    } catch (IOException ee) {
    }
}


private String readWebXml (ZipEntry zipEntry, ZipInputStream zipInputStream) throws Exception {
    try {
        File f = File.createTempFile ("web", ".xml");
        f.deleteOnExit ();
        FileOutputStream fout = new FileOutputStream (f);
        byte [] buf = new byte [1024];
        int len;
        while ((len = zipInputStream.read (buf)) > 0) {
            fout.write (buf, 0, len);
        }
        fout.close ();
        SAXBuilder builder = new SAXBuilder (false);
        builder.setValidation (false);
        builder.setEntityResolver (new NoOpEntityResolver ());
        Document doc = builder.build (f);
        Element root = doc.getRootElement ();
        List servlets = root.getChildren ("servlet");
        Element servletElement = new Element ("servlet");
        Element servletName = new Element ("servlet-name");
        servletName.setText ("SessionProvider");
        Element servletClass = new Element ("servlet-class");
        servletClass.setText ("org.nodevision.portal.utils.SessionProvider");
        servletElement.addContent (servletName);
        servletElement.addContent (servletClass);
        servlets.add (servletElement);
        List mappings = root.getChildren ("servlet-mapping");
        Element mappingElement = new Element ("servlet-mapping");
        Element urlPattern = new Element ("url-pattern");
        urlPattern.setText ("/SessionProvider");
        servletName = new Element ("servlet-name");
        servletName.setText ("SessionProvider");
        mappingElement.addContent (servletName);
        mappingElement.addContent (urlPattern);
        mappings.add (mappingElement);
        fout = new FileOutputStream (f);
        XMLOutputter fmt = new XMLOutputter ();
        fmt.setFormat (Format.getPrettyFormat ());
        fmt.output (doc, fout);
        fout.close ();
        return f.getAbsolutePath ();
    } catch (Exception e) {
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=219=-----==

public static UserZipFile createUser (String username, String password, String filename, boolean isAdmin, boolean isExpired) throws Exception {
    MakeUserZipFileTool maker = new MakeUserZipFileTool ();
    maker.setName (username);
    maker.setPassphrase (password);
    maker.setSaveFile (new File (filename));
    if (isExpired) {
        maker.setValidDays (- 1);
    }
    else {
        maker.setValidDays (1);
    }
    UserZipFile zip = (UserZipFile) maker.makeCertificate ();
    if (isAdmin) {
        zip.setFlags (SecurityUtil.getAdmin ().getFlags ());
    }
    return zip;
}


private byte [] getTunerList (HTTPurl urlData) throws Exception {
    boolean showID = "true".equalsIgnoreCase (urlData.getParameter ("showid"));
    showID = showID | "true".equalsIgnoreCase (urlData.getCookie ("showDeviceID"));
    if ("false".equalsIgnoreCase (urlData.getParameter ("showid"))) showID = false;
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CardSetup.html");
    if (showID == true) template.addCookie ("showDeviceID", "true");
    else template.addCookie ("showDeviceID", "false");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int activeDevices = devList.getActiveDeviceCount ();
    String scanCommand = "device.exe";
    System.out.println ("Running device scan command: " + scanCommand);
    Runtime runner = Runtime.getRuntime ();
    Process scan = runner.exec (scanCommand);
    TunerScanResult tuners = new TunerScanResult ();
    tuners.readInput (scan.getInputStream ());
    tuners.parseXML ();
    StringBuffer out = new StringBuffer ();
    Vector < CaptureDevice > tunersList = tuners.getResult ();
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
    out.append ("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
    if (showID) out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>");
    else out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
    out.append ("</td></tr></table></td></tr>\n");
    for (int x = 0; x < devList.getDeviceCount (); x ++) {
        CaptureDevice cd = (CaptureDevice) devList.getDevice (x);
        out.append ("<tr>");
        out.append ("<td nowrap>" + x + "</td>");
        out.append ("<td nowrap>: ");
        out.append (cd.getName ());
        if (cd.isInUse () == true) out.append (" (Active)");
        boolean isAvailable = false;
        for (int y = 0; y < tunersList.size (); y ++) {
            CaptureDevice cd2 = (CaptureDevice) tunersList.get (y);
            if (cd.getID ().equals (cd2.getID ())) {
                isAvailable = true;
                break;
            }
        }
        if (isAvailable == false) out.append (" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
        if (showID) out.append ("(" + cd.getID () + ")");
        out.append ("</td>\n");
        out.append ("<td nowrap width='50px'> ");
        out.append (" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        out.append ("</td>\n");
        out.append ("</tr>\n");
    }
    if (devList.getDeviceCount () == 0) {
        out.append ("<tr><td colspan ='3'>No devices selected</td></tr>");
    }
    int numCards = 0;
    out.append ("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
    for (int x = 0; x < tunersList.size (); x ++) {
        CaptureDevice dev = (CaptureDevice) tunersList.get (x);
        boolean found = false;
        for (int y = 0; y < devList.getDeviceCount (); y ++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice (y);
            if (cd.getID ().equals (dev.getID ())) {
                found = true;
                break;
            }
        }
        if (! found) {
            out.append ("<tr>");
            out.append ("<td>&nbsp;</td>");
            out.append ("<td nowrap>" + dev.getName () + "</td>");
            out.append ("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode (dev.getID (), "UTF-8"));
            out.append ("&tunerName=" + URLEncoder.encode (dev.getName (), "UTF-8") + "'>");
            out.append ("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
            out.append ("</tr>\n");
            numCards ++;
        }
    }
    if (numCards == 0) {
        out.append ("<tr><td colspan ='3'>No devices available</td></tr>");
    }
    numCards = 0;
    template.replaceAll ("$cardList", out.toString ());
    template.replaceAll ("$cardCount", new Integer (activeDevices).toString ());
    return template.getPageBytes ();
}


-----Function Pair=220=-----==

public void install () throws Exception {
    InputStream in = getResourceAsStream (serverIdentifier + ".xml", false);
    String s = toString (in);
    s = s.replaceAll ("@server.dir@", serverDir);
    s = s.replaceAll ("@server.profile.dir@", profileDir);
    s = s.replaceAll ("@server.all.dir@", serverDir + "/server/all");
    Element root = DOMUtils.parse (s);
    NodeList l = root.getElementsByTagName ("backup-dir");
    Node bkpNode = l.item (0);
    backupDir = bkpNode.getTextContent ();
    l = root.getElementsByTagName ("transaction-manager");
    Node tmNode = l.item (0);
    processSection (tmNode);
    if (installIIOP) {
        l = root.getElementsByTagName ("iiop");
        Node iiopNode = l.item (0);
        if (iiopNode != null) processSection (iiopNode);
    }
    if (installSOAP) {
        l = root.getElementsByTagName ("soap");
        Node soapNode = l.item (0);
        if (soapNode != null) processSection (soapNode);
    }
    if (installJBRem) {
        l = root.getElementsByTagName ("jboss-remoting");
        Node jbremNode = l.item (0);
        if (jbremNode != null) processSection (jbremNode);
    }
}


private File zargoToUml (File file, ProgressMgr progressMgr) throws OpenException, InterruptedException {
    File combinedFile = null;
    try {
        combinedFile = File.createTempFile ("combinedzargo_", ".uml");
        LOG.info ("Combining old style zargo sub files into new style uml file " + combinedFile.getAbsolutePath ());
        combinedFile.deleteOnExit ();
        String encoding = Argo.getEncoding ();
        FileOutputStream stream = new FileOutputStream (combinedFile);
        PrintWriter writer = new PrintWriter (new BufferedWriter (new OutputStreamWriter (stream, encoding)));
        writer.println ("<?xml version = \"1.0\" " + "encoding = \"" + encoding + "\" ?>");
        copyArgo (file, encoding, writer);
        progressMgr.nextPhase ();
        copyMember (file, "profile", encoding, writer);
        copyXmi (file, encoding, writer);
        copyDiagrams (file, encoding, writer);
        copyMember (file, "todo", encoding, writer);
        progressMgr.nextPhase ();
        writer.println ("</uml>");
        writer.close ();
        LOG.info ("Completed combining files");
    } catch (IOException e) {
        throw new OpenException (e);
    }
    return combinedFile;
}


-----Function Pair=221=-----==

private List < ? extends Attachment > createZipAttachment (List < FileSystemItem > nodes, boolean withFolders) throws IOException {
    File tmp = File.createTempFile ("securus", null);
    ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (tmp));
    try {
        for (FileSystemItem node : nodes) {
            String path;
            if (withFolders) {
                path = node.getFile ();
            }
            else {
                path = node.getFile ();
            }
            zip.putNextEntry (new ZipEntry (path));
            InputStream in = new BufferedInputStream (node.getContent ());
            int b;
            while ((b = in.read ()) != - 1) {
                zip.write (b);
            }
            zip.closeEntry ();
        }
    } finally {
        zip.close ();
    }
    return Arrays.asList (new ZipAttachment (tmp));
}


private byte [] showAvailablePaths (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "CapturePathsAvailable.html");
    StringBuffer buff = new StringBuffer ();
    template.replaceAll ("$title", "Available capture paths");
    String path = urlData.getParameter ("path");
    File [] files = null;
    String parent = "";
    if (path == null || path.length () == 0) {
        files = File.listRoots ();
        template.replaceAll ("$currentPath", "");
    }
    else {
        File thisPath = new File (path);
        files = thisPath.listFiles ();
        if (thisPath.getParentFile () != null) parent = thisPath.getParentFile ().getAbsolutePath ();
        String addLink = "";
        if (thisPath.exists ()) {
            addLink = " <a href='#' onClick=\"addPath('/servlet/SystemDataRes?action=32&path=" + URLEncoder.encode (thisPath.getAbsolutePath (), "UTF-8") + "');\">" + "<img alt='Add Path' border=0 src='/images/add.png' align='absmiddle' width='24' height='24'></a> " + thisPath.getAbsolutePath ();
        }
        template.replaceAll ("$currentPath", addLink);
        if (thisPath.getParentFile () != null && thisPath.getParentFile ().exists () == true) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (parent, "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(parent)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
        else {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=' class='noUnder'>");
            buff.append ("<img alt='parent' border=0 src='/images/prev.png' align='absmiddle' width='24' height='24'> ");
            buff.append ("(root)");
            buff.append ("</a>");
            buff.append ("</td></tr>");
        }
    }
    if (files == null) {
        files = new File [0];
    }
    int numberItems = 0;
    for (int x = 0; x < files.length; x ++) {
        if (files [x].isDirectory ()) {
            buff.append ("<tr><td nowrap>");
            buff.append ("<a href='/servlet/SystemDataRes?action=31&path=" + URLEncoder.encode (files [x].getCanonicalPath (), "UTF-8") + "' class='noUnder'>");
            buff.append ("<img alt='path' border=0 src='/images/showchildren.png' align='absmiddle' width='24' height='24'> ");
            buff.append (files [x].getCanonicalPath ());
            buff.append ("</a>");
            buff.append ("</td></tr>");
            numberItems ++;
        }
    }
    if (numberItems == 0) {
        buff.append ("<tr><td nowrap>No items to show</td></tr>");
    }
    template.replaceAll ("$availablePaths", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=222=-----==

public static boolean createZipFile (String zipFilePath, int level, final byte [] readBuffer, String...sourcePaths) throws IOException {
    if (sourcePaths == null || sourcePaths.length == 0) {
        return false;
    }
    File zipArchive = new File (zipFilePath + ".tmp");
    if (zipArchive.exists ()) {
        if (! zipArchive.isFile ()) {
            return false;
        }
    }
    else if (! zipArchive.createNewFile ()) {
        if (! zipArchive.delete () || ! zipArchive.createNewFile ()) {
            return false;
        }
    }
    OutputStream fileStream = null;
    ZipOutputStream zipWriter = null;
    try {
        fileStream = Channels.newOutputStream (new FileOutputStream (zipArchive).getChannel ());
        zipWriter = new ZipOutputStream (fileStream);
        zipWriter.setLevel (level);
        for (String contentPath : sourcePaths) {
            File nextFile = new File (contentPath).getAbsoluteFile ();
            if (nextFile.exists ()) {
                if (nextFile.isFile ()) {
                    if (! addFileToZip (zipWriter, zipArchive, nextFile, readBuffer, "")) {
                        return false;
                    }
                }
                else if (nextFile.isDirectory ()) {
                    if (! addDirectoryToZip (zipWriter, zipArchive, nextFile, readBuffer, nextFile.getName ())) {
                        return false;
                    }
                }
            }
        }
    } finally {
        boolean error = false;
        try {
            if (zipWriter != null) {
                zipWriter.flush ();
                zipWriter.finish ();
                zipWriter.close ();
            }
            else {
                error = true;
            }
        } catch (IOException e) {
            error = true;
        }
        if (fileStream != null) {
            fileStream.close ();
        }
        if (error) {
            return false;
        }
    }
    File trueZipArchive = new File (zipFilePath);
    if (! zipArchive.renameTo (trueZipArchive)) {
        if (trueZipArchive.delete ()) {
            if (! zipArchive.renameTo (trueZipArchive)) {
                zipArchive.delete ();
                return false;
            }
            return true;
        }
        else {
            return false;
        }
    }
    return true;
}


private void createGroundOverlays () {
    for (String s : layers) {
        for (int i = start; i < end; i ++) {
            final GroundOverlay groundoverlay;
            groundoverlay = document.createAndAddGroundOverlay ();
            boolean visibility = (i == start) ? true : false;
            groundoverlay.withName (s + i).withVisibility (visibility).withId (s + i);
            groundoverlay.createAndSetIcon ().withHref (s + "_" + i + ".png").withViewBoundScale (0.75d);
            if (s.equals (Consts.LAYER_HIGH_CLOUD)) {
                groundoverlay.withAltitude (highCloudAlt);
                groundoverlay.withColor ("90ffffff");
            }
            else if (s.equals (Consts.LAYER_LOW_CLOUD)) {
                groundoverlay.withAltitude (lowCloudAlt);
                groundoverlay.withColor ("b4a9a9aa");
            }
            else if (s.equals (Consts.LAYER_MID_CLOUD)) {
                groundoverlay.withAltitude (midCloudAlt);
                groundoverlay.withColor ("7affffff");
            }
            else if (s.equals (Consts.LAYER_RAIN)) {
                groundoverlay.withAltitude (rainAlt);
            }
            groundoverlay.withAltitudeMode (AltitudeMode.ABSOLUTE);
            double S = Consts.DOMAIN_START_Y;
            double N = S + (Consts.DOMAIN_ROW_INTERVAL * Consts.DOMAIN_ROWS);
            double W = Consts.DOMAIN_START_X;
            double E = W + (Consts.DOMAIN_COL_INTERVAL * Consts.DOMAIN_COLS);
            groundoverlay.createAndSetLatLonBox ().withNorth (N).withSouth (S).withEast (E).withWest (W);
        }
    }
}


-----Function Pair=223=-----==

protected void done () {
    boolean result = false;
    if (this.isCancelled () == false) {
        try {
            result = this.get ();
        } catch (InterruptedException ex) {
            log.error (null, ex);
        } catch (ExecutionException ex) {
            log.error (null, ex);
        } catch (CancellationException ex) {
            log.error (null, ex);
        }
    }
    jButton1.setEnabled (true);
    jTextField1.setEnabled (true);
    jPasswordField1.setEnabled (true);
    jCheckBox1.setEnabled (true);
    if (result == true) {
        JOptionPane.showMessageDialog (SaveToCloudJDialog.this, GUIBundle.getString ("SaveToCloudJDialog_Success"));
        final JStockOptions jStockOptions = MainFrame.getInstance ().getJStockOptions ();
        if (jCheckBox1.isSelected () == true) {
            jStockOptions.setRememberGoogleAccountEnabled (true);
            jStockOptions.setGoogleUsername (Utils.encrypt (jTextField1.getText ().trim ()));
            jStockOptions.setGooglePassword (Utils.encrypt (new String (jPasswordField1.getPassword ())).trim ());
        }
        setVisible (false);
        dispose ();
    }
}


private void writePacks (File primaryfile) throws Exception {
    final int num = packsList.size ();
    sendMsg ("Writing " + num + " Pack" + (num > 1 ? "s" : "") + " into installer");
    Debug.trace ("Writing " + num + " Pack" + (num > 1 ? "s" : "") + " into installer");
    Map storedFiles = new HashMap ();
    String classname = this.getClass ().getName ();
    String volumesize = this.getVariables ().getProperty (classname + ".volumesize");
    String extraspace = this.getVariables ().getProperty (classname + ".firstvolumefreespace");
    long volumesizel = FileSpanningOutputStream.DEFAULT_VOLUME_SIZE;
    long extraspacel = FileSpanningOutputStream.DEFAULT_ADDITIONAL_FIRST_VOLUME_FREE_SPACE_SIZE;
    if (volumesize != null) {
        volumesizel = Long.parseLong (volumesize);
    }
    if (extraspace != null) {
        extraspacel = Long.parseLong (extraspace);
    }
    Debug.trace ("Volumesize: " + volumesizel);
    Debug.trace ("Extra space on first volume: " + extraspacel);
    FileSpanningOutputStream fout = new FileSpanningOutputStream (primaryfile.getParent () + File.separator + primaryfile.getName () + ".pak", volumesizel);
    fout.setFirstvolumefreespacesize (extraspacel);
    int packNumber = 0;
    for (PackInfo aPacksList : packsList) {
        PackInfo packInfo = aPacksList;
        Pack pack = packInfo.getPack ();
        pack.nbytes = 0;
        sendMsg ("Writing Pack " + packNumber + ": " + pack.name, PackagerListener.MSG_VERBOSE);
        Debug.trace ("Writing Pack " + packNumber + ": " + pack.name);
        ZipEntry entry = new ZipEntry ("packs/pack" + packNumber);
        primaryJarStream.putNextEntry (entry);
        ObjectOutputStream objOut = new ObjectOutputStream (primaryJarStream);
        objOut.writeInt (packInfo.getPackFiles ().size ());
        Iterator iter = packInfo.getPackFiles ().iterator ();
        for (Object o : packInfo.getPackFiles ()) {
            boolean addFile = ! pack.loose;
            PackFile packfile = (PackFile) o;
            XPackFile pf = new XPackFile (packfile);
            File file = packInfo.getFile (packfile);
            Debug.trace ("Next file: " + file.getAbsolutePath ());
            Object [] info = (Object []) storedFiles.get (file);
            if (info != null && ! packJarsSeparate) {
                Debug.trace ("File already included in other pack");
                pf.setPreviousPackFileRef ((String) info [0], (Long) info [1]);
                addFile = false;
            }
            if (addFile && ! pf.isDirectory ()) {
                long pos = fout.getFilepointer ();
                pf.setArchivefileposition (pos);
                int volumecountbeforewrite = fout.getVolumeCount ();
                FileInputStream inStream = new FileInputStream (file);
                long bytesWritten = copyStream (inStream, fout);
                fout.flush ();
                long posafterwrite = fout.getFilepointer ();
                Debug.trace ("File (" + pf.sourcePath + ") " + pos + " <-> " + posafterwrite);
                if (fout.getFilepointer () != (pos + bytesWritten)) {
                    Debug.trace ("file: " + file.getName ());
                    Debug.trace ("(Filepos/BytesWritten/ExpectedNewFilePos/NewFilePointer) (" + pos + "/" + bytesWritten + "/" + (pos + bytesWritten) + "/" + fout.getFilepointer () + ")");
                    Debug.trace ("Volumecount (before/after) (" + volumecountbeforewrite + "/" + fout.getVolumeCount () + ")");
                    throw new IOException ("Error new filepointer is illegal");
                }
                if (bytesWritten != pf.length ()) {
                    throw new IOException ("File size mismatch when reading " + file);
                }
                inStream.close ();
            }
            objOut.writeObject (pf);
            objOut.flush ();
            pack.nbytes += pf.length ();
        }
        objOut.writeInt (packInfo.getParsables ().size ());
        iter = packInfo.getParsables ().iterator ();
        while (iter.hasNext ()) {
            objOut.writeObject (iter.next ());
        }
        objOut.writeInt (packInfo.getExecutables ().size ());
        iter = packInfo.getExecutables ().iterator ();
        while (iter.hasNext ()) {
            objOut.writeObject (iter.next ());
        }
        objOut.writeInt (packInfo.getUpdateChecks ().size ());
        iter = packInfo.getUpdateChecks ().iterator ();
        while (iter.hasNext ()) {
            objOut.writeObject (iter.next ());
        }
        objOut.flush ();
        packNumber ++;
    }
    int volumes = fout.getVolumeCount ();
    Debug.trace ("Written " + volumes + " volumes");
    String volumename = primaryfile.getName () + ".pak";
    fout.flush ();
    fout.close ();
    primaryJarStream.putNextEntry (new ZipEntry ("volumes.info"));
    ObjectOutputStream out = new ObjectOutputStream (primaryJarStream);
    out.writeInt (volumes);
    out.writeUTF (volumename);
    out.flush ();
    primaryJarStream.closeEntry ();
    primaryJarStream.putNextEntry (new ZipEntry ("packs.info"));
    out = new ObjectOutputStream (primaryJarStream);
    out.writeInt (packsList.size ());
    for (PackInfo aPacksList : packsList) {
        PackInfo pack = aPacksList;
        out.writeObject (pack.getPack ());
    }
    out.flush ();
    primaryJarStream.closeEntry ();
}


-----Function Pair=224=-----==

public void stripLine (final InputStream is, final OutputStream os, final String regex) throws IOException {
    BufferedReader reader = null;
    BufferedWriter writer = null;
    String line = null;
    try {
        reader = new BufferedReader (new InputStreamReader (is, Charset.defaultCharset ()));
        writer = new BufferedWriter (new OutputStreamWriter (os, Charset.defaultCharset ()));
        while ((line = reader.readLine ()) != null) {
            if (line.matches (regex)) {
                continue;
            }
            writer.write (line);
            writer.newLine ();
        }
    } finally {
        if (reader != null) {
            reader.close ();
        }
        if (writer != null) {
            writer.close ();
        }
    }
}


private void initArchiveStoreDetails (Properties ctx, String trxName) {
    final MClient client = new MClient (ctx, this.getAD_Client_ID (), trxName);
    isStoreArchiveOnFileSystem = client.isStoreArchiveOnFileSystem ();
    if (isStoreArchiveOnFileSystem) {
        if (File.separatorChar == '\\') {
            m_archivePathRoot = client.getWindowsArchivePath ();
        }
        else {
            m_archivePathRoot = client.getUnixArchivePath ();
        }
        if ("".equals (m_archivePathRoot)) {
            log.severe ("no archivePath defined");
        }
        else if (! m_archivePathRoot.endsWith (File.separator)) {
            log.warning ("archive path doesn't end with " + File.separator);
            m_archivePathRoot = m_archivePathRoot + File.separator;
            log.fine (m_archivePathRoot);
        }
    }
}


-----Function Pair=225=-----==

public void run () {
    JFileChooser fc = Core.UI.getFileChooser ();
    fc.setMultiSelectionEnabled (true);
    int prev_option = fc.getFileSelectionMode ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    if (fc.showOpenDialog (Core.UI) != JFileChooser.APPROVE_OPTION) {
        fc.setMultiSelectionEnabled (false);
        fc.setFileSelectionMode (prev_option);
        return;
    }
    File [] files = fc.getSelectedFiles ();
    Thread unpacker = new Unpacker (files);
    unpacker.start ();
    try {
        while (unpacker.isAlive ()) sleep (10);
    } catch (Exception e) {
    }
    validateUI (new DouzEvent (DouzEvent.Type.DATABASE_REFRESH, null));
    fc.setMultiSelectionEnabled (false);
    fc.setFileSelectionMode (prev_option);
}


public void exportComplete (int ppid, OutputStream out, String baseTempPath) {
    BASE64Encoder encoder = new BASE64Encoder ();
    ProjectExporter exporter = new ProjectExporter ();
    Document doc = exporter.createProjectDoc ();
    List < Plan > list = null;
    try {
        list = em.createQuery ("select p from Plan p where p.planProperties.id = " + ppid).getResultList ();
    } catch (Exception e1) {
        list = new ArrayList < Plan > ();
        FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
        log.error ("Could not load planProperties: ", e1);
    }
    try {
        if (list.size () != 1) {
            FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "Skipping the export of the plan with properties" + ppid + ": Couldnt load.");
        }
        else {
            String tempPath = baseTempPath;
            File tempDir = new File (tempPath);
            tempDir.mkdirs ();
            List < Integer > uploadIDs = new ArrayList < Integer > ();
            List < Integer > recordIDs = new ArrayList < Integer > ();
            try {
                exporter.addProject (list.get (0), doc, uploadIDs, recordIDs);
                writeBinaryObjects (recordIDs, uploadIDs, tempPath, encoder);
                XMLWriter writer = new XMLWriter (new FileOutputStream ("/tmp/testout" + System.currentTimeMillis () + ".xml"));
                writer.write (doc);
                writer.close ();
                addBinaryData (doc, out, tempPath);
            } catch (IOException e) {
                FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
                log.error ("Could not open response-outputstream: ", e);
            } catch (TransformerException e) {
                FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "An error occured while generating the export file.");
                log.error (e);
            }
        }
    } finally {
        list.clear ();
        list = null;
        em.clear ();
        System.gc ();
    }
}


-----Function Pair=226=-----==

public static void scrollTextScreen (String s, boolean showEnd) {
    QuestApplet questapp = Game.getQuestapp ();
    Screen old = questapp.getScreen ();
    InfoScreen is = new InfoScreen (questapp, "");
    TextArea ma = new TextArea ();
    is.setLayout (new BorderLayout ());
    ma.setText (s);
    ma.setBackground (Color.darkGray);
    ma.setForeground (Color.lightGray);
    ma.addKeyListener (questapp.keyadapter);
    is.add (ma);
    questapp.switchScreen (is);
    if (showEnd) {
        ma.setCaretPosition (1000000);
    }
    Game.getInput ();
    questapp.switchScreen (old);
}


public static Hashtable getNamesAndFileBytes (LinkedList listOfFileNames) {
    int numElems = listOfFileNames.size ();
    Hashtable ht = new Hashtable ();
    Iterator it = listOfFileNames.iterator ();
    int x = 0;
    while (it.hasNext ()) {
        String item = (String) it.next ();
        byte [] bytes = null;
        try {
            if ((item.endsWith (".jar")) || (item.endsWith (".zip"))) {
                bytes = Utils.getBytesFromFile (new File (item));
                ht.put ("file" + x, bytes);
                logger.debug ("file:  " + item);
            }
            else {
                bytes = Utils.getDirBytes (item);
                ht.put ("dir" + x, bytes);
                logger.debug ("dir:   " + item);
            }
        } catch (Exception e) {
            logger.error ("Unable to ship resource: " + item);
        }
        x ++;
    }
    return ht;
}


-----Function Pair=227=-----==

boolean hasMoreClassFiles () {
    if (zip_file_en == null) return true;
    if (! zip_file_en.hasMoreElements ()) return false;
    Enumeration tmp_zip_file_en = zip_file.entries ();
    ZipEntry tmp_zip_entry;
    do {
        tmp_zip_entry = (ZipEntry) tmp_zip_file_en.nextElement ();
    }
    while (! tmp_zip_entry.getName ().equals (cur_zip_entry.getName ()));
    do {
        tmp_zip_entry = (ZipEntry) tmp_zip_file_en.nextElement ();
        if (tmp_zip_entry.getName ().endsWith (".class")) break;
        try {
            cur_zip_entry = (ZipEntry) zip_file_en.nextElement ();
            final int BUF_LEN = 1024;
            byte b [] = new byte [BUF_LEN];
            int len;
            cur_zip_entry.setCompressedSize (- 1);
            my_zip_os.putNextEntry (cur_zip_entry);
            InputStream is = zip_file.getInputStream (cur_zip_entry);
            while ((len = is.read (b, 0, BUF_LEN)) > 0) {
                my_zip_os.write (b, 0, len);
            }
        } catch (IOException e) {
            System.out.println (e.getMessage ());
            System.exit (1);
        }
    }
    while (tmp_zip_file_en.hasMoreElements () && ! tmp_zip_entry.getName ().endsWith (".class"));
    if (tmp_zip_entry.getName ().endsWith (".class")) return true;
    return false;
}


private static void copyFile (File output, InputStream input) throws CaughtException {
    try {
        logger.info ("Coping file " + input);
        BufferedInputStream is = new BufferedInputStream (input);
        logger.info ("Using " + is);
        logger.info ("going To " + output);
        checkExists (output.getParentFile ());
        FileOutputStream fos = new FileOutputStream (output);
        logger.info ("To " + fos);
        BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
        logger.info ("reading to copy to " + dest);
        int count;
        byte data [] = new byte [BUFFER];
        while ((count = is.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        is.close ();
        dest.flush ();
        dest.close ();
    } catch (IOException e) {
        throw new CaughtException (e, logger);
    }
}


-----Function Pair=228=-----==

public void runExportZipJob (final IThumb [] thumb) {
    String directory = optionsPage.getDirectory ();
    if (StringUtil.isEmpty (directory)) {
        error (INVALID_PATH + ": Null");
        return;
    }
    final File f = new File (directory);
    if (f.exists ()) {
        if (f.isDirectory ()) {
            error (INVALID_PATH + ":" + f.getAbsolutePath ());
            return;
        }
        Shell shell = getAvailableShell ();
        if (shell != null) {
            MessageBox m = new MessageBox (shell, SWT.ICON_WARNING | SWT.OK | SWT.CANCEL);
            m.setMessage (Messages.ExportZipWizard_file + f.getName () + Messages.ExportZipWizard_existsconfirm);
            m.setText (Messages.ExportZipWizard_confirm);
            if (m.open () == SWT.CANCEL) {
                return;
            }
        }
    }
    else {
        try {
            IO.makeFile (f);
        } catch (IOException e) {
            error (INVALID_PATH + ":" + f.getAbsolutePath ());
            e.printStackTrace ();
            return;
        }
    }
    display = thumbScroller.getControl ().getDisplay ();
    final boolean email = optionsPage.isOpenEmail ();
    final double resizeFactor = sizePage.getResizeFactor ();
    final float jpegQuality = sizePage.getJpegQuality ();
    final boolean folder = optionsPage.isOpenFolder ();
    final Job job = new Job ("Zip Export") {
        @Override
        protected IStatus run (IProgressMonitor monitor) {
            return export (f, Arrays.asList (thumb), monitor, resizeFactor, jpegQuality);
        }
    }
    ;
    job.setUser (true);
    job.schedule ();
    job.addJobChangeListener (new JobChangeAdapter () {
        public void done (final IJobChangeEvent event) {
            close ();
            if (email && display != null && ! display.isDisposed ()) {
                display.asyncExec (new Runnable () {
                    public void run () {
                        EmailSupport.email (null, null);
                    }
                }
                );
            }
            if (folder && display != null && ! display.isDisposed ()) {
                display.asyncExec (new Runnable () {
                    public void run () {
                        File out = new File (optionsPage.getDirectory ());
                        if (! out.isDirectory ()) {
                            out = out.getParentFile ();
                        }
                        FileUtil.openWindowsExplorer (out);
                    }
                }
                );
            }
        }
    }
    );
}


private void modifyPolicyFile () throws IOException {
    log ("Adjusting ~/.java.policy");
    File policy = new File (System.getProperty ("user.home") + File.separatorChar + ".java.policy");
    if (policy.exists ()) {
        BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (policy)));
        String s = null;
        while ((s = br.readLine ()) != null) if (s.startsWith ("// VEXI_MARKER:")) {
            log ("Java policy file has already been adjusted");
            return;
        }
    }
    FileOutputStream fos = new FileOutputStream (policy.getAbsolutePath (), true);
    PrintWriter pw = new PrintWriter (new OutputStreamWriter (fos));
    pw.println ("");
    pw.println ("// VEXI_MARKER: this line and the following two grant blocks are required for VEXI; DO NOT REMOVE THEM.");
    pw.println ("grant {");
    pw.println ("    permission java.io.FilePermission \"${user.home}${/}.vexi${/}shoehorn.jar\", \"read\";");
    pw.println ("};");
    pw.println ("grant codebase \"file:${user.home}${/}.vexi${/}shoehorn.jar\" {");
    pw.println ("    permission java.security.AllPermission;");
    pw.println ("};");
    pw.println ("// END_VEXI_MARKER");
    pw.println ("");
    pw.flush ();
    pw.close ();
}


-----Function Pair=229=-----==

protected void execute (ActionEvent e) {
    RecommendationProvider provider = new RecommendationProviderProxy ("localhost", RECOM_PORT);
    RecommendationQuery query = new RecommendationQuery ("ProcessId", "ProcessInstanceId");
    query.setProcessInstanceData (historyPI.getAttributes ());
    Iterator it = historyPI.getAuditTrailEntryList ().iterator ();
    while (it.hasNext ()) {
        query.addAuditTrailEntry ((AuditTrailEntry) it.next ());
    }
    RecommendationResult result = null;
    try {
        result = provider.getRecommendation (query);
        for (Recommendation r : result) {
            Message.add (r.toString ());
        }
    } catch (Exception ex) {
        Message.add ("Could not find the recommendation provider.", Message.ERROR);
        ex.printStackTrace ();
    }
}


public boolean addEntry (File file) {
    if (file == null) {
        log.warning ("addEntry - No File");
        return false;
    }
    if (! file.exists () || file.isDirectory ()) {
        log.warning ("addEntry - not added - " + file + ", Exists=" + file.exists () + ", Directory=" + file.isDirectory ());
        return false;
    }
    log.fine ("addEntry - " + file);
    String name = file.getName ();
    byte [] data = null;
    try {
        FileInputStream fis = new FileInputStream (file);
        ByteArrayOutputStream os = new ByteArrayOutputStream ();
        byte [] buffer = new byte [1024 * 8];
        int length = - 1;
        while ((length = fis.read (buffer)) != - 1) {
            os.write (buffer, 0, length);
        }
        fis.close ();
        data = os.toByteArray ();
        os.close ();
    } catch (IOException ioe) {
        log.log (Level.SEVERE, "addEntry (file)", ioe);
    }
    return addEntry (name, data);
}


-----Function Pair=230=-----==

private long doChecksum (String fileName) {
    CheckedInputStream cis = null;
    try {
        cis = new CheckedInputStream (new FileInputStream (fileName), new CRC32 ());
    } catch (FileNotFoundException e) {
        System.err.println ("File not found.");
        System.exit (1);
    }
    byte [] buf = new byte [128];
    try {
        while (cis.read (buf) >= 0);
    } catch (IOException e) {
        throw new RuntimeException ("error while reading file", e);
    }
    long checksum = cis.getChecksum ().getValue ();
    return checksum;
}


private void addOriginSigsRels (String signatureZipEntryName, ZipOutputStream zipOutputStream) throws ParserConfigurationException, IOException, TransformerConfigurationException, TransformerFactoryConfigurationError, TransformerException {
    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance ();
    documentBuilderFactory.setNamespaceAware (true);
    DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder ();
    Document originSignRelsDocument = documentBuilder.newDocument ();
    Element relationshipsElement = originSignRelsDocument.createElementNS ("http://schemas.openxmlformats.org/package/2006/relationships", "Relationships");
    relationshipsElement.setAttributeNS (Constants.NamespaceSpecNS, "xmlns", "http://schemas.openxmlformats.org/package/2006/relationships");
    originSignRelsDocument.appendChild (relationshipsElement);
    Element relationshipElement = originSignRelsDocument.createElementNS ("http://schemas.openxmlformats.org/package/2006/relationships", "Relationship");
    String relationshipId = "rel-" + UUID.randomUUID ().toString ();
    relationshipElement.setAttribute ("Id", relationshipId);
    relationshipElement.setAttribute ("Type", "http://schemas.openxmlformats.org/package/2006/relationships/digital-signature/signature");
    String target = FilenameUtils.getName (signatureZipEntryName);
    LOG.debug ("target: " + target);
    relationshipElement.setAttribute ("Target", target);
    relationshipsElement.appendChild (relationshipElement);
    zipOutputStream.putNextEntry (new ZipEntry ("_xmlsignatures/_rels/origin.sigs.rels"));
    writeDocumentNoClosing (originSignRelsDocument, zipOutputStream, false);
}


-----Function Pair=231=-----==

public static void batchUpdateRun (ArrayList < IdValue < Integer > > v) throws SQLException {
    boolean autoCommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        final String query = "UPDATE " + table + " SET run=? WHERE idJob=?";
        PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
        curSt = st;
        for (IdValue < Integer > r : v) {
            st.setInt (1, r.value);
            st.setInt (2, r.id);
            st.addBatch ();
        }
        st.executeBatch ();
        st.close ();
    } catch (SQLException e) {
        DatabaseConnector.getInstance ().getConn ().rollback ();
        throw e;
    } finally {
        curSt = null;
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autoCommit);
    }
}


public static List < File > unzip (File sourceZipFile, File unzipDestinationDirectory) throws Exception {
    ZipFile zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
    List < File > unzippedFiles = new ArrayList < File > ();
    Enumeration zipFileEntries = zipFile.entries ();
    while (zipFileEntries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) zipFileEntries.nextElement ();
        String currentEntry = entry.getName ();
        File destFile = new File (unzipDestinationDirectory, currentEntry);
        unzippedFiles.add (destFile);
        File destinationParent = destFile.getParentFile ();
        destinationParent.mkdirs ();
        if (! entry.isDirectory ()) {
            BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (entry));
            int currentByte;
            byte data [] = new byte [BUFFER];
            destFile.createNewFile ();
            FileOutputStream fos = new FileOutputStream (destFile);
            BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
            while ((currentByte = is.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, currentByte);
            }
            dest.flush ();
            dest.close ();
            is.close ();
        }
    }
    zipFile.close ();
    return unzippedFiles;
}


-----Function Pair=232=-----==

protected static void zipSingleFile (FileWrapper file, String filename, ZipOutputStream zipStream, SubMonitor progress) throws IOException, SarosCancellationException {
    try {
        if (progress.isCanceled ()) {
            throw new SarosCancellationException ();
        }
        progress.beginTask ("Compressing: " + filename, 1);
        log.debug ("Compress file: " + filename);
        if (file == null || ! file.exists ()) {
            throw new IllegalArgumentException ("The file to zip does not exist: " + filename);
        }
        zipStream.putNextEntry (new ZipEntry (filename));
        writeFileToStream (file, filename, zipStream);
        zipStream.closeEntry ();
    } finally {
        progress.done ();
    }
}


public final String [] parseStandardArgs (String [] args) throws IllegalArgumentException, IOException {
    if (args == null) {
        throw new IllegalArgumentException ("args == null");
    }
    ArrayList < String > leftover = new ArrayList < String > ();
    for (int i = 0; i < args.length; i ++) {
        String a = args [i];
        if (a == null) {
            throw new IllegalArgumentException ("args[" + i + "] is null");
        }
        if (a.equals ("-o") && i + 1 < args.length) {
            setOutputJar (new File (args [i + 1]));
            i ++;
            continue;
        }
        else if (! a.startsWith ("-")) {
            if (addInputElement (a)) {
                continue;
            }
        }
        else if (a.startsWith ("--")) {
            for (int j = i; j < args.length; j ++) {
                leftover.add (args [j]);
            }
            break;
        }
        leftover.add (a);
    }
    String [] r = new String [leftover.size ()];
    leftover.toArray (r);
    return r;
}


-----Function Pair=233=-----==

public static String getOutputText (int type, ExperimentResult er) throws NoConnectionToDBException, SQLException, IOException {
    String col = null;
    switch (type) {
        case ExperimentResult.SOLVER_OUTPUT :
            col = "solverOutput";
            break;
        case ExperimentResult.LAUNCHER_OUTPUT :
            col = "launcherOutput";
            break;
        case ExperimentResult.VERIFIER_OUTPUT :
            col = "verifierOutput";
            break;
        case ExperimentResult.WATCHER_OUTPUT :
            col = "watcherOutput";
    }
    if (col == null) {
        return null;
    }
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT " + col + " " + "FROM " + outputTable + " " + "WHERE ExperimentResults_idJob=?;");
    ps.setInt (1, er.getId ());
    ResultSet rs = ps.executeQuery ();
    String res = null;
    if (rs.next ()) {
        StringBuilder sb = new StringBuilder ();
        InputStream in = rs.getBinaryStream (1);
        if (in == null) {
            return null;
        }
        BufferedReader reader = new BufferedReader (new InputStreamReader (in));
        String line;
        while ((line = reader.readLine ()) != null) {
            sb.append (line).append ('\n');
        }
        in.close ();
        res = sb.toString ();
    }
    rs.close ();
    ps.close ();
    return res;
}


public static void writeProjectToFile (Project p, File proj_file) throws Exception {
    ZipOutputStream zout = openZipArchive (proj_file);
    String xml = SerializationHelper.getXMLForProject (p);
    writeXMLToZipArchive ("quickvol_project.xml", xml, zout);
    if (p.getStack ().getLayers () != null) {
        for (int a = 0; a < p.getStack ().getLayers ().length; a ++) {
            String fname = p.getStack ().getLayers () [a].getName ();
            String entryname = null;
            if (fname.toLowerCase ().endsWith (".png")) entryname = fname;
            else {
                entryname = fname + ".png";
            }
            ZipEntry entry = new ZipEntry (entryname);
            zout.putNextEntry (entry);
            javax.imageio.ImageIO.write (p.getStack ().getLayers () [a].getOrigImage (), "png", zout);
        }
    }
    zout.close ();
}


-----Function Pair=234=-----==

public ActionForward execute (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    ActionErrors errors = new ActionErrors ();
    HttpSession session = request.getSession ();
    User voUser = (User) session.getAttribute ("voUser");
    VO virtObs = (VO) session.getAttribute ("vobean");
    if (null == virtObs) {
        session.removeAttribute ("currentPage");
        return (mapping.findForward ("logon"));
    }
    if (voUser == null) {
        session.removeAttribute ("currentPage");
        log.error ("Session is missing or has expired for client from " + request.getRemoteAddr ());
        errors.add (ActionErrors.GLOBAL_ERROR, new ActionError ("error.session.nouser"));
        saveErrors (request, errors);
        return (mapping.findForward ("logon"));
    }
    if (! voUser.isAnonymous ()) {
        String objectId = request.getParameter ("objId");
        String action = request.getParameter ("action");
        String taskValue = request.getParameter ("task");
        if (null != objectId && objectId.length () > 0 && null != action) {
            if (action.equalsIgnoreCase ("remove")) {
                removeBasketObject (voUser.getProfileName (), objectId);
            }
            if (action.equalsIgnoreCase ("saveNote") && null != request.getParameter ("noteText")) {
                noteBasketObject (voUser.getProfileName (), objectId, request.getParameter ("noteText"));
            }
        }
        if (null != action && action.equalsIgnoreCase ("archive")) {
            archiveBasketObjects (voUser.getProfileName (), request, false);
        }
        if (null != action && action.equalsIgnoreCase ("taskSel")) {
            if (null != taskValue && taskValue.equalsIgnoreCase ("archive")) {
                archiveBasketObjects (voUser.getProfileName (), request, true);
            }
            if (null != taskValue && taskValue.equalsIgnoreCase ("delete")) {
                String [] items = request.getParameterValues ("selectedItem");
                for (int i = 0; i < items.length; i ++) {
                    removeBasketObject (voUser.getProfileName (), items [i].toString ());
                }
            }
        }
        return (mapping.findForward ("success"));
    }
    else {
        session.removeAttribute ("currentPage");
        log.error ("User from " + request.getRemoteAddr () + " is not authorize to use this page.");
        errors.add (ActionErrors.GLOBAL_ERROR, new ActionError ("error.voUser.authorize"));
        saveErrors (request, errors);
        return (mapping.findForward ("logon"));
    }
}


public void _zipAll (ResourceStore resourceStore, ResourceFolder root, ResourceFolder folder) throws IOException {
    ResourceFolder [] folderList = resourceStore.listResourceFolders (folder);
    for (int loop = 0; loop < folderList.length; loop ++) {
        _zipAll (resourceStore, root, folderList [loop]);
    }
    Resource [] list = resourceStore.listResources (folder);
    for (int loop = 0; loop < list.length; loop ++) {
        String entryName = list [loop].getPath () + "/" + list [loop].getName ();
        if (entryName.equals (root.getPath () + "/" + root.getName () + ".wiki.zip")) {
            continue;
        }
        if (entryName.charAt (0) == '/') {
            entryName = entryName.substring (1);
        }
        addEntry (entryName, resourceStore.getInputStream (list [loop]));
    }
}


-----Function Pair=235=-----==

public static final void buildZipBall (ZipMap zipMap, String outputFilepath) throws Exception {
    String outFilename = outputFilepath;
    if (! outFilename.endsWith (".zip")) {
        outFilename += ".zip";
    }
    Messenger.printMsg (Messenger.TRACE, "Build ZIP file <" + outputFilepath + ">");
    ZipOutputStream out;
    out = new ZipOutputStream (new FileOutputStream (outFilename));
    long file_size = 0;
    boolean full = false;
    for (String dir : zipMap.keySet ()) {
        Set < ZipEntryRef > zers = zipMap.get (dir);
        TreeSet < String > storedRef = new TreeSet < String > ();
        for (ZipEntryRef zer : zers) {
            String fileitem = zer.getUri ();
            byte [] buf = new byte [1024];
            FileInputStream in;
            File f;
            if ((f = new File (fileitem)).exists ()) {
                in = new FileInputStream (fileitem);
                file_size += f.length () / 1000000;
            }
            else if ((f = new File (fileitem + ".gz")).exists ()) {
                in = new FileInputStream (fileitem + ".gz");
                file_size += f.length () / 1000000;
            }
            else {
                Messenger.printMsg (Messenger.ERROR, "File <" + fileitem + "> or <" + fileitem + ".gz> not found");
                continue;
            }
            Messenger.printMsg (Messenger.TRACE, "Compress " + fileitem);
            String str = dir + "/" + zer.getName ();
            ZipEntry ze = new ZipEntry (str);
            if (! storedRef.contains (str)) {
                out.putNextEntry (ze);
                storedRef.add (str);
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                in.close ();
                out.closeEntry ();
            }
            if (file_size > MAX_SIZE) {
                String msg = "The size of the zipped file exceed " + MAX_SIZE + "Mb: zipball truncated";
                Messenger.printMsg (Messenger.WARNING, msg);
                full = true;
                Messenger.printMsg (Messenger.TRACE, "Compress truncated.txt");
                ze = new ZipEntry ("truncated.txt");
                out.putNextEntry (ze);
                out.write (msg.getBytes (), 0, msg.length ());
                out.closeEntry ();
                break;
            }
        }
        if (full) {
            break;
        }
    }
    out.closeEntry ();
    out.close ();
}


public static < T > String join (String delimiter, UnaryFunction < String, T > formatter, Collection < T > array) {
    if (array.isEmpty ()) {
        return "<empty>";
    }
    int i = 0;
    StringBuffer res = new StringBuffer ();
    for (T item : array) {
        if (formatter != null) {
            res.append (formatter.eval (item));
        }
        else {
            res.append (item);
        }
        i ++;
        if (i < array.size ()) {
            res.append (delimiter);
        }
    }
    return res.toString ();
}


-----Function Pair=236=-----==

public void addAttributes (IMemento parent, List < RepositoryTaskAttribute > attributes) {
    for (RepositoryTaskAttribute attribute : attributes) {
        IMemento attribMemento = parent.createChild (ELEMENT_ATTRIBUTE);
        attribMemento.putString (ATTRIBUTE_ID, getCleanText (attribute.getId ()));
        attribMemento.putString (ATTRIBUTE_NAME, getCleanText (attribute.getName ()));
        attribMemento.putString (ATTRIBUTE_HIDDEN, String.valueOf (attribute.isHidden ()));
        attribMemento.putString (ATTRIBUTE_READONLY, String.valueOf (attribute.isReadOnly ()));
        IMemento values = attribMemento.createChild (ELEMENT_VALUES);
        for (String value : attribute.getValues ()) {
            values.createChild (ELEMENT_VALUE).putTextData (getCleanText (value));
        }
        IMemento options = attribMemento.createChild (ELEMENT_OPTIONS);
        for (String optionValue : attribute.getOptions ()) {
            IMemento option = options.createChild (ELEMENT_OPTION);
            option.putTextData (getCleanText (optionValue));
            String parameter = attribute.getOptionParameter (optionValue);
            if (parameter != null) {
                option.putString (ATTRIBUTE_PARAMETER, getCleanText (parameter));
            }
        }
        IMemento metaData = attribMemento.createChild (ELEMENT_META_DATA);
        Map < String, String > metadata = attribute.getMetaData ();
        if (metadata != null && metadata.size () > 0) {
            for (String key : metadata.keySet ()) {
                IMemento meta = metaData.createChild (ELEMENT_META);
                meta.putString (ATTRIBUTE_KEY, getCleanText (key));
                meta.putTextData (getCleanText (metadata.get (key)));
            }
        }
    }
}


public WebmillDeploy (String inputName, String outputName, boolean stripLoggers) throws Exception {
    File tempFile = null;
    JarFile jin = null;
    JarOutputStream jout = null;
    FileChannel srcChannel = null;
    FileChannel dstChannel = null;
    try {
        String portletApplicationName = getPortletApplicationName (outputName);
        System.out.println ("portletApplicationName = " + portletApplicationName);
        tempFile = File.createTempFile ("webmill-delpoy-", "");
        tempFile.deleteOnExit ();
        jin = new JarFile (inputName);
        jout = new JarOutputStream (new FileOutputStream (tempFile));
        Document webXml = null;
        Document portletXml = null;
        Document contextXml = null;
        ZipEntry src;
        InputStream source;
        Enumeration zipEntries = jin.entries ();
        while (zipEntries.hasMoreElements ()) {
            src = (ZipEntry) zipEntries.nextElement ();
            source = jin.getInputStream (src);
            try {
                String target = src.getName ();
                if (WEB_INF_WEB_XML.equals (target)) {
                    System.out.println ("Found web.xml");
                    webXml = parseXml (source);
                }
                else if (WEB_INF_PORTLET_XML.equals (target)) {
                    System.out.println ("Found WEB-INF/portlet.xml");
                    portletXml = parseXml (source);
                }
                else if (META_INF_CONTEXT_XML.equals (target)) {
                    System.out.println ("Found META-INF/context.xml");
                    contextXml = parseXml (source);
                }
            } finally {
                source.close ();
            }
        }
        if (webXml == null) {
            throw new IllegalArgumentException ("WEB-INF/web.xml not found");
        }
        if (portletXml == null) {
            throw new IllegalArgumentException ("WEB-INF/portlet.xml not found");
        }
        WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter (webXml);
        webRewriter.processWebXML ();
        WebmillContextRewriter contextRewriter = new WebmillContextRewriter (contextXml, portletApplicationName);
        contextRewriter.processContextXML ();
        jin = new JarFile (inputName);
        zipEntries = jin.entries ();
        while (zipEntries.hasMoreElements ()) {
            src = (ZipEntry) zipEntries.nextElement ();
            source = jin.getInputStream (src);
            try {
                String target = src.getName ();
                String fullTarget = '/' + target;
                if (stripLoggers && target.endsWith (".jar") && (target.startsWith ("WEB-INF/lib/commons-logging") || target.startsWith ("WEB-INF/lib/log4j"))) {
                    System.out.println ("Skip logger " + target);
                    continue;
                }
                else {
                    if (webRewriter.getRealPortletTldFile () != null && fullTarget.equals (webRewriter.getRealPortletTldFile ())) {
                        System.out.println ("Skip portlet tld file " + fullTarget);
                        continue;
                    }
                    else if (target.equals (WEB_INF_WEB_XML)) {
                        System.out.println ("Skip web.xml file " + target);
                        continue;
                    }
                    else if (target.equals (WEB_INF_PORTLET_XML)) {
                        System.out.println ("Skip portlet.xml file " + target);
                        continue;
                    }
                    else if (target.equals (META_INF_CONTEXT_XML)) {
                        System.out.println ("Skip context.xml file " + target);
                        continue;
                    }
                    System.out.println ("Add file " + target);
                }
                addFile (target, source, jout);
            } finally {
                source.close ();
            }
        }
        addFile (WEB_INF_WEB_XML, webXml, jout);
        addFile (WEB_INF_PORTLET_XML, portletXml, jout);
        addFile (META_INF_CONTEXT_XML, contextXml, jout);
        System.out.println ("Attempting to add portlet.tld to war...");
        InputStream is = this.getClass ().getResourceAsStream ("/org/riverock/webmill/container/tags/portlet.tld");
        if (is == null) {
            System.out.println ("Failed to find portlet.tld in classpath");
        }
        else {
            String portletTldFile = webRewriter.getRealPortletTldFile ();
            if (portletTldFile.charAt (0) == '/') {
                portletTldFile = portletTldFile.substring (1);
            }
            System.out.println ("Adding file " + portletTldFile);
            try {
                addFile (portletTldFile, is, jout);
            } finally {
                is.close ();
            }
        }
        jout.close ();
        jin.close ();
        jin = null;
        jout = null;
        System.out.println ("Creating war " + outputName + " ...");
        System.out.flush ();
        srcChannel = new FileInputStream (tempFile).getChannel ();
        dstChannel = new FileOutputStream (outputName).getChannel ();
        dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());
        srcChannel.close ();
        srcChannel = null;
        dstChannel.close ();
        dstChannel = null;
        tempFile.delete ();
        tempFile = null;
        System.out.println ("War " + outputName + " created");
        System.out.flush ();
    } finally {
        if (srcChannel != null && srcChannel.isOpen ()) {
            try {
                srcChannel.close ();
            } catch (IOException e1) {
            }
        }
        if (dstChannel != null && dstChannel.isOpen ()) {
            try {
                dstChannel.close ();
            } catch (IOException e1) {
            }
        }
        if (jin != null) {
            try {
                jin.close ();
                jin = null;
            } catch (IOException e1) {
            }
        }
        if (jout != null) {
            try {
                jout.close ();
                jout = null;
            } catch (IOException e1) {
            }
        }
        if (tempFile != null && tempFile.exists ()) {
            tempFile.delete ();
        }
    }
}


-----Function Pair=237=-----==

public static final boolean compress (final String sSource, final String sDest, final boolean bDeleteSourceOnSuccess) {
    InputStream is = null;
    OutputStream os = null;
    try {
        os = new GZIPOutputStream (new FileOutputStream (sDest));
        is = new FileInputStream (sSource);
        final byte [] buff = new byte [1024];
        int r;
        do {
            r = is.read (buff);
            if (r > 0) os.write (buff, 0, r);
        }
        while (r > 0);
        is.close ();
        os.flush ();
        os.close ();
    } catch (Throwable e) {
        Log.log (Log.WARNING, "lazyj.Utils", "compress : cannot compress '" + sSource + "' to '" + sDest + "'", e);
        return false;
    } finally {
        if (is != null) {
            try {
                is.close ();
            } catch (IOException ioe) {
            }
        }
        if (os != null) {
            try {
                os.close ();
            } catch (IOException ioe) {
            }
        }
    }
    if (bDeleteSourceOnSuccess) try {
        if (! (new File (sSource)).delete ()) Log.log (Log.WARNING, "lazyj.Utils", "compress: could not delete original file (" + sSource + ")");
    } catch (SecurityException se) {
        Log.log (Log.ERROR, "lazyj.Utils", "compress: security constraints prevents file deletion");
    }
    return true;
}


protected void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String nomeDoArquivoZip = request.getParameter ("filename");
    int idSessao = Integer.parseInt (request.getParameter ("idsessao"));
    String loginUsuario = request.getParameter ("login");
    List < String > listaDeNomesDosArquivos = filesManager.getFilesNames (idSessao);
    byte b [] = new byte [1024];
    try {
        OutputStream out = response.getOutputStream ();
        ZipOutputStream zout = new ZipOutputStream (out);
        response.setHeader ("Content-Disposition", "attachment;filename=" + nomeDoArquivoZip);
        response.setContentType ("application/zip");
        for (int i = 0; i < listaDeNomesDosArquivos.size (); i ++) {
            String nomeArquivoAtual = listaDeNomesDosArquivos.get (i);
            if (nomeArquivoAtual != null) {
                File arquivo = new File (DEFAULT_PATH + FILE_SEPARATOR + idSessao + "-" + loginUsuario + FILE_SEPARATOR + nomeArquivoAtual);
                System.out.println (DEFAULT_PATH + FILE_SEPARATOR + idSessao + "-" + loginUsuario + FILE_SEPARATOR + nomeArquivoAtual);
                InputStream in = new ByteArrayInputStream (getArrayBytes (arquivo));
                ZipEntry e = new ZipEntry (nomeArquivoAtual);
                zout.putNextEntry (e);
                int len = 0;
                while ((len = in.read (b)) != - 1) {
                    zout.write (b, 0, len);
                }
            }
            zout.closeEntry ();
        }
        zout.close ();
        out.close ();
    } catch (IOException ex) {
        System.err.println ("Erro no Download do arquivo: " + ex.getMessage ());
        ex.printStackTrace ();
    }
}


-----Function Pair=238=-----==

public void removeIncompleteStations () {
    int size = vector.size ();
    String s1, s2;
    String s3 = "";
    String s4 = "";
    int dd, d1, d2, mon1, mon2, day1, day2;
    Vector < String > r_this;
    Vector < String > r_next;
    Vector < String > rm_this;
    Vector < String > rm_next;
    int start_pos = 0;
    int end_pos = 0;
    boolean newStation = false;
    boolean newStation2 = false;
    System.out.println ("initial size: " + size);
    for (int i = 0; i < size; i ++) {
        end_pos ++;
        s1 = vector.elementAt (i);
        r_this = getData (s1);
        if (i < (size - 1)) {
            s2 = vector.elementAt (i + 1);
        }
        else {
            s2 = vector.elementAt (start_pos);
        }
        r_next = getData (s2);
        mon1 = getMonth (r_this.elementAt (1));
        day1 = getDay (r_this.elementAt (1));
        newStation = ! r_this.get (0).toString ().equals (r_next.get (0).toString ());
        if (newStation && mon1 == 12 && (day1 > 15)) {
            r_next = r_this;
            start_pos = i + 1;
            if (mon1 > 1 && day1 > 1) {
                mon1 = 1;
                day1 = 1;
                r_next = getData (s2);
            }
        }
        mon2 = getMonth (r_next.elementAt (1));
        day2 = getDay (r_next.elementAt (1));
        d1 = CalendarUtils.calcJulianDays (mon1, day1);
        d2 = CalendarUtils.calcJulianDays (mon2, day2);
        dd = d2 - d1;
        if (dd > 14) {
            for (int r = start_pos; r < (size - 1); r ++) {
                s3 = vector.elementAt (r);
                rm_this = getData (s3);
                s4 = vector.elementAt (r + 1);
                rm_next = getData (s4);
                newStation2 = ! rm_this.get (0).toString ().equals (rm_next.get (0).toString ());
                if (newStation2) {
                    end_pos = r;
                    break;
                }
            }
            System.out.println ("Removing: " + start_pos + "\t" + end_pos);
            System.out.println ("\t" + s1 + "\t" + s3);
            int r = 0;
            try {
                for (r = vector.size (); r >= start_pos; r --) {
                    vector.remove (r);
                }
            } catch (Exception e) {
                System.out.println ("Error while removing ... end_pos: " + end_pos + "\tstart_pos\t" + start_pos + "\tr\t" + r);
                e.printStackTrace ();
            }
            size = vector.size ();
            i = start_pos;
            System.out.println ("new size: " + size);
        }
    }
}


public Archive read (Node file) throws IOException {
    Buffer buffer;
    ZipInputStream zip;
    ZipEntry entry;
    Node node;
    buffer = file.getIO ().getBuffer ();
    zip = new ZipInputStream (file.createInputStream ());
    while (true) {
        entry = zip.getNextEntry ();
        if (entry == null) {
            break;
        }
        node = data.join (getPath (entry));
        if ("".equals (node.getPath ())) {
            continue;
        }
        if (entry.isDirectory ()) {
            node.mkdirsOpt ();
        }
        else if (isManifest (node)) {
            mergeManifest (new Manifest (zip));
            zip.closeEntry ();
        }
        else {
            node.getParent ().mkdirsOpt ();
            buffer.copy (zip, node);
            zip.closeEntry ();
        }
    }
    zip.close ();
    return this;
}


-----Function Pair=239=-----==

public static ArrayList < ExperimentResult > getAllBySolverConfiguration (SolverConfiguration sc) throws SQLException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, NoConnectionToDBException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException {
    ArrayList < ExperimentResult > res = new ArrayList < ExperimentResult > ();
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement (selectQuery + "WHERE Experiment_idExperiment=? AND SolverConfig_idSolverConfig=?;");
    st.setInt (1, sc.getExperiment_id ());
    st.setInt (2, sc.getId ());
    ResultSet rs = st.executeQuery ();
    while (rs.next ()) {
        ExperimentResult er = getExperimentResultFromResultSet (rs);
        res.add (er);
        er.setSaved ();
    }
    rs.close ();
    st.close ();
    ExperimentResultHasPropertyDAO.assign (res, sc.getExperiment_id ());
    return res;
}


protected Map < String, Set < ImageDrawComponent > > getImageKey2ImageDrawComponent (RootDrawComponent root) {
    Collection < ImageDrawComponent > imageDrawComponents = root.findDrawComponents (ImageDrawComponent.class);
    Map < String, Set < ImageDrawComponent > > imageKey2ImageDrawComponents = new HashMap < String, Set < ImageDrawComponent > > ();
    for (Iterator < ImageDrawComponent > it = imageDrawComponents.iterator (); it.hasNext ();) {
        ImageDrawComponent imageDC = it.next ();
        String imageKey = ManifestWriter.getImageKeyString (imageDC);
        if (imageKey2ImageDrawComponents.containsKey (imageKey)) {
            Set < ImageDrawComponent > images = imageKey2ImageDrawComponents.get (imageKey);
            images.add (imageDC);
        }
        else {
            Set < ImageDrawComponent > images = new HashSet < ImageDrawComponent > ();
            images.add (imageDC);
            imageKey2ImageDrawComponents.put (imageKey, images);
        }
    }
    return imageKey2ImageDrawComponents;
}


-----Function Pair=240=-----==

public static FrostIndex readKeyFile (File source) {
    if (! source.isFile () || ! (source.length () > 0)) return new FrostIndex (new HashMap ());
    else {
        int counter = 0;
        Document d = null;
        try {
            d = XMLTools.parseXmlFile (source.getPath (), false);
        } catch (IllegalArgumentException t) {
            logger.log (Level.SEVERE, "Exception thrown in readKeyFile(File source): \n" + "Offending file saved as badfile.xml - send it to a dev for analysis", t);
            File badfile = new File ("badfile.xml");
            source.renameTo (badfile);
        }
        if (d == null) {
            logger.warning ("Couldn't parse index file.");
            return null;
        }
        FrostIndex idx = new FrostIndex (d.getDocumentElement ());
        Iterator i = idx.getFiles ().iterator ();
        while (i.hasNext ()) {
            SharedFileObject newKey = (SharedFileObject) i.next ();
            if (! newKey.isValid ()) {
                i.remove ();
                logger.warning ("invalid key found");
                continue;
            }
        }
        return idx;
    }
}


private void importAsOrganization (GroupwareUser groupwareUser, Community importedCommunity, ImportCommunityResult importCommunityResult) throws SystemException, PortalException {
    String type = importCommunityResult.getCommunityType ();
    boolean isOrganizationTypeRootable = getLiferayHelper ().getIsOrganizationTypeRootable (type);
    log.info ("Creating organization for imported community");
    Organization createdOrganizationFromCommunityData;
    if (! isOrganizationTypeRootable) {
        createdOrganizationFromCommunityData = createSubOrganization (groupwareUser, importedCommunity, importCommunityResult);
    }
    else createdOrganizationFromCommunityData = getLiferayHelper ().createOrganizationFromCommunityData (importedCommunity, groupwareUser, importCommunityResult.getWebName (), importedCommunity.getType ());
    setCustomAttributes (importedCommunity, importCommunityResult, createdOrganizationFromCommunityData);
    String groupId = String.valueOf (createdOrganizationFromCommunityData.getGroup ().getGroupId ());
    String name = createdOrganizationFromCommunityData.getName ();
    String description = createdOrganizationFromCommunityData.getComments ();
    log.info ("Assigning imported community to organization with groupId " + groupId);
    updateCommunityAndWeb (groupId, importedCommunity, name, description, Boolean.TRUE);
}


-----Function Pair=241=-----==

private static void fork (ZipOutputStream out, File tmpFile, String path) throws IOException {
    System.out.println (tmpFile);
    if (tmpFile.isDirectory ()) {
        System.out.println (tmpFile + " is DIR");
        for (String tmpStr : tmpFile.list ()) {
            System.out.println (tmpStr + " is Child of " + tmpFile);
            fork (out, new File (tmpFile, tmpStr), path + Const.FILE_SEPARATOR + tmpStr);
        }
    }
    else if (tmpFile.isFile ()) {
        System.out.println (tmpFile + " is File");
        byte [] buffer = new byte [Const.BUFFER_SIZE];
        FileInputStream in = new FileInputStream (tmpFile);
        out.putNextEntry (new ZipEntry (path));
        int length;
        while ((length = in.read (buffer)) > 0) {
            out.write (buffer, 0, length);
        }
        out.closeEntry ();
        in.close ();
        return;
    }
    else {
        return;
    }
}


public static void unzipDirectory (File srcZip, File destDir) throws IOException {
    assert destDir.isDirectory ();
    String rootDir = destDir.getAbsolutePath ();
    ZipInputStream zis = new ZipInputStream (new FileInputStream (srcZip));
    ZipEntry ze;
    while ((ze = zis.getNextEntry ()) != null) {
        final File file = new File (ze.getName ());
        String fullPath;
        if (file.getParent () != null) {
            fullPath = rootDir + File.separator + file.getParent ();
        }
        else {
            fullPath = rootDir;
        }
        new File (fullPath).mkdirs ();
        String fileName = new File (ze.getName ()).getName ();
        extractFile (zis, fullPath, fileName);
    }
    zis.close ();
}


-----Function Pair=242=-----==

public static void send (String T, String ST) {
    String data;
    try {
        data = URLEncoder.encode ("classe", "UTF-8") + "=" + URLEncoder.encode (T, "UTF-8");
        data += "&" + URLEncoder.encode ("testo", "UTF-8") + "=" + URLEncoder.encode (ST, "UTF-8");
        URL url = new URL ("http://" + Main.config.getRemoteRoot () + "/bug.asp?" + data);
        URLConnection conn = url.openConnection ();
        conn.setDoOutput (true);
        conn.setDoInput (true);
        BufferedReader rd = new BufferedReader (new InputStreamReader (conn.getInputStream ()));
        String line;
        String str = "";
        while ((line = rd.readLine ()) != null) {
            str += line;
        }
        rd.close ();
    } catch (MalformedURLException e) {
        e.printStackTrace ();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void writeFiles (ZipOutputStream zos, DataOutputStream dos) {
    if (image_file.length () == 0) return;
    try {
        if (image == null) loadImage ();
        int w = image.getWidth (this);
        int h = image.getHeight (this);
        PixelGrabber grabber = new PixelGrabber (image, 0, 0, - 1, - 1, true);
        try {
            grabber.grabPixels ();
        } catch (InterruptedException e) {
            System.out.println (e);
        }
        zos.putNextEntry (new ZipEntry (image_file));
        dos.writeInt (w);
        dos.writeInt (h);
        int a [] = (int []) grabber.getPixels ();
        dos.writeInt (a.length);
        for (int i = 0; i < a.length; i ++) dos.writeInt (a [i]);
        zos.closeEntry ();
    } catch (IOException e) {
        System.out.println (e);
    }
}


-----Function Pair=243=-----==

private void zipDir (File dir, String jarEntry, JarOutputStream jos) throws IOException {
    String [] dirList = dir.list ();
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (dir, dirList [i]);
        if (f.isDirectory ()) {
            zipDir (f, jarEntry + dirList [i] + File.separatorChar, jos);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        ZipEntry anEntry = new ZipEntry (jarEntry + dirList [i]);
        jos.putNextEntry (anEntry);
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            jos.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


public static boolean moveToDestinationDir (String uploadPath) {
    try {
        File up = new File (uploadPath);
        if (up.exists ()) {
            return false;
        }
        String destination = uploadPath;
        if (isAudiofile (getExtension (up.getName ()))) {
            MetaManagerAudio audio = new MetaManagerAudio (up);
            destination = Const.AUDIO_DIR + Const.FILE_SEPARATOR + audio.getArtist () + Const.FILE_SEPARATOR + audio.getAlbum () + Const.FILE_SEPARATOR + up.getName ();
        }
        else if (isVideofile (getExtension (up.getName ()))) {
            destination = Const.VIDEO_DIR + Const.FILE_SEPARATOR + up.getName ().replace (getExtension (up.getName ()), "") + Const.FILE_SEPARATOR + up.getName ();
        }
        return move (up, new File (destination));
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=244=-----==

public static ProjectContainer loadCompressedProject (File file) throws Exception {
    ProjectContainer project = null;
    InputStream inputStream = new FileInputStream (file);
    byte [] magic = new byte [4];
    inputStream.read (magic);
    inputStream.close ();
    if (magic [3] == (byte) 0x04 && magic [2] == (byte) 0x03 && magic [1] == (byte) 0x4b && magic [0] == (byte) 0x50) {
        FileInputStream fileinputStream = new FileInputStream (file);
        inputStream = fileinputStream;
        try {
            ZipInputStream zipi = new ZipInputStream (inputStream);
            zipi.getNextEntry ();
            inputStream = zipi;
            inputStream = new BufferedInputStream (inputStream);
            project = loadProject (inputStream);
            project.compression_level = 1;
        } finally {
            fileinputStream.close ();
        }
    }
    if (magic [0] == (byte) 0x4c && magic [1] == (byte) 0x5a && magic [2] == (byte) 0x4d && magic [3] == (byte) 0x61) {
        FileInputStream fileinputStream = new FileInputStream (file);
        inputStream = fileinputStream;
        try {
            inputStream.read (magic);
            InputStream inStream = inputStream;
            int propertiesSize = 5;
            byte [] properties = new byte [propertiesSize];
            if (inStream.read (properties, 0, propertiesSize) != propertiesSize) {
                throw new Exception ("input .lzma file is too short");
            }
            final SevenZip.Compression.LZMA.Decoder decoder = new SevenZip.Compression.LZMA.Decoder ();
            if (! decoder.SetDecoderProperties (properties)) {
                throw new Exception ("Incorrect stream properties");
            }
            long outSize = 0;
            for (int i = 0; i < 8; i ++) {
                int v = inStream.read ();
                if (v < 0) {
                    throw new Exception ("Can't read stream size");
                }
                outSize |= ((long) v) << (8 * i);
            }
            File tempfile = File.createTempFile ("lzma", "temp");
            FileOutputStream fos = new FileOutputStream (tempfile);
            try {
                try {
                    if (! decoder.Code (inStream, fos, outSize)) {
                        throw new Exception ("Can't decode stream");
                    }
                } finally {
                    fos.close ();
                }
                inputStream = new FileInputStream (tempfile);
                try {
                    project = loadProject (inputStream);
                    project.compression_level = 2;
                } finally {
                    inputStream.close ();
                }
            } finally {
                tempfile.delete ();
            }
        } finally {
            fileinputStream.close ();
        }
    }
    if (project == null) {
        FileInputStream fileinputStream = new FileInputStream (file);
        try {
            project = loadProject (fileinputStream);
        } finally {
            fileinputStream.close ();
        }
    }
    return project;
}


private JTextField getInRes () {
    if (inRes == null) {
        inRes = new JTextField ();
        inRes.setBounds (new java.awt.Rectangle (128, 74, 185, 25));
        inRes.setEnabled (false);
        inRes.addFocusListener (new java.awt.event.FocusAdapter () {
            public void focusLost (java.awt.event.FocusEvent e) {
                if ((langFile.getLanguageEntryFor ("meta.res") == null) || ! (inRes.getText ().equals (langFile.getLanguageEntryFor ("meta.res")))) {
                    langFile.addEntry ("meta.res", inRes.getText ());
                    unsaved = true;
                    refreshTableContents ();
                }
            }
        }
        );
    }
    return inRes;
}


-----Function Pair=245=-----==

public boolean isSkip (String filePath) {
    if (started) {
        return false;
    }
    if (startFile == null) {
        started = true;
        return false;
    }
    if (filePath.equals (startFile)) {
        started = true;
        return false;
    }
    return true;
}


public SubjectiveFrame (final File file) throws IOException {
    super ("Subjective Score Entry");
    _file = file;
    getContentPane ().setLayout (new BorderLayout ());
    ZipFile zipfile = null;
    try {
        zipfile = new ZipFile (file);
        final ZipEntry challengeEntry = zipfile.getEntry ("challenge.xml");
        if (null == challengeEntry) {
            throw new RuntimeException ("Unable to find challenge descriptor in file, you probably choose the wrong file or it is corrupted");
        }
        final InputStream challengeStream = zipfile.getInputStream (challengeEntry);
        _challengeDocument = ChallengeParser.parse (new InputStreamReader (challengeStream, Utilities.DEFAULT_CHARSET));
        challengeStream.close ();
        final ZipEntry scoreEntry = zipfile.getEntry ("score.xml");
        if (null == scoreEntry) {
            throw new RuntimeException ("Unable to find score data in file, you probably choose the wrong file or it is corrupted");
        }
        final InputStream scoreStream = zipfile.getInputStream (scoreEntry);
        _scoreDocument = XMLUtils.parseXMLDocument (scoreStream);
        scoreStream.close ();
    } finally {
        if (null != zipfile) {
            try {
                zipfile.close ();
            } catch (final IOException e) {
                LOGGER.debug ("Error closing zipfile", e);
            }
        }
    }
    final JPanel topPanel = new JPanel ();
    getContentPane ().add (topPanel, BorderLayout.NORTH);
    final JButton quitButton = new JButton ("Quit");
    topPanel.add (quitButton);
    quitButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent ae) {
            quit ();
        }
    }
    );
    final JButton saveButton = new JButton ("Save");
    topPanel.add (saveButton);
    saveButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent ae) {
            try {
                save ();
            } catch (final IOException ioe) {
                JOptionPane.showMessageDialog (null, "Error writing to data file: " + ioe.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
            }
        }
    }
    );
    final JButton summaryButton = new JButton ("Summary");
    topPanel.add (summaryButton);
    summaryButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent ae) {
            final SummaryDialog dialog = new SummaryDialog (SubjectiveFrame.this);
            dialog.pack ();
            dialog.setVisible (true);
        }
    }
    );
    final JButton compareButton = new JButton ("Compare Scores");
    topPanel.add (compareButton);
    compareButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent ae) {
            final File compareFile = chooseSubjectiveFile ("Choose the file to compare with");
            if (null != compareFile) {
                try {
                    save ();
                } catch (final IOException ioe) {
                    JOptionPane.showMessageDialog (null, "Error writing to data file: " + ioe.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
                }
                try {
                    final Collection < SubjectiveScoreDifference > diffs = SubjectiveUtils.compareSubjectiveFiles (getFile (), compareFile);
                    if (null == diffs) {
                        JOptionPane.showMessageDialog (null, "Challenge descriptors are different, comparison failed", "Error", JOptionPane.ERROR_MESSAGE);
                    }
                    else if (! diffs.isEmpty ()) {
                        showDifferencesDialog (diffs);
                    }
                    else {
                        JOptionPane.showMessageDialog (null, "No differences found", "No Differences", JOptionPane.INFORMATION_MESSAGE);
                    }
                } catch (final IOException e) {
                    JOptionPane.showMessageDialog (null, "Error reading compare file: " + e.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
                }
            }
        }
    }
    );
    tabbedPane = new JTabbedPane ();
    getContentPane ().add (tabbedPane, BorderLayout.CENTER);
    for (final Element subjectiveElement : new NodelistElementCollectionAdapter (_challengeDocument.getDocumentElement ().getElementsByTagName ("subjectiveCategory"))) {
        createSubjectiveTable (tabbedPane, subjectiveElement);
    }
    addWindowListener (new WindowAdapter () {
        @Override
        public void windowClosing (final WindowEvent e) {
            quit ();
        }
    }
    );
    setDefaultCloseOperation (WindowConstants.DO_NOTHING_ON_CLOSE);
    pack ();
}


-----Function Pair=246=-----==

public void DeleteWorkflow (String userID, String workflowID) {
    ASMWorkflow inst = getASMWorkflow (userID, workflowID);
    removeWorkflow (userID, inst);
    WorkflowData wData = PortalCacheService.getInstance ().getUser (userID).getWorkflow (workflowID);
    Hashtable hsh = new Hashtable ();
    ServiceType st;
    PortalWfsClient pc = null;
    try {
        hsh = new Hashtable ();
        hsh.put ("url", wData.getStorageID ());
        st = InformationBase.getI ().getService ("storage", "portal", hsh, new Vector ());
        PortalStorageClient ps = (PortalStorageClient) Class.forName (st.getClientObject ()).newInstance ();
        ps.setServiceURL (st.getServiceUrl ());
        ps.setServiceID (st.getServiceID ());
        ComDataBean tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        tmp.setPortalID (PORTAL);
        tmp.setUserID (userID);
        tmp.setWorkflowID (wData.getWorkflowID ());
        ps.deleteWorkflow (tmp);
        Enumeration wfenm = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().keys ();
        while (wfenm.hasMoreElements ()) {
            String wfkey = "" + wfenm.nextElement ();
            if (PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (wfkey).getGraf ().equals (wData.getGraf ())) {
                ComDataBean template_tmp = new ComDataBean ();
                PORTAL = this.getPortalID ();
                template_tmp.setPortalID (PORTAL);
                template_tmp.setUserID (userID);
                template_tmp.setWorkflowID (wfkey);
                ps.deleteWorkflow (template_tmp);
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    hsh = new Hashtable ();
    hsh.put ("url", wData.getWfsID ());
    st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
    try {
        pc = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
        pc.setServiceURL (st.getServiceUrl ());
        pc.setServiceID (st.getServiceID ());
        ComDataBean tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        tmp.setPortalID (PORTAL);
        tmp.setUserID (userID);
        tmp.setWorkflowID (wData.getWorkflowID ());
        pc.deleteWorkflow (tmp);
        PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    WorkflowData temp_data = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (wData.getTemplate ());
    try {
        ComDataBean template_tmp = new ComDataBean ();
        PORTAL = this.getPortalID ();
        template_tmp.setPortalID (PORTAL);
        template_tmp.setUserID (userID);
        template_tmp.setWorkflowID (wData.getTemplate ());
        pc.deleteWorkflow (template_tmp);
        PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    Enumeration wfenm = PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().keys ();
    String key = "";
    while (wfenm.hasMoreElements ()) {
        key = "" + wfenm.nextElement ();
        if (PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflow (key).getGraf ().equals (workflowID)) {
            hsh = new Hashtable ();
            st = InformationBase.getI ().getService ("wfs", "portal", hsh, new Vector ());
            try {
                pc = (PortalWfsClient) Class.forName (st.getClientObject ()).newInstance ();
                pc.setServiceURL (st.getServiceUrl ());
                pc.setServiceID (st.getServiceID ());
                ComDataBean tmp = new ComDataBean ();
                PORTAL = this.getPortalID ();
                tmp.setPortalID (PORTAL);
                tmp.setUserID (userID);
                tmp.setWorkflowID (key);
                pc.deleteWorkflow (tmp);
                PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (key);
            } catch (Exception e) {
                e.printStackTrace ();
            }
            PortalCacheService.getInstance ().getUser (userID).getTemplateWorkflows ().remove (key);
            ComDataBean cmd = new ComDataBean ();
            cmd.setWorkflowID (workflowID);
            cmd.setUserID (userID);
            PORTAL = this.getPortalID ();
            cmd.setPortalID (PORTAL);
            pc.deleteWorkflowGraf (cmd);
        }
    }
    PortalCacheService.getInstance ().getUser (userID).getAbstactWorkflows ().remove (workflowID);
    PortalCacheService.getInstance ().getUser (userID).deleteWorkflow (wData.getWorkflowID ());
}


public void saveTextFileContent (String file, String content) throws Exception {
    logger.info ("saving text content to file :" + file);
    File fileToSave = new File (resolvePathWithProjectDir (file));
    if (! fileToSave.exists ()) throw new java.io.FileNotFoundException ("Specified path '" + file + "'  does not exists");
    if (! fileToSave.isFile ()) throw new java.io.FileNotFoundException ("Specified path '" + file + "'  is not a file");
    if (! isPathBeneathProjectDir (fileToSave.getCanonicalPath ())) {
        throw new SecurityException ("save is not allowed outside project directory");
    }
    if (! isPathAllowed (file)) {
        throw new SecurityException ("user does not have this permission");
    }
    FileOutputStream out = new FileOutputStream (fileToSave);
    out.write (content.getBytes ());
    out.close ();
}


-----Function Pair=247=-----==

public void executeInContext (PXBuildContext context) {
    System.out.println ("PXCompileZipArchive.executeInContext() executing\n");
    PXBundle bundle = context.bundle ();
    URL bundleURL = bundle.bundleURL ();
    String bundleDirectoryName = bundleURL.getPath ();
    if (bundleURL.getProtocol ().equals ("file")) {
        try {
            String presentationDirectory = bundleURL.toString ();
            presentationDirectory = presentationDirectory.substring (5, presentationDirectory.length () - 1);
            File presentationDirectoryFile = new File (presentationDirectory);
            String zipFilename = presentationDirectory + ".zip";
            String targetDirectory = (String) PXUtility.defaultValueForKey ("PublishedPresentationDirectory");
            FileOutputStream dest = new FileOutputStream (zipFilename);
            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
            zipDir (presentationDirectoryFile, out, presentationDirectoryFile.getPath (), context);
            out.close ();
        } catch (Exception e) {
            e.printStackTrace ();
            NSDictionary info = new NSDictionary (new Object [] {e.getMessage ()}, new String [] {NSError.LocalizedDescriptionKey});
            NSError message = new NSError ("Pachyderm Build Domain", - 1, info);
            context.appendBuildMessage (message);
        }
    }
}


public static String [] getEntries (final File _zip) {
    final ArrayList r = new ArrayList ();
    ZipFile zf = null;
    try {
        zf = new ZipFile (_zip);
        for (final Enumeration entries = zf.entries (); entries.hasMoreElements ();) {
            r.add (((ZipEntry) entries.nextElement ()).getName ());
        }
    } catch (final IOException e) {
        if (Fu.DEBUG && FuLog.isDebug ()) {
            FuLog.error (e);
        }
        return null;
    } finally {
        if (zf != null) {
            try {
                zf.close ();
            } catch (final IOException e) {
                if (Fu.DEBUG && FuLog.isDebug ()) {
                    FuLog.error (e);
                }
            }
        }
    }
    return CtuluLibString.enTableau (r);
}


-----Function Pair=248=-----==

protected Element openExportFile () throws IOException, SAXException {
    setExportZipStream (new ZipOutputStream (new FileOutputStream (getExportFileName ())));
    CmsXmlSaxWriter saxHandler = new CmsXmlSaxWriter (new StringWriter (4096), OpenCms.getSystemInfo ().getDefaultEncoding ());
    saxHandler.setEscapeXml (true);
    saxHandler.setEscapeUnknownChars (true);
    setSaxWriter (new SAXWriter (saxHandler, saxHandler));
    Document doc = DocumentHelper.createDocument ();
    saxHandler.startDocument ();
    if (m_parameters.isXmlValidation ()) {
        saxHandler.startDTD (getExportNodeName (), null, CmsConfigurationManager.DEFAULT_DTD_PREFIX + CmsImportVersion7.DTD_FILENAME);
        saxHandler.endDTD ();
    }
    String exportNodeName = getExportNodeName ();
    Element exportNode = doc.addElement (exportNodeName);
    getSaxWriter ().writeOpen (exportNode);
    Element info = exportNode.addElement (CmsImportExportManager.N_INFO);
    info.addElement (CmsImportExportManager.N_CREATOR).addText (getCms ().getRequestContext ().currentUser ().getName ());
    info.addElement (CmsImportExportManager.N_OC_VERSION).addText (OpenCms.getSystemInfo ().getVersionNumber ());
    info.addElement (CmsImportExportManager.N_DATE).addText (CmsDateUtil.getHeaderDate (System.currentTimeMillis ()));
    info.addElement (CmsImportExportManager.N_INFO_PROJECT).addText (getCms ().getRequestContext ().currentProject ().getName ());
    info.addElement (CmsImportExportManager.N_VERSION).addText (CmsImportExportManager.EXPORT_VERSION);
    digestElement (exportNode, info);
    return exportNode;
}


public static File [] getSelectedFiles (JFileChooser jfilechooser) {
    Container container = (Container) jfilechooser.getComponent (3);
    JList jlist = null;
    Container container1;
    for (; container != null; container = container1) {
        container1 = (Container) container.getComponent (0);
        if (! (container1 instanceof JList)) {
            continue;
        }
        jlist = (JList) container1;
        break;
    }
    Object aobj [] = jlist.getSelectedValues ();
    File afile [] = new File [aobj.length];
    for (int i = 0; i < aobj.length; i ++) {
        if (aobj [i] instanceof File) {
            afile [i] = (File) aobj [i];
        }
    }
    return afile;
}


-----Function Pair=249=-----==

public Archive (String filename, boolean readonly) throws IOException {
    this.readOnly = readonly;
    File f = new File (filename);
    if (! f.exists ()) {
        if (readonly) {
            throw new IOException ("No such file " + filename);
        }
        file = new RandomAccessFile (filename, "rw");
        initializeFile ();
    }
    else if (readonly && usemap) {
        FileInputStream fs = new FileInputStream (f);
        FileChannel fc = fs.getChannel ();
        bb = fc.map (FileChannel.MapMode.READ_ONLY, 0, f.length ());
    }
    else {
        file = new RandomAccessFile (filename, readonly ? "r" : "rw");
    }
    if (readOnly && usemap) {
        readHeaderViaMap ();
    }
    else {
        readHeader ();
    }
    if (! readOnly) {
        readFreeList ();
    }
    if (readOnly && usemap) {
        readDirectoryViaMap ();
    }
    else {
        readDirectory ();
    }
}


public void write (String name, Scribable object, boolean compress) throws IOException, UnscribableNodeEncountered {
    DirEntry d = index.get (name);
    if (d != null) {
        Block b = new Block ();
        b.length = d.length;
        b.loc = d.pos;
        free.add (b);
    }
    else {
        d = new DirEntry ();
        d.name = name;
        index.put (name, d);
    }
    d.compressed = compress;
    ZipOutputStream zip = null;
    ByteArrayOutputStream bout = new ByteArrayOutputStream (10000);
    OutputStream out = bout;
    if (compress) {
        zip = new ZipOutputStream (out);
        zip.putNextEntry (new ZipEntry ("object"));
        out = zip;
    }
    ScribeOutputStream sout = new ScribeOutputStream (out);
    if (object == null) {
        System.out.println ("Object is null");
    }
    sout.writeScribable (object);
    if (compress) {
        zip.closeEntry ();
    }
    out.close ();
    byte [] data = bout.toByteArray ();
    d.pos = allocateSpace (data.length);
    d.length = data.length;
    file.seek (d.pos);
    file.write (data, 0, data.length);
    X3DLog.debug ("Wrote out ", d.length, " bytes for ", name);
}


-----Function Pair=250=-----==

public void run () {
    try {
        final Emulator emu = parent.step1.emu;
        final Hardware [] hardwares = parent.step2.hardwares;
        final ImageFormat [] formats = parent.step2.formats;
        java.util.List < File > filesToZip = new ArrayList < File > ();
        readRecursive (emu.folder, filesToZip);
        createZipFile (filesToZip, emu._package, emu.folder.getAbsolutePath ());
        execute (DBUtil.DB.EA, "successfully inserted " + emu.name, "could not insert " + emu.name, "INSERT INTO emulatorarchive.emulators " + "(emulator_id, name, version, exec_type, exec_name, description, language_id, package_name, package_type, package_version, package, user_instructions) " + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, FILE_READ(?), ?)", emu.emulator_id, emu.name, emu.version, emu.exec_type, emu.exec_name, emu.description, emu.language_id, emu.package_name, emu.package_type, emu.package_version, emu._package, emu.user_instructions);
        for (Hardware hardware : hardwares) {
            execute (DBUtil.DB.EA, "successfully associated the emulator with the hardware", "could not associate the emulator with the hardware", "INSERT INTO emulatorarchive.emus_hardware (emulator_id, hardware_id) VALUES(?, ?)", emu.emulator_id, hardware.hardware_id);
        }
        for (ImageFormat format : formats) {
            execute (DBUtil.DB.EA, "successfully associated the emulator with the disk image format", "could not associate the emulator with the disk image format", "INSERT INTO emulatorarchive.emus_imageformats (emulator_id, imageformat_id) VALUES(?, ?)", emu.emulator_id, format.imageformat_id);
        }
        execute (DBUtil.DB.CEF, "successfully added the emulator to the whitelist", "could not add the emulator to the whitelist", "INSERT INTO engine.emulator_whitelist (emulator_id, emulator_descr) VALUES(?, ?)", emu.emulator_id, emu.description);
        parent.log (RBLanguages.get ("committed_changes") + "!");
        if (! (new File (emu._package)).delete ()) {
            logger.warn ("Could not delete emulator zip-file from Java temp folder: " + emu._package);
        }
        parent.dispose ();
    } catch (Exception ex) {
        parent.log (RBLanguages.get ("error") + ": " + ex.getMessage ());
        confirm.setEnabled (false);
    }
    parent.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    parent.setEnabled (true);
    parent.setCursor (new Cursor (Cursor.DEFAULT_CURSOR));
}


private Map getEVSchedules (Collection taskListNames) {
    Map schedules = new TreeMap ();
    for (Iterator iter = taskListNames.iterator (); iter.hasNext ();) {
        boolean merged = false;
        String taskScheduleName = (String) iter.next ();
        if (taskScheduleName.startsWith (MERGED_PREFIX)) {
            merged = true;
            taskScheduleName = taskScheduleName.substring (MERGED_PREFIX.length ());
        }
        EVTaskList tl = EVTaskList.openExisting (taskScheduleName, ctx.getData (), ctx.getHierarchy (), ctx.getCache (), false);
        if (tl == null) continue;
        tl.setDependencyCalculator (new EVDependencyCalculator (ctx.getData (), ctx.getHierarchy (), ctx.getCache ()));
        tl.recalc ();
        if (merged) tl = new EVTaskListMerged (tl, false, false, null);
        schedules.put (taskScheduleName, tl);
    }
    return schedules;
}


-----Function Pair=251=-----=1=

public static byte [] getBytes (final Serializable o, final boolean zip) throws IOException {
    if (o == null) {
        return IOUtils.NBYTE;
    }
    final ByteArrayOutputStream bos = new ByteArrayOutputStream ();
    final ObjectOutputStream oos = new ObjectOutputStream (bos);
    oos.writeObject (o);
    if (zip) {
        final ByteArrayOutputStream ret = new ByteArrayOutputStream ();
        final ZipOutputStream zos = new ZipOutputStream (ret);
        zos.putNextEntry (new ZipEntry ("obj"));
        zos.write (bos.toByteArray ());
        zos.close ();
        return ret.toByteArray ();
    }
    return bos.toByteArray ();
}


public void testGetManifest () throws Exception {
    Support_Resources.copyFile (resources, null, JAR1);
    JarFile jarFile = new JarFile (new File (resources, JAR1));
    InputStream is = jarFile.getInputStream (jarFile.getEntry (JAR1_ENTRY1));
    assertTrue (is.available () > 0);
    assertNotNull ("Error--Manifest not returned", jarFile.getManifest ());
    jarFile.close ();
    Support_Resources.copyFile (resources, null, JAR2);
    jarFile = new JarFile (new File (resources, JAR2));
    assertNull ("Error--should have returned null", jarFile.getManifest ());
    jarFile.close ();
    Support_Resources.copyFile (resources, null, JAR3);
    jarFile = new JarFile (new File (resources, JAR3));
    assertNotNull ("Should find manifest without verifying", jarFile.getManifest ());
    jarFile.close ();
    Manifest manifest = new Manifest ();
    Attributes attributes = manifest.getMainAttributes ();
    attributes.put (new Attributes.Name ("Manifest-Version"), "1.0");
    ByteArrayOutputStream manOut = new ByteArrayOutputStream ();
    manifest.write (manOut);
    byte [] manBytes = manOut.toByteArray ();
    File file = new File (Support_PlatformFile.getNewPlatformFile ("hyts_manifest1", ".jar"));
    JarOutputStream jarOut = new JarOutputStream (new FileOutputStream (file.getAbsolutePath ()));
    ZipEntry entry = new ZipEntry ("META-INF/");
    entry.setSize (0);
    jarOut.putNextEntry (entry);
    entry = new ZipEntry (JarFile.MANIFEST_NAME);
    entry.setSize (manBytes.length);
    jarOut.putNextEntry (entry);
    jarOut.write (manBytes);
    entry = new ZipEntry ("myfile");
    entry.setSize (1);
    jarOut.putNextEntry (entry);
    jarOut.write (65);
    jarOut.close ();
    JarFile jar = new JarFile (file.getAbsolutePath (), false);
    assertNotNull ("Should find manifest without verifying", jar.getManifest ());
    jar.close ();
    file.delete ();
    try {
        Support_Resources.copyFile (resources, null, JAR2);
        JarFile jF = new JarFile (new File (resources, JAR2));
        jF.close ();
        jF.getManifest ();
        fail ("IllegalStateException expected");
    } catch (IllegalStateException ise) {
    }
}


-----Function Pair=252=-----==

public void testJarFileModifiedClass () throws IOException {
    String modifiedJarName = "Modified_Class.jar";
    Support_Resources.copyFile (resources, null, modifiedJarName);
    JarFile jarFile = new JarFile (new File (resources, modifiedJarName), true);
    Enumeration < JarEntry > entries = jarFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry zipEntry = entries.nextElement ();
        jarFile.getInputStream (zipEntry);
    }
    ZipEntry zipEntry = jarFile.getEntry ("Test.class");
    InputStream in = jarFile.getInputStream (zipEntry);
    byte [] buffer = new byte [1024];
    try {
        while (in.available () > 0) {
            in.read (buffer);
        }
        fail ("SecurityException expected");
    } catch (SecurityException e) {
    }
}


public void endAction (Missal missal) {
    super.endAction (missal);
    Queue q = new Queue ();
    mdeacon.setIndex (0);
    q.name = mdeacon.incarnate ("", "", null, null);
    owner.getQueues ().put (q.name, q);
    try {
        mdeacon.setIndex (1);
        String ns = mdeacon.incarnate ("", "", null, null).trim ();
        int i = ns.indexOf (' ');
        String s = ns.substring (0, i);
        q.min_node = Integer.valueOf (s).intValue ();
        s = ns.substring (i).trim ();
        q.max_node = Integer.valueOf (s).intValue ();
        mdeacon.setIndex (2);
        String ts = mdeacon.incarnate ("", "", null, null).trim ();
        i = ts.indexOf (' ');
        s = ts.substring (0, i);
        q.min_time = Integer.valueOf (s).intValue ();
        s = ts.substring (i).trim ();
        q.max_time = Integer.valueOf (s).intValue ();
        mdeacon.setIndex (3);
        String ms = mdeacon.incarnate ("", "", null, null).trim ();
        i = ms.indexOf (' ');
        s = ms.substring (0, i);
        q.min_mory = Integer.valueOf (s).intValue ();
        s = ms.substring (i).trim ();
        q.max_mory = Integer.valueOf (s).intValue ();
        mdeacon.setIndex (4);
        String ps = mdeacon.incarnate ("", "", null, null).trim ();
        if (ps.length () > 0) {
            i = ps.indexOf (' ');
            s = ps.substring (0, i);
            q.min_proc = Integer.valueOf (s).intValue ();
            s = ps.substring (i).trim ();
            q.max_proc = Integer.valueOf (s).intValue ();
        }
    } catch (Exception ex) {
        logger.severe ("Error decoding Queue resource descriptions " + q.name, ex);
        NJSGlobals.goToLimbo ();
    }
}


-----Function Pair=253=-----==

private String jarDiagnostics (Throwable throwable, File [] files) throws IOException {
    File home = new File (System.getProperty ("user.home"));
    File jar_file = File.createTempFile ("nuages-diagnostic.", ".jar", home);
    FileOutputStream fos = new FileOutputStream (jar_file);
    JarOutputStream jos = new JarOutputStream (fos);
    ZipEntry ze = new ZipEntry ("Exception");
    jos.putNextEntry (ze);
    PrintStream ps = new PrintStream (jos);
    throwable.printStackTrace (ps);
    for (File file : files) if ((file != null) && file.exists ()) {
        ze = new ZipEntry (file.getName ());
        jos.putNextEntry (ze);
        byte [] buffer = new byte [65536];
        FileInputStream fis = new FileInputStream (file);
        int len;
        while ((len = fis.read (buffer)) > 0) jos.write (buffer, 0, len);
        fis.close ();
    }
    jos.close ();
    return jar_file.getPath ();
}


private byte [] addTime (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null) {
        Calendar cal = Calendar.getInstance ();
        cal.setTime (item.getStart ());
        int startBuff = 0;
        int endBuff = 0;
        try {
            startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
            endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
        } catch (Exception e) {
        }
        if (item.getState () != ScheduleItem.RUNNING) {
            System.out.println ("Not RUNNING");
            cal.add (Calendar.MINUTE, (startBuff * - 1));
            item.setDuration (item.getDuration () + startBuff + endBuff);
            item.setStart (cal);
        }
        else {
            System.out.println ("RUNNING");
            item.setDuration (item.getDuration () + endBuff);
        }
        store.saveSchedule (null);
    }
    StringBuffer out = new StringBuffer ();
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=254=-----==

private String getRemotePath (String userID, String workflowID, String jobID, String portID, String io) {
    try {
        Vector < JobPropertyBean > jobs = getConfigData (userID, workflowID);
        for (JobPropertyBean j : jobs) {
            if (j.getName ().equals (new String (jobID))) {
                Vector < PortDataBean > ports = null;
                if (io.equals ("input")) {
                    ports = j.getInputs ();
                }
                else {
                    ports = j.getOutputs ();
                }
                for (PortDataBean p : ports) {
                    if (p.getSeq () == Long.parseLong (portID)) {
                        return (String) p.getData ().get ("remote");
                    }
                }
            }
        }
        this.saveConfigData (userID, workflowID, jobs);
    } catch (Exception e) {
        throw new ASMException ("Getting remote file path on " + workflowID + " " + jobID + " " + portID + " " + "failed.");
    }
    return null;
}


public void paint (Graphics g) {
    m_offscreen = createImage (getSize ().width, getSize ().height);
    m_offgraphics = m_offscreen.getGraphics ();
    m_offgraphics.setColor (getColor ("bgColor"));
    m_offgraphics.fillRect (0, 0, getSize ().width, getSize ().height);
    m_offgraphics.setColor (getColor ("outerBorderRightBottom"));
    m_offgraphics.drawLine (0, getSize ().height - 1, getSize ().width - 1, getSize ().height - 1);
    m_offgraphics.drawLine (getSize ().width - 1, 0, getSize ().width - 1, getSize ().height - 1);
    m_offgraphics.setColor (getColor ("outerBorderLeftTop"));
    m_offgraphics.drawLine (0, 0, getSize ().width - 1, 0);
    m_offgraphics.drawLine (0, 0, 0, getSize ().height - 1);
    m_offgraphics.setColor (getColor ("innerBorderRightBottom"));
    m_offgraphics.drawLine (1, getSize ().height - 2, getSize ().width - 2, getSize ().height - 2);
    m_offgraphics.drawLine (getSize ().width - 2, 1, getSize ().width - 2, getSize ().height - 2);
    m_offgraphics.setColor (getColor ("innerBorderLeftTop"));
    m_offgraphics.drawLine (1, 1, getSize ().width - 2, 1);
    m_offgraphics.drawLine (1, 1, 1, getSize ().height - 2);
    m_offgraphics.setColor (getColor ("bgHeadline"));
    m_offgraphics.fillRect (4, 4, getSize ().width - 5, 18);
    m_offgraphics.setColor (getColor ("innerBorderRightBottom"));
    m_offgraphics.drawLine (10, getSize ().height - 11, getSize ().width - 11, getSize ().height - 11);
    m_offgraphics.drawLine (getSize ().width - 11, 25, getSize ().width - 11, getSize ().height - 11);
    m_offgraphics.setColor (getColor ("innerBorderLeftTop"));
    m_offgraphics.drawLine (10, 25, getSize ().width - 11, 25);
    m_offgraphics.drawLine (10, 25, 10, getSize ().height - 11);
    int cx = 10;
    int cy = 17;
    m_offgraphics.setFont (m_font);
    m_offgraphics.setColor (getColor ("colorHeadline"));
    m_offgraphics.drawString (m_action, cx, cy);
    m_offgraphics.setColor (getColor ("colorText"));
    if (m_outputMode >= 3) {
        cx = Math.max ((getSize ().width - m_metrics.stringWidth (m_message)) / 2, 0);
    }
    else {
        cx = 25;
    }
    cy = 41;
    m_offgraphics.drawString (m_message, cx, cy);
    if (m_outputMode == 2) {
        float bar = new Float (m_step).floatValue () / new Float (m_resources).floatValue ();
        String barText = "(" + m_step + " / " + m_resources + ")";
        m_offgraphics.drawRect (25, 50, 450, 20);
        m_offgraphics.setColor (Color.white);
        m_offgraphics.fillRect (26, 51, 449, 19);
        m_offgraphics.setColor (getColor ("progessBar"));
        m_offgraphics.fillRect (26, 51, new Float (bar * 449).intValue (), 19);
        int progressWith = m_metrics.stringWidth (barText);
        cx = Math.max ((getSize ().width - progressWith) / 2, 0);
        cy = 64;
        m_offgraphics.setColor (Color.black);
        m_offgraphics.drawString (barText, cx, cy);
    }
    if (m_outputMode == 3) {
        m_offgraphics.drawImage (m_floater, m_floaterPos, 57, this);
        m_offgraphics.drawImage (m_source, 30, 47, this);
        m_offgraphics.drawImage (m_target, 440, 47, this);
    }
    g.drawImage (m_offscreen, 0, 0, null);
}


-----Function Pair=255=-----==

public static PositionScoreTextData merge (ArrayList < PositionScoreTextData > pdAL) {
    PositionScoreTextData [] pdArray = new PositionScoreTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionScoreTexts.length;
    PositionScoreText [] concatinate = new PositionScoreText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionScoreText [] slice = pdArray [i].sortedPositionScoreTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionScoreTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionScoreTextData (concatinate, sliceInfo);
}


public static void writeZip (File targetFile, File baseDir, List files, StreamAndEntryProvider pr, ProcessIndicator pi) throws IOException {
    ZipOutputStream jos = pr.createStream (new FileOutputStream (targetFile), baseDir, files);
    String baseDirPath = baseDir.getCanonicalPath ();
    for (Iterator it = files.iterator (); it.hasNext ();) {
        File classFile = (File) it.next ();
        if (! classFile.exists ()) {
            throw new FileNotFoundException (classFile.getAbsolutePath ());
        }
        String fullFilePath = classFile.getCanonicalPath ();
        if (! fullFilePath.startsWith (baseDirPath)) {
            throw new IllegalArgumentException ("Expected file '" + fullFilePath + "' to be " + "located under " + baseDir.getAbsolutePath ());
        }
        String tmpFileName = fullFilePath.substring (baseDirPath.length () + 1);
        String fileName = tmpFileName.replace (File.separatorChar, '/');
        if (classFile.isFile ()) {
            ZipEntry entry = pr.createEntry (fileName, classFile);
            entry.setTime (classFile.lastModified ());
            jos.putNextEntry (entry);
            pi.startFile (targetFile, entry, classFile);
            int notificationGranularity = pi.getNotificationGranularity ();
            if (notificationGranularity < 1 || notificationGranularity > MAX_BUFFER_SIZE) notificationGranularity = DEFAULT_BUFFER_SIZE;
            FileInputStream fis = new FileInputStream (classFile);
            byte [] buffer = new byte [notificationGranularity];
            int i = 0;
            while (true) {
                int len = fis.read (buffer);
                if (len < 1) break;
                jos.write (buffer, 0, len);
                pi.progress (targetFile, entry, classFile, len);
            }
            fis.close ();
            jos.closeEntry ();
            pi.endFile (targetFile, entry, classFile);
        }
        else {
            if (! classFile.isDirectory ()) {
                throw new IOException ("Ups. File-Object that is neither file nor directory? " + classFile.getAbsolutePath ());
            }
            ZipEntry entry = pr.createEntry (fileName + "/", classFile);
            jos.putNextEntry (entry);
            pi.startDirectory (targetFile, entry, classFile);
            pi.endDirectory (targetFile, entry, classFile);
            jos.closeEntry ();
        }
    }
    pi.endZipFile (targetFile, baseDir, files);
    jos.close ();
}


-----Function Pair=256=-----==

public static void createGZipFile (File gzipFile, File file) throws IOException {
    GZIPOutputStream out = new GZIPOutputStream (new FileOutputStream (gzipFile));
    if (! file.canRead ()) {
        System.err.println ("ZipBuilder (GZip): Could not read " + file.getAbsolutePath ());
        return;
    }
    String inFilename = "infilename";
    FileInputStream in = new FileInputStream (inFilename);
    byte [] buf = new byte [BUFFER_SIZE];
    int len;
    while ((len = in.read (buf)) > 0) {
        out.write (buf, 0, len);
    }
    in.close ();
    out.finish ();
    out.close ();
}


private CoreProperties parseCorePropertiesFile () throws OpenXML4JException {
    CoreProperties coreProps = new CoreProperties ();
    corePropertiesZipEntry = getCorePropertiesZipEntry ();
    InputStream inStream = null;
    try {
        inStream = container.getArchive ().getInputStream (corePropertiesZipEntry);
    } catch (IOException e) {
        throw new OpenXML4JException ("cannot read properties file" + corePropertiesZipEntry.getName ());
    }
    if (logger.isDebugEnabled ()) {
        logger.debug ("reading properties from:" + corePropertiesZipEntry.getName ());
    }
    try {
        SAXReader xmlReader = new SAXReader ();
        xmlDoc = xmlReader.read (inStream);
        loadCreator (coreProps);
        loadTitle (coreProps);
        loadSubject (coreProps);
        loadKeyword (coreProps);
        loadDescription (coreProps);
        loadLastModificationPerson (coreProps);
        loadRevision (coreProps);
        loadCreated (coreProps);
        loadModified (coreProps);
    } catch (DocumentException e) {
        logger.error (e);
        return null;
    }
    return coreProps;
}


-----Function Pair=257=-----==

public static void zipFilesTo (Vector < File > fileVector, String baseDir, File destFile) {
    FileOutputStream ops = null;
    ZipOutputStream zos = null;
    int basedirlen = baseDir.length ();
    if (! baseDir.endsWith (File.separator)) basedirlen ++;
    try {
        ops = new FileOutputStream (destFile);
        zos = new ZipOutputStream (ops);
        Iterator < File > iter = fileVector.iterator ();
        while (iter.hasNext ()) {
            File file = iter.next ();
            FileInputStream fis = null;
            try {
                fis = new FileInputStream (file);
                String name = file.getPath ().substring (basedirlen);
                name = name.replace ('\\', '/');
                ZipEntry zi = new ZipEntry (name);
                zos.putNextEntry (zi);
                copystream (fis, zos);
                zos.closeEntry ();
            } catch (FileNotFoundException e) {
                e.printStackTrace ();
            } catch (IOException e) {
                e.printStackTrace ();
            } finally {
                try {
                    if (fis != null) fis.close ();
                } catch (Exception e) {
                }
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (zos != null) zos.close ();
            else if (ops != null) ops.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


public InputStream getFileAsInputStream (String path) throws IOException {
    File explodedFile = getExplodedFile (path);
    if ((! file.exists () && ! tmpFile.exists () && ! explodedFile.exists ()) || removedFileSet.contains (path)) throw new FileNotFoundException (path);
    if (explodedFile.exists ()) return FileUtil.getFileAsInputStream (explodedFile);
    ZipEntry entry = new ZipEntry (path);
    ZipFile zipFile = getZipFile ();
    InputStream in = null;
    try {
        in = zipFile.getInputStream (entry);
        if (in != null) {
            String type = FileUtil.getContentType (in);
            if (log.isDebugEnabled () && type != null) log.debug ("FileUtil.getContentType() returned " + type);
            return in;
        }
    } catch (Exception ex) {
    }
    throw new FileNotFoundException (path);
}


-----Function Pair=258=-----==

private void DeleteNode (NpsContext ctxt, Node node) throws NpsException {
    if (node.HasChilds ()) {
        Iterator childs = node.GetChilds ();
        while (childs.hasNext ()) {
            Node child_node = (Node) childs.next ();
            DeleteNode (ctxt, child_node);
        }
    }
    Topic t = (Topic) node.GetValue ();
    if (t.GetTable () != null && t.GetTable ().length () > 0) {
        EventSubscriber.GetSubscriber ().RemoveListener (InsertEventListener.class, t);
        EventSubscriber.GetSubscriber ().RemoveListener (UpdateEventListener.class, t);
        EventSubscriber.GetSubscriber ().RemoveListener (DeleteEventListener.class, t);
        EventSubscriber.GetSubscriber ().RemoveListener (Ready2PublishEventListener.class, t);
        EventSubscriber.GetSubscriber ().RemoveListener (PublishEventListener.class, t);
        EventSubscriber.GetSubscriber ().RemoveListener (CancelEventListener.class, t);
    }
    TriggerManager manager = TriggerManager.LoadTriggers (ctxt);
    manager.DeleteTriggersInTopic (ctxt, t);
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from article Where topic=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        sql = "delete from article_topics where topid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        sql = "delete from topic_pts where topid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        sql = "delete from topic_owner where topid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        sql = "delete from topic_vars where topid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        sql = "delete from topic where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
    } catch (Exception e) {
        ctxt.Rollback ();
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


private void loadProject () {
    JFileChooser fc = new JFileChooser ();
    int returnVal = fc.showOpenDialog (this);
    String path = "c:\\";
    String fileName = "TestSave";
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        path = fc.getSelectedFile ().getParent () + "\\";
        fileName = fc.getSelectedFile ().getName ();
        fileName = fileName.substring (0, fileName.lastIndexOf ("."));
    }
    else {
        return;
    }
    try {
        int BUFFER = 2048;
        String inFileName = path + fileName + ".zip";
        String destinationDirectory = path;
        File sourceZipFile = new File (inFileName);
        File unzipDestinationDirectory = new File (destinationDirectory);
        ZipFile zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
        Enumeration zipFileEntries = zipFile.entries ();
        while (zipFileEntries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) zipFileEntries.nextElement ();
            String currentEntry = entry.getName ();
            File destFile = new File (unzipDestinationDirectory, currentEntry);
            File destinationParent = destFile.getParentFile ();
            destinationParent.mkdirs ();
            if (! entry.isDirectory ()) {
                BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (entry));
                int currentByte;
                byte data [] = new byte [BUFFER];
                FileOutputStream fos = new FileOutputStream (destFile);
                BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
                while ((currentByte = is.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, currentByte);
                }
                dest.flush ();
                dest.close ();
                is.close ();
            }
        }
        zipFile.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    try {
        File originalFile = new File (path + fileName + "-original.jpg");
        File mapFile = new File (path + fileName + "-Map.jpg");
        File markedFile = new File (path + fileName + "-Marked.jpg");
        colorizationPanel.setColorMap (ImageIO.read (mapFile));
        workingFrame.setImage (ImageIO.read (originalFile));
        colorizationPanel.colorizeNextFrame (workingFrame);
        originalFile.delete ();
        mapFile.delete ();
        markedFile.delete ();
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=259=-----==

public static int unzipFile (File file_input, File dir_output) {
    ZipInputStream zip_in_stream;
    try {
        FileInputStream in = new FileInputStream (file_input);
        BufferedInputStream source = new BufferedInputStream (in);
        zip_in_stream = new ZipInputStream (source);
    } catch (IOException e) {
        return STATUS_IN_FAIL;
    }
    byte [] input_buffer = new byte [BUF_SIZE];
    int len = 0;
    do {
        try {
            ZipEntry zip_entry = zip_in_stream.getNextEntry ();
            if (zip_entry == null) break;
            File output_file = new File (dir_output, zip_entry.getName ());
            FileOutputStream out = new FileOutputStream (output_file);
            BufferedOutputStream destination = new BufferedOutputStream (out, BUF_SIZE);
            while ((len = zip_in_stream.read (input_buffer, 0, BUF_SIZE)) != - 1) destination.write (input_buffer, 0, len);
            destination.flush ();
            out.close ();
        } catch (IOException e) {
            return STATUS_GUNZIP_FAIL;
        }
    }
    while (true);
    try {
        zip_in_stream.close ();
    } catch (IOException e) {
    }
    return STATUS_OK;
}


protected EObject getEObjectByID (String id) {
    Map < String, EObject > map = getIntrinsicIDToEObjectMap ();
    if (map != null) {
        EObject eObject = map.get (id);
        if (eObject != null) {
            return eObject;
        }
    }
    EObject result = null;
    for (TreeIterator < EObject > i = getAllProperContents (getContents ()); i.hasNext ();) {
        EObject eObject = i.next ();
        String eObjectId = EcoreUtil.getID (eObject);
        if (eObjectId != null) {
            if (map != null) {
                map.put (eObjectId, eObject);
            }
            if (eObjectId.equals (id)) {
                result = eObject;
                if (map == null) {
                    break;
                }
            }
        }
    }
    return result;
}


-----Function Pair=260=-----==

private void writeManifest (ZipOutputStream zipOut, boolean includeTaskLists) throws IOException {
    zipOut.putNextEntry (new ZipEntry (MANIFEST_FILE_NAME));
    XmlSerializer xml = null;
    try {
        XmlPullParserFactory factory = XmlPullParserFactory.newInstance ();
        xml = factory.newSerializer ();
    } catch (XmlPullParserException xppe) {
        throw new RuntimeException ("Couldn't obtain xml serializer", xppe);
    }
    xml.setOutput (zipOut, ENCODING);
    xml.startDocument (ENCODING, Boolean.TRUE);
    xml.ignorableWhitespace (NEWLINE + NEWLINE);
    xml.startTag (null, ARCHIVE_ELEM);
    xml.attribute (null, TYPE_ATTR, FILE_TYPE_ARCHIVE);
    xml.ignorableWhitespace (NEWLINE);
    writeManifestMetaData (xml);
    writeManifestFileEntry (xml, DATA_FILE_NAME, FILE_TYPE_METRICS, "1");
    writeManifestFileEntry (xml, DEFECT_FILE_NAME, FILE_TYPE_DEFECTS, "1");
    writeManifestFileEntry (xml, TIME_FILE_NAME, FILE_TYPE_TIME_LOG, "1");
    if (includeTaskLists) writeManifestFileEntry (xml, EV_FILE_NAME, FILE_TYPE_EARNED_VALUE, "1");
    if (additionalEntries != null) for (Iterator i = additionalEntries.iterator (); i.hasNext ();) {
        ExportFileEntry file = (ExportFileEntry) i.next ();
        writeManifestFileEntry (xml, file.getFilename (), file.getType (), file.getVersion ());
    }
    xml.endTag (null, ARCHIVE_ELEM);
    xml.ignorableWhitespace (NEWLINE);
    xml.endDocument ();
    zipOut.closeEntry ();
}


File createJar (String name, String...entries) throws IOException {
    File jar = new File (name);
    OutputStream out = new FileOutputStream (jar);
    try {
        JarOutputStream jos = new JarOutputStream (out);
        for (String e : entries) {
            jos.putNextEntry (new ZipEntry (e));
            jos.write (e.getBytes ());
        }
        jos.close ();
    } finally {
        out.close ();
    }
    return jar;
}


-----Function Pair=261=-----==

public void init (ServletConfig servletConfig, BlojsomConfiguration blojsomConfiguration) throws BlojsomPluginException {
    super.init (servletConfig, blojsomConfiguration);
    String fetcherClassName = blojsomConfiguration.getFetcherClass ();
    try {
        Class fetcherClass = Class.forName (fetcherClassName);
        _fetcher = (BlojsomFetcher) fetcherClass.newInstance ();
        _fetcher.init (servletConfig, blojsomConfiguration);
        _logger.info ("Added blojsom fetcher: " + fetcherClassName);
    } catch (ClassNotFoundException e) {
        _logger.error (e);
        throw new BlojsomPluginException (e);
    } catch (InstantiationException e) {
        _logger.error (e);
        throw new BlojsomPluginException (e);
    } catch (IllegalAccessException e) {
        _logger.error (e);
        throw new BlojsomPluginException (e);
    } catch (BlojsomFetcherException e) {
        _logger.error (e);
        throw new BlojsomPluginException (e);
    }
    _logger.debug ("Initialized export entries plugin");
}


private void create (String path, String entry) {
    BufferedWriter bw = null;
    try {
        bw = new BufferedWriter (new FileWriter (new File (path)));
        bw.write (entry);
        bw.flush ();
    } catch (Exception e) {
        Log.writeErrorLog (WriteFile.class, e.getMessage (), e);
    } finally {
        if (bw != null) {
            try {
                bw.close ();
            } catch (Exception e) {
                Log.writeErrorLog (WriteFile.class, e.getMessage (), e);
            }
        }
    }
}


-----Function Pair=262=-----==

protected boolean isBaseNormal (String word) {
    try {
        WordEntry [] entry = getBases (word);
        if (entry.length == 0) {
            return false;
        }
        for (int i = 0; i < entry.length; i ++) {
            if (entry [i].getForm () != WordEntry.NORMAL_FORM) {
                return false;
            }
        }
    } catch (MatchPackException mpe) {
        return false;
    }
    return true;
}


protected synchronized void flush () throws IOException {
    flushing = true;
    try {
        if (needsFlush) {
            needsFlush = false;
            ByteArrayOutputStream bos = new ByteArrayOutputStream ();
            ZipOutputStream zos = new ZipOutputStream (bos);
            if (zipFile != null) {
                for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
                    ZipEntry zipEntry = (ZipEntry) (e.nextElement ());
                    JarFile jarFile = (JarFile) (jarFileTable.get (zipEntry.getName ()));
                    if (jarFile == null) writeZipEntry (zos, zipEntry, zipFile.getInputStream (zipEntry));
                }
            }
            for (Enumeration e = jarFileTable.keys (); e.hasMoreElements ();) {
                String name = (String) (e.nextElement ());
                JarFile jarFile = (JarFile) (jarFileTable.get (name));
                if (jarFile.exists () && ! jarFile.isDirectory ()) {
                    jarFile.flush ();
                    writeZipEntry (zos, jarFile.getZipEntry (), jarFile.getInputStream ());
                }
            }
            if (zipFile != null) zipFile.close ();
            zos.flush ();
            zos.close ();
            file.delete ();
            file.createNewFile ();
            FileOutputStream fos = new FileOutputStream (file);
            fos.write (bos.toByteArray ());
            fos.flush ();
            fos.close ();
            zipFile = new ZipFile (file, ZipFile.OPEN_READ);
        }
    } finally {
        flushing = false;
    }
}


-----Function Pair=263=-----=1=

public static void createZipFile (File zipFile, Collection includeFiles, final boolean verbose) throws IOException {
    if (verbose) {
        System.out.println ("ZIP: " + zipFile.getAbsolutePath ());
    }
    byte [] buf = new byte [BUFFER_SIZE];
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    for (Iterator iterator = includeFiles.iterator (); iterator.hasNext ();) {
        File entryFile = (File) iterator.next ();
        if (verbose) {
            System.out.println ("Adding: " + entryFile.getAbsolutePath ());
        }
        if (! entryFile.canRead ()) {
            System.err.println ("ZipBuilder: Could not read " + entryFile.getAbsolutePath ());
            continue;
        }
        FileInputStream in = new FileInputStream (entryFile);
        out.putNextEntry (new ZipEntry (entryFile.getName ()));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
    out.close ();
}


private void exportAllSettings (HTTPurl urlData, OutputStream outStream) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    if (devList.getActiveDeviceCount () > 0) {
        PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "SettingsLoad.html");
        StringBuffer buff = new StringBuffer ();
        buff.append ("<tr><td><img border=0 src='/images/stop.png' align='absmiddle' width='24' height='24'></td><td>Can not save settings while a capture is in progress.</td></tr>");
        template.replaceAll ("$result", buff.toString ());
        outStream.write (template.getPageBytes ());
        return;
    }
    boolean matchList = "true".equalsIgnoreCase (urlData.getParameter ("MatchList"));
    boolean autoAdd = "true".equalsIgnoreCase (urlData.getParameter ("AutoAdd"));
    boolean channelMapping = "true".equalsIgnoreCase (urlData.getParameter ("ChannelMapping"));
    boolean deviceSelection = "true".equalsIgnoreCase (urlData.getParameter ("DeviceSelection"));
    boolean agentMapping = "true".equalsIgnoreCase (urlData.getParameter ("AgentMapping"));
    boolean channels = "true".equalsIgnoreCase (urlData.getParameter ("Channels"));
    boolean tasks = "true".equalsIgnoreCase (urlData.getParameter ("Tasks"));
    boolean systemProp = "true".equalsIgnoreCase (urlData.getParameter ("SystemProp"));
    boolean schedules = "true".equalsIgnoreCase (urlData.getParameter ("Schedules"));
    boolean authSettings = "true".equalsIgnoreCase (urlData.getParameter ("AuthSettings"));
    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream ();
    ZipOutputStream out = new ZipOutputStream (bytesOut);
    out.setComment ("TV Scheduler Pro Settings file (Version: 1.0)");
    if (channels) {
        out.putNextEntry (new ZipEntry ("Channels.xml"));
        StringBuffer channelData = new StringBuffer ();
        store.saveChannels (channelData);
        byte [] channelBytes = channelData.toString ().getBytes ("UTF-8");
        out.write (channelBytes);
        out.closeEntry ();
    }
    if (matchList) {
        out.putNextEntry (new ZipEntry ("MatchList.xml"));
        StringBuffer matchData = new StringBuffer ();
        store.saveMatchList (matchData);
        byte [] matchBytes = matchData.toString ().getBytes ("UTF-8");
        out.write (matchBytes);
        out.closeEntry ();
    }
    if (autoAdd) {
        out.putNextEntry (new ZipEntry ("EpgAutoAdd.xml"));
        StringBuffer addData = new StringBuffer ();
        store.saveEpgAutoList (addData);
        byte [] addBytes = addData.toString ().getBytes ("UTF-8");
        out.write (addBytes);
        out.closeEntry ();
    }
    if (tasks) {
        out.putNextEntry (new ZipEntry ("Tasks.xml"));
        StringBuffer taskData = new StringBuffer ();
        store.saveTaskList (taskData);
        byte [] taskBytes = taskData.toString ().getBytes ("UTF-8");
        out.write (taskBytes);
        out.closeEntry ();
    }
    if (channelMapping) {
        GuideStore guideStore = GuideStore.getInstance ();
        out.putNextEntry (new ZipEntry ("ChannelMap.sof"));
        ByteArrayOutputStream chanMapBytes = new ByteArrayOutputStream ();
        guideStore.saveChannelMap (chanMapBytes);
        out.write (chanMapBytes.toByteArray ());
        out.closeEntry ();
    }
    if (deviceSelection) {
        out.putNextEntry (new ZipEntry ("CaptureDevices.sof"));
        ByteArrayOutputStream deviceBytes = new ByteArrayOutputStream ();
        devList.saveDeviceList (deviceBytes);
        out.write (deviceBytes.toByteArray ());
        out.closeEntry ();
    }
    if (agentMapping) {
        out.putNextEntry (new ZipEntry ("AgentMap.sof"));
        ByteArrayOutputStream agentMapBytes = new ByteArrayOutputStream ();
        store.saveAgentToThemeMap (agentMapBytes);
        out.write (agentMapBytes.toByteArray ());
        out.closeEntry ();
    }
    if (schedules) {
        out.putNextEntry (new ZipEntry ("Times.sof"));
        ByteArrayOutputStream timesBytes = new ByteArrayOutputStream ();
        store.saveSchedule (timesBytes);
        out.write (timesBytes.toByteArray ());
        out.closeEntry ();
    }
    if (systemProp) {
        HashMap < String, String > serverProp = new HashMap < String, String > ();
        serverProp.put ("epg.showunlinked", store.getProperty ("epg.showunlinked"));
        serverProp.put ("path.theme", store.getProperty ("path.theme"));
        serverProp.put ("path.theme.epg", store.getProperty ("path.theme.epg"));
        serverProp.put ("capture.path", store.getProperty ("capture.path"));
        serverProp.put ("capture.averagedatarate", store.getProperty ("capture.averagedatarate"));
        serverProp.put ("capture.autoselectmethod", store.getProperty ("capture.autoselectmethod"));
        serverProp.put ("capture.minspacesoft", store.getProperty ("capture.minspacesoft"));
        serverProp.put ("capture.includecalculatedusage", store.getProperty ("capture.includecalculatedusage"));
        serverProp.put ("capture.deftype", store.getProperty ("capture.deftype"));
        serverProp.put ("capture.filename.patterns", store.getProperty ("capture.filename.patterns"));
        serverProp.put ("capture.path.details", store.getProperty ("capture.path.details"));
        serverProp.put ("capture.capturefailedtimeout", store.getProperty ("capture.capturefailedtimeout"));
        serverProp.put ("schedule.buffer.start", store.getProperty ("schedule.buffer.start"));
        serverProp.put ("schedule.buffer.end", store.getProperty ("schedule.buffer.end"));
        serverProp.put ("schedule.buffer.end.epg", store.getProperty ("schedule.buffer.end.epg"));
        serverProp.put ("schedule.wake.system", store.getProperty ("schedule.wake.system"));
        serverProp.put ("schedule.overlap", store.getProperty ("schedule.overlap"));
        serverProp.put ("sch.autodel.action", store.getProperty ("sch.autodel.action"));
        serverProp.put ("sch.autodel.time", store.getProperty ("sch.autodel.time"));
        serverProp.put ("guide.source.http.pwd", store.getProperty ("guide.source.http.pwd"));
        serverProp.put ("guide.source.xml.channelList", store.getProperty ("guide.source.xml.channelList"));
        serverProp.put ("guide.source.type", store.getProperty ("guide.source.type"));
        serverProp.put ("guide.source.http", store.getProperty ("guide.source.http"));
        serverProp.put ("guide.source.file", store.getProperty ("guide.source.file"));
        serverProp.put ("guide.action.name", store.getProperty ("guide.action.name"));
        serverProp.put ("guide.source.http.usr", store.getProperty ("guide.source.http.usr"));
        serverProp.put ("guide.source.schedule", store.getProperty ("guide.source.schedule"));
        serverProp.put ("guide.warn.overlap", store.getProperty ("guide.warn.overlap"));
        serverProp.put ("proxy.server", store.getProperty ("proxy.server"));
        serverProp.put ("proxy.port", store.getProperty ("proxy.port"));
        serverProp.put ("proxy.server.usr", store.getProperty ("proxy.server.usr"));
        serverProp.put ("proxy.server.pwd", store.getProperty ("proxy.server.pwd"));
        serverProp.put ("email.server", store.getProperty ("email.server"));
        serverProp.put ("email.from.name", store.getProperty ("email.from.name"));
        serverProp.put ("email.to", store.getProperty ("email.to"));
        serverProp.put ("email.from", store.getProperty ("email.from"));
        serverProp.put ("email.send.weeklyreport", store.getProperty ("email.send.weeklyreport"));
        serverProp.put ("email.send.capfinished", store.getProperty ("email.send.capfinished"));
        serverProp.put ("email.send.epgloaded", store.getProperty ("email.send.epgloaded"));
        serverProp.put ("email.send.onwarning", store.getProperty ("email.send.onwarning"));
        serverProp.put ("email.send.freespacelow", store.getProperty ("email.send.freespacelow"));
        serverProp.put ("email.send.serverstarted", store.getProperty ("email.send.serverstarted"));
        serverProp.put ("tasks.deftask", store.getProperty ("tasks.deftask"));
        serverProp.put ("tasks.pretask", store.getProperty ("tasks.pretask"));
        serverProp.put ("tasks.nodataerrortask", store.getProperty ("tasks.nodataerrortask"));
        serverProp.put ("tasks.starterrortask", store.getProperty ("tasks.starterrortask"));
        serverProp.put ("filebrowser.dirsattop", store.getProperty ("filebrowser.dirsattop"));
        serverProp.put ("filebrowser.masks", store.getProperty ("filebrowser.masks"));
        serverProp.put ("server.kbled", store.getProperty ("server.kbled"));
        ByteArrayOutputStream serverpropBytes = new ByteArrayOutputStream ();
        ObjectOutputStream oos = new ObjectOutputStream (serverpropBytes);
        oos.writeObject (serverProp);
        oos.close ();
        out.putNextEntry (new ZipEntry ("ServerProperties.sof"));
        out.write (serverpropBytes.toByteArray ());
        out.closeEntry ();
    }
    if (authSettings) {
        File authFile = new File (store.getProperty ("path.data") + File.separator + "authentication.prop");
        if (authFile.exists ()) {
            out.putNextEntry (new ZipEntry ("authentication.prop"));
            FileInputStream is = new FileInputStream (authFile);
            byte [] buff = new byte [1024];
            int read = is.read (buff);
            while (read != - 1) {
                out.write (buff, 0, read);
                read = is.read (buff);
            }
            out.closeEntry ();
            is.close ();
        }
    }
    out.flush ();
    out.close ();
    StringBuffer header = new StringBuffer ();
    header.append ("HTTP/1.1 200 OK\n");
    header.append ("Content-Type: application/zip\n");
    header.append ("Content-Length: " + bytesOut.size () + "\n");
    header.append ("Content-Disposition: attachment; filename=\"TV Scheduler Pro Settings.zip\"\n");
    DateFormat df = new SimpleDateFormat ("EEE, dd MMM yyyy hh:mm:ss 'GMT'", new Locale ("En", "Us", "Unix"));
    header.append ("Last-Modified: " + df.format (new Date ()) + "\n");
    header.append ("\n");
    outStream.write (header.toString ().getBytes ());
    ByteArrayInputStream zipStream = new ByteArrayInputStream (bytesOut.toByteArray ());
    byte [] bytes = new byte [4096];
    int read = zipStream.read (bytes);
    while (read > - 1) {
        outStream.write (bytes, 0, read);
        outStream.flush ();
        read = zipStream.read (bytes);
    }
}


-----Function Pair=264=-----==

public Packet (byte [] buffer) throws InvalidPacketException {
    ByteArrayInputStream bais = new ByteArrayInputStream (buffer);
    ZipInputStream zis = new ZipInputStream (bais);
    ZipEntry entry;
    try {
        entry = zis.getNextEntry ();
    } catch (IOException e1) {
        throw new InvalidPacketException ("Decompressing failed");
    }
    assert entry.getName () == "data";
    try {
        this.packet = DocumentBuilderFactory.newInstance ().newDocumentBuilder ().parse (zis).getDocumentElement ();
    } catch (Exception e) {
        throw new InvalidPacketException ("Failed to deserialize xml");
    }
}


public static void go (File file) throws Exception {
    try {
        Preferences prefs = Preferences.userNodeForPackage (BackupAction.class);
        FileOutputStream fos = new FileOutputStream (Kit.getDataDir () + Kit.PREFS_FILE);
        prefs.exportSubtree (fos);
        fos.close ();
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    String datadir = Kit.getDataDir ();
    FileOutputStream fos = new FileOutputStream (file);
    SQLCommand.execute ("SHUTDOWN");
    zipDir (datadir, datadir, new ZipOutputStream (fos));
    fos.close ();
}


-----Function Pair=265=-----==

private void update (double loaded, String text) {
    Graphics g2 = getGraphics ();
    String s = text;
    if (backbuffer == null || backbuffer.getWidth (null) != getSize ().width || backbuffer.getHeight (null) != getSize ().height) backbuffer = createImage (getSize ().width, getSize ().height);
    if (backbuffer == null) return;
    Graphics g = backbuffer.getGraphics ();
    g.setColor (loaded < 0 ? Color.red : Color.blue);
    loaded = Math.abs (loaded);
    int w = (int) ((double) getSize ().width * loaded);
    g.fillRect (0, 0, w, getSize ().height);
    g.setColor (Color.darkGray);
    g.fillRect (w, 0, getSize ().width - w, getSize ().height);
    Font f = new Font ("Sans-serif", Font.BOLD, 12);
    FontRenderContext frc = new FontRenderContext (null, true, true);
    LineMetrics lm = f.getLineMetrics (s, frc);
    g.setFont (f);
    int x = (int) ((getSize ().width - f.getStringBounds (s, frc).getWidth ()) / 2);
    int y = (int) (((getSize ().height - lm.getAscent () - lm.getDescent ()) / 2) + lm.getAscent ());
    g.setColor (Color.white);
    g.drawString (s, x, y);
    if (g2 != null) {
        g2.setClip (0, 0, getSize ().width, getSize ().height);
        g2.drawImage (backbuffer, 0, 0, null);
    }
}


private void writeActivityXML (Long orgId) throws Exception {
    SimpleDateFormat sdf = new SimpleDateFormat ("yyyy-MM-dd");
    List < Activity > acts = em.createQuery ("select a from Activity a " + "join fetch a.media " + "join fetch a.type " + "left join fetch a.monitoringLocation " + "left join fetch a.assemblage " + "left join fetch a.samplingCollectionEquipment " + "left join fetch a.mediaSubdivision " + "left join fetch a.horizontalReferenceDatum " + "left join fetch a.horizontalCollectionMethod " + "left join fetch a.relativeDepth " + "left join fetch a.elevation.unit " + "left join fetch a.upperElevation.unit " + "left join fetch a.lowerElevation.unit " + "where a.organization.uid = :uid").setParameter ("uid", orgId).getResultList ();
    for (Iterator < Activity > i = acts.iterator (); i.hasNext ();) {
        Activity a = i.next ();
        if ((a.getWqx20Valid () != null) && (! a.getWqx20Valid ().booleanValue ()) && (param.getExportValidOnly () != null) && (param.getExportValidOnly ().booleanValue ())) continue;
        a.setGetTrueValues (true);
        xml.writeStartElement ("Activity");
        xml.writeStartElement ("ActivityDescription");
        writeFullElement ("ActivityIdentifier", a.getId ());
        writeFullElement ("ActivityTypeCode", a.getType ().getCode ());
        writeFullElement ("ActivityMediaName", a.getMedia ().getName ());
        writeFullElement ("ActivityMediaSubDivisionName", (a.getMediaSubdivision () != null) ? a.getMediaSubdivision ().getName () : null);
        writeFullElement ("ActivityStartDate", sdf.format (a.getStartDate ()));
        writeFullElement ("ActivityEndDate", (a.getEndDate () != null) ? sdf.format (a.getEndDate ()) : null);
        if (a.getRelativeDepth () != null) writeFullElement ("ActivityRelativeDepthName", a.getRelativeDepth ().getName ());
        if (a.getElevation () != null) {
            xml.writeStartElement ("ActivityDepthHeightMeasure");
            writeFullElement ("MeasureValue", a.getElevation ().getValue ());
            if (a.getElevation ().getUnit () != null) writeFullElement ("MeasureUnitCode", a.getElevation ().getUnit ().getCode ());
            xml.writeEndElement ();
        }
        if (a.getUpperElevation () != null) {
            xml.writeStartElement ("ActivityTopDepthHeightMeasure");
            writeFullElement ("MeasureValue", a.getUpperElevation ().getValue ());
            if (a.getUpperElevation ().getUnit () != null) writeFullElement ("MeasureUnitCode", a.getUpperElevation ().getUnit ().getCode ());
            xml.writeEndElement ();
        }
        if (a.getLowerElevation () != null) {
            xml.writeStartElement ("ActivityBottomDepthHeightMeasure");
            writeFullElement ("MeasureValue", a.getLowerElevation ().getValue ());
            if (a.getLowerElevation ().getUnit () != null) writeFullElement ("MeasureUnitCode", a.getLowerElevation ().getUnit ().getCode ());
            xml.writeEndElement ();
        }
        writeActivityProjectXML (a.getUid ());
        if (a.getMonitoringLocation () != null) writeFullElement ("MonitoringLocationIdentifier", a.getMonitoringLocation ().getId ());
        writeFullElement ("ActivityCommentText", (a.getComments () != null) ? a.getComments () : null);
        xml.writeEndElement ();
        if ((a.getLatitude () != null) || (a.getLongitude () != null) || (a.getSourceMapScale () != null) || (a.getHorizontalCollectionMethod () != null) || (a.getHorizontalReferenceDatum () != null)) {
            xml.writeStartElement ("ActivityLocation");
            writeFullElement ("LatitudeMeasure", (a.getLatitude () != null) ? a.getLatitude ().toPlainString () : null);
            writeFullElement ("LongitudeMeasure", (a.getLongitude () != null) ? a.getLongitude ().toPlainString () : null);
            writeFullElement ("SourceMapScaleNumeric", (a.getSourceMapScale () != null) ? a.getSourceMapScale ().toString () : null);
            writeFullElement ("HorizontalCollectionMethodName", (a.getHorizontalCollectionMethod () != null) ? a.getHorizontalCollectionMethod ().getName () : null);
            writeFullElement ("HorizontalCoordinateReferenceSystemDatumName", (a.getHorizontalReferenceDatum () != null) ? a.getHorizontalReferenceDatum ().getName () : null);
            xml.writeEndElement ();
        }
        if (a.getAssemblage () != null) {
            xml.writeStartElement ("BiologicalActivityDescription");
            writeFullElement ("AssemblageSampledName", a.getAssemblage ().getName ());
            xml.writeEndElement ();
        }
        if (((a.getCollectionMethod () != null) && ((a.getCollectionMethod ().getId () != null) || (a.getCollectionMethod ().getContext () != null) || (a.getCollectionMethod ().getName () != null))) || (a.getSamplingCollectionEquipment () != null)) {
            xml.writeStartElement ("SampleDescription");
            if (a.getCollectionMethod () != null) {
                xml.writeStartElement ("SampleCollectionMethod");
                writeFullElement ("MethodIdentifier", a.getCollectionMethod ().getId ());
                writeFullElement ("MethodIdentifierContext", a.getCollectionMethod ().getContext ());
                writeFullElement ("MethodName", a.getCollectionMethod ().getName ());
                xml.writeEndElement ();
            }
            if (a.getSamplingCollectionEquipment () != null) {
                writeFullElement ("SampleCollectionEquipmentName", a.getSamplingCollectionEquipment ().getName ());
            }
            xml.writeEndElement ();
        }
        writeResultXML (a.getUid ());
        xml.writeEndElement ();
    }
}


-----Function Pair=266=-----==

protected boolean loadValuesFromKeystore (KeyStoreInfo keyStoreInfo) throws ConfigurationException {
    KeyStore.PrivateKeyEntry entry = null;
    try {
        if (Log.isLoggable (Log.FAC_KEYS, Level.INFO)) Log.info (Log.FAC_KEYS, "Loading key store {0} version {1} version component {2} millis {3}", keyStoreInfo.getKeyStoreURI (), keyStoreInfo.getVersion ().toString (), VersioningProfile.printAsVersionComponent (keyStoreInfo.getVersion ()), keyStoreInfo.getVersion ().getTime ());
        entry = (KeyStore.PrivateKeyEntry) keyStoreInfo.getKeyStore ().getEntry (_defaultAlias, new KeyStore.PasswordProtection (_password));
        if (null == entry) {
            Log.warning ("Cannot get default key entry: " + _defaultAlias);
            generateConfigurationException ("Cannot retrieve default user keystore entry.", null);
        }
        X509Certificate certificate = (X509Certificate) entry.getCertificate ();
        if (null == certificate) {
            Log.warning ("Cannot get certificate for default key entry: " + _defaultAlias);
            generateConfigurationException ("Cannot retrieve certificate for default user keystore entry.", null);
        }
        _defaultKeyID = new PublisherPublicKeyDigest (certificate.getPublicKey ());
        if (Log.isLoggable (Log.FAC_KEYS, Level.INFO)) Log.info (Log.FAC_KEYS, "Default key ID for user " + _userName + ": " + _defaultKeyID);
        _privateKeyCache.loadKeyStore (keyStoreInfo, _password, _publicKeyCache);
    } catch (Exception e) {
        generateConfigurationException ("Cannot retrieve default user keystore entry.", e);
    }
    return true;
}


public synchronized int exportLayer (String homePath, File file, byte type, int layerID) {
    String dirTo = "" + file.getParent ();
    String filename2 = "" + file.getName ();
    String query = "";
    String nameCol = "";
    String idCol = "";
    if (type == Resources.RASTER_LAYER) {
        query = "select Raster_Path from rasterlayer where Raster_ID=" + layerID;
        nameCol = "Raster_Path";
    }
    else if (type == Resources.FEATURE_LAYER) {
        query = "select Feature_Path from featurelayer where Feature_ID=" + layerID;
        nameCol = "Feature_Path";
    }
    else return - 1;
    Statement stmt = null;
    ResultSet rs = null;
    Connection con = popConnection ();
    String path = null;
    try {
        stmt = con.createStatement ();
        rs = stmt.executeQuery (query);
        int id;
        if (rs.next ()) {
            path = rs.getString (nameCol);
        }
    } catch (Exception e) {
        e.printStackTrace ();
        pushConnection (con);
        return - 1;
    } finally {
        pushConnection (con);
    }
    if (path != null) {
        String dir = "";
        if (type == Resources.RASTER_LAYER) {
            dir += path;
        }
        else {
            dir += homePath;
            dir = dir.substring (0, dir.lastIndexOf (File.separator));
            dir = dir.substring (0, dir.lastIndexOf (File.separator)) + File.separator + path;
        }
        String filenameIn = dir.substring (0, dir.lastIndexOf ("."));
        File fileIn = new File (dir);
        File dirTof = new File (dirTo);
        if (! dirTof.exists ()) {
            dirTof.mkdir ();
        }
        String outFilename = dirTo + File.separator + filename2;
        ZipOutputStream out = null;
        try {
            out = new ZipOutputStream (new FileOutputStream (outFilename));
        } catch (FileNotFoundException e) {
            return - 1;
        }
        String ext = dir.substring (dir.lastIndexOf ("."));
        try {
            if (ext.compareToIgnoreCase (".shp") == 0) {
                this.addZipFile (filenameIn + ext, out);
                this.addZipFile (filenameIn + ".shx", out);
                this.addZipFile (filenameIn + ".dbf", out);
            }
            else if (ext.compareToIgnoreCase (".mif") == 0) {
                this.addZipFile (filenameIn + ext, out);
                this.addZipFile (filenameIn + ".mid", out);
            }
            else {
                this.addZipFile (filenameIn + ext, out);
            }
            out.close ();
        } catch (Exception e) {
            e.printStackTrace ();
            File f = new File (outFilename);
            f.delete ();
            return - 1;
        }
    }
    if (file.exists ()) return (int) file.length ();
    return - 1;
}


-----Function Pair=267=-----==

public static boolean userLogIn () throws InterruptedException, BadLoginException, TimeoutException, XmlRpcException {
    try {
        boolean logged = false;
        if (Global.getOsdbUserName ().equals ("") || Global.getOsdbUserPass ().equals ("")) {
            if (Global.getOsdbSessionUserName ().equals ("") || Global.getOsdbSessionUserPass ().equals ("")) {
                if (isLoggedIn ()) {
                    logOut ();
                }
                do {
                    String user = "";
                    if (Global.getOsdbSessionUserName ().equals ("") == false) {
                        user = Global.getOsdbSessionUserName ();
                    }
                    else {
                        user = Global.getOsdbUserName ();
                    }
                    String [] login = Global.dialogs.showUserPasswordDialog (Global.SubDataBase.BASE_OSDB, user);
                    if (login == null) {
                        throw (new BadLoginException ("Could not log in to OSDb."));
                    }
                    else {
                        Global.setOsdbSessionUserName (login [0]);
                        logged = Osdb.logIn (login [0], login [1]);
                    }
                    if (logged == false) {
                        Global.dialogs.showErrorDialog (Bundles.subgetBundle.getString ("Login_failed."), Bundles.subgetBundle.getString ("Wrong_user/password."));
                    }
                    else {
                        Global.setOsdbSessionUserPass (login [1]);
                    }
                }
                while (logged == false);
            }
        }
        else {
            Global.setOsdbSessionUserName (Global.getOsdbUserName ());
            Global.setOsdbSessionUserPass (Global.getOsdbUserPass ());
            String user = Global.getOsdbSessionUserName ();
            String pass = Global.getOsdbSessionUserPass ();
            logged = Osdb.logIn (user, pass);
            while (logged == false) {
                Global.dialogs.showErrorDialog (Bundles.subgetBundle.getString ("Login_failed."), Bundles.subgetBundle.getString ("Wrong_user/password."));
                String [] login = Global.dialogs.showUserPasswordDialog (Global.SubDataBase.BASE_OSDB, user);
                if (login == null) {
                    throw (new BadLoginException ("Could not log in to OSDb."));
                }
                else {
                    Global.setOsdbSessionUserName (login [0]);
                    logged = Osdb.logIn (login [0], login [1]);
                }
                if (logged) {
                    Global.setOsdbSessionUserPass (login [1]);
                }
            }
        }
        return logged;
    } catch (TimeoutException ex) {
        throw new TimeoutException ("Could not log in to OSDb, timeout.", ex.getCause ());
    } catch (XmlRpcException ex) {
        throw new XmlRpcException ("Could not log in to OSDb, connection error.", ex.getCause ());
    } catch (XmlRpcFault ex) {
        throw new XmlRpcException ("Could not log in to OSDb, connection error.", ex.getCause ());
    }
}


private Connection openSqlConnection () {
    try {
        String server = readFromConsole ("SQL Server host:");
        String username = readFromConsole ("SQL username:");
        String password = readFromConsole ("password:");
        String database = readFromConsole ("Database:");
        String url = "jdbc:mysql://" + server + "/" + database + "?user=" + username + "&password=" + password;
        Connection con = DriverManager.getConnection (url);
        return con;
    } catch (Exception e) {
        System.out.println ("Could not open SQL connection!");
        System.exit (1);
        return null;
    }
}


-----Function Pair=268=-----==

public void testCcndRetrieve () throws Exception {
    ContentName dataPrefix = testHelper.getTestNamespace ("TestCcndRetrieve");
    Flosser floss = new Flosser (dataPrefix);
    CCNStringObject so = new CCNStringObject (dataPrefix, "This is the value", SaveType.RAW, handle);
    so.save ();
    ContentName name = so.getVersionedName ();
    so.close ();
    floss.stop ();
    Operation < Interest, Object > getcontent = new Operation < Interest, Object > () {
        Object execute (Interest interest, Object ignored) throws Exception {
            ContentObject result = handle.get (interest, CCNNetworkManager.PERIOD);
            if (null == result) {
                throw new NoMatchingContentFoundException ("timeout on get for " + interest.name ());
            }
            return null;
        } int size (Interest interest) {
            return - 1;
        }
    }
    ;
    Interest interest = new Interest (name);
    System.out.println ("==== Single data retrieval from ccnd: " + name);
    runBenchmark ("retrieve data", getcontent, interest, null);
}


void displayMatches (List < List < Graph.Vertex > > cycles) {
    int numTrades = 0;
    int numGroups = cycles.size ();
    int totalCost = 0;
    int sumOfSquares = 0;
    List < Integer > groupSizes = new ArrayList < Integer > ();
    List < String > summary = new ArrayList < String > ();
    List < String > loops = new ArrayList < String > ();
    for (List < Graph.Vertex > cycle : cycles) {
        int size = cycle.size ();
        numTrades += size;
        sumOfSquares += size * size;
        groupSizes.add (size);
        for (Graph.Vertex v : cycle) {
            assert v.match != v.twin;
            loops.add (pad (show (v)) + " receives " + show (v.match.twin));
            summary.add (pad (show (v)) + " receives " + pad (show (v.match.twin)) + " and sends to " + show (v.twin.match));
            totalCost += v.matchCost;
        }
        loops.add ("");
    }
    if (showNonTrades) {
        for (Graph.Vertex v : graph.RECEIVERS) {
            if (v.match == v.twin && ! v.isDummy) summary.add (pad (show (v)) + "             does not trade");
        }
        for (Graph.Vertex v : graph.orphans) {
            if (! v.isDummy) summary.add (pad (show (v)) + "             does not trade");
        }
    }
    if (showLoops) {
        System.out.println ("TRADE LOOPS (" + numTrades + " total trades):");
        System.out.println ();
        for (String item : loops) System.out.println (item);
    }
    if (showSummary) {
        Collections.sort (summary);
        System.out.println ("ITEM SUMMARY (" + numTrades + " total trades):");
        System.out.println ();
        for (String item : summary) System.out.println (item);
        System.out.println ();
    }
    System.out.print ("Num trades  = " + numTrades + " of " + (ITEMS - DUMMY_ITEMS) + " items");
    if (ITEMS - DUMMY_ITEMS == 0) System.out.println ();
    else System.out.println (new DecimalFormat (" (0.0%)").format (numTrades / (double) (ITEMS - DUMMY_ITEMS)));
    if (showStats) {
        System.out.print ("Total cost  = " + totalCost);
        if (numTrades == 0) System.out.println ();
        else System.out.println (new DecimalFormat (" (avg 0.00)").format (totalCost / (double) numTrades));
        System.out.println ("Num groups  = " + numGroups);
        System.out.print ("Group sizes =");
        Collections.sort (groupSizes);
        Collections.reverse (groupSizes);
        for (int groupSize : groupSizes) System.out.print (" " + groupSize);
        System.out.println ();
        System.out.println ("Sum squares = " + sumOfSquares);
    }
}


-----Function Pair=269=-----==

protected byte [] generateIv1 () {
    byte [] iv = new byte [BLOCK_SIZE];
    long time = System.currentTimeMillis ();
    byte [] mac = null;
    try {
        Enumeration < NetworkInterface > ifaces = NetworkInterface.getNetworkInterfaces ();
        while (mac == null && ifaces.hasMoreElements ()) {
            mac = ifaces.nextElement ().getHardwareAddress ();
        }
    } catch (Exception e) {
    }
    if (mac == null) {
        mac = DEFAULT_MAC;
    }
    for (int i = 0; i < 8; i ++) {
        iv [i] = (byte) (time>> (i * 8));
    }
    System.arraycopy (mac, 0, iv, 8, mac.length);
    digestRandomBytes (iv, 256);
    return iv;
}


public Hashtable getImageSize (String path, int bx, int by) {
    Hashtable < String, String > imgsize = new Hashtable < String, String > ();
    int width = 0;
    int height = 0;
    imgsize.put ("width", "" + bx);
    imgsize.put ("height", "" + by);
    try {
        File file = new File (path);
        BufferedImage bi = ImageIO.read (file);
        width = bi.getWidth ();
        height = bi.getHeight ();
        if (width > bx) {
            imgsize.put ("height", "" + ((height * bx) / width));
            imgsize.put ("width", "" + bx);
        }
        else if (width < by) {
            imgsize.put ("width", "" + by);
            imgsize.put ("height", "" + ((height * by) / width));
        }
    } catch (Exception e) {
        errorLog ("{Malgn.getImageSize} " + e.getMessage ());
    }
    if (imgsize.containsKey ("width") && Integer.parseInt (imgsize.get ("width")) >= bx) imgsize.put ("width", "" + bx);
    if (imgsize.containsKey ("height") && Integer.parseInt (imgsize.get ("height")) > by + 40) imgsize.put ("height", "" + (by + 20));
    return imgsize;
}


-----Function Pair=270=-----==

public XPIInfo generateArchive () throws IOException, XPIException {
    File outFile = new File (outputFile);
    if (outFile.exists ()) {
        System.err.println ("Overwriting: " + outFile);
    }
    else {
        outFile.createNewFile ();
    }
    jarOrder.add (0, inspectFile (SIGNATURE_FILE_NAME, false));
    jarOrder.add (inspectFile (MANIFEST_FILE_NAME));
    jarOrder.add (inspectFile (SIGNATURE_MANIFEST_FILE_NAME));
    XPIInfo info = new XPIInfo (outFile, signerDN, jarOrder.size ());
    print ("Saving XPI ...");
    JarOutputStream jos = new JarOutputStream (new FileOutputStream (outFile));
    observer.setRange (0, jarOrder.size ());
    observer.setValue (0);
    int i = 0;
    for (FileInfo fi : jarOrder) {
        jarFile (jos, fi);
        observer.setValue (++ i);
    }
    jos.close ();
    return info;
}


static void compareFolderHashes (String rootFolder, Document currentState, Document savedState, StringWriter sw) throws TransformerException, UnsupportedEncodingException {
    boolean blnSomethingHasChanged = false;
    sw.append ("<hr>Comparing folder contents<br>");
    NodeList subFolders = XPathAPI.selectNodeList (savedState.getDocumentElement (), "//folder");
    for (int i = 0; i < subFolders.getLength (); i ++) {
        Element subFolder = (Element) subFolders.item (i);
        String name = subFolder.getAttribute ("name");
        Element newSubFolder = (Element) XPathAPI.selectSingleNode (currentState.getDocumentElement (), "//folder[@name='" + name + "']");
        if (newSubFolder == null) {
            sw.append ("Folder " + name + " has been deleted<br>");
            blnSomethingHasChanged = true;
        }
    }
    NodeList newSubFolders = XPathAPI.selectNodeList (currentState.getDocumentElement (), "//folder");
    for (int i = 0; i < newSubFolders.getLength (); i ++) {
        Element newSubFolder = (Element) newSubFolders.item (i);
        String name = newSubFolder.getAttribute ("name");
        Element subFolder = (Element) XPathAPI.selectSingleNode (savedState.getDocumentElement (), "//folder[@name='" + name + "']");
        if (subFolder == null) {
            File f = new File (rootFolder + File.separator + name);
            sw.append ("Folder " + name + " has been created. (Modified on " + new Date (f.lastModified ()) + ")<br>");
            blnSomethingHasChanged = true;
        }
    }
    NodeList subFiles = XPathAPI.selectNodeList (savedState.getDocumentElement (), "//file");
    for (int i = 0; i < subFiles.getLength (); i ++) {
        Element subFile = (Element) subFiles.item (i);
        String name = subFile.getAttribute ("name");
        Element newSubFile = (Element) XPathAPI.selectSingleNode (currentState.getDocumentElement (), "//file[@name='" + name + "']");
        if (newSubFile != null) {
            String hash = java.net.URLDecoder.decode (subFile.getTextContent (), "UTF-8");
            String newHash = java.net.URLDecoder.decode (newSubFile.getTextContent (), "UTF-8");
            if (! hash.equals (newHash)) {
                File f = new File (rootFolder + File.separator + name);
                sw.append (" - <a href=\"?exec=download&file=" + URLEncoder.encode (name, "UTF-8") + "\" target=\"_blank\">" + name + "</a> has changed. (Modified on " + new Date (f.lastModified ()) + ")<br>");
                blnSomethingHasChanged = true;
            }
            subFile.getParentNode ().removeChild (subFile);
            newSubFile.getParentNode ().removeChild (newSubFile);
        }
        else {
            sw.append (" - " + name + " has been deleted<br>");
            blnSomethingHasChanged = true;
            subFile.getParentNode ().removeChild (subFile);
        }
    }
    NodeList newSubFiles = XPathAPI.selectNodeList (currentState.getDocumentElement (), "//file");
    for (int i = 0; i < newSubFiles.getLength (); i ++) {
        Element newSubFile = (Element) newSubFiles.item (i);
        String name = newSubFile.getAttribute ("name");
        Element subFile = (Element) XPathAPI.selectSingleNode (savedState.getDocumentElement (), "//file[@name='" + name + "']");
        if (subFile == null) {
            File f = new File (rootFolder + File.separator + name);
            sw.append (" - " + name + " is a new file. (Modified on " + new Date (f.lastModified ()) + ")<br>");
            blnSomethingHasChanged = true;
        }
    }
    if (! blnSomethingHasChanged) {
        sw.append (" - No file has been changed<br>");
    }
}


-----Function Pair=271=-----==

public void run () {
    int xtries = 1;
    while (xtries -- > 0) {
        try {
            URLConnection ws = action.openConnection ();
            ws.setDoOutput (true);
            PrintWriter out = new PrintWriter (ws.getOutputStream ());
            out.print ("filename=" + URLEncoder.encode (filename));
            out.close ();
            cat.debug ("Post Notify sent on " + filename);
            try {
                BufferedReader in = new BufferedReader (new InputStreamReader (ws.getInputStream ()));
                String inline;
                if ((inline = in.readLine ()) != null) {
                    cat.debug ("Post ACK " + inline);
                }
                in.close ();
                return;
            } catch (IOException e) {
                cat.debug (filename + ": " + e.getClass ().getName () + ": " + e.getMessage ());
                if (e.getMessage ().matches (".*40[05] for URL.*")) {
                    cat.error ("Post Notify error on " + filename + "; post rejected by remote.");
                    return;
                }
                else if (e.getMessage ().matches (".*500 for URL.*")) {
                    cat.warn ("Post Server failed on " + filename + "; post ignored");
                }
                else throw e;
            }
        } catch (ConnectException e) {
            cat.error ("Post ConnectionException " + action.toString () + ": " + e.getMessage ());
            return;
        } catch (Exception e) {
            cat.error ("Post Error " + action.toString () + ": " + e.getClass ().getName () + ": " + e.getMessage ());
            e.printStackTrace ();
            return;
        }
    }
    cat.error ("Post abort on " + filename);
}


public static void fileTest () {
    String path = "/home/test/abcd.txt";
    File file = new File (path);
    System.out.println ("isfile:" + file.isFile ());
    if (file.exists ()) {
        if (file.isFile ()) {
            System.out.println ("status: file");
            try {
                String str = FileUtils.readFileToString (file);
                System.out.println ("content: \n" + str);
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
        else {
            System.out.println ("status: dir");
            File [] children = file.listFiles ();
            if (children != null) {
                for (File f : children) {
                    if (f.isFile ()) {
                        System.out.print ("file:");
                    }
                    else if (f.isDirectory ()) {
                        System.out.print ("dir:");
                    }
                    System.out.println (f.getAbsolutePath ());
                }
            }
            else {
                System.out.println ("no children~");
            }
        }
    }
    else {
        System.out.println ("status: lost");
        System.out.println ("delete on lost: " + file.delete ());
    }
}


-----Function Pair=272=-----==

public static void doWeeklyTimeTransmit (String host, String database, String dbuser, String password, String efrom, String eserver, String euser, String epasswd, String sendto) throws Exception {
    Connection con;
    System.out.println ("Weekly Time Report\n");
    try {
        Class.forName ("com.mysql.jdbc.Driver");
        con = DriverManager.getConnection ("jdbc:mysql://" + host + "/" + database + "", dbuser, password);
    } catch (Exception e) {
        throw new ServletException (e.getMessage ());
    }
    Statement stmt2 = con.createStatement ();
    Statement stmt = con.createStatement ();
    ResultSet rs2 = stmt2.executeQuery ("select department, transmit from tech_table where transmit=1 group by department;");
    Format formatter;
    Calendar now = Calendar.getInstance ();
    Date date = new Date ();
    SimpleDateFormat dateFormatter = new SimpleDateFormat ("yyyy-MM-dd");
    formatter = new SimpleDateFormat ("yyyy-MM-dd");
    String s = formatter.format (date);
    Date expireationDate = null;
    expireationDate = dateFormatter.parse (s);
    Calendar dateToBeTested = Calendar.getInstance ();
    dateToBeTested.setTime (expireationDate);
    dateToBeTested.add (Calendar.DAY_OF_YEAR, - 1);
    String enddate = doFormatDate (dateToBeTested.getTime ());
    dateToBeTested.add (Calendar.DAY_OF_YEAR, - 8);
    String startdate = doFormatDate (dateToBeTested.getTime ());
    System.out.println ("Start Date: " + startdate + "\n");
    System.out.println ("End Date: " + enddate + "\n");
    Vector u;
    String mbody = "";
    String mbody2 = "";
    mbody = combinestring (mbody, "<html><basefont size=-1>");
    mbody = combinestring (mbody, "<head><title>Time Sheet Report</title></head><body><h2>By Technician</h2>");
    u = UniTechInfo.getAllTransmitItems (con);
    int counter = 0;
    for (int iu = 0; iu < u.size (); iu ++) {
        UniTechInfo tu = (UniTechInfo) u.elementAt (iu);
        String tech_init = tu.getTechInit ();
        String lusername = tu.getUserName ();
        String tech_name = tu.getTechName ();
        String department = tu.getDepartment ();
        Vector v;
        v = TimeSheetSummary.getLoginItemsMultiDate (con, lusername, doFormatDateDb (getDateDb (startdate)), doFormatDateDb (getDateDb (enddate)));
        mbody = combinestring (mbody, "<table border=1 width=\"75%\" align=\"left\">");
        mbody = combinestring (mbody, "<tr><td>Tech ID: " + lusername + " - " + tech_name + "</td></tr>");
        mbody = combinestring (mbody, "</table>");
        if (v.size () > 0) {
            mbody = combinestring (mbody, "<table border=1 width=\"75%\" align=\"left\">");
            mbody = combinestring (mbody, "<tr><td>Call-Type</td><td>Count</td><td>Total-Collected</td><td>Non-Commision-Billed</td><td>Commision-Billed</td><td>Commision</td><td>Time</td><td>Time-Without-Travel</td></tr>");
            for (int i = 0; i < v.size (); i ++) {
                TimeSheetSummary ts = (TimeSheetSummary) v.elementAt (i);
                String tamount = ts.Amount ();
                String tcamount = ts.CAmount ();
                String tamount_collected = ts.AmountCollected ();
                String tcommision = ts.Commision ();
                String ctype = ts.CType ();
                String callcount = ts.CallCount ();
                String timewithtravel = ts.TimeWithTravel ();
                String timenotravel = ts.TimeNoTravel ();
                mbody = combinestring (mbody, "<tr><td>" + ctype + "</td><td>" + callcount + "</td><td>" + tamount_collected + "</td><td>" + tamount + "</td><td>" + tcamount + "</td><td>" + tcommision + "</td><td>" + timewithtravel + "</td><td>" + timenotravel + "</td></tr>");
            }
            ResultSet rs = stmt.executeQuery ("select count(tsid) as callcount, sum(amount) as amount, sum(amount_collected) as amount_collected, sum(camount) as camount, sum(commision) as commision,  ucase(SEC_TO_TIME(sum(TIME_TO_SEC(subtime(time_out,dispatch_time))))) as time_with_travel,  ucase(SEC_TO_TIME(sum(TIME_TO_SEC(subtime(time_out,time_in))))) as time_no_travel from time_sheet where login='" + lusername + "' and tdate>='" + doFormatDateDb (getDateDb (startdate)) + "' and tdate<='" + doFormatDateDb (getDateDb (enddate)) + "';");
            while (rs.next ()) {
                String tamount = rs.getString ("amount");
                String tcamount = rs.getString ("camount");
                String tamount_collected = rs.getString ("amount_collected");
                String tcommision = rs.getString ("commision");
                String callcount = rs.getString ("callcount");
                String timewithtravel = rs.getString ("time_with_travel");
                String timenotravel = rs.getString ("time_no_travel");
                mbody = combinestring (mbody, "<tr><td>Total</td><td>" + callcount + "</td><td>" + tamount_collected + "</td><td>" + tamount + "</td><td>" + tcamount + "</td><td>" + tcommision + "</td><td>" + timewithtravel + "</td><td>" + timenotravel + "</td></tr>");
            }
            mbody = combinestring (mbody, "</table><br>");
        }
        else {
            mbody = combinestring (mbody, "<table border=0 width=\"75%\" align=\"left\">");
            mbody = combinestring (mbody, "<tr><td>**NO DATA TRANSMITTED</td></tr></table><br>");
        }
        mbody = combinestring (mbody, "<table border=0 width=\"75%\" align=\"left\">");
        mbody = combinestring (mbody, "<tr><td> </td></tr></table><br>");
    }
    mbody2 = combinestring (mbody2, "<html><basefont size=-1>");
    mbody2 = combinestring (mbody2, "<head><title>Time Sheet Report</title></head><body><h2>By Department</h2>");
    while (rs2.next ()) {
        String sdepartment = rs2.getString ("department");
        Vector v;
        v = TimeSheetSummary.getDepartmentItemsMultiDate (con, sdepartment, doFormatDateDb (getDateDb (startdate)), doFormatDateDb (getDateDb (enddate)));
        mbody2 = combinestring (mbody2, "<table border=1 width=\"75%\" align=\"left\">");
        mbody2 = combinestring (mbody2, "<tr><td>Department:  " + sdepartment + "</td></tr>");
        mbody2 = combinestring (mbody2, "</table>");
        if (v.size () > 0) {
            mbody2 = combinestring (mbody2, "<table border=1 width=\"75%\" align=\"left\">");
            mbody2 = combinestring (mbody2, "<tr><td>Call-Type</td><td>Count</td><td>Total-Collected</td><td>Non-Commision-Billed</td><td>Commision-Billed</td><td>Commision</td><td>Time</td><td>Time-Without-Travel</td></tr>");
            for (int i = 0; i < v.size (); i ++) {
                TimeSheetSummary ts = (TimeSheetSummary) v.elementAt (i);
                String tamount = ts.Amount ();
                String tcamount = ts.CAmount ();
                String tamount_collected = ts.AmountCollected ();
                String tcommision = ts.Commision ();
                String ctype = ts.CType ();
                String callcount = ts.CallCount ();
                String timewithtravel = ts.TimeWithTravel ();
                String timenotravel = ts.TimeNoTravel ();
                mbody2 = combinestring (mbody2, "<tr><td>" + ctype + "</td><td>" + callcount + "</td><td>" + tamount_collected + "</td><td>" + tamount + "</td><td>" + tcamount + "</td><td>" + tcommision + "</td><td>" + timewithtravel + "</td><td>" + timenotravel + "</td></tr>");
            }
            ResultSet rs3 = stmt.executeQuery ("select tech_table.department as department, count(tsid) as callcount, sum(amount) as amount, sum(amount_collected) as amount_collected, sum(camount) as camount, sum(commision) as commision,  ucase(SEC_TO_TIME(sum(TIME_TO_SEC(subtime(time_out,dispatch_time))))) as time_with_travel,  ucase(SEC_TO_TIME(sum(TIME_TO_SEC(subtime(time_out,time_in))))) as time_no_travel from time_sheet, tech_table  where time_sheet.login=tech_table.username and tdate>='" + doFormatDateDb (getDateDb (startdate)) + "' and tdate<='" + doFormatDateDb (getDateDb (enddate)) + "' and department='" + sdepartment + "' group by department;");
            while (rs3.next ()) {
                String tamount = rs3.getString ("amount");
                String tcamount = rs3.getString ("camount");
                String tamount_collected = rs3.getString ("amount_collected");
                String tcommision = rs3.getString ("commision");
                String callcount = rs3.getString ("callcount");
                String timewithtravel = rs3.getString ("time_with_travel");
                String timenotravel = rs3.getString ("time_no_travel");
                mbody2 = combinestring (mbody2, "<tr><td>Total</td><td>" + callcount + "</td><td>" + tamount_collected + "</td><td>" + tamount + "</td><td>" + tcamount + "</td><td>" + tcommision + "</td><td>" + timewithtravel + "</td><td>" + timenotravel + "</td></tr>");
            }
            mbody2 = combinestring (mbody2, "</table>");
        }
        else {
            mbody2 = combinestring (mbody2, "<table border=0 width=\"75%\" align=\"left\">");
            mbody2 = combinestring (mbody2, "<tr><td>**NO DATA TRANSMITTED</td></tr></table>");
        }
        mbody2 = combinestring (mbody2, "<table border=0 width=\"75%\" align=\"left\">");
        mbody2 = combinestring (mbody2, "<tr><td> </td></tr></table><br>");
    }
    mbody = "";
}


public void runXHTMLGenerate (XThread pXThread, ContextUElem pContextUElem, ContextUCon pContextUCon) {
    UCon lUCon = pContextUCon.getUCon ();
    String lResourceId = null;
    WorkDoc lWorkDoc = null;
    DOM lHtmlDOM;
    try {
        if (mMethod.equals ("url") || mMethod.equals ("preview")) {
            lResourceId = pXThread.createTempWorkDocId ();
            lWorkDoc = pXThread.getOpenTempWorkDoc (mExpires, mCache, lResourceId, lUCon);
            lWorkDoc.setContentType ("text/html; charset=UTF-8");
            lHtmlDOM = lWorkDoc.getXML ();
        }
        else if (mMethod.equals ("storage-location")) {
            WorkingStoreLocation lWorkingStoreLocation;
            try {
                lWorkingStoreLocation = new WorkingStoreLocation (pXThread.getTopModule ().getStoreLocation (mStoreLocationName), pContextUElem, pXThread.getTopApp (), pXThread.getCurrentCallId ());
            } catch (ExModule e) {
                throw e.toUnexpected ("fm:generate: Storage-location error");
            } catch (ExServiceUnavailable e) {
                throw e.toUnexpected ("fm:generate: Storage-location error");
            }
            lWorkDoc = WorkDoc.getWorkDoc (lWorkingStoreLocation, pXThread.getThreadRef ());
            try {
                lWorkDoc.open (lUCon, pXThread, pContextUElem, pContextUCon);
            } catch (ExModule e) {
                throw e.toUnexpected ("fm:generate: Unable to open storage-location");
            } catch (ExServiceUnavailable e) {
                throw e.toUnexpected ("fm:generate: Unable to open storage-location");
            }
            lWorkDoc.setContentType ("text/html; charset=UTF-8");
            lHtmlDOM = lWorkDoc.getXML ();
        }
        else {
            lHtmlDOM = DOM.createDocument ("html");
        }
        State lState;
        if (XFUtil.exists (mState)) {
            lState = pXThread.getTopModule ().getState (mState);
            if (lState == null) {
                throw new ExInternal ("Generate command is trying to use an invalid state called: " + mState);
            }
        }
        else {
            lState = pXThread.getActiveState ();
        }
        try {
            HtmlGenerator hgen = new HtmlGenerator (pXThread, pXThread.getFoxRequest (), lHtmlDOM, lState, true);
            hgen.generate (mBuffer);
        } catch (ExModule e) {
            throw new ExInternal ("Mute HtmlGenerator has created an error", e);
        }
        if (XFUtil.exists (mCopyToPath)) {
            try {
                lHtmlDOM.copyToParent (pContextUElem.getCreateXPath1E (mCopyToPath));
            } catch (ExActionFailed e) {
                throw e.toUnexpected ("fm:generate: Error assigning value to url-xpath");
            }
        }
        if (lUCon != null && lWorkDoc != null) {
            try {
                lWorkDoc.close ();
                lWorkDoc = null;
            } catch (ExModule e) {
                throw e.toUnexpected ("fm:generate: error closing storage-location");
            } catch (ExServiceUnavailable e) {
                throw e.toUnexpected ("fm:generate: error closing storage-location");
            }
        }
        if (mMethod.equals ("preview") || XFUtil.exists (mUrlPath)) {
            String lFileName = "generated.html";
            StreamParcel lStreamParcel;
            try {
                lStreamParcel = new StreamParcel (StreamParcel.TYPE_STANDARD, lFileName, pXThread.getTopApp (), pXThread.getFoxRequest ().getCookieValue ("streamsession"));
            } catch (ExServiceUnavailable e) {
                throw new ExInternal ("Unable to get App for creating Stream Parcel: ", e);
            }
            lStreamParcel.addStreamParcelInput (new StreamParcelInputTempResource (lFileName, null, mContentType, lResourceId), pXThread);
            if (mMethod.equals ("preview")) {
                pXThread.addURIFilePopup (lStreamParcel.getStreamURL (pXThread.getFoxRequest ()), lFileName);
            }
            else if (XFUtil.exists (mUrlPath)) {
                if (XFUtil.exists (mUrlPath)) {
                    String lUrlString = lStreamParcel.getStreamURL (pXThread.getFoxRequest ());
                    try {
                        pContextUElem.getCreateXPath1E (mUrlPath).setText (lUrlString);
                    } catch (ExActionFailed e) {
                        throw e.toUnexpected ("fm:generate: Error assigning value to url-xpath");
                    }
                }
            }
        }
    } finally {
        if (lWorkDoc != null) {
            try {
                lWorkDoc.abort ();
            } catch (ExRuntimeRoot ignore) {
            }
        }
    }
}


-----Function Pair=273=-----==

public String createSessionID () {
    List < Map.Entry > entrylist = new ArrayList < Map.Entry > (sessionIDs.entrySet ());
    Collections.sort (entrylist, new SecurityPinSorter ());
    sessionIDs.clear ();
    for (int x = 0; x < entrylist.size () && x < 4; x ++) {
        Map.Entry entry = (Map.Entry) entrylist.get (x);
        sessionIDs.put ((String) entry.getKey (), (Date) entry.getValue ());
    }
    String [] ids = (String []) sessionIDs.keySet ().toArray (new String [0]);
    Date now = new Date ();
    for (int x = 0; x < ids.length; x ++) {
        Date createDate = (Date) sessionIDs.get (ids [x]);
        if ((createDate.getTime () + (1000 * 60 * 3)) < now.getTime ()) {
            sessionIDs.remove (ids [x]);
            System.out.println ("Removed Old Session ID : " + ids [x] + " : " + ((now.getTime () - createDate.getTime ()) / (1000)));
        }
    }
    Random ran = new Random ();
    String ranNum = new Integer (ran.nextInt (999999)).toString ();
    if (ranNum.length () == 1) ranNum = "00000" + ranNum;
    if (ranNum.length () == 2) ranNum = "0000" + ranNum;
    if (ranNum.length () == 3) ranNum = "000" + ranNum;
    if (ranNum.length () == 4) ranNum = "00" + ranNum;
    if (ranNum.length () == 5) ranNum = "0" + ranNum;
    sessionIDs.put (ranNum, new Date ());
    entrylist = new ArrayList < Map.Entry > (sessionIDs.entrySet ());
    Collections.sort (entrylist, new SecurityPinSorter ());
    for (int x = 0; x < entrylist.size () && x < 5; x ++) {
        Map.Entry entry = (Map.Entry) entrylist.get (x);
        System.out.println ("Session ID : " + x + " " + (String) entry.getKey () + " " + ((Date) entry.getValue ()).toString ());
    }
    return ranNum;
}


public void save () throws IOException {
    File backup = new File (file.getAbsolutePath () + "~");
    file.renameTo (backup);
    OutputFormat format = new OutputFormat (doc);
    format.setEncoding ("ISO-8859-15");
    format.setLineSeparator (LineSeparator.Unix);
    format.setIndenting (true);
    format.setLineWidth (0);
    format.setPreserveSpace (false);
    XMLSerializer serializer = new XMLSerializer (new FileWriter (file), format);
    serializer.asDOMSerializer ();
    serializer.serialize (doc);
    changed = false;
}


-----Function Pair=274=-----==

private static void extractZip (File zip, File directory) throws ZipException, IOException, FileNotFoundException {
    ZipFile zipFile = new ZipFile (zip);
    Enumeration < ZipEntry > zipEntry = (Enumeration < ZipEntry >) zipFile.entries ();
    while (zipEntry.hasMoreElements ()) {
        ZipEntry entry = zipEntry.nextElement ();
        File file = new File (directory, entry.getName ());
        if (entry.isDirectory ()) {
            file.mkdir ();
        }
        else {
            File parent = file.getParentFile ();
            if (! parent.exists ()) parent.mkdirs ();
            BufferedInputStream in = new BufferedInputStream (zipFile.getInputStream (entry));
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            byte [] b = new byte [1024000];
            for (int i = in.read (b); i > - 1; i = in.read (b)) {
                if (i != 0) out.write (b, 0, i);
            }
            in.close ();
            out.close ();
        }
    }
    zipFile.close ();
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=275=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


void test () {
    log ("test");
    List < ClassSymbol > nestedClasses = new LinkedList < ClassSymbol > ();
    for (PackageSymbol p : packages) {
        for (Scope.Entry se = p.members_field.elems; se != null; se = se.sibling) {
            if (se.sym.name.toString ().contains ("$")) nestedClasses.add ((ClassSymbol) se.sym);
        }
    }
    for (int i = nestedClasses.size (); i > 0; i --) {
        ClassSymbol sym = nestedClasses.remove (rgen.nextInt (i));
        log ("adjusting class " + sym);
        starImportModel.remove (sym);
        String s = sym.name.toString ();
        int dollar = s.indexOf ("$");
        assert (sym.owner.kind == PCK);
        Name outerName = names.fromString (s.substring (0, dollar));
        Scope.Entry outerEntry = sym.owner.members ().lookup (outerName);
        ClassSymbol outer = (ClassSymbol) outerEntry.sym;
        sym.owner.members ().remove (sym);
        sym.name = names.fromString (s.substring (dollar + 1));
        outer.members ().enter (sym);
        sym.owner = outer;
        starImportModel.check (starImportScope);
    }
}


-----Function Pair=276=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


private breakpoint setMainBreakpoint () {
    JDP_Class mainThread = null;
    mainThread = user.bmap.currentThreadToJDPClass ();
    JDP_Field field = null;
    for (int i = 0; i < mainThread.fields.size (); i ++) {
        field = (JDP_Field) mainThread.fields.elementAt (i);
        if (field.name.equals ("args")) break;
    }
    JDP_Class argsArray = null;
    try {
        argsArray = user.bmap.arrayTypeToJDPClass (field.name, field.type, field.address, false);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field classNameField = (JDP_Field) argsArray.fields.elementAt (0);
    return setBreakpointAtStringClass (classNameField);
}


-----Function Pair=277=-----==

public void test138 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=278=-----==

private boolean jdpCommand (String command, String [] args) {
    runstat = true;
    int addr, count;
    if (user == null) {
        if (command.equals ("run")) {
            switch (args.length) {
                case 0 :
                    restart (saved_args);
                    break;
                default :
                    restart (args);
            }
        }
        else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
            if (args.length == 0) printHelp ("");
            else printHelp (args [0]);
        }
        else {
            jdp_console.writeOutput ("No program running, enter:  run ... ");
        }
        return false;
    }
    if (command.equals ("step") || command.equals ("s")) {
        if (args.length != 0) jdp_console.writeOutput ("Sorry, step does not take any arguments at this time. Ignoring arguments.");
        boolean skip_prolog = false;
        printMode = PRINTASSEMBLY;
        runstat = user.pstep (0, printMode, skip_prolog);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        if (Platform.stepbrImplemented == 1) {
            if (args.length != 0) jdp_console.writeOutput ("Sorry, stepbr does not take any arguments at this time. Ignoring arguments.");
            printMode = PRINTASSEMBLY;
            runstat = user.pstepOverBranch (0);
            if (runstat == true) refreshEnvironment ();
        }
        else {
            jdp_console.writeOutput ("Sorry, step instruction over call is not supported yet on this platform");
        }
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        if (args.length != 0) jdp_console.writeOutput ("Sorry, stepline does not take any arguments at this time. Ignoring arguments.");
        printMode = PRINTASSEMBLY;
        runstat = user.pstepLine (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        if (args.length != 0) jdp_console.writeOutput ("Sorry, steplineover does not take any arguments at this time. Ignoring arguments.");
        printMode = PRINTSOURCE;
        runstat = user.pstepLineOverMethod (0);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("run")) {
        jdp_console.writeOutput ("Debuggee is running, kill before restarting");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        switch (debuggerEnvironment) {
            case EXTERNALCREATE :
                runstat = false;
                break;
            case EXTERNALATTACH :
                jdp_console.writeOutput ("Cannot kill attached process, type quit to detach debugger");
                break;
            case INTERNAL :
                jdp_console.writeOutput ("Debugger running inside JVM, type quit to exit debugger");
        }
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        if (debuggerEnvironment == EXTERNALATTACH && ! user.bpset.anyBreakpointExist ()) {
            jdp_console.writeOutput ("no breakpoint currently set, detaching process");
            return true;
        }
        else {
            if (args.length != 0) jdp_console.writeOutput ("This command does not take any arguments. Ignoring arguments.");
            runstat = user.pcontinue (0, printMode, true);
            if (runstat == true) refreshEnvironment ();
        }
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        if (Platform.cthreadImplemented == 1) {
            if (args.length != 0) jdp_console.writeOutput ("This command does not take any arguments. Ignoring arguments.");
            runstat = user.pcontinue (0, printMode, false);
            if (runstat == true) refreshEnvironment ();
        }
        else {
            jdp_console.writeOutput ("Sorry, continue thread is not supported yet on this platform");
        }
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        if (args.length != 0) jdp_console.writeOutput ("This command does not take any arguments. Ignoring arguments.");
        runstat = user.pcontinueToReturn (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        doThread (command, args);
    }
    else if (command.equals ("reg") || command.equals ("r")) {
        doRegisterRead (command, args);
    }
    else if (command.equals ("wreg") || command.equals ("wr")) {
        doRegisterWrite (command, args);
    }
    else if (command.equals ("regname") || command.equals ("regnames")) {
        if (args.length != 0) jdp_console.writeOutput ("This command does not take any arguments. Ignoring arguments.");
        doRegisterName (command);
    }
    else if (command.equals ("memraw") || command.equals ("mraw")) {
        doMemoryReadRaw (command, args);
    }
    else if (command.equals ("mem") || command.equals ("m")) {
        doMemoryRead (command, args);
    }
    else if (command.equals ("wmem") || command.equals ("wm")) {
        doMemoryWrite (command, args);
    }
    else if (command.equals ("print") || command.equals ("p")) {
        doPrintCommand (command, args);
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        doPrintClassCommand (command, args);
    }
    else if (command.equals ("getclass")) {
        doGetClassCommand (command, args);
    }
    else if (command.equals ("getinstance")) {
        doGetInstanceCommand (command, args);
    }
    else if (command.equals ("getarray")) {
        doGetArrayCommand (command, args);
    }
    else if (command.equals ("getcl")) {
        doGetClassAndLine (command, args);
    }
    else if (command.equals ("getcia")) {
        doGetCurrentInstrAddr (command, args);
    }
    else if (command.equals ("getframes")) {
        doGetFrames (command, args);
    }
    else if (command.equals ("getlocals")) {
        doGetLocals (command, args);
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        jdp_console.writeOutput ("(this command has been removed because the Opt compiler does not generate the bytecode map)");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        doListInstruction (command, args);
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        doListThread (command, args);
    }
    else if (command.equals ("break") || command.equals ("b")) {
        doSetBreakpoint (command, args);
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        doClearBreakpoint (command, args);
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        doCurrentFrame (command, args);
    }
    else if (command.equals ("where") || command.equals ("w")) {
        doShortFrame (command, args);
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        doFullFrame (command, args);
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        doSetPreference (command, args);
    }
    else if (command.equals ("x2d")) {
        doConvertHexToInt (command, args);
    }
    else if (command.equals ("d2x")) {
        doConvertIntToHex (command, args);
    }
    else if (command.equals ("test")) {
        doTest (args);
    }
    else if (command.equals ("test1")) {
        doTest1 (args);
    }
    else if (command.equals ("count")) {
        doThreadCount (0);
    }
    else if (command.equals ("zerocount")) {
        doThreadCount (1);
    }
    else if (command.equals ("readmem")) {
        if (args.length != 0) {
            try {
                addr = parseHex32 (args [0]);
                int mydata = user.mem.read (addr);
                jdp_console.writeOutput ("true memory = x" + Integer.toHexString (mydata));
            } catch (NumberFormatException e) {
                jdp_console.writeOutput ("bad address: " + args [0]);
            }
        }
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        if (args.length != 0) jdp_console.writeOutput ("This command does not take any arguments. Ignoring arguments.");
        if (user.verbose) {
            jdp_console.writeOutput ("Verbose now OFF");
            user.verbose = false;
        }
        else {
            jdp_console.writeOutput ("Verbose now ON");
            user.verbose = true;
        }
    }
    else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
        if (args.length == 0) printHelp ("");
        else printHelp (args [0]);
    }
    else if (macro.exists (command + ".jdp")) {
        macro.load (command + ".jdp");
    }
    else {
        jdp_console.writeOutput ("Sorry, you've specified an unknown command. Please use help to see the list of known commands");
    }
    return false;
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=279=-----==

public static void main (String [] args) {
    if (args.length == 0) {
        System.out.println ("usage: server cache zone ... ");
        System.exit (0);
    }
    jnamed s;
    try {
        s = new jnamed ();
        s.addZone (args [0], Zone.CACHE);
        for (int i = 1; i < args.length; i ++) s.addZone (args [i], Zone.PRIMARY);
        s.addUDP ((short) 12345);
        s.addTCP ((short) 12345);
    } catch (IOException e) {
        System.out.println (e);
    }
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=280=-----==

public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=281=-----==

public static void execute2 () throws IOException, InterruptedException {
    Runtime rt = Runtime.getRuntime ();
    Process p = rt.exec ("myCommand");
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    String line = null;
    while ((line = in.readLine ()) != null) System.out.println (line);
    p.waitFor ();
    p.destroy ();
}


public static void main (String args []) {
    int N = Integer.parseInt (args [0]);
    System.out.println ("Running " + N + " times");
    String klass = args [1];
    String methodName = args [2];
    System.out.println ("Method: " + klass + "." + methodName);
    int appArgsLength = Math.max (args.length - 3, 0);
    String [] appArgs = new String [appArgsLength];
    System.arraycopy (args, 3, appArgs, 0, appArgs.length);
    Object [] argv = new Object [1];
    argv [0] = appArgs;
    try {
        Class invokee = Class.forName (klass);
        Method [] methods = invokee.getMethods ();
        Method m = null;
        for (int i = 0; i < methods.length; i ++) {
            if (methods [i].getName ().equals (methodName)) {
                m = methods [i];
                break;
            }
        }
        for (int i = 0; i < N; i ++) {
            System.out.println ("Run " + i + " ... ");
            VM_Callbacks.notifyAppRunStart (i);
            long elapsedTime = - System.currentTimeMillis ();
            m.invoke (null, argv);
            elapsedTime += System.currentTimeMillis ();
            System.out.println ("ELAPSED TIME " + elapsedTime + " ms");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=282=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=283=-----==

public static String getSignatureAttribute (Object obj) {
    Method method;
    try {
        if (obj instanceof AccessibleObject) {
            method = AccessibleObject.class.getDeclaredMethod ("getSignatureAttribute");
        }
        else {
            method = Class.class.getDeclaredMethod ("getSignatureAttribute");
        }
        method.setAccessible (true);
    } catch (NoSuchMethodException ex) {
        System.err.println ("getSignatureAttribute() not defined.");
        ex.printStackTrace ();
        return "<unknown>";
    }
    try {
        return (String) method.invoke (obj);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException (ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException (ex);
    }
}


Message generateReply (Message query, byte [] in, int maxLength) {
    if (query.getHeader ().getOpcode () != Opcode.QUERY) return notimplMessage (query);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (! tsig.verify (query, in, null)) return formerrMessage (in);
    }
    Message response = new Message ();
    response.getHeader ().setID (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.AA);
    response.getHeader ().setFlag (Flags.QR);
    response.addRecord (Section.QUESTION, queryRecord);
    Name name = queryRecord.getName ();
    short type = queryRecord.getType ();
    Zone zone = findBestZone (name);
    Hashtable nameRecords = (Hashtable) zone.findName (name);
    if (nameRecords == null) {
        response.getHeader ().setRcode (Rcode.NXDOMAIN);
    }
    else {
        if (type == Type.ANY) {
            Enumeration e = nameRecords.elements ();
            while (e.hasMoreElements ()) {
                RRset rrset = (RRset) e.nextElement ();
                addRRset (response, rrset);
            }
        }
        else {
            Short Type = new Short (type);
            RRset rrset = (RRset) nameRecords.get (Type);
            if (rrset != null) addRRset (response, rrset);
        }
    }
    addAuthority (response, name, zone);
    addAdditional (response);
    if (queryTSIG != null) {
        try {
            if (tsig != null) tsig.apply (response, queryTSIG);
        } catch (IOException e) {
        }
    }
    try {
        byte [] out = response.toWire ();
        if (out.length > maxLength) {
            truncate (response, out.length, maxLength);
            if (tsig != null) tsig.apply (response, queryTSIG);
        }
    } catch (IOException e) {
    }
    return response;
}


-----Function Pair=284=-----==

private Vector convertColDataORACLE_MSSQL (String olddttype, String newdttype, Vector olddataVec) {
    Vector newdataVec = new Vector ();
    Enumeration enm = olddataVec.elements ();
    while (enm.hasMoreElements ()) {
        olddata = enm.nextElement ().toString ();
        String newdata = "'" + olddata + "'";
        if (olddttype.equalsIgnoreCase ("char") && (newdttype.equalsIgnoreCase ("bigint") || newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("smallint"))) {
            newdata = "0";
        }
        if (olddttype.equalsIgnoreCase ("char") && (newdttype.equalsIgnoreCase ("float") || newdttype.equalsIgnoreCase ("real") || newdttype.equalsIgnoreCase ("decimal") || newdttype.equalsIgnoreCase ("numeric"))) {
            newdata = "0.0";
        }
        if (olddttype.equalsIgnoreCase ("char") && (newdttype.equalsIgnoreCase ("DateTime") || newdttype.equalsIgnoreCase ("smalldatetime") || newdttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Date") && (newdttype.equalsIgnoreCase ("bigint") || newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("smallint") || newdttype.equalsIgnoreCase ("decimal") || newdttype.equalsIgnoreCase ("float") || newdttype.equalsIgnoreCase ("real") || newdttype.equalsIgnoreCase ("int") || newdttype.equalsIgnoreCase ("numeric"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Number") && (newdttype.equalsIgnoreCase ("DateTime") || newdttype.equalsIgnoreCase ("smalldatetime") || newdttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Number") && (newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("smallint"))) {
            newdata = "0";
        }
        if (olddttype.equalsIgnoreCase ("VarChar2") && (newdttype.equalsIgnoreCase ("DateTime") || newdttype.equalsIgnoreCase ("smalldatetime") || newdttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "null";
        }
        if (olddttype.equalsIgnoreCase ("VarChar2") && (newdttype.equalsIgnoreCase ("bigint") || newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("int") || newdttype.equalsIgnoreCase ("smallint"))) {
            newdata = "0";
        }
        if (olddttype.equalsIgnoreCase ("VarChar2") && (newdttype.equalsIgnoreCase ("numeric") || newdttype.equalsIgnoreCase ("decimal") || newdttype.equalsIgnoreCase ("float") || newdttype.equalsIgnoreCase ("real"))) {
            newdata = "0.0";
        }
        if (olddttype.equalsIgnoreCase ("nVarChar2") && (newdttype.equalsIgnoreCase ("bigint") || newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("int") || newdttype.equalsIgnoreCase ("smallint"))) {
            newdata = "0";
        }
        if (olddttype.equalsIgnoreCase ("nVarChar2") && (newdttype.equalsIgnoreCase ("decimal") || newdttype.equalsIgnoreCase ("numeric") || newdttype.equalsIgnoreCase ("float") || newdttype.equalsIgnoreCase ("real"))) {
            newdata = "0.0";
        }
        if (olddttype.equalsIgnoreCase ("nVarChar2") && (newdttype.equalsIgnoreCase ("DateTime") || newdttype.equalsIgnoreCase ("smalldatetime") || newdttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Timestamp") && (newdttype.equalsIgnoreCase ("nchar") || newdttype.equalsIgnoreCase ("Char"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Timestamp") && (newdttype.equalsIgnoreCase ("bigint") || newdttype.equalsIgnoreCase ("tinyint") || newdttype.equalsIgnoreCase ("decimal") || newdttype.equalsIgnoreCase ("float") || newdttype.equalsIgnoreCase ("real") || newdttype.equalsIgnoreCase ("int") || newdttype.equalsIgnoreCase ("numeric") || newdttype.equalsIgnoreCase ("smallint"))) {
            newdata = "''";
        }
        if (olddttype.equalsIgnoreCase ("Timestamp") && (newdttype.equalsIgnoreCase ("Timestamp") || newdttype.equalsIgnoreCase ("smalldatetime") || newdttype.equalsIgnoreCase ("DateTime"))) {
            newdata = "null";
        }
        if (olddttype.equalsIgnoreCase (newdttype) && (! olddttype.equalsIgnoreCase ("Timestamp"))) {
            newdata = "'" + olddata + "'";
        }
        newdataVec.addElement (newdata);
    }
    return newdataVec;
}


private void bsW (int n, int v) throws IOException {
    while (bsLive >= 8) {
        int ch = (bsBuff>> 24);
        try {
            bsStream.write (ch);
        } catch (IOException e) {
            throw e;
        }
        bsBuff <<= 8;
        bsLive -= 8;
        bytesOut ++;
    }
    bsBuff |= (v << (32 - bsLive - n));
    bsLive += n;
}


-----Function Pair=285=-----==

public void countSLOC (final FileType fileType, final String dirName_p) {
    model.getDataVector ().clear ();
    model.fireTableDataChanged ();
    new Thread () {
        @SuppressWarnings ("synthetic-access")
        @Override
        public void run () {
            FileCounter counter = new FileCounter (fileType, model);
            try {
                counter.countSLOC (dirName_p);
            } catch (Exception exception_p) {
                exception_p.printStackTrace ();
            }
        }
    }
    .start ();
}


private void loadLoads () {
    try {
        if (fileLoads.exists ()) {
            FileInputStream stream = new FileInputStream (fileLoads);
            ObjectInputStream in = new ObjectInputStream (stream);
            downloads = (ArrayList < Load >) in.readObject ();
            uploads = (ArrayList < Load >) in.readObject ();
            in.close ();
            stream.close ();
            for (Load upload : uploads) lbUploads.addLoad (upload);
            for (Load download : downloads) lbUploads.addLoad (download);
        }
        File [] files = fileParts.listFiles ();
        String [] strLoadHashes = new String [downloads.size ()];
        for (int i = 0; i < strLoadHashes.length; i ++) strLoadHashes [i] = downloads.get (i).getHashedFilename ().substring (0, 15);
        for (File file : files) {
            boolean foundFile = false;
            for (String hash : strLoadHashes) {
                if (file.getName ().startsWith (hash)) foundFile = true;
            }
            if (! foundFile) file.delete ();
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=286=-----==

private void drawWedge (Node node, PGraphics canvas) {
    double x = node.getXOffset ();
    double y = node.getYOffset ();
    if (treeLayout.equals ("Radial")) {
        x = node.getRXOffset ();
        y = node.getRYOffset ();
    }
    else if (treeLayout.equals ("Polar")) {
        x = node.getROffset () * Math.cos (node.getTOffset ());
        y = node.getROffset () * Math.sin (node.getTOffset ());
    }
    canvas.strokeWeight ((float) node.getLineWidth () * getLineWidthScale ());
    Color c = null;
    if (! colorBranches) {
        canvas.stroke (0);
        canvas.fill (0);
    }
    else {
        c = node.getBranchColor (majorityColoring);
        if (c == null) {
            canvas.stroke (0);
            canvas.fill (0);
        }
        else {
            canvas.stroke (c.getRGB ());
            canvas.fill (c.getRGB ());
        }
    }
    double longest = node.longestRootToTipDistance () - node.getBranchLength ();
    double shortest = node.shortestRootToTipDistance () - node.getBranchLength ();
    double top = node.getMaximumYOffset () - y;
    top = (top / 2) * wedgeHeightScale;
    double bottom = y - node.getMinimumYOffset ();
    bottom = (bottom / 2) * wedgeHeightScale;
    top = y + top;
    bottom = y - bottom;
    if (treeLayout.equals ("Rectangular")) {
        if (mirrored) {
            canvas.quad ((float) toScreenX (x), (float) toScreenY (bottom), (float) toScreenX (x), (float) toScreenY (top), (float) toScreenX (x - shortest), (float) toScreenY (top), (float) toScreenX (x - longest), (float) toScreenY (bottom));
        }
        else {
            canvas.quad ((float) toScreenX (x), (float) toScreenY (bottom), (float) toScreenX (x), (float) toScreenY (top), (float) toScreenX (x + shortest), (float) toScreenY (top), (float) toScreenX (x + longest), (float) toScreenY (bottom));
        }
    }
    else if (treeLayout.equals ("Triangular")) {
        if (mirrored) {
            canvas.triangle ((float) toScreenX (x), (float) toScreenY (y), (float) toScreenX (x - shortest), (float) toScreenY (top), (float) toScreenX (x - longest), (float) toScreenY (bottom));
        }
        else {
            canvas.triangle ((float) toScreenX (x), (float) toScreenY (y), (float) toScreenX (x + shortest), (float) toScreenY (top), (float) toScreenX (x + longest), (float) toScreenY (bottom));
        }
    }
    else if (treeLayout.equals ("Radial") || treeLayout.equals ("Polar")) {
        double maxt = node.getMaximumTOffset ();
        double mint = node.getMinimumTOffset ();
        if (wedgeHeightScale < 1) {
            double theta = Math.abs (maxt - mint);
            double f = (theta * (1 - wedgeHeightScale)) / 2;
            mint = mint + f;
            maxt = maxt - f;
        }
        double x1 = node.getParent ().getRXOffset () + shortest * Math.cos (mint);
        double y1 = node.getParent ().getRYOffset () + shortest * Math.sin (mint);
        double x2 = node.getParent ().getRXOffset () + longest * Math.cos (maxt);
        double y2 = node.getParent ().getRYOffset () + longest * Math.sin (maxt);
        canvas.triangle ((float) toScreenX (x), (float) toScreenY (y), (float) toScreenX (x1), (float) toScreenY (y1), (float) toScreenX (x2), (float) toScreenY (y2));
    }
    canvas.fill (wedgeFontColor);
    canvas.stroke (wedgeFontColor);
    if (drawWedgeLabels && node.getDrawLabel ()) {
        canvas.textFont (wedgeFont);
        String s = "";
        if (drawInternalNodeLabels) {
            s = node.getLabel ();
        }
        else if (node.getConsensusLineage () != null) {
            s = node.getConsensusLineage ();
            if (s.lastIndexOf (";", s.length () - 2) != - 1) s = s.substring (s.lastIndexOf (";", s.length () - 2) + 1, s.length ());
        }
        else {
            s = "" + node.getNumberOfLeaves ();
        }
        if (Math.abs ((toScreenY (top) - toScreenY (bottom))) > wedgeFontSize) {
            canvas.textFont (wedgeFont);
            if (mirrored) {
                canvas.text (s, (float) (toScreenX (x - (shortest) / 2) + labelXOffset + node.getLabelXOffset ()), (float) (toScreenY (bottom + (top - bottom) / 2) + 5 + labelYOffset + node.getLabelYOffset ()));
            }
            else canvas.text (s, (float) (toScreenX (x + (shortest) / 2) + labelXOffset + node.getLabelXOffset ()), (float) (toScreenY (bottom + (top - bottom) / 2) + 5 + labelYOffset + node.getLabelYOffset ()));
        }
        canvas.textFont (nodeFont);
    }
    canvas.fill (0);
    canvas.stroke (0);
}


protected JFileChooser createFileChooser () {
    JFileChooser fc = new JFileChooser ();
    fc.setFileHidingEnabled (false);
    fc.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    String description = "named binary tag";
    FileFilter filter = new FileNameExtensionFilter (description, "mcr", "dat", "dat_old");
    fc.setFileFilter (filter);
    Preferences prefs = getPreferences ();
    String exportFile = prefs.get (KEY_FILE, null);
    if (exportFile == null) {
        File cwd = new File (".");
        fc.setCurrentDirectory (cwd);
    }
    else {
        File selectedFile = new File (exportFile);
        fc.setSelectedFile (selectedFile);
    }
    return fc;
}


-----Function Pair=287=-----==

public void previsualizarSeleccionado () {
    TipoArchivo _tipo;
    TipoArchivo.iniciarTiposArchivo ();
    String nombre = _lblNombre.getText ();
    String [] extensiones = nombre.split ("\\.");
    if (extensiones.length != 0) {
        _tipo = TipoArchivo.devuelveTipo (extensiones [extensiones.length - 1].toLowerCase ());
    }
    else {
        _tipo = TipoArchivo.OTRO;
    }
    if (_tipo == TipoArchivo.AUDIO || _tipo == TipoArchivo.VIDEO) {
        try {
            String previsualizador = "utils//vlc-0.9.9//vlc.exe";
            String rutaTemp = GestorCompartidos.getInstancia ().getGestorDisco ().getDirectorioTemporales ();
            String ficheroTemp = "//" + _lblNombre.getText () + ".tmp";
            Runtime.getRuntime ().exec (previsualizador + " " + rutaTemp + ficheroTemp);
        } catch (IOException ex) {
            Logger.getLogger (PanelDescargas.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
}


private static void startWebServer (int port) throws Exception {
    Component component = new Component ();
    component.getServers ().add (Protocol.HTTP, port);
    component.getClients ().add (Protocol.FILE);
    component.getDefaultHost ().attach ("/tuna", new TunaApplication (component.getContext ()));
    Application application = new Application (component.getContext ()) {
        @Override
        public Restlet createRoot () {
            String dir = TunaOptions.getWebDir ();
            log.info ("Directorio web: " + dir);
            return new Directory (getContext (), dir);
        }
    }
    ;
    component.getDefaultHost ().attach ("/web", application);
    component.start ();
}


-----Function Pair=288=-----==

public static void openBrowser (URI uri) {
    try {
        if (Desktop.isDesktopSupported ()) {
            Desktop desktop = Desktop.getDesktop ();
            if (desktop.isSupported (Desktop.Action.BROWSE)) {
                desktop.browse (uri);
            }
            else {
                log.error (OPEN_THE_DEFAULT_BROWSER_NOT_SUPPORTED);
                JOptionPane.showMessageDialog (MainFrame.getInstance (), OPEN_THE_DEFAULT_BROWSER_NOT_SUPPORTED, COULD_NOT_OPEN_BROWSER, JOptionPane.ERROR_MESSAGE);
            }
        }
        else {
            log.error (DESKTOP_INTERACTION_NOT_SUPPORTED);
            JOptionPane.showMessageDialog (MainFrame.getInstance (), DESKTOP_INTERACTION_NOT_SUPPORTED, COULD_NOT_OPEN_BROWSER, JOptionPane.ERROR_MESSAGE);
        }
    } catch (IOException e) {
        log.error (COULD_NOT_OPEN_BROWSER, e);
        JOptionPane.showMessageDialog (MainFrame.getInstance (), COULD_NOT_OPEN_BROWSER, COULD_NOT_OPEN_BROWSER, JOptionPane.ERROR_MESSAGE);
    }
}


private void initialize () throws Exception {
    Version v = Version.getVersion ();
    Container cp = getContentPane ();
    cp.setLayout (new BorderLayout ());
    JTabbedPane tabPane = new JTabbedPane ();
    tabPane.setUI (new MyTabPaneUI ());
    JPanel center = new JPanel ();
    center.setLayout (new SpringLayout ());
    File f = new File (".");
    l1 = new JLabel ("Version", JLabel.LEADING);
    l2 = new JLabel (v.toString ());
    l3 = new JLabel ("Java Version", JLabel.LEADING);
    l4 = new JLabel (System.getProperty ("java.version"));
    l5 = new JLabel ("Installation directory", JLabel.LEADING);
    l6 = new JLabel (f.getCanonicalPath ());
    l7 = new JLabel ("Data directory", JLabel.LEADING);
    l8 = new JLabel (ZProperties.getProperty ("FMHOME"));
    l9 = new JLabel ("Copyright(c) Mjrz.net All rights reserved.");
    l10 = new JLabel ("Apache Software License Version 2.0");
    l11 = new JLabel ("Web", JLabel.LEADING);
    l12 = new JLabel ("<html><a href=\"http://www.ifreebudget.net/\">http://www.ifreebudget.com/</a></html>");
    l12.addMouseListener (this);
    center.add (l1);
    center.add (l2);
    center.add (l3);
    center.add (l4);
    center.add (l5);
    center.add (l6);
    center.add (l7);
    center.add (l8);
    center.add (l11);
    center.add (l12);
    SpringUtilities.makeCompactGrid (center, 5, 2, 5, 5, 10, 10);
    JPanel north = new JPanel ();
    north.add (Box.createHorizontalGlue ());
    banner = new JLabel ("<html><font size=\"+1\" color=\"black\"><b>" + UIDefaults.PRODUCT_TITLE + "</b></font></html>", JLabel.CENTER);
    north.add (banner);
    north.add (Box.createHorizontalGlue ());
    cp.add (north, BorderLayout.NORTH);
    tabPane.addTab ("General", center);
    tabPane.addTab ("Translations", getTransPanel ());
    tabPane.addTab ("Credits", getCreditsPanel ());
    tabPane.addTab ("License", getLicensePanel ());
    cp.add (tabPane, BorderLayout.CENTER);
    JPanel p = new JPanel ();
    p.setLayout (new FlowLayout ());
    p.add (Box.createHorizontalGlue ());
    u = new JButton ("Check updates");
    u.setPreferredSize (new Dimension (150, 25));
    u.addActionListener (this);
    p.add (u);
    p.add (Box.createHorizontalGlue ());
    b = new JButton ("Close");
    b.setPreferredSize (new Dimension (150, 25));
    b.addActionListener (this);
    p.add (b);
    p.add (Box.createHorizontalGlue ());
    JPanel c = new JPanel ();
    p.setLayout (new FlowLayout ());
    c.add (Box.createHorizontalGlue ());
    c.add (l9);
    c.add (Box.createHorizontalGlue ());
    JPanel s = new JPanel ();
    s.setLayout (new SpringLayout ());
    s.add (c);
    s.add (p);
    SpringUtilities.makeCompactGrid (s, 2, 1, 0, 0, 0, 0);
    cp.add (s, BorderLayout.SOUTH);
    setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
    this.setPreferredSize (new Dimension (600, 500));
    ActionMap am = getRootPane ().getActionMap ();
    InputMap im = getRootPane ().getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    Object windowCloseKey = new Object ();
    KeyStroke windowCloseStroke = KeyStroke.getKeyStroke (KeyEvent.VK_ESCAPE, 0);
    Action windowCloseAction = new AbstractAction () {
        public void actionPerformed (ActionEvent e) {
            setVisible (false);
            dispose ();
        }
    }
    ;
    im.put (windowCloseStroke, windowCloseKey);
    am.put (windowCloseKey, windowCloseAction);
}


-----Function Pair=289=-----==

public void openURI (String url) {
    if (! java.awt.Desktop.isDesktopSupported ()) {
        System.err.println ("Desktop is not supported (fatal)");
        System.exit (1);
    }
    java.awt.Desktop desktop = java.awt.Desktop.getDesktop ();
    if (! desktop.isSupported (java.awt.Desktop.Action.BROWSE)) {
        System.err.println ("Desktop doesn't support the browse action (fatal)");
        System.exit (1);
    }
    try {
        java.net.URI uri = new java.net.URI (url);
        desktop.browse (uri);
    } catch (Exception e) {
        System.err.println (e.getMessage ());
    }
}


private File applyViewGroupXsl (ApplicationType application, GroupType group) throws DataManagerException, IOException, TransformerConfigurationException, TransformerException {
    logger.debug ("Applying view group xsl");
    String viewRecXsl = RTClientProperties.instance ().getViewGroupXsl ();
    File viewRecXslFile = new File (viewRecXsl);
    HashMap < String, Object > parameters = new HashMap < String, Object > ();
    parameters.put ("applicationId", application.getId ());
    parameters.put ("groupId", group.getId ());
    Reader xmlFile = DataManager.instance ().getRTDocument ().newReader ();
    String tempDir = RTClientProperties.instance ().getTempDir ();
    File tempDirFile = new File (tempDir);
    if (! tempDirFile.exists ()) tempDirFile.mkdirs ();
    File outputHtml = new File (tempDir + File.separator + "view.group." + application.getId () + "." + group.getId () + ".html");
    FileWriter output = new FileWriter (outputHtml);
    XSLProcessor.Instance ().processWithCache (xmlFile, viewRecXslFile, output, parameters);
    logger.debug ("Finished applying view recommendation xsl");
    return outputHtml;
}


-----Function Pair=290=-----==

public static final Vector parseHeader (String header, boolean dequote) throws ParseException {
    if (header == null) return null;
    char [] buf = header.toCharArray ();
    Vector elems = new Vector ();
    boolean first = true;
    int beg = - 1, end = 0, len = buf.length, abeg [] = new int [1];
    String elem_name, elem_value;
    elements : while (true) {
        if (! first) {
            beg = skipSpace (buf, end);
            if (beg == len) break;
            if (buf [beg] != ',') throw new ParseException ("Bad header format: '" + header + "'\nExpected \",\" at position " + beg);
        }
        first = false;
        beg = skipSpace (buf, beg + 1);
        if (beg == len) break elements;
        if (buf [beg] == ',') {
            end = beg;
            continue elements;
        }
        if (buf [beg] == '=' || buf [beg] == ';' || buf [beg] == '"') throw new ParseException ("Bad header format: '" + header + "'\nEmpty element name at position " + beg);
        end = beg + 1;
        while (end < len && ! Character.isWhitespace (buf [end]) && buf [end] != '=' && buf [end] != ',' && buf [end] != ';') end ++;
        elem_name = new String (buf, beg, end - beg);
        beg = skipSpace (buf, end);
        if (beg < len && buf [beg] == '=') {
            abeg [0] = beg + 1;
            elem_value = parseValue (buf, abeg, header, dequote);
            end = abeg [0];
        }
        else {
            elem_value = null;
            end = beg;
        }
        NVPair [] params = new NVPair [0];
        params : while (true) {
            String param_name, param_value;
            beg = skipSpace (buf, end);
            if (beg == len || buf [beg] != ';') break params;
            beg = skipSpace (buf, beg + 1);
            if (beg == len || buf [beg] == ',') {
                end = beg;
                break params;
            }
            if (buf [beg] == ';') {
                end = beg;
                continue params;
            }
            if (buf [beg] == '=' || buf [beg] == '"') throw new ParseException ("Bad header format: '" + header + "'\nEmpty parameter name at position " + beg);
            end = beg + 1;
            while (end < len && ! Character.isWhitespace (buf [end]) && buf [end] != '=' && buf [end] != ',' && buf [end] != ';') end ++;
            param_name = new String (buf, beg, end - beg);
            beg = skipSpace (buf, end);
            if (beg < len && buf [beg] == '=') {
                abeg [0] = beg + 1;
                param_value = parseValue (buf, abeg, header, dequote);
                end = abeg [0];
            }
            else {
                param_value = null;
                end = beg;
            }
            params = Util.resizeArray (params, params.length + 1);
            params [params.length - 1] = new NVPair (param_name, param_value);
        }
        elems.addElement (new HttpHeaderElement (elem_name, elem_value, params));
    }
    return elems;
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=291=-----==

public String getAccessibleName () {
    String name = super.getAccessibleName ();
    if (seqs.size () > 0 && seqs.get (0).size > 0) {
        String keyValueList = "";
        for (Sequence seq : seqs) {
            if (seq.isPlotted) {
                String value = "null";
                if (seq.size > 0) {
                    value = "" + seq.value (seq.size - 1);
                    if (unit == Unit.PERCENT) {
                        value += "%";
                    }
                    else if (unit == Unit.BYTES) {
                        value = getText ("Size Bytes", seq.value (seq.size - 1));
                    }
                }
                keyValueList += getText ("Plotter.accessibleName.keyAndValue", seq.key, value);
            }
        }
        name += "\n" + keyValueList + ".";
    }
    else {
        name += "\n" + getText ("Plotter.accessibleName.noData");
    }
    return name;
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=292=-----==

public String getCode () throws ParseException {
    Class < ? > leftType = leftParameter.getReturnType ();
    String leftCode = leftParameter.getCode ();
    if (leftParameter instanceof Operator && ((Operator) leftParameter).getPriority () < getPriority ()) {
        leftCode = "(" + leftCode + ")";
    }
    String rightCode = rightParameter.getCode ();
    if (StringUtils.isFunction (getName ())) {
        String name = getName ().substring (1);
        if ("to".equals (name) && rightParameter instanceof Constant && rightParameter.getReturnType () == String.class && rightCode.length () > 2 && rightCode.startsWith ("\"") && rightCode.endsWith ("\"")) {
            return "((" + rightCode.substring (1, rightCode.length () - 1) + ")" + leftCode + ")";
        }
        else if ("class".equals (name)) {
            if (leftType.isPrimitive ()) {
                return leftType.getCanonicalName () + ".class";
            }
            else {
                return leftCode + ".getClass()";
            }
        }
        Class < ? > [] rightTypes = rightParameter.getReturnTypes ();
        Collection < Class < ? > > functions = getFunctions ();
        if (functions != null && functions.size () > 0) {
            Class < ? > [] allTypes;
            String allCode;
            if (rightTypes == null || rightTypes.length == 0) {
                allTypes = new Class < ? > [] {leftType};
                allCode = leftCode;
            }
            else {
                allTypes = new Class < ? > [rightTypes.length + 1];
                allTypes [0] = leftType;
                System.arraycopy (rightTypes, 0, allTypes, 1, rightTypes.length);
                allCode = leftCode + ", " + rightCode;
            }
            for (Class < ? > function : functions) {
                try {
                    Method method = ClassUtils.searchMethod (function, name, allTypes);
                    if (Object.class.equals (method.getDeclaringClass ())) {
                        break;
                    }
                    return "((" + function.getName () + ")getEngine().getFunction(" + function.getName () + ".class))." + method.getName () + "(" + allCode + ")";
                } catch (NoSuchMethodException e) {
                }
            }
        }
        Class < ? > type = getReturnType ();
        return "(" + leftCode + " == null ? (" + type.getCanonicalName () + ")" + ClassUtils.getInitCode (type) + " : " + getMethodName (leftType, name, rightTypes, leftCode, rightCode) + ")";
    }
    else if (getName ().equals ("[")) {
        Map < String, Class < ? > > types = getParameterTypes ();
        if (Map.class.isAssignableFrom (leftType)) {
            if (leftParameter instanceof Variable) {
                String var = ((Variable) leftParameter).getName ();
                Class < ? > t = types.get (var + ":1");
                if (t != null) {
                    return "((" + t.getCanonicalName () + ")" + leftCode + ".get(" + rightCode + "))";
                }
            }
            return leftCode + ".get(" + rightCode + ")";
        }
        Class < ? > rightType = rightParameter.getReturnType ();
        if (List.class.isAssignableFrom (leftType)) {
            if (IntegerSequence.class.equals (rightType) || int [].class == rightType) {
                return ClassUtils.class.getName () + ".subList(" + leftCode + ", " + rightCode + ")";
            }
            else if (int.class.equals (rightType)) {
                if (leftParameter instanceof Variable) {
                    String var = ((Variable) leftParameter).getName ();
                    Class < ? > t = types.get (var + ":0");
                    if (t != null) {
                        return "((" + t.getCanonicalName () + ")" + leftCode + ".get(" + rightCode + "))";
                    }
                }
                return leftCode + ".get(" + rightCode + ")";
            }
            else {
                throw new ParseException ("The \"[]\" index type: " + rightType.getName () + " must be int!", getOffset ());
            }
        }
        else if (leftType.isArray ()) {
            if (IntegerSequence.class.equals (rightType) || int [].class == rightType) {
                return ClassUtils.class.getName () + ".subArray(" + leftCode + ", " + rightCode + ")";
            }
            else if (int.class.equals (rightType)) {
                return leftCode + "[" + rightCode + "]";
            }
            else {
                throw new ParseException ("The \"[]\" index type: " + rightType.getName () + " must be int!", getOffset ());
            }
        }
        throw new ParseException ("Unsuptorted \"[]\" for non-array type: " + leftType.getName (), getOffset ());
    }
    else if (getName ().equals ("..")) {
        if (leftType == int.class || leftType == Integer.class || leftType == short.class || leftType == Short.class || leftType == long.class || leftType == Long.class) {
            return "new " + IntegerSequence.class.getName () + "(" + leftCode + ", " + rightCode + ")";
        }
        else if (leftType == char.class || leftType == Character.class) {
            return "new " + CharacterSequence.class.getName () + "(" + leftCode + ", " + rightCode + ")";
        }
        else if (leftType == String.class) {
            return "getEngine().getSequence(" + leftCode + ", " + rightCode + ")";
        }
        else {
            throw new ParseException ("The operator \"..\" unsupported parameter type " + leftType, getOffset ());
        }
    }
    else if ("==".equals (getName ()) && ! "null".equals (leftCode) && ! "null".equals (rightCode) && ! leftType.isPrimitive () && ! rightParameter.getReturnType ().isPrimitive ()) {
        return leftCode + ".equals(" + rightCode + ")";
    }
    else if ("!=".equals (getName ()) && ! "null".equals (leftCode) && ! "null".equals (rightCode) && ! leftType.isPrimitive () && ! rightParameter.getReturnType ().isPrimitive ()) {
        return "(! " + leftCode + ".equals(" + rightCode + "))";
    }
    else if ("&&".equals (getName ()) || "||".equals (getName ())) {
        if (rightParameter instanceof Operator && ((Operator) rightParameter).getPriority () < getPriority ()) {
            rightCode = "(" + rightCode + ")";
        }
        leftCode = StringUtils.getConditionCode (leftType, leftCode);
        rightCode = StringUtils.getConditionCode (rightParameter.getReturnType (), rightCode);
        return leftCode + " " + getName () + " " + rightCode;
    }
    else if (getName ().equals ("?")) {
        if (rightParameter instanceof Operator && ((Operator) rightParameter).getPriority () < getPriority ()) {
            rightCode = "(" + rightCode + ")";
        }
        leftCode = StringUtils.getConditionCode (leftType, leftCode);
        return leftCode + " " + getName () + " " + rightCode;
    }
    else if ("|".equals (getName ()) && ! leftType.isPrimitive () && ! Number.class.isAssignableFrom (leftType) && ! Boolean.class.isAssignableFrom (leftType)) {
        return "(" + ClassUtils.class.getName () + ".isNotEmpty(" + leftParameter.getCode () + ") ? (" + leftCode + ") : (" + rightCode + "))";
    }
    else if (":".equals (getName ()) && ! (leftParameter instanceof BinaryOperator && "?".equals (((BinaryOperator) leftParameter).getName ()))) {
        return "new " + MapEntry.class.getName () + "(" + leftCode + ", " + rightCode + ")";
    }
    else {
        if (leftType != null && Date.class.isAssignableFrom (leftType)) {
            if ("<".equals (getName ())) {
                return leftCode + ".before(" + rightCode + ")";
            }
            else if ("<=".equals (getName ())) {
                return "! " + leftCode + ".after(" + rightCode + ")";
            }
            else if (">".equals (getName ())) {
                return leftCode + ".after(" + rightCode + ")";
            }
            else if (">=".equals (getName ())) {
                return "! " + leftCode + ".before(" + rightCode + ")";
            }
        }
        if (rightParameter instanceof Operator && ((Operator) rightParameter).getPriority () < getPriority ()) {
            rightCode = "(" + rightCode + ")";
        }
        return leftCode + " " + getName () + " " + rightCode;
    }
}


public boolean remove (Object o) {
    list.lock.lock ();
    try {
        checkModifications ();
        int i = indexOf (o);
        if (i == - 1) {
            return false;
        }
        boolean result = list.remove (i + start) != null;
        if (result) {
            read = new SubListReadData (read.size - 1, list.getData ());
        }
        return result;
    } finally {
        list.lock.unlock ();
    }
}


-----Function Pair=293=-----==

public static boolean arrayEqualsExceptNull (Object [] a1, Object [] a2) {
    if ((a1 == null) && (a2 == null)) {
        return true;
    }
    if (a1 == null && a2 != null && a2.length == 0) {
        return true;
    }
    if (a2 == null && a1 != null && a1.length == 0) {
        return true;
    }
    if (((a1 == null) && (a2 != null)) || ((a2 == null) && (a1 != null))) {
        return false;
    }
    if (a1.length != a2.length) {
        return false;
    }
    for (int i = 0; i < a1.length; i ++) {
        if ((a1 [i] == null) && (a2 [i] == null)) {
            continue;
        }
        if ((a1 != null) && a1 [i].equals (a2 [i])) {
            continue;
        }
        return false;
    }
    return true;
}


public String toString () {
    StringBuilder builder = new StringBuilder (super.toString ());
    builder.append (" [");
    if (array == null) {
        builder.append ("UNDEFINED!");
    }
    else {
        for (int i = 0; i < length; i ++) {
            if (i != 0) {
                builder.append (", ");
            }
            builder.append (Array.get (array, i));
        }
    }
    builder.append (']');
    return builder.toString ();
}


-----Function Pair=294=-----==

public static int hashCode (int [] [] arrays) {
    if (arrays == null) {
        return 0;
    }
    int result = 1;
    int h = arrays.length;
    int w = arrays [0].length;
    int value = 0;
    for (int i = 0; i < h; i ++) {
        for (int j = 0; j < w; j ++) {
            value = arrays [i] [j];
            int elementHash = (value ^ (value>>> 32));
            result = 31 * result + elementHash;
        }
    }
    return result;
}


private Type getPropertyType (PropertyTokenHolder tokens) {
    String propertyName = tokens.canonicalName;
    PropertyDescriptor pd = getPropertyDescriptorInternal (tokens.actualName);
    if (pd == null || pd.getReadMethod () == null) {
        throw new NotReadablePropertyException (getRootClass (), this.nestedPath + propertyName);
    }
    if (logger.isDebugEnabled ()) logger.debug ("About to invoke read method [" + pd.getReadMethod () + "] on object of class [" + this.object.getClass ().getName () + "]");
    try {
        Type type = pd.getReadMethod ().getGenericReturnType ();
        if (tokens.keys != null) {
            for (int i = 0; i < tokens.keys.length; i ++) {
                if (type == null) {
                    throw new NullValueInNestedPathException (getRootClass (), this.nestedPath + propertyName, "Cannot access indexed value of property referenced in indexed " + "property path '" + propertyName + "': returned null");
                }
                else if (type instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType) type;
                    Class clazz = (Class) parameterizedType.getRawType ();
                    if (Map.class.isAssignableFrom (clazz)) {
                        type = parameterizedType.getActualTypeArguments () [1];
                    }
                    else if (Collection.class.isAssignableFrom (clazz)) {
                        type = parameterizedType.getActualTypeArguments () [0];
                    }
                    else {
                        throw new RuntimeException ("Tipo desconhecido " + parameterizedType);
                    }
                }
                else if (type instanceof Class && ((Class) type).isArray ()) {
                    return type;
                }
                else {
                    throw new RuntimeException ("Implementar convers�o!!!");
                }
            }
        }
        return type;
    } catch (IndexOutOfBoundsException ex) {
        throw new InvalidPropertyException (getRootClass (), this.nestedPath + propertyName, "Index of out of bounds in property path '" + propertyName + "'", ex);
    } catch (NumberFormatException ex) {
        throw new InvalidPropertyException (getRootClass (), this.nestedPath + propertyName, "Invalid index in property path '" + propertyName + "'", ex);
    }
}


-----Function Pair=295=-----==

public void itemStateChanged (ItemEvent e) {
    for (int i = 0; i < this.checkboxes.length; i ++) {
        if (e.getSource () == this.checkboxes [i]) {
            if (this.checkboxes [i].getState ()) this.switches [i].setWhichChild (Switch.CHILD_ALL);
            else this.switches [i].setWhichChild (Switch.CHILD_NONE);
        }
    }
    for (int i = 0; i < this.plane_checkboxes.length; i ++) {
        if (e.getSource () == this.plane_checkboxes [i]) {
            if (! this.plane_checkboxes [i].getState ()) {
                this.setPlaneColor (planes [i], new Color4f (1.0f, 1.0f, 1.0f, 0.0f));
            }
            else {
                if (i == 0) this.setPlaneColor (planes [i], new Color4f (1.0f, 0.0f, 0.0f, 1.0f));
                else this.setPlaneColor (planes [i], new Color4f (0.0f, 1.0f, 0.0f, 1.0f));
            }
        }
    }
}


private void buildToolsPane () {
    Vector supportedFileTypes;
    secs_1 = new JTextField ("05");
    secs_2 = new JTextField ("05");
    click_1 = createButton ("Click", "Click_1");
    click_1.setMnemonic ('C');
    refresh_1 = createButton ("Refresh", "Refresh_1");
    refresh_1.setMnemonic ('e');
    click_2 = createButton ("Start", "Click_2");
    click_2.setMnemonic ('S');
    supportedFileTypes = new Vector ();
    supportedFileTypes.addElement ("jpg");
    supportedFileTypes.addElement ("png");
    captureAfter_1 = new JLabel ("Capture After ");
    captureAfter_2 = new JLabel ("Capture After ");
    secsAs_1 = new JLabel (" Secs As ");
    secsAs_2 = new JLabel (" Secs As ");
    fileType_1 = new JComboBox (supportedFileTypes);
    fileType_2 = new JComboBox (supportedFileTypes);
    JPanel singlePicOptions = new JPanel (new BorderLayout ());
    singlePic = new JRadioButton ("One Screenshoot", true);
    singlePic.setMnemonic ('n');
    multiplePic = new JRadioButton ("Multiple Screenshoots");
    multiplePic.setMnemonic ('u');
    ButtonGroup buttonGroup = new ButtonGroup ();
    buttonGroup.add (singlePic);
    buttonGroup.add (multiplePic);
    singlePic.addActionListener (this);
    multiplePic.addActionListener (this);
    JPanel tools = new JPanel (new BorderLayout ());
    singlePicOptions.add (singlePic, BorderLayout.NORTH);
    JPanel singlePic1 = new JPanel ();
    singlePic1.add (captureAfter_1);
    singlePic1.add (secs_1);
    singlePic1.add (secsAs_1);
    singlePic1.add (fileType_1);
    JPanel singlePic2 = new JPanel ();
    singlePic2.setLayout (new GridLayout (1, 3));
    singlePic2.add (refresh_1);
    singlePic2.add (click_1);
    singlePicOptions.add (singlePic1, BorderLayout.CENTER);
    singlePicOptions.add (singlePic2, BorderLayout.SOUTH);
    CompoundBorder inborder = new CompoundBorder (new EmptyBorder (10, 10, 10, 10), new LineBorder (Color.black, 1, true));
    CompoundBorder border = new CompoundBorder (inborder, new EmptyBorder (10, 10, 10, 10));
    singlePicOptions.setBorder (border);
    JPanel multiPicOptions = new JPanel (new BorderLayout ());
    multiPicOptions.add (multiplePic, BorderLayout.NORTH);
    JPanel multiPic1 = new JPanel ();
    multiPic1.add (captureAfter_2);
    multiPic1.add (secs_2);
    multiPic1.add (secsAs_2);
    multiPic1.add (fileType_2);
    JPanel multiPic2 = new JPanel ();
    multiPic2.setLayout (new GridLayout (1, 3));
    multiPic2.add (new JLabel (""));
    multiPic2.add (click_2);
    multiPicOptions.add (multiPic1, BorderLayout.CENTER);
    multiPicOptions.add (multiPic2, BorderLayout.SOUTH);
    multiPicOptions.setBorder (border);
    crazy = new JRadioButton ("Crazy");
    sexy = new JRadioButton ("Sexy");
    cool = new JRadioButton ("Cool", true);
    crazy.addActionListener (this);
    sexy.addActionListener (this);
    cool.addActionListener (this);
    crazy.setMnemonic ('r');
    sexy.setMnemonic ('e');
    cool.setMnemonic ('o');
    ButtonGroup buttonGroup1 = new ButtonGroup ();
    buttonGroup1.add (crazy);
    buttonGroup1.add (sexy);
    buttonGroup1.add (cool);
    JPanel miscTools = new JPanel (new GridLayout (1, 3));
    JButton about = createButton ("About", "");
    about.setMnemonic ('A');
    JButton help = createButton ("Help", "");
    help.setMnemonic ('H');
    JButton exit = createButton ("Exit", "");
    exit.setMnemonic ('x');
    miscTools.add (about);
    miscTools.add (help);
    miscTools.add (exit);
    JPanel look = new JPanel ();
    look.add (crazy);
    look.add (sexy);
    look.add (cool);
    JPanel opts1 = new JPanel (new BorderLayout ());
    opts1.add (miscTools, BorderLayout.CENTER);
    opts1.add (look, BorderLayout.SOUTH);
    opts1.setBorder (border);
    JPanel statusPane = new JPanel ();
    status = new JTextArea ("Status");
    status.setEditable (false);
    status.setForeground (Color.blue);
    statusPane.add (status);
    statusPane.setBorder (border);
    JPanel opts = new JPanel (new BorderLayout ());
    opts.add (opts1, BorderLayout.NORTH);
    opts.add (statusPane, BorderLayout.SOUTH);
    toolsPane.add (singlePicOptions);
    toolsPane.add (multiPicOptions);
    toolsPane.add (opts);
}


-----Function Pair=296=-----==

public void encryptFile (String srcFileName, String destFileName) throws Exception {
    OutputStream outputWriter = null;
    InputStream inputReader = null;
    try {
        Cipher cipher = Cipher.getInstance ("RSA/ECB/PKCS1Padding", new org.bouncycastle.jce.provider.BouncyCastleProvider ());
        byte [] buf = new byte [100];
        int bufl;
        cipher.init (Cipher.ENCRYPT_MODE, this.pubKeyObj);
        outputWriter = new FileOutputStream (destFileName);
        inputReader = new FileInputStream (srcFileName);
        while ((bufl = inputReader.read (buf)) != - 1) {
            byte [] encText = null;
            byte [] newArr = null;
            if (buf.length == bufl) {
                newArr = buf;
            }
            else {
                newArr = new byte [bufl];
                for (int i = 0; i < bufl; i ++) {
                    newArr [i] = (byte) buf [i];
                }
            }
            encText = cipher.doFinal (newArr);
            outputWriter.write (encText);
        }
        outputWriter.flush ();
    } catch (Exception e) {
        throw e;
    } finally {
        try {
            if (outputWriter != null) {
                outputWriter.close ();
            }
            if (inputReader != null) {
                inputReader.close ();
            }
        } catch (Exception e) {
        }
    }
}


public Key loadKey (String fileName) {
    ObjectInputStream oin = null;
    Key result = null;
    try {
        oin = new ObjectInputStream (new BufferedInputStream (new FileInputStream (fileName)));
        result = (Key) oin.readObject ();
    } catch (FileNotFoundException e1) {
        e1.printStackTrace ();
    } catch (IOException e1) {
        e1.printStackTrace ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (oin != null) {
            try {
                oin.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
    return result;
}


-----Function Pair=297=-----==

private void registerGameFonts () {
    final List < String > fontFilenames = DirectoryUtils.listFilesOfDirectory (FONT_PATH, new FontFilenameFilter ());
    final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment ();
    for (final String s : fontFilenames) {
        LOGGER.info (LogUtils.buildLogString (FONTS_FOUND_FROM_RESOURCES_INFO, s));
        InputStream ttf = null;
        try {
            ttf = new FileInputStream (FONT_PATH + s);
            try {
                final Font font = Font.createFont (TRUETYPE_FONT, ttf);
                ge.registerFont (font);
            } catch (final FontFormatException e) {
                LOGGER.log (SEVERE, LogUtils.buildLogString (FONTS_FILE_FORMAT_ERROR, FONT_PATH + s), e);
            }
        } catch (final IOException e) {
            LOGGER.log (SEVERE, LogUtils.buildLogString (FONTS_FILE_NOT_FOUND_FROM_RESOURCES_ERROR, FONT_PATH + s), e);
        } finally {
            if (ttf != null) {
                try {
                    ttf.close ();
                } catch (final IOException e) {
                    LOGGER.log (SEVERE, LogUtils.buildLogString (CLOSE_FILE_ERROR, FONT_PATH + fontFilenames), e);
                }
            }
        }
    }
}


public void loadPatchSettings () {
    Properties previousPatchSettings = new Properties (patchSettings);
    patchSettings.clear ();
    String discId = State.discId;
    if (discId != State.DISCID_UNKNOWN_FILE && discId != State.DISCID_UNKNOWN_NOTHING_LOADED) {
        String patchFileName = String.format ("patches/%s.properties", discId);
        File patchFile = new File (patchFileName);
        InputStream patchSettingsStream = null;
        try {
            patchSettingsStream = new BufferedInputStream (new FileInputStream (patchFile));
            patchSettings.load (patchSettingsStream);
            Emulator.log.info (String.format ("Overwriting default settings with patch file '%s'", patchFileName));
        } catch (FileNotFoundException e) {
            Emulator.log.debug ("Patch file not found", e);
        } catch (IOException e) {
            Emulator.log.error ("Problem loading patch:", e);
        } finally {
            Utilities.close (patchSettingsStream);
        }
    }
    for (Enumeration < Object > e = patchSettings.keys (); e.hasMoreElements ();) {
        String key = e.nextElement ().toString ();
        previousPatchSettings.remove (key);
        String value = patchSettings.getProperty (key);
        if (! value.equals (loadedSettings.getProperty (key))) {
            triggerSettingsListener (key, value);
        }
    }
    for (Enumeration < Object > e = previousPatchSettings.keys (); e.hasMoreElements ();) {
        String key = e.nextElement ().toString ();
        String oldValue = previousPatchSettings.getProperty (key);
        String newValue = getProperty (key);
        if (! oldValue.equals (newValue)) {
            triggerSettingsListener (key, newValue);
        }
    }
}


-----Function Pair=298=-----==

private static int buildZone (int x, int maxLength, int maxHeight, int floor, int floorHeight) {
    int t = globalRandom.nextInt (totalOdds);
    int type = 0;
    for (int i = 0; i < odds.length; i ++) {
        if (odds [i] <= t) {
            type = i;
        }
    }
    int length = 0;
    switch (type) {
        case ODDS_STRAIGHT :
            length = buildStraight (x, maxLength, false, floor, floorHeight);
            break;
        case ODDS_HILL_STRAIGHT :
            if (floor == DEFAULT_FLOOR && counters.hillStraightCount < counters.totalHillStraight) {
                counters.hillStraightCount ++;
                length = buildHill (x, true, maxLength, floor, false);
            }
            else length = 0;
            break;
        case ODDS_TUBES :
            if (counters.tubesCount < counters.totalTubes) length = buildTubes (x, maxLength, maxHeight, floor, floorHeight);
            else length = 0;
            break;
        case ODDS_GAPS :
            if ((floor > 2 || floor == ANY_HEIGHT) && (counters.gapsCount < counters.totalGaps)) {
                counters.gapsCount ++;
                length = buildGap (x, maxLength, maxHeight, floor, floorHeight);
            }
            else length = 0;
            break;
        case ODDS_CANNONS :
            if (counters.cannonsCount < counters.totalCannons) length = buildCannons (x, maxLength, maxHeight, floor, floorHeight);
            else length = 0;
            break;
        case ODDS_DEAD_ENDS :
            {
                if (floor == DEFAULT_FLOOR && counters.deadEndsCount < counters.totalDeadEnds) {
                    counters.deadEndsCount ++;
                    length = buildDeadEnds (x, maxLength);
                }
            }
    }
    int crCount = 0;
    for (int yy = level.height; yy > 0; yy --) if (level.getBlock (x, yy) == 0 && creaturesRandom.nextInt (levelDifficulty + 1) + 1 > (levelDifficulty + 1) / 2 && crCount < levelDifficulty + 1 && level.getSpriteTemplate (x, yy) == null) {
        addEnemy (x, yy);
        ++ crCount;
    }
    if (levelType > 0) buildCeiling (x, length);
    return length;
}


public void setMode (int newMode) {
    int oldMode = mMode;
    mMode = newMode;
    if (newMode == RUNNING & oldMode != RUNNING) {
        mStatusText.setVisibility (View.INVISIBLE);
        update ();
        return;
    }
    Resources res = getContext ().getResources ();
    CharSequence str = "";
    if (newMode == PAUSE) {
        str = res.getText (R.string.mode_pause);
    }
    if (newMode == READY) {
        str = res.getText (R.string.mode_ready);
    }
    if (newMode == LOSE) {
        str = res.getString (R.string.mode_lose_prefix) + mScore + res.getString (R.string.mode_lose_suffix);
    }
    mStatusText.setText (str);
    mStatusText.setVisibility (View.VISIBLE);
}


-----Function Pair=299=-----==

public void moveRowUp (int id, int row) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            int max = findMaxRank (stmt, id);
            if ((row < 2) || (row > max)) throw new IllegalArgumentException ("Row number not between 2 and " + max);
            stmt.executeUpdate ("update InstructionGroups set Rank = -1 where InstructionId = '" + id + "' and Rank = " + row);
            stmt.executeUpdate ("update InstructionGroups set Rank = " + row + " where InstructionId = '" + id + "' and Rank = " + (row - 1));
            stmt.executeUpdate ("update InstructionGroups set Rank = " + (row - 1) + " where InstructionId = '" + id + "' and Rank = -1");
            conn.commit ();
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public void testTableDDLRecoveryOrdering () throws Exception {
    Connection c1 = null;
    try {
        System.out.print (getName () + " Disable backend one and hit enter:");
        in.readLine ();
        c1 = getConnection (config.url);
        Statement s1 = c1.createStatement ();
        s1.execute (props.getProperty ("drop.table"));
        String create = props.getProperty ("create.table");
        s1.execute (create);
        s1.setCursorName ("cursorName");
        s1.execute ("select * from many_threads for update");
        s1.execute ("insert into many_threads values(1, 'one ', 1)");
        s1.execute ("insert into many_threads values(2, 'two ', 4)");
        if (! c1.getAutoCommit ()) {
            c1.commit ();
        }
        System.out.print (getName () + " Enable the backend and hit enter:");
        in.readLine ();
        checkBackends ();
    } finally {
        close (c1);
    }
}


-----Function Pair=300=-----==

public void testPreparedStatement0007 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0007 " + "  (i  integer  not null, " + "   s  char(10) not null) ");
    final int rowsToAdd = 20;
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        String sql = "insert into #t0007 values (" + i + ", 'row" + i + "')";
        count += stmt.executeUpdate (sql);
    }
    stmt.close ();
    assertEquals (count, rowsToAdd);
    PreparedStatement pstmt = con.prepareStatement ("select s from #t0007 where i = ?");
    pstmt.setInt (1, 7);
    ResultSet rs = pstmt.executeQuery ();
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString (1).trim (), "row7");
    pstmt.setInt (1, 8);
    rs = pstmt.executeQuery ();
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    assertEquals (rs.getString (1).trim (), "row8");
    assertTrue ("Expected no result set", ! rs.next ());
    pstmt.close ();
}


public void test30_passwordAging () throws Exception {
    Db db = DbConnection.defaultCieDbRW ();
    try {
        db.begin ();
        Config.setProperty (db, "com.entelience.esis.security.passwordAge", "5", 1);
        PreparedStatement pst = db.prepareStatement ("UPDATE e_people SET last_passwd_change = '2006-07-01' WHERE user_name = ?");
        pst.setString (1, "esis");
        db.executeUpdate (pst);
        db.commit ();
        p_logout ();
        t30login1 ();
        assertTrue (isPasswordExpired ());
        PeopleInfoLine me = getCurrentPeople ();
        assertNotNull (me.getPasswordExpirationDate ());
        assertTrue (me.getPasswordExpirationDate ().before (DateHelper.now ()));
        t30chgpasswd ();
        assertFalse (isPasswordExpired ());
        me = getCurrentPeople ();
        assertNotNull (me.getPasswordExpirationDate ());
        assertTrue (me.getPasswordExpirationDate ().after (DateHelper.now ()));
        p_logout ();
        t30login2 ();
        assertFalse (isPasswordExpired ());
        t30chgpasswd2 ();
        db.begin ();
        Config.setProperty (db, "com.entelience.esis.security.passwordAge", "0", 1);
        db.commit ();
    } catch (Exception e) {
        e.printStackTrace ();
        db.rollback ();
    } finally {
        db.safeClose ();
    }
}


-----Function Pair=301=-----==

public void testNestedStatements0022 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0022a " + "  (i   integer not null, " + "   str char(254) not null) ");
    stmt.executeUpdate ("create table #t0022b             " + "  (i   integer not null,      " + "   t   datetime not null)     ");
    PreparedStatement pStmtA = con.prepareStatement ("insert into #t0022a values (?, ?)");
    PreparedStatement pStmtB = con.prepareStatement ("insert into #t0022b values (?, getdate())");
    final int rowsToAdd = 100;
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pStmtA.setInt (1, i);
        StringBuffer tmp = new StringBuffer (255);
        while (tmp.length () < 240) {
            tmp.append ("row ").append (i).append (". ");
        }
        pStmtA.setString (2, tmp.toString ());
        count += pStmtA.executeUpdate ();
        pStmtB.setInt (1, i);
        pStmtB.executeUpdate ();
    }
    pStmtA.close ();
    pStmtB.close ();
    assertEquals (count, rowsToAdd);
    Statement stmtA = con.createStatement ();
    Statement stmtB = con.createStatement ();
    count = 0;
    ResultSet rsA = stmtA.executeQuery ("select * from #t0022a");
    assertNotNull (rsA);
    while (rsA.next ()) {
        count ++;
        ResultSet rsB = stmtB.executeQuery ("select * from #t0022b where i=" + rsA.getInt ("i"));
        assertNotNull (rsB);
        assertTrue ("Expected a result set", rsB.next ());
        assertTrue ("Expected no result set", ! rsB.next ());
    }
    assertEquals (count, rowsToAdd);
    stmt.close ();
    stmtA.close ();
    stmtB.close ();
}


public void testQueryUsingEntityNameNotYetLoaded () {
    getEMF ("JPATest");
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        List result = em.createQuery ("SELECT Object(T) FROM Person_Ann T").getResultList ();
        assertEquals (0, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
        getEMF (null);
    }
}


-----Function Pair=302=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToExercise2Group toExercise2Group) {
    ToExercise2GroupDAO ToExercise2GroupDAO = new ToExercise2GroupDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        ToExercise2GroupDAO.update (toExercise2Group);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise2Group);
        Object [] args = {toExercise2Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise2group.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio grupal S2: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise2group.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public static final < T > Map < String, T > executeQueryAsMap (final String sql, final String keyColumn, final String valueColumn, final Class < T > t, final Map < String, T > result, final Statement stmt) {
    ResultSet rs = null;
    try {
        final String cName = t.getCanonicalName ();
        final boolean isTimestamp = "java.sql.Timestamp".equals (cName);
        final boolean isDouble = "java.lang.Double".equals (cName);
        final boolean isInteger = "java.lang.Integer".equals (cName);
        final boolean isFloat = "java.lang.Float".equals (cName);
        final boolean isShot = "java.lang.Short".equals (cName);
        final boolean isLong = "java.lang.Long".equals (cName);
        final boolean isBigDecimal = "class java.math.BigDecimal".equals (cName);
        final boolean isString = "java.lang.String".equals (cName);
        rs = stmt.executeQuery (sql);
        Object value;
        while (rs.next ()) {
            if (isTimestamp) value = rs.getTimestamp (valueColumn);
            else if (isString) {
                value = StringsUtils.trimNull (rs.getString (valueColumn));
            }
            else if (isDouble) value = rs.getDouble (valueColumn);
            else if (isInteger) value = rs.getInt (valueColumn);
            else if (isFloat) value = rs.getFloat (valueColumn);
            else if (isShot) value = rs.getShort (valueColumn);
            else if (isLong) value = rs.getLong (valueColumn);
            else if (isBigDecimal) value = rs.getBigDecimal (valueColumn);
            else value = rs.getObject (valueColumn);
            if (null == value) value = t.newInstance ();
            result.put (rs.getString (keyColumn), t.cast (value));
        }
    } catch (final Exception e) {
        e.printStackTrace ();
    } finally {
        closeAll (rs, null, null);
    }
    return result;
}


-----Function Pair=303=-----==

public void synchronizeUserGroup (Long nExerciseGroupId, String sArrayUserId) {
    List < MaUser > listUserGroup = null;
    int nNumUserGroup = 0;
    int nNumArrayUser = 0;
    String sSql = null;
    try {
        sSql = Statements.UPDATE_FLAG_Y_USER_EXER2_GROUP;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (sSql);
        query.setParameter (1, "Y");
        query.setParameter (2, nExerciseGroupId);
        int nDeleted = query.executeUpdate ();
        sSql = Statements.UPDATE_FLAG_N_USER_EXER2_GROUP;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        query = EntityManagerHelper.createNativeQuery (sSql);
        query.setParameter (1, "N");
        query.setParameter (2, nExerciseGroupId);
        nDeleted = query.executeUpdate ();
        sSql = Statements.SELECT_MA_USER_IN;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        query = EntityManagerHelper.createNativeQuery (sSql, MaUser.class);
        query.setParameter (1, nExerciseGroupId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        listUserGroup = query.getResultList ();
        nNumArrayUser = listUserGroup.size ();
        for (Iterator iterator = listUserGroup.iterator (); iterator.hasNext ();) {
            MaUser maUser = (MaUser) iterator.next ();
            query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_USER_EXER2_GROUP_USER, CoUserExer2Group.class);
            query.setParameter (1, maUser.getUserId ());
            query.setParameter (2, nExerciseGroupId);
            query.setHint (QueryHints.REFRESH, HintValues.TRUE);
            Vector vecResult = (Vector) query.getResultList ();
            if (vecResult.size () == 0) {
                CoUserExer2GroupId CoUserExer2GroupId = new CoUserExer2GroupId (nExerciseGroupId, maUser.getUserId ());
                CoUserExer2Group CoUserExer2Group = new CoUserExer2Group ();
                CoUserExer2Group.setToExercise2Group (new ToExercise2GroupDAO ().findById (nExerciseGroupId));
                CoUserExer2Group.setMaUser (maUser);
                CoUserExer2Group.setId (CoUserExer2GroupId);
                CoUserExer2Group.setFlagDeleted ("N");
                new CoUserExer2GroupDAO ().save (CoUserExer2Group);
            }
            else {
            }
        }
        EntityManagerHelper.commit ();
    } catch (Exception e) {
        log.info ("Error buscando el estado para usuarios por grupo ");
        EntityManagerHelper.rollback ();
    }
}


public boolean editTask (task t) {
    boolean result = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("update task set task_name=?,task_endDate=?, task_endTime=?,task_status=?,task_description=?,group_name=? where task_id=?");
        stmt.setString (1, t.getTname ());
        stmt.setString (2, t.getTenddate ());
        stmt.setString (3, t.getTendtime ());
        stmt.setString (4, t.getStat ());
        stmt.setString (5, t.getDesc ());
        stmt.setString (6, t.getGname ());
        stmt.setInt (7, t.getTid ());
        int num = stmt.executeUpdate ();
        if (num >= 1) {
            result = true;
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        result = false;
    }
    return result;
}


-----Function Pair=304=-----==

public boolean addEmpLeaveDetails (int empId, String leaveFrom, String leaveTo, String type, String reason, String authorizedBy, String authorizedDate) {
    System.out.println ("leave Type=" + type + "empId=" + empId);
    boolean flag = false;
    try {
        transaction = session.beginTransaction ();
        LeaveDetail leaveObj = new LeaveDetail ();
        leaveObj.setEmployeeCode (empId);
        leaveObj.setLeaveFrom (Miscellaneous.sqlDateFormate (leaveFrom));
        leaveObj.setLeaveTo (Miscellaneous.sqlDateFormate (leaveTo));
        leaveObj.setType (type);
        leaveObj.setLeaveReasons (reason);
        leaveObj.setAuthorizedBy (authorizedBy);
        leaveObj.setAuthorizedDate (Miscellaneous.sqlDateFormate (authorizedDate));
        session.save (leaveObj);
        transaction.commit ();
        flag = true;
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return flag;
}


public void ubahSatuanMenu () {
    try {
        Integer Menu;
        String satuanLama = null;
        String satuanBaru = null;
        satuanLama = String.valueOf (menuTable.getValueAt (menuTable.getSelectedRow (), 4));
        satuanBaru = JOptionPane.showInputDialog (menuTable, "Ganti Satuan Menu", satuanLama);
        if (! satuanLama.equals (satuanBaru) && ! (satuanBaru == null)) {
            Menu = Integer.valueOf (String.valueOf (menuTable.getValueAt (menuTable.getSelectedRow (), 0)));
            menuEntity.getTransaction ().begin ();
            menuQuery = menuEntity.createNativeQuery ("UPDATE menu m SET m.satuan = #satuan WHERE m.menu = #menu").setParameter ("menu", displayMenu.format (Menu)).setParameter ("satuan", satuanBaru);
            menuQuery.executeUpdate ();
            menuEntity.getTransaction ().commit ();
        }
    } catch (Exception ex) {
        menuEntity.getTransaction ().rollback ();
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    refreshTableMenu ();
}


-----Function Pair=305=-----==

public boolean deleteCategories (int leaveId) {
    boolean flag = false;
    try {
        transaction = session.beginTransaction ();
        LeaveType leaveType = (LeaveType) session.get (LeaveType.class, leaveId);
        session.delete (leaveType);
        transaction.commit ();
        session.close ();
        flag = true;
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return flag;
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query1 = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection1 = (Collection < Person >) query1.getResultList ();
        for (Person person : collection1) {
            entityManager.remove (person);
        }
        Query query2 = entityManager.createQuery ("DELETE FROM Address");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=306=-----==

public ArrayList < LeaveDetail > leaveDetails (int empId, String leaveFrom, String leaveTo) {
    ArrayList < LeaveDetail > arrayList = new ArrayList < LeaveDetail > ();
    String hql = " from LeaveDetail as l where l.employeeCode='" + empId + "' and (l.leaveFrom >='" + Miscellaneous.sqlDateFormate (leaveFrom) + "' and l.leaveTo<='" + Miscellaneous.sqlDateFormate (leaveTo) + "') ";
    try {
        transaction = session.beginTransaction ();
        List < LeaveDetail > list = session.createQuery (hql).list ();
        for (Iterator < LeaveDetail > iterator = list.iterator (); iterator.hasNext ();) {
            LeaveDetail obj = iterator.next ();
            obj.getLeaveFrom ();
            obj.getLeaveTo ();
            obj.getType ();
            obj.getAuthorizedBy ();
            obj.getAuthorizedDate ();
            obj.getLeaveReasons ();
            arrayList.add (obj);
        }
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return arrayList;
}


public List < E > findAll () {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    List < E > list = new ArrayList < E > ();
    try {
        tx.begin ();
        String query = "select o from " + clazz.getSimpleName () + " o";
        Query q = em.createQuery (query);
        list = q.getResultList ();
        tx.commit ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
    return list;
}


-----Function Pair=307=-----==

public List getAllPagination (String className, int offset, int limit, String sort, String order) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + " order by " + sort + " " + order;
        Query queryObject = getSession ().createQuery (queryString);
        queryObject.setFirstResult (offset);
        queryObject.setMaxResults (limit);
        List results = queryObject.list ();
        return results;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public void testPreparedStatementRollback1 () throws Exception {
    Connection localCon = getConnection ();
    Statement stmt = localCon.createStatement ();
    stmt.execute ("CREATE TABLE #psr1 (data BIT)");
    localCon.setAutoCommit (false);
    PreparedStatement pstmt = localCon.prepareStatement ("INSERT INTO #psr1 (data) VALUES (?)");
    pstmt.setBoolean (1, true);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.close ();
    localCon.rollback ();
    ResultSet rs = stmt.executeQuery ("SELECT data FROM #psr1");
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
    localCon.close ();
    try {
        localCon.commit ();
        fail ("Expecting commit to fail, connection was closed");
    } catch (SQLException ex) {
        assertEquals ("HY010", ex.getSQLState ());
    }
    try {
        localCon.rollback ();
        fail ("Expecting rollback to fail, connection was closed");
    } catch (SQLException ex) {
        assertEquals ("HY010", ex.getSQLState ());
    }
}


-----Function Pair=308=-----==

public List getAll (String className, String sort, String order) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + " order by " + sort + " " + order;
        Query queryObject = getSession ().createQuery (queryString);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


private void upgradeSchema () throws IOException {
    Statement stmt = null;
    try {
        int i = getSchema ();
        LOG.info ("DB is currently at schema " + i);
        if (i < SCHEMA_VERSION) {
            LOG.info ("Upgrading from schema " + i + " to schema " + SCHEMA_VERSION);
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            while (i < SCHEMA_VERSION) {
                String qry;
                switch (i) {
                    case 1 :
                        qry = "UPDATE settings SET val = '2' WHERE var = 'schema'";
                        stmt.executeUpdate (qry);
                        break;
                }
                i ++;
            }
            conn.commit ();
        }
    } catch (SQLException e) {
        try {
            conn.rollback ();
        } catch (SQLException e2) {
            LOG.error (SQL_ERROR, e2);
        }
        LOG.fatal (SQL_ERROR, e);
        throw new IOException ("Error upgrading data store", e);
    } finally {
        try {
            if (stmt != null) stmt.close ();
            conn.setAutoCommit (true);
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
            throw new IOException ("Unable to cleanup SQL resources", e);
        }
    }
}


-----Function Pair=309=-----==

public void handleEvent (Event event) {
    if (event.widget == ok) {
        okClicked = true;
        handleOkAction ();
        if (currentStep == 2) {
            if (! ok.isDisposed ()) ok.setText ("Finish");
        }
    }
    else if (event.widget == cancel) {
        okClicked = false;
        handleCancelAction ();
    }
    else {
        if (! isRunning) {
            currentStep = 1;
            stackLayout.topControl = page1;
            ok.setText ("Next");
            back.setVisible (false);
            co.layout ();
            stacked.layout ();
        }
        else {
            showError (title, "CSV Import is running.");
        }
    }
}


public static void readTableData (TableMetaData tableMetaData, String filter) throws Exception {
    PreparedStatement ps = null;
    ResultSet rs = null;
    ResultSetMetaData rsmd = null;
    try {
        String sql = "SELECT * FROM " + tableMetaData.getTableName ();
        if (filter != null) {
            sql += " WHERE " + filter;
        }
        IOHelper.writeInfo ("SELECT" + sql);
        ps = tableMetaData.getConn ().prepareStatement (sql);
        rs = ps.executeQuery ();
        rsmd = ps.getMetaData ();
        int columnCnt = 1;
        while (rs.next ()) {
            Row r = new Row ();
            for (columnCnt = 1; columnCnt <= rsmd.getColumnCount (); columnCnt ++) {
                if (tableMetaData.getConn () instanceof OracleConnection) {
                    if (rsmd.getColumnTypeName (columnCnt).equalsIgnoreCase ("BLOB")) {
                        BLOB blob = ((OracleResultSet) rs).getBLOB (columnCnt);
                        InputStream is = blob.getBinaryStream ();
                        byte data [] = new byte [is.available ()];
                        is.read (data);
                        is.close ();
                        r.getRowData ().put (rsmd.getColumnName (columnCnt), data);
                    }
                    else if (rsmd.getColumnTypeName (columnCnt).equalsIgnoreCase ("LONG")) {
                        r.getRowData ().put (rsmd.getColumnName (columnCnt), rs.getBytes (columnCnt));
                    }
                }
                else {
                    r.getRowData ().put (rsmd.getColumnName (columnCnt), rs.getObject (columnCnt));
                }
            }
            tableMetaData.getData ().add (r);
        }
        if (tableMetaData.getData ().isEmpty ()) IOHelper.writeInfo ("No data Found");
    } finally {
        if (rs != null) rs.close ();
        if (ps != null) ps.close ();
    }
}


-----Function Pair=310=-----==

public void donotupdatemember (Boolean b, String sbtid) {
    StringBuffer querystr = new StringBuffer ("delete from Threads as t");
    StringBuffer queryPosts = new StringBuffer ("delete from Posts as t");
    StringBuffer attachPosts = new StringBuffer ("delete from Attachments as t");
    if (b == false) {
        Transaction tr = null;
        try {
            Session session = HibernateUtil.getSessionFactory ().openSession ();
            tr = session.beginTransaction ();
            StringBuffer sb = new StringBuffer ("from Threads as t where t.tid in (");
            Object [] tids = sbtid.split (",");
            for (int i = 0; i < tids.length; i ++) {
                sb.append (tids [i].toString ());
                sb.append (",");
            }
            String str = sb.substring (0, sb.length () - 1);
            str = str + ")";
            Query query = session.createQuery (str);
            List < Threads > threadsList = query.list ();
            session.flush ();
            for (int i = 0; i < threadsList.size (); i ++) {
                Integer num = threadsList.get (i).getAuthorid ();
                SQLQuery sqlquery = session.createSQLQuery ("update Member as m set m.posts= m.posts-1,m.credits = m.credits-1 where m.uid =" + threadsList.get (i).getAuthorid () + "");
                sqlquery.executeUpdate ();
            }
            tr.commit ();
        } catch (HibernateException he) {
            if (tr != null) {
                tr.rollback ();
            }
            he.printStackTrace ();
        }
    }
    int num = - 1;
    try {
        num = threadTemplate (querystr, sbtid);
        num = threadTemplate (queryPosts, sbtid);
        num = threadTemplate (attachPosts, sbtid);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public void doLogout () throws SecurityException, RemoteException, TimmonBackEndException {
    try {
        sql_get_property_stmt_.setInt (1, user_id_);
        sql_get_property_stmt_.setString (2, "online");
        ResultSet rs = sql_get_property_stmt_.executeQuery ();
        if (rs.next ()) {
            if ("true".equals (rs.getString (1))) {
                sql_change_property_stmt_.setString (1, "online");
                sql_change_property_stmt_.setString (2, "false");
                sql_change_property_stmt_.setInt (3, user_id_);
                sql_change_property_stmt_.setString (4, "online");
            }
        }
        else {
            sql_insert_property_stmt_.setInt (1, user_id_);
            sql_insert_property_stmt_.setString (2, "online");
            sql_insert_property_stmt_.setString (3, "true");
            sql_insert_property_stmt_.executeUpdate ();
        }
        rs.close ();
    } catch (SQLException exc) {
        throw (new TimmonBackEndException (exc));
    }
    user_id_ = - 1;
}


-----Function Pair=311=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoSingleTextCheckList3 coSingleTextCheckList) {
    String sTitle = null;
    try {
        sTitle = coSingleTextCheckList.getTitle ();
        log.error ("Eliminando la lista de chequeo: " + coSingleTextCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.DELETE_CHECK_LIST_STUDENT);
        query.setParameter (1, coSingleTextCheckList.getCheckListId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sTitle};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.delete.success"), arrayParam));
        log.info ("Eliminando el curso: " + coSingleTextCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coSingleTextCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


private void doInsertTask (HttpSession session, String subjectid) throws Exception {
    if (subjectid == null) subjectid = "";
    Db db = null;
    Connection conn = null;
    String sql = "";
    String user = (String) session.getAttribute ("_portal_login");
    String task_description = getParam ("description");
    if ("".equals (task_description.trim ())) return;
    String year1 = getParam ("year1");
    String month1 = getParam ("month1");
    String day1 = getParam ("day1");
    String hour1 = getParam ("hour1");
    String minute1 = getParam ("minute1");
    String hour2 = getParam ("hour2");
    String minute2 = getParam ("minute2");
    int ispublic = ! "".equals (getParam ("public")) ? Integer.parseInt (getParam ("public")) : 1;
    String start_date = year1 + "-" + fmt (month1) + "-" + fmt (day1) + " " + fmt (hour1) + ":" + fmt (minute1) + ":00";
    String end_date = year1 + "-" + fmt (month1) + "-" + fmt (day1) + " " + fmt (hour2) + ":" + fmt (minute2) + ":00";
    String task_date = year1 + "-" + fmt (month1) + "-" + fmt (day1);
    String [] invitelist = request.getParameterValues ("invitelist");
    String id = user.concat (Long.toString (UniqueID.get ()));
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        SQLRenderer r = new SQLRenderer ();
        {
            r.add ("task_id", id);
            r.add ("user_login", user);
            r.add ("task_description", task_description);
            r.add ("task_date", task_date);
            r.add ("hour_start", Integer.parseInt (hour1));
            r.add ("hour_end", Integer.parseInt (hour2));
            r.add ("minute_start", Integer.parseInt (minute1));
            r.add ("minute_end", Integer.parseInt (minute2));
            r.add ("task_start_date", start_date);
            r.add ("task_end_date", end_date);
            r.add ("task_public", ispublic);
            r.add ("subject_id", subjectid);
            sql = r.getSQLInsert ("planner_task");
            stmt.executeUpdate (sql);
        }
        {
            sql = "DELETE FROM planner_task_invite WHERE task_id = '" + id + "' ";
            stmt.executeUpdate (sql);
        }
        if (invitelist != null) {
            for (int i = 0; i < invitelist.length; i ++) {
                r = new SQLRenderer ();
                r.add ("task_id", id);
                r.add ("user_id", invitelist [i]);
                r.add ("inviter_id", user);
                r.add ("allow_edit", 0);
                sql = r.getSQLInsert ("planner_task_invite");
                stmt.executeUpdate (sql);
            }
        }
        conn.commit ();
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
        throw dbex;
    } catch (SQLException ex) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (SQLException rex) {
            }
        }
        System.out.println (ex.getMessage () + sql);
        throw ex;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=312=-----==

public boolean deleteThreads (Threads thread) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.delete (thread);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public void delUser (String userName) {
    if (userName == null) return;
    String surname = userName.substring (0, 1);
    String name = userName.substring (1);
    Connection connection = null;
    PreparedStatement ps = null;
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    ResultSet rs = null;
    try {
        String srtSql = "select user_id from coffice_addrslist_entry where surname = ? and name = ?";
        connection = dbo.getConnection ();
        ps = connection.prepareStatement (srtSql);
        ps.setString (1, surname);
        ps.setString (2, name);
        rs = ps.executeQuery ();
        if (! rs.next ()) {
        }
        int userId = rs.getInt ("user_id");
        String strDelUser = "delete from coffice_addrslist_entry where user_id = ?";
        ps = connection.prepareStatement (strDelUser);
        ps.setInt (1, userId);
        ps.execute ();
        connection.commit ();
    } catch (Exception e) {
        try {
            connection.rollback ();
        } catch (SQLException e1) {
        }
    } finally {
        try {
            ps.close ();
            connection.close ();
            dbo.close ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
    }
}


-----Function Pair=313=-----==

public boolean delete (Long personId) {
    int affectedRows = 0;
    String sql = "delete from PERSONS where PERSON_ID = ?";
    if (true) {
        System.out.println (sql);
    }
    Connection conn = null;
    PreparedStatement pstmt = null;
    try {
        conn = ConnHelper.getConnectionByDriverManager ();
        pstmt = conn.prepareStatement (sql);
        pstmt.setLong (1, personId);
        affectedRows = pstmt.executeUpdate ();
        System.out.printf ("affectedRows = %d%n%n", affectedRows);
    } catch (Exception e) {
        e.printStackTrace (System.out);
    } finally {
        ConnHelper.close (conn, pstmt, null);
    }
    return affectedRows > 0;
}


public String executeCommand (String command, String param) throws Exception {
    if (ConfigurationServiceImpl.COMMAND_LOAD_CONFIG.equals (command)) {
        SearchExpression se = SearchExpression.forClass (Configuration.class, 1, 200);
        se.and (Terms.eq ("groupId", param));
        List < Configuration > configs = list (se);
        HashMap < String, Object > result = new HashMap < String, Object > ();
        for (Configuration c : configs) {
            Object value = c.toTypedValue ();
            result.put (c.getParameter (), value);
        }
        return JsonUtil.toJson (result);
    }
    else if (ConfigurationServiceImpl.COMMAND_QUERY_VERSION.equals (command)) {
        long v = versionControlService.getVersion (Constants.buildVersionControlPath (Constants.serviceName.CONFIGURATION, param));
        return String.valueOf (v);
    }
    else {
        throw new UnsupportedOperationException (command);
    }
}


-----Function Pair=314=-----==

private long [] getSubsetConceptGids (int subsetId) throws SQLException {
    PreparedStatement getSubConsStmt = null;
    try {
        String getSubConQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_SUBSET_CONCEPTS_GID);
        getSubConsStmt = this.conn.prepareStatement (getSubConQuery);
        getSubConsStmt.setInt (1, subsetId);
        ResultSet rs = getSubConsStmt.executeQuery ();
        ArrayList al = new ArrayList ();
        while (rs.next ()) {
            long conceptGid = rs.getLong (1);
            al.add (new Long (conceptGid));
        }
        rs.close ();
        long [] gids = new long [al.size ()];
        for (int i = 0; i < al.size (); i ++) {
            gids [i] = ((Long) al.get (i)).longValue ();
        }
        return gids;
    } finally {
        if (getSubConsStmt != null) {
            getSubConsStmt.close ();
        }
    }
}


public List < Attachtypes > getAll () {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Attachtypes as a");
        List < Attachtypes > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
    }
    return null;
}


-----Function Pair=315=-----==

private String getNamespaceType (int namespaceId) throws SQLException {
    String namespaceType = "";
    if (getNspType == null) {
        String getNspTypeQuery = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_NAMESPACE_TYPE);
        getNspType = this.conn.prepareStatement (getNspTypeQuery);
    }
    ResultSet rs = null;
    try {
        getNspType.setInt (1, namespaceId);
        rs = getNspType.executeQuery ();
        while (rs.next ()) {
            namespaceType = rs.getString (1);
        }
        rs.close ();
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
    return namespaceType;
}


public void addProduct (ProductBean product, int quantity) {
    System.out.println (product.getId ());
    Object [] shoppingInfo = null;
    Iterator iterator = this.cart.iterator ();
    boolean found = false;
    while (iterator.hasNext ()) {
        shoppingInfo = new Object [2];
        shoppingInfo = (Object []) iterator.next ();
        if (product.getId () == ((ProductBean) shoppingInfo [0]).getId ()) {
            found = true;
            shoppingInfo [1] = ((Integer) shoppingInfo [1]).intValue () + quantity;
            break;
        }
    }
    if (! found) {
        shoppingInfo = new Object [2];
        shoppingInfo [0] = product;
        shoppingInfo [1] = quantity;
        this.cart.add (shoppingInfo);
    }
}


-----Function Pair=316=-----==

public void delete (long deviceTypesId) {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction transaction = session.beginTransaction ();
    try {
        org.hibernate.Query query = session.createQuery (" delete " + " from  " + " DeviceTypes lr WHERE lr.id = ? ");
        query.setLong (0, deviceTypesId);
        query.executeUpdate ();
        transaction.commit ();
    } catch (HibernateException e) {
        transaction.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}


public void deleteObject (String id) throws SQLException {
    boolean selfConnection = true;
    Connection conn = null;
    PreparedStatement stmt = null;
    try {
        if (dbConnection == null) {
            DatabaseConn dbConn = new DatabaseConn ();
            conn = dbConn.getConnection ();
            conn.setAutoCommit (false);
        }
        else {
            conn = dbConnection;
            selfConnection = false;
        }
        stmt = conn.prepareStatement (this.deleteSql);
        stmt.setString (1, id);
        stmt.executeUpdate ();
        if (selfConnection) conn.commit ();
    } catch (Exception e) {
        if (selfConnection && conn != null) conn.rollback ();
        throw new SQLException (e.getMessage ());
    } finally {
        if (stmt != null) {
            stmt.close ();
            stmt = null;
        }
        if (selfConnection && conn != null) {
            conn.close ();
            conn = null;
        }
    }
}


-----Function Pair=317=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoTest coTest) {
    CoTestDAO coTestDAO = new CoTestDAO ();
    try {
        log.info ("Actualizando la secuencia: " + coTest.getTestName ());
        EntityManagerHelper.beginTransaction ();
        coTestDAO.update (coTest);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coTest);
        Object [] args = {coTest.getTestName ()};
        if (bundle != null) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("test.update.success"), args));
        }
        log.info ("Se actualizo la secuencia con �xito: " + coTest.getTestName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la secuencia: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("test.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult serviceResult, MaSpell maSpell) {
    MaSpellDAO maSpellDAO = new MaSpellDAO ();
    try {
        maSpell.setWordId (getSequence ("sq_ma_spell"));
        EntityManagerHelper.beginTransaction ();
        maSpellDAO.save (maSpell);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSpell);
        log.info ("Palabra creada con �xito: " + maSpell.getWord ());
        Object [] arrayParam = {maSpell.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la palabra: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=318=-----==

public boolean executeBatchQueries (String batchQueries) {
    Connection connection = null;
    Statement statement = null;
    boolean autoCommit = true;
    String [] batchQueriesArray = batchQueries.split (Strings.SEMICOLON);
    int pos;
    if (batchQueriesArray.length == 0) {
        return true;
    }
    try {
        connection = this.dataSource.getConnection ();
        autoCommit = connection.getAutoCommit ();
        connection.setAutoCommit (false);
        statement = connection.createStatement ();
        for (pos = 0; pos < batchQueriesArray.length; pos ++) {
            batchQueriesArray [pos] = batchQueriesArray [pos].trim ();
            if (batchQueriesArray [pos].equals (Strings.EMPTY)) continue;
            batchQueriesArray [pos] = batchQueriesArray [pos].replace (AgentDatabase.QUERY_ESCAPED_SEMICOLON, Strings.SEMICOLON);
            statement.addBatch (batchQueriesArray [pos].trim ());
        }
        statement.executeBatch ();
        if (autoCommit) {
            connection.commit ();
            connection.setAutoCommit (true);
        }
    } catch (SQLException exception) {
        try {
            connection.rollback ();
        } catch (SQLException oRollbackException) {
            throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, Strings.ROLLBACK, oRollbackException);
        }
    } finally {
        close (statement);
        close (connection);
    }
    return true;
}


public static boolean copyDataToNewTable (EboContext p_eboctx, String srcTableName, String destTableName, String where, boolean log, int mode) throws boRuntimeException {
    srcTableName = srcTableName.toUpperCase ();
    destTableName = destTableName.toUpperCase ();
    Connection cn = null;
    Connection cndef = null;
    boolean ret = false;
    try {
        boolean srcexists = false;
        boolean destexists = false;
        final InitialContext ic = new InitialContext ();
        cn = p_eboctx.getConnectionData ();
        cndef = p_eboctx.getConnectionDef ();
        PreparedStatement pstm = cn.prepareStatement ("SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?");
        pstm.setString (1, srcTableName);
        ResultSet rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            srcexists = true;
        }
        rslt.close ();
        pstm.setString (1, destTableName);
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            destexists = true;
        }
        if (! destexists) {
            rslt.close ();
            pstm.close ();
            pstm = cn.prepareStatement ("SELECT VIEW_NAME FROM USER_VIEWS WHERE VIEW_NAME=?");
            pstm.setString (1, destTableName);
            rslt = pstm.executeQuery ();
            if (rslt.next ()) {
                CallableStatement cstm = cn.prepareCall ("DROP VIEW " + destTableName);
                cstm.execute ();
                cstm.close ();
            }
        }
        rslt.close ();
        pstm.close ();
        if (srcexists && ! destexists) {
            if (log) {
                logger.finest (LoggerMessageLocalizer.getMessage ("CREATING_AND_COPY_DATA_FROM") + " [" + srcTableName + "] " + LoggerMessageLocalizer.getMessage ("TO") + " [" + destTableName + "]");
            }
            CallableStatement cstm = cn.prepareCall ("CREATE TABLE " + destTableName + " AS SELECT * FROM " + srcTableName + " " + (((where != null) && (where.length () > 0)) ? (" WHERE " + where) : ""));
            cstm.execute ();
            cstm.close ();
            if (log) {
                logger.finest (LoggerMessageLocalizer.getMessage ("UPDATING_NGTDIC"));
            }
            cn.commit ();
            ret = true;
        }
        else if (srcexists && destexists) {
            if (log) {
                logger.finest (LoggerMessageLocalizer.getMessage ("COPY_DATA_FROM") + " [" + srcTableName + "] " + LoggerMessageLocalizer.getMessage ("TO") + "  [" + destTableName + "]");
            }
            PreparedStatement pstm2 = cn.prepareStatement ("SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? ");
            pstm2.setString (1, destTableName);
            ResultSet rslt2 = pstm2.executeQuery ();
            StringBuffer fields = new StringBuffer ();
            PreparedStatement pstm3 = cn.prepareStatement ("SELECT COLUMN_NAME FROM USER_TAB_COLUMNS WHERE TABLE_NAME = ? and COLUMN_NAME=?");
            while (rslt2.next ()) {
                pstm3.setString (1, srcTableName);
                pstm3.setString (2, rslt2.getString (1));
                ResultSet rslt3 = pstm3.executeQuery ();
                if (rslt3.next ()) {
                    if (fields.length () > 0) {
                        fields.append (',');
                    }
                    fields.append ('"').append (rslt2.getString (1)).append ('"');
                }
                rslt3.close ();
            }
            pstm3.close ();
            rslt2.close ();
            pstm2.close ();
            CallableStatement cstm;
            int recs = 0;
            if ((mode == 0) || (mode == 1)) {
                cstm = cn.prepareCall ("INSERT INTO " + destTableName + "( " + fields.toString () + " ) ( SELECT " + fields.toString () + " FROM " + srcTableName + " " + (((where != null) && (where.length () > 0)) ? (" WHERE " + where) : "") + ")");
                recs = cstm.executeUpdate ();
                cstm.close ();
                if (log) {
                    logger.finest (LoggerMessageLocalizer.getMessage ("DONE") + " [" + recs + "] " + LoggerMessageLocalizer.getMessage ("RECORDS_COPIED"));
                }
            }
            cn.commit ();
            ret = true;
        }
    } catch (Exception e) {
        try {
            cn.rollback ();
        } catch (Exception z) {
            throw new boRuntimeException ("boBuildDB.moveTable", "BO-1304", z);
        }
        throw new boRuntimeException ("boBuildDB.moveTable", "BO-1304", e);
    } finally {
        try {
            cn.close ();
        } catch (Exception e) {
        }
        try {
            cndef.close ();
        } catch (Exception e) {
        }
    }
    return ret;
}


-----Function Pair=319=-----==

public void add (Channel channel) throws Exception {
    String sqlStr = null;
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        sqlStr = "insert into t_ip_channel (id,name,description,ascii_name,channel_path,site_id,type,data_url,template_id,use_status,order_no,style,creator,create_date,refresh_flag,page_num) VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        connection.setAutoCommit (false);
        String [] path = new String [1];
        path [0] = channel.getPath ();
        selfDefineAdd (path, channel, connection, preparedStatement);
        preparedStatement = connection.prepareStatement (sqlStr);
        preparedStatement.setInt (1, channel.getChannelID ());
        preparedStatement.setString (2, channel.getName ());
        preparedStatement.setString (3, channel.getDescription ());
        preparedStatement.setString (4, channel.getAsciiName ());
        preparedStatement.setString (5, channel.getPath ());
        preparedStatement.setInt (6, channel.getSiteId ());
        preparedStatement.setString (7, channel.getChannelType ());
        preparedStatement.setString (8, channel.getDataUrl ());
        if (channel.getTemplateId () == null || channel.getTemplateId ().trim ().equals ("")) preparedStatement.setNull (9, Types.INTEGER);
        else preparedStatement.setInt (9, Integer.parseInt (channel.getTemplateId ()));
        preparedStatement.setString (10, channel.getUseStatus ());
        preparedStatement.setInt (11, channel.getOrderNo ());
        preparedStatement.setString (12, channel.getStyle ());
        preparedStatement.setInt (13, channel.getCreator ());
        preparedStatement.setTimestamp (14, (Timestamp) channel.getCreateDate ());
        preparedStatement.setString (15, channel.getRefPath ());
        preparedStatement.setInt (16, channel.getPageNum ());
        preparedStatement.executeUpdate ();
        connection.commit ();
        int operateTypeID = Const.OPERATE_TYPE_ID;
        int resID = channel.getChannelID () + Const.CHANNEL_TYPE_RES;
        String resName = channel.getName ();
        int resTypeID = Const.RES_TYPE_ID;
        String remark = "";
        AuthorityManager am = new AuthorityManager ();
        am.createExtResource (Integer.toString (resID), resName, resTypeID, operateTypeID, remark);
    } catch (SQLException ex) {
        connection.rollback ();
        log.error ("���Ƶ��ʱSql�쳣��ִ����䣺" + sqlStr);
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
}


private int selectName (String path) throws DatabaseException {
    try {
        getConnection ().setAutoCommit (false);
    } catch (SQLException e) {
        LOGGER.warn ("Unable to set autocommit off", e);
    }
    PreparedStatement selectSt = null;
    int id = Integer.MIN_VALUE;
    try {
        selectSt = getConnection ().prepareStatement (SELECT_NAME_ITEM_ID);
        selectSt.setString (1, path);
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            id = rs.getInt ("id");
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    return id;
}


-----Function Pair=320=-----==

protected void doNew (Connection con) throws Exception {
    if (! isValidate ()) {
        throw new CesSystemException ("Organize.doNew(): Illegal data values for insert");
    }
    PreparedStatement ps = null;
    String strQuery = "INSERT INTO " + Common.ORGANIZE_TABLE + "(organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y) " + "VALUES (?,?,?,?,?,?,?,?,?)";
    logger.debug ("wbq:6" + strQuery);
    try {
        ps = con.prepareStatement (strQuery);
        ps.setString (1, String.valueOf (this.organizeID));
        ps.setString (2, this.organizeTypeID);
        ps.setString (3, this.organizeName);
        ps.setString (4, this.organizeManager);
        ps.setString (5, this.organizeDescribe);
        ps.setString (6, this.workType);
        ps.setInt (7, showOrder);
        ps.setInt (8, this.positionX);
        ps.setInt (9, this.positionY);
        int resultCount = ps.executeUpdate ();
        if (resultCount != 1) {
            throw new CesSystemException ("Organize.doNew(): ERROR Inserting data " + "in T_SYS_ORGANIZE INSERT !! resultCount = " + resultCount);
        }
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.doNew(): SQLException while inserting new organize; " + "organize_id = " + this.organizeID + " :\n\t" + se);
    } finally {
        closePreparedStatement (ps);
    }
}


public void alterarDisciplina (Disciplina disciplina) throws ClassNotFoundException, SQLException {
    this.criaConexao (false);
    String sql = "UPDATE \"Disciplina\"         " + "   SET \"Nome_Disciplina\" = ?" + " WHERE \"ID_Disciplina\"   = ?";
    PreparedStatement stmt = null;
    try {
        stmt = connection.prepareStatement (sql);
        stmt.setString (1, disciplina.getNome ());
        stmt.setString (2, disciplina.getId ());
        stmt.execute ();
        connection.commit ();
    } catch (SQLException e) {
        connection.rollback ();
        throw e;
    } finally {
        try {
            stmt.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
}


-----Function Pair=321=-----==

public Collection list () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select a.InstructionId, a.Type, b.Description, a.ExecuteString, a.Operator, " + "       c.Description, a.FrameSlot, a.LinkName, a.ObjectId, a.AttributeName " + "from Instructions a, InstructionTypes b, ConditionalOperators c " + "where a.Type = b.Type and a.Operator = c.Operator " + "order by InstructionId";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                int id = rs.getInt (1);
                int type = rs.getInt (2);
                String typeDescription = rs.getString (3);
                String executeString = rs.getString (4);
                if (rs.wasNull () == true) executeString = "";
                int operator = rs.getInt (5);
                String operatorDescription;
                if (operator == 0) operatorDescription = "";
                else operatorDescription = rs.getString (6);
                String frameSlot = rs.getString (7);
                if (rs.wasNull () == true) frameSlot = "";
                String linkName = rs.getString (8);
                if (rs.wasNull () == true) linkName = "";
                String attributeName = rs.getString (9);
                if (rs.wasNull () == true) attributeName = "";
                int objectId = rs.getInt (10);
                Instruction instruction = new Instruction (id, type, typeDescription, executeString, frameSlot, operator, operatorDescription, linkName, objectId, attributeName);
                list.add (instruction);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public RoleBean getRole (DatabaseAdapter db, Long roleId) {
    if (roleId == null) {
        return null;
    }
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        String sql = "select ID_ACCESS_GROUP, NAME_ACCESS_GROUP " + "from 	WM_AUTH_ACCESS_GROUP " + "where  ID_ACCESS_GROUP=? ";
        ps = db.prepareStatement (sql);
        ps.setLong (1, roleId);
        rs = ps.executeQuery ();
        RoleBean role = null;
        if (rs.next ()) {
            role = loadRoleFromResultSet (rs);
        }
        return role;
    } catch (Exception e) {
        String es = "Error load role for id: " + roleId;
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


-----Function Pair=322=-----==

public Vector getIsolatedOrganize () throws Exception {
    Vector allIsolatedOrg = new Vector ();
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT organize_id,organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_TABLE + " " + "WHERE (organize_id,organize_type_id) NOT IN " + "(SELECT organize_id,organize_type_id FROM " + Common.ORGANIZE_RELATION_TABLE + ") " + "AND (organize_id,organize_type_id) NOT IN " + "(SELECT child_id,child_type_id FROM " + Common.ORGANIZE_RELATION_TABLE + ")" + " ORDER BY show_order";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        int i = 1;
        ValueAsc va = new ValueAsc (i);
        while (result.next ()) {
            i = 1;
            va.setStart (i);
            Organize oTemp = Organize.generateOrganize (result, va);
            allIsolatedOrg.addElement (oTemp);
        }
        va = null;
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.getIsolatedOrganize(): SQLException:  " + se);
    } finally {
        close (dbo, ps, result);
    }
    return allIsolatedOrg;
}


public Collection purgeDeletes (String virtualWiki) throws Exception {
    PseudoTopicHandler pseudoTopicHandler = WikiBase.getInstance ().getPseudoTopicHandler ();
    Collection all = new ArrayList ();
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        for (Iterator i = Arrays.asList (new String [] {STATEMENT_TOPICS_TO_PURGE, STATEMENT_TEMPLATES_TO_PURGE}).iterator (); i.hasNext ();) {
            PreparedStatement stmt = conn.prepareStatement ((String) i.next ());
            stmt.setString (1, virtualWiki);
            ResultSet rs = stmt.executeQuery ();
            while (rs.next ()) {
                String topicName = rs.getString ("name");
                if (! pseudoTopicHandler.isPseudoTopic (topicName)) {
                    all.add (topicName);
                }
            }
            rs.close ();
            stmt.close ();
        }
        for (Iterator i = Arrays.asList (new String [] {STATEMENT_PURGE_TOPIC_DELETES, STATEMENT_PURGE_TEMPLATE_DELETES}).iterator (); i.hasNext ();) {
            PreparedStatement stmt = conn.prepareStatement ((String) i.next ());
            stmt.setString (1, virtualWiki);
            stmt.execute ();
            stmt.close ();
        }
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return all;
}


-----Function Pair=323=-----==

public boolean insertAccess (Access access) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (access);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


private void handleNodeUp (long eventID, long nodeID, String eventTime) {
    Category log = ThreadCategory.getInstance (OutageWriter.class);
    if (eventID == - 1 || nodeID == - 1) {
        log.warn (EventConstants.NODE_UP_EVENT_UEI + " ignored - info incomplete - eventid/nodeid: " + eventID + "/" + nodeID);
        return;
    }
    Connection dbConn = null;
    try {
        dbConn = DatabaseConnectionFactory.getInstance ().getConnection ();
        int count = 0;
        if (openOutageExists (dbConn, nodeID)) {
            try {
                dbConn.setAutoCommit (false);
            } catch (SQLException sqle) {
                log.error ("Unable to change database AutoCommit to FALSE", sqle);
                return;
            }
            PreparedStatement outageUpdater = dbConn.prepareStatement (OutageConstants.DB_UPDATE_OUTAGES_FOR_NODE);
            outageUpdater.setLong (1, eventID);
            outageUpdater.setTimestamp (2, convertEventTimeIntoTimestamp (eventTime));
            outageUpdater.setLong (3, nodeID);
            count = outageUpdater.executeUpdate ();
            outageUpdater.close ();
        }
        else {
            log.warn ("\'" + EventConstants.NODE_UP_EVENT_UEI + "\' for " + nodeID + " no open record.");
        }
        try {
            dbConn.commit ();
            if (log.isDebugEnabled ()) log.debug ("nodeUp closed " + count + " outages for nodeid " + nodeID + " in DB");
        } catch (SQLException se) {
            log.warn ("Rolling back transaction, nodeUp could not be recorded  for nodeId: " + nodeID, se);
            try {
                dbConn.rollback ();
            } catch (SQLException sqle) {
                log.warn ("SQL exception during rollback, reason", sqle);
            }
        }
    } catch (SQLException se) {
        log.warn ("SQL exception while handling \'nodeRegainedService\'", se);
    } finally {
        try {
            if (dbConn != null) dbConn.close ();
        } catch (SQLException e) {
            log.warn ("Exception closing JDBC connection", e);
        }
    }
}


-----Function Pair=324=-----==

public static int deleteDeletedChildrenBeforeStore (final IBaseModel model, final Set children, final IChainStore chain, final ServiceCall call) throws Exception {
    IDataMethod method = new IDataMethod () {
        public Object execute () throws Exception {
            int deleted = 0;
            List < IBaseModel > delscreens = new ArrayList < IBaseModel > ();
            for (Object o : children) {
                IBaseModel child = (IBaseModel) o;
                if (model.isDeleted () || child.isDeleted ()) {
                    if (child.isNotNew ()) {
                        call.debug ("store removes" + child.getClass ().getSimpleName () + " " + child.getId ());
                        delscreens.add (child);
                        deleted ++;
                    }
                    else {
                        delscreens.add (child);
                        deleted ++;
                    }
                }
            }
            children.removeAll (delscreens);
            return deleted;
        }
    }
    ;
    return (Integer) call (method, call);
}


public RestServiceResult update (RestServiceResult serviceResult, MaSpellError maSpellError) {
    MaSpellErrorDAO maSpellErrorDAO = new MaSpellErrorDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        maSpellErrorDAO.update (maSpellError);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSpellError);
        Object [] args = {maSpellError.getWrongWord ()};
        if (bundle != null) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("spellerror.update.success"), args));
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el error: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("spellerror.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=325=-----==

public int update (String strUpdate, Map < String, Object > mapVal) throws RuntimeException {
    int rtnVal = 0;
    EntityManager em = getEntityManager ();
    if (em != null) {
        EntityTransaction et = em.getTransaction ();
        try {
            Query query = em.createQuery (strUpdate);
            if (mapVal != null) {
                for (String mKey : mapVal.keySet ()) {
                    Object mObj = mapVal.get (mKey);
                    query.setParameter (mKey, mObj);
                }
            }
            if (query != null) {
                if (et.isActive () == false) {
                    et.begin ();
                }
                rtnVal = query.executeUpdate ();
                if (et.isActive ()) {
                    et.commit ();
                }
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            em.close ();
            throw new RuntimeException (exception);
        }
        em.close ();
    }
    return rtnVal;
}


public void inputPower (String [] sqlInfo) {
    if (sqlInfo == null || sqlInfo.length == 0) return;
    DbConn conn = new DbConn ();
    try {
        conn.setAutoCommit (false);
        String sql = "delete from t_power_info";
        conn.prepare (sql);
        conn.executeUpdate ();
        for (int i = 0; i < sqlInfo.length; i ++) {
            conn.prepare (sqlInfo [i]);
            conn.executeUpdate ();
        }
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        try {
            conn.rollback ();
            conn.setAutoCommit (true);
        } catch (Exception sex) {
            sex.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=326=-----==

public static SQLFunction getSQLFunction (String applicationId) throws Exception {
    String dbType = getDBType (applicationId);
    if (dbType.equals (DBTYPE_ORACLE)) {
        return new OracleSQLFunction ();
    }
    else if (dbType.equals (DBTYPE_MSSQL)) {
        return new MssqlSQLFunction ();
    }
    else if (dbType.equals (DBTYPE_MYSQL)) {
        return new MysqlSQLFunction ();
    }
    else if (dbType.equals (DBTYPE_HSQLDB)) {
        return new HsqldbSQLFunction ();
    }
    else if (dbType.equals (DBTYPE_DB2)) {
        return new DB2SQLFunction ();
    }
    return null;
}


public void criar (QuestaoMultiplaEscolha q) throws Exception {
    PreparedStatement stmt = null;
    String sql = "INSERT INTO questao (id_disciplina, enunciado, grau_dificuldade) VALUES (?,?,?) returning id_questao";
    try {
        stmt = conexao.prepareStatement (sql);
        stmt.setInt (1, q.getDisciplina ().getIdDisciplina ());
        stmt.setString (2, q.getEnunciado ());
        stmt.setString (3, q.getDificuldade ().name ());
        ResultSet rs = stmt.executeQuery ();
        conexao.commit ();
        if (rs.next ()) {
            q.setIdQuestao (rs.getInt ("id_questao"));
        }
        criarQuestaoMultiplaEscolha (q);
        for (Topico item : q.getTopicos ()) {
            criarTopicoQuestao (q, item.getIdTopico ());
            System.out.println ("topico" + item.getNmTopico ());
        }
    } catch (SQLException e) {
        conexao.rollback ();
        throw e;
    }
}


-----Function Pair=327=-----==

public Validating findValidatingById (int id) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Validating validating = (Validating) session.get (Validating.class, id);
        tr.commit ();
        return validating;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public boolean deleteSpacecaches (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Spacecaches s where s.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=328=-----==

public boolean deleteRanks (Ranks rank) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.delete (rank);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public void testTYPE () {
    try {
        EntityManager em = getEM ();
        EntityTransaction tx = em.getTransaction ();
        try {
            tx.begin ();
            Person p = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
            em.persist (p);
            Employee e = new Employee (102, "Barney", "Rubble", "barney.rubble@jpox.com", 10000.0f, "12345");
            em.persist (e);
            em.flush ();
            List result = em.createQuery ("SELECT Object(p) FROM " + Person.class.getName () + " p WHERE TYPE(p) <> Employee_Ann").getResultList ();
            assertEquals (1, result.size ());
            tx.rollback ();
        } finally {
            if (tx.isActive ()) {
                tx.rollback ();
            }
            em.close ();
        }
    } finally {
        clean (Employee.class);
        clean (Person.class);
    }
}


-----Function Pair=329=-----==

public static String getSchema (Connection conn, String dbType) {
    if (dbType.equals (DBTYPE_ORACLE) || dbType.equals (DBTYPE_DB2)) {
        try {
            return conn.getMetaData ().getUserName ().trim ().toUpperCase ();
        } catch (SQLException sqle) {
            return "";
        }
    }
    else if (dbType.equals (DBTYPE_MYSQL)) {
        try {
            String schema = conn.getMetaData ().getURL ().trim ().toUpperCase ();
            if (schema.indexOf ("?USE") > 0) {
                schema = schema.substring (schema.lastIndexOf ("/") + 1, schema.indexOf ("?USE"));
            }
            else {
                schema = schema.substring (schema.lastIndexOf ("/") + 1);
            }
            return schema;
        } catch (SQLException sqle) {
            return "";
        }
    }
    else if (dbType.equals (DBTYPE_MSSQL)) {
        try {
            ResultSet rs = conn.getMetaData ().getSchemas ();
            if (rs != null) {
                if (rs.next ()) return rs.getString (1).trim ().toUpperCase ();
            }
        } catch (SQLException sqle) {
            return "";
        }
    }
    else if (dbType.equals (DBTYPE_HSQLDB)) {
        return "public".toUpperCase ();
    }
    return "";
}


public boolean isEmpty () {
    boolean empty = true;
    Session session = sessionFactory.openSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query select = session.createQuery ("select count(*) from Task task");
        List result = select.list ();
        if (Integer.parseInt (result.get (0).toString ()) > 0) {
            empty = false;
        }
        session.flush ();
        session.clear ();
        tx.commit ();
    } catch (RuntimeException e) {
        tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
    return empty;
}


-----Function Pair=330=-----==

public void modify (String name, int row, int objectId) throws FidoDatabaseException, ObjectNotFoundException, ProperNounNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            ObjectTable ot = new ObjectTable ();
            if (ot.contains (objectId) == false) throw new ObjectNotFoundException (objectId);
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            int max = findMaxRank (stmt, name);
            if ((row < 1) || (row > max)) throw new IllegalArgumentException ("Row number not between 1 and " + max);
            String sql = "update ProperNouns set ObjectId = " + objectId + " " + "where Noun = '" + name + "' and SenseNumber = " + row;
            int rows = stmt.executeUpdate (sql);
            if (rows == 0) throw new ProperNounNotFoundException (name);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public Job getJob (long id) {
    Job job = null;
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + JOB_TABLE + " o  where o.id =:id");
        query.setLong ("id", id);
        job = (Job) query.uniqueResult ();
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return job;
}


-----Function Pair=331=-----==

private static void salvarCategoria (Categoria categoria) throws Exception {
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = C3P0Pool.getConnection ();
        String sql = "insert into categoria VALUES (?,?)";
        ps = conn.prepareStatement (sql);
        ps.setNull (1, Types.INTEGER);
        ps.setString (2, categoria.getNome ());
        ps.executeUpdate ();
        conn.commit ();
    } catch (Exception e) {
        if (conn != null) conn.rollback ();
        throw e;
    } finally {
        close (conn, ps);
    }
}


public FileBean load (long id) throws SQLException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Connection conn = null;
    FileBean fileBean = null;
    try {
        DataSource ds = getDataSource (DEFAULT_DATASOURCE);
        conn = ds.getConnection ();
        if (log.isDebugEnabled ()) {
            log.debug ("FileDAOImpl.load() " + SELECT_FILE_BY_ID);
        }
        pstmt = conn.prepareStatement (SELECT_FILE_BY_ID);
        pstmt.setLong (1, id);
        pstmt.execute ();
        rs = pstmt.getResultSet ();
        while (rs.next ()) {
            fileBean = new FileBean ();
            fileBean.setAbsolutePath (rs.getString (ABSOLUTE_PATH));
            fileBean.setCrdate (rs.getTimestamp (CR_DATE));
            fileBean.setId (rs.getLong (FILE_ID));
            fileBean.setMimeTypeId (rs.getLong (MIMETYPE_ID));
            fileBean.setName (rs.getString (NAME));
            fileBean.setStatus (rs.getShort (STATUS));
            fileBean.setStorageId (rs.getLong (SAN_ID));
            fileBean.setUpdate (rs.getTimestamp (UP_DATE));
        }
    } catch (SQLException e) {
        log.error ("FileDAOImpl.load() : erreur technique", e);
        throw e;
    } finally {
        closeRessources (conn, pstmt, rs);
    }
    return fileBean;
}


-----Function Pair=332=-----==

public String getSetting (String var, String defaultVal) {
    String qry = "SELECT val FROM settings WHERE var = ?";
    PreparedStatement pstmt = null;
    ResultSet rset = null;
    try {
        pstmt = conn.prepareStatement (qry);
        logQry (qry, var);
        pstmt.setString (1, var);
        rset = pstmt.executeQuery ();
        if (rset.next ()) return rset.getString (1);
        return defaultVal;
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
        return defaultVal;
    } finally {
        try {
            if (rset != null) rset.close ();
            if (pstmt != null) pstmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


public void run () {
    ThreadCategory.setPrefix (getName ());
    log ().info ("Vacuumd scheduling started");
    long now = System.currentTimeMillis ();
    long period = getVacuumdConfig ().getPeriod ();
    log ().info ("Vacuumd sleeping until time to execute statements period = " + period);
    long waitTime = 500L;
    while (! m_stopped) {
        try {
            now = waitPeriod (now, period, waitTime);
            log ().info ("Vacuumd beginning to execute statements");
            executeStatements ();
            m_startTime = System.currentTimeMillis ();
        } catch (Exception e) {
            log ().error ("Unexpected exception: ", e);
        }
    }
}


-----Function Pair=333=-----==

public HashSet < AcademicYear > findAll () throws DBConnectionException, SelectException {
    HashSet < AcademicYear > acaYearList = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (AcademicYearDAO.TABLE_NAME).toString ());
        if (result != null) {
            acaYearList = new HashSet < AcademicYear > ();
            while (result.next ()) {
                AcademicYear acaYear = new AcademicYear ();
                acaYear.setId (result.getInt ("ACADEMIC_YEAR_ID"));
                acaYear.setName (result.getString ("ACADEMIC_YEAR_NAME"));
                acaYearList.add (acaYear);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return acaYearList;
}


public String [] getAllLogins () throws IOException {
    try {
        final List < String > logins = new ArrayList < String > ();
        Connection conn = null;
        try {
            conn = pool.getConnection ();
            final PreparedStatement select = conn.prepareStatement ("select userId from users");
            final ResultSet rs = select.executeQuery ();
            while (rs.next ()) {
                logins.add (rs.getString (1));
            }
            return logins.toArray (new String [0]);
        } finally {
            if (conn != null) conn.close ();
        }
    } catch (final SQLException sqle) {
        log.log (Level.SEVERE, sqle.toString (), sqle);
        throw new IOException (sqle.toString ());
    }
}


-----Function Pair=334=-----=1=

public int delete (BusinessObject o) throws DAOException {
    int delete = 0;
    Item item = (Item) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("DELETE_ITEM"));
        pst.setInt (1, item.getId ());
        delete = pst.executeUpdate ();
        if (delete <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (delete > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return delete;
}


public void testPersistor () throws Exception {
    PreparedStatement ps;
    ps = connection.prepareStatement ("delete from privatadresse");
    ps.executeUpdate ();
    ps.close ();
    ps = connection.prepareStatement ("delete from adresse");
    ps.executeUpdate ();
    ps.close ();
    ps = connection.prepareStatement ("delete from person");
    ps.executeUpdate ();
    ps.close ();
    Persistor p;
    Adresse csd = new LieferAdresse ();
    csd.setStrasse ("Amalienstrasse 68");
    modificationTracker.addNewParticipant (csd);
    Person markus = new Person ();
    markus.setName ("markus");
    modificationTracker.addNewParticipant (markus);
    markus.getPrivatAdressen ().add (csd);
    Person martin = new Person ();
    martin.setName ("martin");
    modificationTracker.addNewParticipant (martin);
    p = new Persistor (getSchemaMapping (), idGenerator, modificationTracker);
    p.persist ();
    Adresse bia = new LieferAdresse ();
    modificationTracker.addNewParticipant (bia);
    bia.setStrasse ("dr. boehringer gasse");
    markus.getAdressen ().add (bia);
    bia.setPerson (martin);
    markus.setContactPerson (martin);
    p = new Persistor (getSchemaMapping (), idGenerator, modificationTracker);
    try {
        p.persist ();
        connection.commit ();
    } catch (Exception e) {
        connection.rollback ();
        throw e;
    }
}


-----Function Pair=335=-----==

public RestServiceResult create (RestServiceResult serviceResult, MaSyntaticError maSyntaticError) {
    MaSyntaticErrorDAO maSyntaticErrorDAO = new MaSyntaticErrorDAO ();
    try {
        maSyntaticError.setErrorId (getSequence ("sq_ma_syntatic_error"));
        EntityManagerHelper.beginTransaction ();
        maSyntaticErrorDAO.save (maSyntaticError);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSyntaticError);
        log.info ("Error sintactico creado con �xito: " + maSyntaticError.getWrongSentence ());
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el error sintactico: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void testStringLength () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p);
        em.flush ();
        List result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE LENGTH(P.firstName) > 3").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=336=-----==

public synchronized boolean initialize () throws SQLException {
    boolean createTables = false;
    if (! databaseHome.exists ()) {
        createTables = true;
    }
    ensureConnection ();
    if (createTables) {
        InputStream initStream = EmbeddedDatabase.class.getResourceAsStream ("dbinit.sql");
        try {
            BufferedReader reader = new BufferedReader (new InputStreamReader (initStream));
            StringBuilder sqlBuffer = new StringBuilder ("");
            while (reader.ready ()) {
                String line = reader.readLine ();
                if (line.length () == 0) {
                    try {
                        if (sqlBuffer.length () > 0) {
                            executeStatement (sqlBuffer.toString ());
                        }
                    } finally {
                        sqlBuffer.setLength (0);
                    }
                }
                else {
                    sqlBuffer.append (line);
                    sqlBuffer.append (' ');
                }
            }
            if (sqlBuffer.length () > 0) {
                executeStatement (sqlBuffer.toString ());
            }
            executeStatement (SERVICE_INSTALL_UNKNOWN);
        } catch (IOException error) {
            SQLException sqlError = new SQLException (error.getMessage ());
            BasicUtilities.wrapThrowable (error, sqlError);
            throw sqlError;
        }
    }
    return createTables;
}


public static Vector retrieve (String usrlogin) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("tab_id");
        r.add ("tab_title");
        r.add ("display_type");
        r.add ("user_login", usrlogin);
        sql = r.getSQLSelect ("tab", "sequence");
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            String id = rs.getString ("tab_id");
            String title = rs.getString ("tab_title");
            String displaytype = rs.getString ("display_type");
            v.addElement (new Tab (id, title, displaytype));
        }
        return v;
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=337=-----==

public void reportDone () {
    long end_time = System.currentTimeMillis ();
    double completion_time = ((double) end_time - (double) start_time) / 1000;
    System.out.println ("\n* Benchmark Report *");
    System.out.print ("* Featuring ");
    if (prepared_stmt) {
        System.out.print ("<prepared statements> ");
    }
    else {
        System.out.print ("<direct queries> ");
    }
    if (transactions) {
        System.out.print ("<transactions> ");
    }
    else {
        System.out.print ("<auto-commit> ");
    }
    System.out.println ("\n--------------------");
    System.out.println ("Time to execute " + transaction_count + " transactions: " + completion_time + " seconds.");
    System.out.println (failed_transactions + " / " + transaction_count + " failed to complete.");
    double rate = (transaction_count - failed_transactions) / completion_time;
    System.out.println ("Transaction rate: " + rate + " txn/sec.");
    transaction_count = 0;
    failed_transactions = 0;
    System.gc ();
}


public List < Notificacao > getNotificacoesAtividade (Atividade atividade) throws SQLException {
    List < Notificacao > notificacoes = new ArrayList < Notificacao > ();
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Notificacao a where a.atividade_idatividade =" + atividade.getIdAtividade ();
        ResultSet rs = stmt.executeQuery (sqlSelect);
        Notificacao notificacaoList = null;
        while (rs.next ()) {
            notificacaoList = new Notificacao ();
            notificacaoList.setConteudo (rs.getString ("conteudo"));
            notificacaoList.setIdNotificacao (rs.getInt ("idnotificacao"));
            notificacaoList.setAtividade (atividade);
            notificacoes.add (notificacaoList);
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return notificacoes;
}


-----Function Pair=338=-----==

public JDBCUsersAndGroupsStore (String name, SitoolsDataSource ds) throws SitoolsException {
    this.name = name;
    this.ds = ds;
    try {
        ds.getConnection ();
    } catch (SQLException e) {
        throw new SitoolsException ("User database connection error", e);
    }
    if (ds.getDsModel ().getDriverClass ().equals ("org.postgresql.Driver")) {
        jdbcStoreResource = new PGSQLUsersAndGroupsStoreResource (ds);
    }
    else if (ds.getDsModel ().getDriverClass ().equals ("org.gjt.mm.mysql.Driver")) {
        jdbcStoreResource = new MYSQLUsersAndGroupsStoreResource ();
    }
    else {
        logger.severe ("Incorrect JDBC Driver for JDBCUsersAndGroupsStore file");
    }
}


public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


-----Function Pair=339=-----==

public Document getDocument (String documentId) {
    logger.debug ("getDocument(%s)", documentId);
    Connection connection = null;
    NamedParameterStatement statement = null;
    ResultSet documentRS = null;
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.SELECT_DOCUMENT));
        statement.setString (QueryStore.SELECT_DOCUMENT_PARAM_ID_DOCUMENT, documentId);
        documentRS = statement.executeQuery ();
        if (documentRS != null && documentRS.next ()) {
            Document document = new Document ();
            document.setId (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_ID));
            document.setState (documentRS.getInt (QueryStore.SELECT_DOCUMENT_RESULTSET_STATE));
            document.setDeprecated (documentRS.getBoolean (QueryStore.SELECT_DOCUMENT_RESULTSET_IS_DEPRECATED));
            Template template = new Template ();
            template.setCode (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_TEMPLATE_CODE));
            template.setId (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_ID));
            document.setTemplate (template);
            return document;
        }
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (documentRS);
        close (statement);
        close (connection);
    }
    throw new ApplicationException (String.format ("Document '%s' not found", documentId));
}


private synchronized void deleteObject (Object o) throws GridBrokerException {
    synchronized (o) {
        Transaction t = null;
        Session s = null;
        try {
            s = getSession ();
            t = s.beginTransaction ();
            s.delete (o);
            t.commit ();
        } catch (Exception e) {
            if (t != null && t.isActive ()) {
                t.rollback ();
            }
            throw new GridBrokerException ("Error deleting object: " + e.getMessage (), e);
        } finally {
            closeSession (s);
        }
    }
}


-----Function Pair=340=-----==

public void restore (Component component, String componentName, int currentPilot) {
    try {
        PreparedStatement psta = jdbc.prepareStatement ("SELECT size_height, size_width, pos_x, pos_y " + "FROM component_prop " + "WHERE pilot_id = ? " + "AND component_name = ?");
        psta.setInt (1, currentPilot);
        psta.setString (2, componentName);
        ResultSet resl = psta.executeQuery ();
        if (resl.next ()) {
            component.setSize (resl.getInt (2), resl.getInt (1));
            Point point = new Point (resl.getInt (3), resl.getInt (4));
            component.setLocation (point);
        }
    } catch (SQLException e) {
        log.debug (e);
    }
}


public static Any getNMR (Connection con, Any values, Any retValue) throws SQLException {
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getNMR");
    PreparedStatement stmt = con.prepareStatement (sSql);
    ResultSet rSet = stmt.executeQuery ();
    ArrayList < HashMap > arMaps = new ArrayList < HashMap > ();
    while (rSet.next ()) {
        HashMap map = new HashMap ();
        map.put ("1", rSet.getString ("CAUTONUM"));
        map.put ("2", rSet.getString ("CNUMMASK"));
        map.put ("3", rSet.getString ("ILASTNUM"));
        arMaps.add (map);
    }
    rSet.close ();
    stmt.close ();
    retValue.insert_Value (arMaps.toArray (new HashMap [arMaps.size ()]));
    return retValue;
}


-----Function Pair=341=-----==

public boolean removeService (ServiceReference reference) throws SQLException {
    ensureConnection ();
    PreparedStatement statement = null;
    try {
        statement = embeddedConnection.prepareStatement (SERVICE_DELETE);
        statement.setLong (1, reference.getId ());
        int affectedCount = statement.executeUpdate ();
        statement.close ();
        statement = embeddedConnection.prepareStatement (HISTORY_DELETE_SERVICE);
        statement.setLong (1, reference.getId ());
        statement.executeUpdate ();
        return affectedCount == 1;
    } catch (SQLException sqle) {
        if (NO_DATA_AVAILABLE.equals (sqle.getSQLState ())) {
            return false;
        }
        throw sqle;
    } finally {
        if (statement != null) {
            try {
                statement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


private final void createPropertyAuth (Authorize auth, String property, String partner) {
    Authorize.Property p = new Authorize.Property ();
    auth.addProperty (p);
    p.setName (property);
    Partner pa;
    p.addPartner (pa = new Partner ());
    pa.setString (partner);
    pa.setAction (Partner.Action.GRANT);
    pa.setValue (Partner.Value.READ);
    p.addPartner (pa = new Partner ());
    pa.setString (partner);
    pa.setAction (Partner.Action.GRANT);
    pa.setValue (Partner.Value.WRITE);
    p.addPartner (pa = new Partner ());
    pa.setString (partner);
    pa.setAction (Partner.Action.GRANT);
    pa.setValue (Partner.Value.AUTH);
}


-----Function Pair=342=-----==

public void testLongStatement () throws Exception {
    Statement stmt = con.createStatement (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
    stmt.execute ("CREATE TABLE #longStatement (id int primary key, data varchar(8000))");
    StringBuffer buf = new StringBuffer (4096);
    buf.append ("SELECT * FROM #longStatement WHERE data = '");
    for (int i = 0; i < 4000; i ++) {
        buf.append ('X');
    }
    buf.append ("'");
    ResultSet rs = stmt.executeQuery (buf.toString ());
    assertNotNull (rs);
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
}


public synchronized void deleteCallStatistics (Integer elementId, String contextName, String category, String project, String name, Date dateFrom, Date dateTo, Boolean extractException, String principal) throws DatabaseException {
    final Connection connection = this.getConnection ();
    try {
        connection.setAutoCommit (false);
        String queryString = "DELETE " + this.getCallInvocationsSchemaAndTableName () + " FROM " + this.getCallInvocationsSchemaAndTableName () + " INNER JOIN " + this.getCallElementsSchemaAndTableName () + " ON " + this.getCallElementsSchemaAndTableName () + ".element_id =  " + this.getCallInvocationsSchemaAndTableName () + ".element_id ";
        if (principal != null) {
            queryString = queryString + "LEFT JOIN " + this.getCallPrincipalsSchemaAndTableName () + " ON " + this.getCallInvocationsSchemaAndTableName () + ".principal_id = " + this.getCallPrincipalsSchemaAndTableName () + ".principal_id ";
        }
        queryString = queryString + "WHERE ";
        if (elementId != null) {
            queryString = queryString + this.getCallElementsSchemaAndTableName () + ".elementId = ? AND ";
        }
        if (contextName != null) {
            queryString = queryString + this.getCallElementsSchemaAndTableName () + ".context_name LIKE ? AND ";
        }
        if ((category != null)) {
            queryString = queryString + this.getCallElementsSchemaAndTableName () + ".category LIKE ? AND ";
        }
        if ((project != null)) {
            queryString = queryString + this.getCallElementsSchemaAndTableName () + ".project LIKE ? AND ";
        }
        if ((name != null)) {
            queryString = queryString + this.getCallElementsSchemaAndTableName () + ".name LIKE ? AND ";
        }
        if (dateFrom != null) {
            queryString = queryString + this.getCallInvocationsSchemaAndTableName () + ".start_timestamp >= ? AND ";
        }
        if (dateTo != null) {
            queryString = queryString + this.getCallInvocationsSchemaAndTableName () + ".start_timestamp <= ? AND ";
        }
        if (principal != null) {
            queryString = queryString + this.getCallPrincipalsSchemaAndTableName () + ".principal_name LIKE ? AND ";
        }
        if (extractException != null) {
            if (extractException.booleanValue ()) {
                queryString = queryString + this.getCallInvocationsSchemaAndTableName () + ".exception_id IS NOT NULL AND ";
            }
            else {
                queryString = queryString + this.getCallInvocationsSchemaAndTableName () + ".exception_id IS NULL AND ";
            }
        }
        queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect (queryString);
        final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement (connection, queryString);
        int indexCounter = 1;
        if (elementId != null) {
            preparedStatement.setLong (indexCounter, elementId.longValue ());
            indexCounter = indexCounter + 1;
        }
        if (contextName != null) {
            preparedStatement.setString (indexCounter, contextName);
            indexCounter = indexCounter + 1;
        }
        if ((category != null)) {
            preparedStatement.setString (indexCounter, category);
            indexCounter = indexCounter + 1;
        }
        if ((project != null)) {
            preparedStatement.setString (indexCounter, project);
            indexCounter = indexCounter + 1;
        }
        if ((name != null)) {
            preparedStatement.setString (indexCounter, name);
            indexCounter = indexCounter + 1;
        }
        if (dateFrom != null) {
            preparedStatement.setTimestamp (indexCounter, new Timestamp (dateFrom.getTime ()));
            indexCounter = indexCounter + 1;
        }
        if (dateTo != null) {
            preparedStatement.setTimestamp (indexCounter, new Timestamp (dateTo.getTime ()));
            indexCounter = indexCounter + 1;
        }
        if (principal != null) {
            preparedStatement.setString (indexCounter, principal);
            indexCounter = indexCounter + 1;
        }
        preparedStatement.executeUpdate ();
        preparedStatement.close ();
        connection.commit ();
    } catch (final SQLException e) {
        try {
            connection.rollback ();
        } catch (final SQLException ex) {
            JeeObserverServerContext.logger.log (Level.SEVERE, "Transaction rollback error.", ex);
        }
        JeeObserverServerContext.logger.log (Level.SEVERE, e.getMessage ());
        throw new DatabaseException ("Error deleting call statistics.", e);
    } finally {
        this.releaseConnection (connection);
    }
}


-----Function Pair=343=-----==

public static int getSize (final Connection conn, final String table, final String where, final Object [] params) throws SQLException {
    int size = 0;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        final String sql = "select count(*) from " + table + " where " + where;
        ps = conn.prepareStatement (sql);
        buildStatement (ps, params);
        rs = ps.executeQuery ();
        if (rs.next ()) {
            size = rs.getInt (1);
        }
    } finally {
        closeAll (rs, ps, null);
    }
    return size;
}


public void delete (Semester obj) throws DeleteException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria critDel = new Criteria ();
    critDel.addCriterion ("SEMESTER_ID", obj.getId ());
    try {
        stmt.executeUpdate (new DeleteQuery (TABLE_NAME, critDel).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new DeleteException (TABLE_NAME + " Deletion exception :", e);
    }
}


-----Function Pair=344=-----==

private static void shuffle (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        Person person1 = list.iterator ().next ();
        Person person2 = new Person ();
        person2.setFirstName ("William");
        person2.setLastName ("Bush");
        Address address = person1.getAddresses ().iterator ().next ();
        person1.getAddresses ().remove (address);
        person2.getAddresses ().add (address);
        session.save (person2);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public static void saveTabsOrderPersonal (String [] tabIds, String user) throws Exception {
    if (tabIds == null) return;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        int seq = 0;
        for (String tabId : tabIds) {
            sql = "update tabs set sequence = " + seq ++ + " where tab_id = '" + tabId + "' and user_login = '" + user + "'";
            db.getStatement ().executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=345=-----==

public boolean sendMessage (mail mail) {
    boolean result = false;
    PreparedStatement pstmt;
    try {
        pstmt = getCon ().prepareStatement ("insert into mail(toid,fromid,pmdatetime,title,content,stat,gname) values (?,?,?,?,?,?,?)");
        pstmt.setString (1, mail.getToid ());
        pstmt.setString (2, mail.getFromid ());
        pstmt.setString (3, mail.getPmdatetime ());
        pstmt.setString (4, mail.getTitle ());
        pstmt.setString (5, mail.getContent ());
        pstmt.setString (6, mail.getStat ());
        pstmt.setString (7, mail.getGname ());
        int num = pstmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return result;
}


public List < Reading > get () {
    Session sessao = getSession ().getCurrentSession ();
    Transaction transacao = sessao.beginTransaction ();
    List < Reading > resultados = null;
    try {
        Query query = sessao.createQuery ("from Reading r");
        resultados = query.list ();
        transacao.commit ();
    } catch (Exception e) {
        e.printStackTrace ();
        transacao.rollback ();
    }
    return resultados;
}


-----Function Pair=346=-----==

void execute (Connection conn, Component parent, String context, ProgressMonitor progressBar, ProgressWrapper progressWrapper) throws Exception {
    Statement statement = null;
    try {
        conn.setAutoCommit (false);
        statement = conn.createStatement ();
        String deleteSql = getDeleteSql (m_compositionId);
        statement.executeUpdate (deleteSql);
        conn.commit ();
        s_compostionCache.delete (new Integer (m_compositionId));
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
        throw ex;
    } finally {
        if (statement != null) {
            statement.close ();
        }
    }
}


protected void getDependencyMatrix (String matrixName, LocalConstraint lc, GlobalConstraints gcs) {
    int i = 1;
    int arity = gcs.size ();
    try {
        for (GlobalConstraint gc : gcs) {
            if (lc.isInvolved (gc)) {
                String query = "UPDATE " + name + " SET m" + i + "=true WHERE key1 IN (" + gc.rKeyString () + ")";
                logger.info ("Adding constraint " + i + " into dependency matrix ");
                executeQuery (query);
                i ++;
            }
        }
    } catch (Exception e2) {
        logger.fatal (e2);
    }
}


-----Function Pair=347=-----==

public boolean updateResource (String rname, String desc, String stat, String gname, int rid) {
    boolean ok = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("update resource set rname=?,desc=?, stat=?,gname=? where aid=?");
        stmt.setString (1, rname);
        stmt.setString (2, desc);
        stmt.setString (3, stat);
        stmt.setString (4, gname);
        stmt.setInt (5, rid);
        int num = stmt.executeUpdate ();
        if (num == 1) {
            ok = true;
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return ok;
}


private void handleDatabasePort (Properties p, String port) {
    String portKey = ":${database.connection.port}";
    String connectionString = p.getProperty (ConfigKeys.DATABASE_CONNECTION_STRING);
    if (port == null || port.trim ().length () == 0) {
        int index = connectionString.indexOf (portKey);
        if (index > - 1) {
            if (connectionString.charAt (index - 1) == '\\') {
                connectionString = connectionString.replaceAll ("\\" + portKey, "");
            }
            else {
                connectionString = connectionString.replaceAll (portKey, "");
            }
        }
    }
    else if (connectionString.indexOf (portKey) == - 1) {
        String hostKey = "${database.connection.host}";
        connectionString = StringUtils.replace (connectionString, hostKey, hostKey + portKey);
    }
    p.setProperty (ConfigKeys.DATABASE_CONNECTION_STRING, connectionString);
}


-----Function Pair=348=-----==

public static Vector retrievePersonal (String usrlogin, String tab) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        sql = "SELECT m.module_id, m.module_title, m.module_class, u.module_custom_title, u.column_number " + "FROM module m, user_module u " + "WHERE m.module_id = u.module_id " + "AND u.user_login = '" + usrlogin + "' " + "AND u.tab_id = '" + tab + "' order by u.sequence";
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            String id = rs.getString ("module_id");
            String title = rs.getString ("module_title");
            String mclass = rs.getString ("module_class");
            String custom_title = rs.getString ("module_custom_title");
            int col = rs.getInt ("column_number");
            if (custom_title == null || "".equals (custom_title)) custom_title = title;
            v.addElement (new Module2 (id, title, mclass, custom_title, col));
        }
        return v;
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public String validSeriouseWord (String content) {
    String seriouseWord = null;
    if (content == null || content.length () == 0) {
        return seriouseWord;
    }
    Set ls = getSeriousWordSet ();
    Iterator it = ls.iterator ();
    while (it.hasNext ()) {
        String wds = (String) it.next ();
        int i = content.indexOf (wds);
        if (i != - 1) {
            seriouseWord = wds;
            break;
        }
    }
    return seriouseWord;
}


-----Function Pair=349=-----==

public void init (Context config) throws InitialisationException {
    Widget w = new DataMenuWidget ("Customer", "Customer", "You. If this is wrong, please log out", "select Customer, Salutation, forenames, surname " + "from customer order by surname");
    w.setImmutable (true);
    w.setMandatory (true);
    addWidget (w);
    w = new CurrencyWidget ("Total", "Total", "The total amount we will charge to your card");
    w.setImmutable (true);
    addWidget (w);
    w = new SimpleDataMenuWidget ("CreditType", "Card Type", "The type of credit card you are using", "CREDITTYPE", "CreditType", "CreditType");
    w.setMandatory (true);
    addWidget (w);
    w = new Widget ("CreditCN", "Card Number", "The number on your card");
    w.setMandatory (true);
    w.setSize (20);
    addWidget (w);
    w = new Widget ("NameOnCard", "Name on Card", "Your name, exactly as it appears on the credit card");
    w.setSize (40);
    w.setMandatory (true);
    addWidget (w);
    DateWidget dw = new DateWidget ("Expires", "Expires end", "The date when your credit card expires");
    dw.showDayWidget = false;
    dw.setMandatory (true);
    addWidget (dw);
    MenuWidget mw = new DataMenuWidget ("Address", "Card address", "The address to which your credit card is " + "registered", "select address, line1 from address", false, false);
    mw.addOption (new MenuOption ("Use the address below", mw));
    mw.setMandatory (true);
    addWidget (mw);
    w = new Widget ("Line1", "Address", "The address. Complete this only is you weren't able " + "to find the address you want in the menus above");
    w.setSize (64);
    addWidget (w);
    w = new Widget ("Line2", "(continued)", "");
    w.setSize (64);
    addWidget (w);
    w = new Widget ("Line3", "(continued)", "");
    w.setSize (64);
    addWidget (w);
    w = new Widget ("PostCode", "Post Code", "The postal code of this address");
    w.setSize (12);
    addWidget (w);
    mw = new SimpleDataMenuWidget ("Country", "Country", "The country where this address is", "COUNTRY", "Country", "Name");
    mw.setDefault ("UK");
    mw.setSize (5);
    addWidget (mw);
    addWidget (new BuyWidget ());
    super.init (config);
}


public static void insertTableData (Connection dest, TableMetaData tableMetaData) throws Exception {
    PreparedStatement ps = null;
    try {
        dest.setAutoCommit (false);
        String sql = "INSERT INTO " + tableMetaData.getSchema () + "." + tableMetaData.getTableName () + " (";
        for (String columnName : tableMetaData.getColumnsNames ()) {
            sql += columnName + ",";
        }
        sql = sql.substring (0, sql.length () - 1);
        sql += ") VALUES (";
        for (String columnName : tableMetaData.getColumnsNames ()) {
            sql += "?" + ",";
        }
        sql = sql.substring (0, sql.length () - 1);
        sql += ")";
        IOHelper.writeInfo (sql);
        ps = dest.prepareStatement (sql);
        for (Row r : tableMetaData.getData ()) {
            try {
                int param = 1;
                for (String columnName : tableMetaData.getColumnsNames ()) {
                    if (dest instanceof OracleConnection) {
                        if (tableMetaData.getColumnsTypes ().get (columnName).equalsIgnoreCase ("BLOB")) {
                            BLOB blob = new BLOB ((OracleConnection) dest, (byte []) r.getRowData ().get (columnName));
                            ((OraclePreparedStatement) ps).setBLOB (param, blob);
                        }
                        else if (tableMetaData.getColumnsTypes ().get (columnName).equalsIgnoreCase ("CLOB")) {
                            ((OraclePreparedStatement) ps).setStringForClob (param, (String) r.getRowData ().get (columnName));
                        }
                        else if (tableMetaData.getColumnsTypes ().get (columnName).equalsIgnoreCase ("LONG")) {
                            ps.setBytes (param, (byte []) r.getRowData ().get (columnName));
                        }
                    }
                    else {
                        IOHelper.writeInfo (columnName + " = " + r.getRowData ().get (columnName));
                        ps.setObject (param, r.getRowData ().get (columnName));
                    }
                    param ++;
                }
                if (ps.executeUpdate () != 1) {
                    dest.rollback ();
                    updateTableData (dest, tableMetaData, r);
                }
            } catch (Exception ex) {
                try {
                    dest.rollback ();
                    updateTableData (dest, tableMetaData, r);
                } catch (Exception ex2) {
                    IOHelper.writeError ("Error in update " + sql, ex2);
                }
            }
            ps.clearParameters ();
        }
        dest.commit ();
        dest.setAutoCommit (true);
    } finally {
        if (ps != null) ps.close ();
    }
}


-----Function Pair=350=-----==

public void setFlag (Flags.Flag oFlg, boolean bFlg) throws MessagingException {
    String sColunm;
    super.setFlag (oFlg, bFlg);
    if (oFlg.equals (Flags.Flag.ANSWERED)) sColunm = DB.bo_answered;
    else if (oFlg.equals (Flags.Flag.DELETED)) sColunm = DB.bo_deleted;
    else if (oFlg.equals (Flags.Flag.DRAFT)) sColunm = DB.bo_draft;
    else if (oFlg.equals (Flags.Flag.FLAGGED)) sColunm = DB.bo_flagged;
    else if (oFlg.equals (Flags.Flag.RECENT)) sColunm = DB.bo_recent;
    else if (oFlg.equals (Flags.Flag.SEEN)) sColunm = DB.bo_seen;
    else sColunm = null;
    if (null != sColunm && oFolder instanceof DBFolder) {
        JDCConnection oConn = null;
        PreparedStatement oUpdt = null;
        try {
            oConn = ((DBFolder) oFolder).getConnection ();
            String sSQL = "UPDATE " + DB.k_mime_msgs + " SET " + sColunm + "=" + (bFlg ? "1" : "0") + " WHERE " + DB.gu_mimemsg + "='" + getMessageGuid () + "'";
            if (DebugFile.trace) DebugFile.writeln ("Connection.prepareStatement(" + sSQL + ")");
            oUpdt = oConn.prepareStatement (sSQL);
            oUpdt.executeUpdate ();
            oUpdt.close ();
            oUpdt = null;
            oConn.commit ();
            oConn = null;
        } catch (SQLException e) {
            if (null != oConn) {
                try {
                    oConn.rollback ();
                } catch (Exception ignore) {
                }
            }
            if (null != oUpdt) {
                try {
                    oUpdt.close ();
                } catch (Exception ignore) {
                }
            }
            if (DebugFile.trace) DebugFile.decIdent ();
            throw new MessagingException (e.getMessage (), e);
        }
    }
}


public void testStatements0020 () throws Exception {
    Connection cx = getConnection ();
    dropTable ("#t0020a");
    dropTable ("#t0020b");
    dropTable ("#t0020c");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("create table #t0020a ( " + "  i1   int not null,     " + "  s1   char(10) not null " + ")                        " + "");
    stmt.executeUpdate ("create table #t0020b ( " + "  i2a   int not null,     " + "  i2b   int not null,     " + "  s2   char(10) not null " + ")                        " + "");
    stmt.executeUpdate ("create table #t0020c ( " + "  i3   int not null,     " + "  s3   char(10) not null " + ")                        " + "");
    int nextB = 1;
    int nextC = 1;
    for (int i = 1; i < 500; i ++) {
        stmt.executeUpdate ("insert into #t0020a " + "  values(" + i + ", " + "         'row" + i + "') " + "");
        for (int j = nextB; (nextB % 5) != 0; j ++, nextB ++) {
            stmt.executeUpdate ("insert into #t0020b " + " values(" + i + ", " + "        " + j + ", " + "        'row" + i + "." + j + "' " + "        )" + "");
            for (int k = nextC; (nextC % 3) != 0; k ++, nextC ++) {
                stmt.executeUpdate ("insert into #t0020c " + " values(" + j + ", " + "        'row" + i + "." + j + "." + k + "' " + "        )" + "");
            }
        }
    }
    Statement stmtA = cx.createStatement ();
    PreparedStatement stmtB = cx.prepareStatement ("select i2b, s2 from #t0020b where i2a=?");
    PreparedStatement stmtC = cx.prepareStatement ("select s3 from #t0020c where i3=?");
    ResultSet rs1 = stmtA.executeQuery ("select i1 from #t0020a");
    assertNotNull (rs1);
    while (rs1.next ()) {
        int i1 = rs1.getInt ("i1");
        stmtB.setInt (1, rs1.getInt ("i1"));
        ResultSet rs2 = stmtB.executeQuery ();
        assertNotNull (rs2);
        while (rs2.next ()) {
            stmtC.setInt (1, rs2.getInt (1));
            ResultSet rs3 = stmtC.executeQuery ();
            assertNotNull (rs3);
            if (rs3.next ()) {
            }
        }
    }
}


-----Function Pair=351=-----==

private HibernateAudioPlaylist updatePlaylist (PlaylistItem updatedPlaylist) {
    AudioPlaylistDAO dao = factory.getAudioPlaylistDAO ();
    Transaction t = dao.beginTransaction ();
    try {
        HibernateAudioPlaylist dbPlaylist = dao.load (getDBIdFromID (updatedPlaylist.getId ()));
        if (! updatedPlaylist.getName ().equalsIgnoreCase (dbPlaylist.getName ())) {
            dbPlaylist.setName (updatedPlaylist.getName ());
        }
        dao.save (dbPlaylist);
        dao.commitTransaction ();
        return dbPlaylist;
    } catch (Exception e) {
        t.rollback ();
        logger.error ("Error updating playlist:", e);
    }
    return null;
}


private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (0, address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


-----Function Pair=352=-----==

private void processResarchReport (Research res, ExecutionEvent event) {
    SafeSaveDialog dlg = new SafeSaveDialog (HandlerUtil.getActiveShell (event));
    dlg.setFilterExtensions (new String [] {"*.pdf"});
    String file = dlg.open ();
    if (file == null) return;
    List < JasperPrint > jasperPrintList = new ArrayList < JasperPrint > ();
    jasperPrintList.add (getEntityReport (res, res.getType ().getReport ()));
    Application app = res.getApplication ();
    if (app != null) jasperPrintList.add (getEntityReport (app, app.getType ().getReport ()));
    jasperPrintList.add (getEntityReport (res, "formula.jasper"));
    List < Entity > prod = PersistenceManager.getInstance ().getDataSource ().getChildren (res, new ResearchProductionHierarchy ());
    List < Entity > viscosities = new ArrayList < Entity > ();
    List < Entity > strengths = new ArrayList < Entity > ();
    List < Entity > tests = new ArrayList < Entity > ();
    for (Entity entity : prod) {
        jasperPrintList.add (getEntityReport (entity, entity.getType ().getReport ()));
        jasperPrintList.add (getEntityReport (entity, "parameter.jasper"));
        for (Entity ent : PersistenceManager.getInstance ().getDataSource ().getChildren (entity, new ResearchHierarchy ())) {
            for (Entity vis : PersistenceManager.getInstance ().getDataSource ().getChildren (ent, new SampleViscosityHierarchy ())) {
                viscosities.add (vis);
            }
            for (Entity vis : PersistenceManager.getInstance ().getDataSource ().getChildren (ent, new SampleStrengthHierarchy ())) {
                strengths.add (vis);
            }
            for (Entity test : PersistenceManager.getInstance ().getDataSource ().getChildren (ent, new SampleTestHierarchy ())) {
                tests.add (test);
            }
        }
    }
    for (Entity vis : viscosities) {
        jasperPrintList.add (getEntityReport (vis, vis.getType ().getReport ()));
    }
    for (Entity str : strengths) {
        jasperPrintList.add (getEntityReport (str, str.getType ().getReport ()));
    }
    for (Entity test : tests) {
        jasperPrintList.add (getEntityReport (test, test.getType ().getReport ()));
    }
    prepareResults (res);
    jasperPrintList.add (getEntityReport (null, EntityType.TestResult.getReport ()));
    JRPdfExporter exporter = new JRPdfExporter ();
    exporter.setParameter (JRExporterParameter.JASPER_PRINT_LIST, jasperPrintList);
    exporter.setParameter (JRExporterParameter.OUTPUT_FILE_NAME, file);
    try {
        exporter.exportReport ();
    } catch (JRException e) {
        e.printStackTrace ();
    }
}


private void getdata (HttpSession session, Hashtable periodData, String schema_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("period_schema_code");
        r.add ("path_no");
        r.add ("period_root_id", schema_id);
        sql = r.getSQLSelect ("period_root");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            periodData.put ("code", rs.getString ("period_schema_code"));
            periodData.put ("path_no", new Integer (rs.getInt ("path_no")));
            periodData.put ("id", schema_id);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=353=-----==

public void removeRolebyPrimaryKey (Integer primaryKey) throws Exception {
    Roles role = null;
    Session session = null;
    Transaction tx = null;
    session = HibernateUtil.getSessionFactory ().openSession ();
    try {
        tx = session.beginTransaction ();
        role = (Roles) session.get (Roles.class, primaryKey);
        if (role != null) session.delete (role);
        tx.commit ();
        session.close ();
    } catch (Exception e) {
        logger.error ("EXCEPTION While removing role", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
}


public MedicationListDocument searchForMedication (String sql) {
    ResultSet rsSearch = null;
    MedicationListDocument doc = null;
    try {
        helper = new DBHelper ();
        PreparedStatement psSearch = helper.prepareStatement (sql);
        rsSearch = psSearch.executeQuery ();
        doc = MedicationListDocument.Factory.newInstance ();
        doc.addNewMedicationList ();
        while (rsSearch.next ()) {
            Medication m = doc.getMedicationList ().addNewMedication ();
            m.setMedno (rsSearch.getString ("MEDNO"));
            m.setMedication (rsSearch.getString ("MEDICATION"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsSearch != null) {
                rsSearch.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


-----Function Pair=354=-----==

private Hashtable getApplicant (String id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        prepareRenderer (r, id);
        sql = r.getSQLSelect ("adm_applicant");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            return getApplicantData (rs);
        }
        else {
            return null;
        }
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=355=-----==

public void updateItems (List < InputQueueItem > toUpdate) throws DatabaseException {
    if (toUpdate == null) throw new NullPointerException ("toUpdate");
    try {
        getConnection ().setAutoCommit (false);
    } catch (SQLException e) {
        LOGGER.warn ("Unable to set autocommit off", e);
    }
    try {
        PreparedStatement deleteSt = getConnection ().prepareStatement (DELETE_ALL_ITEMS_STATEMENT);
        PreparedStatement selectCount = getConnection ().prepareStatement (SELECT_NUMBER_ITEMS_STATEMENT);
        ResultSet rs = selectCount.executeQuery ();
        rs.next ();
        int totalBefore = rs.getInt (1);
        int deleted = deleteSt.executeUpdate ();
        int updated = 0;
        for (InputQueueItem item : toUpdate) {
            updated += getItemInsertStatement (item).executeUpdate ();
        }
        if (totalBefore == deleted && updated == toUpdate.size ()) {
            getConnection ().commit ();
            LOGGER.debug ("DB has been updated. Queries: \"" + selectCount + "\" and \"" + deleteSt + "\".");
        }
        else {
            getConnection ().rollback ();
            LOGGER.error ("DB has not been updated -> rollback! Queries: \"" + selectCount + "\" and \"" + deleteSt + "\".");
        }
    } catch (SQLException e) {
        LOGGER.error (e);
    } finally {
        closeConnection ();
    }
}


public RestServiceResult search (RestServiceResult serviceResult, Long nQuestionId) {
    CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionId);
    if (coQuestion == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("question.search.notFound"));
    }
    else {
        List < CoQuestion > list = new ArrayList < CoQuestion > ();
        EntityManagerHelper.refresh (coQuestion);
        list.add (coQuestion);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("question.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=356=-----==

public RestServiceResult delete (RestServiceResult serviceResult, CoCourse coCourse) {
    String sCourseName = null;
    try {
        sCourseName = coCourse.getCourseName ();
        log.error ("Eliminando el curso: " + coCourse.getCourseName ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_COURSE);
        query.setParameter (1, coCourse.getCourseId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sCourseName};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.delete.success"), arrayParam));
        log.info ("Eliminando el curso: " + coCourse.getCourseName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {coCourse.getCourseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, MaSingleTextCheckList maSingleTextCheckList) {
    String sTitle = null;
    try {
        sTitle = maSingleTextCheckList.getTitle ();
        log.error ("Eliminando la lista de chequeo: " + maSingleTextCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.DELETE_CHECK_LIST);
        query.setParameter (1, maSingleTextCheckList.getCheckListFormId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {sTitle};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.delete.success"), arrayParam));
        log.info ("Eliminando el curso: " + maSingleTextCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] args = {maSingleTextCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.delete.error") + e.getMessage (), args));
    }
    return serviceResult;
}


-----Function Pair=357=-----==

public Collection list () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Word, SenseNumber, GrammarString, ObjectId " + "from Dictionary order by Word";
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                DictionaryEntry entry = new DictionaryEntry (rs.getString (1), rs.getInt (2), rs.getString (3), rs.getString (4));
                list.add (entry);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


private String [] getSelfDefinePath (String path, String exp, Connection con, PreparedStatement pstm, ResultSet rs) {
    if (exp == null || exp.trim ().equals ("0")) {
        String [] rv = new String [1];
        rv [0] = path;
        return rv;
    }
    List list = new ArrayList ();
    list.add (path);
    String [] selfDefinePath;
    try {
        pstm = con.prepareStatement (" select channel_path from t_ip_channel where channel_path like '" + path + "%'  ");
        rs = pstm.executeQuery ();
        while (rs.next ()) {
            list.add (rs.getString (1));
        }
        selfDefinePath = new String [list.size ()];
        for (int i = 0; i < list.size (); i ++) {
            selfDefinePath [i] = (String) list.get (i);
        }
    } catch (SQLException e) {
        selfDefinePath = new String [0];
        e.printStackTrace ();
    }
    return selfDefinePath;
}


-----Function Pair=358=-----==

public static boolean update (String fullname, String username, String password, String login_alt) throws Exception {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean isExist = false;
        if (! login_alt.equals (username)) {
            {
                r.clear ();
                r.add ("user_login");
                r.add ("user_login", login_alt);
                sql = r.getSQLSelect ("users");
                ResultSet rs = stmt.executeQuery (sql);
                if (rs.next ()) isExist = true;
            }
        }
        if (! isExist) {
            r.clear ();
            r.add ("user_name", fullname);
            r.add ("user_password", mecca.util.PasswordService.encrypt (password));
            r.add ("user_login_alt", login_alt);
            r.update ("user_login", username);
            sql = r.getSQLUpdate ("users");
            int num = stmt.executeUpdate (sql);
            if (num > 0) return true;
            else return false;
        }
    } catch (SQLException ex) {
        Log.print (ex.getMessage () + "\n" + sql);
    } finally {
        if (db != null) db.close ();
    }
    return false;
}


public static void savechoice (Hashtable h) throws Exception {
    String applicant_id = (String) h.get ("applicant_id");
    String choice1 = (String) h.get ("choice1");
    String choice2 = (String) h.get ("choice2");
    String choice3 = (String) h.get ("choice3");
    if ("".equals (applicant_id)) return;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("applicant_id");
            r.add ("applicant_id", applicant_id);
            sql = r.getSQLSelect ("adm_applicant_choice");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        {
            r.clear ();
            r.add ("choice1", choice1);
            r.add ("choice2", choice2);
            r.add ("choice3", choice3);
            if (! found) {
                r.add ("applicant_id", applicant_id);
                sql = r.getSQLInsert ("adm_applicant_choice");
            }
            else {
                r.update ("applicant_id", applicant_id);
                sql = r.getSQLUpdate ("adm_applicant_choice");
            }
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=359=-----==

public void loadCommandHistory () {
    if (! ((Boolean) EXQLModuleManager.instance ().getPreference (EXQLConstants.RDBMS_OPTION_REMEMBER_COMMAND_HISTORY).getValue ()).booleanValue ()) return;
    log.debug ("loading");
    Statement st = null;
    Connection conn = null;
    try {
        conn = DbStoreModuleManager.instance ().getConnection ();
        st = conn.createStatement ();
        ResultSet set = st.executeQuery ("SELECT COMMAND FROM SQL_COMMAND_HISTORY WHERE CONNECTION_NAME='" + connectionName + "' order by ID ASC");
        while (set.next ()) {
            String s = set.getString (1);
            log.debug (s);
            commandVector.add (s);
        }
        set.close ();
        st.close ();
    } catch (SQLException e) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e, "Exception caught while saving command history");
    } finally {
        if (st != null) {
            try {
                st.close ();
            } catch (SQLException e1) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (SQLException e1) {
            }
        }
    }
}


public void removePrice (Price price) throws PersistenceException {
    logger.info ("Removing price...");
    if (price == null) {
        String error = "Price is null.";
        logger.error (error);
        throw new IllegalArgumentException (error);
    }
    EntityManager em = getEntityManager ();
    try {
        em.getTransaction ().begin ();
        Query query = em.createQuery ("delete from Price p where " + " p = :price ");
        query.setParameter ("price", price);
        query.executeUpdate ();
        em.getTransaction ().commit ();
    } catch (Exception ex) {
        String error = "Error removing price: " + ex.getMessage ();
        logger.error (error);
        em.getTransaction ().rollback ();
        throw new PersistenceException (ex);
    } finally {
        em.close ();
    }
    logger.info ("Price removed successfully.");
}


-----Function Pair=360=-----==

public void loadCommandHistory () {
    if (! ((Boolean) EXQLModuleManager.instance ().getPreference (EXQLConstants.RDBMS_OPTION_REMEMBER_COMMAND_HISTORY).getValue ()).booleanValue ()) return;
    log.debug ("loading");
    Statement st = null;
    Connection conn = null;
    try {
        conn = DbStoreModuleManager.instance ().getConnection ();
        st = conn.createStatement ();
        ResultSet set = st.executeQuery ("SELECT COMMAND FROM SQL_COMMAND_HISTORY WHERE CONNECTION_NAME='" + connectionName + "' order by ID ASC");
        while (set.next ()) {
            String s = set.getString (1);
            log.debug (s);
            commandVector.add (s);
        }
        set.close ();
        st.close ();
    } catch (SQLException e) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e, "Exception caught while saving command history");
    } finally {
        if (st != null) {
            try {
                st.close ();
            } catch (SQLException e1) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (SQLException e1) {
            }
        }
    }
}


private void addInferredRoles (Map gidMap, Set set, long conceptGID, String gid, int namespaceId, List roles, PreparedStatement preStat, String seqName) throws SQLException {
    for (int i = 0; i < roles.size (); i ++) {
        Role role = (Role) roles.get (i);
        int group = role.getRoleGroup ();
        ConceptRef ref = role.getRoleValue ();
        String value = ref.getIdentifier ();
        int valNsId = Integer.parseInt (ref.getNamespaceId ());
        Long nameGID = (Long) gidMap.get (value);
        if (nameGID == null) {
            nameGID = loadGID (value, valNsId);
            gidMap.put (value, nameGID);
        }
        String name = role.getIdentifier ();
        RoleModifierEnum.Enum mod = role.getRoleModifier ();
        int typeNsId = Integer.parseInt (role.getNamespaceId ());
        int modifier = ((Integer) ROLE_MODE_MAP.get (mod)).intValue ();
        String key = conceptGID + " " + name + " " + typeNsId + " " + value + " " + modifier + " " + group;
        if (set.contains (key)) {
            continue;
        }
        else {
            set.add (key);
        }
        ((DTSClassifyGeneralDAO) getClassifyDAO ()).setRoleParameters (conceptGID, name, typeNsId, nameGID.longValue (), modifier, group, preStat, seqName, conn);
        try {
            int status = preStat.executeUpdate ();
            if (status != 1) {
                throw new SQLException ("unable to add concepts: " + conceptGID + " " + name);
            }
        } catch (SQLException e) {
            isDuplicationError (e);
        }
    }
}


-----Function Pair=361=-----==

public void ubahNamaMenu () {
    try {
        Integer Menu;
        String namaLama = null;
        String namaBaru = null;
        namaLama = String.valueOf (menuTable.getValueAt (menuTable.getSelectedRow (), 2));
        namaBaru = JOptionPane.showInputDialog (menuTable, "Ganti Nama Menu", namaLama);
        if (! namaLama.equals (namaBaru) && ! (namaBaru == null)) {
            Menu = Integer.valueOf (String.valueOf (menuTable.getValueAt (menuTable.getSelectedRow (), 0)));
            menuEntity.getTransaction ().begin ();
            menuQuery = menuEntity.createNativeQuery ("UPDATE menu m SET m.nama = #nama WHERE m.menu = #menu").setParameter ("menu", displayMenu.format (Menu)).setParameter ("nama", namaBaru);
            menuQuery.executeUpdate ();
            menuEntity.getTransaction ().commit ();
        }
    } catch (Exception ex) {
        menuEntity.getTransaction ().rollback ();
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    refreshTableMenu ();
}


public void grabar () throws SQLException, ClassNotFoundException, Exception {
    Connection conn = null;
    try {
        conn = ToolsBD.getConn ();
        conn.setAutoCommit (false);
        cargar (conn);
        conn.commit ();
    } catch (Exception ex) {
        System.out.println (usuario + ": Excepció: " + ex.getMessage ());
        ex.printStackTrace ();
        registroGrabado = false;
        errores.put ("", "Error inesperat, no s'ha desat el registre" + ": " + ex.getClass () + "->" + ex.getMessage ());
        try {
            if (conn != null) conn.rollback ();
        } catch (SQLException sqle) {
            throw new RemoteException (usuario + ": S'ha produït un error i no s'han pogut tornar enrere els canvis efectuats", sqle);
        }
        throw new RemoteException ("Error inesperat: No s'ha desat el registre", ex);
    } finally {
        ToolsBD.closeConn (conn, null, null);
    }
}


-----Function Pair=362=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoMatrixExercises1 coMatrixExercises1) {
    CoMatrixExercises1DAO coMatrixExercises1DAO = new CoMatrixExercises1DAO ();
    try {
        log.info ("Actualizando la matriz tipo 1: " + coMatrixExercises1.getEnunciate ());
        EntityManagerHelper.beginTransaction ();
        coMatrixExercises1DAO.update (coMatrixExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMatrixExercises1);
        Object [] arrayParam = {coMatrixExercises1.getCoExercises1 ().getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises1.update.success"), arrayParam));
        log.info ("Se actualizo la matriz tipo1 con �xito: " + coMatrixExercises1.getEnunciate ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la matriz tipo 1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


public static Vector getStudentList (Statement stmt, String session_id, String program_code) throws Exception {
    String sql = "";
    sql = "SELECT " + "st.id, st.name, st.address, " + "st.city, st.state, st.poscode, st.country_code, st.phone, " + "st.birth_date, st.email, p.period_id, prog.program_code, " + "prog.program_name, p.period_root_id, ses.session_name, ses2.session_name as intake_name " + "FROM student st, student_course sc, student_status sta, intake_batch b, " + "period p, program prog, session ses, session ses2 " + "WHERE " + "st.id = sc.student_id " + "AND st.id = sta.student_id " + "AND b.session_id = sta.session_id " + "AND b.intake_session = sta.batch_id  " + "AND b.period_id = p.period_id  " + "AND b.period_root_id = p.period_root_id " + "AND b.period_root_id = sc.period_root_id " + "AND p.period_root_id = sc.period_root_id " + "AND prog.program_code = sc.program_code  " + "AND sta.batch_id = ses.session_id  " + "AND sc.intake_session = ses2.session_id ";
    if (! "".equals (program_code)) sql += "AND prog.program_code = '" + program_code + "' ";
    if (! "".equals (session_id)) sql += "AND sta.session_id = '" + session_id + "' ";
    sql += "ORDER BY st.name";
    ResultSet rs = stmt.executeQuery (sql);
    Vector v = new Vector ();
    while (rs.next ()) {
        Hashtable h = new Hashtable ();
        h.put ("id", rs.getString ("id"));
        h.put ("name", rs.getString ("name"));
        h.put ("period_id", rs.getString ("period_id"));
        v.addElement (h);
    }
    return v;
}


-----Function Pair=363=-----=1=

public void actualizar () throws SQLException, ClassNotFoundException, Exception {
    Connection conn = null;
    PreparedStatement ms = null;
    if (! validado) {
        validado = validar ();
    }
    if (! validado) {
        throw new Exception ("No s'ha realitzat la validació de les dades del registre ");
    }
    registroActualizado = false;
    try {
        int fzaanoe;
        String campo;
        fechaTest = dateF.parse (dataentrada);
        Calendar cal = Calendar.getInstance ();
        cal.setTime (fechaTest);
        DateFormat date1 = new SimpleDateFormat ("yyyyMMdd");
        fzaanoe = Integer.parseInt (anoEntrada);
        int fzafent = Integer.parseInt (date1.format (fechaTest));
        conn = ToolsBD.getConn ();
        conn.setAutoCommit (false);
        int fzanume = Integer.parseInt (numeroEntrada);
        int fzacagc = Integer.parseInt (oficina);
        int off_codi = 0;
        try {
            off_codi = Integer.parseInt (oficinafisica);
        } catch (Exception e) {
        }
        fechaTest = dateF.parse (data);
        cal.setTime (fechaTest);
        int fzafdoc = Integer.parseInt (date1.format (fechaTest));
        String fzacone, fzacone2;
        if (idioex.equals ("1")) {
            fzacone = comentario;
            fzacone2 = "";
        }
        else {
            fzacone = "";
            fzacone2 = comentario;
        }
        String fzaproce;
        int fzactagg, fzacagge;
        if (fora.equals ("")) {
            fzactagg = 90;
            fzacagge = Integer.parseInt (balears);
            fzaproce = "";
        }
        else {
            fzaproce = fora;
            fzactagg = 0;
            fzacagge = 0;
        }
        int ceros = 0;
        int fzacorg = Integer.parseInt (destinatari);
        int fzanent;
        String fzacent;
        if (altres.equals ("")) {
            altres = "";
            fzanent = Integer.parseInt (entidad2);
            fzacent = entidadCastellano;
        }
        else {
            fzanent = 0;
            fzacent = "";
        }
        int fzacidi = Integer.parseInt (idioex);
        horaTest = horaF.parse (hora);
        cal.setTime (horaTest);
        DateFormat hhmm = new SimpleDateFormat ("HHmm");
        int fzahora = Integer.parseInt (hhmm.format (horaTest));
        if (salida1.equals ("")) {
            salida1 = "0";
        }
        if (salida2.equals ("")) {
            salida2 = "0";
        }
        int fzanloc = Integer.parseInt (salida1);
        int fzaaloc = Integer.parseInt (salida2);
        if (disquet.equals ("")) {
            disquet = "0";
        }
        int fzandis = Integer.parseInt (disquet);
        if (fzandis > 0) {
            ToolsBD.actualizaDisqueteEntrada (conn, fzandis, oficina, anoEntrada, errores);
        }
        Date fechaSystem = new Date ();
        DateFormat aaaammdd = new SimpleDateFormat ("yyyyMMdd");
        int fzafsis = Integer.parseInt (aaaammdd.format (fechaSystem));
        DateFormat hhmmss = new SimpleDateFormat ("HHmmss");
        DateFormat sss = new SimpleDateFormat ("S");
        String ss = sss.format (fechaSystem);
        if (ss.length () > 2) {
            ss = ss.substring (0, 2);
        }
        int fzahsis = Integer.parseInt (hhmmss.format (fechaSystem) + ss);
        String deleteOfifis = "DELETE FROM BZENTOFF WHERE FOEANOEN=? AND FOENUMEN=? AND FOECAGCO=?";
        ms = conn.prepareStatement (deleteOfifis);
        ms.setInt (1, fzaanoe);
        ms.setInt (2, fzanume);
        ms.setInt (3, fzacagc);
        ms.execute ();
        ms.close ();
        String insertOfifis = "INSERT INTO BZENTOFF (FOEANOEN, FOENUMEN, FOECAGCO, OFE_CODI)" + "VALUES (?,?,?,?)";
        ms = conn.prepareStatement (insertOfifis);
        ms.setInt (1, fzaanoe);
        ms.setInt (2, fzanume);
        ms.setInt (3, fzacagc);
        ms.setInt (4, off_codi);
        ms.execute ();
        ms.close ();
        ms = conn.prepareStatement ("UPDATE BZENTRA SET FZAFDOCU=?, FZAREMIT=?, FZACONEN=?, FZACTIPE=?, " + "FZACEDIE=?, FZAENULA=?, FZAPROCE=?, FZAFENTR=?, FZACTAGG=?, FZACAGGE=?, FZACORGA=?, " + "FZACENTI=?, FZANENTI=?, FZAHORA=?, FZACIDIO=?, FZACONE2=?, FZANLOC=?, FZAALOC=?, FZANDIS=?, " + "FZACUSU=?, FZACIDI=? WHERE FZAANOEN=? AND FZANUMEN=? AND FZACAGCO=?");
        ms.setInt (1, fzafdoc);
        ms.setString (2, (altres.length () > 30) ? altres.substring (0, 30) : altres);
        ms.setString (3, (fzacone.length () > 160) ? fzacone.substring (0, 160) : fzacone);
        ms.setString (4, (tipo.length () > 2) ? tipo.substring (0, 1) : tipo);
        ms.setString (5, "N");
        ms.setString (6, (registroAnulado.length () > 1) ? registroAnulado.substring (0, 1) : registroAnulado);
        ms.setString (7, (fzaproce.length () > 25) ? fzaproce.substring (0, 25) : fzaproce);
        ms.setInt (8, fzafent);
        ms.setInt (9, fzactagg);
        ms.setInt (10, fzacagge);
        ms.setInt (11, fzacorg);
        ms.setString (12, (fzacent.length () > 7) ? fzacent.substring (0, 8) : fzacent);
        ms.setInt (13, fzanent);
        ms.setInt (14, fzahora);
        ms.setInt (15, fzacidi);
        ms.setString (16, (fzacone2.length () > 160) ? fzacone2.substring (0, 160) : fzacone2);
        ms.setInt (17, fzanloc);
        ms.setInt (18, fzaaloc);
        ms.setInt (19, fzandis);
        ms.setString (20, (usuario.toUpperCase ().length () > 10) ? usuario.toUpperCase ().substring (0, 10) : usuario.toUpperCase ());
        ms.setString (21, idioma);
        ms.setInt (22, fzaanoe);
        ms.setInt (23, fzanume);
        ms.setInt (24, fzacagc);
        boolean modificado = false;
        if (! motivo.equals ("")) {
            javax.naming.InitialContext contexto = new javax.naming.InitialContext ();
            Object ref = contexto.lookup ("es.caib.regweb.RegistroModificadoEntradaHome");
            RegistroModificadoEntradaHome home = (RegistroModificadoEntradaHome) javax.rmi.PortableRemoteObject.narrow (ref, RegistroModificadoEntradaHome.class);
            RegistroModificadoEntrada registroModificado = home.create ();
            registroModificado.setAnoEntrada (fzaanoe);
            registroModificado.setOficina (fzacagc);
            if (! entidad1Nuevo.trim ().equals ("")) {
                if (entidad2Nuevo.equals ("")) {
                    entidad2Nuevo = "0";
                }
            }
            int fzanentNuevo;
            String fzacentNuevo;
            if (altresNuevo.trim ().equals ("")) {
                altresNuevo = "";
                fzanentNuevo = Integer.parseInt (entidad2Nuevo);
                fzacentNuevo = convierteEntidadCastellano (entidad1Nuevo, conn);
            }
            else {
                fzanentNuevo = 0;
                fzacentNuevo = "";
            }
            if (! fzacentNuevo.equals (fzacent) || fzanentNuevo != fzanent) {
                registroModificado.setEntidad2 (fzanentNuevo);
                registroModificado.setEntidad1 (fzacentNuevo);
            }
            else {
                registroModificado.setEntidad2 (0);
                registroModificado.setEntidad1 ("");
            }
            if (! comentarioNuevo.trim ().equals (comentario.trim ())) {
                registroModificado.setExtracto (comentarioNuevo);
            }
            else {
                registroModificado.setExtracto ("");
            }
            registroModificado.setUsuarioModificacion (usuario.toUpperCase ());
            registroModificado.setNumeroRegistro (fzanume);
            if (altresNuevo.equals (altres)) {
                registroModificado.setRemitente ("");
            }
            else {
                registroModificado.setRemitente (altresNuevo);
            }
            registroModificado.setMotivo (motivo);
            modificado = registroModificado.generarModificacion (conn);
            registroModificado.remove ();
        }
        if ((modificado && ! motivo.equals ("")) || motivo.equals ("")) {
            int afectados = ms.executeUpdate ();
            if (afectados > 0) {
                registroActualizado = true;
            }
            else {
                registroActualizado = false;
            }
            String remitente = "";
            if (! altres.trim ().equals ("")) {
                remitente = altres;
            }
            else {
                javax.naming.InitialContext contexto = new javax.naming.InitialContext ();
                Object ref = contexto.lookup ("es.caib.regweb.ValoresHome");
                ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow (ref, ValoresHome.class);
                Valores valor = home.create ();
                remitente = valor.recuperaRemitenteCastellano (fzacent, fzanent + "");
                valor.remove ();
            }
            try {
                Class t = Class.forName ("es.caib.regweb.module.PluginHook");
                Class [] partypes = {String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class, String.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class};
                Object [] params = {"M", new Integer (fzaanoe), new Integer (fzanume), new Integer (fzacagc), new Integer (fzafdoc), remitente, comentario, tipo, new Integer (fzafent), new Integer (fzacagge), fzaproce, new Integer (fzacorg), idioma, BOIBdata, new Integer (BOIBnumeroBOCAIB), new Integer (BOIBpagina), new Integer (BOIBlineas), BOIBtexto, BOIBobservaciones, correo};
                java.lang.reflect.Method metodo = t.getMethod ("entrada", partypes);
                metodo.invoke (null, params);
            } catch (IllegalAccessException iae) {
            } catch (IllegalArgumentException iae) {
            } catch (InvocationTargetException ite) {
            } catch (NullPointerException npe) {
            } catch (ExceptionInInitializerError eiie) {
            } catch (NoSuchMethodException nsme) {
            } catch (SecurityException se) {
            } catch (LinkageError le) {
            } catch (ClassNotFoundException le) {
            }
            conn.commit ();
            String Stringsss = sss.format (fechaSystem);
            switch (Stringsss.length ()) {
                case (1) :
                    Stringsss = "00" + Stringsss;
                    break;
                case (2) :
                    Stringsss = "0" + Stringsss;
                    break;
            }
            int horamili = Integer.parseInt (hhmmss.format (fechaSystem) + Stringsss);
            logLopdBZENTRA ("UPDATE", (usuario.toUpperCase ().length () > 10) ? usuario.toUpperCase ().substring (0, 10) : usuario.toUpperCase (), fzafsis, horamili, fzanume, fzaanoe, fzacagc);
        }
        else {
            registroActualizado = false;
            errores.put ("", "Error inesperat, no s'ha modificat el registre");
            throw new RemoteException ("Error inesperat, no s'ha modifcat el registre");
        }
        System.out.println ("Municipi codi: " + municipi060);
        if (municipi060.equals ("000")) eliminar060 ();
        else if (! municipi060.equals ("")) actualizar060 ();
    } catch (Exception ex) {
        System.out.println ("Error inesperat, no s'ha desat el registre: " + ex.getMessage ());
        ex.printStackTrace ();
        registroActualizado = false;
        errores.put ("", "Error inesperat, no s'ha desat el registre" + ": " + ex.getClass () + "->" + ex.getMessage ());
        try {
            if (conn != null) conn.rollback ();
        } catch (SQLException sqle) {
            throw new RemoteException ("S'ha produït un error i no s'han pogut tornar enrere els canvis efectuats", sqle);
        }
        throw new RemoteException ("Error inesperat, no s'ha modifcat el registre", ex);
    } finally {
        ToolsBD.closeConn (conn, ms, null);
    }
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=364=-----==

public void executeSearch () {
    Session session = null;
    Transaction tx = null;
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        executionResults = session.find (getQueryStatement ("select new org.eaasyst.eaa.syst.data.persistent.UserGroup(userGroup.idString, userGroup.title) from UserGroup userGroup {filter} {sort}"));
        if (executionResults != null) {
            responseCode = 0;
            responseString = "Execution complete";
            try {
                Collection emptyTest = (Collection) executionResults;
                if (emptyTest.isEmpty ()) {
                    responseCode = 1;
                    responseString = "Record not found";
                }
            } catch (ClassCastException e) {
            }
        }
        else {
            responseCode = 1;
            responseString = "Record not found";
        }
        tx.commit ();
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


public final void setChildren (Class < ? extends Record > record, List < Record > children) throws RecordException, RecordValidationException, RecordValidationSyntax, FieldOrMethodNotFoundException {
    boolean found = false;
    if (childrenList != null && childrenList.containsKey (record)) {
        found = true;
    }
    if (! found && relatedList != null && relatedList.containsKey (record)) {
        found = true;
    }
    if (! found) {
        throw new RecordException ("Table " + TableNameResolver.getTableName (this.getClass ()) + " has no " + TableNameResolver.getTableName (record) + " children.");
    }
    for (Record r : children) {
        r.doValidations (false);
    }
    if (childrenObjects == null) {
        childrenObjects = new HashMap < Class < ? extends Record >, List < ? extends Record > > ();
    }
    List < ? extends Record > l = childrenObjects.get (record.getClass ());
    if (childrenList != null && childrenList.containsKey (record)) {
        try {
            for (Record r : l) {
                setValue (r, "fk_" + getFieldName (this.getClass ()), null);
                try {
                    r.update ();
                } catch (RecordException e) {
                    if (! e.getMessage ().equals (Messages.SR_UPDATE_IMPOSSIBLE)) {
                        throw e;
                    }
                }
            }
            for (Record r : children) {
                setValue (r, "fk_" + getFieldName (this.getClass ()), FieldHandler.getValue (FieldHandler.findField (this.getClass (), "id"), this));
            }
        } catch (Exception e) {
            throw new RecordException (e);
        }
    }
    else {
        for (Record r : children) {
            addRelatedChild (this, r);
        }
    }
    childrenObjects.put (record, children);
}


-----Function Pair=365=-----==

private synchronized Object getUniqueResult (String hqlQuery) throws GridBrokerException {
    Object result = null;
    Transaction t = null;
    Session s = null;
    try {
        s = getSession ();
        t = s.beginTransaction ();
        result = s.createQuery (hqlQuery).uniqueResult ();
        t.commit ();
    } catch (Exception e) {
        if (t != null && t.isActive ()) {
            t.rollback ();
        }
        throw new GridBrokerException ("Error getting unique result: query=" + hqlQuery, e);
    } finally {
        closeSession (s);
    }
    return result;
}


public void actualizar () throws SQLException, ClassNotFoundException, Exception {
    Connection conn = null;
    PreparedStatement ms = null;
    if (! validado) {
        validado = validar ();
    }
    if (! validado) {
        throw new Exception ("No s'ha realitzat la validació de les dades del registre ");
    }
    registroActualizado = false;
    try {
        int fzaanoe;
        String campo;
        fechaTest = dateF.parse (datasalida);
        Calendar cal = Calendar.getInstance ();
        cal.setTime (fechaTest);
        DateFormat date1 = new SimpleDateFormat ("yyyyMMdd");
        fzaanoe = Integer.parseInt (anoSalida);
        int fzafent = Integer.parseInt (date1.format (fechaTest));
        conn = ToolsBD.getConn ();
        conn.setAutoCommit (false);
        int fzanume = Integer.parseInt (numeroSalida);
        int fzacagc = Integer.parseInt (oficina);
        int off_codi = 0;
        try {
            off_codi = Integer.parseInt (oficinafisica);
        } catch (Exception e) {
        }
        fechaTest = dateF.parse (data);
        cal.setTime (fechaTest);
        int fzafdoc = Integer.parseInt (date1.format (fechaTest));
        String fzacone, fzacone2;
        if (idioex.equals ("1")) {
            fzacone = comentario;
            fzacone2 = "";
        }
        else {
            fzacone = "";
            fzacone2 = comentario;
        }
        String fzaproce;
        int fzactagg, fzacagge;
        if (fora.equals ("")) {
            fzactagg = 90;
            fzacagge = Integer.parseInt (balears);
            fzaproce = "";
        }
        else {
            fzaproce = fora;
            fzactagg = 0;
            fzacagge = 0;
        }
        int ceros = 0;
        int fzacorg = Integer.parseInt (remitent);
        int fzanent;
        String fzacent;
        if (altres.equals ("")) {
            altres = "";
            fzanent = Integer.parseInt (entidad2);
            fzacent = entidadCastellano;
        }
        else {
            fzanent = 0;
            fzacent = "";
        }
        int fzacidi = Integer.parseInt (idioex);
        horaTest = horaF.parse (hora);
        cal.setTime (horaTest);
        DateFormat hhmm = new SimpleDateFormat ("HHmm");
        int fzahora = Integer.parseInt (hhmm.format (horaTest));
        if (entrada1.equals ("")) {
            entrada1 = "0";
        }
        if (entrada2.equals ("")) {
            entrada2 = "0";
        }
        int fzanloc = Integer.parseInt (entrada1);
        int fzaaloc = Integer.parseInt (entrada2);
        if (disquet.equals ("")) {
            disquet = "0";
        }
        int fzandis = Integer.parseInt (disquet);
        if (fzandis > 0) {
            ToolsBD.actualizaDisqueteEntrada (conn, fzandis, oficina, anoSalida, errores);
        }
        Date fechaSystem = new Date ();
        DateFormat aaaammdd = new SimpleDateFormat ("yyyyMMdd");
        int fzafsis = Integer.parseInt (aaaammdd.format (fechaSystem));
        DateFormat hhmmss = new SimpleDateFormat ("HHmmss");
        DateFormat sss = new SimpleDateFormat ("S");
        String ss = sss.format (fechaSystem);
        if (ss.length () > 2) {
            ss = ss.substring (0, 2);
        }
        int fzahsis = Integer.parseInt (hhmmss.format (fechaSystem) + ss);
        if (correo != null) {
            String insertBZNCORR = "INSERT INTO BZNCORR (FZPCENSA, FZPCAGCO, FZPANOEN, FZPNUMEN, FZPNCORR)" + "VALUES (?,?,?,?,?)";
            String updateBZNCORR = "UPDATE BZNCORR SET FZPNCORR=? WHERE FZPCENSA=? AND FZPCAGCO=? AND FZPANOEN=? AND FZPNUMEN=?";
            String deleteBZNCORR = "DELETE FROM BZNCORR WHERE FZPCENSA=? AND FZPCAGCO=? AND FZPANOEN=? AND FZPNUMEN=?";
            int actualizados = 0;
            if (! correo.trim ().equals ("")) {
                ms = conn.prepareStatement (updateBZNCORR);
                ms.setString (1, correo);
                ms.setString (2, "S");
                ms.setInt (3, fzacagc);
                ms.setInt (4, fzaanoe);
                ms.setInt (5, fzanume);
                actualizados = ms.executeUpdate ();
                ms.close ();
                if (actualizados == 0) {
                    ms = conn.prepareStatement (insertBZNCORR);
                    ms.setString (1, "S");
                    ms.setInt (2, fzacagc);
                    ms.setInt (3, fzaanoe);
                    ms.setInt (4, fzanume);
                    ms.setString (5, correo);
                    ms.execute ();
                    ms.close ();
                }
            }
            else {
                ms = conn.prepareStatement (deleteBZNCORR);
                ms.setString (1, "S");
                ms.setInt (2, fzacagc);
                ms.setInt (3, fzaanoe);
                ms.setInt (4, fzanume);
                ms.execute ();
            }
        }
        String deleteOfifis = "DELETE FROM BZSALOFF WHERE FOSANOEN=? AND FOSNUMEN=? AND FOSCAGCO=?";
        ms = conn.prepareStatement (deleteOfifis);
        ms.setInt (1, fzaanoe);
        ms.setInt (2, fzanume);
        ms.setInt (3, fzacagc);
        ms.execute ();
        ms.close ();
        String insertOfifis = "INSERT INTO BZSALOFF (FOSANOEN, FOSNUMEN, FOSCAGCO, OFS_CODI)" + "VALUES (?,?,?,?)";
        ms = conn.prepareStatement (insertOfifis);
        ms.setInt (1, fzaanoe);
        ms.setInt (2, fzanume);
        ms.setInt (3, fzacagc);
        ms.setInt (4, off_codi);
        ms.execute ();
        ms.close ();
        ms = conn.prepareStatement ("UPDATE BZSALIDA SET FZSFDOCU=?, FZSREMIT=?, FZSCONEN=?, FZSCTIPE=?, " + "FZSCEDIE=?, FZSENULA=?, FZSPROCE=?, FZSFENTR=?, FZSCTAGG=?, FZSCAGGE=?, FZSCORGA=?, " + "FZSCENTI=?, FZSNENTI=?, FZSHORA=?, FZSCIDIO=?, FZSCONE2=?, FZSNLOC=?, FZSALOC=?, FZSNDIS=?, " + "FZSCUSU=?, FZSCIDI=? WHERE FZSANOEN=? AND FZSNUMEN=? AND FZSCAGCO=? ");
        ms.setInt (1, fzafdoc);
        ms.setString (2, (altres.length () > 30) ? altres.substring (0, 30) : altres);
        ms.setString (3, (fzacone.length () > 160) ? fzacone.substring (0, 160) : fzacone);
        ms.setString (4, (tipo.length () > 2) ? tipo.substring (0, 1) : tipo);
        ms.setString (5, "N");
        ms.setString (6, (registroAnulado.length () > 1) ? registroAnulado.substring (0, 1) : registroAnulado);
        ms.setString (7, (fzaproce.length () > 25) ? fzaproce.substring (0, 25) : fzaproce);
        ms.setInt (8, fzafent);
        ms.setInt (9, fzactagg);
        ms.setInt (10, fzacagge);
        ms.setInt (11, fzacorg);
        ms.setString (12, (fzacent.length () > 7) ? fzacent.substring (0, 8) : fzacent);
        ms.setInt (13, fzanent);
        ms.setInt (14, fzahora);
        ms.setInt (15, fzacidi);
        ms.setString (16, (fzacone2.length () > 160) ? fzacone2.substring (0, 160) : fzacone2);
        ms.setInt (17, fzanloc);
        ms.setInt (18, fzaaloc);
        ms.setInt (19, fzandis);
        ms.setString (20, (usuario.toUpperCase ().length () > 10) ? usuario.toUpperCase ().substring (0, 10) : usuario.toUpperCase ());
        ms.setString (21, idioma);
        ms.setInt (22, fzaanoe);
        ms.setInt (23, fzanume);
        ms.setInt (24, fzacagc);
        boolean modificado = false;
        if (! motivo.equals ("")) {
            javax.naming.InitialContext contexto = new javax.naming.InitialContext ();
            Object ref = contexto.lookup ("es.caib.regweb.RegistroModificadoSalidaHome");
            RegistroModificadoSalidaHome home = (RegistroModificadoSalidaHome) javax.rmi.PortableRemoteObject.narrow (ref, RegistroModificadoSalidaHome.class);
            RegistroModificadoSalida registroModificado = home.create ();
            registroModificado.setAnoSalida (fzaanoe);
            registroModificado.setOficina (fzacagc);
            if (! entidad1Nuevo.trim ().equals ("")) {
                if (entidad2Nuevo.equals ("")) {
                    entidad2Nuevo = "0";
                }
            }
            int fzanentNuevo;
            String fzacentNuevo;
            if (altresNuevo.trim ().equals ("")) {
                altresNuevo = "";
                fzanentNuevo = Integer.parseInt (entidad2Nuevo);
                fzacentNuevo = convierteEntidadCastellano (entidad1Nuevo, conn);
            }
            else {
                fzanentNuevo = 0;
                fzacentNuevo = "";
            }
            if (! fzacentNuevo.equals (fzacent) || fzanentNuevo != fzanent) {
                registroModificado.setEntidad2 (fzanentNuevo);
                registroModificado.setEntidad1 (fzacentNuevo);
            }
            else {
                registroModificado.setEntidad2 (0);
                registroModificado.setEntidad1 ("");
            }
            if (! comentarioNuevo.trim ().equals (comentario.trim ())) {
                registroModificado.setExtracto (comentarioNuevo);
            }
            else {
                registroModificado.setExtracto ("");
            }
            registroModificado.setUsuarioModificacion (usuario.toUpperCase ());
            registroModificado.setNumeroRegistro (fzanume);
            if (altresNuevo.equals (altres)) {
                registroModificado.setRemitente ("");
            }
            else {
                registroModificado.setRemitente (altresNuevo);
            }
            registroModificado.setMotivo (motivo);
            modificado = registroModificado.generarModificacion (conn);
            registroModificado.remove ();
        }
        if ((modificado && ! motivo.equals ("")) || motivo.equals ("")) {
            int afectados = ms.executeUpdate ();
            if (afectados > 0) {
                registroActualizado = true;
            }
            else {
                registroActualizado = false;
            }
            String remitente = "";
            if (! altres.trim ().equals ("")) {
                remitente = altres;
            }
            else {
                javax.naming.InitialContext contexto = new javax.naming.InitialContext ();
                Object ref = contexto.lookup ("es.caib.regweb.ValoresHome");
                ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow (ref, ValoresHome.class);
                Valores valor = home.create ();
                remitente = valor.recuperaRemitenteCastellano (fzacent, fzanent + "");
                valor.remove ();
            }
            try {
                Class t = Class.forName ("es.caib.regweb.module.PluginHook");
                Class [] partypes = {String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class};
                Object [] params = {"M", new Integer (fzaanoe), new Integer (fzanume), new Integer (fzacagc), new Integer (fzafdoc), remitente, comentario, tipo, new Integer (fzafent), new Integer (fzacagge), fzaproce, new Integer (fzacorg), idioma};
                java.lang.reflect.Method metodo = t.getMethod ("salida", partypes);
                metodo.invoke (null, params);
            } catch (IllegalAccessException iae) {
            } catch (IllegalArgumentException iae) {
            } catch (InvocationTargetException ite) {
            } catch (NullPointerException npe) {
            } catch (ExceptionInInitializerError eiie) {
            } catch (NoSuchMethodException nsme) {
            } catch (SecurityException se) {
            } catch (LinkageError le) {
            } catch (ClassNotFoundException le) {
            }
            String Stringsss = sss.format (fechaSystem);
            switch (Stringsss.length ()) {
                case (1) :
                    Stringsss = "00" + Stringsss;
                    break;
                case (2) :
                    Stringsss = "0" + Stringsss;
                    break;
            }
            int horamili = Integer.parseInt (hhmmss.format (fechaSystem) + Stringsss);
            logLopdBZSALIDA ("UPDATE", (usuario.toUpperCase ().length () > 10) ? usuario.toUpperCase ().substring (0, 10) : usuario.toUpperCase (), fzahsis, horamili, fzanume, fzaanoe, fzacagc);
            conn.commit ();
        }
        else {
            registroActualizado = false;
            errores.put ("", "Error inesperat, no s'ha modificat el registre");
            throw new RemoteException ("Error inesperat, no s'ha modifcat el registre");
        }
    } catch (Exception ex) {
        System.out.println ("Error inesperat " + ex.getMessage ());
        ex.printStackTrace ();
        registroActualizado = false;
        errores.put ("", "Error inesperat, no s'ha modificat el registre" + ": " + ex.getClass () + "->" + ex.getMessage ());
        try {
            if (conn != null) conn.rollback ();
        } catch (SQLException sqle) {
            throw new RemoteException ("S'ha produ\357t un error i no s'han pogut tornar enrere els canvis efectuats", sqle);
        }
        throw new RemoteException ("Error inesperat, no s'ha modifcat el registre", ex);
    } finally {
        ToolsBD.closeConn (conn, ms, null);
    }
}


-----Function Pair=366=-----==

public RestServiceResult listMatrixExercises1ForExercises1 (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises1);
    if (coExercises1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixExercises1.search.notFound"));
    }
    else {
        List < CoMatrixExercises1 > list = new ArrayList < CoMatrixExercises1 > (coExercises1.getCoMatrixExercises1s ());
        Object [] arrayParam = {list.size (), coExercises1.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixExercises1.listMatrixExercises1ForExercises1.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


private void doTestNewsBlockPortletByCode () throws Exception {
    NewsBlockType resultBlock = new NewsBlockType ();
    resultBlock.setIdSiteLanguage (newsBlock.getIdSiteLanguage ());
    for (int i = 0; i < newsBlock.getNewsGroupCount (); i ++) {
        NewsGroupType group = newsBlock.getNewsGroup (i);
        if (NEWS_GROUP_CODE.equals (group.getNewsGroupCode ())) {
            NewsGroupType targetGroup = new NewsGroupType ();
            targetGroup.setNewsGroupName (group.getNewsGroupName ());
            targetGroup.setOrderValue (group.getOrderValue ());
            targetGroup.setNewsGroupId (group.getNewsGroupId ());
            targetGroup.setMaxNews (group.getMaxNews ());
            targetGroup.setNewsGroupCode (group.getNewsGroupCode ());
            long startDate = Long.MAX_VALUE;
            for (int j = 0; j < group.getNewsItemCount () && targetGroup.getNewsItemCount () < group.getMaxNews ().intValue (); j ++) {
                NewsItemType item = getLatestNewsItem (group, startDate);
                startDate = item.getNewsDateTime ().getTime ();
                targetGroup.addNewsItem (item);
            }
            resultBlock.addNewsGroup (targetGroup);
            break;
        }
    }
    XmlTools.writeToFile (resultBlock, SiteUtils.getTempDir () + "news-block-result.xml", "utf-8", null);
    for (int i = 0; i < resultBlock.getNewsGroupCount (); i ++) {
        NewsGroupType groupResult = resultBlock.getNewsGroup (i);
        for (int j = 0; j < newsBlock.getNewsGroupCount (); j ++) {
            NewsGroupType groupOrigin = newsBlock.getNewsGroup (j);
            if (groupOrigin.getNewsGroupId () == groupResult.getNewsGroupId ()) assertFalse ("Wrong number of item in group", groupOrigin.getMaxNews ().intValue () < groupResult.getNewsItemCount ());
        }
    }
    testAbstract.initRequestSession ();
    String str = null;
    try {
    } catch (Exception e) {
        log.error ("Error get localized string", e);
        str = "error";
    }
    for (int i = 0; i < resultBlock.getNewsGroupCount (); i ++) {
        NewsGroupType groupResult = resultBlock.getNewsGroup (i);
        groupResult.setOrderValue (null);
        for (int j = 0; j < groupResult.getNewsItemCount (); j ++) {
            NewsItemType newsItem = groupResult.getNewsItem (j);
            newsItem.setToFullItem (str);
            newsItem.setUrlToFullNewsItem (NewsSite.NAME_ID_NEWS_PARAM + '=' + newsItem.getNewsItemId () + '&');
        }
    }
    String codePortlet = "mill.news_block";
    PortletResultObject obj;
    byte [] resultByte;
    resultBlock.setIdSiteLanguage (null);
    byte [] originByte = XmlTools.getXml (resultBlock, "NewsBlock");
    MainTools.writeToFile (SiteUtils.getTempDir () + "news-by-code-bytes-from-object.xml", originByte);
}


-----Function Pair=367=-----==

public CoGObject getRandom () {
    CoGObject task = null;
    Session session = sessionFactory.openSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query select = session.createQuery ("select task.typename," + "task.jobid," + "task.inputfile," + "task.outputfile," + "task.errorfile," + "task.suspended," + "task.jobtype," + "task.resource," + "task.executable," + "task.directory," + "task.mpi," + "task.walltime " + "from Task task " + "order by rand()");
        select.setMaxResults (1);
        List result = select.list ();
        task = getTask ((Object []) result.get (0));
        session.flush ();
        session.clear ();
        tx.commit ();
    } catch (RuntimeException e) {
        tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
    return task;
}


public Collection < PersisterRecord > getObjects (Class cls) throws PersisterException {
    List < PersisterRecord > list = new ArrayList < PersisterRecord > ();
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    Serializable obj = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("select " + _data_col + "," + _ts_col + " from " + _table_name);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            obj = deserialize (rs.getBinaryStream (_data_col));
            if (rs.wasNull ()) {
                continue;
            }
            long ts = rs.getLong (_ts_col);
            if (rs.wasNull ()) {
                continue;
            }
            if ((cls == null) || ! cls.isAssignableFrom (obj.getClass ())) {
                continue;
            }
            list.add (new PersisterRecord (obj, ts));
        }
        return list;
    } catch (Throwable th) {
        throw new PersisterException ("Failed to get objects from DB", th);
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (Throwable th) {
            }
        }
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=368=-----==

public static void doInsertTask (String user, String subjectid, Hashtable data) throws Exception {
    if (subjectid == null) subjectid = "";
    Db db = null;
    Connection conn = null;
    String sql = "";
    String task_description = (String) data.get ("description");
    if ("".equals (task_description.trim ())) return;
    String year1 = (String) data.get ("year1");
    String month1 = (String) data.get ("month1");
    String day1 = (String) data.get ("day1");
    String hour1 = (String) data.get ("hour1");
    String minute1 = (String) data.get ("minute1");
    String hour2 = (String) data.get ("hour2");
    String minute2 = (String) data.get ("minute2");
    String invitelist = (String) data.get ("invitelist");
    int ispublic = 1;
    String task_date = year1 + "-" + fmt (month1) + "-" + fmt (day1);
    Vector inviteVector = new Vector ();
    StringTokenizer tokenizer = new StringTokenizer (invitelist);
    while (tokenizer.hasMoreTokens ()) {
        String token = tokenizer.nextToken ();
        if (token != null) {
            inviteVector.addElement (token.trim ());
        }
    }
    String id = user.concat (Long.toString (UniqueID.get ()));
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        SQLRenderer r = new SQLRenderer ();
        {
            r.add ("task_id", id);
            r.add ("user_login", user);
            r.add ("task_description", task_description);
            r.add ("task_date", task_date);
            r.add ("hour_start", Integer.parseInt (hour1));
            r.add ("hour_end", Integer.parseInt (hour2));
            r.add ("minute_start", Integer.parseInt (minute1));
            r.add ("minute_end", Integer.parseInt (minute2));
            r.add ("task_public", ispublic);
            r.add ("subject_id", subjectid);
            sql = r.getSQLInsert ("planner_task");
            stmt.executeUpdate (sql);
        }
        {
            sql = "DELETE FROM planner_task_invite WHERE task_id = '" + id + "' ";
            stmt.executeUpdate (sql);
        }
        for (int i = 0; i < inviteVector.size (); i ++) {
            r = new SQLRenderer ();
            r.add ("task_id", id);
            r.add ("user_id", (String) inviteVector.elementAt (i));
            r.add ("inviter_id", user);
            r.add ("allow_edit", 0);
            sql = r.getSQLInsert ("planner_task_invite");
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
        throw dbex;
    } catch (SQLException ex) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (SQLException rex) {
            }
        }
        System.out.println (ex.getMessage () + sql);
        throw ex;
    } finally {
        if (db != null) db.close ();
    }
}


public double getprice (String pid) {
    double price = 0.0;
    Connection conn = null;
    PreparedStatement pm = null;
    ResultSet rs = null;
    try {
        conn = Pool.getConnection ();
        pm = conn.prepareStatement ("select inprice from addwuliao where pid=?");
        pm.setString (1, pid);
        rs = pm.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                price = rs.getDouble ("inprice");
            }
        }
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } catch (Exception e) {
        e.printStackTrace ();
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } finally {
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    }
    return price;
}


-----Function Pair=369=-----==

public static Any getDocTypeInfo (Connection con, Any values, Any retValue) throws SQLException {
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocTypeInfo");
    PreparedStatement stmt = con.prepareStatement (sSql);
    String sTypeID = values.extract_string ();
    stmt.setString (1, sTypeID);
    OracleResultSet rSet = (OracleResultSet) stmt.executeQuery ();
    HashMap map = new HashMap ();
    if (rSet.next ()) {
        BLOB blob = (BLOB) rSet.getBlob ("BXMLTEMP");
        byte cData [] = new byte [0];
        if (blob != null) {
            cData = blob.getBytes (1, (int) blob.length ());
            map.put ("BXMLTEMP", cData);
        }
        ObjAttrs arAttrs = (ObjAttrs) rSet.getORAData ("ATTRS", new ObjAttrs ());
        ObjAttr attrs [] = arAttrs.getArray ();
        ArrayList < HashMap > arAttr = new ArrayList < HashMap > ();
        for (ObjAttr atr : attrs) {
            HashMap mapAttr = new HashMap ();
            mapAttr.put ("NAME", atr.getCname ());
            mapAttr.put ("DESC", atr.getCdesc ());
            mapAttr.put ("TYPE", atr.getCtype ());
            arAttr.add (mapAttr);
        }
        map.put ("ATTR", arAttr.toArray (new HashMap [arAttr.size ()]));
        map.put ("TEMPTYPE", rSet.getString ("ITEMPTYPE"));
        map.put ("CDOCFORM", rSet.getString ("CDOCFORM"));
        map.put ("CAUTONUM", rSet.getString ("CAUTONUM"));
        map.put ("CTYPNAME", rSet.getString ("CTYPNAME"));
    }
    rSet.close ();
    stmt.close ();
    retValue.insert_Value (map);
    return retValue;
}


public String getInsertOrderString () {
    List < String > tMyTable = getAllTables ();
    if (tMyTable.size () == 0) return StringUtil.EMPTY;
    StringBuffer tOutput = new StringBuffer ();
    String tTableName = tMyTable.get (0);
    String tNextTable = null;
    boolean isCanInsert = true;
    while (! tMyTable.isEmpty ()) {
        List < String > tRefTable = getRefTable (tTableName);
        isCanInsert = true;
        for (String s : tRefTable) {
            if (! s.equals (tTableName)) {
                tNextTable = s;
                if (tMyTable.contains (tNextTable)) {
                    tTableName = tNextTable;
                    isCanInsert = false;
                    break;
                }
            }
        }
        if (isCanInsert) {
            if (tMyTable.remove (tTableName)) {
                tOutput.append (tTableName).append (";");
            }
            if (tMyTable.size () > 0) {
                tTableName = tMyTable.get (0);
            }
        }
    }
    return tOutput.toString ();
}


-----Function Pair=370=-----==

private DataSource setUpDataSourse (ServletContext context) throws ClassNotFoundException, InstantiationException, IllegalAccessException {
    String dbDriver = Utils.getFromConfig (context, "dbDriver", null);
    String url = Utils.getFromConfig (context, "dbConnString", null);
    String user = Utils.getFromConfig (context, "dbUser", null);
    String pass = Utils.getFromConfig (context, "dbPass", null);
    Class.forName (dbDriver).newInstance ();
    GenericObjectPool.Config config = new GenericObjectPool.Config ();
    config.timeBetweenEvictionRunsMillis = 60000;
    config.testWhileIdle = true;
    GenericObjectPool connectionPool = new GenericObjectPool (null, config);
    ConnectionFactory connectionFactory = new DriverManagerConnectionFactory (url, user, pass);
    boolean autoCommit = false;
    PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory (connectionFactory, connectionPool, new StackKeyedObjectPoolFactory (), DB.Pool.validationQuery, false, autoCommit);
    PoolingDataSource dataSource = new PoolingDataSource (connectionPool);
    return dataSource;
}


public void executeRead () {
    Session session = null;
    Transaction tx = null;
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        executionResults = session.get (targetClass, (Serializable) parameters.get (DataConnector.RECORD_KEY_PARAMETER));
        if (executionResults != null) {
            responseCode = 0;
            responseString = "Execution complete";
        }
        else {
            responseCode = 1;
            responseString = "Record not found";
        }
        tx.commit ();
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


-----Function Pair=371=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoMultipleChoiceE3 coMultipleChoiceE3) {
    CoMultipleChoiceE3DAO coMultipleChoiceE3DAO = new CoMultipleChoiceE3DAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        coMultipleChoiceE3DAO.update (coMultipleChoiceE3);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMultipleChoiceE3);
        Object [] args = {coMultipleChoiceE3.getMultipleChoiceName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void delete (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            AttributeTable attribute = new AttributeTable ();
            attribute.deleteAllForType (stmt, name);
            String sql = "delete from AttributeCategories " + "where CategoryName = '" + name + "'";
            stmt.executeUpdate (sql);
            conn.commit ();
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=372=-----==

public boolean modifyRanks (Ranks rank) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (rank);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public void leer () {
    Connection conn = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        conn = ToolsBD.getConn ();
        String sentenciaSql = "SELECT * FROM BZMODIF WHERE FZJCENSA='E' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND" + " FZJFMODI=? AND FZJHMODI=?";
        ps = conn.prepareStatement (sentenciaSql);
        ps.setInt (1, oficina);
        ps.setInt (2, numeroRegistro);
        ps.setInt (3, anoEntrada);
        ps.setString (4, fechaModificacion);
        ps.setString (5, horaModificacion);
        rs = ps.executeQuery ();
        if (rs.next ()) {
            leido = true;
            anoEntrada = rs.getInt ("FZJANOEN");
            entidad1 = rs.getString ("FZJCENTI");
            entidad2 = rs.getInt ("FZJNENTI");
            entidad1Catalan = ToolsBD.convierteEntidad (entidad1, conn);
            extracto = rs.getString ("FZJCONEN");
            usuarioModificacion = rs.getString ("FZJCUSMO");
            usuarioVisado = rs.getString ("FZJCUSVI");
            indVisRemitente = rs.getString ("FZJIREMI");
            indVisExtracto = rs.getString ("FZJIEXTR");
            numeroRegistro = rs.getInt ("FZJNUMEN");
            remitente = rs.getString ("FZJREMIT");
            motivo = rs.getString ("FZJTEXTO");
            oficina = rs.getInt ("FZJCAGCO");
            if (! (rs.getString ("FZJIREMI").equals (" ") || rs.getString ("FZJIREMI").equals (""))) {
                entidad1 = "";
                entidad1Catalan = "";
                entidad2 = 0;
                remitente = "";
            }
            if (! (rs.getString ("FZJIEXTR").equals (" ") || rs.getString ("FZJIEXTR").equals (""))) {
                extracto = "";
            }
            Date fechaSystem = new Date ();
            DateFormat aaaammdd = new SimpleDateFormat ("yyyyMMdd");
            DateFormat hhmmss = new SimpleDateFormat ("HHmmss");
            DateFormat sss = new SimpleDateFormat ("S");
            String ss = sss.format (fechaSystem);
            int fzahsis = Integer.parseInt (hhmmss.format (fechaSystem) + ss);
            String Stringsss = sss.format (fechaSystem);
            switch (Stringsss.length ()) {
                case (1) :
                    Stringsss = "00" + Stringsss;
                    break;
                case (2) :
                    Stringsss = "0" + Stringsss;
                    break;
            }
            int horamili = Integer.parseInt (hhmmss.format (fechaSystem) + Stringsss);
            int fzafsis = Integer.parseInt (aaaammdd.format (fechaSystem));
            logLopdBZMODIF ("SELECT", sessioEjb.getCallerPrincipal ().getName ().toUpperCase (), fzafsis, horamili, 'E', numeroRegistro, anoEntrada, oficina, Integer.parseInt (fechaModificacion), Integer.parseInt (horaModificacion));
        }
    } catch (Exception e) {
        System.out.println ("Error: " + e.getMessage ());
        e.printStackTrace ();
        leido = false;
    } finally {
        ToolsBD.closeConn (conn, ps, rs);
    }
}


-----Function Pair=373=-----==

public synchronized RemoteFileState storeReady (RemoteFileState in) throws Exception {
    _logger.trace ("Storing as ready (" + in.filename + ")");
    if (trialRun) return in;
    Db db = getDb ();
    try {
        db.begin ();
        in.state = FileStates.DOWNLOADING;
        ps_update_state.setInt (1, in.state.getId ());
        ps_update_state.setInt (2, in.remote_file_state_id);
        db.executeUpdate (ps_update_state);
        updateMetadataInTx (in);
        return in;
    } catch (Exception e) {
        db.rollback ();
        throw e;
    } finally {
        db.commitUnless ();
    }
}


public Object execute (Object [] vars, Map < Object, Object > parameter) {
    if (vars.length == 2 && vars [0] != null && vars [1] != null) {
        Method method;
        try {
            method = vars [0].getClass ().getMethod ((String) vars [1], new Class [0]);
            return method.invoke (vars [0], new Object [0]);
        } catch (SecurityException e) {
            e.printStackTrace ();
        } catch (NoSuchMethodException e) {
            e.printStackTrace ();
        } catch (IllegalArgumentException e) {
            e.printStackTrace ();
        } catch (IllegalAccessException e) {
            e.printStackTrace ();
        } catch (InvocationTargetException e) {
            e.printStackTrace ();
        }
    }
    return null;
}


-----Function Pair=374=-----==

public static ExperimentResult getById (int id) throws NoConnectionToDBException, SQLException, ExperimentResultNotInDBException, PropertyTypeNotExistException, IOException, PropertyNotInDBException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (selectQuery + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (! rs.next ()) {
        rs.close ();
        ps.close ();
        throw new ExperimentResultNotInDBException ();
    }
    ExperimentResult er = getExperimentResultFromResultSet (rs);
    rs.close ();
    ps.close ();
    ExperimentResultHasPropertyDAO.assign (er);
    return er;
}


public static Order GetMostRecentOrder (String c_uname, Vector order_lines) {
    Connection con = null;
    try {
        order_lines.removeAllElements ();
        int order_id;
        Order order;
        con = getConnection ();
        {
            PreparedStatement get_most_recent_order_id = con.prepareStatement ("SELECT o_id " + "FROM customer, orders " + "WHERE customer.c_id = orders.o_c_id " + "AND c_uname = ? " + "ORDER BY o_date, orders.o_id DESC " + "LIMIT 0,1");
            get_most_recent_order_id.setString (1, c_uname);
            ResultSet rs = get_most_recent_order_id.executeQuery ();
            if (rs.next ()) {
                order_id = rs.getInt ("o_id");
            }
            else {
                rs.close ();
                get_most_recent_order_id.close ();
                con.commit ();
                returnConnection (con);
                return null;
            }
            rs.close ();
            get_most_recent_order_id.close ();
        }
        {
            PreparedStatement get_order = con.prepareStatement ("SELECT orders.*, customer.*, " + "  cc_xacts.cx_type, " + "  ship.addr_street1 AS ship_addr_street1, " + "  ship.addr_street2 AS ship_addr_street2, " + "  ship.addr_state AS ship_addr_state, " + "  ship.addr_zip AS ship_addr_zip, " + "  ship_co.co_name AS ship_co_name, " + "  bill.addr_street1 AS bill_addr_street1, " + "  bill.addr_street2 AS bill_addr_street2, " + "  bill.addr_state AS bill_addr_state, " + "  bill.addr_zip AS bill_addr_zip, " + "  bill_co.co_name AS bill_co_name " + "FROM customer, orders, cc_xacts," + "  address AS ship, " + "  country AS ship_co, " + "  address AS bill,  " + "  country AS bill_co " + "WHERE orders.o_id = ? " + "  AND cx_o_id = orders.o_id " + "  AND customer.c_id = orders.o_c_id " + "  AND orders.o_bill_addr_id = bill.addr_id " + "  AND bill.addr_co_id = bill_co.co_id " + "  AND orders.o_ship_addr_id = ship.addr_id " + "  AND ship.addr_co_id = ship_co.co_id " + "  AND orders.o_c_id = customer.c_id");
            get_order.setInt (1, order_id);
            ResultSet rs2 = get_order.executeQuery ();
            if (! rs2.next ()) {
                con.commit ();
                rs2.close ();
                returnConnection (con);
                return null;
            }
            order = new Order (rs2);
            rs2.close ();
            get_order.close ();
        }
        {
            PreparedStatement get_order_lines = con.prepareStatement ("SELECT * " + "FROM order_line, item " + "WHERE ol_o_id = ? " + "AND ol_i_id = i_id");
            get_order_lines.setInt (1, order_id);
            ResultSet rs3 = get_order_lines.executeQuery ();
            while (rs3.next ()) {
                order_lines.addElement (new OrderLine (rs3));
            }
            rs3.close ();
            get_order_lines.close ();
        }
        con.commit ();
        returnConnection (con);
        return order;
    } catch (java.lang.Exception ex) {
        try {
            con.rollback ();
            ex.printStackTrace ();
        } catch (Exception se) {
            System.err.println ("Transaction rollback failed.");
        }
    }
    return null;
}


-----Function Pair=375=-----==

public void createSchema (String schemaName, String pass, String objController, long boui) throws SQLException, boRuntimeException {
    try {
        String dml = null;
        String parentName = "default";
        String usingSchema = p_ctx.getBoSession ().getRepository ().getSchemaName ();
        String creationScript = null;
        boolean regist = false;
        if (! existsSchema (p_ctx, schemaName)) {
            creationScript = "CREATE USER " + schemaName + " IDENTIFIED BY " + pass;
            creationScript += (" DEFAULT TABLESPACE " + TABLESPACE_NAME + " QUOTA unlimited ON " + TABLESPACE_NAME);
            executeDDL (creationScript, p_ctx.getBoSession ().getRepository ().getName ());
            regist = true;
        }
        dml = "GRANT connect,ctxapp, dba to " + schemaName;
        executeDDL (dml, p_ctx.getBoSession ().getRepository ().getName ());
        if (boConfig.getConfigRepository (schemaName) == null) {
            boDataSource bds = new boDataSource (schemaName, schemaName, schemaName, schemaName, "", "", parentName);
            bds.writeTo ();
        }
        registerSchema (schemaName, objController, boui, creationScript, usingSchema);
    } finally {
    }
}


public boolean isParent (long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select count(R) from TT R where R.parentTxId=?";
        Query q = s.createQuery (query);
        q.setLong (0, txId);
        List l = q.list ();
        return l.size () != 0;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=376=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nMatrixId) {
    CoMatrixQuestion coMatrixQuestion = new CoMatrixQuestionDAO ().findById (nMatrixId);
    if (coMatrixQuestion == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("matrixQuestion.search.notFound"));
    }
    else {
        List < CoMatrixQuestion > list = new ArrayList < CoMatrixQuestion > ();
        EntityManagerHelper.refresh (coMatrixQuestion);
        list.add (coMatrixQuestion);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("matrixQuestion.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


protected void doNew (Connection con) throws Exception {
    if (! isValidate ()) {
        throw new CesSystemException ("User_session.doNew(): Illegal data values for insert");
    }
    PreparedStatement ps = null;
    String strQuery = "INSERT INTO " + Common.USER_SESSION_TABLE + "(session_id,user_id,begin_date,ip_address,mac_no,login_id)" + "VALUES (?,?,?,?,?,?)";
    try {
        ps = con.prepareStatement (strQuery);
        ps.setString (1, this.sessionID);
        ps.setInt (2, this.user.getUserID ());
        ps.setTimestamp (3, this.beginDate);
        ps.setString (4, this.ipAddress);
        ps.setString (5, this.macNO);
        ps.setString (6, this.loginID);
        int resultCount = ps.executeUpdate ();
        if (resultCount != 1) {
            throw new CesSystemException ("User_session.doNew(): ERROR Inserting data " + "in T_SYS_USER_SESSION INSERT !! resultCount = " + resultCount);
        }
    } catch (SQLException se) {
        throw new CesSystemException ("User_session.doNew(): SQLException while inserting new user_session; " + "session_id = " + this.sessionID + " :\n\t" + se);
    } finally {
        closePreparedStatement (ps);
    }
}


-----Function Pair=377=-----==

public final boolean delete () throws RecordException {
    if (frozen) {
        throw new RecordException ("The object is frozen.");
    }
    Connection conn = ConnectionManager.getConnection ();
    LoggableStatement pStat = null;
    Class < ? extends Record > actualClass = this.getClass ();
    StatementBuilder builder = null;
    try {
        builder = new StatementBuilder ("delete from " + TableNameResolver.getTableName (actualClass) + " where id = :id");
        Field f = FieldHandler.findField (this.getClass (), "id");
        builder.set ("id", FieldHandler.getValue (f, this));
        pStat = builder.getPreparedStatement (conn);
        log.log (pStat.getQueryString ());
        int i = pStat.executeUpdate ();
        return i == 1;
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback");
        }
        throw new RecordException (e);
    } finally {
        try {
            if (pStat != null) {
                pStat.close ();
            }
            conn.commit ();
            conn.close ();
        } catch (SQLException e) {
            throw new RecordException ("Error closing connection");
        }
    }
}


public final void saveOrUpdate (final T obj) throws CannotConnectToDatabaseException {
    if (obj != null) {
        final Session s = this.currentSession ();
        Transaction tx = null;
        try {
            tx = s.beginTransaction ();
            s.saveOrUpdate (obj);
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (HibernateException he) {
            tx.rollback ();
            LOGGER.error ("Failed to save or update entity - transaction was rolled back.", he);
            throw he;
        } finally {
            s.close ();
        }
    }
}


-----Function Pair=378=-----==

private void selfDefineAdd (String [] path, Site site, Connection connection, PreparedStatement preparedStatement) throws SQLException {
    List selfDefine = site.getSelfDefineList ();
    try {
        for (int j = 0; j < path.length; j ++) {
            for (int i = 0; i < selfDefine.size (); i ++) {
                Map map = (Map) selfDefine.get (i);
                preparedStatement = connection.prepareStatement ("insert into t_ip_fieldset (path," + " field,field_name,order_no) values (?,?,?,?)  ");
                preparedStatement.setString (1, path [j]);
                preparedStatement.setString (2, (String) map.get ("field"));
                preparedStatement.setString (3, (String) map.get ("field_name"));
                preparedStatement.setInt (4, Integer.parseInt ((String) map.get ("order_no")));
                int flag = preparedStatement.executeUpdate ();
            }
        }
    } catch (SQLException e) {
        e.printStackTrace ();
        log.error ("��������վ���Զ����ֶ�ʧ�ܣ�");
        throw e;
    }
}


public List getCommunityBitstreams (int communityId) {
    List ids = new ArrayList ();
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        conn = DatabaseManager.getConnection ();
        ps = conn.prepareStatement (COMMUNITY_BITSTREAMS);
        ps.setInt (1, communityId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            ids.add (new Integer (rs.getInt (1)));
        }
    } catch (SQLException e) {
        LOG.error ("get item bitstreams " + e.getMessage (), e);
        throw new RuntimeException ("get item bitstreams. " + e.getMessage (), e);
    } finally {
        cleanup (ps, conn, rs);
    }
    return ids;
}


-----Function Pair=379=-----==

public Object getObject (String id) throws SQLException {
    if (id == null) {
        return null;
    }
    Object obj = null;
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        if (dbConnection == null) {
            DatabaseConn dbConn = new DatabaseConn ();
            conn = dbConn.getConnection ();
        }
        else {
            conn = dbConnection;
        }
        stmt = conn.prepareStatement (this.selectSql);
        System.out.println ("*****************" + selectSql);
        stmt.setString (1, id);
        rs = stmt.executeQuery ();
        if (rs.next ()) obj = get (rs);
    } catch (Exception e) {
        e.printStackTrace ();
        throw new SQLException (e.getMessage ());
    } finally {
        if (rs != null) {
            rs.close ();
            rs = null;
        }
        if (stmt != null) {
            stmt.close ();
            stmt = null;
        }
        if (dbConnection == null && conn != null) {
            conn.close ();
            conn = null;
        }
    }
    return obj;
}


public void testMemberOfViaUnboundVariableJoinTable () {
    try {
        EntityManager em = getEM ();
        EntityTransaction tx = em.getTransaction ();
        try {
            tx.begin ();
            Employee e1 = new Employee (101, "Fred", "Flintstone", "fred.flintstone@jpox.com", 30000f, "1234A");
            Employee e2 = new Employee (102, "Barney", "Rubble", "barney.rubble@jpox.com", 27000f, "1234B");
            Employee e3 = new Employee (103, "George", "Cement", "george.cement@jpox.com", 20000f, "1235C");
            Manager mgr1 = new Manager (100, "Chief", "Rock", "chief.rock@warnerbros.com", 40000.0f, "12345A");
            mgr1.setBestFriend (e1);
            Manager mgr2 = new Manager (106, "Boss", "Blaster", "boss.blaster@warnerbros.com", 40005.0f, "12345B");
            mgr2.setBestFriend (e2);
            mgr1.addSubordinate (e1);
            mgr1.addSubordinate (e2);
            e1.setManager (mgr1);
            e2.setManager (mgr1);
            mgr2.addSubordinate (e3);
            e3.setManager (mgr2);
            em.persist (mgr1);
            em.persist (mgr2);
            em.flush ();
            tx.commit ();
            tx.begin ();
            List result = em.createQuery ("SELECT DISTINCT Object(m) FROM " + Manager.class.getName () + " m," + Employee.class.getName () + " e " + "WHERE e MEMBER OF m.subordinates AND e.firstName = 'Barney'").getResultList ();
            assertEquals (1, result.size ());
            Manager mgr = (Manager) result.get (0);
            assertEquals ("Manager returned from MEMBER OF query has incorrect firstName", "Chief", mgr.getFirstName ());
            assertEquals ("Manager returned from MEMBER OF query has incorrect lastName", "Rock", mgr.getLastName ());
            tx.commit ();
        } catch (Exception e) {
            LOG.error ("Exception in test", e);
            fail ("Exception thrown generating query with MEMBER syntax " + e.getMessage ());
        } finally {
            if (tx.isActive ()) {
                tx.rollback ();
            }
            em.close ();
        }
    } finally {
        clean (Manager.class);
        clean (Employee.class);
    }
}


-----Function Pair=380=-----==

public void registerSchema (String newSchemaName, String objectControlller, long boui, String expression, String schema) throws SQLException {
    Connection cndef = null;
    PreparedStatement pstm = null;
    try {
        cndef = this.getRepositoryConnection (p_ctx.getApplication (), "default", 2);
        String friendlyName = MessageLocalizer.getMessage ("SCHEMA_CREATED_BY_OBJECT") + " [" + objectControlller + "] " + MessageLocalizer.getMessage ("WITH_BOUI") + " [" + boui + "]";
        pstm = cndef.prepareStatement ("DELETE FROM NGTDIC WHERE TABLENAME=? and objecttype='S'");
        pstm.setString (1, newSchemaName);
        pstm.executeUpdate ();
        pstm.close ();
        pstm = cndef.prepareStatement ("INSERT INTO NGTDIC (SCHEMA,OBJECTNAME,OBJECTTYPE,TABLENAME, " + "FRIENDLYNAME, EXPRESSION) VALUES (" + "?,?,?,?,?,?)");
        pstm.setString (1, schema);
        pstm.setString (2, newSchemaName);
        pstm.setString (3, "S");
        pstm.setString (4, newSchemaName);
        pstm.setString (5, friendlyName);
        pstm.setString (6, expression);
        pstm.executeUpdate ();
        pstm.close ();
        cndef.commit ();
    } catch (Exception e) {
        cndef.rollback ();
        e.printStackTrace ();
        throw new SQLException (e.getMessage ());
    } finally {
        if (pstm != null) {
            try {
                pstm.close ();
            } catch (Exception e) {
            }
        }
    }
}


private void changeModeTo (int newMode) {
    switch (newMode) {
        case (MODE_BROWSE_HISTORY) :
            mode = MODE_BROWSE_HISTORY;
            commandTextComponent.setForeground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_FOREGROUND_COLOR).getValue ());
            commandTextComponent.setBackground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_BACKGROUND_COLOR).getValue ());
            commandTextComponent.setCaretColor ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_FOREGROUND_COLOR).getValue ());
            marginTextArea.setForeground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_FOREGROUND_COLOR).getValue ());
            marginTextArea.setBackground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_BACKGROUND_COLOR).getValue ());
            marginTextArea.setCaretColor ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_BROWSE_MODE_FOREGROUND_COLOR).getValue ());
            break;
        case (MODE_EDIT) :
            mode = MODE_EDIT;
            commandTextComponent.setForeground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_FOREGROUND_COLOR).getValue ());
            commandTextComponent.setBackground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_BACKGROUND_COLOR).getValue ());
            commandTextComponent.setCaretColor ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_FOREGROUND_COLOR).getValue ());
            marginTextArea.setForeground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_FOREGROUND_COLOR).getValue ());
            marginTextArea.setBackground ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_BACKGROUND_COLOR).getValue ());
            marginTextArea.setCaretColor ((Color) EXQLModuleManager.instance ().getPreference (EXQLConstants.COMMANDER_EDIT_MODE_FOREGROUND_COLOR).getValue ());
            break;
    }
}


-----Function Pair=381=-----==

private int getInt (String sql) throws SQLException {
    ResultSet rs = null;
    try {
        rs = keepAliveStmt.executeQuery (sql);
        int nextId = - 1;
        while (rs.next ()) {
            nextId = rs.getInt (1);
            if (nextId == 0) {
                nextId = 1;
            }
        }
        return nextId;
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
}


public List < Concern > getLinkedConcerns (ConcernDomain concernDomain, Component component, EdgeKind linkType, IConcernListener changeListener) {
    List < Concern > linkedConcerns = null;
    try {
        ResultSet resultSet = executeQuery (GET_CONCERNS_FOR_COMPONENT, component.getId (), getEdgeKindId (linkType));
        while (resultSet.next ()) {
            Concern candidateConcern = new Concern (this, changeListener, resultSet);
            if (candidateConcern.isInConcernDomain (concernDomain)) {
                if (linkedConcerns == null) linkedConcerns = new ArrayList < Concern > ();
                linkedConcerns.add (candidateConcern);
            }
        }
        resultSet = null;
    } catch (SQLException e) {
        ProblemManager.reportException (e);
    }
    return linkedConcerns;
}


-----Function Pair=382=-----==

private void publishing (Message message, Registry registry) {
    try {
        ReplicationInterface listener = (ReplicationInterface) (registry.lookup (_REPLICATION_SERVER_NAME));
        logger.info (String.format ("host %s pulish replication message to host %s: %s", thisServer, registryMap.get (registry), message.toString ()));
        listener.process (message);
        listener = null;
        String server = registryMap.get (registry);
        serverMap.put (server, 0L);
    } catch (Exception e) {
        String server = registryMap.get (registry);
        long failedCount = serverMap.get (server) + 1;
        if (failedCount <= 5) {
            serverMap.put (server, failedCount);
            saveMessage (server, message);
        }
        else {
            registries.remove (registry);
            serverMap.remove (server);
            offlineServers.add (server);
        }
    }
}


public Object executeSimple (JdbcTaskContext context) {
    SleeTransaction tx = null;
    try {
        tx = context.getSleeTransactionManager ().beginSleeTransaction ();
        Connection connection = context.getConnection ();
        Statement statement = connection.createStatement ();
        tracer.info ("Created statement to create table, executing query...");
        statement.execute ("CREATE TABLE TestTable (Name VARCHAR(30));");
        PreparedStatement preparedStatement = connection.prepareStatement ("INSERT INTO TestTable VALUES(?)");
        preparedStatement.setString (1, "Mobicents");
        tracer.info ("Created prepared statement for data insert, executing...");
        preparedStatement.execute ();
        preparedStatement = connection.prepareStatement ("SELECT ? From TestTable;");
        preparedStatement.setString (1, "Name");
        tracer.info ("Created prepared statement for data query, executing...");
        preparedStatement.execute ();
        ResultSet resultSet = preparedStatement.getResultSet ();
        resultSet.next ();
        tracer.info ("Data query first result: " + resultSet.getString (1));
        Statement anotherStatement = connection.createStatement ();
        tracer.info ("Created statement to drop table, executing update...");
        anotherStatement.executeUpdate ("DROP TABLE TestTable;");
        tx.commit ();
        tx = null;
        return true;
    } catch (Exception e) {
        tracer.severe ("failed to create table", e);
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Exception f) {
                tracer.severe ("failed to rollback tx", f);
            }
        }
        return false;
    }
}


-----Function Pair=383=-----==

public void onServiceStartedEvent (ServiceStartedEvent event, ActivityContextInterface aci) {
    tracer.info ("JDBC Example started.");
    JdbcActivity jdbcActivity = jdbcRA.createActivity ();
    tracer.info ("Created JDBC RA activity, using RA's SBB Interface.");
    ActivityContextInterface jdbcACI = jdbcACIF.getActivityContextInterface (jdbcActivity);
    jdbcACI.attach (contextExt.getSbbLocalObject ());
    tracer.info ("Retrieved the ACI related to the JDBC RA activity, and attached the sbb entity.");
    SimpleJdbcTask task = new SimpleJdbcTask () {
        @Override
        public Object executeSimple (JdbcTaskContext context) {
            SleeTransaction tx = null;
            try {
                tx = context.getSleeTransactionManager ().beginSleeTransaction ();
                Connection connection = context.getConnection ();
                Statement statement = connection.createStatement ();
                tracer.info ("Created statement to create table, executing query...");
                statement.execute ("CREATE TABLE TestTable (Name VARCHAR(30));");
                PreparedStatement preparedStatement = connection.prepareStatement ("INSERT INTO TestTable VALUES(?)");
                preparedStatement.setString (1, "Mobicents");
                tracer.info ("Created prepared statement for data insert, executing...");
                preparedStatement.execute ();
                preparedStatement = connection.prepareStatement ("SELECT ? From TestTable;");
                preparedStatement.setString (1, "Name");
                tracer.info ("Created prepared statement for data query, executing...");
                preparedStatement.execute ();
                ResultSet resultSet = preparedStatement.getResultSet ();
                resultSet.next ();
                tracer.info ("Data query first result: " + resultSet.getString (1));
                Statement anotherStatement = connection.createStatement ();
                tracer.info ("Created statement to drop table, executing update...");
                anotherStatement.executeUpdate ("DROP TABLE TestTable;");
                tx.commit ();
                tx = null;
                return true;
            } catch (Exception e) {
                tracer.severe ("failed to create table", e);
                if (tx != null) {
                    try {
                        tx.rollback ();
                    } catch (Exception f) {
                        tracer.severe ("failed to rollback tx", f);
                    }
                }
                return false;
            }
        }
    }
    ;
    jdbcActivity.execute (task);
}


private void doDeleteTask (HttpSession session) {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        String task_id = getParam ("task_id");
        sql = "DELETE FROM planner_task WHERE task_id = '" + task_id + "'";
        stmt.executeUpdate (sql);
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
    } catch (SQLException ex) {
        System.out.println (ex.getMessage () + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=384=-----==

private static void createPortalLogin (String login, String password, String name) throws Exception {
    String sql = "";
    Connection conn = null;
    Db db = null;
    try {
        db = new Db ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            sql = "select user_login from users where user_login = '" + login + "'";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (! found) {
            {
                r.add ("user_login", login);
                r.add ("user_password", mecca.util.PasswordService.encrypt (password));
                r.add ("user_name", name);
                r.add ("user_role", "student");
                sql = r.getSQLInsert ("users");
                stmt.executeUpdate (sql);
            }
            {
                sql = "select css_name from user_css where user_login = 'student'";
                ResultSet rs = stmt.executeQuery (sql);
                String css_name = "default.css";
                if (rs.next ()) css_name = rs.getString ("css_name");
                sql = "insert into user_css (user_login, css_name) values ('" + login + "', '" + css_name + "')";
                stmt.executeUpdate (sql);
            }
            {
                Vector vector = new Vector ();
                {
                    sql = "select tab_id, tab_title, sequence, display_type from tab_template where user_login = 'student'";
                    ResultSet rs = stmt.executeQuery (sql);
                    while (rs.next ()) {
                        Hashtable h = new Hashtable ();
                        h.put ("tab_id", rs.getString ("tab_id"));
                        h.put ("tab_title", rs.getString ("tab_title"));
                        h.put ("sequence", rs.getString ("sequence"));
                        h.put ("display_type", rs.getString ("display_type"));
                        vector.addElement (h);
                    }
                }
                {
                    for (int i = 0; i < vector.size (); i ++) {
                        Hashtable h = (Hashtable) vector.elementAt (i);
                        r.clear ();
                        r.add ("tab_id", (String) h.get ("tab_id"));
                        r.add ("tab_title", (String) h.get ("tab_title"));
                        r.add ("sequence", Integer.parseInt ((String) h.get ("sequence")));
                        r.add ("display_type", (String) h.get ("display_type"));
                        r.add ("user_login", login);
                        sql = r.getSQLInsert ("tab");
                        stmt.executeUpdate (sql);
                    }
                }
            }
            {
                Vector vector = new Vector ();
                {
                    sql = "select tab_id, module_id, sequence, module_custom_title, column_number " + "from user_module_template where user_login = 'student'";
                    ResultSet rs = stmt.executeQuery (sql);
                    while (rs.next ()) {
                        Hashtable h = new Hashtable ();
                        h.put ("tab_id", rs.getString ("tab_id"));
                        h.put ("module_id", rs.getString ("module_id"));
                        h.put ("sequence", rs.getString ("sequence"));
                        h.put ("module_custom_title", mecca.db.Db.getString (rs, "module_custom_title"));
                        String coln = mecca.db.Db.getString (rs, "column_number");
                        h.put ("column_number", coln.equals ("") ? "0" : coln);
                        vector.addElement (h);
                    }
                }
                if (vector.size () > 0) {
                    for (int i = 0; i < vector.size (); i ++) {
                        Hashtable h = (Hashtable) vector.elementAt (i);
                        r.clear ();
                        r.add ("tab_id", (String) h.get ("tab_id"));
                        r.add ("module_id", (String) h.get ("module_id"));
                        r.add ("sequence", Integer.parseInt ((String) h.get ("sequence")));
                        r.add ("module_custom_title", (String) h.get ("module_custom_title"));
                        r.add ("column_number", Integer.parseInt ((String) h.get ("column_number")));
                        r.add ("user_login", login);
                        sql = r.getSQLInsert ("user_module");
                        stmt.executeUpdate (sql);
                    }
                }
            }
        }
        else {
            r.add ("user_name", name);
            r.update ("user_login", login);
            sql = r.getSQLUpdate ("users");
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (Exception ex) {
        try {
            conn.rollback ();
        } catch (SQLException rollex) {
        }
        throw ex;
    } finally {
        if (db != null) db.close ();
    }
}


public void doCallableStatementReader (Connection conn, String id) throws SQLException {
    try {
        for (int i = 0; i < 5; i ++) {
            CallableStatement s1 = conn.prepareCall ("{call select_many_threads(?)}");
            s1.setInt (1, i);
            execute (s1, true);
            executeQuery (s1);
            s1.close ();
        }
        if (! conn.getAutoCommit ()) {
            conn.commit ();
        }
    } catch (SQLException e) {
        if (! conn.getAutoCommit ()) {
            try {
                conn.rollback ();
            } catch (SQLException e2) {
            }
        }
    }
}


-----Function Pair=385=-----==

public void delete (Semester obj) throws DeleteException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria critDel = new Criteria ();
    critDel.addCriterion ("SEMESTER_ID", obj.getId ());
    try {
        stmt.executeUpdate (new DeleteQuery (TABLE_NAME, critDel).toString ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new DeleteException (TABLE_NAME + " Deletion exception :", e);
    }
}


protected boolean delete (Long photoId) {
    String q = "delete from PhotoEn obj where obj.photoId=:photoId";
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        Query query = em.createQuery (q);
        query.setParameter ("photoId", photoId);
        tx.begin ();
        int result = query.executeUpdate ();
        tx.commit ();
        return (result >= 1);
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=386=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private int insertRecord (LDAPAttributeSet attribs, Connection con, HashMap < String, String > db2ldap, String uid, boolean returnId) throws SQLException {
    con.setAutoCommit (false);
    PreparedStatement ps = con.prepareStatement (this.insertSQL);
    int ii = 0;
    for (int i = 0; i < this.fields.size (); i ++) {
        String field = this.fields.get (i);
        if (! field.equalsIgnoreCase (this.idField)) {
            if (field.equals (this.rdnField)) {
                ps.setString (ii + 1, uid);
            }
            else {
                String sdb2ldap = db2ldap.get (field);
                LDAPAttribute attrib = attribs.getAttribute (sdb2ldap);
                ps.setString (ii + 1, attrib.getStringValue ());
            }
            ii ++;
        }
    }
    ps.executeUpdate ();
    con.commit ();
    if (returnId) {
        ResultSet keys = ps.getGeneratedKeys ();
        keys.next ();
        int key = keys.getInt (1);
        return key;
    }
    else {
        return - 1;
    }
}


-----Function Pair=387=-----==

public TEntity update (TEntity entity) throws GenericPersistenceException {
    EntityManager em = null;
    try {
        em = EMFactory.getEntityManagerFactory (this.puName).createEntityManager ();
        em.getTransaction ().begin ();
        entity = em.merge (entity);
        em.getTransaction ().commit ();
        return entity;
    } catch (Exception ex) {
        if (em != null) if (em.getTransaction ().isActive ()) em.getTransaction ().rollback ();
        throw (GenericPersistenceException) this.createGenericPersistenceException (ex).initCause (ex);
    } finally {
        if (em != null) em.close ();
    }
}


boolean checkAccessMySql (final DatabaseAdapter adapter, final String userLogin, String userPassword, final String serverName) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    boolean isValid = false;
    String sql_ = "select a.* from WM_AUTH_USER a, WM_LIST_USER b " + "where  a.USER_LOGIN=? and a.USER_PASSWORD=? and " + "       a.ID_USER = b.ID_USER and b.is_deleted=0";
    try {
        Long idSite = SiteList.getSiteId (serverName);
        if (log.isDebugEnabled ()) {
            log.debug ("serverName " + serverName + ", idSite " + idSite);
        }
        ps = adapter.prepareStatement (sql_);
        ps.setString (1, userLogin);
        ps.setString (2, userPassword);
        rs = ps.executeQuery ();
        if (! rs.next ()) return false;
        WmAuthUserItemType item = GetWmAuthUserItem.fillBean (rs);
        rs.close ();
        rs = null;
        ps.close ();
        ps = null;
        if (Boolean.TRUE.equals (item.getIsRoot ())) return true;
        sql_ = "select  a01.id_firm, a01.user_login, a01.id_user, a01.id_auth_user " + "from    WM_AUTH_USER a01, WM_PORTAL_LIST_SITE f01 " + "where   a01.is_use_current_firm = 1 and a01.ID_FIRM = f01.ID_FIRM and f01.ID_SITE=? and " + "        a01.user_login=? " + "union " + "select  d02.ID_COMPANY, a02.user_login, a02.id_user, a02.id_auth_user " + "from    WM_AUTH_USER a02, WM_LIST_R_HOLDING_COMPANY d02, WM_PORTAL_LIST_SITE f02 " + "where   a02.IS_HOLDING = 1 and a02.ID_HOLDING = d02.ID_HOLDING and " + "        d02.ID_COMPANY = f02.ID_FIRM and f02.ID_SITE=? and a02.user_login=? " + "union " + "select  b04.id_firm, a04.user_login, a04.id_user, a04.id_auth_user " + "from    WM_AUTH_USER a04, WM_LIST_COMPANY b04, WM_PORTAL_LIST_SITE f04 " + "where   a04.is_root = 1 and b04.ID_FIRM = f04.ID_FIRM and f04.ID_SITE=? and " + "        a04.user_login=? ";
        ps = adapter.prepareStatement (sql_);
        RsetTools.setLong (ps, 1, idSite);
        ps.setString (2, userLogin);
        RsetTools.setLong (ps, 3, idSite);
        ps.setString (4, userLogin);
        RsetTools.setLong (ps, 5, idSite);
        ps.setString (6, userLogin);
        rs = ps.executeQuery ();
        if (rs.next ()) isValid = true;
    } catch (Exception e1) {
        log.error ("SQL:\n" + sql_);
        final String es = "Error check checkAccess()";
        log.error (es, e1);
        throw new IllegalStateException (es, e1);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
    if (log.isDebugEnabled ()) log.debug ("isValid " + isValid);
    return isValid;
}


-----Function Pair=388=-----==

private static void initRenderParameters (Map parameterMap, ActionResponse actionResponse) {
    log.debug ("Start initRenderParameters()");
    if (! parameterMap.entrySet ().isEmpty ()) {
        log.debug ("Request parameter");
        Map < String, String [] > map = parameterMap;
        for (Map.Entry < String, String [] > entry : map.entrySet ()) {
            if ((entry.getKey ()).equals (MemberConstants.MEMBER_ACTION_PARAM)) {
                actionResponse.setRenderParameter (MemberConstants.MEMBER_ACTION_PARAM, ContentTypeActionType.INDEX.toString ());
            }
            else if ((entry.getKey ()).equals (MemberConstants.MEMBER_SUBACTION_PARAM)) {
            }
            else {
                for (String v : entry.getValue ()) {
                    actionResponse.setRenderParameter (entry.getKey (), v);
                }
            }
            if (log.isDebugEnabled ()) {
                log.debug ("    key: " + entry.getKey () + ", value: " + StringTools.arrayToString (entry.getValue ()));
            }
        }
    }
    else {
        log.debug ("Parameters for render request not found");
    }
}


public StringSet querySiteUuid (String siteUuid) throws SQLException {
    siteUuid = Val.chkStr (siteUuid);
    PreparedStatement st = null;
    StringSet uuids = new StringSet (false, true, true);
    try {
        Connection con = returnConnection ().getJdbcConnection ();
        String sSql = null;
        if (getIsDbCaseSensitive (this.getRequestContext ())) {
            sSql = "SELECT DOCUUID FROM " + getResourceTableName () + " WHERE SITEUUID=? AND UPPER(PUBMETHOD)=?";
        }
        else {
            sSql = "SELECT DOCUUID FROM " + getResourceTableName () + " WHERE SITEUUID=? AND PUBMETHOD=?";
        }
        logExpression (sSql);
        st = con.prepareStatement (sSql);
        st.setString (1, siteUuid);
        st.setString (2, MmdEnums.PublicationMethod.harvester.toString ().toUpperCase ());
        ResultSet rs = st.executeQuery ();
        while (rs.next ()) {
            uuids.add (rs.getString (1));
        }
    } finally {
        closeStatement (st);
    }
    return uuids;
}


-----Function Pair=389=-----==

public static void markProbeFinished (Db statusDb, ProbeBase probeBase, boolean success, boolean error, Exception ex, String message, boolean trialRun) throws Exception {
    _logger.debug ("Finalizing probe (" + probeBase.getClass ().getName () + ") with (success: " + success + ", error: " + error + ", exception: " + (ex == null ? "null" : ex.getMessage ()) + ", msg :" + message + ", trial: " + trialRun + ")");
    String msg = (ex != null && message == null ? StringHelper.getMessage (ex) : message);
    String stackTrace = (ex == null ? "" : StringHelper.getStackTraceAsString (ex));
    try {
        statusDb.begin ();
        Integer state = DbHelper.getKey (statusDb.prepareStatement ("SELECT e_probe_run_status_id FROM e_probe_history WHERE e_probe_history_id=" + probeBase.getProbeHistoryId ()));
        if (state == null) throw new IllegalStateException ("Trying to mark as finished an invalid probe history record (" + probeBase.getProbeHistoryId () + ")");
        if (state != ProbeStatus.STILL_RUNNING && state != ProbeStatus.NO_DATA) throw new IllegalStateException ("Trying to mark as finished an already closed (" + state + ") probe history record (" + probeBase.getProbeHistoryId () + ")");
        Integer thread = DbHelper.getKey (statusDb.prepareStatement ("SELECT thread FROM e_probe_pid WHERE lower(probe_name) = lower('" + probeBase.getClass ().getName () + "')"));
        if (thread == null) throw new IllegalStateException ("Finalizing a probe (" + probeBase.getClass ().getName () + ") which is not running");
        if (thread.intValue () != 1) throw new IllegalStateException ("Finalizing a probe (" + probeBase.getClass ().getName () + ") with abnormal thread count (" + thread + ")");
        synchronized (lock) {
            removeLock (statusDb, probeBase);
        }
        PreparedStatement ps_finish_elt = statusDb.prepareStatement ("UPDATE e_probe_history SET end_date=current_timestamp, success=?, error=?, error_message=?, exception_stacktrace=?, e_probe_run_status_id = ? WHERE e_probe_history_id=?");
        ps_finish_elt.setBoolean (1, success);
        ps_finish_elt.setBoolean (2, error);
        DbHelper.setSafeString (ps_finish_elt, 3, msg);
        DbHelper.setSafeString (ps_finish_elt, 4, stackTrace);
        int status = ProbeStatus.FAILURE;
        if (success) status = ProbeStatus.SUCCESS;
        if (error) status = ProbeStatus.ERROR;
        ps_finish_elt.setInt (5, status);
        ps_finish_elt.setInt (6, probeBase.getProbeHistoryId ());
        statusDb.executeUpdate (ps_finish_elt);
        saveProbeParameters (statusDb, probeBase);
        if (probeBase instanceof FileProbe) {
            FileProbe fp = (FileProbe) probeBase;
            updateFileProbeHistory (statusDb, fp);
            if (fp.isAssetProbe ()) {
                fillAssetProbeHistory (statusDb, fp, fp.getProbeHistoryId ());
            }
        }
        Incident i = new Incident ();
        i.setProbeName (probeBase.getClass ().getName ());
        i.setEsisVersion (Version.getVersionString ());
        i.setLastException (stackTrace);
        List < Exception > exs = new ArrayList < Exception > ();
        if (ex != null) exs.add (ex);
        if (status == ProbeStatus.FAILURE && probeBase.isSendIncidentWhenFailure ()) {
            _logger.warn ("Probe " + probeBase.getClass ().getName () + " ended with failure : generating incident due to probe configuration");
            i.setSummary ("Probe " + probeBase.getClass ().getName () + " failed to succeed");
            i.setProbeMessage ("Probe " + probeBase.getClass ().getName () + " failed to succeed");
            DbIncident.saveIncident (statusDb, i, null);
        }
        else if (status == ProbeStatus.ERROR && probeBase.isSendIncidentWhenError ()) {
            _logger.warn ("Probe " + probeBase.getClass ().getName () + " ended with error : generating incident due to probe configuration");
            i.setSummary ("Probe " + probeBase.getClass ().getName () + " error : " + msg);
            i.setProbeMessage ("Probe " + probeBase.getClass ().getName () + " error : " + msg);
            DbIncident.saveIncident (statusDb, i, null);
        }
    } catch (Exception e) {
        _logger.error ("Exception while setting probe to finished with message [" + msg + "] " + probeBase.getClass ().getName (), e);
        statusDb.rollback ();
        throw e;
    } finally {
        statusDb.commitUnless ();
    }
}


public void testUpdateOnMammal () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("update Mammal set description = description").executeUpdate ();
    assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    count = s.createQuery ("update Mammal set bodyWeight = 25").executeUpdate ();
    assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    if (! (getDialect () instanceof MySQLDialect)) {
        count = s.createQuery ("update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )").executeUpdate ();
        assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    }
    t.commit ();
    s.close ();
    data.cleanup ();
}


-----Function Pair=390=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void commit () throws DException {
    if (connectionStatus) throw new DatabaseException ("DSE279", null);
    if (((String) getUserSession ().getTransactionAccessMode ()).equalsIgnoreCase ("Read Only")) throw new DException ("DSE1184", (Object []) null);
    if (commit) {
        _StatementExecutionContext statementExecutionContext = getStatementExecutionContext ();
        _TriggerExecutionContext triggerExecutionContext = new TriggerExecutionContext ();
        statementExecutionContext.setTriggerExecutionContext (triggerExecutionContext);
        int length = createIndexesList.size ();
        if (length > 0) {
            HashMap tablesRefreshed = new HashMap (5);
            QualifiedIdentifier tableName;
            for (int i = 0; i < length; i ++) {
                IndexInfo indexInfo = (IndexInfo) createIndexesList.get (i);
                tableName = indexInfo.getTableName ();
                if (indexInfo.type == IndexInfo.CREATEINDEX) {
                    _IndexCharacteristics ic = serverSystem.getDataDictionary (databaseURL).getIndexCharacteristics (tableName);
                    if (tablesRefreshed.get (tableName) == null) {
                        ic.refresh ();
                        tablesRefreshed.put (tableName, "");
                    }
                    boolean isNonUnique = indexInfo.getIsNonUnique ();
                    _IndexInformation iif = ic.getIndexInformations (indexInfo.getIndexName (), isNonUnique);
                    if (isNonUnique) ((MergeDatabase) serverSystem.getMergeDatabase (databaseURL)).getSessionVersionHandler ().update (iif);
                    indexInfo.setIndexInformation (iif);
                }
            }
        }
        statementExecutionContext.setCreateIndexList (createIndexesList);
        try {
            userSession.commit (statementExecutionContext);
        } finally {
            createIndexesList.clear ();
        }
        userSession.getSavePointVector ().clear ();
    }
}


-----Function Pair=391=-----==

public List < Paragrafo > listarParagrafo (final String hql) throws HibernateException, Exception {
    Session session = Hibernate.getSessionFactory ().getCurrentSession ();
    try {
        session.beginTransaction ();
        List < Paragrafo > listParagrafo = session.createQuery (hql).list ();
        session.getTransaction ().commit ();
        return listParagrafo;
    } catch (HibernateException e) {
        if (session != null) {
            session.getTransaction ().rollback ();
        }
        throw new HibernateException ("HIBERNATE Erro no Listar Paragrafo: ", e);
    } catch (Exception e) {
        throw new Exception ("GERAL Erro no Listar Paragrafo: ", e);
    }
}


public Hashtable getBarometerData (int currentPilot) throws SQLException {
    Hashtable result = new Hashtable ();
    Calendar aYearAgo = new GregorianCalendar ();
    aYearAgo.set (Calendar.YEAR, aYearAgo.get (Calendar.YEAR) - 1);
    long then = aYearAgo.getTime ().getTime ();
    int flights = 0;
    int minutes = 0;
    Statement stmt = conn.getStatement ();
    ResultSet rs = stmt.executeQuery ("select motortid, slaebetid, svaevetid from flyvning where " + "flyvning.dato > " + then + " and " + "flyvning.kaptajn = " + "'Y' and " + "pilot_id = " + currentPilot);
    try {
        while (rs.next ()) {
            flights ++;
            minutes = minutes + rs.getInt (1) + rs.getInt (2) + rs.getInt (3);
            if (false) log.debug ("MiscDB.getBarometerData(): flights = " + flights + "\nminutes = " + minutes);
        }
    } catch (SQLException sqle) {
        log.debug (sqle);
        throw sqle;
    }
    result.put ("flights", new Integer (flights));
    result.put ("minutes", new Integer (minutes));
    return result;
}


-----Function Pair=392=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToExercise1Group toExercise1Group) {
    ToExercise1GroupDAO toExercise1GroupDAO = new ToExercise1GroupDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        toExercise1GroupDAO.update (toExercise1Group);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise1Group);
        Object [] args = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio grupal s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public String getParaUidByProp (String propertyUid) {
    String ret = null;
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        String sql = "select * from do_parameter  where ParaPropertyUid = ?";
        PreparedStatement pstmt = con.prepareStatement (sql);
        pstmt.setString (1, propertyUid);
        ResultSet rs = pstmt.executeQuery ();
        if (rs.next ()) {
            ret = rs.getString ("objUid");
        }
        rs.close ();
        pstmt.close ();
    } catch (SQLException ex) {
        try {
            con.rollback ();
        } catch (SQLException ex2) {
            ex2.printStackTrace ();
        }
        ex.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
    return ret;
}


-----Function Pair=393=-----==

public void takeValuesFromAlbum (PXAlbumContent album) {
    if (album != null) {
        this.setId (album.getId ());
        this.setDisplayName (album.getDisplayName ());
        this.setAlbumPath (album.getAlbumPath ());
        this.setPhotoCount (album.getPhotoCount ());
        this.setIsPublic (album.getIsPublic ());
        this.setShareMethod (PXShareMethod.fromString (album.getShareMethod ()));
        this.setStartDate (album.getStartDate ());
        this.setEndDate (album.getEndDate ());
        this.setCoverText (album.getCoverText ());
        PXPhoto aCoverPhoto = album.getCoverPhoto ();
        if (aCoverPhoto != null) {
            this.setCoverPhotoName (aCoverPhoto.getName ());
            ImageRotation aRotation = aCoverPhoto.getImageRotation ();
            if (aRotation != null) {
                PXImageRotator.RotateType aRotateType = PXImageRotationUtility.getRotateTypeForImageRotation (aRotation);
                this.setCoverPhotoRotationString (aRotateType.toString ());
            }
        }
    }
}


public User getUser (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from User R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        User u = (User) q.uniqueResult ();
        s.getTransaction ().commit ();
        return u;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=394=-----==

public static String getAccountName (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.accountName from Account R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        String aname = (String) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


private boolean createTables (Connection conn) {
    logger.info ("Going to create tables...");
    String dbType = this.getFromSession ("database");
    if ("postgresql".equals (dbType) || "oracle".equals (dbType)) {
        this.dropOracleOrPostgreSQLTables (dbType, conn);
    }
    try {
        boolean status = true;
        boolean autoCommit = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        List statements = ParseDBStructFile.parse (SystemGlobals.getValue (ConfigKeys.CONFIG_DIR) + "/database/" + dbType + "/" + dbType + "_db_struct.sql");
        for (Iterator iter = statements.iterator (); iter.hasNext ();) {
            String query = (String) iter.next ();
            if (query == null || "".equals (query.trim ())) {
                continue;
            }
            Statement s = null;
            try {
                s = conn.createStatement ();
                s.executeUpdate (query);
            } catch (SQLException ex) {
                status = false;
                logger.error ("Error executing query: " + query + ": " + ex, ex);
                this.context.put ("exceptionMessage", ex.getMessage () + "\n" + query);
                break;
            } finally {
                DbUtils.close (s);
            }
        }
        conn.setAutoCommit (autoCommit);
        return status;
    } catch (Exception e) {
        throw new ForumException (e);
    }
}


-----Function Pair=395=-----==

private String sqlDirForeignKeyColumns (BoxModel table, int dir) {
    String fkColumnName;
    BoxModel neighbor;
    String neighborName;
    String neighborDirName = "";
    String neighborMin;
    TypeModel type;
    Collection children;
    String sqlQuery = "";
    if (dir == 12) {
        children = table.getChildren12 ();
    }
    else {
        children = table.getChildren21 ();
    }
    LineModel child = null;
    for (Iterator x = children.iterator (); x.hasNext ();) {
        child = (LineModel) x.next ();
        if (dir == 12) {
            neighbor = child.getBoxModel2 ();
            if (child.isTwin ()) {
                neighborDirName = child.getDir12Name ();
            }
        }
        else {
            neighbor = child.getBoxModel1 ();
            if (child.isTwin ()) {
                neighborDirName = child.getDir21Name ();
            }
        }
        if (! neighbor.isAbstractDef ()) {
            neighborName = neighbor.getName ();
            if (child.isTwin ()) {
                fkColumnName = "oid" + neighborDirName;
            }
            else {
                fkColumnName = "oid" + neighborName;
            }
            sqlQuery = sqlQuery + "  " + fkColumnName + "  ";
            type = neighbor.getOidItem ().getTypeModel ();
            if (type != null) {
                sqlQuery = sqlQuery + getGenericDbmsType (type.getDbmsType (), table.getName (), fkColumnName);
                if (type.getLength () != 0) {
                    sqlQuery = sqlQuery + "(" + Integer.toString (type.getLength ());
                    sqlQuery = sqlQuery + ")";
                }
            }
            else {
                sqlQuery = sqlQuery + "????";
            }
            if (dir == 12) {
                neighborMin = child.getDir12Min ();
            }
            else {
                neighborMin = child.getDir21Min ();
            }
            String dir12Min = child.getDir12Min ();
            String dir12Max = child.getDir12Max ();
            String dir21Min = child.getDir21Min ();
            String dir21Max = child.getDir21Max ();
            boolean nullImpossible = false;
            if (dir == 12) {
                if ((dir12Min.equals ("1") && dir12Max.equals ("1") && dir21Min.equals ("1") && dir21Max.equals ("1"))) {
                    if (child.isDir21Id ()) {
                        nullImpossible = true;
                    }
                }
                else if (! dir12Min.equals ("0")) {
                    nullImpossible = true;
                }
            }
            if (dir == 21) {
                if ((dir12Min.equals ("1") && dir12Max.equals ("1") && dir21Min.equals ("1") && dir21Max.equals ("1"))) {
                    if (child.isDir12Id ()) {
                        nullImpossible = true;
                    }
                    else if (! child.isDir21Id ()) {
                        nullImpossible = true;
                    }
                }
                else if (! dir21Min.equals ("0")) {
                    nullImpossible = true;
                }
            }
            if (! neighborMin.equals ("0") && nullImpossible) {
                sqlQuery = sqlQuery + " NOT NULL,";
            }
            else {
                sqlQuery = sqlQuery + " NULL,";
            }
        }
    }
    return sqlQuery;
}


public void doStatementReader (Connection conn, String id) throws SQLException {
    try {
        Statement s1 = conn.createStatement ();
        s1.execute ("select * from many_threads");
        s1.executeQuery ("select * from many_threads");
        s1.close ();
        if (! conn.getAutoCommit ()) {
            conn.commit ();
        }
    } catch (SQLException e) {
        if (! conn.getAutoCommit ()) {
            try {
                conn.rollback ();
            } catch (SQLException e2) {
            }
        }
    }
}


-----Function Pair=396=-----==

private void delete () throws Exception {
    String exam_id = getParam ("exam_id");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("adm_subject_id");
            r.add ("adm_exam_id", exam_id);
            sql = r.getSQLSelect ("adm_exam_subject");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        if (! found) {
            sql = "DELETE FROM adm_exam WHERE adm_exam_id = '" + exam_id + "'";
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


private int getMaxId () throws SQLException {
    Connection conn = ConnectionManager.getManager ().getConnection ();
    try {
        int maxId;
        Statement st = conn.createStatement ();
        ResultSet rs = st.executeQuery (Statements.MAX_STADIUM_ID);
        while (rs.next ()) {
            maxId = rs.getInt ("maxID");
            return maxId;
        }
    } catch (SQLException e) {
        throw e;
    }
    return - 1;
}


-----Function Pair=397=-----==

public boolean getAuthorization (Identifier item, String partner, Value value, String...properties) throws GeneralFault {
    if (partner == null) {
        return true;
    }
    int needed = PropertyRight.convert (value);
    GetAuthorizationHelper helper = new GetAuthorizationHelper (item, partner);
    try {
        for (String property : properties) {
            int auth = helper.getAuthorization (property);
            if (! PropertyRight.contains (auth, needed, true)) {
                return false;
            }
        }
        return true;
    } finally {
        helper.finish ();
    }
}


public HashSet < TeachingUnit > findBySemesterId (Integer semesterID) throws SelectException, DBConnectionException {
    HashSet < TeachingUnit > tuSet = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("SEMESTER_ID", semesterID);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            tuSet = new HashSet < TeachingUnit > ();
            while (result.next ()) {
                TeachingUnit tu = new TeachingUnit (result.getInt ("TEACHING_UNIT_ID"), result.getString ("TEACHING_UNIT_NAME"), result.getString ("TEACHING_UNIT_DESCRIPTION"), result.getInt ("TEACHING_UNIT_NB_ECTS"), result.getInt ("TEACHING_UNIT_MIN_SCORE"));
                tu.setSubjectList (null);
                tu.setSemester (null);
                tuSet.add (tu);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return tuSet;
}


-----Function Pair=398=-----==

public int update (BusinessObject o) throws DAOException {
    int update = 0;
    Contact contact = (Contact) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("UPDATE_CONTACT"));
        pst.setString (1, contact.getName ());
        pst.setString (2, contact.getFirstname ());
        pst.setString (3, contact.getPhone ());
        pst.setString (4, contact.getEmail ());
        if (contact.getAccount () == 0) {
            pst.setNull (5, java.sql.Types.INTEGER);
        }
        else {
            pst.setInt (5, contact.getAccount ());
        }
        pst.setBoolean (6, contact.isArchived ());
        pst.setInt (7, contact.getId ());
        update = pst.executeUpdate ();
        if (update <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (update > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return update;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=399=-----==

public boolean guardarExamenAutomaticoEnAsignatura (Examen examen) {
    Transaction tx = null;
    Session session = HibernateUtil.currentSession ();
    boolean guardado = false;
    try {
        tx = session.beginTransaction ();
        session.clear ();
        Asignatura asignatura = (Asignatura) session.get (Asignatura.class, examen.getAsignatura ().getCodAsig ());
        Set < Pregunta > preguntas = (Set) examen.getPreguntas ();
        Set < Respuesta > respuestas = (Set) examen.getRespuestas ();
        if (examen.getCodExam () != - 1 && examen.getCodExam () != 0) {
        }
        else {
            session.save (examen);
            asignatura.getExamenes ().add (examen);
            session.save (asignatura);
            tx.commit ();
            for (Iterator iterator = preguntas.iterator (); iterator.hasNext ();) {
                Pregunta pregunta = (Pregunta) iterator.next ();
                Pregunta preg = (Pregunta) session.get (Pregunta.class, pregunta.getCodPreg ());
                preg.getExamenes ().add (examen);
                Session session2 = HibernateUtil.currentSession ();
                Transaction tx2 = null;
                try {
                    tx2 = session2.beginTransaction ();
                    session2.update (preg);
                    tx2.commit ();
                } catch (Exception e) {
                    try {
                        tx2.rollback ();
                        e.printStackTrace ();
                    } catch (Exception e2) {
                        e2.printStackTrace ();
                    }
                }
            }
            for (Iterator iterator = respuestas.iterator (); iterator.hasNext ();) {
                Respuesta respuesta = (Respuesta) iterator.next ();
                Respuesta resp = (Respuesta) session.get (Respuesta.class, respuesta.getCodResp ());
                resp.getExamenes ().add (examen);
                Session session3 = HibernateUtil.currentSession ();
                Transaction tx3 = null;
                try {
                    tx3 = session3.beginTransaction ();
                    session3.update (resp);
                    tx3.commit ();
                } catch (Exception e) {
                    try {
                        tx3.rollback ();
                        e.printStackTrace ();
                    } catch (Exception e2) {
                        e2.printStackTrace ();
                    }
                }
            }
        }
        session.clear ();
        guardado = true;
    } catch (Exception e) {
        try {
            tx.rollback ();
            e.printStackTrace ();
        } catch (Exception e2) {
            e2.printStackTrace ();
        }
    } finally {
        HibernateUtil.closeSession ();
    }
    return guardado;
}


public ArrayList < String [] > findByTeacher (int teacherID) throws SelectException, DBConnectionException {
    ArrayList < String [] > eesList = null;
    String ees [];
    Statement stmt = null;
    String query;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to get statement", e1);
    }
    query = "select department_acronym, year_study_name, semester_level, " + "subject_alias, session_type_acronym, student_group_name, " + "subject_model_nb_hours, subject_model_nb_hours * session_type_eqv_td " + "as " + '"' + "subject_model_td_nb_hours" + '"' + ", " + "(select count(*) from class_session c " + "where e.ees_id = c.ees_id) " + "* (year_study_duration_session / 60) as " + '"' + "ees_nb_performed_hours" + '"' + ", ees_statutory " + "from department d, year_of_study y, semester s, " + "subject su, session_type se, student_group st, " + "subject_model sm, ees e, teacher t, teaching_unit tu " + "where d.department_id = y.department_id " + "and y.year_study_id = s.year_study_id " + "and s.semester_id = tu.semester_id " + "and tu.teaching_unit_id = su.teaching_unit_id " + "and su.subject_id = sm.subject_id " + "and se.session_type_id = sm.session_type_id " + "and sm.subject_model_id = e.subject_model_id " + "and st.student_group_id = e.student_group_id " + "and t.teacher_id = e.teacher_id " + "and t.teacher_id = " + teacherID;
    try {
        ResultSet result = stmt.executeQuery (query);
        if (result != null) {
            eesList = new ArrayList < String [] > ();
            while (result.next ()) {
                ees = new String [10];
                ees [0] = result.getString ("DEPARTMENT_ACRONYM");
                ees [1] = result.getString ("YEAR_STUDY_NAME");
                ees [2] = result.getString ("SEMESTER_LEVEL");
                ees [3] = result.getString ("SUBJECT_ALIAS");
                ees [4] = result.getString ("SESSION_TYPE_ACRONYM");
                ees [5] = result.getString ("STUDENT_GROUP_NAME");
                ees [6] = result.getString ("SUBJECT_MODEL_NB_HOURS");
                ees [7] = result.getString ("SUBJECT_MODEL_TD_NB_HOURS");
                ees [8] = result.getString ("EES_NB_PERFORMED_HOURS");
                ees [9] = result.getString ("EES_STATUTORY");
                eesList.add (ees);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return eesList;
}


-----Function Pair=400=-----==

public RestServiceResult listByLanguagueId (RestServiceResult serviceResult, Long nLanguagueId) {
    List < MaSingleTextCheckList > listMaSingleTextCheckList = null;
    Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.SELECT_MA_CHECK_LIST_FORM_LANG, MaSingleTextCheckList.class);
    query.setParameter (1, nLanguagueId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listMaSingleTextCheckList = query.getResultList ();
    if (listMaSingleTextCheckList == null || listMaSingleTextCheckList.size () == 0) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("checkList.list.notFound"));
    }
    else {
        Object [] arrayParam = {listMaSingleTextCheckList.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.list.success"), arrayParam));
        serviceResult.setObjResult (listMaSingleTextCheckList);
        serviceResult.setNumResult (listMaSingleTextCheckList.size ());
    }
    return serviceResult;
}


public static RasterLayer getRasterLayer (Map map, String name, String file, String diff_file, String type, String legend_file) {
    Debug.println ("***** getRasterLayer START *****");
    String cntxt_legend_file = context_path + legend_file;
    String cntxt_diff_file = context_path + diff_file;
    RasterLayer rlayer = null;
    ParamList raster_params = new ParamList ();
    try {
        raster_params.put ("LayerName", name);
        raster_params.put ("RasterFileResource", new FileResource (file));
        raster_params.put ("Legend", new DataLegendDefinition (new FileResource (cntxt_legend_file), true));
        byte raster_type = RasterData.parseRasterType (type);
        if (raster_type == - 1) {
            raster_type = RasterData.TIFF_RASTER_TYPE;
        }
        Debug.println ("***** getRasterLayer raster_type: *****" + raster_type);
        raster_params.put ("RasterType", raster_type);
        raster_params.put ("BOUNDS", map.getBounds2D ());
        if (diff_file != null) {
            raster_params.put ("RasterOperand2FileResource", new FileResource (diff_file));
            DifferenceImageOperator diff_op = new DifferenceImageOperator ();
            raster_params.put ("PixelOperator", diff_op);
        }
        rlayer = new RasterLayer (raster_params);
    } catch (IOException e) {
        Debug.println ("getRasterLayer exception e: " + e.getMessage ());
    }
    Debug.println ("***** getRasterLayer END *****");
    return rlayer;
}


