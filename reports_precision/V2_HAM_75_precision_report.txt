Found 22/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public void init (IEditorSite site, IEditorInput input) throws PartInitException {
    elementEditorInput = (ElementEditorInput) input;
    ChangeEventFactory.getInstance ().addRefreshListener (this);
    if (diagram == null) {
        if (elementEditorInput.getElementWrapper () instanceof ViewpointWrapper) {
            diagram = ViewpointTypeFactory.getViewPointType ((ViewpointWrapper) elementEditorInput.getElementWrapper ());
            updatePartName ();
        }
        else {
            if (elementEditorInput.getElementWrapper () == null) {
                RestoreEditorManager.registerPartToRestore (this);
                diagram = ViewpointTypeFactory.getViewPointType (null);
            }
            else {
                System.err.println ("Editor base is not a ViewpointWrapper - " + elementEditorInput.getElementWrapper ());
            }
        }
    }
    super.init (site, input);
}


-----Function Pair=2=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=3=-----==

private void calculateConnections (Collection newSelections, Collection deselections) {
    Collection currentNodes = new HashSet ();
    if (getSelectionMode () != DEFAULT_MODE) {
        Iterator iter = getCurrentViewer ().getSelectedEditParts ().iterator ();
        while (iter.hasNext ()) {
            EditPart selected = (EditPart) iter.next ();
            if (! (selected instanceof ConnectionEditPart) && ! deselections.contains (selected)) {
                currentNodes.add (selected);
            }
        }
    }
    Collection connections = new ArrayList ();
    for (Iterator nodes = newSelections.iterator (); nodes.hasNext ();) {
        GraphicalEditPart node = (GraphicalEditPart) nodes.next ();
        for (Iterator itr = node.getSourceConnections ().iterator (); itr.hasNext ();) {
            ConnectionEditPart sourceConn = (ConnectionEditPart) itr.next ();
            if ((sourceConn.getSelected () == EditPart.SELECTED_NONE) && (newSelections.contains (sourceConn.getTarget ()) || currentNodes.contains (sourceConn.getTarget ()))) {
                connections.add (sourceConn);
            }
        }
        for (Iterator itr = node.getTargetConnections ().iterator (); itr.hasNext ();) {
            ConnectionEditPart targetConn = (ConnectionEditPart) itr.next ();
            if ((targetConn.getSelected () == EditPart.SELECTED_NONE) && (newSelections.contains (targetConn.getSource ()) || currentNodes.contains (targetConn.getSource ()))) {
                connections.add (targetConn);
            }
        }
    }
    newSelections.addAll (connections);
    connections = new HashSet ();
    for (Iterator nodes = deselections.iterator (); nodes.hasNext ();) {
        GraphicalEditPart node = (GraphicalEditPart) nodes.next ();
        for (Iterator itr = node.getSourceConnections ().iterator (); itr.hasNext ();) {
            ConnectionEditPart sourceConn = (ConnectionEditPart) itr.next ();
            if (sourceConn.getSelected () != EditPart.SELECTED_NONE) {
                connections.add (sourceConn);
            }
        }
        for (Iterator itr = node.getTargetConnections ().iterator (); itr.hasNext ();) {
            ConnectionEditPart targetConn = (ConnectionEditPart) itr.next ();
            if (targetConn.getSelected () != EditPart.SELECTED_NONE) {
                connections.add (targetConn);
            }
        }
    }
    deselections.addAll (connections);
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=4=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof EJBTool.deployment.navigator.EJBToolAbstractNavigatorItem) {
        return;
    }
    EJBTool.deployment.navigator.EJBToolAbstractNavigatorItem abstractNavigatorItem = (EJBTool.deployment.navigator.EJBToolAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof EJBTool.deployment.navigator.EJBToolNavigatorItem) {
        navigatorView = ((EJBTool.deployment.navigator.EJBToolNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof EJBTool.deployment.navigator.EJBToolNavigatorGroup) {
        EJBTool.deployment.navigator.EJBToolNavigatorGroup navigatorGroup = (EJBTool.deployment.navigator.EJBToolNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof EJBTool.deployment.navigator.EJBToolNavigatorItem) {
            navigatorView = ((EJBTool.deployment.navigator.EJBToolNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof DrlModelAbstractNavigatorItem) {
        return;
    }
    DrlModelAbstractNavigatorItem abstractNavigatorItem = (DrlModelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof DrlModelNavigatorItem) {
        navigatorView = ((DrlModelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof DrlModelNavigatorGroup) {
        DrlModelNavigatorGroup navigatorGroup = (DrlModelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof DrlModelNavigatorItem) {
            navigatorView = ((DrlModelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=5=-----==

protected void updateMarkersHard () {
    for (EObject obj : fMarkers2EObject.values ()) {
        obj.eNotify (fMarkersStale);
    }
    fMarkers2EObject.clear ();
    IMarker [] markers = null;
    IFile file = getFileInput ();
    Resource resource = getProcess ().eResource ();
    try {
        markers = file.findMarkers (null, true, IResource.DEPTH_ZERO);
    } catch (CoreException ex) {
        BPELUIPlugin.log (ex);
        return;
    }
    for (IMarker m : markers) {
        String href = null;
        EObject target = null;
        try {
            href = (String) m.getAttribute ("address.model");
            if (href == null) {
                continue;
            }
            target = resource.getEObject (href);
        } catch (CoreException ex) {
            continue;
        }
        if (target == null) {
            continue;
        }
        fMarkers2EObject.put (m.getId (), target);
        target.eNotify (new NotificationImpl (AdapterNotification.NOTIFICATION_MARKER_ADDED, null, m));
    }
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=6=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof PlwebAbstractNavigatorItem) {
        return;
    }
    PlwebAbstractNavigatorItem abstractNavigatorItem = (PlwebAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof PlwebNavigatorItem) {
        navigatorView = ((PlwebNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof PlwebNavigatorGroup) {
        PlwebNavigatorGroup navigatorGroup = (PlwebNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof PlwebNavigatorItem) {
            navigatorView = ((PlwebNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=7=-----==

private boolean calcChecked () {
    if (target == null) {
        return false;
    }
    Map map = target.getFilterProperty ();
    if (map == null) {
        target.setFilterProperty (new HashMap ());
        return true;
    }
    if (! map.containsKey (type + visibility)) {
        return true;
    }
    Boolean value = (Boolean) map.get (type + visibility);
    return ! value.booleanValue ();
}


public void run () {
    Model model = main.getOwlModel ();
    if (model == null) {
        MessageDialog.openError (main.getShell (), "Error!", "Load or query a BioPAX model first!");
        return;
    }
    if (withRoot) {
        updateRoot ();
    }
    if (allOpenPathways) {
        for (ScrollingGraphicalViewer viewer : main.getTabToViewerMap ().values ()) {
            updateViewerContent (viewer);
        }
    }
    else {
        updateViewerContent (main.getViewer ());
    }
}


-----Function Pair=8=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof DrlModelAbstractNavigatorItem) {
        return;
    }
    DrlModelAbstractNavigatorItem abstractNavigatorItem = (DrlModelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof DrlModelNavigatorItem) {
        navigatorView = ((DrlModelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof DrlModelNavigatorGroup) {
        DrlModelNavigatorGroup navigatorGroup = (DrlModelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof DrlModelNavigatorItem) {
            navigatorView = ((DrlModelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof CtbAbstractNavigatorItem) {
        return;
    }
    CtbAbstractNavigatorItem abstractNavigatorItem = (CtbAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof CtbNavigatorItem) {
        navigatorView = ((CtbNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof CtbNavigatorGroup) {
        CtbNavigatorGroup navigatorGroup = (CtbNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof CtbNavigatorItem) {
            navigatorView = ((CtbNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=9=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.MindmapDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.MindmapDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            mindmap.Map model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, MapEditPart.MODEL_ID, MindmapDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (mindmap.diagram.part.MindmapDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (mindmap.diagram.part.MindmapDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                MindmapDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        MindmapDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.MathDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.MathDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            MathDiagram model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, MathDiagramEditPart.MODEL_ID, MathDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (jfb.examples.gmf.math.diagram.part.MathDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (jfb.examples.gmf.math.diagram.part.MathDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                MathDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        MathDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=10=-----==

public boolean promising (NeighborInfo ni) {
    if (ni.node_id == my_neighbor_info.node_id) return false;
    if (leaf_pred_count == 0) {
        return true;
    }
    BigInteger ni_guid = GuidTools.instance (ni.node_id);
    boolean duplicate = false;
    for (int i = 0; i < leaf_pred_count; ++ i) if (leaf_preds [i].node_id == ni.node_id) duplicate = true;
    if (! duplicate) {
        int i = 0;
        for (i = 0; i < leaf_pred_count; ++ i) {
            if (in_range_mod (GuidTools.instance (leaf_preds [i].node_id), my_guid, ni_guid)) return true;
        }
        if ((i == leaf_pred_count) && (leaf_pred_count < leaf_set_size)) {
            return true;
        }
    }
    duplicate = false;
    for (int i = 0; i < leaf_succ_count; ++ i) if (leaf_succs [i].node_id == ni.node_id) duplicate = true;
    if (! duplicate) {
        int i;
        for (i = 0; i < leaf_succ_count; ++ i) {
            if (in_range_mod (my_guid, GuidTools.instance (leaf_succs [i].node_id), ni_guid)) return true;
        }
        if ((i == leaf_succ_count) && (leaf_succ_count < leaf_set_size)) {
            return true;
        }
    }
    return false;
}


protected short op_scan_table () {
    int advance = 2;
    int location = operands [1] & 0xFFFF;
    int lastloc;
    int len = operands [2] & 0xFFFF;
    boolean words = true;
    if (count == 4) {
        advance = operands [3] & 0x7F;
        words = (operands [3] & 0x80) == 0x80;
    }
    if (words) {
        lastloc = location + (len << 1);
        while (location < lastloc) {
            if (((zm.memory_image [location] & 0xFF) == ((operands [0]>> 8) & 0xFF)) && ((zm.memory_image [location + 1] & 0xFF) == (operands [0] & 0xFF))) {
                return (short) location;
            }
            location += advance;
        }
    }
    else {
        lastloc = location + len;
        while (location < lastloc) {
            if ((zm.memory_image [location] & 0xFF) == (operands [0] & 0xFFFF)) {
                return (short) location;
            }
            location += advance;
        }
    }
    return 0;
}


-----Function Pair=11=-----==

public int [] getItemOrder () {
    checkWidget ();
    int count = items.length;
    int [] indices = new int [count];
    for (int i = 0; i < count; i ++) {
        CoolItem item = items [i];
        int index = 0;
        while (index < originalItems.length) {
            if (originalItems [index] == item) break;
            index ++;
        }
        if (index == originalItems.length) error (SWT.ERROR_CANNOT_GET_ITEM);
        indices [i] = index;
    }
    return indices;
}


public List getSelection () {
    Selectable selectionAry [] = getGraphicPanel ().getSelectionModel ().getSelection ();
    ArrayList selection = new ArrayList ();
    for (int i = 0; i < selectionAry.length; i ++) {
        Selectable s = selectionAry [i];
        if (s instanceof GraphPortModel) {
            if (! (((GraphPortModel) s).getNode ().isSelected () || ((GraphPortModel) s).getNode ().getGraph ().isSelected ()) && myGraphicObjects.contains (s)) selection.add (s);
        }
        else if (s instanceof GraphModel) {
            if (myGraphicObjects.contains (s)) selection.add (s);
        }
        else if (s instanceof GraphNodeModel) {
            if (! ((GraphNodeModel) s).getGraph ().isSelected () && myGraphicObjects.contains (s)) selection.add (s);
        }
    }
    for (int i = 0; i < selectionAry.length; i ++) {
        Selectable s = selectionAry [i];
        if (s instanceof GraphEdgeModel) {
            GraphEdgeModel edge = (GraphEdgeModel) s;
            if ((edge.getGraph () == null || ! edge.getGraph ().isSelected ()) && myGraphicObjects.contains (s)) selection.add (s);
        }
    }
    return selection;
}


-----Function Pair=12=-----==

public void renderOffDescriptor (String label, byte [] data, final JPanel destination) {
    try {
        final JoglOffViewerPanel ofvp = new JoglOffViewerPanel (new OffParser (new String (data)), false);
        ofvp.setBorder (BorderFactory.createTitledBorder (label));
        SwingUtilities.invokeLater (new Runnable () {
            public void run () {
                destination.add (ofvp);
                destination.validate ();
                destination.repaint ();
            }
        }
        );
        return;
    } catch (IOException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (ShapeFileFormatException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    }
    final JLabel l = new JLabel ("Error parsing off data! See program log for details.");
    l.setBorder (BorderFactory.createTitledBorder (label));
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            destination.add (l);
            destination.validate ();
            destination.repaint ();
        }
    }
    );
}


public static String byteArr2HexStr (byte [] arrB) throws Exception {
    int iLen = arrB.length;
    StringBuffer sb = new StringBuffer (iLen * 2);
    for (int i = 0; i < iLen; i ++) {
        int intTmp = arrB [i];
        while (intTmp < 0) {
            intTmp = intTmp + 256;
        }
        if (intTmp < 16) {
            sb.append ("0");
        }
        sb.append (Integer.toString (intTmp, 16));
    }
    return sb.toString ();
}


-----Function Pair=13=-----==

public boolean implies (Permission permission) {
    if (! permissionClass.isInstance (permission)) {
        return false;
    }
    GCFPermission perm = (GCFPermission) permission;
    int perm_low = perm.getMinPort ();
    int perm_high = perm.getMaxPort ();
    Enumeration search = permissions.elements ();
    int count = permissions.size ();
    int port_low [] = new int [count];
    int port_high [] = new int [count];
    int port_range_count = 0;
    while (search.hasMoreElements ()) {
        GCFPermission cur_perm = (GCFPermission) search.nextElement ();
        if (cur_perm.impliesByHost (perm)) {
            if (cur_perm.impliesByPorts (perm)) {
                return true;
            }
            port_low [port_range_count] = cur_perm.getMinPort ();
            port_high [port_range_count] = cur_perm.getMaxPort ();
            port_range_count ++;
        }
    }
    for (int i = 0; i < port_range_count; i ++) {
        for (int j = 0; j < port_range_count - 1; j ++) {
            if (port_low [j] > port_low [j + 1]) {
                int tmp = port_low [j];
                port_low [j] = port_low [j + 1];
                port_low [j + 1] = tmp;
                tmp = port_high [j];
                port_high [j] = port_high [j + 1];
                port_high [j + 1] = tmp;
            }
        }
    }
    int current_low = port_low [0];
    int current_high = port_high [0];
    for (int i = 1; i < port_range_count; i ++) {
        if (port_low [i] > current_high + 1) {
            if (current_low <= perm_low && current_high >= perm_high) {
                return true;
            }
            if (perm_low <= current_high) {
                return false;
            }
            current_low = port_low [i];
            current_high = port_high [i];
        }
        else {
            if (current_high < port_high [i]) {
                current_high = port_high [i];
            }
        }
    }
    return (current_low <= perm_low && current_high >= perm_high);
}


public void addPosterization (RasterFilterListManager filterManager, IRasterRendering rendering) throws FilterTypeException {
    EnhancementStretchListManager elm = new EnhancementStretchListManager (filterManager);
    LinearStretchParams leParams = new LinearStretchParams ();
    double min = data.getMin ();
    double max = data.getMax ();
    double [] stretchs = data.getStretchs ();
    double distance = max - min;
    for (int i = 0; i < stretchs.length; i ++) stretchs [i] = min + stretchs [i] * distance;
    double [] in = new double [(stretchs.length - 1) * 2 + 4];
    int [] out = new int [(stretchs.length - 1) * 2 + 4];
    in [0] = in [1] = min;
    out [0] = out [1] = 0;
    in [in.length - 1] = in [in.length - 2] = max;
    out [out.length - 1] = out [out.length - 2] = 255;
    boolean even = true;
    out [2] = 0;
    for (int i = 3; i < in.length - 2; i = i + 2) {
        if (even) out [i] = out [i + 1] = 255;
        else out [i] = out [i + 1] = 0;
        even = ! even;
    }
    out [out.length - 2] = 255;
    for (int i = 2; i < in.length - 2; i = i + 2) in [i] = in [i + 1] = stretchs [(int) (i / 2)];
    leParams.rgb = true;
    leParams.red.stretchIn = in;
    leParams.red.stretchOut = out;
    leParams.green.stretchIn = in;
    leParams.green.stretchOut = out;
    leParams.blue.stretchIn = in;
    leParams.blue.stretchOut = out;
    elm.addEnhancedStretchFilter (leParams, lyr.getDataSource ().getStatistics (), rendering.getRenderBands (), false);
}


-----Function Pair=14=-----==

private static void test3 (Connection conn, String dburl, String dbuser, String dbpass, String dbtable) throws SQLException {
    OraReader or = new OraReader ();
    String strSQL = "select c.GEOMETRY, ROWID  from VIAS c where (sdo_filter(GEOMETRY, mdsys.sdo_geometry(2003, 82337, null, mdsys.sdo_elem_info_array(1, 1003, 1), mdsys.sdo_ordinate_array(-167305.445478584,3826564.14408529, 1026816.46891846,3826564.14408529, 1026816.46891846,4919672.72433395, -167305.445478584,4919672.72433395, -167305.445478584,3826564.14408529)), 'mask=anyinteract querytype=window') = 'TRUE')";
    Statement s = conn.createStatement (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    int fetchSize = 20000;
    s.setFetchSize (fetchSize);
    s.setFetchDirection (ResultSet.FETCH_FORWARD);
    long t1 = System.currentTimeMillis ();
    ResultSet r = s.executeQuery (strSQL);
    long t2 = System.currentTimeMillis ();
    System.out.println ("Tiempo de consulta:" + (t2 - t1) + " msecs.");
    ResultSetMetaData metadata = r.getMetaData ();
    System.out.println (metadata.getColumnClassName (1));
    WKBParser2 parser = new WKBParser2 ();
    int numReg = 0;
    while (r.next ()) {
        STRUCT st = (oracle.sql.STRUCT) r.getObject (1);
        MultiLineString pt2 = (MultiLineString) or.read (st);
        numReg ++;
    }
    System.out.println ("numReg = " + numReg);
    s.close ();
}


public DateChooser (Calendar date) {
    DateFormatSymbols sym = new DateFormatSymbols ();
    months = sym.getShortMonths ();
    String [] wkd = sym.getShortWeekdays ();
    for (int i = 0; i < 7; i ++) {
        int l = Math.min (wkd [i + 1].length (), 2);
        labels [i] = wkd [i + 1].substring (0, l);
    }
    highlightColor = UIManager.getColor ("List.selectionBackground");
    disabledColor = Color.red;
    setBorder (BorderFactory.createEtchedBorder ());
    setLayout (new BorderLayout (5, 5));
    JPanel top = new JPanel ();
    top.setLayout (new BorderLayout (0, 0));
    top.setBorder (BorderFactory.createEmptyBorder (2, 2, 2, 2));
    JPanel p1 = new JPanel ();
    p1.setLayout (new BorderLayout ());
    top.add (p1, BorderLayout.CENTER);
    b_lmonth = new JButton ("<");
    b_lmonth.addActionListener (this);
    b_lmonth.setMargin (new Insets (0, 0, 0, 0));
    p1.add (b_lmonth, BorderLayout.WEST);
    l_month = new JLabel ();
    l_date = new JLabel ("Date");
    l_date.setAlignmentX (0);
    p1.add (l_date, BorderLayout.CENTER);
    b_rmonth = new JButton (">");
    b_rmonth.addActionListener (this);
    b_rmonth.setMargin (new Insets (0, 0, 0, 0));
    p1.add (b_rmonth, BorderLayout.EAST);
    add ("North", top);
    calendarPane = new CalendarPane ();
    calendarPane.setOpaque (false);
    add ("Center", calendarPane);
    int fd = date.getFirstDayOfWeek ();
    weekendCols [0] = (Calendar.SUNDAY - fd + 7) % 7;
    weekendCols [1] = (Calendar.SATURDAY - fd + 7) % 7;
    setSelectedDate (date);
}


-----Function Pair=15=-----==

public void call (String a) {
    StringRef args = new StringRef (a);
    if (HELP (args, "VER")) return;
    if (args.value.length () > 0) {
        String word = StripWord (args);
        if (! word.equalsIgnoreCase ("set")) return;
        word = StripWord (args);
        try {
            Dos.dos.version.major = (byte) Integer.parseInt (word);
            Dos.dos.version.minor = (byte) Integer.parseInt (args.value);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    else WriteOut (Msg.get ("SHELL_CMD_VER_VER"), new Object [] {Config.VERSION, new Integer (Dos.dos.version.major), new Integer (Dos.dos.version.minor)});
}


public OrdersTO doTrade () throws Exception {
    QuoteTO preco = getQuote (idPaper);
    currTime ++;
    double price = preco.getClose ();
    if (currTime < PERIODO) {
        novo_dia (price, dias);
        return createOrdemTO (0, price, true);
    }
    else {
        novo_dia (price, dias);
        int v;
        double aux = k (dias);
        if (aux > 80) v = VOLUME;
        else if (aux < 20) v = - 1 * VOLUME;
        else v = 0;
        return createOrdemTO (Math.abs (v), dias [PERIODO - 1], v > 0 ? true : false);
    }
}


-----Function Pair=16=-----==

private void printStatistics (final OctTree octTree) {
    System.out.println ("Number of nodes: " + nodes.size ());
    double attrSum = 0.0;
    for (Node node : nodes) {
        for (Edge edge : attrEdges.get (node)) {
            attrSum += edge.weight;
        }
    }
    System.out.println ("Overall attraction: " + attrSum);
    double meanAttrEnergy = 0.0;
    for (Node node : nodes) meanAttrEnergy += getAttractionEnergy (node);
    meanAttrEnergy = (attrExponent == 0.0) ? Math.exp (meanAttrEnergy / attrSum) : Math.pow (meanAttrEnergy * attrExponent / attrSum, 1.0 / attrExponent);
    System.out.println ("Weighted mean of attraction energy: " + meanAttrEnergy);
    double repuSum = 0.0, repuSquareSum = 0.0;
    for (Node node : nodes) {
        repuSum += node.weight;
        repuSquareSum += node.weight * node.weight;
    }
    repuSum = repuSum * repuSum - repuSquareSum;
    System.out.println ("Overall repulsion: " + repuSum);
    double meanRepuEnergy = 0.0;
    for (Node node : nodes) meanRepuEnergy += getRepulsionEnergy (node, octTree);
    meanRepuEnergy /= repuFactor;
    meanRepuEnergy = (repuExponent == 0.0) ? Math.exp (- meanRepuEnergy / repuSum) : Math.pow (- meanRepuEnergy * repuExponent / repuSum, 1.0 / repuExponent);
    System.out.println ("Weighted mean of repulsion energy: " + meanRepuEnergy);
    System.out.println ("Mean attraction / mean repulsion: " + meanAttrEnergy / meanRepuEnergy);
}


private TreeMap addSubDirectory (TreeMap in, String [] path, String nameOfNewDirectory) {
    if (path.length == 0) {
        TreeMap map = new TreeMap ();
        in.put (nameOfNewDirectory, map);
    }
    else {
        String currentPathComponent = path [0];
        String [] nextPath = new String [path.length - 1];
        for (int i = 0; i < path.length - 1; i ++) {
            nextPath [i] = path [i + 1];
        }
        TreeMap nextTreeMap = (TreeMap) in.get (currentPathComponent);
        nextTreeMap = addSubDirectory (nextTreeMap, nextPath, nameOfNewDirectory);
        in.put (currentPathComponent, nextTreeMap);
    }
    return in;
}


-----Function Pair=17=-----==

static ImageProducer [] BitmapDir (byte [] imageData) {
    final int count = WORD (imageData, 4);
    final Order [] order = new Order [count];
    int offset = 6;
    for (int i = 0; i < count; ++ i) {
        order [i] = new Order (WORD (imageData, offset + 6), imageData [offset] & 0xff, Bitmap (imageData, DWORD (imageData, offset + 12), imageData [2]));
        offset += 16;
    }
    java.util.Arrays.sort (order);
    final ImageProducer [] producers = new ImageProducer [count];
    for (int i = 0; i < count; ++ i) {
        producers [i] = order [i].producer;
    }
    return producers;
}


public void shuttlesort (int from [], int to [], int low, int high) {
    if (high - low < 2) {
        return;
    }
    int middle = (low + high) / 2;
    shuttlesort (to, from, low, middle);
    shuttlesort (to, from, middle, high);
    int p = low;
    int q = middle;
    if (high - low >= 4 && compare (from [middle - 1], from [middle]) <= 0) {
        for (int i = low; i < high; i ++) {
            to [i] = from [i];
        }
        return;
    }
    for (int i = low; i < high; i ++) {
        if (q >= high || (p < middle && compare (from [p], from [q]) <= 0)) {
            to [i] = from [p ++];
        }
        else {
            to [i] = from [q ++];
        }
    }
}


-----Function Pair=18=-----==

public Resource init () {
    patterns = new ArrayList < Hit > ();
    allAnnotTypesAndFeaturesFromDatastore = new HashMap < String, List < String > > ();
    thisInstance = this;
    corpusIds = new ArrayList < Object > ();
    populatedAnnotationTypesAndFeatures = new HashMap < String, Set < String > > ();
    OptionsMap userConfig = Gate.getUserConfig ();
    if (userConfig.get ("Features_shortcuts") != null) {
        String shortcutsString = (String) userConfig.get ("Features_shortcuts");
        shortcutsString = shortcutsString.replaceAll ("^\\[\\[", "");
        shortcutsString = shortcutsString.replaceAll ("\\]\\]$", "");
        String [] rows = shortcutsString.split ("\\], \\[");
        numShortcuts = rows.length;
        if (shortcutsString.length () > 0) {
            for (int row = 0; row < numShortcuts; row ++) {
                String [] cols = rows [row].split (", ");
                for (int col = 0; col < cols.length; col ++) {
                    shortcuts [row] [col] = cols [col];
                }
            }
        }
    }
    initGui ();
    if (target != null) {
        if (target instanceof Searcher) {
            searcher = (Searcher) target;
        }
        else if (target instanceof LuceneDataStoreImpl) {
            searcher = ((LuceneDataStoreImpl) target).getSearcher ();
        }
        else {
            throw new GateRuntimeException ("Invalid target specified for the GUI");
        }
        updateDisplay ();
    }
    validate ();
    return this;
}


public void mousePressed (MouseEvent event) {
    scrolling = false;
    int th = calcThumbHeight ();
    int canvasHeight = getHeight () - fontHeight - 1;
    int w = getWidth ();
    if (canvasHeight < totalLinesHeight) {
        int x = event.getX ();
        int y = event.getY ();
        if (x > w - scrollWidth && y < canvasHeight) {
            if (y >= thumbPos + 2 && y <= thumbPos + 2 + th) {
                yDown = y;
                yStart = thumbPos;
            }
            else {
                thumbPos = y - 2;
                clipThumbPos ();
            }
            scrolling = true;
            thumbMoused = true;
            outputDirty = true;
            repaint ();
        }
    }
}


-----Function Pair=19=-----==

public Item dequeue () {
    if (isEmpty ()) {
        throw new NoSuchElementException ();
    }
    int random = StdRandom.uniform (N);
    Node n = (Node) array [random];
    Item item = n.item;
    Node prev = n.previous;
    Node next = n.next;
    if (prev == null) {
        if (next == null) {
            first = null;
            last = null;
            N --;
        }
        else {
            first = next;
            first.previous = null;
            N --;
        }
    }
    else {
        if (next == null) {
            last = n.previous;
            last.next = null;
            N --;
        }
        else {
            prev.next = n.next;
            next.previous = prev;
            N --;
        }
    }
    for (int i = random; i < N; i ++) {
        array [i] = array [i + 1];
    }
    return item;
}


protected void process_colour_pointer_pdu (RdpPacket_Localised data) throws RdesktopException {
    logger.debug ("Rdp.RDP_POINTER_COLOR");
    int x = 0, y = 0, width = 0, height = 0, cache_idx = 0, masklen = 0, datalen = 0;
    byte [] mask = null, pixel = null;
    cache_idx = data.getLittleEndian16 ();
    x = data.getLittleEndian16 ();
    y = data.getLittleEndian16 ();
    width = data.getLittleEndian16 ();
    height = data.getLittleEndian16 ();
    masklen = data.getLittleEndian16 ();
    datalen = data.getLittleEndian16 ();
    mask = new byte [masklen];
    pixel = new byte [datalen];
    data.copyToByteArray (pixel, 0, data.getPosition (), datalen);
    data.incrementPosition (datalen);
    data.copyToByteArray (mask, 0, data.getPosition (), masklen);
    data.incrementPosition (masklen);
}


-----Function Pair=20=-----==

static ImageProducer Bitmap (byte [] imageData, int offset, int type) {
    if (WORD (imageData, offset + 12) != 1) throw new IllegalArgumentException ("planes!=1");
    final int width = DWORD (imageData, offset + 4);
    final int h = DWORD (imageData, offset + 8);
    final int height = type != 0 ? h / 2 : h;
    final int bitCount = WORD (imageData, offset + 14);
    final int nColorsUsed = DWORD (imageData, offset + 32);
    final int colorCount = nColorsUsed != 0 ? nColorsUsed : 1 << bitCount;
    final int colorOffset = offset + DWORD (imageData, offset);
    final int compression = DWORD (imageData, offset + 16);
    if (compression != 0 && compression != 3) throw new IllegalArgumentException ("compression!=0 && compression!=3");
    if (bitCount < 16 || compression == 3) {
        int idx = colorOffset;
        for (int i = 0; i < colorCount; ++ i) {
            final byte b = imageData [idx];
            imageData [idx] = imageData [idx + 2];
            imageData [idx + 2] = b;
            imageData [idx + 3] = (byte) 255;
            idx += 4;
        }
    }
    final int [] intData = new int [height * width];
    int dst = 0;
    final int xorBytes = colorOffset + 4 * (bitCount < 16 ? colorCount : nColorsUsed);
    final int xorBytesPerRow = ((width * bitCount / 8) + 3) & ~ 3;
    final int andBytes = xorBytes + xorBytesPerRow * height;
    int xorOffset = xorBytes;
    int andOffset = andBytes;
    final int xorMask = bitCount < 32 ? (1 << bitCount) - 1 : 0xffffffff;
    final int pixelsPerByte = 8 / bitCount;
    final int bytesPerPixel = bitCount / 8;
    final int extraMaskBytesPerRow = (((width + 31) & ~ 31) - width) / 8;
    for (int y = 0; y < height; ++ y) {
        int xPixel = 0, aPixel = 0;
        byte xData = 0, aData = 0;
        for (int x = 0; x < width; ++ x) {
            int argb;
            if (bitCount < 16) {
                if (-- xPixel < 0) {
                    xData = imageData [xorOffset ++];
                    xPixel = pixelsPerByte - 1;
                }
                argb = TRIPLE (imageData, colorOffset + ((xData>> (xPixel * bitCount)) & xorMask) * 4);
            }
            else {
                argb = (imageData [xorOffset] & 0xff) | ((imageData [xorOffset + 1] & 0xff) << 8) | ((imageData [xorOffset + 2] & 0xff) << 16);
                if (compression == 3) argb = TRIPLE (imageData, colorOffset + argb * 4);
                else argb |= 0xff000000;
                xorOffset += bytesPerPixel;
            }
            if (type != 0) {
                if (-- aPixel < 0) {
                    aData = imageData [andOffset ++];
                    aPixel = 7;
                }
                if ((aData & (1 << aPixel)) != 0) {
                    argb &= 0xffffff;
                }
            }
            intData [dst ++] = argb;
        }
        andOffset += extraMaskBytesPerRow;
    }
    return new MemoryImageSource (width, height, intData, dst - width, - width);
}


public void train (SampleSet sampleSet, StopHandle stopHandle) throws StopException, TrainException {
    samples = ArraySampleSet.toArraySampleSet (sampleSet, stopHandle).getSamples ();
    int states = transProb.length;
    double [] [] tmpTransProb = new double [states] [states];
    double [] tmpStProb = new double [states];
    double [] [] tmpMean = new double [states] [dim];
    double [] [] [] tmpSigma = new double [states] [dim] [dim];
    double [] w = new double [samples.length];
    double total = 0;
    for (int k = 0; k < samples.length; k ++) {
        w [k] = samples [k].weight;
        total += w [k];
    }
    for (int k = 0; k < samples.length; k ++) {
        w [k] = w [k] / total;
    }
    double [] prob = new double [samples.length];
    for (int k = 0; k < samples.length; k ++) {
        prob [k] = getDensity ((double [] []) samples [k].x);
    }
    double lastTarget = Double.NaN;
    double thisTarget = 0;
    for (int k = 0; k < samples.length; k ++) {
        thisTarget += Math.log (prob [k]) * samples [k].weight;
    }
    while (Double.isNaN (lastTarget) || thisTarget - lastTarget >= eps) {
        if (stopHandle != null && stopHandle.isStoped ()) {
            throw new StopException ();
        }
        if (logStep) {
            logStep (thisTarget);
        }
        init (tmpTransProb, 0);
        init (tmpMean, 0);
        init (tmpSigma, 0);
        init (tmpStProb, 0);
        for (int k = 0; k < samples.length; k ++) {
            double [] [] ob = (double [] []) samples [k].x;
            int l = ob.length;
            double [] [] alpha = getAlpha (ob);
            double [] [] beta = getBeta (ob);
            for (int i = 0; i < states; i ++) {
                double v = alpha [0] [i] * beta [0] [i] / prob [k];
                tmpStProb [i] += prob [k] > 0 ? v * w [k] : 0;
                double [] tmpgamma = new double [l];
                for (int t = 0; t < l; t ++) {
                    tmpgamma [t] = alpha [t] [i] * beta [t] [i];
                }
                double gama1 = 0;
                double gama2 = 0;
                for (int t = 0; t < l; t ++) {
                    gama1 += tmpgamma [t];
                    if (t != l - 1) {
                        gama2 += tmpgamma [t];
                    }
                }
                for (int j = 0; j < states; j ++) {
                    double kc = 0;
                    for (int t = 0; t < l - 1; t ++) {
                        kc += alpha [t] [i] * transProb [i] [j] * getDensity (j, ob [t + 1]) * beta [t + 1] [j];
                    }
                    v = kc / gama2;
                    tmpTransProb [i] [j] += gama2 > 0 ? v * w [k] : 0;
                }
                double [] q = new double [l];
                for (int t = 0; t < l; t ++) {
                    q [t] = gama1 > 0 ? tmpgamma [t] / gama1 : 0;
                }
                for (int b = 0; b < dim; b ++) {
                    v = 0;
                    for (int t = 0; t < l; t ++) {
                        v += q [t] * ob [t] [b];
                    }
                    tmpMean [i] [b] += v * w [k];
                    for (int c = 0; c <= b; c ++) {
                        v = 0;
                        for (int t = 0; t < l; t ++) {
                            v += q [t] * (ob [t] [b] - obMean [i].get (b, 0)) * (ob [t] [c] - obMean [i].get (c, 0));
                        }
                        tmpSigma [i] [b] [c] += v * w [k];
                        tmpSigma [i] [c] [b] = tmpSigma [i] [b] [c];
                    }
                }
            }
        }
        for (int i = 0; i < states; i ++) {
            for (int j = 0; j < states; j ++) {
                transProb [i] [j] = tmpTransProb [i] [j];
            }
            stProb [i] = tmpStProb [i];
            for (int b = 0; b < dim; b ++) {
                obMean [i].set (b, 0, tmpMean [i] [b]);
            }
            Matrix sigma = new Matrix (tmpSigma [i]);
            obInvSigma [i] = sigma.inverse ();
            obDetInvSigma [i] = obInvSigma [i].det ();
        }
        for (int k = 0; k < samples.length; k ++) {
            prob [k] = getDensity ((double [] []) samples [k].x);
        }
        lastTarget = thisTarget;
        thisTarget = 0;
        for (int k = 0; k < samples.length; k ++) {
            thisTarget += Math.log (prob [k]) * samples [k].weight;
        }
    }
}


-----Function Pair=21=-----==

public void load (String [] line) {
    this.line = line;
    MOVIEID = CommonUtils.objectToInteger (line [0]);
    LN = line [1];
    LB = line [2];
    CN = line [3];
    LT = line [4];
    OT = line [5];
    PC = line [6];
    YR = CommonUtils.objectToInteger (line [7]);
    CF = line [8];
    CA = line [9];
    GR = line [10];
    LA = line [11];
    SU = line [12];
    LE = CommonUtils.objectToInteger (line [13]);
    RD = line [14];
    ST = line [15];
    PR = line [16];
    QP = line [17];
    CC = line [18];
    PF = line [19];
    DF = line [20];
    SI = CommonUtils.objectToInteger (line [21]);
    MF = line [22];
    AR = line [23];
    AL = line [24];
    DS = line [25];
    SE = line [26];
    CO = line [27];
    VS = line [28];
    RC = line [29];
}


public void init_solver () {
    int i, j, index;
    int nbpositions;
    nbpositions = maingame.rownb * maingame.colnb;
    levelmin = 0;
    levelmax = - 1;
    level = 0;
    best_level = 0;
    solved = false;
    stop = false;
    killed = false;
    piecelisttab = new e2piecelist [nbpositions];
    currentpiecetab = new e2piece [nbpositions];
    rotation = new int [nbpositions];
    collist = new int [nbpositions];
    rowlist = new int [nbpositions];
    checkrotation = true;
    rotationfound = false;
    mainthread = new Thread (this);
    start_time = (long) (new Date ()).getTime ();
    count_from_start = 0;
    count_from_last = 0;
    count_bestlevel = 0;
    count_worstlevel = 0;
    last_time_count = start_time;
    display_every_count_nb = 1000000;
    System.out.println (" backtracker init");
}


-----Function Pair=22=-----==

public void trimCorners () {
    if (isTrimmed ()) return;
    int w = getWidth ();
    int h = getHeight ();
    if (w == 0 || h == 0) {
        System.out.println ("IntImage::trimCorners(): w=" + w + " h=" + h);
    }
    int x;
    for (int y = 0; y < h; y ++) {
        int ypos = y * w;
        for (x = 0; x < w; x ++) {
            int pos = x + ypos;
            if (m_data [pos] == BLACK_CORNER || m_data [pos] > WHITE_CORNER) {
                m_data [pos] = OUTLIER;
            }
            else {
                break;
            }
        }
        if (x == 0) {
            break;
        }
    }
    for (int y = h - 1; y >= 0; y --) {
        int ypos = y * w;
        for (x = 0; x < w; x ++) {
            int pos = x + ypos;
            if (m_data [pos] == BLACK_CORNER || m_data [pos] > WHITE_CORNER) {
                m_data [pos] = OUTLIER;
            }
            else {
                break;
            }
        }
        if (x == 0) {
            break;
        }
    }
    for (int y = 0; y < h; y ++) {
        int ypos = y * w;
        for (x = w - 1; x >= 0; x --) {
            int pos = x + ypos;
            if (m_data [pos] == BLACK_CORNER || m_data [pos] > WHITE_CORNER) {
                m_data [pos] = OUTLIER;
            }
            else {
                break;
            }
        }
        if (x == w - 1) {
            break;
        }
    }
    for (int y = h - 1; y >= 0; y --) {
        int ypos = y * w;
        for (x = w - 1; x >= 0; x --) {
            int pos = x + ypos;
            if (m_data [pos] == BLACK_CORNER || m_data [pos] > WHITE_CORNER) {
                m_data [pos] = OUTLIER;
            }
            else {
                break;
            }
        }
        if (x == w - 1) {
            break;
        }
    }
    setTrimmed (true);
    reset ();
}


private static int threeSum (int [] a) {
    int pairs = 0;
    for (int i = 0; i < a.length; i ++) {
        int j = i + 1;
        int k = a.length - 1;
        int delta;
        while (j < k) {
            delta = a [i] + a [j] + a [k];
            if (delta == 0) {
                pairs ++;
                j ++;
                k --;
            }
            else if (delta > 0) {
                k --;
            }
            else {
                j ++;
            }
        }
    }
    return pairs;
}


-----Function Pair=23=-----==

public WireframeMesh getWireframeMesh () {
    int i, from [], to [];
    CurveF3d subdiv;
    Vec3 vert [];
    if (cachedWire != null) return cachedWire;
    subdiv = this;
    vert = new Vec3 [subdiv.vertex.length];
    for (i = 0; i < vert.length; i ++) vert [i] = subdiv.vertex [i].r;
    if (closed) {
        from = new int [vert.length];
        to = new int [vert.length];
        from [vert.length - 1] = vert.length - 1;
        to [vert.length - 1] = 0;
    }
    else {
        from = new int [vert.length - 1];
        to = new int [vert.length - 1];
    }
    for (i = 0; i < vert.length - 1; i ++) {
        from [i] = i;
        to [i] = i + 1;
    }
    return (cachedWire = new WireframeMesh (vert, from, to));
}


public void append (DataModel childNode) {
    if (values == null) values = new DataModel [1];
    String childName = childNode.getId ();
    int numChildren = numValidChildren;
    if (childName == null) {
        for (int i = 0; i < values.length; i ++) {
            if ((values [i] == null)) {
                values [i] = childNode;
                numValidChildren ++;
                return;
            }
        }
    }
    else {
        for (int i = 0; i < numChildren; i ++) {
            if ((values [i].getId () != null) && (values [i].getId ().compareTo (childName) == 0)) {
                values [i] = childNode;
                return;
            }
        }
    }
    setNumChildren (numChildren + 5);
    values [numValidChildren] = childNode;
    if (childNode instanceof BaseModel) childNode.setParent (this);
    numValidChildren = numChildren + 1;
}


-----Function Pair=24=-----==

void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=25=-----==

public void cmdProc (Interp interp, TclObject [] objv) throws TclException {
    if (objv.length < 4 || (objv.length % 2) != 0) {
        throw new TclNumArgsException (interp, 1, objv, "varList list ?varList list ...? command");
    }
    TclObject [] name = new TclObject [(objv.length - 2) / 2];
    TclObject [] value = new TclObject [(objv.length - 2) / 2];
    int c, i, j, base;
    int maxIter = 0;
    TclObject command = objv [objv.length - 1];
    boolean done = false;
    for (i = 0; i < objv.length - 2; i += 2) {
        int x = i / 2;
        name [x] = objv [i + 1];
        value [x] = objv [i + 2];
        int nSize = TclList.getLength (interp, name [x]);
        int vSize = TclList.getLength (interp, value [x]);
        if (nSize == 0) {
            throw new TclException (interp, "foreach varlist is empty");
        }
        int iter = (vSize + nSize - 1) / nSize;
        if (maxIter < iter) {
            maxIter = iter;
        }
    }
    for (c = 0; ! done && c < maxIter; c ++) {
        for (i = 0; i < objv.length - 2; i += 2) {
            int x = i / 2;
            int nSize = TclList.getLength (interp, name [x]);
            base = nSize * c;
            for (j = 0; j < nSize; j ++) {
                try {
                    if (base + j >= TclList.getLength (interp, value [x])) {
                        interp.setVar (TclList.index (interp, name [x], j), TclString.newInstance (""), 0);
                    }
                    else {
                        interp.setVar (TclList.index (interp, name [x], j), TclList.index (interp, value [x], base + j), 0);
                    }
                } catch (TclException e) {
                    throw new TclException (interp, "couldn't set loop variable: \"" + TclList.index (interp, name [x], j) + "\"");
                }
            }
        }
        try {
            interp.eval (command, 0);
        } catch (TclException e) {
            switch (e.getCompletionCode ()) {
                case TCL.BREAK :
                    done = true;
                    break;
                case TCL.CONTINUE :
                    continue;
                case TCL.ERROR :
                    interp.addErrorInfo ("\n    (\"foreach\" body line " + interp.errorLine + ")");
                    throw e;
                default :
                    throw e;
            }
        }
    }
    interp.resetResult ();
}


void genTry (JCTree body, List < JCCatch > catchers, Env < GenContext > env) {
    int limit = code.nextreg;
    int startpc = code.curPc ();
    Code.State stateTry = code.state.dup ();
    genStat (body, env, CRT_BLOCK);
    int endpc = code.curPc ();
    boolean hasFinalizer = env.info.finalize != null && env.info.finalize.hasFinalizer ();
    List < Integer > gaps = env.info.gaps.toList ();
    code.statBegin (TreeInfo.endPos (body));
    genFinalizer (env);
    code.statBegin (TreeInfo.endPos (env.tree));
    Chain exitChain = code.branch (goto_);
    endFinalizerGap (env);
    if (startpc != endpc) for (List < JCCatch > l = catchers; l.nonEmpty (); l = l.tail) {
        code.entryPoint (stateTry, l.head.param.sym.type);
        genCatch (l.head, env, startpc, endpc, gaps);
        genFinalizer (env);
        if (hasFinalizer || l.tail.nonEmpty ()) {
            code.statBegin (TreeInfo.endPos (env.tree));
            exitChain = code.mergeChains (exitChain, code.branch (goto_));
        }
        endFinalizerGap (env);
    }
    if (hasFinalizer) {
        code.newRegSegment ();
        int catchallpc = code.entryPoint (stateTry, syms.throwableType);
        int startseg = startpc;
        while (env.info.gaps.nonEmpty ()) {
            int endseg = env.info.gaps.next ().intValue ();
            registerCatch (body.pos (), startseg, endseg, catchallpc, 0);
            startseg = env.info.gaps.next ().intValue ();
        }
        code.statBegin (TreeInfo.finalizerPos (env.tree));
        code.markStatBegin ();
        Item excVar = makeTemp (syms.throwableType);
        excVar.store ();
        genFinalizer (env);
        excVar.load ();
        registerCatch (body.pos (), startseg, env.info.gaps.next ().intValue (), catchallpc, 0);
        code.emitop0 (athrow);
        code.markDead ();
        if (env.info.cont != null) {
            code.resolve (env.info.cont);
            code.statBegin (TreeInfo.finalizerPos (env.tree));
            code.markStatBegin ();
            LocalItem retVar = makeTemp (syms.throwableType);
            retVar.store ();
            env.info.finalize.genLast ();
            code.emitop1w (ret, retVar.reg);
            code.markDead ();
        }
    }
    code.resolve (exitChain);
    code.endScopes (limit);
}


-----Function Pair=26=-----==

void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


public void createSession () {
    sessionid = "0";
    String query;
    int count;
    ResultSet rs;
    query = "insert into session set created=now();";
    if (showQuery) out.println ("Create Session: " + query + "<BR>");
    count = executeUpdate (query);
    query = "select max(session.uid) as sessionid from session;";
    if (showQuery) out.println ("Get Session ID: " + query + "<BR>");
    rs = executeQuery (query);
    if (showQuery) out.println ("Completed execute query <BR>");
    try {
        rs.next ();
        sessionid = rs.getString ("sessionid");
    } catch (SQLException sqle) {
        out.println ("SQL Exception Error " + sqle.toString ());
    }
}


-----Function Pair=27=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=28=-----==

protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getBlue ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


public HashMap pathjoin (HashMap paths1, HashMap paths2) {
    HashMap returnpaths = new HashMap ();
    Object [] path1Array = paths1.values ().toArray ();
    Object [] path2Array = paths2.values ().toArray ();
    for (int j = 0; j < path1Array.length; j ++) {
        for (int k = 0; k < path2Array.length; k ++) {
            HashMap currentjoin = new HashMap ();
            HashMap path1 = new HashMap ();
            path1 = (HashMap) path1Array [j];
            Object [] path1subArray = path1.values ().toArray ();
            for (int p = 0; p < path1subArray.length; p ++) {
                currentjoin.put (currentjoin.size (), path1subArray [p]);
            }
            HashMap path2 = new HashMap ();
            path2 = (HashMap) path2Array [k];
            Object [] path2subArray = path2.values ().toArray ();
            for (int q = 0; q < path2subArray.length; q ++) {
                currentjoin.put (currentjoin.size (), path2subArray [q]);
            }
            returnpaths.put (returnpaths.size (), currentjoin);
        }
    }
    return returnpaths;
}


-----Function Pair=29=-----==

public Double2M max2 (Spolecne.D3 F, double x, double y, double uhel, double krok, double phodn, double mez) {
    double hodn, t;
    for (int k = 1; k <= 6; k ++) {
        do {
            if (Math.abs (mez - uhel) < krok) {
                uhel = mez;
                break;
            }
            hodn = F.f (x, y, uhel);
            t = phodn;
            if (hodn > phodn) {
                phodn = hodn;
                uhel = uhel + krok;
            }
        }
        while (hodn >= t);
        phodn = F.f (x, y, uhel);
        krok = - krok / 10;
        uhel = uhel + krok;
    }
    return new Double2M (phodn, uhel - krok);
}


public Double2M max3 (Spolecne.D3B F, double x, double y, double uhel, double krok, double phodn, double mez, boolean tp) {
    double hodn, t;
    for (int k = 1; k <= 6; k ++) {
        do {
            if (Math.abs (mez - uhel) < krok) {
                uhel = mez;
                break;
            }
            hodn = F.f (x, y, uhel, tp);
            t = phodn;
            if (hodn > phodn) {
                phodn = hodn;
                uhel = uhel + krok;
            }
        }
        while (hodn >= t);
        phodn = F.f (x, y, uhel, tp);
        krok = - krok / 10;
        uhel = uhel + krok;
    }
    return new Double2M (phodn, uhel - krok);
}


-----Function Pair=30=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=31=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public void method31 () {
    boolean flag = true;
    while (flag) {
        flag = false;
        for (int i = 0; i < anInt772 - 1; i ++) if (anIntArray774 [i] < anIntArray774 [i + 1]) {
            int j = anIntArray774 [i];
            anIntArray774 [i] = anIntArray774 [i + 1];
            anIntArray774 [i + 1] = j;
            long l = aLongArray773 [i];
            aLongArray773 [i] = aLongArray773 [i + 1];
            aLongArray773 [i + 1] = l;
            flag = true;
        }
    }
}


-----Function Pair=32=-----=1=

public static void BubbleSortLong2 (long [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                long temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


public static void BubbleSortByte2 (byte [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                byte temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=33=-----==

private void printTypeIds () throws RaplaException, SQLException {
    Connection connection = ((DBOperator) operator).createConnection ();
    String sql = "SELECT * from DYNAMIC_TYPE";
    try {
        Statement statement = connection.createStatement ();
        ResultSet set = statement.executeQuery (sql);
        while (! set.isLast ()) {
            set.next ();
            String idString = set.getString ("ID");
            String key = set.getString ("TYPE_KEY");
            System.out.println ("id " + idString + " key " + key);
        }
    } catch (SQLException ex) {
        throw new RaplaException (ex);
    } finally {
        connection.close ();
    }
}


public void contactListSyncCompleted (MsnMessenger messenger) {
    log.fine (messenger + " contact list sync completed");
    MsnGroup [] groups = connection.getContactList ().getGroups ();
    Group gw;
    for (MsnGroup group : groups) {
        gw = getGroupFactory ().create (group.getGroupName ());
        populateContactsFromList (group.getContacts (), gw, false);
    }
    MsnGroup defaultGroup = connection.getContactList ().getDefaultGroup ();
    gw = getGroupFactory ().create (defaultGroup.getGroupName ());
    populateContactsFromList (connection.getContactList ().getContactsInList (MsnList.FL), gw, true);
    for (ConnectionEventListener eventHandler : eventHandlers) {
        eventHandler.statusChanged (JmlMsnConnection.this);
    }
}


-----Function Pair=34=-----==

public void testPutSendReceiveGetXmlString () throws Exception {
    if (XMPP_ACCOUNT1 != null) {
        ConnectionConfiguration cc = new ConnectionConfiguration (XMPP_ADDRESS1, Integer.valueOf (XMPP_PORT1));
        XMPPConnection conn = new XMPPConnection (cc);
        conn.connect ();
        conn.login (XMPP_LOGIN1, XMPP_PASSWORD1);
        Message packet = new Message (XMPP_ACCOUNT2);
        packet.setFrom (XMPP_ACCOUNT1);
        packet.setBody ("Test");
        MapperFactory factory = new SimpleMapperFactory ();
        Mapper < TestStringDocument > instance = factory.createInstance (TestStringDocument.class);
        instance.addExtension (packet, testXmlString1);
        conn.sendPacket (packet);
        conn.disconnect ();
        ConnectionConfiguration cc2 = new ConnectionConfiguration (XMPP_ADDRESS2, Integer.valueOf (XMPP_PORT2));
        XMPPConnection conn2 = new XMPPConnection (cc2);
        conn2.connect ();
        PacketCollector pc = conn2.createPacketCollector (new PacketTypeFilter (Message.class));
        conn2.login (XMPP_LOGIN2, XMPP_PASSWORD2);
        Packet p = pc.nextResult ();
        TestStringDocument result = instance.getExtension (p);
        assertEquals (TEST_STRING1, result.getTestString ());
        conn2.disconnect ();
    }
}


private void UploadActionPerformed (ActionEvent evt) {
    JFileChooser chooser = new JFileChooser ();
    FileNameExtensionFilter filter = new FileNameExtensionFilter ("*.jpg", "jpg");
    chooser.setFileFilter (filter);
    File dir = new File (System.getProperty ("user.home"));
    chooser.setCurrentDirectory (dir);
    Component parent = null;
    int returnVal = chooser.showOpenDialog (parent);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        UserStatus.setText ("Bitte warten");
    }
    try {
        Pic.setVisible (false);
        FTPClient client = new FTPClient ();
        client.connect ("showus.de");
        client.login ("web2", "kcinnay88");
        client.enterLocalActiveMode ();
        client.setFileTransferMode (FTPClient.BINARY_FILE_TYPE);
        client.setFileType (FTPClient.BINARY_FILE_TYPE);
        int reply = client.getReplyCode ();
        System.out.println ("Connect returned: " + reply);
        FileInputStream in = new FileInputStream (chooser.getSelectedFile ().getAbsolutePath ());
        System.out.println ("Uploading File");
        client.storeFile ("/html/Applet/user/" + Config.id + ".jpg", in);
        client.logout ();
        in.close ();
        System.out.println ("done");
        UserStatus.setText ("Upload fertig, Bild wird aktuallisiert");
    } catch (SocketException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        UserStatus.setText ("Fehler beim Upload");
        e.printStackTrace ();
    }
}


-----Function Pair=35=-----==

public static void makeConnection () throws XMPPException {
    String user = "elena";
    String pass = "parolica";
    ConnectionConfiguration config = new ConnectionConfiguration ("localhost", 5222);
    conn = new XMPPConnection (config);
    try {
        conn.connect ();
        if (conn.isConnected ()) {
            SASLAuthentication.supportSASLMechanism ("PLAIN", 0);
            conn.login (user, pass, "");
            logger.info ("I'm connected!");
        }
    } catch (XMPPException ex) {
        logger.fatal (ex);
    }
}


private boolean initConnection () {
    try {
        if (ftp == null) {
            ftp = new FTPClient ();
            serverIP = getServer ();
            userName = getUserName ();
            password = getPassword ();
        }
        ftp.connect (serverIP);
        ftp.login (userName, password);
        return true;
    } catch (SocketException a_excp) {
        throw new RuntimeException (a_excp);
    } catch (IOException a_excp) {
        throw new RuntimeException (a_excp);
    } catch (Throwable a_th) {
        throw new RuntimeException (a_th);
    }
}


-----Function Pair=36=-----==

public void run () {
    try {
        java.util.List ml = proxy.listMessages ();
        VBoxGUI.this.tableModel.addAllMessageInfos (ml);
        VBoxGUI.this.totalMsgsLabel.setText (String.valueOf (msgTable.getRowCount ()));
        SwingUtilities.invokeLater (new Runnable () {
            public void run () {
                selectUnreadMessages (VBoxGUI.this.msgTable);
            }
        }
        );
    } catch (VBoxException vbe) {
        vbe.printStackTrace ();
        showErrorDialog ("listError.title", null, "listError.message", vbe);
    }
    VBoxGUI.this.setProgressVisible (false);
    VBoxGUI.this.msgTable.setEnabled (true);
    listAction.setEnabled (true);
}


public void forcedJoin (String channel) {
    startLock.lock ();
    if (! isStarted ()) {
        startLock.unlock ();
        return;
    }
    startLock.unlock ();
    try {
        ed.dispatch (SingleChannelChatListener.class, "forcedJoin", channel);
    } catch (SecurityException e) {
        e.printStackTrace ();
    } catch (NoSuchMethodException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=37=-----==

void applyRotation (PdfDictionary pageN, ByteBuffer out) {
    if (! rotateContents) return;
    Rectangle page = reader.getPageSizeWithRotation (pageN);
    int rotation = page.getRotation ();
    switch (rotation) {
        case 90 :
            out.append (PdfContents.ROTATE90);
            out.append (page.getTop ());
            out.append (' ').append ('0').append (PdfContents.ROTATEFINAL);
            break;
        case 180 :
            out.append (PdfContents.ROTATE180);
            out.append (page.getRight ());
            out.append (' ');
            out.append (page.getTop ());
            out.append (PdfContents.ROTATEFINAL);
            break;
        case 270 :
            out.append (PdfContents.ROTATE270);
            out.append ('0').append (' ');
            out.append (page.getRight ());
            out.append (PdfContents.ROTATEFINAL);
            break;
    }
}


public static void main (String [] args) {
    System.out.println ("Chapter 8: example CompactFontFormatExample");
    System.out.println ("-> Creates a PDF file with a compact font format font.");
    System.out.println ("-> jars needed: iText.jar");
    System.out.println ("-> resources needed: esl_gothic_shavian.otf");
    System.out.println ("-> file generated: cff.pdf");
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapter08/cff.pdf"));
        document.open ();
        BaseFont bf = BaseFont.createFont ("resources/in_action/chapter08/esl_gothic_shavian.otf", "Cp1252", BaseFont.EMBEDDED);
        System.out.println (bf.getClass ().getName ());
        Font font = new Font (bf, 12);
        document.add (new Paragraph ("All human beings are born free and equal in dignity and rights. " + "They are endowed with reason and conscience and should act towards one another in a spirit of brotherhood."));
        document.add (new Paragraph ("Yl hVman bIiNz R bPn frI n ikwal in dignitI n rFts. " + "Hej R endQd wiH rIzn n konSans n Sud Akt tawPds wan anaHr in a spirit ov braHarhUd.", font));
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


-----Function Pair=38=-----==

public static void pdf (EID eid, String path) {
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream (path));
        document.open ();
        Image img1 = Image.getInstance (eid.getPicture ());
        System.out.println (img1.getClass ().getName ());
        document.add (img1);
        PdfPTable table = new PdfPTable (1);
        document.add (new Paragraph (eid.getFullName ()));
        table.addCell (new Phrase ("Third firstname initial:" + eid.getData ().getThirdFirstnameInitial ()));
        table.addCell (new Phrase ("Sex:" + eid.getData ().getSex ()));
        table.addCell (new Phrase ("Nationality:" + eid.getData ().getNationality ()));
        table.addCell (new Phrase ("National number:" + eid.getData ().getNationalNumber ()));
        table.addCell (new Phrase ("Birth date:" + eid.getData ().getBirthDate ()));
        table.addCell (new Phrase ("Birth location:" + eid.getData ().getBirthLocation ()));
        table.addCell (new Phrase ("Noble condition:" + eid.getData ().getNobleCondition ()));
        table.addCell (new Phrase ("Special status:" + eid.getData ().getSpecialStatus ()));
        table.addCell (new Phrase ("Card number:" + eid.getData ().getCardNumber ()));
        table.addCell (new Phrase ("Document type:" + eid.getData ().getDocumentType ()));
        table.addCell (new Phrase ("Delivery municipality:" + eid.getData ().getDeliveryMunicipality ()));
        table.addCell (new Phrase ("Validity date:" + eid.getData ().getValidityBeginDate () + " - " + eid.getData ().getValidityEndDate ()));
        table.addCell (new Paragraph ("Address"));
        table.addCell (new Phrase ("Municipality:" + eid.getAddress ().getMunicipality ()));
        table.addCell (new Phrase ("Street and number:" + eid.getAddress ().getStreetAndNumber ()));
        table.addCell (new Phrase ("Zip code:" + eid.getAddress ().getZipCode ()));
        document.add (table);
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


DefaultMutableTreeNode populateTree (String childNode, String parentNode) {
    DefaultMutableTreeNode outterNode;
    if (parentNode.equals ("root")) {
        outterNode = new DefaultMutableTreeNode (childNode);
        GlobalVars.tempNode = outterNode;
        treeModel.insertNodeInto (outterNode, root, 0);
    }
    else {
        DefaultMutableTreeNode innerNode = new DefaultMutableTreeNode (childNode);
        treeModel.insertNodeInto (innerNode, GlobalVars.tempNode, 0);
    }
    treeModel.addTreeModelListener (new MyTreeModelListener ());
    jTree_expand_width ();
    jTree1.setModel (treeModel);
    jTree1.updateUI ();
    return (root);
}


-----Function Pair=39=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=40=-----==

private static void doCopyFile (File srcFile, File destFile, boolean preserveFileDate) throws IOException {
    if (destFile.exists () && destFile.isDirectory ()) {
        throw new IOException ("Destination '" + destFile + "' exists but is a directory");
    }
    FileChannel input = new FileInputStream (srcFile).getChannel ();
    try {
        FileChannel output = new FileOutputStream (destFile).getChannel ();
        try {
            output.transferFrom (input, 0, input.size ());
        } finally {
            IOUtils.closeQuietly (output);
        }
    } finally {
        IOUtils.closeQuietly (input);
    }
    if (srcFile.length () != destFile.length ()) {
        throw new IOException ("Failed to copy full contents from '" + srcFile + "' to '" + destFile + "'");
    }
    if (preserveFileDate) {
        destFile.setLastModified (srcFile.lastModified ());
    }
}


private void callDailyProcForSchemasInMasterDB () throws Exception {
    DBConnection conn = null;
    try {
        conn = new DBConnection ();
        String masterDatabases = PropertiesUtil.getMainProperty ("medsol.incr.data.master.databases", "aanda,hindustan,mathilakam,mathilakampharma");
        if (StringUtils.hasText (masterDatabases)) {
            for (StringTokenizer tokenizer = new StringTokenizer (masterDatabases, ","); tokenizer.hasMoreTokens ();) {
                String schemaName = (String) tokenizer.nextElement ();
                if (isPreviousDataLoadSuccess (schemaName)) {
                    CallableStatement cs = conn.getConnection ().prepareCall ("{call " + PropertiesUtil.getMainProperty ("medsol.load.data.proc", "createtableloadfiles") + " (?,?)}");
                    cs.setString (1, schemaName);
                    cs.setString (2, BASE_DIR);
                    cs.execute ();
                    cs.close ();
                    copyDataToSlaveDB (schemaName);
                }
                else {
                    logger.error ("Previous data load not successful for database : " + schemaName);
                }
            }
        }
    } finally {
        if (conn != null) {
            try {
                conn.close ();
            } catch (SQLException e) {
                logger.error ("Exception while closing DB Connection", e);
            }
        }
    }
}


-----Function Pair=41=-----==

private void checkCopyrightStatements (Map < String, List < Map < CopyrightField, String > > > copyrights) {
    String fileName = copyrights.keySet ().iterator ().next ();
    List < Map < CopyrightField, String > > copyrightList = copyrights.get (fileName);
    if (copyrightList.size () == 0) {
        System.out.println (fileName + ": missing copyright line.");
    }
    for (Map < CopyrightField, String > holder : copyrightList) {
        if (holder.get (CopyrightField.YEAR_INFO) == null) {
            System.out.println (fileName + ": missing copyright year.");
        }
        if (holder.get (CopyrightField.AUTHOR_NAME) == null) {
            System.out.println (fileName + ": missing copyright holder name.");
        }
        else {
            String holderName = holder.get (CopyrightField.AUTHOR_NAME);
            if (holderName.contains ("Chemistry") && holderName.contains ("Development") && holderName.contains ("Kit")) {
                System.out.println (fileName + ": copyright is not a legal entity");
            }
            else if (holder.get (CopyrightField.AUTHOR_EMAIL) == null) {
                System.out.println (fileName + ": copyright holder is not identified by an email address");
            }
        }
    }
}


public void copyFile (final FileWrapper from, final FileWrapper to) throws FileNotFoundException, IOException {
    if (! from.exists ()) {
        s_log.error ("Cannot copy from file (" + from.getAbsolutePath () + ") which doesn't appear to exist.");
        return;
    }
    FileWrapper toFile = to;
    if (to.isDirectory ()) {
        toFile = getFile (to, from.getName ());
    }
    if (s_log.isDebugEnabled ()) {
        s_log.debug ("Copying from file (" + from.getAbsolutePath () + ") to file (" + toFile.getAbsolutePath () + ")");
    }
    if (toFile.exists ()) {
        long fromCheckSum = getCheckSum (from);
        long toCheckSum = getCheckSum (toFile);
        if (fromCheckSum == toCheckSum) {
            if (s_log.isInfoEnabled ()) {
                s_log.info ("File to be copied(" + from.getAbsolutePath () + ") has the same checksum(" + fromCheckSum + ") as the file to copy to (" + toFile.getAbsolutePath () + "). Skipping copy.");
            }
            return;
        }
    }
    _iou.copyFile (from, toFile);
}


-----Function Pair=42=-----==

public static boolean deleteDirectory (String dir) {
    File d = new File (dir);
    if ((! d.isDirectory ()) || (! d.exists ())) return false;
    if (! d.delete ()) {
        String [] lista_file = d.list ();
        for (int i = 0; i < lista_file.length; i ++) {
            File f = new File (d.getAbsolutePath () + File.separator + lista_file [i]);
            if (f.isDirectory ()) {
                deleteDirectory (f.getAbsolutePath ());
            }
            else {
                deleteFile (f.getAbsolutePath ());
            }
        }
        return d.delete ();
    }
    return false;
}


protected void list (PrintWriter writer) {
    if (debug >= 1) log ("list: Listing contexts for virtual host '" + host.getName () + "'");
    writer.println (sm.getString ("managerServlet.listed", host.getName ()));
    Container [] contexts = host.findChildren ();
    for (int i = 0; i < contexts.length; i ++) {
        Context context = (Context) contexts [i];
        String displayPath = context.getPath ();
        if (displayPath.equals ("")) displayPath = "/";
        if (context != null) {
            if (context.getAvailable ()) {
                writer.println (sm.getString ("managerServlet.listitem", displayPath, "running", "" + context.getManager ().findSessions ().length, context.getDocBase ()));
            }
            else {
                writer.println (sm.getString ("managerServlet.listitem", displayPath, "stopped", "0", context.getDocBase ()));
            }
        }
    }
}


-----Function Pair=43=-----==

private static boolean isEadJar (Manifest man, JarInputStream jis) {
    if (man == null) {
        JarEntry entry = null;
        try {
            while ((entry = jis.getNextJarEntry ()) != null) {
                if (isFileToUnzip (entry.getName ())) return true;
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
        return false;
    }
    else {
        Attributes atr = man.getMainAttributes ();
        return (atr != null && atr.getValue ("Main-Class") != null && atr.getValue ("Main-Class").contains (JAR_CHECKER));
    }
}


public void updateLanguage () {
    refreshTitle ();
    ModelManager.groupData.name = Messages.getString ("tree.mydata");
    ModelManager.groupTrash.name = Messages.getString ("tree.trash");
    ModelManager.groupSearch.name = Messages.getString ("tree.search");
    getMenuBarManager ().getMenu ().getItem (0).setText (Messages.getString ("item.file"));
    getMenuBarManager ().getMenu ().getItem (1).setText (Messages.getString ("item.edit"));
    getMenuBarManager ().getMenu ().getItem (2).setText (Messages.getString ("item.window"));
    getMenuBarManager ().getMenu ().getItem (3).setText (Messages.getString ("item.help"));
    Iterator ite = itemManager.keySet ().iterator ();
    while (ite.hasNext ()) {
        String key = (String) ite.next ();
        Item item = (Item) itemManager.get (key);
        item.setText (Messages.getString (key));
    }
    passreminder.model.Item item = (passreminder.model.Item) (UIManager.getInstance ().itemTableViewer.getElementAt (UIManager.getInstance ().itemTableViewer.getTable ().getSelectionIndex ()));
    UIManager.getInstance ().refreshItem (item, false);
}


-----Function Pair=44=-----==

private String processSmilies (String message, String contentType) {
    String startPlainTextTag;
    String endPlainTextTag;
    if (contentType == null || contentType.equals (TEXT_CONTENT_TYPE) || "".equals (contentType)) {
        startPlainTextTag = "<PLAINTEXT>";
        endPlainTextTag = "</PLAINTEXT>";
    }
    else {
        startPlainTextTag = "";
        endPlainTextTag = "";
    }
    ArrayList smiliesList = ImageLoader.getDefaultSmiliesPack ();
    StringBuffer regexp = new StringBuffer ();
    regexp.append ("(?<!(alt='|alt=\"))(");
    for (int i = 0; i < smiliesList.size (); i ++) {
        Smiley smiley = (Smiley) smiliesList.get (i);
        String [] smileyStrings = smiley.getSmileyStrings ();
        for (int j = 0; j < smileyStrings.length; j ++) {
            regexp.append (GuiUtils.replaceSpecialRegExpChars (smileyStrings [j])).append ("|");
        }
    }
    regexp = regexp.deleteCharAt (regexp.length () - 1);
    regexp.append (')');
    Pattern p = Pattern.compile (regexp.toString ());
    Matcher m = p.matcher (message);
    StringBuffer msgBuffer = new StringBuffer ();
    boolean matchSuccessfull = false;
    while (m.find ()) {
        if (! matchSuccessfull) matchSuccessfull = true;
        String matchGroup = m.group ().trim ();
        String replacement = endPlainTextTag + "<IMG SRC='" + ImageLoader.getSmiley (matchGroup).getImagePath () + "' ALT='" + matchGroup + "'></IMG>" + startPlainTextTag;
        m.appendReplacement (msgBuffer, GuiUtils.replaceSpecialRegExpChars (replacement));
    }
    m.appendTail (msgBuffer);
    return msgBuffer.toString ();
}


private FBResource getResource (Element resourceElem) {
    if (resourceElem != null && resourceElem.getName ().equals ("Resource")) {
        String Name = resourceElem.getAttributeValue ("Name");
        String Type = resourceElem.getAttributeValue ("Type");
        String Comment = resourceElem.getAttributeValue ("Comment");
        String X = resourceElem.getAttributeValue ("x");
        String Y = resourceElem.getAttributeValue ("y");
        Hashtable < String, Parameter > Parameters = null;
        List parameterList = resourceElem.getChildren ("Parameter");
        int parameterListSize = parameterList.size ();
        if (parameterListSize > 0) {
            Parameters = new Hashtable < String, Parameter > ();
            Iterator iterator = parameterList.iterator ();
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Parameter parameter = getParameter (currentElement);
                Parameters.put (parameter.getName (), parameter);
            }
        }
        FBNetwork fbNetwork = null;
        Element fbNetworkElem = resourceElem.getChild ("FBNetwork");
        if (fbNetworkElem != null) {
            fbNetwork = getFBNetwork (fbNetworkElem);
        }
        FBResource resource = new FBResource (Name, Comment, Type, X, Y, Parameters, fbNetwork);
        return resource;
    }
    return null;
}


-----Function Pair=45=-----==

public Date calcWhenAvailable (ResourceTypeMap production, ResourceTypeMap availableResources, ResourceTypeMap neededResources) {
    float hoursNeeded = 0;
    for (ResourceType res : ResourceType.values ()) {
        if (res == ResourceType.FOOD) {
            continue;
        }
        int missing = neededResources.get (res) - availableResources.get (res);
        float time = missing / (float) production.get (res);
        if (time > hoursNeeded) {
            hoursNeeded = time;
        }
    }
    int seconds = (int) (hoursNeeded * 3600);
    Calendar cal = new GregorianCalendar ();
    cal.add (Calendar.SECOND, seconds);
    return cal.getTime ();
}


public static IRegion getFirstWhitespaceRegion (int offset, int length, IDocument document) throws BadLocationException {
    XMLTagScanner scanner = getXMLTagScanner ();
    IToken token = null;
    IRegion c_region = null;
    scanner.setRange (document, offset, length);
    while ((token = scanner.nextToken ()) != Token.EOF) {
        int tokenOffset = scanner.getTokenOffset ();
        int tokenLength = scanner.getTokenLength ();
        if (Token.WHITESPACE.equals (token)) {
            c_region = new Region (tokenOffset, tokenLength);
        }
        if (token.getData () instanceof TextAttribute) {
            TextAttribute text = (TextAttribute) token.getData ();
            if (text.getForeground ().getRGB ().equals (IColorConstants.ATTRIBUTE)) {
                return c_region;
            }
        }
    }
    return null;
}


-----Function Pair=46=-----==

protected ECTransition getECTransition (Element ecTransitionElem) {
    if (ecTransitionElem != null) {
        String Source = ecTransitionElem.getAttributeValue ("Source");
        String Destination = ecTransitionElem.getAttributeValue ("Destination");
        String Condition = ecTransitionElem.getAttributeValue ("Condition");
        String Comment = ecTransitionElem.getAttributeValue ("Comment");
        String x = ecTransitionElem.getAttributeValue ("x");
        String y = ecTransitionElem.getAttributeValue ("y");
        ECTransition ecTransition = new ECTransition (Source, Destination, Condition, Comment, x, y);
        return ecTransition;
    }
    else {
        System.err.println ("Invalid element input in getECTransition()");
        if (this.console != null) {
            console.setText ("Invalid element input in getECTransition()");
        }
        return null;
    }
}


private void processHTMLStyleAttribute (String name, Attr attr) {
    for (String tok : attr.getValue ().split (";")) {
        String [] styleDef = tok.split (":");
        if (styleDef.length == 2) {
            String value = expandText (styleDef [1].trim ());
            String styleAttributeName = styleDef [0].trim ();
            Pattern pattern = Pattern.compile ("([^-]+)\\-([a-z])(.*)");
            Matcher matcher = pattern.matcher (styleAttributeName);
            if (matcher.matches ()) {
                styleAttributeName = matcher.group (1) + matcher.group (2).toUpperCase () + matcher.group (3);
            }
            if (reservedStyleMap.containsKey (styleAttributeName)) {
                styleAttributeName = reservedStyleMap.get (styleAttributeName);
            }
            print (name + ".style." + styleAttributeName + "=" + value + ";");
        }
    }
}


-----Function Pair=47=-----==

public static String downloadWebpage2 (String address) throws MalformedURLException, IOException {
    URL url = new URL (address);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
    HttpURLConnection.setFollowRedirects (true);
    String encoding = conn.getContentEncoding ();
    InputStream is = null;
    if (encoding != null && encoding.equalsIgnoreCase ("gzip")) {
        is = new GZIPInputStream (conn.getInputStream ());
    }
    else if (encoding != null && encoding.equalsIgnoreCase ("deflate")) {
        is = new InflaterInputStream (conn.getInputStream ());
    }
    else {
        is = conn.getInputStream ();
    }
    BufferedReader br = new BufferedReader (new InputStreamReader (is));
    String line;
    String page = "";
    while ((line = br.readLine ()) != null) {
        page += line + "\n";
    }
    br.close ();
    return page;
}


private void onSearchFinished (ArrayList < int [] > data) {
    if (data.size () == 0) {
        int resid;
        if (replaceAll) {
            resid = R.string.replace_finish;
        }
        else {
            resid = R.string.not_found;
        }
        Toast.makeText (mJecEditor.getApplicationContext (), mJecEditor.getText (resid), Toast.LENGTH_LONG).show ();
    }
    else if (replaceAll) {
        Editable mText = mJecEditor.getEditText ().getText ();
        int end = data.size ();
        int [] ret;
        for (int i = end - 1; i >= 0; i --) {
            ret = data.get (i);
            mText.replace (ret [0], ret [1], replaceText);
        }
    }
    else {
        int [] ret = data.get (0);
        mJecEditor.getEditText ().setSelection (ret [0], ret [1]);
        int x = mJecEditor.getEditText ().getScrollX ();
        int y = mJecEditor.getEditText ().getScrollY ();
        mJecEditor.getEditText ().scrollBy (x, y + 40);
    }
}


-----Function Pair=48=-----==

protected FB getFB (Element fbElem) {
    if (fbElem != null && fbElem.getName ().equals ("FB")) {
        List content = fbElem.getChildren ();
        int size = content.size ();
        String Name = fbElem.getAttributeValue ("Name");
        String Type = fbElem.getAttributeValue ("Type");
        String Comment = fbElem.getAttributeValue ("Comment");
        String x = fbElem.getAttributeValue ("x");
        String y = fbElem.getAttributeValue ("y");
        Hashtable < String, Parameter > hashTable = new Hashtable < String, Parameter > (size);
        FB fb;
        if (size > 0) {
            Iterator iterator = content.iterator ();
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Parameter parameter = getParameter (currentElement);
                hashTable.put (Name, parameter);
            }
            fb = new FB (Name, Type, Comment, x, y, hashTable);
        }
        else {
            fb = new FB (Name, Type, Comment, x, y, null);
        }
        return fb;
    }
    else {
        System.err.println ("Invalid element input in getFB()");
        if (this.console != null) {
            console.setText ("Invalid element input in getFB()");
        }
        return null;
    }
}


protected ServiceTransaction getServiceTransaction (Element serviceTransactionElem) {
    if (serviceTransactionElem != null && serviceTransactionElem.getName ().equals ("ServiceTransaction")) {
        Element inputPrimitiveElem = serviceTransactionElem.getChild ("InputPrimitive");
        List content = serviceTransactionElem.getChildren ("OutputPrimitive");
        int size = content.size ();
        InputPrimitive inputPrimitive = null;
        if (inputPrimitiveElem != null) {
            inputPrimitive = getInputPrimitive (inputPrimitiveElem);
        }
        ServiceTransaction serviceTransaction = null;
        Hashtable < Integer, OutputPrimitive > hashTable = new Hashtable < Integer, OutputPrimitive > (size);
        int count = 0;
        if (size > 0) {
            Iterator iterator = content.iterator ();
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                OutputPrimitive outputPrimitive = getOutputPrimitive (currentElement);
                hashTable.put (new Integer (count), outputPrimitive);
                count ++;
            }
            serviceTransaction = new ServiceTransaction (inputPrimitive, hashTable);
        }
        else {
            serviceTransaction = new ServiceTransaction (inputPrimitive, null);
        }
        return serviceTransaction;
    }
    else {
        System.err.println ("Invalid element input in getServiceTransaction()");
        if (this.console != null) {
            console.setText ("Invalid element input in getServiceTransaction()");
        }
        return null;
    }
}


-----Function Pair=49=-----==

public static int [] rangesToIndexes (int [] [] ranges) {
    assert (ranges != null);
    int compsLength = 0;
    for (int i = 0; i < ranges.length; i ++) {
        compsLength += ranges [i] [1] - ranges [i] [0] + 1;
    }
    int [] indexes = new int [compsLength];
    int index = 0;
    for (int i = 0; i < ranges.length; i ++) {
        for (int comp = ranges [i] [0]; comp <= ranges [i] [1]; comp ++) {
            indexes [index ++] = comp;
        }
    }
    return indexes;
}


public static String [] differenceSet (List < String > fSet, String [] sSet) {
    StringBuffer result = new StringBuffer ();
    boolean found = false;
    if (sSet == null || sSet.length == 0) {
        for (String cs : fSet) result.append (cs + ";");
    }
    else {
        for (String cs : fSet) {
            found = false;
            for (String ck : sSet) if (ck.equals (cs)) {
                found = true;
                break;
            }
            if (! found) result.append (cs + ";");
        }
    }
    if (result.indexOf (";") > 0) return result.substring (0, result.length () - 1).split (";");
    else return null;
}


-----Function Pair=50=-----==

public static final float [] [] getElevation_16 (boolean withSnow) {
    int len = 16;
    float [] [] table = new float [3] [len];
    float [] [] elev_8 = Colors.getElevation_8 (withSnow);
    table [0] [0] = elev_8 [0] [0];
    table [1] [0] = elev_8 [1] [0];
    table [2] [0] = elev_8 [2] [0];
    table [0] [len - 1] = elev_8 [0] [7];
    table [1] [len - 1] = elev_8 [1] [7];
    table [2] [len - 1] = elev_8 [2] [7];
    for (int i = 1; i < (len - 1); i += 2) {
        table [0] [i] = (table [0] [i - 1] + table [0] [i + 1]) / 2.0f;
        table [1] [i] = (table [1] [i - 1] + table [1] [i + 1]) / 2.0f;
        table [2] [i] = (table [2] [i - 1] + table [2] [i + 1]) / 2.0f;
    }
    return table;
}


public double [] [] getDataByDouble () {
    double [] [] fReturn = null;
    if (! isValid ()) return fReturn;
    int nRows;
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) nRows = 2;
    else nRows = sData.length;
    int nCols = sData [0].length;
    fReturn = new double [nRows] [nCols];
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) {
        for (int j = 0; j < nCols; j ++) {
            fReturn [0] [j] = j + 1;
            try {
                fReturn [0] [j] = Double.parseDouble ((sData [0] [j] == null) ? "0" : sData [0] [j]);
            } catch (NumberFormatException ex) {
                fReturn [0] [j] = 0.0;
            }
        }
    }
    else for (int i = 0; i < nRows; i ++) for (int j = 0; j < nCols; j ++) {
        try {
            fReturn [i] [j] = Double.parseDouble ((sData [i] [j] == null) ? "0" : sData [i] [j]);
        } catch (NumberFormatException ex) {
            fReturn [i] [j] = 0.0;
        }
    }
    return fReturn;
}


-----Function Pair=51=-----==

public RealSquareMatrix getInverse () throws EuclidRuntimeException {
    double [] [] inv = new double [rows] [rows];
    double [] [] temp = getMatrix ();
    double det = this.determinant ();
    if (det == 0) {
        throw new EuclidRuntimeException ("Cannot invert matrix: determinant=0");
    }
    double detr = 1 / det;
    if (this.rows == 1) {
        inv [0] [0] = detr;
    }
    else if (this.rows == 2) {
        inv [0] [0] = detr * temp [1] [1];
        inv [1] [0] = 0 - (detr * temp [0] [1]);
        inv [0] [1] = 0 - (detr * temp [1] [0]);
        inv [1] [1] = detr * temp [0] [0];
    }
    else if (this.rows == 3) {
        inv [0] [0] = detr * (temp [1] [1] * temp [2] [2] - temp [1] [2] * temp [2] [1]);
        inv [0] [1] = detr * (temp [0] [2] * temp [2] [1] - temp [0] [1] * temp [2] [2]);
        inv [0] [2] = detr * (temp [0] [1] * temp [1] [2] - temp [0] [2] * temp [1] [1]);
        inv [1] [0] = detr * (temp [1] [2] * temp [2] [0] - temp [1] [0] * temp [2] [2]);
        inv [1] [1] = detr * (temp [0] [0] * temp [2] [2] - temp [0] [2] * temp [2] [0]);
        inv [1] [2] = detr * (temp [0] [2] * temp [1] [0] - temp [0] [0] * temp [1] [2]);
        inv [2] [0] = detr * (temp [1] [0] * temp [2] [1] - temp [1] [1] * temp [2] [0]);
        inv [2] [1] = detr * (temp [0] [1] * temp [2] [0] - temp [0] [0] * temp [2] [1]);
        inv [2] [2] = detr * (temp [0] [0] * temp [1] [1] - temp [0] [1] * temp [1] [0]);
    }
    else {
        throw new EuclidRuntimeException ("Inverse of larger than 3x3 matricies: NYI");
    }
    RealSquareMatrix imat = new RealSquareMatrix (inv);
    return imat;
}


public Matrix minor (int iM, int jM) {
    int i, j;
    Matrix mResult = new Matrix (this.nLines - 1, this.nCols - 1);
    for (i = 0; i < iM; i ++) {
        for (j = 0; j < jM; j ++) {
            mResult.cell [i] [j] = this.cell [i] [j];
        }
        for (j = jM + 1; j < this.nCols; j ++) {
            mResult.cell [i] [j - 1] = this.cell [i] [j];
        }
    }
    for (i = iM + 1; i < this.nLines; i ++) {
        for (j = 0; j < jM; j ++) {
            mResult.cell [i - 1] [j] = this.cell [i] [j];
        }
        for (j = jM + 1; j < this.nCols; j ++) {
            mResult.cell [i - 1] [j - 1] = this.cell [i] [j];
        }
    }
    return mResult;
}


-----Function Pair=52=-----==

void readVolumetricData () throws Exception {
    System.err.println ("readVolumetricData");
    StringTokenizer st = new StringTokenizer ("");
    volumetricData = new float [countX] [] [];
    for (int x = 0; x < countX; ++ x) {
        float [] [] plane = new float [countY] [];
        volumetricData [x] = plane;
        for (int y = 0; y < countY; ++ y) {
            float [] strip = new float [countZ];
            plane [y] = strip;
            for (int z = 0; z < countZ; ++ z) {
                if (! st.hasMoreTokens ()) {
                    String line = br.readLine ();
                    if (line == null) {
                        System.err.println ("end of file in SqueezeCube?");
                        System.err.println ("x=" + x + " y=" + y + " z=" + z);
                        throw new NullPointerException ();
                    }
                    st = new StringTokenizer (line);
                }
                strip [z] = Float.parseFloat (st.nextToken ());
            }
        }
    }
    System.err.println ("Successfully read " + countX + " x " + countY + " x " + countZ + " data points");
}


void readVolumetricData () throws Exception {
    System.err.println ("readVolumetricData");
    StringTokenizer st = new StringTokenizer ("");
    volumetricData = new float [countX] [] [];
    for (int x = 0; x < countX; ++ x) {
        float [] [] plane = new float [countY] [];
        volumetricData [x] = plane;
        for (int y = 0; y < countY; ++ y) {
            float [] strip = new float [countZ];
            plane [y] = strip;
            for (int z = 0; z < countZ; ++ z) {
                if (! st.hasMoreTokens ()) {
                    String line = br.readLine ();
                    if (line == null) {
                        System.err.println ("end of file in SqueezeCube?");
                        System.err.println ("x=" + x + " y=" + y + " z=" + z);
                        throw new NullPointerException ();
                    }
                    st = new StringTokenizer (line);
                }
                strip [z] = Float.parseFloat (st.nextToken ());
            }
        }
    }
    System.err.println ("Successfully read " + countX + " x " + countY + " x " + countZ + " data points");
}


-----Function Pair=53=-----==

Message generateReply (Message query, byte [] in, Socket s) {
    boolean badversion;
    int maxLength;
    boolean sigonly;
    SetResponse sr;
    if (query.getHeader ().getOpcode () != Opcode.QUERY) return errorMessage (query, Rcode.NOTIMPL);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (! tsig.verify (query, in, null)) return formerrMessage (in);
    }
    OPTRecord queryOPT = query.getOPT ();
    if (queryOPT != null && queryOPT.getVersion () > 0) badversion = true;
    if (s != null) maxLength = 65535;
    else if (queryOPT != null) maxLength = queryOPT.getPayloadSize ();
    else maxLength = 512;
    Message response = new Message ();
    response.getHeader ().setID (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.QR);
    if (query.getHeader ().getFlag (Flags.RD));
    response.getHeader ().setFlag (Flags.RD);
    response.addRecord (queryRecord, Section.QUESTION);
    Name name = queryRecord.getName ();
    short type = queryRecord.getType ();
    short dclass = queryRecord.getDClass ();
    if (type == Type.AXFR && s != null) return doAXFR (name, query, s);
    if (! Type.isRR (type) && type != Type.ANY) return errorMessage (query, Rcode.NOTIMPL);
    byte rcode = addAnswer (response, name, type, dclass, 0);
    if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage (query, rcode);
    addAdditional (response);
    if (queryTSIG != null) {
        try {
            if (tsig != null) tsig.apply (response, queryTSIG);
        } catch (IOException e) {
        }
    }
    try {
        response.freeze ();
        byte [] out = response.toWire ();
        if (out.length > maxLength) {
            response.thaw ();
            truncate (response, out.length, maxLength);
            if (tsig != null) tsig.apply (response, queryTSIG);
        }
    } catch (IOException e) {
    }
    return response;
}


Message generateReply (Message query, byte [] in, int maxLength) {
    Enumeration qds = query.getSection (Section.QUESTION);
    Record queryRecord = (Record) qds.nextElement ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (! tsig.verify (query, in, null)) return formerrMessage (in);
    }
    Message response = new Message ();
    response.getHeader ().setID (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.AA);
    response.getHeader ().setFlag (Flags.QR);
    response.addRecord (Section.QUESTION, queryRecord);
    Name name = queryRecord.getName ();
    short type = queryRecord.getType ();
    Zone zone = findBestZone (name);
    if (zone == null) {
        response.getHeader ().setRcode (Rcode.SERVFAIL);
    }
    else {
        Hashtable nameRecords = (Hashtable) zone.findName (name);
        if (nameRecords == null) {
            response.getHeader ().setRcode (Rcode.NXDOMAIN);
        }
        else {
            if (type == Type.ANY) {
                Enumeration e = nameRecords.elements ();
                while (e.hasMoreElements ()) {
                    RRset rrset = (RRset) e.nextElement ();
                    addRRset (response, rrset);
                }
            }
            else {
                Short Type = new Short (type);
                RRset rrset = (RRset) nameRecords.get (Type);
                if (rrset != null) addRRset (response, rrset);
            }
        }
        addAuthority (response, name, zone);
        addAdditional (response);
    }
    if (queryTSIG != null) {
        try {
            if (tsig != null) tsig.apply (response, queryTSIG);
        } catch (IOException e) {
        }
    }
    try {
        byte [] out = response.toWire ();
        if (out.length > maxLength) {
            truncate (response, out.length, maxLength);
            if (tsig != null) tsig.apply (response, queryTSIG);
        }
    } catch (IOException e) {
    }
    return response;
}


-----Function Pair=54=-----==

private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=55=-----==

public static void shuffle1 (int [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        int tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public static void copyDirectory (File sourceDir, File destDir) throws IOException {
    if (! destDir.exists ()) {
        destDir.mkdir ();
    }
    File [] children = sourceDir.listFiles ();
    for (File sourceChild : children) {
        String name = sourceChild.getName ();
        File destChild = new File (destDir, name);
        if (sourceChild.isDirectory ()) {
            copyDirectory (sourceChild, destChild);
        }
        else {
            copyFile (sourceChild, destChild);
        }
    }
}


-----Function Pair=56=-----==

private void writeParametersToDisk () throws IOException {
    URL location = (URL) parameters.get (Constants.INDEX_LOCATION_URL);
    File file = null;
    try {
        file = new File (new File (location.toURI ()), "LuceneIndexDefinition.xml");
    } catch (URISyntaxException use) {
        file = new File (location.getFile (), "LuceneIndexDefinition.xml");
    }
    java.io.FileWriter fileWriter = new java.io.FileWriter (file);
    Map indexInformation = new HashMap ();
    Iterator iter = parameters.keySet ().iterator ();
    while (iter.hasNext ()) {
        Object key = iter.next ();
        if (key.equals (Constants.INDEX_LOCATION_URL)) continue;
        indexInformation.put (key, parameters.get (key));
    }
    indexInformation.put (Constants.CORPUS_INDEX_FEATURE, Constants.CORPUS_INDEX_FEATURE_VALUE);
    if (corpus != null) indexInformation.put (Constants.CORPUS_SIZE, new Integer (corpus.getDocumentNames ().size ()));
    com.thoughtworks.xstream.XStream xstream = new com.thoughtworks.xstream.XStream ();
    try {
        xstream.toXML (indexInformation, fileWriter);
    } finally {
        fileWriter.close ();
    }
}


public void expandNode (TreePath path1) {
    if (! path1.equals (getSelectionPath ())) {
        setSelectionPath (path1);
    }
    while (myParent.filteringFiles) {
        try {
            Thread.sleep (50);
        } catch (InterruptedException e) {
        }
    }
    DefaultMutableTreeNode selected = (DefaultMutableTreeNode) path1.getLastPathComponent ();
    if (myParent.directoryFiles == null) return;
    if (myParent.directoryFiles.size () == 0) return;
    TreeNode [] tp = selected.getPath ();
    String path = new String (rootValue);
    for (int z = 1; z < tp.length; z ++) {
        path = new String (path + File.separator + tp [z].toString ());
    }
    DefaultMutableTreeNode newNode = null;
    File tempFile = null;
    for (int z = 0; z < myParent.directoryFiles.size (); z ++) {
        {
            tempFile = (File) myParent.directoryFiles.get (z);
            if (tempFile.isHidden () && myParent.showHiddenFiles == false) continue;
            newNode = new DefaultMutableTreeNode (tempFile.getName ());
            newNode.setAllowsChildren (true);
            selected.add (newNode);
        }
    }
}


-----Function Pair=57=-----==

public void testLoadFileBinary2 () throws Exception {
    final File file = new File (getOutdir (), "IoUtilityTestLoadBinary2.bin");
    if (file.exists ()) {
        assertTrue (file.delete ());
    }
    final OutputStream out = new FileOutputStream (file);
    try {
        for (int j = 0; j < 512; j ++) {
            for (int i = 0; i < 256; i ++) {
                out.write (i);
            }
            for (int i = 0; i < 256; i ++) {
                out.write (255 - i);
            }
        }
    } finally {
        out.close ();
    }
    final byte [] loaded = IoUtility.loadFileBinary (file);
    assertEquals (512 * 2 * 256, loaded.length);
    for (int j = 0; j < 512; j ++) {
        for (int i = 0; i < 256; i ++) {
            assertEquals ((byte) i, loaded [i + 512 * j]);
        }
        for (int i = 0; i < 256; i ++) {
            assertEquals ((byte) (255 - i), loaded [i + 256 + 512 * j]);
        }
    }
    assertTrue (file.delete ());
}


public void testANDSearch () throws LDAPException {
    LDAPConnection con = new LDAPConnection ();
    con.connect ("localhost", 50983);
    Util util = new Util ();
    LDAPSearchResults res = con.search ("dc=nam,dc=compinternal,dc=com", 2, "(&(l=NY)(l=LA))", new String [0], false);
    LDAPAttributeSet attribs = new LDAPAttributeSet ();
    attribs.add (new LDAPAttribute ("l", "LA"));
    attribs.getAttribute ("l").addValue ("NY");
    attribs.add (new LDAPAttribute ("objectClass", "inetOrgPerson"));
    attribs.add (new LDAPAttribute ("uid", "aalberts"));
    attribs.add (new LDAPAttribute ("givenname", "Al"));
    attribs.add (new LDAPAttribute ("sn", "Alberts"));
    LDAPEntry entry = new LDAPEntry ("uid=aalberts,dc=nam,dc=compinternal,dc=com", attribs);
    if (! res.hasMore ()) {
        fail ("entries not returned");
        return;
    }
    if (! util.compareEntry (entry, res.next ())) {
        fail ("1st entry failed");
    }
    if (res.hasMore ()) {
        fail ("too many entries");
    }
    con.disconnect ();
}


-----Function Pair=58=-----==

private final void listRecursiveFileDir (String sleg, NbFilesAndOutputFiles nfof, File dir, long refTime) throws IOException {
    if (dir == null) {
        logger.warn ("directory null");
        return;
    }
    if (! dir.exists ()) {
        logger.debug ("directory not exist");
        return;
    }
    if (dir.isDirectory ()) {
        File [] list = dir.listFiles ();
        if ((list == null) || (list.length == 0)) {
            list = null;
            return;
        }
        int len = list.length;
        for (int i = 0; i < len; i ++) {
            if (list [i].isDirectory ()) {
                listRecursiveFileDir (sleg, nfof, list [i], refTime);
            }
            else {
                if (list [i].getName ().endsWith (ArkDirConstants.METAEXT)) {
                    continue;
                }
                if (refTime == 0 || list [i].lastModified () > refTime) {
                    long [] sublist;
                    try {
                        sublist = pathToIdUnique (list [i].getAbsolutePath ());
                    } catch (ArUnvalidIndexException e) {
                        continue;
                    }
                    if ((sublist != null) && (sublist.length >= 2)) {
                        nfof.checkOutputAddFile ();
                        int length = sublist.length;
                        nfof.writeCheckFilesMark (sleg, Long.toString (sublist [length - 2]), Long.toString (sublist [length - 1]), null, null);
                    }
                    sublist = null;
                }
            }
        }
        list = null;
    }
    else {
        if (dir.getName ().endsWith (ArkDirConstants.METAEXT)) {
            return;
        }
        if (refTime == 0 || dir.lastModified () > refTime) {
            long [] sublist;
            try {
                sublist = pathToIdUnique (dir.getAbsolutePath ());
            } catch (ArUnvalidIndexException e) {
                sublist = null;
            }
            if ((sublist != null) && (sublist.length >= 2)) {
                nfof.checkOutputAddFile ();
                int length = sublist.length;
                nfof.writeCheckFilesMark (sleg, Long.toString (sublist [length - 2]), Long.toString (sublist [length - 1]), null, null);
            }
            sublist = null;
        }
    }
}


public static String getRelativePath (File dir, File file) throws IOException {
    ArrayList < String > dirComponents = new ArrayList < String > ();
    File fileAbsolute = dir.getCanonicalFile ();
    while (fileAbsolute != null) {
        dirComponents.add (fileAbsolute.getName ());
        fileAbsolute = fileAbsolute.getParentFile ();
    }
    ArrayList < String > fileComponents = new ArrayList < String > ();
    fileAbsolute = file.getCanonicalFile ();
    while (fileAbsolute != null) {
        fileComponents.add (fileAbsolute.getName ());
        fileAbsolute = fileAbsolute.getParentFile ();
    }
    int i = dirComponents.size () - 1;
    int j = fileComponents.size () - 1;
    while ((i >= 0) && (j >= 0) && (dirComponents.get (i).equals (fileComponents.get (j)))) {
        -- i;
        -- j;
    }
    StringBuffer buffer = new StringBuffer ();
    for (; i >= 0; -- i) {
        buffer.append (".." + File.separator);
    }
    for (; j >= 1; j --) {
        buffer.append (fileComponents.get (j) + File.separator);
    }
    buffer.append (fileComponents.get (j));
    return buffer.toString ();
}


-----Function Pair=59=-----==

public void tearDown () throws Exception {
    LOG.info ("tearDown starting");
    tearDownAll ();
    stopServer ();
    if (tmpDir != null) {
        Assert.assertTrue ("delete " + tmpDir.toString (), recursiveDelete (tmpDir));
    }
    serverFactory = null;
    JMXEnv.tearDown ();
    OperatingSystemMXBean osMbean = ManagementFactory.getOperatingSystemMXBean ();
    if (osMbean != null && osMbean instanceof UnixOperatingSystemMXBean) {
        UnixOperatingSystemMXBean unixos = (UnixOperatingSystemMXBean) osMbean;
        long fdCount = unixos.getOpenFileDescriptorCount ();
        String message = "fdcount after test is: " + fdCount + " at start it was " + initialFdCount;
        LOG.info (message);
        if (fdCount > initialFdCount) {
            LOG.info ("sleeping for 20 secs");
        }
    }
}


private void saveDKFile () throws CoreException {
    File dkStore = getStateLocation ().addTrailingSeparator ().append ("dk.xml").toFile ();
    String ls = System.getProperty ("line.separator");
    FileWriter fw = null;
    try {
        fw = new FileWriter (dkStore);
        fw.write ("<?xml version=\"1.0\"?>" + ls);
        fw.write ("<dkList>" + ls);
        Iterator it = dkMap.values ().iterator ();
        while (it.hasNext ()) {
            IDevelopmentKit val = (IDevelopmentKit) it.next ();
            fw.write ("\t<dk name=\"");
            fw.write (val.getName ());
            fw.write ("\" version=\"");
            fw.write (val.getVersion ());
            fw.write ("\" class=\"");
            fw.write (val.getClass ().getName ());
            fw.write ("\" location=\"");
            fw.write (val.getLocation ().toPortableString ());
            fw.write ("\"/>" + ls);
        }
        fw.write ("</dkList>" + ls);
    } catch (IOException e) {
        throw new CoreException (getExceptionStatus ("Could not save development kit list", e));
    } finally {
        try {
            fw.flush ();
            fw.close ();
        } catch (IOException e) {
            throw new CoreException (getExceptionStatus ("Could not save development kit list", e));
        }
    }
}


-----Function Pair=60=-----=1=

public byte [] deleteAllArchives (HTTPurl urlData, OutputStream outStream) throws Exception {
    File outFile = new File (new DllWrapper ().getAllUserPath () + "archive");
    if (outFile.exists () == false) outFile.mkdirs ();
    File [] files = outFile.listFiles ();
    Arrays.sort (files);
    for (int x = files.length - 1; files != null && x >= 0; x --) {
        File archiveFile = files [x];
        if (archiveFile.isDirectory () == false && archiveFile.getName ().startsWith ("Schedule-")) {
            archiveFile.delete ();
        }
    }
    StringBuffer buff = new StringBuffer (256);
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/ArchiveDataRes?action=showArchive\n\n");
    return buff.toString ().getBytes ();
}


public byte [] deleteAllArchives (HTTPurl urlData) throws Exception {
    File outFile = new File (new DllWrapper ().getAllUserPath () + "archive");
    if (outFile.exists () == false) outFile.mkdirs ();
    File [] files = outFile.listFiles ();
    Arrays.sort (files);
    for (int x = files.length - 1; files != null && x >= 0; x --) {
        File archiveFile = files [x];
        if (archiveFile.isDirectory () == false && archiveFile.getName ().startsWith ("Task-")) {
            archiveFile.delete ();
        }
    }
    StringBuffer buff = new StringBuffer (256);
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/TaskManagementDataRes?action=05\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=61=-----==

public void testMarshal () throws JiBXException, SAXException, IOException {
    RegistryObjectList o = RegistryObjectListFactory.create ();
    IBindingFactory bfact = BindingDirectory.getFactory (RegistryObjectList.class);
    IMarshallingContext marshallingContext = bfact.createMarshallingContext ();
    Writer outConsole = new BufferedWriter (new OutputStreamWriter (System.out));
    marshallingContext.setOutput (outConsole);
    marshallingContext.setIndent (3);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
    Writer out = new BufferedWriter (new OutputStreamWriter (outputStream));
    marshallingContext.setIndent (3);
    marshallingContext.setOutput (out);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    InputSource marshallingResult = new InputSource (new ByteArrayInputStream (outputStream.toByteArray ()));
    FileInputStream fis = new FileInputStream (new File ("src/test/resources/RegistryObjectListTestData.xml"));
    InputSource expectedResult = new InputSource (fis);
    DifferenceListener differenceListener = new IgnoreTextAndAttributeValuesDifferenceListener ();
    Diff diff = new Diff (expectedResult, marshallingResult);
    diff.overrideDifferenceListener (differenceListener);
    assertTrue ("Marshalled RegistryObjectList matches expected XML " + diff, diff.similar ());
}


public void testTorrentMetaInfoTest () throws Exception {
    File testTorrent = new File ("resources/freeculture.Team_6.pdf.torrent");
    TorrentMetainfo meta = TorrentMetainfoImpl.deserialize (new BufferedInputStream (new FileInputStream (testTorrent)));
    InfoDictionary info = meta.getInfo ();
    ByteArrayOutputStream infoBytes = new ByteArrayOutputStream ();
    info.serialize (infoBytes);
    byte [] sha1 = Utils.computeHash (infoBytes.toByteArray ());
    File outTorrent = new File ("freeculture.tmp.torrent");
    OutputStream out = new FileOutputStream (outTorrent);
    meta.serialize (out);
    out.close ();
    ByteArrayOutputStream baout = new ByteArrayOutputStream ();
    meta.serialize (baout);
    ByteArrayInputStream abInputStream = new ByteArrayInputStream (baout.toByteArray ());
    TorrentMetainfo meta2 = TorrentMetainfoImpl.deserialize (abInputStream);
    info = meta2.getInfo ();
    infoBytes = new ByteArrayOutputStream ();
    info.serialize (infoBytes);
    byte [] sha2 = Utils.computeHash (infoBytes.toByteArray ());
    assertTrue (ByteBuffer.wrap (sha1).compareTo (ByteBuffer.wrap (sha2)) == 0);
}


-----Function Pair=62=-----==

public void run () {
    exception = null;
    BufferedOutputStream fos = null;
    try {
        tempFile = File.createTempFile ("htmlexport", "zip", new File (tempdir));
        fos = new BufferedOutputStream (new FileOutputStream (tempFile));
        ZipOutputStream zipout = new ZipOutputStream (fos);
        zipout.setMethod (ZipOutputStream.DEFLATED);
        addAllTopics (zipout, 0, 80);
        addAllSpecialPages (zipout, 80, 10);
        addAllUploadedFiles (zipout, 90, 5);
        addAllImages (zipout, 95, 5);
        zipout.close ();
        logger.debug ("Closing zip and sending to user");
    } catch (Exception e) {
        logger.fatal ("Exception", e);
        exception = e;
    }
    progress = PROGRESS_DONE;
}


public void setUseUnsynchronisation (boolean newValue) throws IllegalTagStateException {
    if (! spec.supportsTagUnsynchronisation ()) requestSpecWhich ("supportsTagUnsynchronisation");
    boolean oldValue = useUnsynchronisation;
    if (oldValue != newValue) {
        this.useUnsynchronisation = newValue;
        changeSupport.firePropertyChange (USE_UNSYNCHRONISATION_PROPERTY, oldValue, newValue);
    }
    if (spec.supportsFrameUnsynchronisation ()) {
        for (Iterator i = frames.iterator (); i.hasNext ();) {
            ID3v2Frame frame = (ID3v2Frame) i.next ();
            frame.setUseUnsynchronisation (newValue);
        }
    }
    this.sizeChanged = true;
}


-----Function Pair=63=-----==

private static byte [] readFile (File file) throws IOException {
    byte [] content = null;
    if (file != null) {
        InputStream in = null;
        try {
            ByteArrayOutputStream out = new ByteArrayOutputStream ();
            in = new FileInputStream (file);
            byte [] buf = new byte [BUFFER_SIZE];
            int n;
            while ((n = in.read (buf)) > 0) out.write (buf, 0, n);
            content = out.toByteArray ();
        } finally {
            if (in != null) try {
                in.close ();
            } catch (IOException e) {
            }
        }
    }
    return content;
}


private ScheduleItem [] filterItems (ScheduleItem [] itemsArray, boolean past) {
    Vector < ScheduleItem > filteredList = new Vector < ScheduleItem > ();
    Date now = new Date ();
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        if (past) {
            if (item.getStop ().getTime () < now.getTime ()) filteredList.add (item);
        }
        else {
            if (item.getStop ().getTime () >= now.getTime ()) filteredList.add (item);
        }
    }
    ScheduleItem [] items = (ScheduleItem []) filteredList.toArray (new ScheduleItem [0]);
    Arrays.sort (items);
    return items;
}


-----Function Pair=64=-----==

protected Expression retrieveChildExpression (Element elem) {
    try {
        addChildElements (extractChildXMLElements (elem));
        addAttributes (extractXMLAttributes (elem));
        XMLElement [] childElems = getChildElements ();
        if (childElems.length == 1) {
            XACMLElement childEngineElem = ((DataAdapter) childElems [0]).getEngineElement ();
            if (childEngineElem instanceof Expression) {
                return (Expression) childEngineElem;
            }
        }
    } catch (Exception ex) {
        Logger logger = LogFactory.getLogger ();
        logger.error ("Error occurs while retrieving child expression from '" + elementName + "'", ex);
    }
    return null;
}


private static void pipe_agent_init () throws IOException {
    String buf;
    buf = br.readLine ();
    while (buf == null) buf = br.readLine ();
    try {
        Class partypes [] = new Class [1];
        partypes [0] = String.class;
        Method meth = agent.getMethod ("agent_init", partypes);
        Object arglist [] = new Object [1];
        arglist [0] = new String (buf);
        meth.invoke (retobj, arglist);
    } catch (InvocationTargetException e) {
        System.err.println ("\nError: Error in your agent_init method!!\n");
        e.printStackTrace ();
    } catch (Throwable e) {
        System.err.println ("ERROR: Arguments are not valid. RL-Framework supports \nInt, \nDouble, \nInt Array, \nDouble Array \nfor Observation type when using pipe communication. \nExiting...\n");
        e.printStackTrace ();
    }
}


-----Function Pair=65=-----==

public void postInitializeEntities (EntityGroup grp) {
    for (Entity entity : grp.getEntities ()) {
        Log.verbose (getClass ().getSimpleName () + ": post-initializing '" + entity.toString () + "'");
        try {
            entity.postInitialize ();
        } catch (Exception e) {
            Log.error (getClass ().getSimpleName () + ": exception on entity post-initialization '" + entity.toString () + ":" + entity.getInstanceName () + "'");
            Log.error (" reason: " + e);
            e.printStackTrace ();
        }
    }
    for (EntityGroup group : grp.getGroups ()) {
        postInitializeEntities (group);
    }
}


public static void main (String [] args) {
    Process p;
    try {
        ProcessBuilder pb = new ProcessBuilder ("cat", "/dev/random");
        p = pb.start ();
    } catch (IOException ioe) {
        System.err.println ("cmd failed: " + ioe.getMessage ());
        p = null;
    }
    try {
        testDexClassLoader ();
    } finally {
        if (p != null) p.destroy ();
        try {
            Thread.sleep (500);
        } catch (Exception ex) {
        }
    }
    System.out.println ("done");
}


-----Function Pair=66=-----==

public static Object convert (Collection c) {
    Iterator i;
    Object obj;
    Object res;
    Class type;
    int n;
    if (c.size () == 0) {
        return null;
    }
    obj = c.iterator ().next ();
    type = (Class) prim_.get (obj.getClass ());
    if (type == null) {
        type = obj.getClass ();
    }
    res = Array.newInstance (type, c.size ());
    for (n = 0, i = c.iterator (); i.hasNext (); n ++) {
        Array.set (res, n, i.next ());
    }
    return res;
}


static void deleteRecursively (DirContext ctx, Name targetName, Transaction tx, String comment) throws NamingException {
    final NamingEnumeration < NameClassPair > children = ctx.list (targetName);
    try {
        while (children.hasMore ()) {
            final NameClassPair child = children.next ();
            targetName.add (child.getName ());
            deleteRecursively (ctx, targetName, tx, "delete recursively");
            targetName.remove (targetName.size () - 1);
        }
    } finally {
        children.close ();
    }
    DiropLogger.LOG.logDelete (targetName, comment);
    try {
        ctx.destroySubcontext (targetName);
    } catch (final Exception e) {
    }
}


-----Function Pair=67=-----==

public Playlist getPlaylist () {
    if (_playlistInstance == null) {
        String classname = _config.getPlaylistClassName ();
        boolean interfaceFound = false;
        try {
            Class aClass = Class.forName (classname);
            Class superClass = aClass;
            while (superClass != null) {
                Class [] interfaces = superClass.getInterfaces ();
                for (int i = 0; i < interfaces.length; i ++) {
                    if ((interfaces [i].getName ()).equals ("javazoom.jlgui.player.amp.playlist.Playlist")) {
                        interfaceFound = true;
                        break;
                    }
                }
                if (interfaceFound == true) break;
                superClass = superClass.getSuperclass ();
            }
            if (interfaceFound == false) {
                log.error ("Error : Playlist implementation not found in " + classname + " hierarchy");
            }
            else {
                Class [] argsClass = new Class [] {};
                Constructor c = aClass.getConstructor (argsClass);
                _playlistInstance = (Playlist) (c.newInstance (null));
                log.info (classname + " loaded");
            }
        } catch (Exception e) {
            log.error ("Error : " + classname + " : " + e.getMessage ());
        }
    }
    return _playlistInstance;
}


static byte [] createByteArrayFromC (int stringAddress) {
    int word;
    int length = 0;
    int addr = stringAddress;
    while (true) {
        word = VM_Magic.getMemoryWord (addr);
        int byte3 = ((word>> 24) & 0xFF);
        int byte2 = ((word>> 16) & 0xFF);
        int byte1 = ((word>> 8) & 0xFF);
        int byte0 = (word & 0xFF);
        if (byte0 == 0) break;
        length ++;
        if (byte1 == 0) break;
        length ++;
        if (byte2 == 0) break;
        length ++;
        if (byte3 == 0) break;
        length ++;
        addr += 4;
    }
    byte [] contents = new byte [length];
    VM_Memory.memcopy (VM_Magic.objectAsAddress (contents), stringAddress, length);
    return contents;
}


-----Function Pair=68=-----==

protected void setGuiParameters () {
    for (PublicCompanyI company : companyManager.getAllPublicCompanies ()) {
        if (company.hasParPrice ()) guiParameters.put (GuiDef.Parm.HAS_ANY_PAR_PRICE, true);
        if (company.canBuyPrivates ()) guiParameters.put (GuiDef.Parm.CAN_ANY_COMPANY_BUY_PRIVATES, true);
        if (company.canHoldOwnShares ()) guiParameters.put (GuiDef.Parm.CAN_ANY_COMPANY_HOLD_OWN_SHARES, true);
        if (company.getMaxNumberOfLoans () != 0) guiParameters.put (GuiDef.Parm.HAS_ANY_COMPANY_LOANS, true);
    }
    loop : for (PrivateCompanyI company : companyManager.getAllPrivateCompanies ()) {
        for (SpecialPropertyI sp : company.getSpecialProperties ()) {
            if (sp instanceof SpecialTokenLay && ((SpecialTokenLay) sp).getToken () instanceof BonusToken) {
                guiParameters.put (GuiDef.Parm.DO_BONUS_TOKENS_EXIST, true);
                break loop;
            }
        }
    }
    if (GameOption.convertValueToBoolean (getGameOption ("NoMapMode"))) {
        guiParameters.put (GuiDef.Parm.NO_MAP_MODE, true);
        guiParameters.put (GuiDef.Parm.ROUTE_HIGHLIGHT, false);
        guiParameters.put (GuiDef.Parm.REVENUE_SUGGEST, false);
    }
    else {
        if ("Highlight".equalsIgnoreCase (getGameOption ("RouteAwareness"))) {
            guiParameters.put (GuiDef.Parm.ROUTE_HIGHLIGHT, true);
        }
        if ("Suggest".equalsIgnoreCase (getGameOption ("RevenueCalculation"))) {
            guiParameters.put (GuiDef.Parm.REVENUE_SUGGEST, true);
        }
    }
}


public Class getColumnClass (int col) {
    Class result = null;
    switch (col) {
        case 0 :
            result = String.class;
            break;
        case 1 :
            result = Type.class;
            break;
        case 2 :
            result = Object.class;
            break;
    }
    return result;
}


-----Function Pair=69=-----==

private static String [] setNames () {
    names = new String [FUNCTIONCOUNT];
    names [0] = new String ("undefined");
    names [RESERVED0] = new String ("reserved0");
    names [RESERVED1] = new String ("reserved1");
    names [RESERVED2] = new String ("reserved2");
    names [RESERVED3] = new String ("reserved3");
    names [GETVERSION] = new String ("GetVersion");
    names [DEFINECLASS] = new String ("DefineClass");
    names [FINDCLASS] = new String ("FindClass");
    names [FROMREFLECTEDMETHOD] = new String ("FromReflectedMethod");
    names [FROMREFLECTEDFIELD] = new String ("FromReflectedField");
    names [TOREFLECTEDMETHOD] = new String ("ToReflectedMethod");
    names [GETSUPERCLASS] = new String ("GetSuperclass");
    names [ISASSIGNABLEFROM] = new String ("IsAssignableFrom");
    names [TOREFLECTEDFIELD] = new String ("ToReflectedField");
    names [THROW] = new String ("Throw");
    names [THROWNEW] = new String ("ThrowNew");
    names [EXCEPTIONOCCURRED] = new String ("ExceptionOccurred");
    names [EXCEPTIONDESCRIBE] = new String ("ExceptionDescribe");
    names [EXCEPTIONCLEAR] = new String ("ExceptionClear");
    names [FATALERROR] = new String ("FatalError");
    names [PUSHLOCALFRAME] = new String ("PushLocalFrame");
    names [POPLOCALFRAME] = new String ("PopLocalFrame");
    names [NEWGLOBALREF] = new String ("NewGlobalRef");
    names [DELETEGLOBALREF] = new String ("DeleteGlobalRef");
    names [DELETELOCALREF] = new String ("DeleteLocalRef");
    names [ISSAMEOBJECT] = new String ("IsSameObject");
    names [NEWLOCALREF] = new String ("NewLocalRef");
    names [ENSURELOCALCAPACITY] = new String ("EnsureLocalCapacity");
    names [ALLOCOBJECT] = new String ("AllocObject");
    names [NEWOBJECT] = new String ("NewObject");
    names [NEWOBJECTV] = new String ("NewObjectV");
    names [NEWOBJECTA] = new String ("NewObjectA");
    names [GETOBJECTCLASS] = new String ("GetObjectClass");
    names [ISINSTANCEOF] = new String ("IsInstanceOf");
    names [GETMETHODID] = new String ("GetMethodID");
    names [CALLOBJECTMETHOD] = new String ("CallObjectMethod");
    names [CALLOBJECTMETHODV] = new String ("CallObjectMethodV");
    names [CALLOBJECTMETHODA] = new String ("CallObjectMethodA");
    names [CALLBOOLEANMETHOD] = new String ("CallBooleanMethod");
    names [CALLBOOLEANMETHODV] = new String ("CallBooleanMethodV");
    names [CALLBOOLEANMETHODA] = new String ("CallBooleanMethodA");
    names [CALLBYTEMETHOD] = new String ("CallByteMethod");
    names [CALLBYTEMETHODV] = new String ("CallByteMethodV");
    names [CALLBYTEMETHODA] = new String ("CallByteMethodA");
    names [CALLCHARMETHOD] = new String ("CallCharMethod");
    names [CALLCHARMETHODV] = new String ("CallCharMethodV");
    names [CALLCHARMETHODA] = new String ("CallCharMethodA");
    names [CALLSHORTMETHOD] = new String ("CallShortMethod");
    names [CALLSHORTMETHODV] = new String ("CallShortMethodV");
    names [CALLSHORTMETHODA] = new String ("CallShortMethodA");
    names [CALLINTMETHOD] = new String ("CallIntMethod");
    names [CALLINTMETHODV] = new String ("CallIntMethodV");
    names [CALLINTMETHODA] = new String ("CallIntMethodA");
    names [CALLLONGMETHOD] = new String ("CallLongMethod");
    names [CALLLONGMETHODV] = new String ("CallLongMethodV");
    names [CALLLONGMETHODA] = new String ("CallLongMethodA");
    names [CALLFLOATMETHOD] = new String ("CallFloatMethod");
    names [CALLFLOATMETHODV] = new String ("CallFloatMethodV");
    names [CALLFLOATMETHODA] = new String ("CallFloatMethodA");
    names [CALLDOUBLEMETHOD] = new String ("CallDoubleMethod");
    names [CALLDOUBLEMETHODV] = new String ("CallDoubleMethodV");
    names [CALLDOUBLEMETHODA] = new String ("CallDoubleMethodA");
    names [CALLVOIDMETHOD] = new String ("CallVoidMethod");
    names [CALLVOIDMETHODV] = new String ("CallVoidMethodV");
    names [CALLVOIDMETHODA] = new String ("CallVoidMethodA");
    names [CALLNONVIRTUALOBJECTMETHOD] = new String ("CallNonvirtualObjectMethod");
    names [CALLNONVIRTUALOBJECTMETHODV] = new String ("CallNonvirtualObjectMethodV");
    names [CALLNONVIRTUALOBJECTMETHODA] = new String ("CallNonvirtualObjectMethodA");
    names [CALLNONVIRTUALBOOLEANMETHOD] = new String ("CallNonvirtualBooleanMethod");
    names [CALLNONVIRTUALBOOLEANMETHODV] = new String ("CallNonvirtualBooleanMethodV");
    names [CALLNONVIRTUALBOOLEANMETHODA] = new String ("CallNonvirtualBooleanMethodA");
    names [CALLNONVIRTUALBYTEMETHOD] = new String ("CallNonvirtualByteMethod");
    names [CALLNONVIRTUALBYTEMETHODV] = new String ("CallNonvirtualByteMethodV");
    names [CALLNONVIRTUALBYTEMETHODA] = new String ("CallNonvirtualByteMethodA");
    names [CALLNONVIRTUALCHARMETHOD] = new String ("CallNonvirtualCharMethod");
    names [CALLNONVIRTUALCHARMETHODV] = new String ("CallNonvirtualCharMethodV");
    names [CALLNONVIRTUALCHARMETHODA] = new String ("CallNonvirtualCharMethodA");
    names [CALLNONVIRTUALSHORTMETHOD] = new String ("CallNonvirtualShortMethod");
    names [CALLNONVIRTUALSHORTMETHODV] = new String ("CallNonvirtualShortMethodV");
    names [CALLNONVIRTUALSHORTMETHODA] = new String ("CallNonvirtualShortMethodA");
    names [CALLNONVIRTUALINTMETHOD] = new String ("CallNonvirtualIntMethod");
    names [CALLNONVIRTUALINTMETHODV] = new String ("CallNonvirtualIntMethodV");
    names [CALLNONVIRTUALINTMETHODA] = new String ("CallNonvirtualIntMethodA");
    names [CALLNONVIRTUALLONGMETHOD] = new String ("CallNonvirtualLongMethod");
    names [CALLNONVIRTUALLONGMETHODV] = new String ("CallNonvirtualLongMethodV");
    names [CALLNONVIRTUALLONGMETHODA] = new String ("CallNonvirtualLongMethodA");
    names [CALLNONVIRTUALFLOATMETHOD] = new String ("CallNonvirtualFloatMethod");
    names [CALLNONVIRTUALFLOATMETHODV] = new String ("CallNonvirtualFloatMethodV");
    names [CALLNONVIRTUALFLOATMETHODA] = new String ("CallNonvirtualFloatMethodA");
    names [CALLNONVIRTUALDOUBLEMETHOD] = new String ("CallNonvirtualDoubleMethod");
    names [CALLNONVIRTUALDOUBLEMETHODV] = new String ("CallNonvirtualDoubleMethodV");
    names [CALLNONVIRTUALDOUBLEMETHODA] = new String ("CallNonvirtualDoubleMethodA");
    names [CALLNONVIRTUALVOIDMETHOD] = new String ("CallNonvirtualVoidMethod");
    names [CALLNONVIRTUALVOIDMETHODV] = new String ("CallNonvirtualVoidMethodV");
    names [CALLNONVIRTUALVOIDMETHODA] = new String ("CallNonvirtualVoidMethodA");
    names [GETFIELDID] = new String ("GetFieldID");
    names [GETOBJECTFIELD] = new String ("GetObjectField");
    names [GETBOOLEANFIELD] = new String ("GetBooleanField");
    names [GETBYTEFIELD] = new String ("GetByteField");
    names [GETCHARFIELD] = new String ("GetCharField");
    names [GETSHORTFIELD] = new String ("GetShortField");
    names [GETINTFIELD] = new String ("GetIntField");
    names [GETLONGFIELD] = new String ("GetLongField");
    names [GETFLOATFIELD] = new String ("GetFloatField");
    names [GETDOUBLEFIELD] = new String ("GetDoubleField");
    names [SETOBJECTFIELD] = new String ("SetObjectField");
    names [SETBOOLEANFIELD] = new String ("SetBooleanField");
    names [SETBYTEFIELD] = new String ("SetByteField");
    names [SETCHARFIELD] = new String ("SetCharField");
    names [SETSHORTFIELD] = new String ("SetShortField");
    names [SETINTFIELD] = new String ("SetIntField");
    names [SETLONGFIELD] = new String ("SetLongField");
    names [SETFLOATFIELD] = new String ("SetFloatField");
    names [SETDOUBLEFIELD] = new String ("SetDoubleField");
    names [GETSTATICMETHODID] = new String ("GetStaticMethodID");
    names [CALLSTATICOBJECTMETHOD] = new String ("CallStaticObjectMethod");
    names [CALLSTATICOBJECTMETHODV] = new String ("CallStaticObjectMethodV");
    names [CALLSTATICOBJECTMETHODA] = new String ("CallStaticObjectMethodA");
    names [CALLSTATICBOOLEANMETHOD] = new String ("CallStaticBooleanMethod");
    names [CALLSTATICBOOLEANMETHODV] = new String ("CallStaticBooleanMethodV");
    names [CALLSTATICBOOLEANMETHODA] = new String ("CallStaticBooleanMethodA");
    names [CALLSTATICBYTEMETHOD] = new String ("CallStaticByteMethod");
    names [CALLSTATICBYTEMETHODV] = new String ("CallStaticByteMethodV");
    names [CALLSTATICBYTEMETHODA] = new String ("CallStaticByteMethodA");
    names [CALLSTATICCHARMETHOD] = new String ("CallStaticCharMethod");
    names [CALLSTATICCHARMETHODV] = new String ("CallStaticCharMethodV");
    names [CALLSTATICCHARMETHODA] = new String ("CallStaticCharMethodA");
    names [CALLSTATICSHORTMETHOD] = new String ("CallStaticShortMethod");
    names [CALLSTATICSHORTMETHODV] = new String ("CallStaticShortMethodV");
    names [CALLSTATICSHORTMETHODA] = new String ("CallStaticShortMethodA");
    names [CALLSTATICINTMETHOD] = new String ("CallStaticIntMethod");
    names [CALLSTATICINTMETHODV] = new String ("CallStaticIntMethodV");
    names [CALLSTATICINTMETHODA] = new String ("CallStaticIntMethodA");
    names [CALLSTATICLONGMETHOD] = new String ("CallStaticLongMethod");
    names [CALLSTATICLONGMETHODV] = new String ("CallStaticLongMethodV");
    names [CALLSTATICLONGMETHODA] = new String ("CallStaticLongMethodA");
    names [CALLSTATICFLOATMETHOD] = new String ("CallStaticFloatMethod");
    names [CALLSTATICFLOATMETHODV] = new String ("CallStaticFloatMethodV");
    names [CALLSTATICFLOATMETHODA] = new String ("CallStaticFloatMethodA");
    names [CALLSTATICDOUBLEMETHOD] = new String ("CallStaticDoubleMethod");
    names [CALLSTATICDOUBLEMETHODV] = new String ("CallStaticDoubleMethodV");
    names [CALLSTATICDOUBLEMETHODA] = new String ("CallStaticDoubleMethodA");
    names [CALLSTATICVOIDMETHOD] = new String ("CallStaticVoidMethod");
    names [CALLSTATICVOIDMETHODV] = new String ("CallStaticVoidMethodV");
    names [CALLSTATICVOIDMETHODA] = new String ("CallStaticVoidMethodA");
    names [GETSTATICFIELDID] = new String ("GetStaticFieldID");
    names [GETSTATICOBJECTFIELD] = new String ("GetStaticObjectField");
    names [GETSTATICBOOLEANFIELD] = new String ("GetStaticBooleanField");
    names [GETSTATICBYTEFIELD] = new String ("GetStaticByteField");
    names [GETSTATICCHARFIELD] = new String ("GetStaticCharField");
    names [GETSTATICSHORTFIELD] = new String ("GetStaticShortField");
    names [GETSTATICINTFIELD] = new String ("GetStaticIntField");
    names [GETSTATICLONGFIELD] = new String ("GetStaticLongField");
    names [GETSTATICFLOATFIELD] = new String ("GetStaticFloatField");
    names [GETSTATICDOUBLEFIELD] = new String ("GetStaticDoubleField");
    names [SETSTATICOBJECTFIELD] = new String ("SetStaticObjectField");
    names [SETSTATICBOOLEANFIELD] = new String ("SetStaticBooleanField");
    names [SETSTATICBYTEFIELD] = new String ("SetStaticByteField");
    names [SETSTATICCHARFIELD] = new String ("SetStaticCharField");
    names [SETSTATICSHORTFIELD] = new String ("SetStaticShortField");
    names [SETSTATICINTFIELD] = new String ("SetStaticIntField");
    names [SETSTATICLONGFIELD] = new String ("SetStaticLongField");
    names [SETSTATICFLOATFIELD] = new String ("SetStaticFloatField");
    names [SETSTATICDOUBLEFIELD] = new String ("SetStaticDoubleField");
    names [NEWSTRING] = new String ("NewString");
    names [GETSTRINGLENGTH] = new String ("GetStringLength");
    names [GETSTRINGCHARS] = new String ("GetStringChars");
    names [RELEASESTRINGCHARS] = new String ("ReleaseStringChars");
    names [NEWSTRINGUTF] = new String ("NewStringUTF");
    names [GETSTRINGUTFLENGTH] = new String ("GetStringUTFLength");
    names [GETSTRINGUTFCHARS] = new String ("GetStringUTFChars");
    names [RELEASESTRINGUTFCHARS] = new String ("ReleaseStringUTFChars");
    names [GETARRAYLENGTH] = new String ("GetArrayLength");
    names [NEWOBJECTARRAY] = new String ("NewObjectArray");
    names [GETOBJECTARRAYELEMENT] = new String ("GetObjectArrayElement");
    names [SETOBJECTARRAYELEMENT] = new String ("SetObjectArrayElement");
    names [NEWBOOLEANARRAY] = new String ("NewBooleanArray");
    names [NEWBYTEARRAY] = new String ("NewByteArray");
    names [NEWCHARARRAY] = new String ("NewCharArray");
    names [NEWSHORTARRAY] = new String ("NewShortArray");
    names [NEWINTARRAY] = new String ("NewIntArray");
    names [NEWLONGARRAY] = new String ("NewLongArray");
    names [NEWFLOATARRAY] = new String ("NewFloatArray");
    names [NEWDOUBLEARRAY] = new String ("NewDoubleArray");
    names [GETBOOLEANARRAYELEMENTS] = new String ("GetBooleanArrayElements");
    names [GETBYTEARRAYELEMENTS] = new String ("GetByteArrayElements");
    names [GETCHARARRAYELEMENTS] = new String ("GetCharArrayElements");
    names [GETSHORTARRAYELEMENTS] = new String ("GetShortArrayElements");
    names [GETINTARRAYELEMENTS] = new String ("GetIntArrayElements");
    names [GETLONGARRAYELEMENTS] = new String ("GetLongArrayElements");
    names [GETFLOATARRAYELEMENTS] = new String ("GetFloatArrayElements");
    names [GETDOUBLEARRAYELEMENTS] = new String ("GetDoubleArrayElements");
    names [RELEASEBOOLEANARRAYELEMENTS] = new String ("ReleaseBooleanArrayElements");
    names [RELEASEBYTEARRAYELEMENTS] = new String ("ReleaseByteArrayElements");
    names [RELEASECHARARRAYELEMENTS] = new String ("ReleaseCharArrayElements");
    names [RELEASESHORTARRAYELEMENTS] = new String ("ReleaseShortArrayElements");
    names [RELEASEINTARRAYELEMENTS] = new String ("ReleaseIntArrayElements");
    names [RELEASELONGARRAYELEMENTS] = new String ("ReleaseLongArrayElements");
    names [RELEASEFLOATARRAYELEMENTS] = new String ("ReleaseFloatArrayElements");
    names [RELEASEDOUBLEARRAYELEMENTS] = new String ("ReleaseDoubleArrayElements");
    names [GETBOOLEANARRAYREGION] = new String ("GetBooleanArrayRegion");
    names [GETBYTEARRAYREGION] = new String ("GetByteArrayRegion");
    names [GETCHARARRAYREGION] = new String ("GetCharArrayRegion");
    names [GETSHORTARRAYREGION] = new String ("GetShortArrayRegion");
    names [GETINTARRAYREGION] = new String ("GetIntArrayRegion");
    names [GETLONGARRAYREGION] = new String ("GetLongArrayRegion");
    names [GETFLOATARRAYREGION] = new String ("GetFloatArrayRegion");
    names [GETDOUBLEARRAYREGION] = new String ("GetDoubleArrayRegion");
    names [SETBOOLEANARRAYREGION] = new String ("SetBooleanArrayRegion");
    names [SETBYTEARRAYREGION] = new String ("SetByteArrayRegion");
    names [SETCHARARRAYREGION] = new String ("SetCharArrayRegion");
    names [SETSHORTARRAYREGION] = new String ("SetShortArrayRegion");
    names [SETINTARRAYREGION] = new String ("SetIntArrayRegion");
    names [SETLONGARRAYREGION] = new String ("SetLongArrayRegion");
    names [SETFLOATARRAYREGION] = new String ("SetFloatArrayRegion");
    names [SETDOUBLEARRAYREGION] = new String ("SetDoubleArrayRegion");
    names [REGISTERNATIVES] = new String ("RegisterNatives");
    names [UNREGISTERNATIVES] = new String ("UnregisterNatives");
    names [MONITORENTER] = new String ("MonitorEnter");
    names [MONITOREXIT] = new String ("MonitorExit");
    names [GETJAVAVM] = new String ("GetJavaVM");
    names [GETSTRINGREGION] = new String ("GetStringRegion");
    names [GETSTRINGUTFREGION] = new String ("GetStringUTFRegion");
    names [GETPRIMITIVEARRAYCRITICAL] = new String ("GetPrimitiveArrayCritical");
    names [RELEASEPRIMITIVEARRAYCRITICAL] = new String ("ReleasePrimitiveArrayCritical");
    names [GETSTRINGCRITICAL] = new String ("GetStringCritical");
    names [RELEASESTRINGCRITICAL] = new String ("ReleaseStringCritical");
    names [NEWWEAKGLOBALREF] = new String ("NewWeakGlobalRef");
    names [DELETEWEAKGLOBALREF] = new String ("DeleteWeakGlobalRef");
    names [EXCEPTIONCHECK] = new String ("ExceptionCheck");
    return names;
}


private static String [] setNames () {
    names = new String [FUNCTIONCOUNT];
    names [0] = new String ("undefined");
    names [RESERVED0] = new String ("reserved0");
    names [RESERVED1] = new String ("reserved1");
    names [RESERVED2] = new String ("reserved2");
    names [RESERVED3] = new String ("reserved3");
    names [GETVERSION] = new String ("GetVersion");
    names [DEFINECLASS] = new String ("DefineClass");
    names [FINDCLASS] = new String ("FindClass");
    names [FROMREFLECTEDMETHOD] = new String ("FromReflectedMethod");
    names [FROMREFLECTEDFIELD] = new String ("FromReflectedField");
    names [TOREFLECTEDMETHOD] = new String ("ToReflectedMethod");
    names [GETSUPERCLASS] = new String ("GetSuperclass");
    names [ISASSIGNABLEFROM] = new String ("IsAssignableFrom");
    names [TOREFLECTEDFIELD] = new String ("ToReflectedField");
    names [THROW] = new String ("Throw");
    names [THROWNEW] = new String ("ThrowNew");
    names [EXCEPTIONOCCURRED] = new String ("ExceptionOccurred");
    names [EXCEPTIONDESCRIBE] = new String ("ExceptionDescribe");
    names [EXCEPTIONCLEAR] = new String ("ExceptionClear");
    names [FATALERROR] = new String ("FatalError");
    names [PUSHLOCALFRAME] = new String ("PushLocalFrame");
    names [POPLOCALFRAME] = new String ("PopLocalFrame");
    names [NEWGLOBALREF] = new String ("NewGlobalRef");
    names [DELETEGLOBALREF] = new String ("DeleteGlobalRef");
    names [DELETELOCALREF] = new String ("DeleteLocalRef");
    names [ISSAMEOBJECT] = new String ("IsSameObject");
    names [NEWLOCALREF] = new String ("NewLocalRef");
    names [ENSURELOCALCAPACITY] = new String ("EnsureLocalCapacity");
    names [ALLOCOBJECT] = new String ("AllocObject");
    names [NEWOBJECT] = new String ("NewObject");
    names [NEWOBJECTV] = new String ("NewObjectV");
    names [NEWOBJECTA] = new String ("NewObjectA");
    names [GETOBJECTCLASS] = new String ("GetObjectClass");
    names [ISINSTANCEOF] = new String ("IsInstanceOf");
    names [GETMETHODID] = new String ("GetMethodID");
    names [CALLOBJECTMETHOD] = new String ("CallObjectMethod");
    names [CALLOBJECTMETHODV] = new String ("CallObjectMethodV");
    names [CALLOBJECTMETHODA] = new String ("CallObjectMethodA");
    names [CALLBOOLEANMETHOD] = new String ("CallBooleanMethod");
    names [CALLBOOLEANMETHODV] = new String ("CallBooleanMethodV");
    names [CALLBOOLEANMETHODA] = new String ("CallBooleanMethodA");
    names [CALLBYTEMETHOD] = new String ("CallByteMethod");
    names [CALLBYTEMETHODV] = new String ("CallByteMethodV");
    names [CALLBYTEMETHODA] = new String ("CallByteMethodA");
    names [CALLCHARMETHOD] = new String ("CallCharMethod");
    names [CALLCHARMETHODV] = new String ("CallCharMethodV");
    names [CALLCHARMETHODA] = new String ("CallCharMethodA");
    names [CALLSHORTMETHOD] = new String ("CallShortMethod");
    names [CALLSHORTMETHODV] = new String ("CallShortMethodV");
    names [CALLSHORTMETHODA] = new String ("CallShortMethodA");
    names [CALLINTMETHOD] = new String ("CallIntMethod");
    names [CALLINTMETHODV] = new String ("CallIntMethodV");
    names [CALLINTMETHODA] = new String ("CallIntMethodA");
    names [CALLLONGMETHOD] = new String ("CallLongMethod");
    names [CALLLONGMETHODV] = new String ("CallLongMethodV");
    names [CALLLONGMETHODA] = new String ("CallLongMethodA");
    names [CALLFLOATMETHOD] = new String ("CallFloatMethod");
    names [CALLFLOATMETHODV] = new String ("CallFloatMethodV");
    names [CALLFLOATMETHODA] = new String ("CallFloatMethodA");
    names [CALLDOUBLEMETHOD] = new String ("CallDoubleMethod");
    names [CALLDOUBLEMETHODV] = new String ("CallDoubleMethodV");
    names [CALLDOUBLEMETHODA] = new String ("CallDoubleMethodA");
    names [CALLVOIDMETHOD] = new String ("CallVoidMethod");
    names [CALLVOIDMETHODV] = new String ("CallVoidMethodV");
    names [CALLVOIDMETHODA] = new String ("CallVoidMethodA");
    names [CALLNONVIRTUALOBJECTMETHOD] = new String ("CallNonvirtualObjectMethod");
    names [CALLNONVIRTUALOBJECTMETHODV] = new String ("CallNonvirtualObjectMethodV");
    names [CALLNONVIRTUALOBJECTMETHODA] = new String ("CallNonvirtualObjectMethodA");
    names [CALLNONVIRTUALBOOLEANMETHOD] = new String ("CallNonvirtualBooleanMethod");
    names [CALLNONVIRTUALBOOLEANMETHODV] = new String ("CallNonvirtualBooleanMethodV");
    names [CALLNONVIRTUALBOOLEANMETHODA] = new String ("CallNonvirtualBooleanMethodA");
    names [CALLNONVIRTUALBYTEMETHOD] = new String ("CallNonvirtualByteMethod");
    names [CALLNONVIRTUALBYTEMETHODV] = new String ("CallNonvirtualByteMethodV");
    names [CALLNONVIRTUALBYTEMETHODA] = new String ("CallNonvirtualByteMethodA");
    names [CALLNONVIRTUALCHARMETHOD] = new String ("CallNonvirtualCharMethod");
    names [CALLNONVIRTUALCHARMETHODV] = new String ("CallNonvirtualCharMethodV");
    names [CALLNONVIRTUALCHARMETHODA] = new String ("CallNonvirtualCharMethodA");
    names [CALLNONVIRTUALSHORTMETHOD] = new String ("CallNonvirtualShortMethod");
    names [CALLNONVIRTUALSHORTMETHODV] = new String ("CallNonvirtualShortMethodV");
    names [CALLNONVIRTUALSHORTMETHODA] = new String ("CallNonvirtualShortMethodA");
    names [CALLNONVIRTUALINTMETHOD] = new String ("CallNonvirtualIntMethod");
    names [CALLNONVIRTUALINTMETHODV] = new String ("CallNonvirtualIntMethodV");
    names [CALLNONVIRTUALINTMETHODA] = new String ("CallNonvirtualIntMethodA");
    names [CALLNONVIRTUALLONGMETHOD] = new String ("CallNonvirtualLongMethod");
    names [CALLNONVIRTUALLONGMETHODV] = new String ("CallNonvirtualLongMethodV");
    names [CALLNONVIRTUALLONGMETHODA] = new String ("CallNonvirtualLongMethodA");
    names [CALLNONVIRTUALFLOATMETHOD] = new String ("CallNonvirtualFloatMethod");
    names [CALLNONVIRTUALFLOATMETHODV] = new String ("CallNonvirtualFloatMethodV");
    names [CALLNONVIRTUALFLOATMETHODA] = new String ("CallNonvirtualFloatMethodA");
    names [CALLNONVIRTUALDOUBLEMETHOD] = new String ("CallNonvirtualDoubleMethod");
    names [CALLNONVIRTUALDOUBLEMETHODV] = new String ("CallNonvirtualDoubleMethodV");
    names [CALLNONVIRTUALDOUBLEMETHODA] = new String ("CallNonvirtualDoubleMethodA");
    names [CALLNONVIRTUALVOIDMETHOD] = new String ("CallNonvirtualVoidMethod");
    names [CALLNONVIRTUALVOIDMETHODV] = new String ("CallNonvirtualVoidMethodV");
    names [CALLNONVIRTUALVOIDMETHODA] = new String ("CallNonvirtualVoidMethodA");
    names [GETFIELDID] = new String ("GetFieldID");
    names [GETOBJECTFIELD] = new String ("GetObjectField");
    names [GETBOOLEANFIELD] = new String ("GetBooleanField");
    names [GETBYTEFIELD] = new String ("GetByteField");
    names [GETCHARFIELD] = new String ("GetCharField");
    names [GETSHORTFIELD] = new String ("GetShortField");
    names [GETINTFIELD] = new String ("GetIntField");
    names [GETLONGFIELD] = new String ("GetLongField");
    names [GETFLOATFIELD] = new String ("GetFloatField");
    names [GETDOUBLEFIELD] = new String ("GetDoubleField");
    names [SETOBJECTFIELD] = new String ("SetObjectField");
    names [SETBOOLEANFIELD] = new String ("SetBooleanField");
    names [SETBYTEFIELD] = new String ("SetByteField");
    names [SETCHARFIELD] = new String ("SetCharField");
    names [SETSHORTFIELD] = new String ("SetShortField");
    names [SETINTFIELD] = new String ("SetIntField");
    names [SETLONGFIELD] = new String ("SetLongField");
    names [SETFLOATFIELD] = new String ("SetFloatField");
    names [SETDOUBLEFIELD] = new String ("SetDoubleField");
    names [GETSTATICMETHODID] = new String ("GetStaticMethodID");
    names [CALLSTATICOBJECTMETHOD] = new String ("CallStaticObjectMethod");
    names [CALLSTATICOBJECTMETHODV] = new String ("CallStaticObjectMethodV");
    names [CALLSTATICOBJECTMETHODA] = new String ("CallStaticObjectMethodA");
    names [CALLSTATICBOOLEANMETHOD] = new String ("CallStaticBooleanMethod");
    names [CALLSTATICBOOLEANMETHODV] = new String ("CallStaticBooleanMethodV");
    names [CALLSTATICBOOLEANMETHODA] = new String ("CallStaticBooleanMethodA");
    names [CALLSTATICBYTEMETHOD] = new String ("CallStaticByteMethod");
    names [CALLSTATICBYTEMETHODV] = new String ("CallStaticByteMethodV");
    names [CALLSTATICBYTEMETHODA] = new String ("CallStaticByteMethodA");
    names [CALLSTATICCHARMETHOD] = new String ("CallStaticCharMethod");
    names [CALLSTATICCHARMETHODV] = new String ("CallStaticCharMethodV");
    names [CALLSTATICCHARMETHODA] = new String ("CallStaticCharMethodA");
    names [CALLSTATICSHORTMETHOD] = new String ("CallStaticShortMethod");
    names [CALLSTATICSHORTMETHODV] = new String ("CallStaticShortMethodV");
    names [CALLSTATICSHORTMETHODA] = new String ("CallStaticShortMethodA");
    names [CALLSTATICINTMETHOD] = new String ("CallStaticIntMethod");
    names [CALLSTATICINTMETHODV] = new String ("CallStaticIntMethodV");
    names [CALLSTATICINTMETHODA] = new String ("CallStaticIntMethodA");
    names [CALLSTATICLONGMETHOD] = new String ("CallStaticLongMethod");
    names [CALLSTATICLONGMETHODV] = new String ("CallStaticLongMethodV");
    names [CALLSTATICLONGMETHODA] = new String ("CallStaticLongMethodA");
    names [CALLSTATICFLOATMETHOD] = new String ("CallStaticFloatMethod");
    names [CALLSTATICFLOATMETHODV] = new String ("CallStaticFloatMethodV");
    names [CALLSTATICFLOATMETHODA] = new String ("CallStaticFloatMethodA");
    names [CALLSTATICDOUBLEMETHOD] = new String ("CallStaticDoubleMethod");
    names [CALLSTATICDOUBLEMETHODV] = new String ("CallStaticDoubleMethodV");
    names [CALLSTATICDOUBLEMETHODA] = new String ("CallStaticDoubleMethodA");
    names [CALLSTATICVOIDMETHOD] = new String ("CallStaticVoidMethod");
    names [CALLSTATICVOIDMETHODV] = new String ("CallStaticVoidMethodV");
    names [CALLSTATICVOIDMETHODA] = new String ("CallStaticVoidMethodA");
    names [GETSTATICFIELDID] = new String ("GetStaticFieldID");
    names [GETSTATICOBJECTFIELD] = new String ("GetStaticObjectField");
    names [GETSTATICBOOLEANFIELD] = new String ("GetStaticBooleanField");
    names [GETSTATICBYTEFIELD] = new String ("GetStaticByteField");
    names [GETSTATICCHARFIELD] = new String ("GetStaticCharField");
    names [GETSTATICSHORTFIELD] = new String ("GetStaticShortField");
    names [GETSTATICINTFIELD] = new String ("GetStaticIntField");
    names [GETSTATICLONGFIELD] = new String ("GetStaticLongField");
    names [GETSTATICFLOATFIELD] = new String ("GetStaticFloatField");
    names [GETSTATICDOUBLEFIELD] = new String ("GetStaticDoubleField");
    names [SETSTATICOBJECTFIELD] = new String ("SetStaticObjectField");
    names [SETSTATICBOOLEANFIELD] = new String ("SetStaticBooleanField");
    names [SETSTATICBYTEFIELD] = new String ("SetStaticByteField");
    names [SETSTATICCHARFIELD] = new String ("SetStaticCharField");
    names [SETSTATICSHORTFIELD] = new String ("SetStaticShortField");
    names [SETSTATICINTFIELD] = new String ("SetStaticIntField");
    names [SETSTATICLONGFIELD] = new String ("SetStaticLongField");
    names [SETSTATICFLOATFIELD] = new String ("SetStaticFloatField");
    names [SETSTATICDOUBLEFIELD] = new String ("SetStaticDoubleField");
    names [NEWSTRING] = new String ("NewString");
    names [GETSTRINGLENGTH] = new String ("GetStringLength");
    names [GETSTRINGCHARS] = new String ("GetStringChars");
    names [RELEASESTRINGCHARS] = new String ("ReleaseStringChars");
    names [NEWSTRINGUTF] = new String ("NewStringUTF");
    names [GETSTRINGUTFLENGTH] = new String ("GetStringUTFLength");
    names [GETSTRINGUTFCHARS] = new String ("GetStringUTFChars");
    names [RELEASESTRINGUTFCHARS] = new String ("ReleaseStringUTFChars");
    names [GETARRAYLENGTH] = new String ("GetArrayLength");
    names [NEWOBJECTARRAY] = new String ("NewObjectArray");
    names [GETOBJECTARRAYELEMENT] = new String ("GetObjectArrayElement");
    names [SETOBJECTARRAYELEMENT] = new String ("SetObjectArrayElement");
    names [NEWBOOLEANARRAY] = new String ("NewBooleanArray");
    names [NEWBYTEARRAY] = new String ("NewByteArray");
    names [NEWCHARARRAY] = new String ("NewCharArray");
    names [NEWSHORTARRAY] = new String ("NewShortArray");
    names [NEWINTARRAY] = new String ("NewIntArray");
    names [NEWLONGARRAY] = new String ("NewLongArray");
    names [NEWFLOATARRAY] = new String ("NewFloatArray");
    names [NEWDOUBLEARRAY] = new String ("NewDoubleArray");
    names [GETBOOLEANARRAYELEMENTS] = new String ("GetBooleanArrayElements");
    names [GETBYTEARRAYELEMENTS] = new String ("GetByteArrayElements");
    names [GETCHARARRAYELEMENTS] = new String ("GetCharArrayElements");
    names [GETSHORTARRAYELEMENTS] = new String ("GetShortArrayElements");
    names [GETINTARRAYELEMENTS] = new String ("GetIntArrayElements");
    names [GETLONGARRAYELEMENTS] = new String ("GetLongArrayElements");
    names [GETFLOATARRAYELEMENTS] = new String ("GetFloatArrayElements");
    names [GETDOUBLEARRAYELEMENTS] = new String ("GetDoubleArrayElements");
    names [RELEASEBOOLEANARRAYELEMENTS] = new String ("ReleaseBooleanArrayElements");
    names [RELEASEBYTEARRAYELEMENTS] = new String ("ReleaseByteArrayElements");
    names [RELEASECHARARRAYELEMENTS] = new String ("ReleaseCharArrayElements");
    names [RELEASESHORTARRAYELEMENTS] = new String ("ReleaseShortArrayElements");
    names [RELEASEINTARRAYELEMENTS] = new String ("ReleaseIntArrayElements");
    names [RELEASELONGARRAYELEMENTS] = new String ("ReleaseLongArrayElements");
    names [RELEASEFLOATARRAYELEMENTS] = new String ("ReleaseFloatArrayElements");
    names [RELEASEDOUBLEARRAYELEMENTS] = new String ("ReleaseDoubleArrayElements");
    names [GETBOOLEANARRAYREGION] = new String ("GetBooleanArrayRegion");
    names [GETBYTEARRAYREGION] = new String ("GetByteArrayRegion");
    names [GETCHARARRAYREGION] = new String ("GetCharArrayRegion");
    names [GETSHORTARRAYREGION] = new String ("GetShortArrayRegion");
    names [GETINTARRAYREGION] = new String ("GetIntArrayRegion");
    names [GETLONGARRAYREGION] = new String ("GetLongArrayRegion");
    names [GETFLOATARRAYREGION] = new String ("GetFloatArrayRegion");
    names [GETDOUBLEARRAYREGION] = new String ("GetDoubleArrayRegion");
    names [SETBOOLEANARRAYREGION] = new String ("SetBooleanArrayRegion");
    names [SETBYTEARRAYREGION] = new String ("SetByteArrayRegion");
    names [SETCHARARRAYREGION] = new String ("SetCharArrayRegion");
    names [SETSHORTARRAYREGION] = new String ("SetShortArrayRegion");
    names [SETINTARRAYREGION] = new String ("SetIntArrayRegion");
    names [SETLONGARRAYREGION] = new String ("SetLongArrayRegion");
    names [SETFLOATARRAYREGION] = new String ("SetFloatArrayRegion");
    names [SETDOUBLEARRAYREGION] = new String ("SetDoubleArrayRegion");
    names [REGISTERNATIVES] = new String ("RegisterNatives");
    names [UNREGISTERNATIVES] = new String ("UnregisterNatives");
    names [MONITORENTER] = new String ("MonitorEnter");
    names [MONITOREXIT] = new String ("MonitorExit");
    names [GETJAVAVM] = new String ("GetJavaVM");
    names [GETSTRINGREGION] = new String ("GetStringRegion");
    names [GETSTRINGUTFREGION] = new String ("GetStringUTFRegion");
    names [GETPRIMITIVEARRAYCRITICAL] = new String ("GetPrimitiveArrayCritical");
    names [RELEASEPRIMITIVEARRAYCRITICAL] = new String ("ReleasePrimitiveArrayCritical");
    names [GETSTRINGCRITICAL] = new String ("GetStringCritical");
    names [RELEASESTRINGCRITICAL] = new String ("ReleaseStringCritical");
    names [NEWWEAKGLOBALREF] = new String ("NewWeakGlobalRef");
    names [DELETEWEAKGLOBALREF] = new String ("DeleteWeakGlobalRef");
    names [EXCEPTIONCHECK] = new String ("ExceptionCheck");
    return names;
}


-----Function Pair=70=-----==

private void readPasswordParameters () {
    String encPasswordParam = readParameter ("ENCPASSWORD", false);
    if (encPasswordParam == null) {
        passwordParam = readParameter ("PASSWORD", false);
    }
    else {
        byte [] pw = {0, 0, 0, 0, 0, 0, 0, 0};
        int len = encPasswordParam.length () / 2;
        if (len > 8) len = 8;
        for (int i = 0; i < len; i ++) {
            String hex = encPasswordParam.substring (i * 2, i * 2 + 2);
            Integer x = new Integer (Integer.parseInt (hex, 16));
            pw [i] = x.byteValue ();
        }
        byte [] key = {23, 82, 107, 6, 35, 78, 88, 7};
        DesCipher des = new DesCipher (key);
        des.decrypt (pw, 0, pw, 0);
        passwordParam = new String (pw);
    }
}


private Repository _createRepository (Results r, SymbolRepository sRepository) {
    DatabaseDriver driver = null;
    try {
        Class < ? > c = Class.forName (sRepository.pDriver);
        Constructor co = c.getConstructor (new Class < ? > [0]);
        driver = (DatabaseDriver) co.newInstance (new Object [0]);
    } catch (Exception ex) {
        r.addError ("could not load database driver '" + sRepository.pDriver + "': " + ex);
        return null;
    }
    if (sRepository.pMaxActive != null) {
        sRepository.aMaxActive = _getIntParameter (r, sRepository.pMaxActive, "max-active");
    }
    else {
        sRepository.aMaxActive = 100;
    }
    if (sRepository.pMaxIdle != null) {
        sRepository.aMaxIdle = _getIntParameter (r, sRepository.pMaxIdle, "max-idle");
    }
    else {
        sRepository.aMaxIdle = 100;
    }
    if (sRepository.pMaxWait != null) {
        sRepository.aMaxWait = _getIntParameter (r, sRepository.pMaxWait, "max-wait");
    }
    else {
        sRepository.aMaxWait = 10;
    }
    if (sRepository.pRemoveAbandonedTimeout != null) {
        sRepository.aRemoveAbandonedTimeout = _getIntParameter (r, sRepository.pRemoveAbandonedTimeout, "remove-abandoned-timeout");
    }
    else {
        sRepository.aRemoveAbandonedTimeout = 60;
    }
    return new Repository (driver, sRepository);
}


-----Function Pair=71=-----=1=

public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println ("caught ClassNotFoundException");
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


public SensorAgent load (String xmlFile) {
    SensorAgent sensorAgent = null;
    try {
        File f = new File (xmlFile);
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
        DocumentBuilder builder = factory.newDocumentBuilder ();
        Document doc = builder.parse (f);
        String name = doc.getElementsByTagName ("name").item (0).getFirstChild ().getNodeValue ();
        String id = doc.getElementsByTagName ("id").item (0).getFirstChild ().getNodeValue ();
        String class_name = doc.getElementsByTagName ("class").item (0).getFirstChild ().getNodeValue ();
        String location = doc.getElementsByTagName ("location").item (0).getFirstChild ().getNodeValue ();
        String valueType = doc.getElementsByTagName ("ValueType").item (0).getFirstChild ().getNodeValue ();
        String dataSchema = doc.getElementsByTagName ("DataSchema").item (0).getAttributes ().getNamedItem ("type").getNodeValue ();
        String dataDisseminateTime = doc.getElementsByTagName ("DataDisseminate").item (0).getAttributes ().getNamedItem ("time").getNodeValue ();
        String dataDisseminateLazy = doc.getElementsByTagName ("DataDisseminate").item (0).getAttributes ().getNamedItem ("lazy").getNodeValue ();
        ArrayList < String > args = new ArrayList < String > ();
        Node arguments = doc.getElementsByTagName ("arguments").item (0);
        for (Node argument = arguments.getFirstChild (); argument != null; argument = argument.getNextSibling ()) {
            if (argument.getNodeType () == Node.ELEMENT_NODE) {
                if (argument.getNodeName ().equals ("argument")) {
                    args.add (argument.getFirstChild ().getNodeValue ());
                }
            }
        }
        Class < ? > cons = Class.forName (class_name);
        Constructor < ? > constructor = cons.getConstructor (Object.class);
        Object arg = Array.newInstance (String.class, args.size ());
        for (int i = 0; i < args.size (); i ++) Array.set (arg, i, args.get (i));
        Sensor sensor = (Sensor) constructor.newInstance (arg);
        DataDisseminate dataDisseminate = new DataDisseminate (dataSource, Integer.parseInt (dataDisseminateTime), Boolean.parseBoolean (dataDisseminateLazy));
        if (dataSchema.equals ("push")) {
            sensorAgent = new PushSensorAgent (dataDisseminate, id, valueType, sensor);
        }
        else if (dataSchema.equals ("pull")) {
        }
        else {
        }
        Thread t = new Thread (sensorAgent);
        t.start ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return sensorAgent;
}


-----Function Pair=72=-----=1=

public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println ("caught ClassNotFoundException");
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println ("caught ClassNotFoundException");
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


-----Function Pair=73=-----==

public void save () {
    if (fileChooser == null) return;
    CGCanvas canvas = getSelectedCanvas ();
    if (canvas != null) {
        int action = fileChooser.showSaveDialog (this);
        if (action == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile ();
            try {
                canvas.save (file);
            } catch (Exception ex) {
                showSaveFailedDialog (ex.getMessage ());
            }
        }
    }
}


public static void main (String [] args) {
    Process p;
    try {
        ProcessBuilder pb = new ProcessBuilder ("cat", "/dev/random");
        p = pb.start ();
    } catch (IOException ioe) {
        System.err.println ("cmd failed: " + ioe.getMessage ());
        p = null;
    }
    try {
        testDexClassLoader ();
    } finally {
        if (p != null) p.destroy ();
        try {
            Thread.sleep (500);
        } catch (Exception ex) {
        }
    }
    System.out.println ("done");
}


-----Function Pair=74=-----==

protected Class < ? > loadClass (String name, boolean resolve) throws ClassNotFoundException {
    Class res;
    res = findLoadedClass (name);
    if (res != null) {
        System.out.println ("FancyLoader.loadClass: " + name + " already loaded");
        if (resolve) resolveClass (res);
        return res;
    }
    try {
        res = findClass (name);
        if (resolve) resolveClass (res);
    } catch (ClassNotFoundException e) {
    }
    res = super.loadClass (name, resolve);
    return res;
}


private void loadServices () {
    int index = 1;
    String serviceClass = null;
    do {
        serviceClass = Properties.getProperty (PropertiesHelper.SERVICE + "." + index);
        if (serviceClass != null) {
            Service service = this.getServiceInstance (serviceClass);
            if (service != null) {
                this.services.add (service);
                logger.info ("Service " + serviceClass + " registered.");
            }
            else {
                logger.warn ("Service " + serviceClass + " was not registered.");
            }
        }
        index ++;
    }
    while (serviceClass != null);
}


-----Function Pair=75=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=76=-----==

private void makeRandPCRError () {
    try {
        BufferedReader input = new BufferedReader (new FileReader (this.pcrerror));
        String pcrerrorVal = input.readLine ();
        input.close ();
        long randNumSeed = (long) (100000000 * Math.random ());
        if (randNumSeed % 2 == 0) {
            randNumSeed ++;
        }
        String randSeedLine = randNumSeed + "     random number seed odd integer";
        BufferedWriter output = new BufferedWriter (new FileWriter (this.pcrerror));
        output.write (pcrerrorVal);
        output.newLine ();
        output.write (randSeedLine);
        output.newLine ();
        output.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public void start (Gedcom gedcom) {
    String cmd = getValueFromUser ("executables", translate ("WhichExecutable"), new String [0]);
    if (cmd == null) return;
    try {
        Process process = Runtime.getRuntime ().exec (cmd);
        BufferedReader in = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        while (true) {
            String line = in.readLine ();
            if (line == null) break;
            println (line);
        }
    } catch (IOException ioe) {
        println (translate ("Error") + ioe.getMessage ());
    }
}


-----Function Pair=77=-----==

public void run () {
    while (! Thread.interrupted ()) {
        try {
            isReady = false;
            getStatistics ();
            isReady = true;
            Thread.sleep (30000);
        } catch (InterruptedException ex) {
            ex.printStackTrace ();
            isReady = false;
            break;
        }
    }
    isReady = false;
    return;
}


private static String monthNameToNo (String monthName) {
    if (monthName.equalsIgnoreCase ("JAN")) {
        return "01";
    }
    if (monthName.equalsIgnoreCase ("FEB")) {
        return "02";
    }
    if (monthName.equalsIgnoreCase ("MAR")) {
        return "03";
    }
    if (monthName.equalsIgnoreCase ("APR")) {
        return "04";
    }
    if (monthName.equalsIgnoreCase ("MAY")) {
        return "05";
    }
    if (monthName.equalsIgnoreCase ("JUN")) {
        return "06";
    }
    if (monthName.equalsIgnoreCase ("JUL")) {
        return "07";
    }
    if (monthName.equalsIgnoreCase ("AUG")) {
        return "08";
    }
    if (monthName.equalsIgnoreCase ("SEP")) {
        return "09";
    }
    if (monthName.equalsIgnoreCase ("OCT")) {
        return "10";
    }
    if (monthName.equalsIgnoreCase ("NOV")) {
        return "11";
    }
    if (monthName.equalsIgnoreCase ("DEC")) {
        return "12";
    }
    else {
        return "01";
    }
}


-----Function Pair=78=-----==

public static String isZero (String s) {
    String ret = isNumeric (s);
    if ("true".equals (ret)) {
        if (s.length () > 0) {
            StringBuffer localVal = new StringBuffer (s);
            if (s.startsWith ("+") || s.startsWith ("-")) {
                localVal.deleteCharAt (0);
            }
            int decimalPoint = localVal.toString ().indexOf (".");
            if (decimalPoint >= 0) {
                localVal.deleteCharAt (decimalPoint);
            }
            try {
                int numb = Integer.parseInt (localVal.toString ());
                if (numb != 0) ret = "false";
            } catch (NumberFormatException e) {
                ret = "false";
            }
        }
    }
    return ret;
}


private byte [] moveTunerDown (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount () - 1) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex + 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=79=-----==

public boolean validateDirectiveSection () throws Exception {
    String testRoot = TEST_DirectiveSection;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("list0", EMPTY);
    sReferencePS.set ("list1", "[0]");
    sReferencePS.set ("list2", "[0][1]");
    sReferencePS.set (FOO, BAR);
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.contains (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


public boolean validateMethodGetFileIndex () throws Exception {
    String testRoot = TEST_MethodGetFileIndex;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set (NAME_FileNameRoot, PREFIX_RESULT + testRoot + A);
    sReferencePS.set (NAME_FileIndex, ZERO);
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + A + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    sReferencePS.set (NAME_FileNameRoot, PREFIX_RESULT + testRoot + B);
    sReferencePS.set (NAME_FileIndex, ONE);
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + B + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=80=-----==

public void execute () {
    if (includes != null && includes.trim ().isEmpty ()) return;
    DirectoryScanner s = getDirectoryScanner (srcDir);
    String [] files = s.getIncludedFiles ();
    files = filter (srcDir, destDir, files);
    if (files.length == 0) return;
    System.out.println ("Generating " + files.length + " stub files to " + destDir);
    List < String > classNames = new ArrayList < String > ();
    for (String file : files) {
        classNames.add (file.replaceAll (".java$", "").replace ('/', '.'));
    }
    if (! fork) {
        GenStubs m = new GenStubs ();
        boolean ok = m.run (srcDir.getPath (), destDir, classNames);
        if (! ok) throw new BuildException ("genstubs failed");
    }
    else {
        List < String > cmd = new ArrayList < String > ();
        String java_home = System.getProperty ("java.home");
        cmd.add (new File (new File (java_home, "bin"), "java").getPath ());
        if (classpath != null) cmd.add ("-Xbootclasspath/p:" + classpath);
        cmd.add (GenStubs.class.getName ());
        cmd.add ("-sourcepath");
        cmd.add (srcDir.getPath ());
        cmd.add ("-s");
        cmd.add (destDir.getPath ());
        cmd.addAll (classNames);
        ProcessBuilder pb = new ProcessBuilder (cmd);
        pb.redirectErrorStream (true);
        try {
            Process p = pb.start ();
            BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
            try {
                String line;
                while ((line = in.readLine ()) != null) System.out.println (line);
            } finally {
                in.close ();
            }
            int rc = p.waitFor ();
            if (rc != 0) throw new BuildException ("genstubs failed");
        } catch (IOException e) {
            throw new BuildException ("genstubs failed", e);
        } catch (InterruptedException e) {
            throw new BuildException ("genstubs failed", e);
        }
    }
}


private byte [] showCapPathPage (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "CapturePaths.html");
    template.replaceAll ("$title", "Capture path and file name setup");
    StringBuffer buff = new StringBuffer ();
    String [] paths = store.getCapturePaths ();
    DllWrapper wrapper = new DllWrapper ();
    NumberFormat nf = NumberFormat.getInstance ();
    for (int x = 0; x < paths.length; x ++) {
        buff.append ("<tr>");
        File capPath = new File (paths [x]);
        if (capPath.exists () == false) {
            buff.append ("<td nowrap>");
            buff.append ("<img border='0' alt='Does Not Exist' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
            buff.append (paths [x] + " </td>");
            buff.append ("<td nowrap> (No details available) </td>");
        }
        else {
            buff.append ("<td nowrap>" + capPath.getCanonicalPath () + " </td>");
            long freeSpace = new File (capPath.getCanonicalPath ()).getFreeSpace ();
            freeSpace /= (1024 * 1024);
            buff.append ("<td nowrap> Free: " + nf.format (freeSpace) + " MB</td>");
        }
        buff.append ("<td nowrap width='50px'> ");
        if (paths.length > 1) {
            buff.append (" <a href='/servlet/SystemDataRes?action=33&id=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
            if (x > 0) buff.append ("<a href='/servlet/SystemDataRes?action=34&id=" + x + "&amount=-1'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
            else buff.append ("<img border='0' alt='' src='/images/blank.gif' align='absmiddle' width='7' height='7'> ");
            if (x < paths.length - 1) buff.append ("<a href='/servlet/SystemDataRes?action=34&id=" + x + "&amount=1'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
            else buff.append ("<img border='0' alt='' src='/images/blank.gif' align='absmiddle' width='7' height='7'> ");
        }
        buff.append (" </td>\n");
        buff.append ("</tr>");
    }
    template.replaceAll ("$capturePaths", buff.toString ());
    template.replaceAll ("$minSpace", store.getProperty ("Capture.minSpace"));
    String autoType = store.getProperty ("Capture.AutoSelectMethod");
    buff = new StringBuffer ();
    if (autoType.equals ("0")) buff.append ("<option value='0' selected>Most Free Space</option>");
    else buff.append ("<option value='0'>Most Free Space</option>");
    if (autoType.equals ("1")) buff.append ("<option value='1' selected>First With Enough Space</option>");
    else buff.append ("<option value='1'>First With Enough Space</option>");
    template.replaceAll ("$AutoSelectType", buff.toString ());
    String includeThis = store.getProperty ("Capture.IncludeCalculatedUsage");
    if ("1".equals (includeThis)) {
        template.replaceAll ("$IncludeThisCapture", "checked");
    }
    else {
        template.replaceAll ("$IncludeThisCapture", "");
    }
    String avDataRate = store.getProperty ("Capture.AverageDataRate").trim ();
    template.replaceAll ("$AverageDataRate", avDataRate);
    String [] patterns = store.getNamePatterns ();
    buff = new StringBuffer ();
    for (int x = 0; x < patterns.length; x ++) {
        buff.append ("<tr>");
        buff.append ("<td>" + patterns [x] + " </td>");
        buff.append ("<td> " + testPattern (patterns [x]) + " </td>");
        buff.append ("<td nowrap width='50px'> ");
        buff.append (" <a href='/servlet/SystemDataRes?action=28&id=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        buff.append ("<a href='/servlet/SystemDataRes?action=30&id=" + x + "&amount=-1'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        buff.append ("<a href='/servlet/SystemDataRes?action=30&id=" + x + "&amount=1'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        buff.append (" </td>\n");
        buff.append ("</tr>");
    }
    template.replaceAll ("$fileNamePatterns", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=81=-----==

boolean do_which (String className, File f) throws Exception {
    Runtime rt = Runtime.getRuntime ();
    if (verbose) System.out.println (f);
    Process proc = rt.exec (JAR_CMD + " -tvf " + f.getAbsolutePath ());
    InputStream proc_out = proc.getInputStream ();
    BufferedReader reader = null;
    try {
        reader = new BufferedReader (new InputStreamReader (proc_out));
        String line = null;
        while ((line = reader.readLine ()) != null) {
            if (line.indexOf (className) != - 1) {
                System.out.println ();
                System.out.println ("Match found: ");
                System.out.println ("\t" + line.trim ());
                System.out.println ("\t" + f.getAbsolutePath ());
                System.out.println ();
                return true;
            }
        }
        return false;
    } finally {
        if (reader != null) reader.close ();
    }
}


public void run (int test, int seq, DatabaseReader read, int num, int system) {
    try {
        PreparedStatement esq = (PreparedStatement) conn.prepareStatement ("select sequence, name as description from sequences_for_screening where id = ? ");
        esq.setInt (1, seq);
        ResultSet entry = esq.executeQuery ();
        if (! entry.first ()) {
            System.out.print ("no entry in the database with id= ");
            System.out.println (seq);
        }
        else {
            one_seq (entry.getString (1), seq, test, read, entry.getString (2), num, system);
        }
    } catch (Exception e) {
        System.out.println ("***********************");
        System.out.println ("Error in running GenoTHREAT");
        e.printStackTrace ();
    }
}


-----Function Pair=82=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=83=-----==

public void outputTrace (String httpURI) {
    this.outputStatusLine (200);
    this.outputStdHeaders ();
    SimpleDateFormat temp = new SimpleDateFormat ("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
    temp.setTimeZone (new SimpleTimeZone (0, "GMT"));
    String dateStr = temp.format (new Date ());
    this.outputHeader ("Last-Modified: " + dateStr);
    this.outputHeader ("Content-type: " + Misc.getContentType ("trace.htm"));
    this.outputHeader ("");
    Iterator mapIterator = this.httpHeaders.keySet ().iterator ();
    String aHeader, aValue;
    while (mapIterator.hasNext ()) {
        aHeader = (String) mapIterator.next ();
        aValue = (String) httpHeaders.get (aHeader);
        this.outputSomething (aHeader + ": " + aValue);
    }
    this.outputFlush ();
}


public void start (Object context) {
    String cmd = getValueFromUser ("executables", i18n ("WhichExecutable"), new String [0]);
    if (cmd == null) return;
    try {
        Process process = Runtime.getRuntime ().exec (cmd);
        BufferedReader in = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        while (true) {
            String line = in.readLine ();
            if (line == null) break;
            println (line);
        }
    } catch (IOException ioe) {
        println (i18n ("Error") + ioe.getMessage ());
    }
}


-----Function Pair=84=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=85=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=86=-----==

protected long writeArchive (ULog log) throws IOException, ValidationException {
    long totalBytes = 0;
    OutputStream out = new BufferedOutputStream (new FileOutputStream (getOutput ()));
    ZipOutputStream zip = getCompressedStream (out);
    try {
        for (FileSpec spec : getSpecs ()) {
            List < Filelike > matches = spec.listMatches ();
            for (Filelike match : matches) {
                if (match.isFile ()) {
                    totalBytes += writeEntry (zip, match, log);
                }
                else {
                    writeDirectory (zip, match, log);
                }
            }
        }
        return totalBytes;
    } finally {
        zip.close ();
    }
}


public static long compute (String str) {
    CRC32 crc = new CRC32 ();
    Adler32 adler = new Adler32 ();
    crc.update (str.getBytes ());
    adler.update (str.getBytes ());
    long dg1 = crc.getValue ();
    long dg2 = adler.getValue ();
    crc.update (String.valueOf (dg2).getBytes ());
    adler.update (String.valueOf (dg1).getBytes ());
    long d3 = crc.getValue ();
    long d4 = adler.getValue ();
    dg1 ^= d4;
    dg2 ^= d3;
    return (dg2 ^ ((dg1>>> 32) | (dg1 << 32)));
}


-----Function Pair=87=-----=1=

public static void main (String [] argv) {
    String to, subject = null, from = null, cc = null, bcc = null, url = null;
    String mailhost = null;
    String mailer = "msgsend";
    String file = null;
    String protocol = null, host = null, user = null, password = null;
    String record = null;
    boolean debug = false;
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    int optind;
    for (optind = 0; optind < argv.length; optind ++) {
        if (argv [optind].equals ("-T")) {
            protocol = argv [++ optind];
        }
        else if (argv [optind].equals ("-H")) {
            host = argv [++ optind];
        }
        else if (argv [optind].equals ("-U")) {
            user = argv [++ optind];
        }
        else if (argv [optind].equals ("-P")) {
            password = argv [++ optind];
        }
        else if (argv [optind].equals ("-M")) {
            mailhost = argv [++ optind];
        }
        else if (argv [optind].equals ("-f")) {
            record = argv [++ optind];
        }
        else if (argv [optind].equals ("-a")) {
            file = argv [++ optind];
        }
        else if (argv [optind].equals ("-s")) {
            subject = argv [++ optind];
        }
        else if (argv [optind].equals ("-o")) {
            from = argv [++ optind];
        }
        else if (argv [optind].equals ("-c")) {
            cc = argv [++ optind];
        }
        else if (argv [optind].equals ("-b")) {
            bcc = argv [++ optind];
        }
        else if (argv [optind].equals ("-L")) {
            url = argv [++ optind];
        }
        else if (argv [optind].equals ("-d")) {
            debug = true;
        }
        else if (argv [optind].equals ("--")) {
            optind ++;
            break;
        }
        else if (argv [optind].startsWith ("-")) {
            System.out.println ("Usage: msgsend [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]");
            System.out.println ("\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]");
            System.out.println ("\t[-f record-mailbox] [-M transport-host] [-a attach-file] [-d] [address]");
            System.exit (1);
        }
        else {
            break;
        }
    }
    try {
        if (optind < argv.length) {
            to = argv [optind];
            System.out.println ("To: " + to);
        }
        else {
            System.out.print ("To: ");
            System.out.flush ();
            to = in.readLine ();
        }
        if (subject == null) {
            System.out.print ("Subject: ");
            System.out.flush ();
            subject = in.readLine ();
        }
        else {
            System.out.println ("Subject: " + subject);
        }
        Properties props = System.getProperties ();
        if (mailhost != null) props.put ("mail.smtp.host", mailhost);
        Session session = Session.getInstance (props, null);
        if (debug) session.setDebug (true);
        Message msg = new MimeMessage (session);
        if (from != null) msg.setFrom (new InternetAddress (from));
        else msg.setFrom ();
        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));
        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));
        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));
        msg.setSubject (subject);
        String text = collect (in);
        if (file != null) {
            MimeBodyPart mbp1 = new MimeBodyPart ();
            mbp1.setText (text);
            MimeBodyPart mbp2 = new MimeBodyPart ();
            mbp2.attachFile (file);
            MimeMultipart mp = new MimeMultipart ();
            mp.addBodyPart (mbp1);
            mp.addBodyPart (mbp2);
            msg.setContent (mp);
        }
        else {
            msg.setText (text);
        }
        msg.setHeader ("X-Mailer", mailer);
        msg.setSentDate (new Date ());
        Transport.send (msg);
        System.out.println ("\nMail was sent successfully.");
        if (record != null) {
            Store store = null;
            if (url != null) {
                URLName urln = new URLName (url);
                store = session.getStore (urln);
                store.connect ();
            }
            else {
                if (protocol != null) store = session.getStore (protocol);
                else store = session.getStore ();
                if (host != null || user != null || password != null) store.connect (host, user, password);
                else store.connect ();
            }
            Folder folder = store.getFolder (record);
            if (folder == null) {
                System.err.println ("Can't get record folder.");
                System.exit (1);
            }
            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);
            Message [] msgs = new Message [1];
            msgs [0] = msg;
            folder.appendMessages (msgs);
            System.out.println ("Mail was recorded successfully.");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public static void main (String [] argv) {
    String to, subject = null, from = null, cc = null, bcc = null, url = null;
    String mailhost = null;
    String mailer = "msgsend";
    String file = null;
    String protocol = null, host = null, user = null, password = null;
    String record = null;
    boolean debug = false;
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    int optind;
    for (optind = 0; optind < argv.length; optind ++) {
        if (argv [optind].equals ("-T")) {
            protocol = argv [++ optind];
        }
        else if (argv [optind].equals ("-H")) {
            host = argv [++ optind];
        }
        else if (argv [optind].equals ("-U")) {
            user = argv [++ optind];
        }
        else if (argv [optind].equals ("-P")) {
            password = argv [++ optind];
        }
        else if (argv [optind].equals ("-M")) {
            mailhost = argv [++ optind];
        }
        else if (argv [optind].equals ("-f")) {
            record = argv [++ optind];
        }
        else if (argv [optind].equals ("-a")) {
            file = argv [++ optind];
        }
        else if (argv [optind].equals ("-s")) {
            subject = argv [++ optind];
        }
        else if (argv [optind].equals ("-o")) {
            from = argv [++ optind];
        }
        else if (argv [optind].equals ("-c")) {
            cc = argv [++ optind];
        }
        else if (argv [optind].equals ("-b")) {
            bcc = argv [++ optind];
        }
        else if (argv [optind].equals ("-L")) {
            url = argv [++ optind];
        }
        else if (argv [optind].equals ("-d")) {
            debug = true;
        }
        else if (argv [optind].equals ("--")) {
            optind ++;
            break;
        }
        else if (argv [optind].startsWith ("-")) {
            System.out.println ("Usage: msgsend [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]");
            System.out.println ("\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]");
            System.out.println ("\t[-f record-mailbox] [-M transport-host] [-a attach-file] [-d] [address]");
            System.exit (1);
        }
        else {
            break;
        }
    }
    try {
        if (optind < argv.length) {
            to = argv [optind];
            System.out.println ("To: " + to);
        }
        else {
            System.out.print ("To: ");
            System.out.flush ();
            to = in.readLine ();
        }
        if (subject == null) {
            System.out.print ("Subject: ");
            System.out.flush ();
            subject = in.readLine ();
        }
        else {
            System.out.println ("Subject: " + subject);
        }
        Properties props = System.getProperties ();
        if (mailhost != null) props.put ("mail.smtp.host", mailhost);
        Session session = Session.getInstance (props, null);
        if (debug) session.setDebug (true);
        Message msg = new MimeMessage (session);
        if (from != null) msg.setFrom (new InternetAddress (from));
        else msg.setFrom ();
        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));
        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));
        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));
        msg.setSubject (subject);
        String text = collect (in);
        if (file != null) {
            MimeBodyPart mbp1 = new MimeBodyPart ();
            mbp1.setText (text);
            MimeBodyPart mbp2 = new MimeBodyPart ();
            mbp2.attachFile (file);
            MimeMultipart mp = new MimeMultipart ();
            mp.addBodyPart (mbp1);
            mp.addBodyPart (mbp2);
            msg.setContent (mp);
        }
        else {
            msg.setText (text);
        }
        msg.setHeader ("X-Mailer", mailer);
        msg.setSentDate (new Date ());
        Transport.send (msg);
        System.out.println ("\nMail was sent successfully.");
        if (record != null) {
            Store store = null;
            if (url != null) {
                URLName urln = new URLName (url);
                store = session.getStore (urln);
                store.connect ();
            }
            else {
                if (protocol != null) store = session.getStore (protocol);
                else store = session.getStore ();
                if (host != null || user != null || password != null) store.connect (host, user, password);
                else store.connect ();
            }
            Folder folder = store.getFolder (record);
            if (folder == null) {
                System.err.println ("Can't get record folder.");
                System.exit (1);
            }
            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);
            Message [] msgs = new Message [1];
            msgs [0] = msg;
            folder.appendMessages (msgs);
            System.out.println ("Mail was recorded successfully.");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=88=-----==

public static void postMail (String hostAddr, String recipients [], String subject, String message, String from) throws MessagingException {
    boolean debug = false;
    Properties props = new Properties ();
    props.put ("mail.host", hostAddr);
    Session session = Session.getDefaultInstance (props, null);
    session.setDebug (debug);
    Message msg = new MimeMessage (session);
    InternetAddress addressFrom = new InternetAddress (from);
    msg.setFrom (addressFrom);
    InternetAddress [] addressTo = new InternetAddress [recipients.length];
    for (int i = 0; i < recipients.length; i ++) {
        addressTo [i] = new InternetAddress (recipients [i]);
    }
    msg.setRecipients (Message.RecipientType.TO, addressTo);
    msg.setSubject (subject);
    msg.setContent (message, "text/plain");
    Transport.send (msg);
}


private void displayPart (MailUserData mud, int msgNum, int partNum, ServletOutputStream out, HttpServletResponse res) throws IOException {
    Part part = null;
    try {
        Message msg = mud.getFolder ().getMessage (msgNum);
        Multipart mp = (Multipart) msg.getContent ();
        part = mp.getBodyPart (partNum);
        String sct = part.getContentType ();
        if (sct == null) {
            out.println ("invalid part");
            return;
        }
        ContentType ct = new ContentType (sct);
        res.setContentType (ct.getBaseType ());
        InputStream is = part.getInputStream ();
        int i;
        while ((i = is.read ()) != - 1) out.write (i);
        out.flush ();
        out.close ();
    } catch (MessagingException mex) {
        out.println (mex.toString ());
    }
}


-----Function Pair=89=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=90=-----=1=

public void exportLibrary () {
    if (app.getLibrary ().isEmpty ()) return;
    String path = "";
    fc = new JFileChooser ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    int returnVal = fc.showSaveDialog (framer);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile ();
        if (Filer.fileExists (file)) {
            int answer = JOptionPane.showConfirmDialog (framer, "File Already Exists, Overwrite?", "File Exists", JOptionPane.YES_NO_OPTION);
            if (answer != JOptionPane.YES_OPTION) exportLibrary ();
        }
        path = file.getAbsolutePath ();
        app.exportLibrary (path);
    }
}


public void actionPerformed (ActionEvent e) {
    JFileChooser fc = createFileChooser ();
    ExampleFileFilter filter = new ExampleFileFilter (new String [] {"jpg", "gif"}, getString ("FileChooserDemo.filterdescription"));
    ExampleFileView fileView = new ExampleFileView ();
    fileView.putIcon ("jpg", jpgIcon);
    fileView.putIcon ("gif", gifIcon);
    fc.setFileView (fileView);
    fc.addChoosableFileFilter (filter);
    fc.setFileFilter (filter);
    fc.setAccessory (new FilePreviewer (fc));
    int result = fc.showOpenDialog (getDemoPanel ());
    if (result == JFileChooser.APPROVE_OPTION) {
        loadImage (fc.getSelectedFile ().getPath ());
    }
}


-----Function Pair=91=-----==

protected void windowClosed () {
    if (booktable.isModified ()) {
        int n = JOptionPane.showConfirmDialog (this, "The list \"" + file + "\" has been modified.\nDo you want to save your changes?", "Bookman", JOptionPane.YES_NO_CANCEL_OPTION);
        if (n == JOptionPane.YES_OPTION) {
            try {
                booktable.save (path + file);
            } catch (Exception e) {
            }
        }
        if (n == JOptionPane.YES_OPTION || n == JOptionPane.NO_OPTION) {
            setVisible (false);
            try {
                booktable.save (System.getProperty ("user.home") + File.separator + ".bookman" + File.separator + "bml-backup" + File.separator + file);
                saveSetting ();
                saveLast ();
            } catch (Exception e) {
            }
            System.exit (0);
        }
    }
    else {
        setVisible (false);
        try {
            booktable.save (System.getProperty ("user.home") + File.separator + ".bookman" + File.separator + "bml-backup" + File.separator + file);
            saveSetting ();
            saveLast ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
        System.exit (0);
    }
    setVisible (true);
}


public void run () {
    while (true) {
        if (! pause && player.getVidas () > 0) {
            actualiza ();
            if (juegonuevo == true) {
                nivelActual.checaColisionJugador (player);
                for (int i = 0; i < rayo.length; i ++) {
                    nivelActual.checaColisionRayo (rayo [i]);
                    nivelActual.checaColisionRayoEnemigos (rayo [i], player);
                }
                nivelActual.checaColisionEnemigos (player);
                nivelActual.checaColisionChocolates (player);
                nivelActual.moverEnemigos (player);
                nivelActual.mueveTimmy ();
                nivelActual.mueveWilly ();
                nivelActual.checaColisionRayosWillyJugador (player);
                nivelActual.checaColisionMonedas (player);
                player.movimiento ();
                if (player.isOutDown ()) {
                    nivelActual.resetLevel ();
                    nivelActual.resetLimitesNivel ();
                    for (int i = 0; i < rayo.length; i ++) {
                        rayo [i].desaparecer ();
                    }
                    player.resetPlayer (Constantes.posicion_jugador_x, Constantes.posicion_jugador_y);
                }
                if (player.getPosXIzq () <= Constantes.limite_izquierda) {
                    if (nivelActual.puedoMoverIzquierda ()) {
                        player.mueveJugadorLimite (2);
                        nivelActual.moverNivel (2);
                        nivelActual.scrollEnemigos (2);
                    }
                }
                else if (player.getPosXIzq () >= Constantes.limite_derecha) {
                    if (nivelActual.puedoMoverDerecha ()) {
                        player.mueveJugadorLimite (- 2);
                        nivelActual.moverNivel (- 2);
                        nivelActual.scrollEnemigos (- 2);
                    }
                }
                repaint ();
            }
        }
        try {
            Thread.sleep (20);
        } catch (InterruptedException ex) {
            System.out.println ("Error en " + ex.toString ());
        }
    }
}


-----Function Pair=92=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=93=-----==

public void run () {
    while (true) {
        if (! pause && player.getVidas () > 0) {
            actualiza ();
            if (juegonuevo == true) {
                nivelActual.checaColisionJugador (player);
                for (int i = 0; i < rayo.length; i ++) {
                    nivelActual.checaColisionRayo (rayo [i]);
                    nivelActual.checaColisionRayoEnemigos (rayo [i], player);
                }
                nivelActual.checaColisionEnemigos (player);
                nivelActual.checaColisionChocolates (player);
                nivelActual.moverEnemigos (player);
                nivelActual.mueveTimmy ();
                nivelActual.mueveWilly ();
                nivelActual.checaColisionRayosWillyJugador (player);
                nivelActual.checaColisionMonedas (player);
                player.movimiento ();
                if (player.isOutDown ()) {
                    nivelActual.resetLevel ();
                    nivelActual.resetLimitesNivel ();
                    for (int i = 0; i < rayo.length; i ++) {
                        rayo [i].desaparecer ();
                    }
                    player.resetPlayer (Constantes.posicion_jugador_x, Constantes.posicion_jugador_y);
                }
                if (player.getPosXIzq () <= Constantes.limite_izquierda) {
                    if (nivelActual.puedoMoverIzquierda ()) {
                        player.mueveJugadorLimite (2);
                        nivelActual.moverNivel (2);
                        nivelActual.scrollEnemigos (2);
                    }
                }
                else if (player.getPosXIzq () >= Constantes.limite_derecha) {
                    if (nivelActual.puedoMoverDerecha ()) {
                        player.mueveJugadorLimite (- 2);
                        nivelActual.moverNivel (- 2);
                        nivelActual.scrollEnemigos (- 2);
                    }
                }
                repaint ();
            }
        }
        try {
            Thread.sleep (20);
        } catch (InterruptedException ex) {
            System.out.println ("Error en " + ex.toString ());
        }
    }
}


boolean save () {
    if (CC.P.openFileName.equals ("")) {
        return saveWithName ();
    }
    try {
        if (splitNonStandardMacro_s) {
            ExportGraphic.export (new File (CC.P.openFileName), CC.P, "fcd", 1.0, true, false, extFCJ_s, false);
            CC.P.setModified (false);
        }
        else {
            BufferedWriter output = new BufferedWriter (new OutputStreamWriter (new FileOutputStream (CC.P.openFileName), Globals.encoding));
            output.write ("[FIDOCAD]\n");
            output.write (CC.getCirc (extFCJ_s).toString ());
            output.close ();
            CC.P.setModified (false);
        }
    } catch (IOException fnfex) {
        JOptionPane.showMessageDialog (this, Globals.messages.getString ("Save_error") + fnfex);
        return false;
    }
    return true;
}


-----Function Pair=94=-----==

private void open (final String theFilename) {
    try {
        final FileOutputStream myFileOutputStream;
        final BufferedOutputStream myBufferedOutputStream;
        if (USE_ZIP) {
            myFileOutputStream = new FileOutputStream (theFilename + ".zip");
            final ZipOutputStream myZip = new ZipOutputStream (myFileOutputStream);
            final String [] myFullPathName = theFilename.split ("/");
            final String mySceneName = myFullPathName [myFullPathName.length - 1];
            myZip.putNextEntry (new ZipEntry (mySceneName));
            myBufferedOutputStream = new BufferedOutputStream (myZip);
        }
        else {
            myFileOutputStream = new FileOutputStream (theFilename);
            myBufferedOutputStream = new BufferedOutputStream (myFileOutputStream);
        }
        _myPrintStream = new PrintStream (myBufferedOutputStream);
    } catch (IOException e) {
        System.err.println (e.toString ());
    }
}


private static ZipInputStream createDirectoriesAux (ZipEntry entry, String path, ZipInputStream inStream) throws IOException {
    if (entry == null) return inStream;
    if (entry.isDirectory ()) {
        return createDirectoriesAux (inStream.getNextEntry (), path, inStream);
    }
    else {
        String tmpPath = entry.getName ();
        tmpPath = tmpPath.replace ('/', '\\');
        int endIndex = tmpPath.indexOf ('\\');
        while (endIndex != - 1) {
            String dirToCreate = tmpPath.substring (0, endIndex);
            File f = new File (path + "\\" + dirToCreate);
            f.mkdir ();
            endIndex = tmpPath.indexOf ("\\", endIndex + 1);
            int x = 10;
            x = x + 1;
        }
        return createDirectoriesAux (inStream.getNextEntry (), path, inStream);
    }
}


-----Function Pair=95=-----==

private static void output (String filename, ZipOutputStream os) {
    if (filename != null && ! filename.equals ("")) {
        FileInputStream fis = null;
        try {
            File f = new File (filename);
            if (! f.exists ()) return;
            os.putNextEntry (new ZipEntry (f.getName ()));
            fis = new FileInputStream (filename);
            int t;
            while ((t = fis.read ()) != - 1) {
                os.write (t);
            }
            os.flush ();
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            try {
                if (fis != null) fis.close ();
            } catch (IOException e) {
            }
        }
    }
}


void combine () {
    ImagePlus imp = getImage ();
    if (imp == null) return;
    int [] indexes = list.getSelectedIndexes ();
    if (indexes.length == 1) {
        error ("More than one item must be selected, or none");
        return;
    }
    if (indexes.length == 0) indexes = getAllIndexes ();
    int nPointRois = 0;
    for (int i = 0; i < indexes.length; i ++) {
        Roi roi = (Roi) rois.get (list.getItem (indexes [i]));
        if (roi.getType () == Roi.POINT) nPointRois ++;
        else break;
    }
    if (nPointRois == indexes.length) combinePoints (imp, indexes);
    else combineRois (imp, indexes);
    if (record ()) Recorder.record ("roiManager", "Combine");
}


-----Function Pair=96=-----==

private void zipFileOs (ZipOutputStream os, FileWrapper [] sourceFiles) throws FileNotFoundException, IOException {
    for (FileWrapper file : sourceFiles) {
        if (file.isDirectory ()) {
            zipFileOs (os, file.listFiles ());
        }
        else {
            FileInputStream fis = null;
            try {
                fis = new FileInputStream (file.getAbsolutePath ());
                os.putNextEntry (new ZipEntry (file.getPath ()));
                _iou.copyBytes (fis, os);
            } finally {
                _iou.closeInputStream (fis);
            }
        }
    }
}


private static void copyDirectory (String from, String to) throws IOException {
    if (! FileUtil.isDirectory (from)) {
        throw new IllegalArgumentException ("argument 'from' [" + from + "] is not a valid directory.");
    }
    if (! FileUtil.isDirectory (to)) {
        throw new IllegalArgumentException ("cannot copy [" + from + "] to [" + to + "]");
    }
    File [] sourceMembers = new File (from).listFiles (FileUtil.DIR_ONLY_FILTER);
    if (sourceMembers == null || sourceMembers.length < 1) {
        return;
    }
    for (File sourceMember : sourceMembers) {
        if (sourceMember.isDirectory ()) {
            copyDirectory (sourceMember.getAbsolutePath (), to);
        }
        else {
            copyFile (sourceMember.getAbsolutePath (), to + File.separator + sourceMember.getName ());
        }
    }
}


-----Function Pair=97=-----==

public void readStateBuffer (final byte [] result) {
    int size = 0;
    try {
        double timenextTime = this.inFile.readDouble ();
        size = this.inFile.readInt ();
        int offset = 0;
        int remain = size;
        int read = 0;
        while ((remain > 0) && (read != - 1)) {
            read = this.inFile.read (result, offset, remain);
            remain -= read;
            offset += read;
        }
        if (offset != size) {
            throw new IOException ("READ SIZE did not fit! File corrupted! in second " + timenextTime);
        }
    } catch (IOException e) {
        System.out.println (e.toString ());
    }
}


protected void execute (ActionEvent e) {
    RecommendationProvider provider = new RecommendationProviderProxy ("localhost", RECOM_PORT);
    RecommendationQuery query = new RecommendationQuery ("ProcessId", "ProcessInstanceId");
    query.setProcessInstanceData (historyPI.getAttributes ());
    Iterator it = historyPI.getAuditTrailEntryList ().iterator ();
    while (it.hasNext ()) {
        query.addAuditTrailEntry ((AuditTrailEntry) it.next ());
    }
    RecommendationResult result = null;
    try {
        result = provider.getRecommendation (query);
        for (Recommendation r : result) {
            Message.add (r.toString ());
        }
    } catch (Exception ex) {
        Message.add ("Could not find the recommendation provider.", Message.ERROR);
        ex.printStackTrace ();
    }
}


-----Function Pair=98=-----==

public static byte [] hash (InputStream in, long bytesToRead, String algorithm) throws NoSuchAlgorithmException, IOException {
    if (bytesToRead < 0 && bytesToRead != - 1) throw new IllegalArgumentException ("bytesToRead < 0 && bytesToRead != -1");
    long bytesReadTotal = 0;
    MessageDigest md = MessageDigest.getInstance (algorithm);
    byte [] data = new byte [10240];
    while (true) {
        int len;
        if (bytesToRead < 0) len = data.length;
        else {
            len = (int) Math.min ((long) data.length, bytesToRead - bytesReadTotal);
            if (len < 1) break;
        }
        int bytesRead = in.read (data, 0, len);
        if (bytesRead < 0) {
            if (bytesToRead >= 0) throw new IOException ("Unexpected EndOfStream! bytesToRead==" + bytesToRead + " but only " + bytesReadTotal + " bytes could be read from InputStream!");
            break;
        }
        bytesReadTotal += bytesRead;
        if (bytesRead > 0) md.update (data, 0, bytesRead);
    }
    return md.digest ();
}


void testFileObject (JavaFileObject fo) throws Exception {
    URI uri = fo.toUri ();
    System.err.println ("uri: " + uri);
    URLConnection urlconn = uri.toURL ().openConnection ();
    if (urlconn instanceof JarURLConnection) {
        JarURLConnection jarconn = (JarURLConnection) urlconn;
        File f = new File (jarconn.getJarFile ().getName ());
        foundJars.add (f.getName ());
    }
    try {
        byte [] uriData = read (urlconn.getInputStream ());
        byte [] foData = read (fo.openInputStream ());
        if (! Arrays.equals (uriData, foData)) {
            if (uriData.length != foData.length) throw new Exception ("data size differs: uri data " + uriData.length + " bytes, fo data " + foData.length + " bytes");
            for (int i = 0; i < uriData.length; i ++) {
                if (uriData [i] != foData [i]) throw new Exception ("unexpected data returned at offset " + i + ", uri data " + uriData [i] + ", fo data " + foData [i]);
            }
            throw new AssertionError ("cannot find difference");
        }
    } finally {
        if (urlconn instanceof JarURLConnection) {
            JarURLConnection jarconn = (JarURLConnection) urlconn;
            jarconn.getJarFile ().close ();
        }
    }
}


-----Function Pair=99=-----==

public static boolean compareInputStreams (InputStream in1, InputStream in2, int length) throws IOException {
    boolean identical = true;
    int read = 0;
    while (read < length) {
        int int1 = in1.read ();
        int int2 = in2.read ();
        read ++;
        if (int1 != int2) {
            identical = false;
            break;
        }
    }
    if (read < length) {
        in1.skip (length - read);
        in2.skip (length - read);
    }
    return identical;
}


public static UserZipFile createUser (String username, String password, String filename, boolean isAdmin, boolean isExpired) throws Exception {
    MakeUserZipFileTool maker = new MakeUserZipFileTool ();
    maker.setName (username);
    maker.setPassphrase (password);
    maker.setSaveFile (new File (filename));
    if (isExpired) {
        maker.setValidDays (- 1);
    }
    else {
        maker.setValidDays (1);
    }
    UserZipFile zip = (UserZipFile) maker.makeCertificate ();
    if (isAdmin) {
        zip.setFlags (SecurityUtil.getAdmin ().getFlags ());
    }
    return zip;
}


-----Function Pair=100=-----==

public static void unzipModel (String filename, String tempdir) throws Exception {
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (filename);
        int BUFFER = 2048;
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry;
        while ((entry = zis.getNextEntry ()) != null) {
            int count;
            byte data [] = new byte [BUFFER];
            FileOutputStream fos = new FileOutputStream (tempdir + entry.getName ());
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) dest.write (data, 0, count);
            dest.flush ();
            dest.close ();
        }
        zis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        throw new Exception ("Can not expand model in \"" + tempdir + "\" because:\n" + e.getMessage ());
    }
}


public void zip (String zipName, String dirName) {
    ZipOutputStream out = null;
    FileOutputStream dest = null;
    CheckedOutputStream checksum = null;
    try {
        dest = new FileOutputStream (new File (zipName));
        checksum = new CheckedOutputStream (dest, new Adler32 ());
        out = new ZipOutputStream (new BufferedOutputStream (checksum));
        File dir = new File (dirName);
        String parent = dir.getParent ();
        int length = parent.length ();
        String substring = parent.substring (0, length);
        addToZip (out, dir, substring);
        System.out.println (">>>> checksum: " + checksum.getChecksum ().getValue ());
    } catch (Exception e) {
        e.printStackTrace ();
    } catch (Error err) {
        err.printStackTrace ();
    } finally {
        try {
            out.flush ();
            out.finish ();
            out.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        } catch (Error err) {
            err.printStackTrace ();
        }
    }
}


-----Function Pair=101=-----==

private static String replaceInlineTag (String it, String [] qname) {
    if (! it.endsWith (".i") && ! it.endsWith (".o") && ! it.endsWith (".c") && ! it.endsWith (".e") && ! it.endsWith (".a")) {
        return it;
    }
    int len = it.length ();
    String dest = it.substring (0, len - 2);
    char x = it.charAt (len - 1);
    String href = getRelativeLocation (qname, dest) + "." + x + ".html";
    String simple = dest;
    int i;
    if ((i = simple.lastIndexOf (":")) >= 0) {
        simple = simple.substring (i + 1);
    }
    return "<a href=\"" + href + "\"><code>" + simple + "</code></a>";
}


public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


-----Function Pair=102=-----==

public static void unzipArchive (File zipArchive, File unzipRootFolder) throws IOException {
    ZipFile zipFile = new ZipFile (zipArchive);
    Enumeration < ? extends ZipEntry > entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.isDirectory ()) {
            File dir = new File (unzipRootFolder, entry.getName ());
            if (! dir.mkdirs ()) throw new IllegalStateException ("Could not create directory entry, possibly permission issues.");
        }
        else {
            InputStream in = zipFile.getInputStream (entry);
            File file = new File (unzipRootFolder, entry.getName ());
            File dir = new File (file.getParent ());
            if (dir.exists ()) {
                assert (dir.isDirectory ());
            }
            else {
                dir.mkdirs ();
            }
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            int len;
            byte [] buf = new byte [1024 * 5];
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.close ();
        }
    }
    zipFile.close ();
}


public final void writeUnmodifiedClasses () throws IOException, IllegalStateException {
    passUnmodifiedClasses = false;
    makeOutputJar ();
    for (int i = 0; i < inputs.size (); i ++) {
        Input in = inputs.get (i);
        if (! in.isClass ()) {
            if (in instanceof JarInput) {
                JarInput jin = (JarInput) in;
                ZipEntry entry = jin.getEntry ();
                InputStream s = jin.open ();
                try {
                    ZipEntry newEntry = new ZipEntry (entry.getName ());
                    newEntry.setComment (entry.getComment ());
                    newEntry.setExtra (entry.getExtra ());
                    newEntry.setTime (entry.getTime ());
                    putNextEntry (newEntry);
                    copyStream (s, outputJar);
                    outputJar.closeEntry ();
                } finally {
                    s.close ();
                }
            }
            else {
                throw new Error ("Unknown non-class input: " + in);
            }
        }
        else {
            String name = in.getClassName ();
            if (name == null) {
                BufferedInputStream s = new BufferedInputStream (in.open (), 65536);
                try {
                    Object cl = makeClassFromStream (s);
                    String entryName = toEntryName (getClassName (cl));
                    if (! entryNames.contains (entryName)) {
                        putNextEntry (new ZipEntry (entryName));
                        BufferedOutputStream clOut = new BufferedOutputStream (outputJar);
                        writeClassTo (cl, null, clOut);
                        clOut.flush ();
                        outputJar.closeEntry ();
                    }
                } finally {
                    s.close ();
                }
            }
            else {
                String entryName = toEntryName (name);
                if (! entryNames.contains (entryName)) {
                    BufferedInputStream s = new BufferedInputStream (in.open ());
                    try {
                        putNextEntry (new ZipEntry (entryName));
                        BufferedOutputStream clOut = new BufferedOutputStream (outputJar);
                        copyStream (s, clOut);
                        clOut.flush ();
                        outputJar.closeEntry ();
                    } finally {
                        s.close ();
                    }
                }
            }
        }
    }
}


-----Function Pair=103=-----==

public static void unzipModel (String filename, String tempdir) throws EDITSException {
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (filename);
        int BUFFER = 2048;
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry;
        while ((entry = zis.getNextEntry ()) != null) {
            int count;
            byte data [] = new byte [BUFFER];
            FileOutputStream fos = new FileOutputStream (tempdir + entry.getName ());
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) dest.write (data, 0, count);
            dest.flush ();
            dest.close ();
        }
        zis.close ();
    } catch (Exception e) {
        throw new EDITSException ("Can not expand model in \"" + tempdir + "\" because:\n" + e.getMessage ());
    }
}


private static void sendWeeklyMessage () {
    if (! Utils.parseBoolean (OGSserver.getProperty ("mail.weekly.use", "no"))) return;
    if (! new SimpleDateFormat ("EEEE HH:mm", Locale.ROOT).format (new Date ()).equalsIgnoreCase (OGSserver.getProperty ("mail.weekly.time"))) return;
    List < Map < String, Object > > gamesList = new ArrayList < Map < String, Object > > ();
    for (String gameName : getGameNames ()) {
        Galaxy galaxy = Galaxy.loadGame (gameName);
        if (galaxy == null || galaxy.getState () != Galaxy.State.RECRUITING) continue;
        Map < String, Object > gameData = new HashMap < String, Object > ();
        gameData.put ("Galaxy.Name", galaxy.getName ());
        gameData.put ("Galaxy.Info", galaxy.getDescriptionString ());
        gameData.put ("Races.Count", galaxy.getRaces ().size ());
        List < Race > sortedRaces = new ArrayList < Race > (galaxy.getRaces ());
        Collections.sort (sortedRaces);
        List < Map < String, Object > > racesList = new ArrayList < Map < String, Object > > ();
        for (Race race : sortedRaces) {
            Map < String, Object > raceData = new HashMap < String, Object > ();
            raceData.put ("Race.Name", race.getName ());
            racesList.add (raceData);
        }
        gameData.put ("Races", racesList);
        gamesList.add (gameData);
    }
    if (gamesList.isEmpty ()) return;
    Map < String, Object > arguments = new HashMap < String, Object > ();
    arguments.put ("Games.Count", gamesList.size ());
    String subject = MailFactory.getSubject ("weekly", arguments, OGSserver.getMessageParameters ());
    arguments.put ("Games", gamesList);
    arguments.put ("mail.server.url", OGSserver.getProperty ("mail.server.url"));
    arguments.put ("mail.doc.url", OGSserver.getProperty ("mail.doc.url"));
    arguments.put ("mail.server.address", OGSserver.getProperty ("mail.server.address"));
    String text = MailFactory.getMessage ("weekly", arguments, OGSserver.getMessageParameters ());
    MailFactory.sendMessage (OGSserver.getProperty ("mail.weekly.address"), subject, text);
}


-----Function Pair=104=-----==

public static void runCmd (String program, String file) {
    String path = file;
    String cmd = program;
    if (! new File (file).exists ()) {
        String nowSkinName = UIManager.getLookAndFeel ().getName ();
        String colorString = "blue";
        if (nowSkinName.equals ("HiFi") || nowSkinName.equals ("Noire")) {
            colorString = "yellow";
        }
        JOptionPane.showMessageDialog (ComicDownGUI.mainFrame, "<html><font color=" + colorString + ">" + file + "</font>" + "不存在，無法開啟</html>", "提醒訊息", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    String [] fileList = new File (file).list ();
    System.out.println (file);
    String firstZipFileName = "";
    boolean existZipFile = false;
    for (int i = 0; i < fileList.length; i ++) {
        System.out.println ("FILE: " + fileList [i]);
        if (fileList [i].matches ("(?s).*\\.zip")) {
            firstZipFileName = fileList [i];
            existZipFile = true;
            break;
        }
    }
    if (existZipFile) {
        path = file + Common.getSlash () + firstZipFileName;
    }
    else {
        String [] picList = new File (file + Common.getSlash () + fileList [0]).list ();
        String firstPicFileInFirstVolume = picList [0];
        path = file + Common.getSlash () + fileList [0] + Common.getSlash () + firstPicFileInFirstVolume;
    }
    Common.debugPrintln ("開啟命令：" + cmd + path);
    try {
        String [] cmds = new String [] {cmd, path};
        Runtime.getRuntime ().exec (cmds, null, new File (Common.getNowAbsolutePath ()));
    } catch (IOException ex) {
        Logger.getLogger (ComicDownGUI.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


private static void zipDir (String dir2zip, ZipOutputStream zos, String parentDir) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (filePath, zos, parentDir);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String fileToAdd = f.getAbsolutePath ().substring (parentDir.length () + 1);
            ZipEntry anEntry = new ZipEntry (fileToAdd);
            System.out.println ("adding: " + anEntry.getName ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
    }
}


-----Function Pair=105=-----==

private String createMetadataXml (String path, String fileType, String fileName, String fileSize) {
    String res = path + METADATA_XML;
    WorkflowResultItem wfResultItem = new WorkflowResultItem (WorkflowResultItem.SERVICE_ACTION_IDENTIFICATION, System.currentTimeMillis ());
    wfResultItem.addLogInfo ("createMetadataXml");
    try {
        wfResultItem.addLogInfo ("createMetadataXml" + " path: " + path + ", fileType: " + fileType + ", fileName: " + fileName + ", fileSize: " + fileSize);
        FileOutputStream fos = new FileOutputStream (res);
        OutputFormat of = new OutputFormat ("XML", "UTF-8", true);
        of.setDoctype (null, "http://banks/dtd/KB.DNEP.SIP.dtd");
        XMLSerializer serializer = new XMLSerializer (fos, of);
        ContentHandler hd = serializer.asContentHandler ();
        hd.startDocument ();
        AttributesImpl atts = new AttributesImpl ();
        hd.startElement ("", "", "SIP", atts);
        hd.startElement ("", "", "Asset", atts);
        hd.startElement ("", "", "Epublication", atts);
        hd.startElement ("", "", "OriginalEpublication", atts);
        atts.clear ();
        atts.addAttribute ("", "", "RootName", "CDATA", "OriginalEpublication");
        hd.startElement ("", "", "DirTree", atts);
        atts.clear ();
        atts.addAttribute ("", "", "DirName", "CDATA", "content");
        hd.startElement ("", "", "Directory", atts);
        atts.clear ();
        atts.addAttribute ("", "", "Name", "CDATA", fileName);
        atts.addAttribute ("", "", "Size", "CDATA", fileSize);
        atts.addAttribute ("", "", "Type", "CDATA", fileType);
        hd.startElement ("", "", "File", atts);
        hd.endElement ("", "", "File");
        hd.endElement ("", "", "Directory");
        hd.endElement ("", "", "DirTree");
        hd.endElement ("", "", "OriginalEpublication");
        hd.endElement ("", "", "Epublication");
        hd.endElement ("", "", "Asset");
        atts.clear ();
        hd.startElement ("", "", "MetadataBlock", atts);
        atts.clear ();
        atts.addAttribute ("", "", "supplier", "CDATA", "nameOfPublisher");
        atts.addAttribute ("", "", "starterFileName", "CDATA", "content/" + fileName);
        atts.addAttribute ("", "", "refPlatformNBN", "CDATA", "");
        atts.addAttribute ("", "", "originalNBN", "CDATA", "nbn001");
        atts.addAttribute ("", "", "dateOfCreation", "CDATA", now (DATE_FORMAT));
        atts.addAttribute ("", "", "NBN", "CDATA", "nbn001");
        atts.addAttribute ("", "", "ingestUserID", "CDATA", "PLANETS1");
        atts.addAttribute ("", "", "sourceType", "CDATA", "CD-ROM");
        atts.addAttribute ("", "", "setupFileName", "CDATA", "");
        atts.addAttribute ("", "", "sourceDescription", "CDATA", "Test SIP message");
        atts.addAttribute ("", "", "libraryFunctionName", "CDATA", "Depot");
        hd.startElement ("", "", "Metadata", atts);
        hd.endElement ("", "", "Metadata");
        hd.endElement ("", "", "MetadataBlock");
        hd.endElement ("", "", "SIP");
        hd.endDocument ();
        fos.close ();
    } catch (Exception e) {
        wfResultItem.addLogInfo ("StorageBackingBean createMetadataXml() error: " + e.getMessage ());
        res = null;
    }
    return res;
}


public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegionScoreTexts [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
            int currentStart = sortedRegionScoreTexts [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegionScoreTexts.length; i ++) {
            int diff = sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    fileType = fileType + USeqUtilities.FLOAT + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedRegionScoreTexts [0].start);
        int bp = sortedRegionScoreTexts [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                workingDOS.writeFloat (sortedRegionScoreTexts [0].score);
                workingDOS.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    workingDOS.writeFloat (sortedRegionScoreTexts [i].score);
                    workingDOS.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


-----Function Pair=106=-----==

private List < String > findFilesInDir (Pattern regex, boolean matchOnlyFileName, File dir) {
    List < String > results = new ArrayList < String > ();
    for (String subFile : dir.list ()) {
        File sub_file = new File (subFile);
        String relativePath = sub_file.getAbsolutePath ().substring (file.getAbsolutePath ().length (), sub_file.getAbsolutePath ().length ());
        if (sub_file.isDirectory ()) {
            results.addAll (findFilesInDir (regex, matchOnlyFileName, sub_file));
        }
        else if (matchOnlyFileName && regex.matcher (sub_file.getName ()).find ()) {
            results.add (relativePath);
        }
        else if (regex.matcher (relativePath).find ()) {
            results.add (relativePath);
        }
    }
    return results;
}


private void addParameters (ZipOutputStream zos, NucleiMgr nucleiMgr) throws IOException {
    ZipNuclei zn = nucleiMgr.getZipNuclei ();
    String ename = nucleiMgr.getParameterEntry ();
    zos.putNextEntry (new ZipEntry (ename));
    Vector parameterFileInfo = nucleiMgr.getParameterFileInfo ();
    String s = null;
    if (parameterFileInfo != null) {
        for (int i = 0; i < parameterFileInfo.size (); i ++) {
            s = (String) parameterFileInfo.elementAt (i);
            s += "\n";
            byte [] b = s.getBytes ();
            zos.write (b, 0, b.length);
        }
    }
    zos.closeEntry ();
}


-----Function Pair=107=-----==

public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositionScores [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositionScores.length; i ++) {
            int currentStart = sortedPositionScores [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT + USeqUtilities.FLOAT;
    else fileType = USeqUtilities.INT + USeqUtilities.FLOAT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedPositionScores [0].position);
        workingDOS.writeFloat (sortedPositionScores [0].score);
        if (useShort) {
            int bp = sortedPositionScores [0].position;
            for (int i = 1; i < sortedPositionScores.length; i ++) {
                int currentStart = sortedPositionScores [i].position;
                int diff = currentStart - bp - 32768;
                workingDOS.writeShort ((short) (diff));
                workingDOS.writeFloat (sortedPositionScores [i].score);
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositionScores [0].position;
            for (int i = 1; i < sortedPositionScores.length; i ++) {
                int currentStart = sortedPositionScores [i].position;
                int diff = currentStart - bp;
                workingDOS.writeInt (diff);
                workingDOS.writeFloat (sortedPositionScores [i].score);
                bp = currentStart;
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


public void save (boolean overwrite, File file) throws IOException, Exception {
    if (expander == null) {
        java.util.Hashtable templates = TemplateReader.readFile (ARGO_TEE);
        expander = new OCLExpander (templates);
    }
    preSave ();
    ZipOutputStream stream = new ZipOutputStream (new FileOutputStream (file));
    BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (stream, "UTF-8"));
    ZipEntry zipEntry = new ZipEntry (getBaseName () + UNCOMPRESSED_FILE_EXT);
    stream.putNextEntry (zipEntry);
    expander.expand (writer, this, "", "");
    writer.flush ();
    stream.closeEntry ();
    String path = file.getParent ();
    Argo.log.info ("Dir ==" + path);
    int size = _members.size ();
    try {
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (! (p.getType ().equalsIgnoreCase ("xmi"))) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
                writer.flush ();
                stream.closeEntry ();
            }
        }
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (p.getType ().equalsIgnoreCase ("xmi")) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
            }
        }
    } catch (IOException e) {
        System.out.println ("hat nicht geklappt: " + e);
        e.printStackTrace ();
    }
    writer.close ();
    postSave ();
    try {
        setFile (file);
    } catch (PropertyVetoException ex) {
    }
}


-----Function Pair=108=-----==

public static String [] executeCommandLine (String [] command) {
    ArrayList al = new ArrayList ();
    try {
        Runtime rt = Runtime.getRuntime ();
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
    } catch (Exception e) {
        System.out.println ("Problem executingCommandLine(), command -> " + Misc.stringArrayToString (command, " "));
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


protected BaseModel (String componentName, InputStream in) throws IOException, InvalidFormatException {
    if (componentName == null) throw new IllegalArgumentException ("componentName must not be null!");
    if (in == null) throw new IllegalArgumentException ("in must not be null!");
    this.componentName = componentName;
    Map < String, Object > artifactMap = new HashMap < String, Object > ();
    createArtifactSerializers (artifactSerializers);
    final ZipInputStream zip = new ZipInputStream (in);
    ZipEntry entry;
    while ((entry = zip.getNextEntry ()) != null) {
        String extension = getEntryExtension (entry.getName ());
        ArtifactSerializer factory = artifactSerializers.get (extension);
        if (factory == null) {
            throw new InvalidFormatException ("Unkown artifact format: " + extension);
        }
        artifactMap.put (entry.getName (), factory.create (zip));
        zip.closeEntry ();
    }
    this.artifactMap = Collections.unmodifiableMap (artifactMap);
    validateArtifactMap ();
}


-----Function Pair=109=-----==

private String addFileToZipContent (String path, InputStream inputStream) {
    String res = null;
    WorkflowResultItem wfResultItem = new WorkflowResultItem (WorkflowResultItem.SERVICE_ACTION_IDENTIFICATION, System.currentTimeMillis ());
    wfResultItem.addLogInfo ("addFileToZipContent");
    try {
        String fileName = path + URI_SEPARATOR + processingDigo.getPermanentUri ().toString ().substring (processingDigo.getPermanentUri ().toString ().lastIndexOf (URI_SEPARATOR) + 1);
        wfResultItem.addLogInfo ("path: " + path + "fileName: " + fileName);
        File f = new File (fileName);
        OutputStream out = new FileOutputStream (f);
        byte buf [] = new byte [1024];
        int len;
        while ((len = inputStream.read (buf)) > 0) out.write (buf, 0, len);
        out.close ();
        inputStream.close ();
        res = fileName;
        wfResultItem.addLogInfo ("\nFile is created........ res: " + res);
    } catch (Exception e) {
        wfResultItem.addLogInfo ("Content file creation error: " + e.getMessage ());
    }
    return res;
}


protected static void zipDir (File zipDir, ZipOutputStream zos) throws IOException {
    String [] dirList = zipDir.list ();
    byte [] readBuffer = new byte [2156];
    for (String file : dirList) {
        File f = new File (zipDir, file);
        if (f.isDirectory ()) {
            ZipEntry anEntry = new ZipEntry (f.getName () + '/');
            zos.putNextEntry (anEntry);
            zipDir (f, zos);
        }
        else {
            ZipEntry anEntry = new ZipEntry (f.getName ());
            zos.putNextEntry (anEntry);
            FileInputStream fis = new FileInputStream (f);
            int bytesIn;
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    }
}


-----Function Pair=110=-----=1=

public FileIndex (File file) throws IOException {
    this.file = file;
    if (file.isFile () && ! file.getName ().endsWith (".zip")) {
        System.out.println ("Converting " + file + " to zip format");
        InputStream in;
        String newFile = file.getAbsolutePath ();
        if (file.getName ().endsWith ("tar.gz")) {
            in = new GZIPInputStream (new FileInputStream (file));
            newFile = newFile.substring (0, newFile.length () - ".tar.gz".length ()) + ".zip";
        }
        else if (file.getName ().endsWith (".tar")) {
            in = new FileInputStream (file);
            newFile = newFile.substring (0, newFile.length () - ".tar".length ()) + ".zip";
        }
        else {
            throw new IOException ("file is not in a compatible tar or tar.gz format");
        }
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (newFile));
        out.setLevel (Deflater.BEST_COMPRESSION);
        TarInputStream tarStream = new TarInputStream (in);
        tarStream.setBufferDebug (false);
        tarStream.setDebug (false);
        TarEntryEnumerator tarEnum = new TarEntryEnumerator (tarStream);
        byte [] buf = new byte [512];
        while (tarEnum.hasMoreElements ()) {
            TarEntry entry = (TarEntry) tarEnum.nextElement ();
            if (! entry.getName ().endsWith (".gif") && ! entry.getName ().endsWith (".png") && ! entry.getName ().endsWith (".html")) {
                ZipEntry zipEntry = new ZipEntry (entry.getName ());
                int len;
                out.putNextEntry (zipEntry);
                while ((len = tarStream.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
            }
        }
        in.close ();
        out.flush ();
        out.close ();
        System.out.println ("Done Converting " + file + " to zip format new file is at " + newFile);
        this.file = new File (newFile);
        this.zipfile = new ZipFile (newFile);
    }
    else if (file.isArchive () && file.getName ().endsWith (".zip")) {
        this.zipfile = new ZipFile (file);
    }
}


private void backupDir (ZipOutputStream zos, String root, File dir) throws IOException {
    if (! root.equals (dir.toString ())) {
        String relDir = dir.toString ().substring (root.length () + 1) + '/';
        zos.putNextEntry (new ZipEntry (relDir));
    }
    File [] children = dir.listFiles ();
    if (children == null) return;
    for (int ii = 0; ii < children.length; ++ ii) {
        File child = children [ii];
        log (child.toString ());
        if (child.isDirectory ()) backupDir (zos, root, child);
        else {
            String relFile = child.toString ().substring (root.length () + 1);
            ZipEntry ze = new ZipEntry (relFile);
            ze.setSize (child.length ());
            ze.setTime (child.lastModified ());
            zos.putNextEntry (ze);
            FileInputStream fis = new FileInputStream (child);
            int len;
            while ((len = fis.read (fileBuffer)) != - 1) {
                crc32.update (fileBuffer, 0, len);
                zos.write (fileBuffer, 0, len);
            }
            fis.close ();
            ze.setCrc (crc32.getValue ());
        }
    }
}


-----Function Pair=111=-----==

public static String [] fetchFileURLStrings (String s, String extension) {
    String [] names = COMMA.split (s);
    ArrayList < String > toReturn = new ArrayList < String > ();
    for (int i = 0; i < names.length; i ++) {
        if (names [i].startsWith ("http")) {
            if (extension != null && names [i].endsWith (extension)) toReturn.add (names [i]);
            else toReturn.add (names [i]);
        }
        else {
            File [] f = null;
            if (extension != null) f = fetchFilesRecursively (new File (names [i]), extension);
            else f = fetchFilesRecursively (new File (names [i]));
            if (f != null) {
                for (int x = 0; x < f.length; x ++) toReturn.add (f [x].toString ());
            }
        }
    }
    int num = toReturn.size ();
    if (num == 0) return null;
    names = new String [num];
    toReturn.toArray (names);
    return names;
}


private int zip (ZipOutputStream zos, String fname) throws IOException {
    int ret;
    File file = getFile (fname);
    if (file.isDirectory ()) {
        String [] files = file.list ();
        for (String f : files) {
            if ((ret = zip (zos, fname + "/" + f)) != 0) return ret;
        }
        return 0;
    }
    ZipEntry entry = new ZipEntry (fname);
    entry.setTime (file.lastModified ());
    zos.putNextEntry (entry);
    FileInputStream fis = new FileInputStream (file);
    Util.copyStream (fis, zos);
    fis.close ();
    zos.closeEntry ();
    return 0;
}


-----Function Pair=112=-----==

private boolean copy (File src, File dst) {
    try {
        InputStream in = new FileInputStream (src);
        OutputStream out = new FileOutputStream (dst);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
        return true;
    } catch (IOException ioe) {
        return false;
    }
}


public static synchronized void copyFile (File source, File destination) throws BlogunityException {
    try {
        InputStream in = new FileInputStream (source);
        OutputStream out = new FileOutputStream (destination);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
    } catch (Throwable t) {
        throw new BlogunityException (I18NStatusFactory.createUnknown (t));
    }
}


-----Function Pair=113=-----==

public static int [] [] loadTableOfInts (File file) {
    int [] [] columnsRows = null;
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line = in.readLine ();
        if (line == null) return null;
        String [] tokens = line.split ("\\t");
        int numColumns = tokens.length;
        int numRows = (int) IO.countNumberOfLines (file);
        columnsRows = new int [numColumns] [numRows];
        int y = 0;
        for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        y ++;
        for (; y < numRows; y ++) {
            line = in.readLine ();
            tokens = line.split ("\\t");
            for (int x = 0; x < numColumns; x ++) columnsRows [x] [y] = Integer.parseInt (tokens [x]);
        }
        in.close ();
    } catch (Exception e) {
        System.out.println ("Problem loading table");
        e.printStackTrace ();
    }
    return columnsRows;
}


private static void dumpToZipStream (Iterator < Lead > aCardioIterator, String date, ZipOutputStream zos) throws IOException {
    int j = 0;
    while (aCardioIterator.hasNext ()) {
        Lead l = aCardioIterator.next ();
        ZipEntry ze = new ZipEntry (date + j + "_" + (j % 2 == 0 ? "1" : "2"));
        j ++;
        zos.putNextEntry (ze);
        short [] data = l.getData ();
        String content = "";
        for (short value : data) {
            content += value + "\n";
        }
        zos.write (content.getBytes ());
    }
}


-----Function Pair=114=-----==

private void readNetworkNodes (FeatureSource source) {
    try {
        FeatureCollection fColl = source.getFeatures ();
        System.out.println ("Feature collection type: " + fColl.getSchema ().getName ());
        System.out.println ("Num features: " + fColl.size ());
        FeatureIterator fIter = fColl.features ();
        int c = 0;
        while (fIter.hasNext ()) {
            c ++;
            if (c % 10000 == 0) {
                System.out.println ("loaded " + c + " features");
            }
            SimpleFeature f = (SimpleFeature) fIter.next ();
            BNode node = featureIO_.readNode (f);
            if (node != null) engine_.getBaseNet ().addNode (node);
        }
        System.out.println ("loaded " + c + " features total");
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


public Document parseToDom (Part part) {
    _log.debug ("parseToDom", new Object [] {part.getName ()});
    ZipFile officeFile = getOfficeFile ();
    ZipEntry documentXML = officeFile.getEntry (part.getName ());
    if (documentXML == null) {
        return null;
    }
    try {
        InputStream documentXMLIS = officeFile.getInputStream (documentXML);
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
        Document doc = dbf.newDocumentBuilder ().parse (documentXMLIS);
        return doc;
    } catch (Exception e) {
        throw new VRuntimeException (e);
    }
}


-----Function Pair=115=-----==

public void zip (String zipFile) {
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
        out.putNextEntry (new ZipEntry ((new File (currentFile)).getName ()));
        String newline = System.getProperty ("line.separator");
        Element map = getDocument ().getDefaultRootElement ();
        for (int i = 0; i < map.getElementCount (); i ++) {
            Element line = map.getElement (i);
            int start = line.getStartOffset ();
            byte [] buf = (getText (start, line.getEndOffset () - start - 1) + newline).getBytes ();
            out.write (buf, 0, buf.length);
        }
        out.closeEntry ();
        out.close ();
    } catch (IOException ioe) {
        showError ("Error has occured while ziping");
    } catch (BadLocationException ble) {
        showError ("Error has occured while ziping");
    }
}


protected Collection < Community > getExplicitUserCommunities (GroupwareUser user, String role) {
    Collection < Community > communities = new ArrayList < Community > ();
    CommunityPrivilege prototype = new CommunityPrivilege ();
    prototype.setUserId (user.getId ());
    prototype.setRole (role);
    Collection < CommunityPrivilege > privileges = privilegePersister.searchByPrototype (prototype);
    for (CommunityPrivilege privilege : privileges) {
        try {
            Community community = communityPersister.getCommunityById (privilege.getCommunityId ());
            communities.add (community);
        } catch (CommunityNotFoundException e) {
            String message = "Privilege found for user " + privilege.getUserId () + " with role " + privilege.getRole () + " in community " + privilege.getCommunityId () + " but community was not found";
            log.debug (message);
        }
    }
    return communities;
}


-----Function Pair=116=-----==

public void open (String path) {
    beginOperation ();
    getDocument ().removeUndoableEditListener (this);
    getDocument ().removeDocumentListener (this);
    clean ();
    discard ();
    InputStream is;
    StringBuffer buffer = new StringBuffer ();
    try {
        File toLoad = new File (path);
        if (! toLoad.canWrite ()) setEditable (false);
        else if (! isEditable ()) setEditable (true);
        is = new FileInputStream (toLoad);
        InputStreamReader in = new InputStreamReader (is);
        char [] buf = new char [BUFFER_SIZE];
        int len;
        boolean lastWasCR = false;
        while ((len = in.read (buf, 0, buf.length)) != - 1) {
            int lastLine = 0;
            for (int i = 0; i < len; i ++) {
                switch (buf [i]) {
                    case '\r' :
                        if (lastWasCR) {
                        }
                        else lastWasCR = true;
                        buffer.append (buf, lastLine, i - lastLine);
                        buffer.append ('\n');
                        lastLine = i + 1;
                        break;
                    case '\n' :
                        if (lastWasCR) {
                            lastWasCR = false;
                            lastLine = i + 1;
                        }
                        else {
                            buffer.append (buf, lastLine, i - lastLine);
                            buffer.append ('\n');
                            lastLine = i + 1;
                        }
                        break;
                    default :
                        if (lastWasCR) {
                            lastWasCR = false;
                        }
                        break;
                }
            }
            buffer.append (buf, lastLine, len - lastLine);
        }
        in.close ();
        if (buffer.length () != 0 && buffer.charAt (buffer.length () - 1) == '\n') buffer.setLength (buffer.length () - 1);
        getDocument ().remove (0, getLength ());
        getDocument ().insertString (0, buffer.toString (), null);
        currentFile = path;
        setCaretPosition (0);
        newText = false;
        getDocument ().addUndoableEditListener (this);
        getDocument ().addDocumentListener (this);
    } catch (BadLocationException bl) {
        FuLog.warning (bl);
    } catch (FileNotFoundException fnf) {
        showError (path + " not found !");
    } catch (IOException io) {
        showError (io.toString ());
    }
    endOperation ();
}


public void zip (final String sourceDirectory, OutputStream dest) throws FileNotFoundException, IOException {
    logger.doLog (AppLogger.DEBUG, "Starting compression...", null);
    this.sourceDirectory = sourceDirectory;
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    fileList = new ArrayList < String > ();
    fileListPopulated = false;
    boolean processingComplete = false;
    Thread thread = new Thread (this);
    thread.start ();
    Object [] files = null;
    while (! processingComplete) {
        synchronized (fileList) {
            if (fileList.size () == 0) {
                logger.doLog (AppLogger.DEBUG, "Sleeping for 1 second", null);
                try {
                    Thread.sleep (1000);
                } catch (InterruptedException e) {
                    logger.doLog (AppLogger.DEBUG, "Thread interrupted. Resuming.", null);
                }
            }
            else {
                processingComplete = fileListPopulated;
                files = fileList.toArray ();
                fileList.clear ();
            }
        }
        if (files != null && files.length > 0) {
            logger.doLog (AppLogger.DEBUG, "Compressing " + files.length + " files (and empty directories)", null);
            byte [] tmpBuf = new byte [BUFFER];
            for (int i = 0; i < files.length; i ++) {
                String fullFileName = (String) files [i];
                ZipEntry entry = new ZipEntry (fullFileName.substring (new File (sourceDirectory).getAbsolutePath ().length ()));
                out.putNextEntry (entry);
                if (new File (fullFileName).isFile ()) {
                    jobListener.updateSubStatus ("Compressing " + fullFileName + "...");
                    FileInputStream in = new FileInputStream (fullFileName);
                    int len;
                    try {
                        while ((len = in.read (tmpBuf)) > 0) {
                            out.write (tmpBuf, 0, len);
                        }
                    } catch (IOException e) {
                        logger.doLog (AppLogger.WARN, "Exception while zipping " + fullFileName, e);
                        if ("The process cannot access the file because another process has locked a portion of the file".equals (e.getMessage ())) {
                            logger.doLog (AppLogger.INFO, "Another process has locked this file for modification. If the file is updated while it is being compressed, the entire archive may be corrupt." + "\nContinuing.", null);
                        }
                    }
                    in.close ();
                }
                out.closeEntry ();
            }
            out.flush ();
            files = null;
        }
    }
    out.close ();
    logger.doLog (AppLogger.DEBUG, "Compression complete.", null);
    jobListener.updateMainStatus ("Compression complete.");
}


-----Function Pair=117=-----==

public static boolean fileExists (File zip, String fileName) throws ZipException, IOException {
    String filename = fileName;
    if (! zip.exists ()) {
        return false;
    }
    while (filename.charAt (0) == '/') {
        filename = filename.substring (1);
    }
    if (filename.contains ("\\")) {
        filename = filename.replace ("\\", "/");
    }
    ZipFile zipFile = new ZipFile (zip);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.getName ().equalsIgnoreCase (filename)) {
            return true;
        }
    }
    return false;
}


public void addFile (File file) throws Exception {
    FileInputStream tFINS = new FileInputStream (file);
    final int bufLength = 1024;
    byte [] buffer = new byte [bufLength];
    int readReturn = 0;
    zOut.putNextEntry (new ZipEntry (file.getName ()));
    do {
        readReturn = tFINS.read (buffer);
        if (readReturn != - 1) {
            zOut.write (buffer, 0, readReturn);
        }
    }
    while (readReturn != - 1);
    zOut.closeEntry ();
    fileCount ++;
}


-----Function Pair=118=-----==

protected void copyResource (File source, File destination) {
    if (! (source.equals ((temRep)))) {
        if (source.isDirectory ()) {
            File directory = destination;
            directory.mkdir ();
            File [] files = source.listFiles ();
            if (files != null) {
                for (int i = 0; i < files.length; i ++) {
                    File f = files [i];
                    destination = new File (directory, f.getName ());
                    copyResource (f, destination);
                }
            }
        }
        else {
            FileOutputStream outStream = null;
            FileInputStream inStream = null;
            if (destination.exists ()) {
                deleteResource (destination);
            }
            try {
                destination.createNewFile ();
                inStream = new FileInputStream (source);
                outStream = new FileOutputStream (destination);
                byte buffer [] = new byte [512 * 1024];
                int nb;
                while ((nb = inStream.read (buffer)) != - 1) {
                    outStream.write (buffer, 0, nb);
                }
            } catch (java.io.FileNotFoundException f) {
            } catch (java.io.IOException e) {
            } finally {
                try {
                    if (inStream != null) inStream.close ();
                } catch (Exception e) {
                }
                try {
                    if (outStream != null) outStream.close ();
                } catch (Exception e) {
                }
            }
        }
    }
}


private void zipProjectDir (File saveFile, File saveDir) {
    ZipOutputStream zos = null;
    BufferedInputStream bis = null;
    try {
        zos = new ZipOutputStream (new FileOutputStream (saveFile));
        List < File > allFile = new ArrayList < File > ();
        getAllProjectFile (saveDir, allFile);
        for (File file : allFile) {
            ZipEntry entry = new ZipEntry (file.getPath ());
            zos.putNextEntry (entry);
            bis = new BufferedInputStream (new FileInputStream (file));
            int count;
            byte buf [] = new byte [1024];
            while ((count = bis.read (buf, 0, 104)) != EOF) {
                zos.write (buf, 0, count);
            }
            bis.close ();
            zos.closeEntry ();
            file.delete ();
        }
        for (File dir : saveDir.listFiles ()) {
            dir.delete ();
        }
        saveDir.delete ();
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    } finally {
        try {
            if (bis != null) {
                bis.close ();
            }
            if (zos != null) {
                zos.close ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=119=-----==

public Collection < String > getVectorLayers (boolean onlyOneFileAllowed) {
    LinkedList < String > layers = new LinkedList < String > ();
    if (zipFile != null) {
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            ZipEntry ze = (ZipEntry) e.nextElement ();
            String fileName = ze.getName ();
            if (fileIsShp (fileName)) {
                String base = getBase (fileName);
                if (onlyOneFileAllowed) {
                    if (layers.size () > 1) throw new IllegalArgumentException ("Only one shapefile per zip is allowed. " + layers.size () + " shapefiles found.");
                    if (base.equals (getBase (file.getName ()))) {
                        layers.add (base);
                    }
                    else throw new IllegalArgumentException ("Shapefile name (" + base + ") is not equal to ZIP file name (" + file.getName () + ").");
                }
                else {
                    layers.add (base);
                }
            }
        }
    }
    return layers;
}


public static void unzipTest () {
    try {
        FileInputStream fis = new FileInputStream ("ispDownLoad_7jnD7a_20110313225359_return_content.zip");
        ZipInputStream zis = new ZipInputStream (fis);
        ZipEntry ze;
        while ((ze = zis.getNextEntry ()) != null) {
            System.out.println (ze);
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            int length;
            byte [] bytes = new byte [512];
            while ((length = zis.read (bytes)) != - 1) {
                baos.write (bytes, 0, length);
            }
            baos.close ();
            System.out.println (baos.toString ());
        }
        zis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=120=-----==

private ScheduleItem [] filterItems (ScheduleItem [] itemsArray, boolean past) {
    Vector < ScheduleItem > filteredList = new Vector < ScheduleItem > ();
    Date now = new Date ();
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        if (past) {
            if (item.getStop ().getTime () < now.getTime ()) filteredList.add (item);
        }
        else {
            if (item.getStop ().getTime () >= now.getTime ()) filteredList.add (item);
        }
    }
    ScheduleItem [] items = (ScheduleItem []) filteredList.toArray (new ScheduleItem [0]);
    Arrays.sort (items);
    return items;
}


private static List < String > getOutputFilesList (String username, String workflow) {
    String prefix = PropertyLoader.getPrefixDir ();
    File outputListFile = new File (prefix + "/users/" + username + "/" + workflow + "_files/outputFilesRemotePath.dat");
    List < String > files = new ArrayList < String > ();
    try {
        BufferedReader br = new BufferedReader (new FileReader (outputListFile));
        String line = null;
        while ((line = br.readLine ()) != null) {
            line = line.trim ();
            if (! (line.equals (""))) {
                files.add (line);
            }
        }
    } catch (Exception ex) {
        return null;
    }
    if (files.size () == 0) return null;
    return files;
}


-----Function Pair=121=-----==

private void zipTempDirectoryToStream (OutputStream out) throws IOException {
    byte b [] = new byte [512];
    ZipOutputStream zout = new ZipOutputStream (out);
    File f = new File (Config.CONTEXT.getRealPath (backupTempFilePath));
    String [] s = f.list ();
    for (int i = 0; i < s.length; i ++) {
        InputStream in = new BufferedInputStream (new FileInputStream (f = new File (Config.CONTEXT.getRealPath (backupTempFilePath + "/" + s [i]))));
        ZipEntry e = new ZipEntry (s [i].replace (File.separatorChar, '/'));
        zout.putNextEntry (e);
        int len = 0;
        while ((len = in.read (b)) != - 1) {
            zout.write (b, 0, len);
        }
        zout.closeEntry ();
        in.close ();
    }
    zout.close ();
    out.close ();
}


private synchronized int extractFile (String entryname, File dest) {
    int buffer = 2048;
    byte [] data = new byte [buffer];
    int count;
    int totalBytesRead = 0;
    try {
        FileOutputStream fos = new FileOutputStream (dest);
        BufferedOutputStream destination = new BufferedOutputStream (fos);
        BufferedInputStream source = new BufferedInputStream (resFile.getInputStream (new ZipEntry (entryname)));
        while ((count = source.read (data, 0, buffer)) != - 1) {
            destination.write (data, 0, count);
            totalBytesRead += count;
        }
        destination.close ();
        source.close ();
        fos.close ();
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
    return totalBytesRead;
}


-----Function Pair=122=-----==

private Manifest parseManifest (final ContentPackage cp, InputStream in) throws IOException, BadParseException {
    try {
        ParserFactory pf = factory.getManifestParserFactory ();
        pf.addInterception (new ParseStateInterceptor () {
            public void intercept (ParseState in) {
                in.getObjectStack ().push (new ManifestImpl (cp, factory));
            }
        }
        );
        ParseState parser = pf.getParser ();
        XMLReader reader = parser.getReader ();
        reader.parse (new InputSource (in));
        Object out = parser.getObjectStack ().pop ();
        if (! (out instanceof Manifest)) throw new BadParseException ("top level was not manifest");
        return (Manifest) out;
    } catch (BadConfigException x) {
        throw new AssertionError ("bad rules file: badly built imscp jar");
    } catch (SAXException x) {
        throw new BadParseException ("Could not parse manifest", x);
    }
}


public static < T > String join (String delimiter, UnaryFunction < String, T > formatter, Collection < T > array) {
    if (array.isEmpty ()) {
        return "<empty>";
    }
    int i = 0;
    StringBuffer res = new StringBuffer ();
    for (T item : array) {
        if (formatter != null) {
            res.append (formatter.eval (item));
        }
        else {
            res.append (item);
        }
        i ++;
        if (i < array.size ()) {
            res.append (delimiter);
        }
    }
    return res.toString ();
}


-----Function Pair=123=-----==

private static void createDirectory (String directory, String subDirectory) {
    String dir [];
    File fl = new File (directory);
    try {
        if (subDirectory == "" && fl.exists () != true) fl.mkdir ();
        else if (subDirectory != "") {
            dir = subDirectory.replace ('\\', '/').split ("/");
            for (int i = 0; i < dir.length; i ++) {
                File subFile = new File (directory + File.separator + dir [i]);
                if (subFile.exists () == false) subFile.mkdir ();
                directory += File.separator + dir [i];
            }
        }
    } catch (Exception ex) {
        System.out.println (ex.getMessage ());
    }
}


public static void createZipFile (File zipFile, List < File > files, String rootPath, IProgressMonitor monitor) throws FileNotFoundException, IOException {
    if (zipFile.exists ()) {
        zipFile.delete ();
    }
    if (rootPath == null) {
        rootPath = "";
    }
    else if (! rootPath.endsWith ("\\") || ! rootPath.endsWith ("/")) {
        rootPath += "/";
    }
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
    for (File file : files) {
        try {
            addZipEntry (zipOut, rootPath, file);
            if (monitor != null) {
                monitor.worked (1);
            }
        } catch (Exception e) {
            StatusHandler.log (e, "Could not add " + file.getName () + " to zip");
        }
    }
    zipOut.close ();
}


-----Function Pair=124=-----==

public static void unziptoDir (final String zipFullPath, final String destPath) throws IOException {
    String out = destPath;
    if (! out.endsWith (FILE_SEP)) {
        out = destPath.concat (FILE_SEP);
    }
    final FileInputStream fis = new FileInputStream (zipFullPath);
    final ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    BufferedOutputStream dest = null;
    ZipEntry entry = null;
    while ((entry = zis.getNextEntry ()) != null) {
        int count;
        final byte [] data = new byte [NB_BITE];
        final FileOutputStream fos = new FileOutputStream (out.concat (entry.getName ()));
        dest = new BufferedOutputStream (fos, NB_BITE);
        while ((count = zis.read (data, 0, NB_BITE)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
    zis.close ();
}


void openZip (String path) {
    ZipInputStream in = null;
    ByteArrayOutputStream out;
    int nRois = 0;
    try {
        in = new ZipInputStream (new FileInputStream (path));
        byte [] buf = new byte [1024];
        int len;
        ZipEntry entry = in.getNextEntry ();
        while (entry != null) {
            String name = entry.getName ();
            if (name.endsWith (".roi")) {
                out = new ByteArrayOutputStream ();
                while ((len = in.read (buf)) > 0) out.write (buf, 0, len);
                out.close ();
                byte [] bytes = out.toByteArray ();
                RoiDecoder rd = new RoiDecoder (bytes, name);
                Roi roi = rd.getRoi ();
                if (roi != null) {
                    name = name.substring (0, name.length () - 4);
                    name = getUniqueName (name);
                    list.add (name);
                    rois.put (name, roi);
                    nRois ++;
                }
            }
            entry = in.getNextEntry ();
        }
        in.close ();
    } catch (IOException e) {
        error (e.toString ());
    }
    if (nRois == 0) error ("This ZIP archive does not appear to contain \".roi\" files");
    updateShowAll ();
}


-----Function Pair=125=-----==

public static void main (String [] args) throws Exception {
    XSSFWorkbook wb = new XSSFWorkbook ();
    XSSFSheet sheet = wb.createSheet ("Big Grid");
    Map < String, XSSFCellStyle > styles = createStyles (wb);
    String sheetRef = sheet.getPackagePart ().getPartName ().getName ();
    FileOutputStream os = new FileOutputStream ("template.xlsx");
    wb.write (os);
    os.close ();
    File tmp = File.createTempFile ("sheet", ".xml");
    Writer fw = new FileWriter (tmp);
    generate (fw, styles);
    fw.close ();
    FileOutputStream out = new FileOutputStream ("big-grid.xlsx");
    substitute (new File ("template.xlsx"), tmp, sheetRef.substring (1), out);
    out.close ();
}


protected void closeExportFile (Element exportNode) throws IOException, SAXException {
    getSaxWriter ().writeClose (exportNode);
    CmsXmlSaxWriter xmlSaxWriter = (CmsXmlSaxWriter) getSaxWriter ().getContentHandler ();
    xmlSaxWriter.endDocument ();
    ZipEntry entry = new ZipEntry (CmsImportExportManager.EXPORT_MANIFEST);
    getExportZipStream ().putNextEntry (entry);
    StringBuffer result = ((StringWriter) xmlSaxWriter.getWriter ()).getBuffer ();
    int steps = result.length () / SUB_LENGTH;
    int rest = result.length () % SUB_LENGTH;
    int pos = 0;
    for (int i = 0; i < steps; i ++) {
        String sub = result.substring (pos, pos + SUB_LENGTH);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
        pos += SUB_LENGTH;
    }
    if (rest > 0) {
        String sub = result.substring (pos, pos + rest);
        getExportZipStream ().write (sub.getBytes (OpenCms.getSystemInfo ().getDefaultEncoding ()));
    }
    getExportZipStream ().closeEntry ();
    getExportZipStream ().close ();
}


-----Function Pair=126=-----==

public static void unzip (File zipFile, File destDir) throws IOException {
    BufferedOutputStream dest = null;
    FileInputStream fis = new FileInputStream (zipFile);
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        if (log.isDebugEnabled ()) {
            log.debug ("Extracting: " + entry);
        }
        int count;
        byte [] data = new byte [BUFFER_SIZE];
        FileOutputStream fos = new FileOutputStream (destDir.getAbsolutePath () + "/" + entry.getName ());
        dest = new BufferedOutputStream (fos, BUFFER_SIZE);
        while ((count = zis.read (data, 0, BUFFER_SIZE)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
    zis.close ();
}


private void packageFile (ZipOutputStream zos, String filename) throws IOException {
    String filepath = environment.toProjectFile (projectName, filename);
    File file = new File (filepath);
    byte [] data = new byte [(int) file.length ()];
    FileInputStream fis = new FileInputStream (file);
    BufferedInputStream bis = new BufferedInputStream (fis);
    int bytesRead = 0;
    while (bytesRead < data.length) {
        int n = bis.read (data, bytesRead, data.length - bytesRead);
        bytesRead += n;
    }
    zos.putNextEntry (new ZipEntry (filename));
    zos.write (data, 0, data.length);
    zos.closeEntry ();
}


-----Function Pair=127=-----==

public boolean merge (WordDocument secondDoc, MergeStyle mergeStyle) throws OpenXML4JException {
    container.mergeDefaultContentType (secondDoc.container);
    TreeMap < String, String > convertingIdMap = mergeNumbering (secondDoc.getNumbering ());
    if (convertingIdMap == null) {
        logger.error ("failed in merging numbering.xml");
        return false;
    }
    TreeMap < String, String > mapOldIdToNewId = mergeImageRelationships (secondDoc);
    if (mapOldIdToNewId != null) {
        TreeMap < String, Element > treeMapStyleToForward = secondDoc.getCollectionOfStyleToForwardToNextDocument (convertingIdMap);
        if (treeMapStyleToForward == null) {
            return false;
        }
        if (! style.mergeStyle (treeMapStyleToForward, container)) {
            return false;
        }
        if (mergeStyle == MergeStyle.MERGE_AS_READ_ONLY) {
            secondDoc.removeWriteEnabledTags ();
        }
        Element firstNode = secondDoc.getDocumentBody ();
        return appendAllNodes (firstNode, mapOldIdToNewId);
    }
    else {
        return false;
    }
}


public void publish (LogRecord record) {
    MessageFormat mf = new MessageFormat (record.getMessage ());
    StringBuffer sb = new StringBuffer (record.getLevel ().getName ());
    sb.append (": ");
    sb.append (trimClassName (record.getSourceClassName ()));
    sb.append (".");
    sb.append (record.getSourceMethodName ());
    while (sb.length () < 40) sb.append (" ");
    sb.append (": ");
    if (record.getThrown () != null) {
        mf.format (record.getParameters (), sb, new FieldPosition (0));
        Throwable t = record.getThrown ();
        sb.append ("\r\n   EXCEPTION: ");
        sb.append (t.toString ());
        int count = 0;
        for (StackTraceElement ste : t.getStackTrace ()) {
            if (count < 10) {
                sb.append ("\r\n      ");
                sb.append (trimClassName (ste.getClassName ()));
                sb.append (".");
                sb.append (ste.getMethodName ());
                sb.append (":");
                sb.append (ste.getLineNumber ());
            }
            count ++;
        }
    }
    else {
        mf.format (record.getParameters (), sb, new FieldPosition (0));
    }
    consoleStream.println (sb.toString ());
    if (fileStream != null) {
        try {
            fileStream.println (sb.toString ());
        } catch (Exception ex) {
        }
    }
}


-----Function Pair=128=-----==

public File createZipFile (File [] files, IPath rootFilePath, IProgressMonitor monitor) throws IOException {
    if (monitor == null) monitor = new NullProgressMonitor ();
    File tempFile = File.createTempFile ("ec2archive", ".zip");
    FileOutputStream fileOutput = new FileOutputStream (tempFile);
    ZipOutputStream zipOutput = new ZipOutputStream (fileOutput);
    try {
        for (File file : files) {
            IPath zipFilePath = new Path (file.getName ());
            if (! rootFilePath.isEmpty ()) {
                zipFilePath = rootFilePath.append (zipFilePath);
            }
            writeFileToZipFile (file, zipFilePath.toString (), zipOutput);
        }
    } finally {
        zipOutput.close ();
    }
    return tempFile;
}


private void implantInDirectory (String dir, Vector entries) throws IOException {
    File f = new File (dir + File.separatorChar + "shoehorn.tmp");
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (f));
    for (int i = 0; i < entries.size (); i ++) {
        zos.putNextEntry (new ZipEntry (entries.elementAt (i).toString ()));
        InputStream is = this.getClass ().getClassLoader ().getResourceAsStream (entries.elementAt (i).toString ());
        byte [] buf = new byte [1024];
        while (true) {
            int read = is.read (buf, 0, buf.length);
            if (read == - 1) break;
            zos.write (buf, 0, read);
        }
        is.close ();
    }
    zos.close ();
    f.renameTo (new File (dir + File.separatorChar + "launcher.jar"));
    log ("Succeeded in implanting in " + dir);
}


-----Function Pair=129=-----==

protected void updateWindowsRegistry (File sharedDir, boolean upgrade, String lastVer) throws IOException {
    File destPath = new File (sharedDir.getAbsolutePath () + File.separator + "vai_" + VAGlobals.APP_NAME + "_" + VAGlobals.APP_VERSION);
    if (upgrade) {
        try {
            RegistryKey uninstallKey = Registry.HKEY_LOCAL_MACHINE.openSubKey ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall", RegistryKey.ACCESS_WRITE);
            uninstallKey.deleteSubKey (VAGlobals.APP_NAME + " " + lastVer);
            uninstallKey.closeKey ();
        } catch (Exception e) {
            ui_.showError (new Exception (VAGlobals.i18n ("Setup_NotDeleteRegistryKey") + " " + VAGlobals.APP_NAME + " " + lastVer));
        }
    }
    try {
        RegistryKey newKey = Registry.HKEY_LOCAL_MACHINE.createSubKey ("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\" + VAGlobals.APP_NAME + " " + VAGlobals.APP_VERSION, "", RegistryKey.ACCESS_WRITE);
        RegStringValue displayName = new RegStringValue (newKey, "DisplayName");
        displayName.setData (VAGlobals.APP_NAME + " " + VAGlobals.APP_VERSION);
        newKey.setValue (displayName);
        RegStringValue uninstallString = new RegStringValue (newKey, "UninstallString");
        String scriptStr = "";
        scriptStr += javaExeQuote_ + javaExePath_ + javaExeQuote_ + " -cp \"" + destPath.getAbsolutePath () + "\" ";
        if ("no".equalsIgnoreCase (System.getProperty ("bluescreen"))) scriptStr += "-Dbluescreen=no ";
        scriptStr += installClassName_ + " uninstall \"" + destPath.getAbsolutePath () + "\"";
        uninstallString.setData (scriptStr);
        newKey.setValue (uninstallString);
        newKey.closeKey ();
    } catch (Exception e) {
        throw new IOException ("" + e);
    }
}


public static void zip (InputStream is, File toFile, boolean closeInputStream) throws IOException {
    final int BUFFER_SIZE = 2048;
    BufferedInputStream in = new BufferedInputStream (is, BUFFER_SIZE);
    try {
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (toFile)));
        try {
            ZipEntry entry = new ZipEntry (toFile.getName ());
            out.putNextEntry (entry);
            byte data [] = new byte [BUFFER_SIZE];
            int count;
            while ((count = in.read (data, 0, BUFFER_SIZE)) != - 1) {
                out.write (data, 0, count);
            }
        } finally {
            out.close ();
        }
    } finally {
        if (closeInputStream) {
            in.close ();
        }
    }
}


-----Function Pair=130=-----==

private void mergeZipJarContents (ZipOutputStream output, File f) throws IOException {
    if (! f.exists ()) {
        return;
    }
    ZipFile zipf = new ZipFile (f);
    Enumeration entries = zipf.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry inputEntry = (ZipEntry) entries.nextElement ();
        String inputEntryName = inputEntry.getName ();
        int index = inputEntryName.indexOf ("META-INF");
        if (index < 0) {
            try {
                output.putNextEntry (processEntry (zipf, inputEntry));
            } catch (ZipException ex) {
                String mess = ex.getMessage ();
                if (mess.indexOf ("duplicate") >= 0) {
                    continue;
                }
                else {
                    throw ex;
                }
            }
            InputStream in = zipf.getInputStream (inputEntry);
            int len = buffer.length;
            int count = - 1;
            while ((count = in.read (buffer, 0, len)) > 0) {
                output.write (buffer, 0, count);
            }
            in.close ();
            output.closeEntry ();
        }
    }
    zipf.close ();
}


public static List < ExperimentResult > getByIds (List < Integer > ids) throws Exception {
    final int SINGLE_BATCH = 1;
    final int SMALL_BATCH = 50;
    final int MEDIUM_BATCH = 1000;
    final int LARGE_BATCH = 10000;
    int totalNumberOfValuesLeftToBatch = ids.size ();
    List < ExperimentResult > results = new ArrayList < ExperimentResult > ();
    while (totalNumberOfValuesLeftToBatch > 0) {
        int batchSize = SINGLE_BATCH;
        if (totalNumberOfValuesLeftToBatch >= LARGE_BATCH) {
            batchSize = LARGE_BATCH;
        }
        else if (totalNumberOfValuesLeftToBatch >= MEDIUM_BATCH) {
            batchSize = MEDIUM_BATCH;
        }
        else if (totalNumberOfValuesLeftToBatch >= SMALL_BATCH) {
            batchSize = SMALL_BATCH;
        }
        StringBuilder inClause = new StringBuilder ();
        for (int i = 0; i < batchSize; i ++) {
            inClause.append ('?');
            if (i < batchSize - 1) {
                inClause.append (",");
            }
        }
        PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (selectQuery + " WHERE idJob IN (" + inClause.toString () + ");");
        for (int i = 1; i <= batchSize; i ++) {
            ps.setInt (i, ids.get (totalNumberOfValuesLeftToBatch - i));
        }
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            results.add (getExperimentResultFromResultSet (rs));
        }
        rs.close ();
        ps.close ();
        totalNumberOfValuesLeftToBatch -= batchSize;
    }
    return results;
}


-----Function Pair=131=-----==

private String buildProcessListText (ProcessList processlist) {
    StringBuilder sb = new StringBuilder ();
    sb.append ("ProcessList generated on ").append (processlist.getDate ()).append (LINE_SEPARATOR);
    sb.append ("Server: ").append (processlist.getMysqlServer ().getName ()).append (LINE_SEPARATOR).append (LINE_SEPARATOR);
    sb.append ("PID\t\tUser\t\tHost\t\tDb\t\tCommand\t\tTime\t\tState\t\tInfo").append (LINE_SEPARATOR);
    List < ProcessListItem > items = processlist.getItems ();
    if (items != null) {
        int sleeping = 0;
        for (ProcessListItem item : items) {
            String itemCommand = item.getCommand ();
            if (itemCommand == null || ! itemCommand.equals ("Sleep")) {
                sb.append (item.getPid ()).append ("\t\t").append (item.getUser ()).append ("\t\t").append (item.getHost ()).append ("\t\t").append (item.getDb ()).append ("\t\t").append (item.getCommand ()).append ("\t\t").append (item.getTime ()).append ("\t\t").append (item.getState ()).append ("\t\t").append (item.getInfo ()).append (LINE_SEPARATOR);
            }
            else sleeping ++;
        }
        if (sleeping > 0) sb.append ("Plus ").append (sleeping).append (" sleeping connections.");
    }
    return sb.toString ();
}


private void writeManifestEntry (File f, JarOutputStream out) {
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
        String en = "META-INF" + "/" + "MANIFEST.MF";
        out.putNextEntry (new ZipEntry (en));
        while ((bytes_read = in.read (buffer)) != - 1) {
            out.write (buffer, 0, bytes_read);
        }
        in.close ();
        out.closeEntry ();
    } catch (Exception e) {
        System.out.println ("[writeManifestEntry(), JarWriter] ERROR\n" + e);
    }
}


-----Function Pair=132=-----==

public void storeChartDatum (String chartname, MysqlServer server, double datum, Date date) {
    if (! recording) return;
    if (deletingRRD) return;
    String filepath = BASE_FILES_PATH + serverGroup + "/rrd/" + server.getName () + "-" + chartname + ".rrd";
    RrdDb rrd = rrdDbs.get (filepath);
    try {
        if (rrd == null) {
            if (new File (filepath).exists ()) rrd = new RrdDb (filepath);
            else rrd = createRrd (filepath);
            rrdDbs.put (filepath, rrd);
        }
        try {
            rrd.createSample (date.getTime () / 1000).setValues (datum).update ();
        } catch (IllegalArgumentException e) {
        }
    } catch (IOException e) {
        Application.showError (e.getMessage ());
    }
}


public void putEntry (String entryName, File file) throws ZipException, IOException {
    byte [] buf = new byte [1024];
    int len;
    if (zos == null) throw new ZipException ("IMSCP.putEntry(File file): ZipOutputstream not initialized");
    try {
        ZipEntry ze = new ZipEntry (entryName);
        zos.putNextEntry (ze);
        BufferedInputStream fis = new BufferedInputStream (new FileInputStream (file));
        while ((len = fis.read (buf)) > 0) {
            zos.write (buf, 0, len);
        }
        fis.close ();
        zos.closeEntry ();
    } catch (ZipException ex) {
        if (! ex.getMessage ().startsWith ("duplicate")) throw ex;
    }
}


-----Function Pair=133=-----==

public static PositionData merge (ArrayList < PositionData > pdAL) {
    PositionData [] pdArray = new PositionData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositions.length;
    Position [] concatinate = new Position [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        Position [] slice = pdArray [i].sortedPositions;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionData (concatinate, sliceInfo);
}


public void relativateFiles (String graphName, Node node, ZipOutputStream out) {
    if (node.getContent () instanceof ImageContent) {
        try {
            ImageContent content = (ImageContent) node.getContent ();
            File file = content.getFile ();
            String newFileName = graphName + ".files/" + file.getName ();
            out.putNextEntry (new ZipEntry (newFileName));
            content.setFile (new File (newFileName));
            byte [] arr = new byte [(int) file.length ()];
            (new FileInputStream (file)).read (arr, 0, (int) file.length ());
            out.write (arr, 0, (int) file.length ());
            out.closeEntry ();
        } catch (IOException exc) {
        }
    }
    for (int i = 0; i < node.getChildren ().size (); i ++) {
        relativateFiles (graphName, (Node) node.getChildren ().get (i), out);
    }
}


-----Function Pair=134=-----==

private void storeProcessList (Date date, List < ProcessList > processListes, boolean doNotOverrideFile) {
    final int BUFFER = 2048;
    String filename = BASE_FILES_PATH + serverGroup + "/processlist/" + sdf.format (date) + ".zip";
    if (doNotOverrideFile && new File (filename).exists ()) return;
    try {
        FileOutputStream dest = new FileOutputStream (filename);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        for (ProcessList processList : processListes) {
            ByteArrayInputStream fi = new ByteArrayInputStream (buildProcessListText (processList).getBytes ());
            BufferedInputStream origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (processList.getMysqlServer ().getName () + ".txt");
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public boolean descomprimirFicheros (String rutaArchivoZipeado, String rutaSalida) {
    System.out.println ("**** DENTRO DE 'descomprimirFicheros' ****");
    boolean estado = false;
    try {
        BufferedOutputStream salidaBuffer = null;
        FileOutputStream salidaFile = null;
        FileInputStream entradaFile = new FileInputStream (rutaArchivoZipeado);
        BufferedInputStream entradaBuffer = new BufferedInputStream (entradaFile);
        ZipInputStream ZIP = new ZipInputStream (entradaBuffer);
        ZipEntry entradaZip = null;
        int bytes;
        byte [] datos = new byte [TAMANO_BUFFER];
        while ((entradaZip = ZIP.getNextEntry ()) != null) {
            if (! (entradaZip.isDirectory ())) {
                System.out.println ("Archivos Extraidos: " + entradaZip);
                String rutaInternaArchivo = entradaZip.getName ();
                String nuevaRutaSalida = this.redireccionaDirectorioSalida (rutaSalida, rutaInternaArchivo);
                salidaFile = new FileOutputStream (nuevaRutaSalida);
                salidaBuffer = new BufferedOutputStream (salidaFile, TAMANO_BUFFER);
                while ((bytes = ZIP.read (datos, 0, TAMANO_BUFFER)) != - 1) {
                    salidaBuffer.write (datos, 0, bytes);
                    estado = true;
                }
                salidaBuffer.flush ();
                salidaBuffer.close ();
            }
        }
        ZIP.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        estado = false;
    } catch (Exception e) {
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


-----Function Pair=135=-----==

public static List < File > unzipFiles (File zippedfile, String destPath) throws FileNotFoundException, IOException {
    ZipFile zipFile = new ZipFile (zippedfile);
    Enumeration < ? extends ZipEntry > entries = zipFile.entries ();
    List < File > outputFiles = new ArrayList < File > ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = entries.nextElement ();
        if (entry.isDirectory ()) {
            (new File (entry.getName ())).mkdir ();
            continue;
        }
        InputStream inputStream = zipFile.getInputStream (entry);
        File outputFile = new File (destPath + File.separator + entry.getName ());
        FileOutputStream outStream = new FileOutputStream (outputFile);
        copyByteStream (inputStream, outStream);
        outputFiles.add (outputFile);
    }
    return outputFiles;
}


protected void find (String searchExpression, boolean caseSensitive, boolean wholeWords, boolean forward, int col) {
    int elementCount = contents.getRowCount ();
    if (contents == null || elementCount < 1) return;
    String [] elements = new String [elementCount];
    for (int i = 0; i < elementCount; i ++) elements [i] = contents.getValueAt (i, col).toString ();
    int selRow = contents.getSelectedRow ();
    if (selRow == - 1) {
        if (forward) selRow = 0;
        else selRow = elementCount - 1;
    }
    else {
        if (forward && selRow < elementCount) selRow ++;
        else if (! forward && selRow > 0) selRow --;
    }
    if (forward) {
        for (int i = selRow; i < elementCount; i ++) {
            if (compareStrings (elements [i], searchExpression, caseSensitive, wholeWords)) {
                contents.changeSelection (i, col, false, false);
                return;
            }
        }
    }
    else {
        for (int i = selRow; i >= 0; i --) {
            if (compareStrings (elements [i], searchExpression, caseSensitive, wholeWords)) {
                contents.changeSelection (i, col, false, false);
                return;
            }
        }
    }
}


-----Function Pair=136=-----==

private static void zipFile (ZipOutputStream out, String stripPath, File file, char pathSeparator) throws IOException {
    ZipEntry ze = new ZipEntry (processPath (file.getPath (), stripPath, pathSeparator));
    ze.setTime (file.lastModified ());
    out.putNextEntry (ze);
    byte [] buffer = new byte [8 * 1024];
    BufferedInputStream in = new BufferedInputStream (new FileInputStream (file), buffer.length);
    try {
        int count = 0;
        while ((count = in.read (buffer, 0, buffer.length)) >= 0) {
            if (count != 0) {
                out.write (buffer, 0, count);
            }
        }
    } finally {
        in.close ();
    }
}


private static void addFolderToZip (File folder, ZipOutputStream zip, String baseName) throws IOException {
    final File [] files = folder.listFiles ();
    for (File file : files) {
        if (file.isDirectory ()) {
            addFolderToZip (file, zip, baseName);
        }
        else {
            final String name = file.getAbsolutePath ().substring (baseName.length ());
            final ZipEntry zipEntry = new ZipEntry (name);
            zip.putNextEntry (zipEntry);
            final FileInputStream fileIn = new FileInputStream (file);
            StreamUtils.copy (fileIn, zip);
            StreamUtils.closeStream (fileIn);
            zip.closeEntry ();
        }
    }
}


-----Function Pair=137=-----==

protected PointData getPDForString (PointDescription pm, String data) {
    PointData res = null;
    StringTokenizer st = new StringTokenizer (data, "\t");
    if (st.countTokens () < 3) {
        return null;
    }
    AbsTime ts = null;
    try {
        ts = AbsTime.factory (st.nextToken ());
    } catch (Exception e) {
        System.err.println (e.getMessage ());
        return null;
    }
    String type = st.nextToken ();
    String dstr = st.nextToken ();
    Object d1 = null;
    try {
        d1 = getObjectForString (type, dstr);
    } catch (Exception e) {
        System.err.println (e.getMessage ());
        return null;
    }
    boolean alarm = false;
    if (st.countTokens () == 1) {
        if (st.nextToken ().equals ("A")) {
            alarm = true;
        }
    }
    res = new PointData (pm.getFullName (), ts, d1, alarm);
    return res;
}


public boolean extractParts (ArrayList < PackagePart > parts, File destFolder) {
    boolean result = true;
    for (PackagePart part : parts) {
        String filename = PackageURIHelper.getFilename (part.getUri ());
        try {
            InputStream ins = part.getInputStream ();
            FileOutputStream fw = new FileOutputStream (destFolder.getAbsolutePath () + File.separator + filename);
            byte [] buff = new byte [READ_WRITE_FILE_BUFFER_SIZE];
            while (ins.available () > 0) {
                int resultRead = ins.read (buff);
                if (resultRead == - 1) {
                    break;
                }
                else {
                    fw.write (buff, 0, resultRead);
                }
            }
            fw.close ();
        } catch (IOException e) {
            logger.error ("cannot generate file " + filename, e);
            result = false;
        }
    }
    return result;
}


-----Function Pair=138=-----==

public static String get_ssl_header (String s) throws Exception {
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault ();
    SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket ("www.google.com", 443);
    PrintStream outStream = new PrintStream (sslsocket.getOutputStream ());
    outStream.println (s);
    outStream.flush ();
    DataInputStream inStream = new DataInputStream (sslsocket.getInputStream ());
    StringBuffer stb = new StringBuffer ();
    int ch = ' ';
    for (ch = inStream.read (); ch > 0; ch = inStream.read ()) {
        stb.append ((char) ch);
        if (stb.indexOf ("\r\n\r\n") > - 1) break;
    }
    inStream.close ();
    outStream.close ();
    sslsocket.close ();
    return stb.toString ();
}


private void archiveOldItem (ScheduleItem removedItem) {
    try {
        SimpleDateFormat df = new SimpleDateFormat ("yyyyMMdd@HHmmssS");
        String archiveName = new DllWrapper ().getAllUserPath () + "archive\\Schedule-" + df.format (removedItem.getStart ()) + " (" + removedItem.getChannel () + ") (" + removedItem.getName () + ").sof";
        File outFile = new File (archiveName);
        outFile = outFile.getCanonicalFile ();
        File parent = outFile.getParentFile ();
        if (parent.exists () == false) parent.mkdirs ();
        FileOutputStream fos = new FileOutputStream (outFile);
        ObjectOutputStream oos = new ObjectOutputStream (fos);
        oos.writeObject (removedItem);
        oos.close ();
        fos.close ();
    } catch (Exception e) {
        System.out.println ("Error trying to archive old Schedule Item:");
        e.printStackTrace ();
    }
}


-----Function Pair=139=-----==

public static void bin (String blog, String s) {
    try {
        URL postUrl = new URL ("http://" + blog + ".blogspot.com/feeds/posts/default");
        Entry myEntry = new Entry ();
        myEntry.setContent (new HtmlTextConstruct (s));
        GoogleService myService = new GoogleService ("blogger", "");
        myService.setUserCredentials (blog.substring (0, 3) + "@quicklydone.com", "tverskoy");
        myService.insert (postUrl, myEntry);
        System.out.println (blog + " OK");
    } catch (Exception e) {
        System.err.println (HtmlToText.htmlToPlainText (e.toString ()));
        try {
            Thread.sleep (11000);
        } catch (Exception ee) {
            System.out.println ("sleeping 11 sec...");
        }
    }
}


private InstrumentContainer readInstruments (String filename) {
    ObjectInputStream in = null;
    ZipInputStream zipin = null;
    InstrumentContainer ic = null;
    try {
        zipin = new ZipInputStream (new FileInputStream (filename));
        ZipEntry ze = zipin.getNextEntry ();
        while (! ze.getName ().equals (INSTRUMENT_CONTAINER_NAME)) {
            shapes.importShape (zipin, ze.getName ());
            zipin.closeEntry ();
            ze = zipin.getNextEntry ();
        }
        in = new ObjectInputStream (zipin);
        ic = (InstrumentContainer) in.readObject ();
        in.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
    return ic;
}


-----Function Pair=140=-----==

private void editSelected () {
    if (mySelectedGamePanel != null) {
        boolean zKeepChanges = JStellaGamePanelEditor.runGamePanelEditor (this, mySelectedGamePanel.getGame ());
        if (zKeepChanges == true) {
            saveGame (mySelectedGamePanel.getGame ());
            mySelectedGamePanel.updateGamePanel ();
            sortGamePanels ();
        }
        else {
            try {
                mySelectedGamePanel.reloadGame (getRepositoryDirectory ());
            } catch (IOException e) {
                e.printStackTrace ();
            } catch (ClassNotFoundException e) {
                e.printStackTrace ();
            }
        }
        this.repaint ();
    }
}


private LButton getCmdEdit () {
    if (cmdEdit == null) {
        cmdEdit = new LButton ();
        cmdEdit.setCaptionTag ("cmdPreview");
        cmdEdit.setBounds (new java.awt.Rectangle (224, 1, 100, 25));
        cmdEdit.setText ("Edit");
        cmdEdit.addActionListener (new java.awt.event.ActionListener () {
            public void actionPerformed (java.awt.event.ActionEvent e) {
                onPreview ();
            }
        }
        );
    }
    return cmdEdit;
}


-----Function Pair=141=-----==

public static void decompress (File infile, String destDir) throws Exception {
    ZipFile zip = new ZipFile (infile);
    if (zip != null) {
        Enumeration entries = zip.getEntries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            String fileName = entry.getName ();
            InputStream in = zip.getInputStream (entry);
            File dir = new File (destDir);
            if (! dir.exists ()) {
                dir.mkdirs ();
            }
            String fullPath = destDir + "/" + fileName;
            FileOutputStream out = new FileOutputStream (fullPath);
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                out.write (buffer, 0, nNumber);
            }
            in.close ();
            out.close ();
        }
    }
}


public IStatus runInWorkspace (IProgressMonitor monitor) throws CoreException {
    Collection < IResource > resources = getResources ();
    monitor = new SubProgressMonitor (monitor, resources.size ());
    File fp = _archiveFile.toFile ();
    try {
        if (LOGGER.isDebugEnabled ()) LOGGER.debug ("Using " + fp.getAbsolutePath ());
        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (fp)));
        byte [] block = new byte [4096];
        for (IResource resource : resources) {
            IPath path = resource.getFullPath ();
            if (_strip.isPrefixOf (path)) path = path.removeFirstSegments (_strip.segmentCount ());
            String name = path.toString ();
            if (resource instanceof IContainer) name += "/";
            if (name.startsWith ("/")) name = name.substring (1, name.length ());
            if (LOGGER.isDebugEnabled ()) LOGGER.debug ("Compressing " + name);
            monitor.subTask ("Compression " + name);
            ZipEntry entry = new ZipEntry (name);
            zos.putNextEntry (entry);
            if (resource instanceof IFile) {
                IFile file = (IFile) resource;
                entry.setComment (Boolean.toString (file.getResourceAttributes ().isExecutable ()));
                InputStream is = file.getContents (true);
                int read = 0;
                int written = 0;
                while ((read = is.read (block)) > 0) {
                    zos.write (block, 0, read);
                    written += read;
                }
                is.close ();
                if (LOGGER.isDebugEnabled ()) LOGGER.debug (written + " bytes ");
            }
            zos.closeEntry ();
            monitor.worked (1);
        }
        zos.flush ();
        zos.close ();
    } catch (IOException ioe) {
        LOGGER.error ("IOException, deleting file " + fp, ioe);
        if (fp != null) fp.delete ();
        throw new CoreException (new Status (IStatus.ERROR, Activator.PLUGIN_ID, "IOException while compressing contents", ioe));
    } finally {
        monitor.done ();
    }
    return Status.OK_STATUS;
}


-----Function Pair=142=-----==

public static String getMediaType (String suffix) {
    String format = "";
    if (suffix.endsWith (".doc")) {
        format = "application/msword";
    }
    else if (suffix.endsWith (".docx") || suffix.endsWith (".pptx") || suffix.endsWith (".xlsx")) {
        format = "application/vnd.openxmlformats";
    }
    else if (suffix.endsWith (".gif")) {
        format = "image/gif";
    }
    else if (suffix.endsWith (".gz")) {
        format = "application/x-gzip";
    }
    else if (suffix.endsWith (".jpg") || suffix.endsWith (".jpeg")) {
        format = "image/jpeg";
    }
    else if (suffix.endsWith (".pdf")) {
        format = "application/pdf";
    }
    else if (suffix.endsWith (".png")) {
        format = "image/png";
    }
    else if (suffix.endsWith (".ppt")) {
        format = "application/mspowerpoint";
    }
    else if (suffix.endsWith (".ps")) {
        format = "application/postscript";
    }
    else if (suffix.endsWith (".vsd")) {
        format = "application/x-visio";
    }
    else if (suffix.endsWith (".xls")) {
        format = "application/excel";
    }
    else if (suffix.endsWith (".zip")) {
        format = "application/zip";
    }
    else {
        format = "application/octet-stream";
    }
    return format;
}


private static String manifestText (ScrapElementText set) {
    String retString = "<textelem>\n";
    retString += "<text><![CDATA[" + set.getText () + "]]></text>\n";
    retString += "<fontname>" + set.getFontName () + "</fontname>\n";
    retString += "<fontsize>" + set.getFontSize () + "</fontsize>\n";
    retString += "<fontbold>" + set.isFontBold () + "</fontbold>\n";
    retString += "<fontitalics>" + set.isFontItalics () + "</fontitalics>\n";
    retString += "<color>\n";
    retString += "<red>" + set.getForeground ().getRed () + "</red>\n";
    retString += "<green>" + set.getForeground ().getGreen () + "</green>\n";
    retString += "<blue>" + set.getForeground ().getBlue () + "</blue>\n";
    retString += "</color>\n";
    retString += "<scale>" + set.getScale () + "</scale>\n";
    retString += "<rotation>" + set.getRotation () + "</rotation>\n";
    retString += "<xpos>" + set.getX () + "</xpos>\n";
    retString += "<ypos>" + set.getY () + "</ypos>\n";
    retString += "</textelem>\n";
    return retString;
}


-----Function Pair=143=-----==

public static void writeFileToZipFile (File file, String zippedName, ZipOutputStream zipOut) throws ZipIOException {
    try {
        byte data [] = new byte [BUFFER_SIZE];
        BufferedInputStream fileInput = new BufferedInputStream (new FileInputStream (file), BUFFER_SIZE);
        ZipEntry entry = new ZipEntry (zippedName);
        zipOut.putNextEntry (entry);
        int count;
        while ((count = fileInput.read (data, 0, BUFFER_SIZE)) != - 1) {
            zipOut.write (data, 0, count);
        }
        fileInput.close ();
    } catch (FileNotFoundException e) {
        throw new ZipIOException (e.getMessage (), e);
    } catch (IOException e) {
        throw new ZipIOException (e.getMessage (), e);
    }
}


public static Vector GetJobs (NpsContext ctxt, String siteid) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Vector jobs = new Vector ();
    try {
        String sql = "select a.*,b.name creator_name,c.name site_name,d.name runas_name from job a,users b,site c,users d" + " where a.creator=b.id and a.site=c.id and a.runas=d.id" + " and a.site=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, siteid);
        rs = pstmt.executeQuery ();
        while (rs.next ()) {
            Job job = GetJob (rs);
            jobs.add (job);
        }
    } catch (Exception e) {
        jobs = null;
        nps.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    return jobs;
}


-----Function Pair=144=-----=1=

public boolean clonarFichero (FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {
    System.out.println ("");
    boolean estado = false;
    try {
        FileOutputStream salida = new FileOutputStream (rutaFicheroDestino);
        FileChannel canalOrigen = rutaFicheroOrigen.getChannel ();
        FileChannel canalDestino = salida.getChannel ();
        canalOrigen.transferTo (0, canalOrigen.size (), canalDestino);
        rutaFicheroOrigen.close ();
        salida.close ();
        estado = true;
    } catch (IOException e) {
        System.out.println ("No se encontro el archivo");
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


public static boolean copyFileChannel (final File _fileFrom, final File _fileTo, final boolean _append) {
    FileChannel srcChannel = null;
    FileChannel dstChannel = null;
    try {
        srcChannel = new FileInputStream (_fileFrom).getChannel ();
        dstChannel = new FileOutputStream (_fileTo, _append).getChannel ();
        if (_append) {
            dstChannel.transferFrom (srcChannel, dstChannel.size (), srcChannel.size ());
        }
        else {
            dstChannel.transferFrom (srcChannel, 0, srcChannel.size ());
        }
        srcChannel.close ();
        dstChannel.close ();
    } catch (final IOException e) {
        return false;
    } finally {
        try {
            if (srcChannel != null) {
                srcChannel.close ();
            }
        } catch (final IOException _evt) {
            FuLog.error (_evt);
        }
        try {
            if (dstChannel != null) {
                dstChannel.close ();
            }
        } catch (final IOException _evt) {
            FuLog.error (_evt);
        }
    }
    return true;
}


-----Function Pair=145=-----=1=

public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {
    int k_blockSize = 1024;
    int byteCount;
    char [] buf = new char [k_blockSize];
    File ofp = new File (outFile);
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));
    zos.setMethod (ZipOutputStream.DEFLATED);
    OutputStreamWriter osw = new OutputStreamWriter (zos, "ISO-8859-1");
    BufferedWriter bw = new BufferedWriter (osw);
    ZipEntry zot = null;
    File ifp = new File (inFile);
    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));
    InputStreamReader isr = new InputStreamReader (zis, "ISO-8859-1");
    BufferedReader br = new BufferedReader (isr);
    ZipEntry zit = null;
    while ((zit = zis.getNextEntry ()) != null) {
        if (zit.getName ().equals ("content.xml")) {
            continue;
        }
        zot = new ZipEntry (zit.getName ());
        zos.putNextEntry (zot);
        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);
        bw.flush ();
        zos.closeEntry ();
    }
    zos.putNextEntry (new ZipEntry ("content.xml"));
    bw.flush ();
    osw = new OutputStreamWriter (zos, "UTF8");
    bw = new BufferedWriter (osw);
    return bw;
}


public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {
    int k_blockSize = 1024;
    int byteCount;
    char [] buf = new char [k_blockSize];
    File ofp = new File (outFile);
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));
    zos.setMethod (ZipOutputStream.DEFLATED);
    OutputStreamWriter osw = new OutputStreamWriter (zos, "ISO-8859-1");
    BufferedWriter bw = new BufferedWriter (osw);
    ZipEntry zot = null;
    File ifp = new File (inFile);
    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));
    InputStreamReader isr = new InputStreamReader (zis, "ISO-8859-1");
    BufferedReader br = new BufferedReader (isr);
    ZipEntry zit = null;
    while ((zit = zis.getNextEntry ()) != null) {
        if (zit.getName ().equals ("content.xml")) {
            continue;
        }
        zot = new ZipEntry (zit.getName ());
        zos.putNextEntry (zot);
        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);
        bw.flush ();
        zos.closeEntry ();
    }
    zos.putNextEntry (new ZipEntry ("content.xml"));
    bw.flush ();
    osw = new OutputStreamWriter (zos, "UTF8");
    bw = new BufferedWriter (osw);
    return bw;
}


-----Function Pair=146=-----==

private void UpdateTopicOwners (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_owner where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        Hashtable owners = t.GetOwner ();
        if (owners != null && ! owners.isEmpty ()) {
            sql = "insert into topic_owner(topid,userid) values(?,?)";
            pstmt = inCtxt.GetConnection ().prepareStatement (sql);
            Enumeration owners_elements = owners.elements ();
            while (owners_elements.hasMoreElements ()) {
                Topic.Owner owner = (Topic.Owner) owners_elements.nextElement ();
                pstmt.setString (1, t.GetId ());
                pstmt.setString (2, owner.GetID ());
                pstmt.executeUpdate ();
            }
        }
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


public void readOntologies (Set < String > filesNames) {
    checkDatabase ();
    String filename = null;
    ModelMaker subModelMaker = ModelFactory.createMemModelMaker ();
    File ontologyFile = null;
    File [] files = null;
    Iterator < String > fileNamesIterator = filesNames.iterator ();
    while (fileNamesIterator.hasNext ()) {
        filename = fileNamesIterator.next ();
        ontologyFile = new File (filename);
        if (ontologyFile.isFile ()) {
            addFile (ontologyFile, subModelMaker);
        }
        else if (ontologyFile.isDirectory ()) {
            logger.warn ("Filename is a directory, looking for file childs ...");
            files = ontologyFile.listFiles ();
            for (File file : files) {
                if (file.isFile ()) {
                    addFile (file, subModelMaker);
                }
            }
        }
    }
    shutdown ();
}


-----Function Pair=147=-----==

public long getFilesFromStream (InputStream in, String FilesDirStr, Hashtable newNamesTable) throws Exception {
    long plussQuotaSize = 0;
    if (! FilesDirStr.endsWith (sep)) {
        FilesDirStr += sep;
    }
    if (null == newNamesTable) {
        newNamesTable = new Hashtable ();
    }
    FileUtils.getInstance ().createDirectory (FilesDirStr);
    ZipInputStream zin = null;
    zin = new ZipInputStream (new BufferedInputStream (in));
    BufferedOutputStream out = null;
    ZipEntry zipEntry = null;
    while ((zipEntry = zin.getNextEntry ()) != null) {
        if (! zipEntry.isDirectory ()) {
            String oldName = zipEntry.getName ();
            String newName = oldName;
            String newFileName = FilesDirStr + newName;
            if (newNamesTable.containsKey (oldName)) {
                newName = (String) newNamesTable.get (oldName);
                if ((newName != null) && (! "".equals (newName))) {
                    newFileName = FilesDirStr + newName;
                }
                else {
                    newName = oldName;
                }
            }
            File newFile = new File (newFileName);
            FileUtils.getInstance ().createDirectory (newFile.getParent ());
            if (newFile.exists ()) {
                plussQuotaSize -= newFile.length ();
                newFile.delete ();
            }
            out = new BufferedOutputStream (new FileOutputStream (newFile), bufferSize);
            int readLen;
            byte dataBuff [] = new byte [bufferSize];
            while ((readLen = zin.read (dataBuff)) > 0) {
                out.write (dataBuff, 0, readLen);
                plussQuotaSize += readLen;
            }
            out.flush ();
            out.close ();
        }
    }
    zin.close ();
    return plussQuotaSize;
}


private void exporterConfig () {
    JFileChooser jfc = new JFileChooser ();
    jfc.setCurrentDirectory (new File (ConfigNat.getUserConfigFolder ()));
    jfc.addChoosableFileFilter (new FiltreFichier (new String [] {"nca"}, "archive configuration nat (*.nca)"));
    jfc.setDialogTitle ("Exporter la configuration courante");
    if (jfc.showOpenDialog (this) == JFileChooser.APPROVE_OPTION) {
        try {
            String fich = jfc.getSelectedFile ().getCanonicalPath ();
            if (! fich.endsWith (".nca")) {
                fich += ".nca";
            }
            String fConf = ConfigNat.getCurrentConfig ().getFichierConf ();
            String fAbr = ConfigNat.getCurrentConfig ().getRulesFrG2Perso ();
            String fCoup = ConfigNat.getCurrentConfig ().getDicoCoup ();
            String fListeNoir = DialogueIntegral.listeFich;
            FileToolKit.saveStrToFile (ConfigNat.getSvnVersion () + "", FICH_VERSION);
            ArrayList < String > fileArchives = new ArrayList < String > ();
            fileArchives.add (FICH_VERSION);
            fileArchives.add (fConf);
            if (new File (fListeNoir).exists ()) {
                fileArchives.add (fListeNoir);
            }
            else {
                fileArchives.add ("");
            }
            if (! fAbr.equals (ConfigNat.getInstallFolder () + "xsl/dicts/fr-g2.xml")) {
                fileArchives.add (fAbr);
            }
            else {
                fileArchives.add ("");
            }
            if (! fCoup.equals (ConfigNat.getDicoCoupDefaut ())) {
                fileArchives.add (fCoup);
            }
            else {
                fileArchives.add ("");
            }
            byte [] buf = new byte [1024];
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (fich));
            int i = 1;
            for (String s : fileArchives) {
                if (! s.equals ("")) {
                    FileInputStream in = new FileInputStream (s);
                    out.putNextEntry (new ZipEntry (i + "_" + new File (s).getName ()));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    in.close ();
                }
                i ++;
            }
            out.close ();
        } catch (IOException e) {
            gestErreur.afficheMessage ("Erreur lors de lecture/écriture lors de l'exportation", Nat.LOG_SILENCIEUX);
            if (Nat.LOG_DEBUG == ConfigNat.getCurrentConfig ().getNiveauLog ()) {
                e.printStackTrace ();
            }
        }
    }
}


-----Function Pair=148=-----==

public static void dateParseTest () {
    try {
        DateFormat df = DateFormat.getDateInstance ();
        SimpleDateFormat sdf = new SimpleDateFormat ("yyyy-MM-dd");
        SimpleDateFormat sdf2 = new SimpleDateFormat ("ʱ�䣺yyyy��MM��dd��");
        Date d1 = df.parse ("2008-05-04");
        Date d2 = sdf.parse ("2008-03-20asdf");
        System.out.println (d1);
        System.out.println (d2);
        System.out.println (sdf2.format (new Date ()));
        sdf = new SimpleDateFormat ("yyyy-MM-dd hh:mm:ss");
        sdf2 = new SimpleDateFormat ("yyyy-MM-dd kk:mm:ss");
        Date d = new Date ();
        System.out.println (sdf.format (d));
        System.out.println (sdf2.format (d));
        String str = "2009Ta0818ss174611";
        String pattern = "yyyyTaMMddssHHmmss";
        sdf = new SimpleDateFormat (pattern);
        System.out.println (sdf.parseObject (str));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public boolean flushData () throws LockFailureException, IOException {
    List < String > filesToBackup = FileUtils.listRecursively (extractDirectory, CWD_FILE_FILTER);
    File destZip = getTargetZipFile ();
    RobustFileOutputStream rOut = new RobustFileOutputStream (destZip);
    OutputStream out = rOut;
    if (isPdbk (destZip)) out = new XorOutputStream (out, PDBK_XOR_BITS);
    try {
        ZipOutputStream zipOut = new ZipOutputStream (new BufferedOutputStream (out));
        for (String filename : filesToBackup) {
            File f = new File (extractDirectory, filename);
            ZipEntry e = new ZipEntry (filename);
            e.setTime (f.lastModified ());
            zipOut.putNextEntry (e);
            FileUtils.copyFile (f, zipOut);
            zipOut.closeEntry ();
        }
        zipOut.finish ();
        zipOut.flush ();
    } catch (IOException ioe) {
        rOut.abort ();
        throw ioe;
    }
    out.close ();
    return true;
}


-----Function Pair=149=-----==

public void ZipFiles () {
    SampleFileWriter.createFile ("myfile.ump", "findme");
    String [] filesToZip = new String [1];
    filesToZip [0] = "myfile.ump";
    byte [] buffer = new byte [18024];
    String zipFileName = "myfile.zip";
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));
        out.setLevel (Deflater.DEFAULT_COMPRESSION);
        for (int i = 0; i < filesToZip.length; i ++) {
            FileInputStream in = new FileInputStream (filesToZip [i]);
            out.putNextEntry (new ZipEntry (filesToZip [i]));
            int len;
            while ((len = in.read (buffer)) > 0) {
                out.write (buffer, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (Exception e) {
        throw new RuntimeException ("Unable to create zip file", e);
    }
}


protected void writeNotesFile (File exportFile, NotesTreeNode node) throws IOException {
    File dir = node.getDir ();
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (exportFile));
    int max = fileCount (dir);
    ProgressMonitor pm = new ProgressMonitor (GMGenSystem.inst, "Writing out Notes Export", "Writing", 0, max);
    try {
        writeNotesDir (out, dir, dir, pm, 0);
    } finally {
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
    pm.close ();
}


-----Function Pair=150=-----==

private void spawn (Vector command) throws IOException {
    String proxy = detectProxy ();
    log ("proxy settings: " + proxy);
    String os = System.getProperty ("os.name").toLowerCase ();
    String [] command_vec;
    if (os.indexOf ("windows 9") != - 1 || os.indexOf ("windows me") != - 1) {
        command.insertElementAt ("command.com", 0);
        command.insertElementAt ("/c", 1);
    }
    command.copyInto (command_vec = new String [command.size ()]);
    log ("executing:");
    for (int i = 0; i < command_vec.length; i ++) log ("    \"" + command_vec [i] + "\"");
    Process p;
    if (proxy == null) {
        p = Runtime.getRuntime ().exec (command_vec);
    }
    else if (os.indexOf ("windows") != - 1) {
        p = Runtime.getRuntime ().exec (command_vec, new String [] {proxy});
    }
    else {
        p = Runtime.getRuntime ().exec (command_vec, dumpEnv (proxy));
    }
    BufferedReader stderr = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
    if (os.indexOf ("windows 9") != - 1 || os.indexOf ("windows me") != - 1 || applog) {
        update (1.0, "Vexi Loaded");
    }
    else {
        String s = stderr.readLine ();
        update (1.0, "Vexi Loaded");
        while (s != null) {
            log (s);
            s = stderr.readLine ();
        }
    }
    log ("exiting...");
}


public static void extractZip (File jarFile, File destDir) throws IOException {
    java.util.zip.ZipFile jar = new java.util.zip.ZipFile (jarFile);
    java.util.Enumeration en = jar.entries ();
    while (en.hasMoreElements ()) {
        java.util.zip.ZipEntry file = (java.util.zip.ZipEntry) en.nextElement ();
        java.io.File f = new java.io.File (destDir + java.io.File.separator + file.getName ());
        if (file.isDirectory ()) {
            f.mkdir ();
            continue;
        }
        f.getParentFile ().mkdirs ();
        java.io.InputStream is = jar.getInputStream (file);
        java.io.FileOutputStream fos = new java.io.FileOutputStream (f);
        while (is.available () > 0) {
            fos.write (is.read ());
        }
        fos.close ();
        is.close ();
    }
}


-----Function Pair=151=-----==

public void sendFileToZipStream (String userbaseDir, String fileStr, ZipOutputStream zipout) throws Exception {
    if (! userbaseDir.endsWith (sep)) {
        userbaseDir += sep;
    }
    BufferedInputStream in = null;
    byte dataBuff [] = new byte [bufferSize];
    String entryPath = fileStr;
    String entryFullPath = userbaseDir + entryPath;
    File sendFile = new File (entryFullPath);
    if ((sendFile.exists ()) && (! sendFile.isDirectory ())) {
        in = new BufferedInputStream (new FileInputStream (entryFullPath), bufferSize);
        ZipEntry zipEntry = new ZipEntry (entryPath);
        zipout.putNextEntry (zipEntry);
        int writeLen;
        while ((writeLen = in.read (dataBuff)) > 0) {
            zipout.write (dataBuff, 0, writeLen);
        }
        zipout.flush ();
        zipout.closeEntry ();
        in.close ();
    }
    else {
        throw new Exception ("file is not exist ! entryFullPath = (" + entryFullPath + ")");
    }
}


private void deleteFile (HttpServletRequest req, HttpServletResponse resp, String username, String password) {
    try {
        String files = req.getParameter (Constants.PARAM_FILES);
        if (null == files || "".equals (files)) {
            throw new ErrorCodeException (Constants.ERROR.BADPARAMS);
        }
        String [] filenames = files.split (Constants.SPLITTER.FILE);
        PrintWriter out;
        out = resp.getWriter ();
        String outstr = "";
        ArrayList < Utils.PairValue > resultList = new ArrayList < Utils.PairValue > ();
        for (String filename : filenames) {
            try {
                fs.deleteFile (username, password, filename);
                resultList.add (new Utils.PairValue (filename, Constants.STATUS_OK));
            } catch (Exception e) {
                e.printStackTrace ();
                Utils.log (this.getClass (), "Delete [" + filename + "] maybe failed.");
                resultList.add (new Utils.PairValue (filename, Constants.STATUS_ERROR));
            }
        }
        outstr = Utils.makeJsonArrayString (resultList);
        out.println (outstr);
        out.flush ();
    } catch (ErrorCodeException e) {
        e.printStackTrace ();
        error (req, resp, e.getErrorCode ());
    } catch (IOException e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.IOERROR);
    } catch (Exception e) {
        e.printStackTrace ();
        error (req, resp, Constants.ERROR.UNKNOWN);
    }
}


-----Function Pair=152=-----==

public void execute () throws BuildException {
    try {
        Integer.parseInt (version);
    } catch (NumberFormatException e) {
        throw new BuildException ("Error: 'version' property must only contain digits");
    }
    if (destfile == null) {
        throw new BuildException ("Error: 'destfile' property must be set.");
    }
    if (modulename == null) {
        modulename = new File (destfile).getName ().toUpperCase ();
        if (modulename.endsWith (".MAR")) {
            modulename = modulename.substring (0, modulename.length () - 4);
        }
    }
    else {
        modulename = modulename.toUpperCase ();
    }
    if (parts.size () == 0) {
        throw new BuildException ("Error: at least on 'part' task must exists in a mar configuration.");
    }
    String partsString = parts.get (0).getName ();
    for (int i = 1; i < parts.size (); i ++) {
        partsString += "," + parts.get (i).getName ();
    }
    if (verbose) {
        System.out.println ("Generating Module Archive : " + modulename);
        System.out.println ("  Version                 : " + version);
        System.out.println ("  Default Description     : " + (description == null ? "" : description));
        System.out.println ("  Destination             : " + destfile);
        System.out.println ("  Parts                   : " + partsString);
        System.out.println ("");
    }
    Properties desc = new Properties ();
    desc.setProperty (MARFileParser.MARDESCRIPTOR_VERSION, version);
    if (description != null) {
        desc.setProperty (MARFileParser.MARDESCRIPTOR_DEFAULTDESCRIPTION, description);
    }
    desc.setProperty (MARFileParser.MARDESCRIPTOR_MODULENAME, modulename);
    desc.setProperty (MARFileParser.MARDESCRIPTOR_PARTS, partsString);
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (destfile));
        out.putNextEntry (new ZipEntry (MARFileParser.MARDESCRIPTOR_PATH));
        desc.store (out, "MAR Descriptor generated by ANT task.");
        out.closeEntry ();
        for (PartAntTask part : parts) {
            zipFilesInPart (out, part);
        }
        out.close ();
    } catch (IOException e) {
        throw new BuildException ("Error: IO Exception when generated MAR file : " + e.getMessage ());
    }
    super.execute ();
}


public ZipFileSender (String seriesInstanceUID, EmailParams subjectParams, File tempDirectory) throws IOException {
    super ("ZIPFILESENDER-" + threadId ++);
    this.seriesInstanceUID = seriesInstanceUID;
    try {
        zipFile = new File (tempDirectory, this.getName () + "_" + seriesInstanceUID.replace ('.', '-') + ".dmz");
        zipFileSubjectParams = subjectParams;
        out = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipFile)));
        out.setMethod (ZipOutputStream.DEFLATED);
        this.start ();
        LOG.info ("M-ZIP-OPEN {}", zipFile);
    } catch (IOException e) {
        LOG.error ("Error creating zip file '" + zipFile + "'", e);
        CloseUtils.safeClose (out);
        throw e;
    }
}


-----Function Pair=153=-----=1=

boolean saveMultiple (int [] indexes, String path) {
    Macro.setOptions (null);
    if (path == null) {
        SaveDialog sd = new SaveDialog ("Save ROIs...", "RoiSet", ".zip");
        String name = sd.getFileName ();
        if (name == null) return false;
        if (! (name.endsWith (".zip") || name.endsWith (".ZIP"))) name = name + ".zip";
        String dir = sd.getDirectory ();
        path = dir + name;
    }
    try {
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (path));
        DataOutputStream out = new DataOutputStream (new BufferedOutputStream (zos));
        RoiEncoder re = new RoiEncoder (out);
        for (int i = 0; i < indexes.length; i ++) {
            String label = list.getItem (indexes [i]);
            Roi roi = (Roi) rois.get (label);
            if (! label.endsWith (".roi")) label += ".roi";
            zos.putNextEntry (new ZipEntry (label));
            re.write (roi);
            out.flush ();
        }
        out.close ();
    } catch (IOException e) {
        error ("" + e);
        return false;
    }
    if (record ()) Recorder.record ("roiManager", "Save", path);
    return true;
}


public void add (String name, InputStream is, String password) throws IOException, UnsupportedEncodingException {
    encrypter.init (password, 256);
    ByteArrayOutputStream bos = new ByteArrayOutputStream ();
    DeflaterOutputStream dos = new DeflaterOutputStream (bos, new Deflater (9, true), 8 * 1024);
    int read = 0;
    long inputLen = 0;
    byte [] buf = new byte [8 * 1024];
    while ((read = is.read (buf)) > 0) {
        inputLen += read;
        dos.write (buf, 0, read);
    }
    dos.close ();
    byte [] data = bos.toByteArray ();
    ExtZipEntry entry = new ExtZipEntry (name);
    entry.setMethod (ZipEntry.DEFLATED);
    entry.setSize (inputLen);
    entry.setCompressedSize (data.length + 28);
    entry.setTime ((new java.util.Date ()).getTime ());
    entry.initEncryptedEntry ();
    zipOS.putNextEntry (entry);
    zipOS.writeBytes (encrypter.getSalt ());
    zipOS.writeBytes (encrypter.getPwVerification ());
    encrypter.encrypt (data, data.length);
    zipOS.writeBytes (data, 0, data.length);
    byte [] finalAuthentication = encrypter.getFinalAuthentication ();
    if (LOG.isLoggable (Level.FINE)) {
        LOG.fine ("finalAuthentication=" + Arrays.toString (finalAuthentication) + " at pos=" + zipOS.getWritten ());
    }
    zipOS.writeBytes (finalAuthentication);
}


-----Function Pair=154=-----==

protected static void checkZipEntry (AesZipFileDecrypter aesDecryptor, String fileName, String fileContent, String password) throws Exception {
    ExtZipEntry entry = aesDecryptor.getEntry (fileName);
    if (entry == null) {
        throw new FileNotFoundException (fileName);
    }
    File decFile = getOutFile ("extractedFile.txt");
    aesDecryptor.extractEntry (entry, decFile, password);
    aesDecryptor.extractEntryWithTmpFile (entry, decFile, password);
    BufferedReader fr = new BufferedReader (new FileReader (decFile));
    String line = fr.readLine ();
    if (decFile.length () > 0) {
        assertEquals (fileContent, line);
    }
    else {
        assertEquals (null, line);
    }
    decFile.delete ();
}


public static int zipIt (String folder_that_contains_the_files) {
    if (folder_that_contains_the_files == null) return 0;
    try {
        String path_zip_file = OctopusApplication.PATH_EXPORT_FOLDER + folder_that_contains_the_files + ".zip";
        folder_that_contains_the_files = OctopusApplication.PATH_EXPORT_FOLDER + folder_that_contains_the_files;
        File zipFile = new File (path_zip_file);
        if (zipFile.exists ()) {
            return 0;
        }
        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipFile)));
        File file = new File (folder_that_contains_the_files);
        if (file.isFile ()) {
            addTargetFile (zos, file);
        }
        else if (file.isDirectory ()) {
            ArrayList names = pathNames (file);
            Iterator it = names.iterator ();
            while (it.hasNext ()) {
                File f = new File ((String) it.next ());
                addTargetFile (zos, f);
            }
        }
        zos.close ();
        return 1;
    } catch (FileNotFoundException e) {
        return 0;
    } catch (ZipException e) {
        return 0;
    } catch (IOException e) {
        return 0;
    } catch (Exception e) {
        return 0;
    }
}


-----Function Pair=155=-----=1=

public synchronized boolean writeFile (String filename, InputStream stream) throws IOException {
    if (fileSent) return false;
    BufferedInputStream origin = new BufferedInputStream (stream, BUFFER);
    try {
        byte data [] = new byte [BUFFER];
        ZipEntry entry = new ZipEntry (filename);
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        fileWritten = true;
        interrupt ();
        return true;
    } catch (IOException e) {
        LOG.error ("Error writing to zip file '" + zipFile + "'", e);
        interrupt ();
        throw e;
    } finally {
        CloseUtils.safeClose (origin);
    }
}


public Archive save (OutputStream dest) throws IOException {
    ZipOutputStream out;
    InputStream in;
    List < Node > content;
    List < Node > files;
    out = new ZipOutputStream (dest);
    out.putNextEntry (new ZipEntry ("/"));
    out.closeEntry ();
    if (manifest != null) {
        out.putNextEntry (new ZipEntry (MANIFEST));
        manifest.write (out);
        out.closeEntry ();
    }
    content = data.find ("**/*");
    files = new ArrayList < Node > ();
    for (Node node : content) {
        if (isManifest (node)) {
            throw new ArchiveException ("manifest file not allowed");
        }
        else if (node.isFile ()) {
            files.add (node);
        }
        else {
            out.putNextEntry (new ZipEntry (node.getPath () + "/"));
            out.closeEntry ();
        }
    }
    for (Node file : files) {
        in = file.createInputStream ();
        out.putNextEntry (new ZipEntry (file.getPath ()));
        file.getWorld ().getBuffer ().copy (in, out);
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    return this;
}


-----Function Pair=156=-----==

public static SamplePackage createSamplePackage (SampleContext sc, Integer [] samples, String name, String notes, Map customObjectMap, AudioFileFormat.Type format) throws PackageGenerationException {
    try {
        if (! sc.getDeviceContext ().isSmdiCoupled () && SampleContextMacros.extractUserIndexes (samples).length > 0) throw new PackageGenerationException ("Cannot not retrieve samples for package - the device is not SMDI coupled");
        Impl_SamplePackageHeader header = new Impl_SamplePackageHeader ();
        header.setCreationDate (new Date ());
        header.setNotes (notes);
        header.setName (name);
        header.setDeviceVersion (sc.getDeviceContext ().getDeviceVersion ());
        header.setDeviceName (sc.getDeviceContext ().getName ());
        ArrayList isl = new ArrayList ();
        for (int i = 0; i < samples.length; i ++) {
            try {
                isl.add (sc.getIsolated (samples [i], format));
            } catch (DeviceException e) {
                throw new PackageGenerationException (e.getMessage ());
            } catch (EmptyException e) {
            }
        }
        IsolatedSample [] isoSamples = (IsolatedSample []) isl.toArray (new IsolatedSample [isl.size ()]);
        header.setSampleCount (isoSamples.length);
        header.setPhysicalSampleCount (isoSamples.length - romSampleCount (isoSamples));
        Impl_SamplePackage pkg = new Impl_SamplePackage (isoSamples);
        if (customObjectMap != null) if (ZUtilities.isMapContentsSerializable (customObjectMap)) pkg.setCustomObjectMap (customObjectMap);
        else throw new PackageGenerationException ("CustomObjectMap not serializable");
        pkg.setHeader (header);
        return pkg;
    } catch (Exception e) {
        throw new PackageGenerationException (e.getMessage ());
    }
}


public void backupFiles (File rootDir, String [] fileNames, String zipName) throws IOException {
    ArrayList files = new ArrayList ();
    Stack pathStack = new Stack ();
    File file;
    FileOutputStream fos = null;
    ZipOutputStream zos = null;
    String path;
    for (int x = 0; x < fileNames.length; x ++) {
        file = new File (rootDir, fileNames [x]);
        pathStack = new Stack ();
        if (file.exists ()) {
            pathStack.push (fileNames [x]);
            scanFile (file, pathStack, files);
        }
        else {
            log.info ("File " + file.getPath () + " not found");
        }
    }
    if (files.size () > 0) {
        fos = new FileOutputStream (new File (rootDir, zipName));
        zos = new ZipOutputStream (fos);
        for (Iterator i = files.iterator (); i.hasNext ();) {
            path = (String) i.next ();
            file = new File (rootDir, path);
            addFile (path, file, zos);
        }
        zos.flush ();
        zos.close ();
        fos.close ();
    }
}


-----Function Pair=157=-----==

private boolean saveLOBDataToDB () {
    if (m_items == null || m_items.size () == 0) {
        setBinaryData (null);
        return true;
    }
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    ZipOutputStream zip = new ZipOutputStream (out);
    zip.setMethod (ZipOutputStream.DEFLATED);
    zip.setLevel (Deflater.BEST_COMPRESSION);
    zip.setComment ("adempiere");
    try {
        for (int i = 0; i < m_items.size (); i ++) {
            MAttachmentEntry item = getEntry (i);
            ZipEntry entry = new ZipEntry (item.getName ());
            entry.setTime (System.currentTimeMillis ());
            entry.setMethod (ZipEntry.DEFLATED);
            zip.putNextEntry (entry);
            byte [] data = item.getData ();
            zip.write (data, 0, data.length);
            zip.closeEntry ();
            log.fine (entry.getName () + " - " + entry.getCompressedSize () + " (" + entry.getSize () + ") " + (entry.getCompressedSize () * 100 / entry.getSize ()) + "%");
        }
        zip.close ();
        byte [] zipData = out.toByteArray ();
        log.fine ("Length=" + zipData.length);
        setBinaryData (zipData);
        return true;
    } catch (Exception e) {
        log.log (Level.SEVERE, "saveLOBData", e);
    }
    setBinaryData (null);
    return false;
}


private Message createEmail (final File file) {
    try {
        final Properties props = new Properties ();
        props.put ("mail.smtp.host", config.getSmtpHost ());
        props.put ("mail.smtp.port", Integer.toString (config.getSmtpPort ()));
        final Session session = Session.getDefaultInstance (props, new Authenticator () {
            protected PasswordAuthentication getPasswordAuthentication () {
                return new PasswordAuthentication (config.getSmtpUserName (), config.getSmtpPassword ());
            }
        }
        );
        final Message message = new MimeMessage (session);
        message.setFrom (new InternetAddress (config.getFromAddress (), config.getFromName ()));
        message.setRecipient (Message.RecipientType.TO, new InternetAddress (config.getToAddress (), config.getToName ()));
        message.setSubject (config.getSubject ());
        message.setSentDate (new Date ());
        final MimeMultipart multipart = new MimeMultipart ();
        message.setContent (multipart);
        final BodyPart attachment = new MimeBodyPart ();
        attachment.setFileName ("unknown-devices.zip");
        final DataSource ds = new URLDataSource (file.toURL ());
        attachment.setDataHandler (new DataHandler (ds));
        attachment.setHeader ("Content-ID", "");
        multipart.addBodyPart (attachment);
        return message;
    } catch (Exception e) {
        LOGGER.warn ("unable-to-create-email", e);
        return null;
    }
}


-----Function Pair=158=-----==

public static UpdateInfo readFrom (File zip) {
    ZipEntry z;
    UpdateInfo v = null;
    FileInputStream fi = null;
    try {
        fi = new FileInputStream (zip);
        ZipInputStream stream = new ZipInputStream (new BufferedInputStream (fi));
        while (true) {
            z = stream.getNextEntry ();
            if (z == null) {
                break;
            }
            if (z.getName ().equals (VHEADER)) {
                XMLDecoder dec = new XMLDecoder (stream);
                v = (UpdateInfo) dec.readObject ();
                break;
            }
        }
    } catch (Exception e) {
    } finally {
        if (fi != null) {
            try {
                fi.close ();
            } catch (IOException e) {
            }
        }
    }
    return v;
}


private void UpdateCode (NpsContext ctxt) throws Exception {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        String sql = "update EVENT_TRIGGER set code=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "select code from EVENT_TRIGGER where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            writer.write (code);
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=159=-----==

private static void init () {
    initialized = true;
    InputStream is = Dosbox.class.getResourceAsStream ("Cache.index");
    if (is != null) {
        DataInputStream dis = new DataInputStream (is);
        try {
            int count = dis.readInt ();
            for (int i = 0; i < count; i ++) {
                Item item = new Item ();
                item.name = dis.readUTF ();
                item.start = dis.readInt ();
                int len = dis.readInt ();
                item.opCodes = new byte [len];
                dis.readFully (item.opCodes);
                Integer key = new Integer (item.start);
                Vector bucket = (Vector) items.get (key);
                if (bucket == null) {
                    bucket = new Vector ();
                    items.put (key, bucket);
                }
                bucket.addElement (item);
            }
            System.out.println ("Loaded " + count + " blocks");
        } catch (Exception e) {
            e.printStackTrace ();
        }
        try {
            dis.close ();
        } catch (Exception e) {
        }
    }
}


public static void decompileClass (String className, ZipOutputStream destZip, String destDir, TabbedPrintWriter writer, ImportHandler imports) {
    try {
        ClassInfo clazz;
        try {
            clazz = ClassInfo.forName (className);
        } catch (IllegalArgumentException ex) {
            GlobalOptions.err.println ("`" + className + "' is not a class name");
            return;
        }
        if (skipClass (clazz)) return;
        String filename = className.replace ('.', File.separatorChar) + ".java";
        if (destZip != null) {
            writer.flush ();
            destZip.putNextEntry (new ZipEntry (filename));
        }
        else if (destDir != null) {
            File file = new File (destDir, filename);
            File directory = new File (file.getParent ());
            if (! directory.exists () && ! directory.mkdirs ()) {
                GlobalOptions.err.println ("Could not create directory " + directory.getPath () + ", check permissions.");
            }
            writer = new TabbedPrintWriter (new BufferedOutputStream (new FileOutputStream (file)), imports, false);
        }
        GlobalOptions.err.println (className);
        ClassAnalyzer clazzAna = new ClassAnalyzer (clazz, imports);
        clazzAna.dumpJavaFile (writer);
        if (destZip != null) {
            writer.flush ();
            destZip.closeEntry ();
        }
        else if (destDir != null) writer.close ();
        System.gc ();
        successCount ++;
    } catch (IOException ex) {
        failedClasses.addElement (className);
        GlobalOptions.err.println ("Can't write source of " + className + ".");
        GlobalOptions.err.println ("Check the permissions.");
        ex.printStackTrace (GlobalOptions.err);
    } catch (Throwable t) {
        failedClasses.addElement (className);
        GlobalOptions.err.println ("Failed to decompile " + className + ".");
        t.printStackTrace (GlobalOptions.err);
    }
}


-----Function Pair=160=-----==

private static void copyFiles (File directory, IAlgorithmDescription [] descr) throws IOException {
    File programDirectory = JSelectDirectoryDialog.getProgramDirectory ();
    for (IAlgorithmDescription des : descr) {
        if (des instanceof RemoteAlgorithmDescription) {
            Bonesa.saveToFile (((RemoteAlgorithmDescription) des).getRoot (), directory.getCanonicalPath () + File.separator + Utils.convertNameToSaveName (des.getName ()) + ".bda");
        }
        else {
            Bonesa.saveToFile (des, directory.getCanonicalPath () + File.separator + Utils.convertNameToSaveName (des.getName ()) + ".bda");
        }
    }
    FileUtils.copyFileToDirectory (new File (programDirectory.getCanonicalPath () + File.separator + "ParameterTuning.jar"), directory);
    FileUtils.copyFileToDirectory (new File (programDirectory.getCanonicalPath () + File.separator + "SATINDistribution.jar"), directory);
    FileUtils.copyFileToDirectory (Bonesa.getParameterTunerJar (), new File (directory.getCanonicalPath () + File.separator + "plugins"));
    FileUtils.copyFileToDirectory (new File (programDirectory.getCanonicalPath () + File.separator + "log4j.properties"), directory);
    FileUtils.copyDirectoryToDirectory (new File (programDirectory.getCanonicalPath () + File.separator + "lib"), directory);
    if (new File (programDirectory.getCanonicalPath () + File.separator + "runtime").exists ()) {
        FileUtils.copyDirectoryToDirectory (new File (programDirectory.getCanonicalPath () + File.separator + "runtime"), directory);
    }
}


private byte [] remTunerFromList (HTTPurl urlData) throws Exception {
    int tunerIndex = - 1;
    try {
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount ()) {
                devList.remDevice (tunerIndex);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=161=-----=1=

public static boolean replaceFile (String archive, String toReplace, String newReplace) {
    try {
        String tempFile = archive + ".copy";
        com.araya.utilities.FileTextReplacer.copyFile (archive, tempFile);
        byte [] buf = new byte [1024];
        ZipInputStream zin = new ZipInputStream (new FileInputStream (tempFile));
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (archive));
        ZipEntry entry = zin.getNextEntry ();
        while (entry != null) {
            String name = entry.getName ();
            name = name.replaceAll ("\\\\", "/");
            if (toReplace.equals (name)) {
            }
            else {
                out.putNextEntry (new ZipEntry (name));
                int len;
                while ((len = zin.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
            }
            entry = zin.getNextEntry ();
        }
        zin.close ();
        InputStream in = new FileInputStream (newReplace);
        out.putNextEntry (new ZipEntry (toReplace));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
        out.close ();
        File temp = new File (tempFile);
        temp.delete ();
        return true;
    } catch (Exception ex) {
        ex.printStackTrace ();
        return false;
    }
}


public static void addFilesToExistingZip (File zipFile, File [] files) throws IOException {
    File tempFile = File.createTempFile (zipFile.getName (), null);
    tempFile.delete ();
    boolean renameOk = zipFile.renameTo (tempFile);
    if (! renameOk) {
        throw new RuntimeException ("could not rename the file " + zipFile.getAbsolutePath () + " to " + tempFile.getAbsolutePath ());
    }
    byte [] buf = new byte [1024];
    ZipInputStream zin = new ZipInputStream (new FileInputStream (tempFile));
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    ZipEntry entry = zin.getNextEntry ();
    while (entry != null) {
        String name = entry.getName ();
        boolean notInFiles = true;
        for (File f : files) {
            if (f.getName ().equals (name)) {
                notInFiles = false;
                break;
            }
        }
        if (notInFiles) {
            out.putNextEntry (new ZipEntry (name));
            int len;
            while ((len = zin.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
        }
        entry = zin.getNextEntry ();
    }
    zin.close ();
    for (int i = 0; i < files.length; i ++) {
        InputStream in = new FileInputStream (files [i]);
        out.putNextEntry (new ZipEntry (files [i].getName ()));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    tempFile.delete ();
}


-----Function Pair=162=-----==

private InstrumentContainer readInstruments (String filename) {
    ObjectInputStream in = null;
    ZipInputStream zipin = null;
    InstrumentContainer ic = null;
    try {
        zipin = new ZipInputStream (new FileInputStream (filename));
        ZipEntry ze = zipin.getNextEntry ();
        while (! ze.getName ().equals (INSTRUMENT_CONTAINER_NAME)) {
            shapes.importShape (zipin, ze.getName ());
            zipin.closeEntry ();
            ze = zipin.getNextEntry ();
        }
        in = new ObjectInputStream (zipin);
        ic = (InstrumentContainer) in.readObject ();
        in.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
    return ic;
}


public long getComputedDownloadSize () throws IOException {
    OutputStreamCounter osc = new OutputStreamCounter ();
    ZipOutputStream zos = new ZipOutputStream (osc);
    List < Media > list = getMediaList ();
    if (list == null || list.size () == 0) return 0;
    for (Media m : list) {
        ZipEntry ze = new ZipEntry (m.file.getName ());
        ze.setMethod (ZipEntry.STORED);
        ze.setCrc (Utils.getDummyCRC (m.file.length ()));
        ze.setSize (m.file.length ());
        zos.putNextEntry (ze);
        Utils.serveDummyData (m.file.length (), zos);
        zos.closeEntry ();
    }
    zos.flush ();
    zos.finish ();
    zos.close ();
    return osc.getCount ();
}


-----Function Pair=163=-----==

public MainForm () {
    initComponents ();
    File [] f = File.listRoots ();
    for (int i = 0; i < f.length; i ++) {
        cb_leftPath.addItem (f [i].toString ());
        cb_rightPath.addItem (f [i].toString ());
    }
    cb_leftPath.getItemAt (0);
    cb_rightPath.getItemAt (0);
    leftPath = (cb_leftPath.getItemAt (0).toString ());
    rightPath = (cb_rightPath.getItemAt (0).toString ());
    LeftPath.setText (leftPath + "*.*");
    RightPath.setText (rightPath + "*.*");
    jListDisplay (leftPath, jList1);
    jListDisplay (rightPath, jList2);
    ActionListener actionListener1 = new ActionListener () {
        public void actionPerformed (ActionEvent actionEvent) {
            leftPath = cb_leftPath.getSelectedItem ().toString ();
            jListDisplay (leftPath, jList1);
            LeftPath.setText (leftPath + "*.*");
        }
    }
    ;
    ActionListener actionListener2 = new ActionListener () {
        public void actionPerformed (ActionEvent actionEvent) {
            rightPath = cb_rightPath.getSelectedItem ().toString ();
            jListDisplay (rightPath, jList2);
            RightPath.setText (rightPath + "*.*");
        }
    }
    ;
    cb_leftPath.addActionListener (actionListener1);
    cb_rightPath.addActionListener (actionListener2);
    File newFolder = new File ("BackUp");
    newFolder.mkdirs ();
}


public void load (Map < ?, ? > options) throws IOException {
    if (! isLoaded) {
        URIConverter uriConverter = getURIConverter ();
        Map < ?, ? > response = options == null ? null : (Map < ?, ? >) options.get (URIConverter.OPTION_RESPONSE);
        if (response == null) {
            response = new HashMap < Object, Object > ();
        }
        InputStream inputStream = null;
        try {
            inputStream = uriConverter.createInputStream (getURI (), new ExtensibleURIConverterImpl.OptionsMap (URIConverter.OPTION_RESPONSE, response, options));
        } catch (IOException exception) {
            Notification notification = setLoaded (true);
            isLoading = true;
            if (errors != null) {
                errors.clear ();
            }
            if (warnings != null) {
                warnings.clear ();
            }
            isLoading = false;
            if (notification != null) {
                eNotify (notification);
            }
            setModified (false);
            throw exception;
        }
        try {
            load (inputStream, options);
        } finally {
            inputStream.close ();
            Long timeStamp = (Long) response.get (URIConverter.RESPONSE_TIME_STAMP_PROPERTY);
            if (timeStamp != null) {
                setTimeStamp (timeStamp);
            }
        }
    }
}


-----Function Pair=164=-----==

private String formatComFile () {
    if (comFile == null) return NONE;
    List < Integer > list = comFile.getDGNumbers ();
    String result = "Data groups:";
    for (Integer i : list) {
        result += " DG" + i.toString ();
    }
    result += "\n";
    SecurityObjectIndicator [] sois = comFile.getSOIArray ();
    if (sois.length > 0) {
        result += "Security Object Indicators:\n";
        for (SecurityObjectIndicator soi : sois) {
            result += "  " + soi.toString () + "\n";
        }
    }
    result = result.substring (0, result.length () - 1);
    return result;
}


private void ZipPageTemplates (ZipOutputStream out) throws Exception {
    if (page_templates == null || page_templates.isEmpty ()) return;
    String filename = "TOPIC" + GetId () + ".pts";
    out.putNextEntry (new ZipEntry (filename));
    try {
        ZipWriter writer = new ZipWriter (out);
        for (Object obj : page_templates) {
            PageTemplate pt = (PageTemplate) obj;
            if (pt != null) {
                writer.println (pt.GetId ());
            }
        }
    } finally {
        out.closeEntry ();
    }
}


-----Function Pair=165=-----==

private void addZipEntry (final int bufsize, final ZipOutputStream zos, final byte [] input_buffer, final File file) throws IOException {
    this.log.debug ("Adding zip entry for file {}", file);
    if (file.exists () && file.isFile ()) {
        final ZipEntry zip_entry = new ZipEntry (file.getName ());
        if (this.zipEntries.contains (file.getName ())) {
            this.log.info ("Skipping duplicate zip entry {}", file.getName ());
            return;
        }
        else {
            this.zipEntries.add (file.getName ());
        }
        zos.putNextEntry (zip_entry);
        final FileInputStream in = new FileInputStream (file);
        final BufferedInputStream source = new BufferedInputStream (in, bufsize);
        int len = 0;
        while ((len = source.read (input_buffer, 0, bufsize)) != - 1) {
            zos.write (input_buffer, 0, len);
        }
        zos.flush ();
        source.close ();
        zos.closeEntry ();
    }
    else {
        this.log.warn ("Skipping nonexistant file or directory {}", file);
    }
}


private void createGroundOverlays () {
    for (String s : layers) {
        for (int i = start; i < end; i ++) {
            final GroundOverlay groundoverlay;
            groundoverlay = document.createAndAddGroundOverlay ();
            boolean visibility = (i == start) ? true : false;
            groundoverlay.withName (s + i).withVisibility (visibility).withId (s + i);
            groundoverlay.createAndSetIcon ().withHref (s + "_" + i + ".png").withViewBoundScale (0.75d);
            if (s.equals (Consts.LAYER_HIGH_CLOUD)) {
                groundoverlay.withAltitude (highCloudAlt);
                groundoverlay.withColor ("90ffffff");
            }
            else if (s.equals (Consts.LAYER_LOW_CLOUD)) {
                groundoverlay.withAltitude (lowCloudAlt);
                groundoverlay.withColor ("b4a9a9aa");
            }
            else if (s.equals (Consts.LAYER_MID_CLOUD)) {
                groundoverlay.withAltitude (midCloudAlt);
                groundoverlay.withColor ("7affffff");
            }
            else if (s.equals (Consts.LAYER_RAIN)) {
                groundoverlay.withAltitude (rainAlt);
            }
            groundoverlay.withAltitudeMode (AltitudeMode.ABSOLUTE);
            double S = Consts.DOMAIN_START_Y;
            double N = S + (Consts.DOMAIN_ROW_INTERVAL * Consts.DOMAIN_ROWS);
            double W = Consts.DOMAIN_START_X;
            double E = W + (Consts.DOMAIN_COL_INTERVAL * Consts.DOMAIN_COLS);
            groundoverlay.createAndSetLatLonBox ().withNorth (N).withSouth (S).withEast (E).withWest (W);
        }
    }
}


-----Function Pair=166=-----==

public static Collection < File > getListeFile (File directory, String expressionSearch, boolean parseSubDirectory, boolean restrictifExpression) throws IOException {
    Collection < File > listeFiles = new ArrayList < File > ();
    String [] listePathFile = null;
    if (parseSubDirectory) {
        FileFilter directoryFilter = new FileFilter () {
            public boolean accept (File file) {
                return file.isDirectory ();
            }
        }
        ;
        File [] listeDirectory = directory.listFiles (directoryFilter);
        for (int j = 0; j < listeDirectory.length; j ++) {
            File subDirectory = listeDirectory [j];
            listeFiles.addAll (getListeFile (subDirectory, expressionSearch, true, restrictifExpression));
        }
    }
    listePathFile = directory.list (new FileFilterName (expressionSearch));
    if (listePathFile != null) {
        for (int i = 0; i < listePathFile.length; i ++) {
            File file = new File (directory.getAbsolutePath () + File.separator + listePathFile [i]);
            if (! file.isDirectory ()) {
                listeFiles.add (file);
            }
        }
    }
    return listeFiles;
}


private Element exportAspectInfo (ZipOutputStream out, ProjectAspect aspect) {
    if (aspect.getAspectType ().isDevelopment ()) {
        Element info = new Element (FDDI.INFO);
        Element subjectName = new Element (FDDI.SUBJECT_NAME);
        subjectName.setText (FDDPMA.SUBJECT_AREA);
        info.addContent (subjectName);
        Element activityName = new Element (FDDI.ACTIVITY_NAME);
        activityName.setText (FDDPMA.BUSINESS_ACTIVITY);
        info.addContent (activityName);
        Element featureName = new Element (FDDI.FEATURE_NAME);
        featureName.setText (FDDPMA.FEATURE);
        info.addContent (featureName);
        Element milestoneName = new Element (FDDI.MILESTONE_NAME);
        milestoneName.setText (FDDPMA.MILESTONE);
        info.addContent (milestoneName);
        MilestoneSetDescription milestones = aspect.getAspectType ().getMilestones ();
        Iterator < MilestoneDescription > iter = milestones.listMilestones ().iterator ();
        while (iter.hasNext ()) {
            MilestoneDescription md = iter.next ();
            Element milestoneInfo = exportMilestoneInfo (out, md);
            info.addContent (milestoneInfo);
        }
        Element milsetoneSetName = new Element (FDDPMA.MILESTONE_SET, FDDPMA.NAMESPACE);
        milsetoneSetName.setText (milestones.getName ());
        info.addContent (milsetoneSetName);
        return info;
    }
    return null;
}


-----Function Pair=167=-----==

private void copy (File fin, File fout) throws IOException {
    FileOutputStream out = null;
    FileInputStream in = null;
    try {
        out = new FileOutputStream (fout);
        in = new FileInputStream (fin);
        byte [] buf = new byte [2048];
        int read = in.read (buf);
        while (read > 0) {
            out.write (buf, 0, read);
            read = in.read (buf);
        }
    } catch (IOException _e) {
        throw _e;
    } finally {
        if (in != null) in.close ();
        if (out != null) out.close ();
    }
}


public static void copyDirectory (final File sourceDir, final File destDir) throws IOException {
    if (! destDir.exists ()) {
        destDir.mkdir ();
    }
    final File [] children = sourceDir.listFiles ();
    for (final File sourceChild : children) {
        final String name = sourceChild.getName ();
        final File destChild = new File (destDir, name);
        if (sourceChild.isDirectory ()) {
            copyDirectory (sourceChild, destChild);
        }
        else {
            copyFile (sourceChild, destChild);
        }
    }
}


-----Function Pair=168=-----==

public void setParameters (final String miningPluginArgument, final String analysisPluginArgument, final String logArgument) {
    SwingWorker worker = new SwingWorker () {
        private LogFile file;
        private Plugin plugin;
        private LogFilter filter;
        public Object construct () {
            try {
                if (! miningPluginArgument.equals ("")) {
                    plugin = MiningPluginCollection.getInstance ().get (miningPluginArgument);
                }
                else {
                    plugin = AnalysisPluginCollection.getInstance ().get (analysisPluginArgument);
                }
                if (! (plugin instanceof DoNotCreateNewInstance)) {
                    plugin = (Plugin) plugin.getClass ().newInstance ();
                }
            } catch (InstantiationException ex) {
                Message.add ("Could not create a new instance of the selected algorithm: " + miningPluginArgument + analysisPluginArgument, Message.ERROR);
            } catch (IllegalAccessException ex) {
                Message.add ("Could not create a new instance of the selected algorithm: " + miningPluginArgument + analysisPluginArgument, Message.ERROR);
            } catch (NullPointerException ex) {
                Class pluginClass = null;
                try {
                    pluginClass = Class.forName (miningPluginArgument + analysisPluginArgument, true, Thread.currentThread ().getContextClassLoader ());
                    plugin = (Plugin) pluginClass.newInstance ();
                } catch (ClassNotFoundException ex1) {
                    Message.add ("Could not create a new instance of the selected algorithm: " + miningPluginArgument + analysisPluginArgument, Message.ERROR);
                } catch (IllegalAccessException ex2) {
                    Message.add ("Could not create a new instance of the selected algorithm: " + miningPluginArgument + analysisPluginArgument, Message.ERROR);
                } catch (InstantiationException ex2) {
                    Message.add ("Could not create a new instance of the selected algorithm: " + miningPluginArgument + analysisPluginArgument, Message.ERROR);
                }
            }
            try {
                file = LogFile.getInstance (logArgument);
                file.getInputStream ();
            } catch (Exception e) {
                file = null;
            }
            if (! logArgument.equals ("") && file == null) {
                if (plugin != null && plugin instanceof AnalysisPlugin) {
                    try {
                        file = LogFile.instantiateEmptyLogFile (logArgument);
                        filter = new DefaultLogFilter (DefaultLogFilter.INCLUDE);
                    } catch (IOException ex3) {
                        Message.add ("Cannot create empty Log file: " + logArgument, Message.ERROR);
                        file = null;
                        filter = null;
                    }
                }
            }
            else if (file != null) {
                OpenLogSettings frame = MainUI.getInstance ().createOpenLogFrame (file);
                while (frame.getProvidedObjects () == null || frame.getProvidedObjects ().length == 0) {
                    try {
                        sleep (1000);
                    } catch (InterruptedException ex4) {
                        break;
                    }
                }
                filter = frame.getLogFilter ();
            }
            return null;
        } public void finished () {
            if (plugin == null && file == null) {
                return;
            }
            Message.add ("Selected log file succesfully loaded.");
            SwingWorker w = new SwingWorker () {
                public Object construct () {
                    MainUI.getInstance ().addAction (plugin, LogStateMachine.START, new Object [] {file});
                    LogReader log = null;
                    try {
                        if (file != null) {
                            log = LogReaderFactory.createInstance (filter, file);
                        }
                    } catch (Exception e) {
                        e.printStackTrace ();
                        return null;
                    }
                    if (! miningPluginArgument.equals ("")) {
                        return ((MiningPlugin) plugin).mine (log);
                    }
                    else {
                        AnalysisInputItem item = new AnalysisInputItem ("Provided Log file");
                        ProvidedObject logObject = new ProvidedObject ("Log file", (log == null ? new Object [] {STARTEDFROMCOMMANDLINE} : new Object [] {log, STARTEDFROMCOMMANDLINE}));
                        item.setProvidedObjects (new ProvidedObject [] {logObject});
                        return ((AnalysisPlugin) plugin).analyse (new AnalysisInputItem [] {item});
                    }
                } public void finished () {
                    if (get () != null) {
                        MainUI.getInstance ().addAction (plugin, LogStateMachine.COMPLETE, new Object [] {((Provider) get ()).getProvidedObjects ()});
                        if (get () instanceof MiningResult) {
                            MainUI.getInstance ().createVisualizationFrame ("Results - " + logArgument + " using " + miningPluginArgument, (MiningResult) get (), plugin);
                        }
                        else if (get () instanceof JComponent) {
                            MainUI.getInstance ().createFrame ("Results - " + logArgument + " using " + analysisPluginArgument, (JComponent) get ());
                        }
                    }
                }
            }
            ;
            w.start ();
        }
    }
    ;
    worker.start ();
}


public void saveSubProject (final String filename, final ProjectHolder aHolder) {
    working = true;
    projectTree.setCursor (new Cursor (Cursor.WAIT_CURSOR));
    Thread aThread = new Thread (new Runnable () {
        public void run () {
            if (filename != null) {
                String newFilename;
                projectTree.setCursor (new Cursor (Cursor.WAIT_CURSOR));
                showStatus ("Saving...");
                if (filename.lastIndexOf (".pb") == - 1) newFilename = filename + ".pb";
                else newFilename = filename;
                Document doc = new DocumentImpl ();
                Element rt = (Element) doc.createElement ("ROOT");
                doc.appendChild (rt);
                if (aHolder == root) {
                    Element el = (Element) doc.createElement ("ProjectVersion");
                    el.appendChild (doc.createTextNode (projectDetail.getProjectVersion ()));
                    rt.appendChild (el);
                    el = (Element) doc.createElement ("ProjectDescription");
                    el.appendChild (doc.createTextNode (projectDetail.getProjectDescription ()));
                    rt.appendChild (el);
                    env.saveEnvironment (doc, rt);
                }
                outputMembers (null, aHolder, doc, rt);
                try {
                    FileWriter fw = new FileWriter (filename);
                    XMLSerializer xmlWriter = new XMLSerializer (new OutputFormat ());
                    xmlWriter.setOutputCharStream (fw);
                    xmlWriter.serialize (doc);
                    fw.close ();
                } catch (Exception ex) {
                    System.out.println (ex);
                }
                working = false;
                projectTree.setCursor (new Cursor (Cursor.DEFAULT_CURSOR));
                showStatus (" ");
            }
        }
    }
    );
    aThread.start ();
}


-----Function Pair=169=-----==

private static boolean unzipWithWarning (File source, File targetDirectory, OverwriteValue policy) {
    try {
        if (! source.exists ()) return false;
        ZipInputStream input = new ZipInputStream (new FileInputStream (source));
        ZipEntry zipEntry = null;
        byte [] buffer = new byte [1024];
        while ((zipEntry = input.getNextEntry ()) != null) {
            if (zipEntry.isDirectory ()) continue;
            File newFile = new File (targetDirectory, zipEntry.getName ());
            if (newFile.exists ()) {
                switch (policy.value) {
                    case NO_TO_ALL :
                        continue;
                    case YES_TO_ALL :
                        break;
                    default :
                        switch (policy.value = confirmOverwrite (zipEntry.getName ())) {
                            case NO_TO_ALL :
                            case NO :
                                continue;
                            default :
                        }
                }
            }
            newFile.getParentFile ().mkdirs ();
            int bytesRead;
            FileOutputStream output = new FileOutputStream (newFile);
            while ((bytesRead = input.read (buffer)) != - 1) output.write (buffer, 0, bytesRead);
            output.close ();
            input.closeEntry ();
        }
        input.close ();
    } catch (Exception exc) {
        exc.printStackTrace ();
        return false;
    }
    return true;
}


public synchronized void setCommandLineArg (String userId, String selected_concrete, String selected_job, String commandline) {
    try {
        Vector < JobPropertyBean > jobs = getConfigData (userId, selected_concrete);
        Vector < JobPropertyBean > new_jobs = new Vector < JobPropertyBean > ();
        for (int i = 0; i < jobs.size (); ++ i) {
            JobPropertyBean actjob = jobs.get (i);
            if (actjob.getName ().equals (new String (selected_job))) {
                actjob.getExe ().put ("params", commandline);
            }
            new_jobs.add (actjob);
        }
        saveConfigData (userId, selected_concrete, new_jobs);
    } catch (ClassNotFoundException ex) {
        ex.printStackTrace ();
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
        ex.printStackTrace ();
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
        ex.printStackTrace ();
        Logger.getLogger (ASMService.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


-----Function Pair=170=-----==

public void exportTeX (File file, Tasks task) throws IOException {
    Tasks.getTaskView ().setCancelable (true);
    task.setOperationName ("Exporting jobs to TeX file");
    if (file.exists ()) {
        file.delete ();
    }
    PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter (file)));
    String format = "|";
    String columns = "";
    for (int i = 0; i < main.tableJobs.getColumnCount (); i ++) {
        int vis_col = main.tableJobs.convertColumnIndexToModel (i);
        columns += main.jobsTableModel.getColumnName (vis_col);
        if (main.jobsTableModel.getColumnClass (vis_col) == Integer.class || main.jobsTableModel.getColumnClass (vis_col) == Double.class || main.jobsTableModel.getColumnClass (vis_col) == Float.class || main.jobsTableModel.getColumnClass (vis_col) == int.class || main.jobsTableModel.getColumnClass (vis_col) == double.class || main.jobsTableModel.getColumnClass (vis_col) == float.class) {
            format += "r|";
        }
        else {
            format += "l|";
        }
        if (i < main.jobsTableModel.getColumnCount () - 1) {
            columns += "&";
        }
    }
    out.write ("\\documentclass[a4paper]{report}\n");
    out.write ("\\title{Results of " + activeExperiment.getName () + "}\n");
    out.write ("\\begin{document}\n");
    out.write ("\\begin{tabular}[h]{" + format + "}\n");
    out.write ("\\hline\n");
    out.write (columns + " \\\\\n");
    out.write ("\\hline\n");
    int total = main.getTableJobs ().getRowCount ();
    int done = 0;
    for (int i = 0; i < main.tableJobs.getRowCount (); i ++) {
        int vis = main.getTableJobs ().convertRowIndexToModel (i);
        done ++;
        task.setTaskProgress ((float) done / (float) total);
        if (task.isCancelled ()) {
            task.setStatus ("Cancelled");
            break;
        }
        task.setStatus ("Exporting row " + done + " of " + total);
        for (int col = 0; col < main.tableJobs.getColumnCount (); col ++) {
            int vis_col = main.tableJobs.convertColumnIndexToModel (col);
            if (main.jobsTableModel.getValueAt (vis, vis_col) == null) {
                out.write ("-");
            }
            else {
                out.write (main.jobsTableModel.getValueAt (vis, vis_col).toString ());
            }
            if (col < main.jobsTableModel.getColumnCount () - 1) {
                out.write (" & ");
            }
        }
        out.write ("\\\\\n");
    }
    out.write ("\\hline\n");
    out.write ("\\end{tabular}\n");
    out.write ("\\end{document}\n");
    out.flush ();
    out.close ();
}


private static void zip (ZipOutputStream zo, File root, File file) throws IOException {
    String rootPath = root.getAbsolutePath ();
    String path = file.getAbsolutePath ();
    path = path.replace ('\\', '/');
    if (file.isDirectory ()) {
        path = path + "/";
    }
    String name = path.substring (rootPath.length ());
    if (Utils.isEmptyString (name)) {
        name = file.getName ();
    }
    ZipEntry entry = new ZipEntry (name);
    if (file.isFile ()) {
        zo.putNextEntry (entry);
        BufferedInputStream is = new BufferedInputStream (new FileInputStream (file));
        byte [] buff = new byte [4096];
        int read;
        while ((read = is.read (buff)) > 0) {
            zo.write (buff, 0, read);
        }
        zo.closeEntry ();
    }
    else if (file.isDirectory ()) {
        zo.putNextEntry (entry);
        zo.closeEntry ();
        File [] files = file.listFiles ();
        if (files.length > 0) {
            for (File f : files) {
                zip (zo, root, f);
            }
        }
    }
}


-----Function Pair=171=-----=1=

public ActionForward execute (ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {
    Locale locale = getLocale (request);
    ActionErrors errors = new ActionErrors ();
    HttpSession session = request.getSession ();
    User voUser = (User) session.getAttribute ("voUser");
    if (! voUser.isAdministrator ()) {
        log.error ("User from " + request.getRemoteAddr () + " is not authorize to use this page.");
        errors.add (ActionErrors.GLOBAL_ERROR, new ActionError ("error.voUser.authorize"));
        saveErrors (request, errors);
        return (mapping.findForward ("logon"));
    }
    String section = VOAccess.getRequestUnicodeParameter (request, "section");
    String xquery = "xquery version \"1.0\";" + "\n   let $hits := for $doc in /* return $doc, " + "\n   $count := count($hits) " + "\n" + "\n return" + "\n<query-results total_hits=\"{$count}\">" + "\n{" + "\n   for $current_doc in $hits" + "\n   let $doc_id := replace(util:document-name($current_doc), \".xml\", \"\")" + "\n   let $current_node := doc(concat(\"" + forumDB + "/\",$doc_id,\".xml\"))/DISCUSSION" + "\n   let $doc_name := $current_node/OBJECT_NAME/text()" + "\n   return" + "\n      <resource doc-uri=\"{document-uri(root($current_doc))}\" doc-id=\"{$doc_id}\" doc-name=\"{$doc_name}\">" + "\n      </resource>" + "\n}" + "\n</query-results>";
    log.debug (xquery);
    Collection col = vobs.dbaccess.CollectionsManager.getCollection (rootDB, true);
    Element resultDocument = null;
    if (null != col) {
        XQueryService service = (XQueryService) vobs.dbaccess.CollectionsManager.getService (rootDB + section, true, "XQueryService");
        ResourceSet result = service.query (xquery);
        if (result.getSize () > 0) {
            XMLResource resource = (XMLResource) result.getResource (0);
            resultDocument = (domBuild.build ((org.w3c.dom.Document) resource.getContentAsDOM ())).getRootElement ();
        }
    }
    String zipFileName = "vo_backup_" + System.currentTimeMillis () + ".zip";
    File backups_dir = new File (fileStore + "/vo_backups");
    if (! backups_dir.exists ()) {
        if (! backups_dir.mkdir ()) {
            log.debug ("Can't create backups dir " + fileStore + "/vo_backups");
            throw new Exception ("Can't create backups dir " + fileStore + "/vo_backups");
        }
    }
    File outZipFile = new File (fileStore + "/vo_backups/" + zipFileName);
    ZipOutputStream outp = null;
    try {
        outp = new ZipOutputStream (new FileOutputStream (outZipFile));
    } catch (FileNotFoundException e) {
        log.debug ("Can't create out file: " + e.toString ());
        e.printStackTrace ();
        throw new Exception ("Can't create out file: " + e.toString ());
    }
    for (Iterator it = resultDocument.getChildren ("resource").iterator (); it.hasNext ();) {
        Element res = (Element) it.next ();
        if (null == res.getAttributeValue ("doc-name") || res.getAttributeValue ("doc-name").length () == 0) {
            log.error ("Entry name of " + res.getAttributeValue ("doc-id") + " is null!");
        }
        else {
            String filePath = res.getAttributeValue ("doc-uri");
            filePath = filePath.substring (0, filePath.lastIndexOf ("/") + 1);
            filePath = filePath.replaceAll (rootDB, "");
            outp.putNextEntry (new ZipEntry (filePath + res.getAttributeValue ("doc-name").replaceAll (" ", "")));
            URL fileUrl = new URL (httpUri + res.getAttributeValue ("doc-uri"));
            URLConnection urlconn = fileUrl.openConnection ();
            InputStream inp = urlconn.getInputStream ();
            BufferedInputStream fileInp = new BufferedInputStream (inp);
            byte [] b = new byte [1024];
            int read = fileInp.read (b, 0, b.length);
            while (read > 0) {
                outp.write (b, 0, read);
                read = fileInp.read (b, 0, b.length);
            }
            inp.close ();
            fileInp.close ();
            outp.closeEntry ();
        }
    }
    outp.close ();
    return (mapping.findForward ("success"));
}


private boolean writeUninstallData () {
    try {
        UninstallData udata = UninstallData.getInstance ();
        List files = udata.getUninstalableFilesList ();
        ZipOutputStream outJar = this.idata.uninstallOutJar;
        if (outJar == null) {
            return true;
        }
        System.out.println ("[ Writing the uninstaller data ... ]");
        outJar.putNextEntry (new ZipEntry ("install.log"));
        BufferedWriter logWriter = new BufferedWriter (new OutputStreamWriter (outJar));
        logWriter.write (this.idata.getInstallPath ());
        logWriter.newLine ();
        Iterator iter = files.iterator ();
        while (iter.hasNext ()) {
            logWriter.write ((String) iter.next ());
            if (iter.hasNext ()) {
                logWriter.newLine ();
            }
        }
        logWriter.flush ();
        outJar.closeEntry ();
        outJar.putNextEntry (new ZipEntry ("jarlocation.log"));
        logWriter = new BufferedWriter (new OutputStreamWriter (outJar));
        logWriter.write (udata.getUninstallerJarFilename ());
        logWriter.newLine ();
        logWriter.write (udata.getUninstallerPath ());
        logWriter.flush ();
        outJar.closeEntry ();
        outJar.putNextEntry (new ZipEntry ("executables"));
        ObjectOutputStream execStream = new ObjectOutputStream (outJar);
        iter = udata.getExecutablesList ().iterator ();
        execStream.writeInt (udata.getExecutablesList ().size ());
        while (iter.hasNext ()) {
            ExecutableFile file = (ExecutableFile) iter.next ();
            execStream.writeObject (file);
        }
        execStream.flush ();
        outJar.closeEntry ();
        Map < String, Object > additionalData = udata.getAdditionalData ();
        if (additionalData != null && ! additionalData.isEmpty ()) {
            Iterator < String > keys = additionalData.keySet ().iterator ();
            HashSet < String > exist = new HashSet < String > ();
            while (keys != null && keys.hasNext ()) {
                String key = keys.next ();
                Object contents = additionalData.get (key);
                if ("__uninstallLibs__".equals (key)) {
                    Iterator nativeLibIter = ((List) contents).iterator ();
                    while (nativeLibIter != null && nativeLibIter.hasNext ()) {
                        String nativeLibName = (String) ((List) nativeLibIter.next ()).get (0);
                        byte [] buffer = new byte [5120];
                        long bytesCopied = 0;
                        int bytesInBuffer;
                        outJar.putNextEntry (new ZipEntry ("native/" + nativeLibName));
                        InputStream in = getClass ().getResourceAsStream ("/native/" + nativeLibName);
                        while ((bytesInBuffer = in.read (buffer)) != - 1) {
                            outJar.write (buffer, 0, bytesInBuffer);
                            bytesCopied += bytesInBuffer;
                        }
                        outJar.closeEntry ();
                    }
                }
                else if ("uninstallerListeners".equals (key) || "uninstallerJars".equals (key)) {
                    ArrayList < String > subContents = new ArrayList < String > ();
                    Iterator listenerIter = ((List) contents).iterator ();
                    while (listenerIter.hasNext ()) {
                        byte [] buffer = new byte [5120];
                        long bytesCopied = 0;
                        int bytesInBuffer;
                        CustomData customData = (CustomData) listenerIter.next ();
                        if (customData.listenerName != null) {
                            subContents.add (customData.listenerName);
                        }
                        Iterator < String > liClaIter = customData.contents.iterator ();
                        while (liClaIter.hasNext ()) {
                            String contentPath = liClaIter.next ();
                            if (exist.contains (contentPath)) {
                                continue;
                            }
                            exist.add (contentPath);
                            try {
                                outJar.putNextEntry (new ZipEntry (contentPath));
                            } catch (ZipException ze) {
                                Debug.trace ("ZipException in writing custom data: " + ze.getMessage ());
                                continue;
                            }
                            InputStream in = getClass ().getResourceAsStream ("/" + contentPath);
                            if (in != null) {
                                while ((bytesInBuffer = in.read (buffer)) != - 1) {
                                    outJar.write (buffer, 0, bytesInBuffer);
                                    bytesCopied += bytesInBuffer;
                                }
                            }
                            else {
                                Debug.trace ("custom data not found: " + contentPath);
                            }
                            outJar.closeEntry ();
                        }
                    }
                    outJar.putNextEntry (new ZipEntry (key));
                    ObjectOutputStream objOut = new ObjectOutputStream (outJar);
                    objOut.writeObject (subContents);
                    objOut.flush ();
                    outJar.closeEntry ();
                }
                else {
                    outJar.putNextEntry (new ZipEntry (key));
                    if (contents instanceof ByteArrayOutputStream) {
                        ((ByteArrayOutputStream) contents).writeTo (outJar);
                    }
                    else {
                        ObjectOutputStream objOut = new ObjectOutputStream (outJar);
                        objOut.writeObject (contents);
                        objOut.flush ();
                    }
                    outJar.closeEntry ();
                }
            }
        }
        ArrayList < String > unInstallScripts = udata.getUninstallScripts ();
        Iterator < String > unInstallIter = unInstallScripts.iterator ();
        ObjectOutputStream rootStream;
        int idx = 0;
        while (unInstallIter.hasNext ()) {
            outJar.putNextEntry (new ZipEntry (UninstallData.ROOTSCRIPT + Integer.toString (idx)));
            rootStream = new ObjectOutputStream (outJar);
            String unInstallScript = (String) unInstallIter.next ();
            rootStream.writeUTF (unInstallScript);
            rootStream.flush ();
            outJar.closeEntry ();
        }
        outJar.flush ();
        outJar.close ();
        return true;
    } catch (Exception err) {
        err.printStackTrace ();
        return false;
    }
}


-----Function Pair=172=-----==

private void zip (File srcFile, FilenameFilter filter, ZipEntry pentry, String prefix) throws IOException {
    ZipEntry entry;
    if (srcFile.isDirectory ()) {
        if (pentry == null) {
            entry = new ZipEntry (srcFile.getName ());
        }
        else {
            entry = new ZipEntry (pentry.getName () + "/" + srcFile.getName ());
        }
        File [] files = srcFile.listFiles (filter);
        for (File f : files) {
            zip (f, filter, entry, prefix);
        }
    }
    else {
        if (pentry == null) {
            entry = new ZipEntry (prefix + srcFile.getName ());
        }
        else {
            entry = new ZipEntry (pentry.getName () + "/" + prefix + srcFile.getName ());
        }
        FileInputStream in;
        try {
            log.debug ("读取文件：{}", srcFile.getAbsolutePath ());
            in = new FileInputStream (srcFile);
            try {
                zipOut.putNextEntry (entry);
                int len;
                while ((len = in.read (buf)) > 0) {
                    zipOut.write (buf, 0, len);
                }
                zipOut.closeEntry ();
            } finally {
                in.close ();
            }
        } catch (FileNotFoundException e) {
            throw new RuntimeException ("制作压缩包时，源文件不存在：" + srcFile.getAbsolutePath (), e);
        }
    }
}


private static void listJar (String [] args) throws Exception {
    boolean verboseFlag = false, fileFlag = false;
    for (int i = 1; i < args [0].length (); i ++) {
        switch (args [0].charAt (i)) {
            case 'v' :
                verboseFlag = true;
                break;
            case 'f' :
                fileFlag = true;
                break;
            default :
                System.out.println ("Error: Illegal option for -t: '" + args [0].charAt (i) + "'");
                return;
        }
    }
    if (fileFlag && args.length < 2) {
        System.out.println ("Error: No file name specified for 'f' option");
        return;
    }
    ZipInputStream zis;
    if (! fileFlag) {
        if (verboseFlag) System.out.println ("Reading input from stdin");
        zis = new ZipInputStream (System.in);
    }
    else {
        if (verboseFlag) System.out.println ("Reading jar file: " + args [1]);
        zis = new ZipInputStream (new FileInputStream (new File (args [1])));
    }
    ZipEntry ze;
    if (verboseFlag) System.out.println ("Listing files:");
    while ((ze = zis.getNextEntry ()) != null) {
        Date date = new Date (ze.getTime ());
        DateFormat dateFormat = new SimpleDateFormat ("EEE MMM dd HH:mm:ss z yyy");
        String formattedDate = dateFormat.format (date);
        zis.closeEntry ();
        System.out.printf ("%6d %s %s\n", ze.getSize (), formattedDate, ze.getName ());
    }
    zis.close ();
}


-----Function Pair=173=-----==

public static String formatCurrencyOld (String valor) {
    String resp = "0";
    if (valor != null && ! valor.equals ("")) {
        try {
            float lvalor = Float.parseFloat (valor);
            lvalor = (float) (Math.round (lvalor * 100)) / 100;
            valor = lvalor + "";
            resp = valor.replace ('.', ',');
            int virgula = resp.indexOf (',');
            String decimal = resp.substring (virgula + 1);
            if (decimal.length () > 2) {
                resp = resp.substring (0, virgula + 3);
            }
            else if (decimal.length () < 2) {
                resp = resp + "0";
            }
            String inteira = resp.substring (0, virgula);
            String aux = "";
            int cont = 0;
            for (int j = inteira.length () - 1; j >= 0; j --) {
                if (cont % 3 == 0 && cont != 0) {
                    aux = inteira.charAt (j) + "." + aux;
                }
                else {
                    aux = inteira.charAt (j) + aux;
                }
                cont ++;
            }
            resp = inteira;
        } catch (Exception e) {
            resp = e.toString ();
        }
    }
    return resp;
}


private void read (String lang, String [] ignore, int first, int last, PrintWriter out) {
    log (true, "Ignoring: " + Arrays.asList (ignore));
    if (out != null) {
        String [] args = new String [] {lang, "" + first, "" + last};
        for (int i = 0; i < DISCLAIMER.length; i ++) {
            out.println (new MessageFormat (DISCLAIMER [i]).format (args));
        }
    }
    for (int year = first; year <= last; year ++) {
        String yyyy = getYYYY (year);
        if (yyyy == null) throw new IllegalArgumentException ("can't create yyyy from " + year);
        try {
            String url = new MessageFormat (URL).format (new String [] {lang, "" + year});
            readURL (yyyy, ignore, new URL (url), out);
        } catch (IOException e) {
            log (true, "IO error on reading " + year);
        }
    }
    log (true, "Read " + imported + " events for '" + lang + "' between " + first + " and " + last);
}


-----Function Pair=174=-----==

public static boolean pertence (String valor, Object vetor []) {
    boolean resp = false;
    if (Util.isNull (valor) || vetor == null) {
        return resp;
    }
    valor = valor.trim ();
    for (int i = 0; i < vetor.length; i ++) {
        String valorVetor = vetor [i].toString ().trim ();
        if (valor.equalsIgnoreCase (valorVetor)) {
            resp = true;
            i = vetor.length;
        }
    }
    return resp;
}


public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=175=-----==

protected void zipDir (File dir, ZipOutputStream zOut, String vPath) throws IOException {
    if (addedDirs.get (vPath) != null) {
        return;
    }
    addedDirs.put (vPath, vPath);
    ZipEntry ze = new ZipEntry (vPath);
    if (dir != null && dir.exists ()) {
        ze.setTime (dir.lastModified ());
    }
    else {
        ze.setTime (System.currentTimeMillis ());
    }
    ze.setSize (0);
    ze.setMethod (ZipEntry.STORED);
    ze.setCrc (EMPTY_CRC);
    zOut.putNextEntry (ze);
}


public Block decompress () {
    try {
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        ZipInputStream zis = new ZipInputStream (inputStream ());
        zis.getNextEntry ();
        int len;
        byte buffer [] = new byte [512];
        while (true) {
            len = zis.read (buffer);
            if (len == - 1) break;
            else baos.write (buffer, 0, len);
        }
        return new Block (baos.toByteArray ());
    } catch (IOException e) {
        throw new WrappingRuntimeException (e);
    }
}


-----Function Pair=176=-----==

public List < TaskComment > readComments (IMemento parent) {
    List < TaskComment > comments = new ArrayList < TaskComment > ();
    for (IMemento commentMemento : parent.getChildren (ELEMENT_COMMENT)) {
        Integer commentNumber = commentMemento.getInteger (ATTRIBUTE_NUMBER);
        String hasAttachment = commentMemento.getString (ATTRIBUTE_HAS_ATTACHMENT);
        String attachmentId = commentMemento.getString (ATTRIBUTE_ATTACHMENT_ID);
        if (commentNumber != null) {
            TaskComment comment = new TaskComment (temporaryFactory, commentNumber);
            if (hasAttachment != null) {
                comment.setHasAttachment (Boolean.parseBoolean (hasAttachment));
            }
            if (attachmentId != null) {
                comment.setAttachmentId (attachmentId);
            }
            IMemento attributesMemento = commentMemento.getChild (ELEMENT_ATTRIBUTES);
            if (attributesMemento != null) {
                List < RepositoryTaskAttribute > attributes = readAttributes (attributesMemento);
                for (RepositoryTaskAttribute repositoryTaskAttribute : attributes) {
                    comment.addAttribute (repositoryTaskAttribute.getId (), repositoryTaskAttribute);
                }
            }
            comments.add (comment);
        }
    }
    return comments;
}


void writeFilesToZip (List < String > filesEntries, String basePath, DirectoryFolder resourcesFolder, ZipOutputStream zipOutStream) {
    DirectoryPersister directoryPersister = ManagerRegistry.getDirectoryPersister ();
    for (String filezipEntryName : filesEntries) {
        ZipEntry zipEntry = new ZipEntry (filezipEntryName);
        String resourceName = null;
        try {
            if (! directoryPersister.existFileInRootFolder (filezipEntryName, resourcesFolder.getId (), resourcesFolder.getWorkspace ())) {
                zipOutStream.putNextEntry (zipEntry);
                if (! filezipEntryName.endsWith ("/")) {
                    resourceName = basePath + filezipEntryName;
                    BufferedInputStream inputStream = new BufferedInputStream (ScormUtil.class.getResourceAsStream (resourceName));
                    writeInputStreamIntoOutputStream (inputStream, zipOutStream);
                }
            }
            zipOutStream.closeEntry ();
        } catch (ZipException e) {
            log.warn ("ZipException adding control files to exported zip", e);
        } catch (IOException e) {
            String errorAddingFileMessage = "Error adding file to zip" + resourceName;
            log.error (errorAddingFileMessage, e);
            throw new CMSRuntimeException (errorAddingFileMessage, e);
        }
    }
}


-----Function Pair=177=-----==

public static Class < ? > getDeclaringClass (Class < ? > c) throws ClassNotFoundException {
    try {
        Class < ? > result = c.getDeclaringClass ();
        return result;
    } catch (Exception e) {
        String [] elements = c.getName ().replace ('.', '/').split ("\\$");
        String name = elements [0];
        for (int i = 1; i < elements.length - 1; i ++) {
            name += "$" + elements [i];
        }
        if (elements.length == 1) {
            return null;
        }
        else {
            return getClassByName (apkpath + apkname, name);
        }
    }
}


private void ZipVars (ZipOutputStream out) throws Exception {
    if (vars == null || vars.isEmpty ()) return;
    String filename = "TOPIC" + GetId () + ".vars";
    out.putNextEntry (new ZipEntry (filename));
    try {
        ZipWriter writer = new ZipWriter (out);
        java.util.Enumeration vars_enum = vars.elements ();
        while (vars_enum.hasMoreElements ()) {
            Var var = (Var) vars_enum.nextElement ();
            if (var != null) {
                writer.println (var.name);
                writer.println (Utils.Null2Empty (var.value));
            }
        }
    } finally {
        out.closeEntry ();
    }
}


-----Function Pair=178=-----=1=

private void buildJar (List < Foto > fotos, OutputStream stream) throws IOException {
    JarOutputStream jar = new JarOutputStream (stream);
    logger.info ("Zipping");
    HashMap < String, String > filenames = new HashMap < String, String > ();
    for (Foto foto : fotos) {
        logger.info ("Zipping " + foto.getTitle ());
        String title = foto.getTitle ();
        title = title.replaceAll ("\\\\", "|");
        title = title.replaceAll ("\\/", "|");
        title = title.replaceAll ("\\~", "-");
        for (; filenames.containsKey (title);) {
            title = title + "_";
        }
        filenames.put (title, "");
        title = title + ".jpg";
        jar.putNextEntry (new ZipEntry (title));
        jar.write (foto.getImgAsBytes ());
    }
    jar.close ();
    logger.info ("Zipping done");
}


public static final byte [] compress (String str) {
    if (str == null) return null;
    byte [] compressed;
    ByteArrayOutputStream out = null;
    ZipOutputStream zout = null;
    try {
        out = new ByteArrayOutputStream ();
        zout = new ZipOutputStream (out);
        ZipEntry zipentry = new ZipEntry ("0.txt");
        zipentry.setMethod (ZipEntry.STORED);
        zipentry.setSize (str.getBytes ().length);
        CRC32 crc32 = new CRC32 ();
        crc32.update (str.getBytes (), 0, str.getBytes ().length);
        zipentry.setCrc (crc32.getValue ());
        zout.putNextEntry (zipentry);
        zout.write (str.getBytes ());
        zout.closeEntry ();
        compressed = out.toByteArray ();
    } catch (IOException e) {
        e.printStackTrace ();
        compressed = null;
    } finally {
        if (zout != null) {
            try {
                zout.close ();
            } catch (IOException e) {
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
    return compressed;
}


-----Function Pair=179=-----==

private Thread writeStdOut (Process p, String outputDirName) {
    final File outputDir = new File (outputDirName);
    final InputStreamReader isr = new InputStreamReader (p.getInputStream ());
    final String outfileName = outputDir.getAbsolutePath () + File.separator + "stdout.txt";
    Thread t_input = new Thread () {
        public void run () {
            FileWriter fw;
            try {
                fw = new FileWriter (outfileName);
            } catch (IOException ioe) {
                logger.error (ioe);
                return;
            }
            int bytes = 0;
            char [] buf = new char [256];
            while (! (done && (bytes < 0))) {
                try {
                    bytes = isr.read (buf);
                    if (bytes > 0) {
                        fw.write (buf, 0, bytes);
                        fw.flush ();
                    }
                } catch (IOException ignore) {
                    break;
                }
            }
            try {
                fw.close ();
            } catch (IOException ioe) {
                logger.error (ioe);
                return;
            }
            logger.debug ("Done writing standard output");
        }
    }
    ;
    t_input.start ();
    return t_input;
}


private byte [] showRunningActions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer buff = new StringBuffer (2048);
    buff.append ("HTTP/1.0 200 OK\n");
    buff.append ("Content-Type: text/html\n");
    buff.append ("Pragma: no-cache\n");
    buff.append ("Cache-Control: no-cache\n\n");
    buff.append ("<html>\n");
    buff.append ("<table align='center' border='1'>\n");
    buff.append ("<tr>\n");
    buff.append ("<td nowrap>Device Index</td>\n");
    buff.append ("<td nowrap>Device Name</td>\n");
    buff.append ("<td nowrap>HashKey</td>\n");
    buff.append ("<td nowrap>Share Name</td>\n");
    buff.append ("<td nowrap>Usage Count</td>\n");
    buff.append ("<td nowrap>Is Running</td>\n");
    buff.append ("<td nowrap>Exit Code</td>\n");
    buff.append ("<td nowrap>Needs Reastart</td>\n");
    buff.append ("</tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    StreamProducerProcess [] producers = devList.getProducers ();
    for (int index = 0; index < producers.length; index ++) {
        StreamProducerProcess producer = producers [index];
        buff.append ("<tr>\n");
        buff.append ("<td nowrap>" + producer.getDeviceIndex () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getCaptureDevice ().getName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getKey () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getMemoryShareName () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getUsageCount () + "</td>\n");
        buff.append ("<td nowrap>" + producer.isProducerRunning () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getExitCode () + "</td>\n");
        buff.append ("<td nowrap>" + producer.getNeedsRestart () + "</td>\n");
        buff.append ("</tr>\n");
    }
    buff.append ("</table>\n");
    buff.append ("<br><br><br>\n");
    buff.append ("</html>");
    buff.append ("\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=180=-----==

public static FileSize getFileTotal (String location) throws IOException {
    File folder = new File (location);
    File [] listOfDirs = folder.listFiles (new FileFilter () {
        @Override
        public boolean accept (File file) {
            boolean isDir = file.isDirectory ();
            return isDir;
        }
    }
    );
    File [] listOfFiles = folder.listFiles (new FileFilter () {
        @Override
        public boolean accept (File file) {
            return file.getName ().toLowerCase ().endsWith (".jpg");
        }
    }
    );
    long size = 0;
    for (int i = 0; i < listOfFiles.length; i ++) {
        size += listOfFiles [i].length ();
    }
    int total = listOfFiles.length;
    for (int i = 0; i < listOfDirs.length; i ++) {
        if (listOfDirs [i].isDirectory ()) {
            String locationTemp = folder.toString () + "/" + listOfDirs [i].getName ();
            FileSize fs = getFileTotal (locationTemp);
            total += fs.getNumberOfFiles ();
            size += fs.getFileSize ();
        }
    }
    FileSize f = new FileSize (total, size);
    return f;
}


public static boolean restaurarCopiaSeguridad (File copia) {
    boolean retorno = true;
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (copia);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        int count;
        byte data [] = new byte [BUFFER];
        ZipEntry entry;
        String destino = DATOS;
        Conexion.apargarBD ();
        while ((entry = zis.getNextEntry ()) != null) {
            if (! entry.isDirectory ()) {
                String entryName = entry.getName ();
                String destFN = destino + entry.getName ();
                FileOutputStream fos = new FileOutputStream (destFN);
                dest = new BufferedOutputStream (fos, BUFFER);
                while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
            }
        }
        zis.close ();
        Conexion.getConexion ();
        retorno = Conexion.isConectado ();
    } catch (Exception ex) {
        Logger.getLogger (Conexion.class.getName ()).log (Level.SEVERE, null, ex);
        retorno = false;
    }
    return retorno;
}


-----Function Pair=181=-----==

private static void addDir (File rootDir, File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (rootDir, files [i], out);
            continue;
        }
        FileInputStream in = new FileInputStream (files [i].getAbsolutePath ());
        System.out.println (" Adding: " + files [i].getAbsolutePath ());
        out.putNextEntry (new ZipEntry (files [i].getAbsolutePath ().substring (rootDir.getAbsolutePath ().length () + 1)));
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


private static void unzipEntry (ZipFile file, ZipEntry entry, String dir) {
    if (entry == null) {
        return;
    }
    try {
        InputStream is = new BufferedInputStream (file.getInputStream (entry));
        int count;
        byte data [] = new byte [BUFFER];
        FileOutputStream fos = new FileOutputStream (dir + "/" + entry.getName ());
        OutputStream dest = new BufferedOutputStream (fos, BUFFER);
        while ((count = is.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
        is.close ();
    } catch (IOException e) {
        log.error (e);
    }
}


-----Function Pair=182=-----==

private void mergeOVALDocuments (OvalSmasherImpl smasher, final RTDocument rt, final ApplicationType application, String outputDir, final String namespace) throws Exception {
    List < ComplianceCheckType > complianceChecks = this.getComplianceChecks (application, intStatusOrder);
    List < String > ovalCheckFiles = new ArrayList < String > (complianceChecks.size ());
    List < CheckLanguageType > checkLanguages = (application.isSetCheckLanguages ()) ? application.getCheckLanguages ().getCheckLanguageList () : Collections.< CheckLanguageType > emptyList ();
    List < FileType > appFiles = (application.isSetFiles ()) ? application.getFiles ().getFileList () : Collections.< FileType > emptyList ();
    List < ComplianceCheckType > listOvalCheck = new ArrayList < ComplianceCheckType > (complianceChecks.size ());
    Map < String, File > mapOvalCheckToFile = new LinkedHashMap < String, File > (complianceChecks.size ());
    Map < String, FileType > mapCheckToFileType = new LinkedHashMap < String, FileType > (complianceChecks.size ());
    for (ComplianceCheckType check : complianceChecks) {
        if (check.isSetCheckContent ()) {
            CheckContentType cct = check.getCheckContent ();
            String checkLanguageId = cct.getCheckLanguageId ();
            CheckLanguageType checkLanguage = checkLanguageHelper.getItem (checkLanguages, checkLanguageId);
            if (checkLanguage != null && checkLanguage.getNamespaceURI ().equals (smasher.getNamespaceURI ())) {
                String fileId = cct.getFileRef ();
                FileType file = fileTypeHelper.getItem (appFiles, fileId);
                if (file != null) {
                    String path = fileTypeHelper.getFilePath (file);
                    if (ovalCheckFiles.contains (path) == false) {
                        ovalCheckFiles.add (path);
                    }
                    mapOvalCheckToFile.put (check.getId (), new File (path));
                    mapCheckToFileType.put (check.getId (), file);
                    listOvalCheck.add (check);
                }
                else throw new FileNotFoundException ("Unable to locate OVAL check file for compliance check: " + check.getId ());
            }
        }
    }
    if (ovalCheckFiles.isEmpty () == false) {
        File outputFile = new File (outputDir, application.getName () + "-oval.xml");
        smasher.smash (ovalCheckFiles, namespace, outputFile.getPath ());
        Map < FileIdTuple, String > mapNewDefinitions = smasher.getNewDefinitionIdMap ();
        Map < FileIdTuple, String > mapNewVariables = smasher.getNewVariableIdMap ();
        for (ComplianceCheckType check : listOvalCheck) {
            CheckContentType cct = check.getCheckContent ();
            File checkFile = mapOvalCheckToFile.get (check.getId ());
            if (mapNewDefinitions.isEmpty () == false) {
                String origDefId = cct.getCheckName ();
                FileIdTuple defIdTuple = new FileIdTuple (origDefId, checkFile);
                String newDefId = mapNewDefinitions.get (defIdTuple);
                if (newDefId != null) {
                    logger.debug (defIdTuple.toString () + " == " + newDefId);
                    cct.setCheckName (newDefId);
                }
            }
            if (mapNewVariables.isEmpty () == false) {
                if (cct.isSetCheckValueRefs ()) {
                    List < String > valueRefs = cct.getCheckValueRefs ().getCheckValueRefList ();
                    List < CheckValueType > checkValues = application.getCheckValues ().getCheckValueList ();
                    List < CheckValueType > referencedValues = checkValueHelper.getStringReferencedItems (checkValues, valueRefs);
                    for (CheckValueType checkValue : referencedValues) {
                        String origCheckId = (checkValue.isSetName ()) ? checkValue.getName () : "";
                        FileIdTuple checkIdTuple = new FileIdTuple (origCheckId, checkFile);
                        String newCheckId = mapNewVariables.get (checkIdTuple);
                        if (newCheckId != null) {
                            logger.debug (checkIdTuple.toString () + " == " + newCheckId);
                            checkValue.setName (newCheckId);
                        }
                    }
                }
            }
            FileType fileType = mapCheckToFileType.get (check.getId ());
            fileType.setFileName (outputFile.getName ());
        }
    }
}


public Question getQuestionFromCP (String filename, String testLocation) {
    boolean itsAtest = false;
    try {
        String testBaseDir = new File (testLocation).getAbsolutePath ();
        String replacementString;
        if (System.getProperty ("os.name").contains ("Linux")) {
            replacementString = tempdir + "/spectemp";
        }
        else {
            replacementString = tempdir + "spectemp";
        }
        String relativeTestDir = testBaseDir.replace (replacementString, "");
        if (sep.equals ("\\")) {
            testLocation = testLocation.replaceAll ("\\\\", "/");
            testBaseDir = testBaseDir.replaceAll ("\\\\", "/");
            relativeTestDir = relativeTestDir.replaceAll ("\\\\", "/");
        }
        if (! relativeTestDir.equals ("")) {
            if (relativeTestDir.charAt (0) == '/') relativeTestDir = relativeTestDir.substring (1, relativeTestDir.length ());
            if (relativeTestDir.charAt (relativeTestDir.length () - 1) != '/') relativeTestDir = relativeTestDir + "/";
        }
        String destDir = FileOps.tempdir + FileOps.sep + "tempunzip";
        long size = (new File (filename)).length ();
        unzip (new File (filename), new File (destDir));
        String tempqFilename = getQFilenameFromManifest (destDir + sep + "imsmanifest.xml");
        ManifestType qManifest = getManifestFromDisk (destDir + sep + "imsmanifest.xml");
        MetadataType qMetadata = null;
        List < FileType > qFiles = null;
        List < ResourceType > resources = qManifest.getResources ().getResource ();
        for (ResourceType resource : resources) {
            if ((resource.getType ().equals ("imsqti_item_xmlv2p0")) || (resource.getType ().equals ("imsqti_item_xmlv2p1"))) {
                qMetadata = resource.getMetadata ();
                qFiles = resource.getFile ();
            }
            if ((resource.getType ().equals ("imsqti_test_xmlv2p1")) || (resource.getType ().equals ("imsqti_assessment_xmlv2p1"))) {
                itsAtest = true;
                return null;
            }
        }
        for (int i = 0; i < qMetadata.getAny ().size (); i ++) {
            try {
                Element item = (Element) qMetadata.getAny ().get (i);
                if (item.getNodeName ().endsWith (":lom")) {
                    JAXBElement < LomType > testLom = (JAXBElement < LomType >) imsMetaUnmarshaller.unmarshal ((Element) item);
                    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
                    DocumentBuilder loader = factory.newDocumentBuilder ();
                    factory.setNamespaceAware (true);
                    Document document = loader.newDocument ();
                    imsMetaMarshaller.marshal (testLom, document);
                    qMetadata.getAny ().set (i, document.getDocumentElement ());
                }
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        File ourQuestionFile = new File (tempqFilename);
        String ourQuestionFullFilename = ourQuestionFile.getAbsolutePath ();
        String [] x;
        if (sep.equals ("\\")) {
            x = ourQuestionFullFilename.split ("\\\\");
        }
        else {
            x = ourQuestionFullFilename.split (sep);
        }
        String ourQuestionFilename = x [x.length - 1];
        String id = "id-" + MiscUtils.miniUUID ();
        File originalDir = new File (destDir + sep);
        File dest = new File (testLocation + sep + id + sep);
        FileUtils.moveDirectory (originalDir, dest);
        String qFilename = dest.getAbsolutePath () + FileOps.sep + tempqFilename;
        AssessmentItemType qtiQ = getAssessmentItemFromDisk (qFilename);
        Question ourQuestion = new Question ();
        ourQuestion.setSize (size);
        ourQuestion.setQtiAssItem (qtiQ);
        Document qDoc = getDocForAssItem (ourQuestion.getQtiAssItem ());
        ourQuestion.setSourceAsDoc (qDoc);
        ourQuestion.setMyid (id);
        ourQuestion.setRefId (id);
        if (qMetadata != null) ourQuestion.setMetadata (qMetadata);
        if (qFiles != null) {
            for (FileType f : qFiles) {
                f.setHref (relativeTestDir + id + "/" + f.getHref ());
            }
            ourQuestion.setFiles (qFiles);
        }
        ourQuestion.setHref (id + "/" + tempqFilename);
        ourQuestion.setBaseHref (relativeTestDir + ourQuestion.getHref ());
        return ourQuestion;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=183=-----==

private long allocateSpace (long size) {
    Block minBlock = null;
    Iterator i = free.iterator ();
    while (i.hasNext ()) {
        Block b = (Block) i.next ();
        if (b.length == size) {
            free.remove (b);
            return b.loc;
        }
        else if (b.length > size) {
            if (minBlock == null) {
                minBlock = b;
            }
            else if (minBlock.length > size) {
                minBlock = b;
            }
        }
    }
    if (minBlock != null) {
        if (minBlock.length < (size * 1.2)) {
            free.remove (minBlock);
            return minBlock.loc;
        }
    }
    long loc = expandLoc;
    expandLoc += size;
    return loc;
}


public void init () {
    final Emulator emu = parent.step1.emu;
    final Hardware [] hardwares = parent.step2.hardwares;
    final ImageFormat [] formats = parent.step2.formats;
    StringBuilder explanationText = new StringBuilder (String.format (RBLanguages.get ("confirm_commit_part1"), emu.name, emu.name, emu.folder, emu.name));
    for (Hardware hardware : hardwares) {
        explanationText.append ("<li>" + hardware.name + "</li>");
    }
    explanationText.append (String.format (RBLanguages.get ("confirm_commit_part2"), emu.name));
    for (ImageFormat format : formats) {
        explanationText.append ("<li>" + format.name + "</li>");
    }
    explanationText.append (RBLanguages.get ("confirm_commit_part3"));
    explanation.setText (explanationText.toString ());
}


-----Function Pair=184=-----==

public void unzipContainer (ZipEntry entry, ZipInputStream in, boolean overwrite) throws IOException, NxqdException {
    NxqdContainer container;
    if (entry.isDirectory ()) {
        String containerName = entry.getName ();
        containerName = containerName.substring (0, containerName.length () - 1);
        if (! manager.containerExists (containerName)) {
            container = manager.createContainer (containerName);
        }
    }
    else {
        String containerName = entry.getName ().substring (0, entry.getName ().indexOf ('/'));
        String documentId = entry.getName ().substring (entry.getName ().indexOf ('/') + 1, entry.getName ().length ());
        if (! manager.containerExists (containerName)) {
            container = manager.createContainer (containerName);
        }
        else {
            container = manager.getContainer (containerName);
        }
        ByteArrayOutputStream documentBytes = new ByteArrayOutputStream ();
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            documentBytes.write (buf, 0, len);
        }
        if (documentId.endsWith (BLOB_SUFFIX)) {
            container.putBlob (documentId.substring (0, documentId.length () - BLOB_SUFFIX.length ()), new NxqdBlobValue (documentBytes.toByteArray ()));
        }
        else {
            if (! entry.isDirectory ()) {
                if (container.documentExists (documentId)) {
                    if (overwrite) {
                        container.deleteDocument (documentId);
                    }
                    else {
                        throw new NxqdException ("Document already exists");
                    }
                }
                container.putDocument (documentId, new NxqdXMLValue (documentBytes.toString ("UTF-8")));
            }
        }
    }
}


public static final List < File > listFiles (final String basePath, int deep, final String...fileNameEndStr) {
    final List < File > list = new ArrayList < File > (8);
    final File baseFile = new File (basePath);
    final SampleFileFilter filter = new SampleFileFilter (fileNameEndStr);
    if (baseFile.exists () && baseFile.isFile () && filter.accept (baseFile)) {
        list.add (baseFile);
        return list;
    }
    File [] files = baseFile.listFiles (filter);
    if (null != files && files.length > 0) {
        for (final File subFile : files) {
            if (subFile.isFile ()) list.add (subFile);
        }
    }
    if (deep <= 0) return list;
    files = baseFile.listFiles (IOUtils.DIR_FILTER);
    if (null != files && files.length > 0) {
        final int dp = -- deep;
        for (final File subFile : files) {
            list.addAll (IOUtils.listFiles (subFile.getAbsolutePath (), dp, fileNameEndStr));
        }
    }
    return list;
}


-----Function Pair=185=-----==

protected ArchiveState getNonFileSetResourcesToAdd (ResourceCollection [] rcs, File zipFile, boolean needsUpdate) throws BuildException {
    Resource [] [] initialResources = grabNonFileSetResources (rcs);
    if (isEmpty (initialResources)) {
        return new ArchiveState (needsUpdate, initialResources);
    }
    if (! zipFile.exists ()) {
        return new ArchiveState (true, initialResources);
    }
    if (needsUpdate && ! doUpdate) {
        return new ArchiveState (true, initialResources);
    }
    Resource [] [] newerResources = new Resource [rcs.length] [];
    for (int i = 0; i < rcs.length; i ++) {
        if (initialResources [i].length == 0) {
            newerResources [i] = new Resource [] {};
            continue;
        }
        for (int j = 0; j < initialResources [i].length; j ++) {
            FileProvider fp = (FileProvider) initialResources [i] [j].as (FileProvider.class);
            if (fp != null && zipFile.equals (fp.getFile ())) {
                throw new BuildException ("A zip file cannot include " + "itself", getLocation ());
            }
        }
        newerResources [i] = selectOutOfDateResources (initialResources [i], new IdentityMapper ());
        needsUpdate = needsUpdate || (newerResources [i].length > 0);
        if (needsUpdate && ! doUpdate) {
            break;
        }
    }
    if (needsUpdate && ! doUpdate) {
        return new ArchiveState (true, initialResources);
    }
    return new ArchiveState (needsUpdate, newerResources);
}


private void DeleteNodeTables (NpsContext ctxt, Node node) {
    Topic t = (Topic) node.GetValue ();
    PreparedStatement pstmt = null;
    try {
        if (t.GetTable () != null && t.GetTable ().length () > 0) {
            String dstable_name = t.GetTable () + "_prop";
            String sql = "drop table " + dstable_name;
            pstmt = ctxt.GetConnection ().prepareStatement (sql);
            pstmt.executeUpdate ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
    if (node.HasChilds ()) {
        Iterator childs = node.GetChilds ();
        while (childs.hasNext ()) {
            Node child_node = (Node) childs.next ();
            DeleteNodeTables (ctxt, child_node);
        }
    }
}


-----Function Pair=186=-----==

public static void unzip (File destination, InputStream source, boolean overwrite) throws IOException {
    ZipInputStream zis = new ZipInputStream (source);
    int available = zis.available ();
    ZipEntry zipEntry = zis.getNextEntry ();
    if (available > 0 && zipEntry == null) {
        throw new ZipException ("No zip entry found. Invalid zip file.");
    }
    while (zipEntry != null) {
        if (zipEntry.isDirectory ()) {
            File folder = new File (destination, zipEntry.getName ());
            if (! folder.exists ()) {
                folder.mkdirs ();
            }
        }
        else {
            File destFile = new File (destination, zipEntry.getName ());
            if (! destFile.exists () || overwrite) {
                destFile.getParentFile ().mkdirs ();
                BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (destFile));
                copy (zis, bos);
                bos.close ();
            }
        }
        zipEntry = zis.getNextEntry ();
    }
    zis.closeEntry ();
}


public static byte [] generateDigest (String filename) throws GIEWSException {
    File file = new File (filename);
    if (! file.exists ()) {
        throw new GIEWSException ("file not found");
    }
    byte [] toChapter1Digest = null;
    try {
        FileInputStream fileStream = new FileInputStream (file);
        ZipInputStream zin = new ZipInputStream (fileStream);
        MessageDigest md = MessageDigest.getInstance ("SHA");
        int byteRead = 1;
        byte buffer [] = new byte [1000];
        ZipEntry ze = zin.getNextEntry ();
        md = MessageDigest.getInstance ("SHA");
        while (ze != null) {
            byteRead = 1;
            if (ze.getName () == "Projects.xml") {
                while (byteRead > 0) {
                    byteRead = zin.read (buffer);
                    md.update (buffer);
                }
            }
            zin.closeEntry ();
            ze = zin.getNextEntry ();
        }
        toChapter1Digest = md.digest ();
        fileStream.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        throw new GIEWSException (e.getMessage ());
    }
    return toChapter1Digest;
}


-----Function Pair=187=-----==

public Document exportToXml (List < Integer > ppids, List < Integer > uploadIDs, List < Integer > recordIDs) {
    ProjectExporter exporter = new ProjectExporter ();
    Document doc = exporter.createProjectDoc ();
    int i = 0;
    for (Integer id : ppids) {
        List < Plan > list = em.createQuery ("select p from Plan p where p.planProperties.id = " + id).getResultList ();
        if (list.size () != 1) {
            FacesMessages.instance ().add (FacesMessage.SEVERITY_ERROR, "Skipping the export of the plan with properties" + id + ": Couldnt load.");
        }
        else {
            exporter.addProject (list.get (0), doc, uploadIDs, recordIDs);
        }
        list.clear ();
        list = null;
        log.info ("XMLExport: addString destinationed project ppid=" + id);
        i ++;
        if ((i % 10 == 0)) {
            em.clear ();
            System.gc ();
        }
    }
    return doc;
}


public void opcionRecordatorio () {
    columnaSeleccionada = table.getSelectedColumn ();
    filaSeleccionada = table.getSelectedRow ();
    if (columnaSeleccionada != - 1 && filaSeleccionada != - 1) {
        datoSeleccionado = obtenerDato (filaSeleccionada, columnaSeleccionada);
        if (datoSeleccionado.equals ("null") || datoSeleccionado.equals ("")) JOptionPane.showMessageDialog (null, "Debe seleccionar una celda que no est� vac�a", "Error", JOptionPane.WARNING_MESSAGE);
        else {
            JLabel pregunta = new JLabel ("�Qu� desea hacer?");
            JRadioButton crear = new JRadioButton ("Crear un Recordatorio", true);
            JRadioButton ver = new JRadioButton ("Ver un Recordatorio");
            ButtonGroup cv = new ButtonGroup ();
            cv.add (crear);
            cv.add (ver);
            JPanel o1 = new JPanel (new GridLayout (3, 1, 3, 3));
            o1.add (pregunta);
            o1.add (crear);
            o1.add (ver);
            JOptionPane.showMessageDialog (null, o1, "Selecci�n", JOptionPane.QUESTION_MESSAGE);
            if (crear.isSelected ()) crearRecordatorioInterfaz ();
            else verRecordatorio ();
        }
    }
    else JOptionPane.showMessageDialog (null, "Primero debe seleccionar una celda de la cuadricula", "Error", JOptionPane.WARNING_MESSAGE);
}


-----Function Pair=188=-----==

private void copyFileSet (FileSet fileset, ZipOutputStream out) throws IOException {
    String prefix = null;
    String fullPath = null;
    if (fileset instanceof ZipFileSet) {
        ZipFileSet zfs = (ZipFileSet) fileset;
        fullPath = zfs.getFullpath (getProject ());
        prefix = zfs.getPrefix (getProject ());
        if (prefix != null && ! prefix.endsWith ("/")) prefix = prefix + "/";
    }
    DirectoryScanner ds = fileset.getDirectoryScanner (getProject ());
    String [] srcFiles = ds.getIncludedFiles ();
    if (fullPath != null && srcFiles.length > 1) throw new BuildException ("fullpath specified for fileset matching multiple files");
    File dir = fileset.getDir (getProject ());
    for (int i = 0; i < srcFiles.length; i ++) {
        String filename = srcFiles [i];
        File inputFile = new File (dir, filename);
        FileInputStream in = new FileInputStream (inputFile);
        filename = filename.replace (File.separatorChar, '/');
        if (fullPath != null) filename = fullPath;
        else if (prefix != null) filename = prefix + filename;
        ZipEntry zipEntry = new ZipEntry (filename);
        zipEntry.setTime (inputFile.lastModified ());
        copyFile (zipEntry, out, in);
    }
}


public static void replaceObjectContent (DocumentBuilder docBuilder, Document contentDoc, ZipFile zf) throws IOException, SAXException {
    logger.fine ("entering");
    Element root = contentDoc.getDocumentElement ();
    NodeList nodelist = root.getElementsByTagName ("draw:object");
    for (int i = 0; i < nodelist.getLength (); i ++) {
        Node objectNode = nodelist.item (i);
        Node hrefNode = objectNode.getAttributes ().getNamedItem ("xlink:href");
        String objectPath = hrefNode.getTextContent ();
        logger.fine ("object path=" + objectPath);
        Document objectDoc = docBuilder.parse (zf.getInputStream (zf.getEntry (objectPath.substring (2) + "/" + "content.xml")));
        Node objectContentNode = objectDoc.getDocumentElement ();
        String tagName = objectContentNode.getNodeName ();
        logger.fine (tagName);
        if (tagName.equals ("math:math") || tagName.equals ("math")) {
            logger.fine ("replacing math");
            Node newObjectNode = contentDoc.createElement ("draw:object");
            newObjectNode.appendChild (contentDoc.importNode (objectContentNode, true));
            objectNode.getParentNode ().replaceChild (newObjectNode, objectNode);
        }
    }
    logger.fine ("done");
}


-----Function Pair=189=-----==

public void run () {
    finished = false;
    try {
        TorrentInfo info = rtorrent.getTorrentInfo (hash);
        FileInfo [] files = info.getFiles ();
        String remoteDir = info.getDirectory ();
        String remoteBaseDir = info.getBaseDirectory ();
        String remoteBasePath = remoteBaseDir;
        File localDir;
        if (remoteDir == null) localDir = new File (localPath);
        else {
            localDir = new File (localPath, remoteDir);
            remoteBasePath += "/" + remoteDir;
            localDir.mkdirs ();
        }
        String sLocalDir = localDir.getAbsolutePath ();
        Connection connection = SshFactory.getConnection (rtorrent.getBoxConfig ().getSsh ());
        SCPClient scp = connection.createSCPClient ();
        char separator = rtorrent.getFileSeparatoChar ();
        for (FileInfo fileInfo : files) {
            String filePath = fileInfo.getPath ();
            String remotePath = '\'' + remoteBasePath + separator + filePath + '\'';
            String localPath = sLocalDir;
            int p = filePath.lastIndexOf (separator);
            if (p != - 1) {
                localPath += (localPath.charAt (localPath.length () - 1) == File.separatorChar ? "" : File.separatorChar) + filePath.substring (0, p).replace (separator, File.separatorChar);
                (new File (localPath)).mkdirs ();
            }
            scp.get (remotePath, localPath);
        }
        finished = true;
        SystemMessages.info ("Secure copy completed: " + info.getName ());
        jobs.remove (this);
    } catch (Throwable e) {
        SystemMessages.error ("Secure copy failed: " + e.getMessage ());
        log.error (e.getMessage (), e);
        error = e;
    }
}


private int overlapDepth (ScheduleItem item) {
    Calendar cal = Calendar.getInstance ();
    ScheduleItem [] items = store.getScheduleArray ();
    HashMap < String, Channel > channels = store.getChannels ();
    Channel schChan = channels.get (item.getChannel ());
    String muxString = schChan.getFrequency () + "-" + schChan.getBandWidth ();
    Vector < ScheduleItem > operlapItems = new Vector < ScheduleItem > ();
    for (int x = 0; x < items.length; x ++) {
        if (items [x].toString ().equals (item.toString ()) == false) {
            if (item.isOverlapping (items [x])) {
                operlapItems.add (items [x]);
            }
        }
    }
    cal.setTime (item.getStart ());
    int duration = item.getDuration ();
    int maxCount = 0;
    for (int x = 0; x < duration; x ++) {
        HashMap < String, Integer > muxCountMap = new HashMap < String, Integer > ();
        muxCountMap.put (muxString, new Integer (1));
        for (int y = 0; y < operlapItems.size (); y ++) {
            ScheduleItem checkItem = (ScheduleItem) operlapItems.get (y);
            long slice = cal.getTime ().getTime ();
            if (slice > checkItem.getStart ().getTime () && slice < checkItem.getStop ().getTime ()) {
                Channel chackChan = channels.get (checkItem.getChannel ());
                String checkMuxString = chackChan.getFrequency () + "-" + chackChan.getBandWidth ();
                Integer muxCount = muxCountMap.get (checkMuxString);
                if (muxCount == null) {
                    muxCountMap.put (checkMuxString, new Integer (1));
                }
                else {
                    muxCountMap.put (checkMuxString, new Integer (muxCount.intValue () + 1));
                }
            }
        }
        String [] muxTotal = muxCountMap.keySet ().toArray (new String [0]);
        if (maxCount < muxTotal.length) maxCount = muxTotal.length;
        cal.add (Calendar.MINUTE, 1);
    }
    return maxCount;
}


-----Function Pair=190=-----==

private void dumpToPDF (File dirOut, String oname, String ff, Book book, Hashtable < String, String > repl) {
    String ret = null;
    try {
        System.out.print ("Creating " + ff + ".pdf...");
        if (zout != null) {
            zout.putNextEntry (new ZipEntry (ff + ".pdf"));
            ret = book.getPDF (zout, lrfSize, repl);
        }
        else if (dirOut != null) {
            File nf = new File (dirOut, ff + ".pdf");
            nf.getParentFile ().mkdirs ();
            FileOutputStream fos = new FileOutputStream (nf);
            ret = book.getPDF (fos, lrfSize, repl);
            fos.close ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (oname + ".pdf");
            ret = book.getPDF (fos, lrfSize, repl);
            fos.close ();
        }
        System.out.println (ret);
    } catch (Exception e) {
        e.printStackTrace ();
        System.out.println ("PDF Error");
    }
}


public static void extractZipDirectory (File zipFile, String directory, File destination) throws Exception {
    ZipFile zip = new ZipFile (zipFile);
    Enumeration < ? extends ZipEntry > elements = zip.entries ();
    while (elements.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) elements.nextElement ();
        if (entry.getName ().replace ('\\', '/').startsWith (directory.replace ('\\', '/') + "/")) {
            File file = new File (destination, entry.getName ().substring (directory.length () + 1));
            if (entry.isDirectory ()) {
                file.mkdirs ();
                continue;
            }
            try {
                extractOneFile (file, zip.getInputStream (entry));
            } catch (Exception e) {
                log.log (Level.WARNING, "Fail to extract " + entry.getName ());
            }
        }
    }
    zip.close ();
}


-----Function Pair=191=-----==

private void dumpToRTF (File dirOut, String oname, String ff, Book book, Hashtable < String, String > repl) {
    try {
        System.out.print ("Creating " + ff + ".rtf...");
        if (zout != null) {
            zout.putNextEntry (new ZipEntry (ff + ".rtf"));
            book.getRTF (zout, repl);
        }
        else if (dirOut != null) {
            File nf = new File (dirOut, ff + ".rtf");
            nf.getParentFile ().mkdirs ();
            FileOutputStream fos = new FileOutputStream (nf);
            book.getRTF (fos, repl);
            fos.close ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (oname + ".rtf");
            book.getRTF (fos, repl);
            fos.close ();
        }
        System.out.println ("RTF Ok");
    } catch (Exception e) {
        System.out.println ("RTF Error:");
        e.printStackTrace ();
    }
}


public static ArrayList < Solver > getSolversInExperiment (Experiment e) throws NoConnectionToDBException, SQLException {
    final String query = "SELECT DISTINCT Solver_idSolver FROM SolverConfig WHERE Experiment_idExperiment=?";
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (query);
    ps.setInt (1, e.getId ());
    ResultSet rs = ps.executeQuery ();
    ArrayList < Solver > solvers = new ArrayList < Solver > ();
    while (rs.next ()) {
        int id = rs.getInt ("Solver_idSolver");
        Solver s = SolverDAO.getById (id);
        solvers.add (s);
    }
    rs.close ();
    ps.close ();
    return solvers;
}


-----Function Pair=192=-----==

public void load () {
    Connection connection = null;
    ZipInputStream is = null;
    try {
        connection = dataSource.getConnection ();
        for (int i = 1; i <= 20; i ++) {
            try {
                IVirtualFile storage = this.storageDirectory.getFile (BackupUtil.getRotatedFileName ("backup", "dat", 1));
                if (storage == null) return;
                storage.setIOHandler (new EncryptionIOHandler (provider));
                is = new ZipInputStream (storage.getInputStream ());
                ZipEntry entry = null;
                BufferedReader reader = new BufferedReader (new InputStreamReader (is));
                while ((entry = is.getNextEntry ()) != null) {
                    EncryptedTable found = null;
                    for (EncryptedTable table : getEncryptedTables (connection)) {
                        if (entry.getName ().equals (table.tableName + ".dat")) {
                            found = table;
                            break;
                        }
                    }
                    if (found == null) log.warn ("Could not find table for entry: " + entry.getName ());
                    else {
                        found.load (connection, reader);
                        is.closeEntry ();
                    }
                }
                is.close ();
                return;
            } catch (Exception e) {
                if (is != null) try {
                    is.close ();
                } catch (IOException ee) {
                    ThrowableManagerRegistry.caught (ee);
                }
                log.warn ("Backup " + i + " failed.", e);
                BackupUtil.reverseRotation (this.storageDirectory, "backup", "dat", 20);
            }
        }
        throw new RuntimeException ("Could not restore encrypted memory tables");
    } catch (SQLException e) {
        throw ThrowableManagerRegistry.caught (e);
    } finally {
        if (connection != null) try {
            connection.close ();
        } catch (SQLException e) {
            ThrowableManagerRegistry.caught (e);
        }
        if (is != null) try {
            is.close ();
        } catch (IOException e) {
            ThrowableManagerRegistry.caught (e);
        }
    }
}


private void addDirectory (ZipOutputStream zout, File kaynakDizin) {
    File [] files = kaynakDizin.listFiles ();
    if (Sunucu.DEBUG) System.out.println ("Adding directory " + kaynakDizin.getName ());
    for (int i = 0; i < files.length; i ++) {
        if (files [i].getName ().equals (zipIsmi)) continue;
        if (files [i].isDirectory ()) {
            if (files [i].getName () == IgnoreDirectory) continue;
            addDirectory (zout, files [i]);
            continue;
        }
        try {
            if (Sunucu.DEBUG) System.out.println ("Adding file " + files [i].getName ());
            byte [] buffer = new byte [1024];
            FileInputStream fin = new FileInputStream (files [i]);
            String icerdekiYol = files [i].getAbsolutePath ().substring (dizinIsmi.length () + 1);
            zout.putNextEntry (new ZipEntry (icerdekiYol));
            int length;
            while ((length = fin.read (buffer)) > 0) {
                zout.write (buffer, 0, length);
            }
            zout.closeEntry ();
            fin.close ();
        } catch (IOException ioe) {
            System.out.println ("IOException :" + ioe);
        }
    }
}


-----Function Pair=193=-----==

private void writeZipEntry (ZipOutputStream zipOut, String entryName, Content content) throws IOException {
    checkCurrentThreadIsntInterrupted ();
    byte [] buffer = new byte [8192];
    InputStream contentIn = null;
    try {
        zipOut.putNextEntry (new ZipEntry (entryName));
        contentIn = content.openStream ();
        int size;
        while ((size = contentIn.read (buffer)) != - 1) {
            zipOut.write (buffer, 0, size);
        }
        zipOut.closeEntry ();
    } finally {
        if (contentIn != null) {
            contentIn.close ();
        }
    }
}


public List < String > getFileNames (Pattern regex, boolean matchOnlyFileName) throws IOException {
    if (file.isFile () && file.getName ().endsWith (".zip")) {
        ZipFile zipfile = new ZipFile (file);
        List < String > results = new ArrayList ();
        for (Enumeration < ? extends ZipEntry > entries = zipfile.entries (); entries.hasMoreElements ();) {
            ZipEntry zipEntry = entries.nextElement ();
            if (! matchOnlyFileName && regex.matcher (zipEntry.getName ()).find ()) {
                results.add (zipEntry.getName ());
            }
            else if (regex.matcher (new File (zipEntry.getName ()).getName ()).find ()) {
                results.add (zipEntry.getName ());
            }
        }
        return results;
    }
    else if (file.isDirectory ()) {
        return findFilesInDir (regex, matchOnlyFileName, file);
    }
    else {
        throw new IOException (file.getAbsolutePath () + " is not in a compatible form");
    }
}


-----Function Pair=194=-----=1=

public static void addToZip (File f, ZipOutputStream zip) throws IOException {
    if (f.isDirectory ()) {
        for (File s : f.listFiles ()) {
            addToZip (s, zip);
        }
    }
    else {
        String baseName = FileDestDir.getCanonicalPath ();
        String fullPath = f.getCanonicalPath ();
        String nameSufix = fullPath.substring (baseName.length () + 1);
        FileInputStream in = new FileInputStream (f);
        byte [] data = new byte [in.available ()];
        in.read (data);
        ZipEntry entry = new ZipEntry (nameSufix.replace ('\\', '/'));
        entry.setSize (data.length);
        entry.setTime (f.lastModified ());
        zip.putNextEntry (entry);
        zip.write (data);
        zip.closeEntry ();
    }
}


public static void zipFiles (File src, File out, FileFilters pattern, boolean verbos) throws Exception {
    src = src.getCanonicalFile ();
    out = out.getCanonicalFile ();
    if (! src.isHidden ()) {
        String root = "";
        if (src.isDirectory ()) {
            root = src.getCanonicalPath ();
        }
        else if (src.isFile ()) {
            root = src.getParentFile ().getCanonicalPath ();
        }
        LinkedHashMap < String, byte [] > entrys = new LinkedHashMap < String, byte [] > ();
        zipFiles (src, pattern, root, entrys, verbos);
        if (! entrys.isEmpty ()) {
            out.createNewFile ();
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            ZipOutputStream zos = new ZipOutputStream (baos);
            for (Entry < String, byte [] > e : entrys.entrySet ()) {
                ZipEntry ze = new ZipEntry (e.getKey ());
                ze.setTime (0);
                zos.putNextEntry (ze);
                zos.write (e.getValue ());
            }
            zos.close ();
            CFile.writeData (out, baos.toByteArray ());
        }
    }
}


-----Function Pair=195=-----==

public static File gunzip (File file) {
    String name = null;
    byte [] data = new byte [2048];
    try {
        GZIPInputStream zip = new GZIPInputStream (new FileInputStream (file));
        String repName = "temp" + file.getName ();
        File newRep = new File (repName);
        newRep.mkdirs ();
        name = repName + "/" + file.getName ().substring (0, file.getName ().length () - 3);
        OutputStream dest = new FileOutputStream (name);
        int count;
        while ((count = zip.read (data)) > 0) {
            dest.write (data, 0, count);
        }
        dest.close ();
        zip.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return new File (name);
}


void testFileObject (JavaFileObject fo) throws Exception {
    URI uri = fo.toUri ();
    System.err.println ("uri: " + uri);
    URLConnection urlconn = uri.toURL ().openConnection ();
    if (urlconn instanceof JarURLConnection) {
        JarURLConnection jarconn = (JarURLConnection) urlconn;
        File f = new File (jarconn.getJarFile ().getName ());
        foundJars.add (f.getName ());
    }
    try {
        byte [] uriData = read (urlconn.getInputStream ());
        byte [] foData = read (fo.openInputStream ());
        if (! Arrays.equals (uriData, foData)) {
            if (uriData.length != foData.length) throw new Exception ("data size differs: uri data " + uriData.length + " bytes, fo data " + foData.length + " bytes");
            for (int i = 0; i < uriData.length; i ++) {
                if (uriData [i] != foData [i]) throw new Exception ("unexpected data returned at offset " + i + ", uri data " + uriData [i] + ", fo data " + foData [i]);
            }
            throw new AssertionError ("cannot find difference");
        }
    } finally {
        if (urlconn instanceof JarURLConnection) {
            JarURLConnection jarconn = (JarURLConnection) urlconn;
            jarconn.getJarFile ().close ();
        }
    }
}


-----Function Pair=196=-----==

public void write (OutputStream out) throws IOException {
    String dir = info.getDirectory ();
    if (dir == null && info.getFiles ().length == 1) {
        String path = info.getBaseDirectory () + "/" + info.getFiles () [0].getPath ();
        writeFile (path, out);
    }
    else {
        ZipOutputStream zipOut = new ZipOutputStream (out);
        zipOut.setLevel (0);
        zipOut.setComment ("name: " + info.getName () + info.getComment () != null ? "\n comment:" + info.getComment () : "" + info.getTag () != null ? "\n tag:" + info.getTag () : "");
        FileInfo [] files = info.getFiles ();
        char separator = rtorrent.getFileSeparatoChar ();
        String remoteBaseDir = info.getBaseDirectory ();
        String remoteBasePath = remoteBaseDir + separator + dir;
        for (FileInfo fileInfo : files) {
            String remotePath = '\'' + remoteBasePath + separator + fileInfo.getPath () + '\'';
            ZipEntry entry = new ZipEntry (dir + "\\" + fileInfo.getPath ().replace (separator, '\\'));
            zipOut.putNextEntry (entry);
            writeFile (remotePath, zipOut);
        }
        zipOut.finish ();
    }
}


protected File createArchive (File dir2Archive, File newArchive) {
    byte buf [] = new byte [BUF_SIZE];
    if (dir2Archive.getParentFile ().canWrite ()) {
        ZipOutputStream out = null;
        String prefix = dir2Archive.getName () + "/";
        ZipEntry entry;
        int cRead;
        try {
            FileOutputStream stream = new FileOutputStream (newArchive);
            out = new ZipOutputStream (stream);
            entry = new ZipEntry (prefix);
            entry.setTime (dir2Archive.lastModified ());
            out.putNextEntry (entry);
            for (File cur : dir2Archive.listFiles ()) {
                if (cur.isFile () && cur.canRead ()) {
                    entry = new ZipEntry (prefix + cur.getName ());
                    entry.setTime (cur.lastModified ());
                    entry.setSize (cur.length ());
                    out.putNextEntry (entry);
                    FileInputStream in = new FileInputStream (cur);
                    while ((cRead = in.read (buf, 0, buf.length)) > 0) {
                        out.write (buf, 0, cRead);
                    }
                    in.close ();
                }
            }
        } catch (Throwable t) {
            t.printStackTrace ();
        } finally {
            try {
                if (out != null) out.close ();
            } catch (Throwable t) {
            }
        }
    }
    return newArchive;
}


-----Function Pair=197=-----==

public static String fileToString (File file, int maxSize) throws FileNotFoundException, IOException, UnknownHostException {
    logger.info ("converting " + file.getAbsolutePath ());
    if (! file.exists () || file.length () == 0) {
        return findCompressed (file);
    }
    if (file.isDirectory ()) {
        File zipped = zip (file);
        return ("ZIPPED directory can be found at the url: " + fileToUrl (zipped));
    }
    if (file.length () > maxSize) {
        return ("As file is very large use the url: " + fileToUrl (file));
    }
    BufferedReader reader = new BufferedReader (new FileReader (file));
    StringBuffer results = new StringBuffer ();
    String line = null;
    while ((line = reader.readLine ()) != null) {
        results.append (line);
        results.append (NEW_LINE);
    }
    reader.close ();
    return results.toString ();
}


File createJar (String name, String...entries) throws IOException {
    File jar = new File (name);
    OutputStream out = new FileOutputStream (jar);
    try {
        JarOutputStream jos = new JarOutputStream (out);
        for (String e : entries) {
            jos.putNextEntry (new ZipEntry (e));
            jos.write (e.getBytes ());
        }
        jos.close ();
    } finally {
        out.close ();
    }
    return jar;
}


-----Function Pair=198=-----==

public static int unzipFile (File file_input, File dir_output) {
    ZipInputStream zip_in_stream;
    try {
        FileInputStream in = new FileInputStream (file_input);
        BufferedInputStream source = new BufferedInputStream (in);
        zip_in_stream = new ZipInputStream (source);
    } catch (IOException e) {
        return STATUS_IN_FAIL;
    }
    byte [] input_buffer = new byte [BUF_SIZE];
    int len = 0;
    do {
        try {
            ZipEntry zip_entry = zip_in_stream.getNextEntry ();
            if (zip_entry == null) break;
            File output_file = new File (dir_output, zip_entry.getName ());
            FileOutputStream out = new FileOutputStream (output_file);
            BufferedOutputStream destination = new BufferedOutputStream (out, BUF_SIZE);
            while ((len = zip_in_stream.read (input_buffer, 0, BUF_SIZE)) != - 1) destination.write (input_buffer, 0, len);
            destination.flush ();
            out.close ();
        } catch (IOException e) {
            return STATUS_GUNZIP_FAIL;
        }
    }
    while (true);
    try {
        zip_in_stream.close ();
    } catch (IOException e) {
    }
    return STATUS_OK;
}


public static void zipDir (String relativeTo, String dir2zip, ZipOutputStream zos) throws Exception {
    File zipDir = new File (dir2zip);
    String [] dirList = zipDir.list ();
    byte [] readBuffer = new byte [2156];
    int bytesIn = 0;
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (zipDir, dirList [i]);
        if (f.isDirectory ()) {
            if (f.getName ().equals ("CVS")) {
                continue;
            }
            String filePath = f.getPath ();
            zipDir (relativeTo, filePath, zos);
            continue;
        }
        if (f.getName ().startsWith ("save-")) {
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        ZipEntry anEntry = new ZipEntry (f.getPath ().substring (relativeTo.length ()));
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            zos.write (readBuffer, 0, bytesIn);
        }
        zos.closeEntry ();
        fis.close ();
    }
}


-----Function Pair=199=-----==

public static ArrayList < File > upZipSelectedFile (File zipFile, String folderPath, String nameContains) throws ZipException, IOException {
    ArrayList < File > fileList = new ArrayList < File > ();
    File desDir = new File (folderPath);
    if (! desDir.exists ()) {
        desDir.mkdir ();
    }
    ZipFile zf = new ZipFile (zipFile);
    for (Enumeration < ? > entries = zf.entries (); entries.hasMoreElements ();) {
        ZipEntry entry = ((ZipEntry) entries.nextElement ());
        if (entry.getName ().contains (nameContains)) {
            InputStream in = zf.getInputStream (entry);
            String str = folderPath + File.separator + entry.getName ();
            str = new String (str.getBytes ("8859_1"), "GB2312");
            File desFile = new File (str);
            if (! desFile.exists ()) {
                File fileParentDir = desFile.getParentFile ();
                if (! fileParentDir.exists ()) {
                    fileParentDir.mkdirs ();
                }
                desFile.createNewFile ();
            }
            OutputStream out = new FileOutputStream (desFile);
            byte buffer [] = new byte [BUFF_SIZE];
            int realLength;
            while ((realLength = in.read (buffer)) > 0) {
                out.write (buffer, 0, realLength);
            }
            in.close ();
            out.close ();
            fileList.add (desFile);
        }
    }
    return fileList;
}


public GameObject findObject (int x, int y) {
    int not_above = getRenderSkipLift ();
    int start_cx = ((scrolltx + x / EConst.c_tilesize) / EConst.c_tiles_per_chunk) % EConst.c_num_chunks;
    int start_cy = ((scrollty + y / EConst.c_tilesize) / EConst.c_tiles_per_chunk) % EConst.c_num_chunks;
    int stop_cx = (2 + (scrolltx + (x + 4 * not_above) / EConst.c_tilesize) / EConst.c_tiles_per_chunk) % EConst.c_num_chunks;
    int stop_cy = (2 + (scrollty + (y + 4 * not_above) / EConst.c_tilesize) / EConst.c_tiles_per_chunk) % EConst.c_num_chunks;
    GameObject best = null;
    boolean trans = true;
    for (int cy = start_cy; cy != stop_cy; cy = EConst.INCR_CHUNK (cy)) for (int cx = start_cx; cx != stop_cx; cx = EConst.INCR_CHUNK (cx)) {
        MapChunk olist = map.getChunk (cx, cy);
        if (olist == null) continue;
        ObjectList.ObjectIterator iter = olist.getObjects ().getIterator ();
        GameObject obj;
        while ((obj = iter.next ()) != null) {
            if (obj.getLift () >= not_above) continue;
            getShapeRect (tempFind, obj);
            if (! tempFind.hasPoint (x, y) || ! obj.isFindable ()) continue;
            ShapeFrame s = obj.getShape ();
            getShapeLocation (tempPoint, obj);
            if (! s.hasPoint (x - tempPoint.x, y - tempPoint.y)) continue;
            if (best == null || best.lt (obj) == 1 || trans) {
                boolean ftrans = obj.getInfo ().isTransparent ();
                if (! ftrans || trans) {
                    best = obj;
                    trans = ftrans;
                }
            }
        }
    }
    return (best);
}


-----Function Pair=200=-----=1=

private void addDirectoryToZip (ZipOutputStream out, File dir, String path) throws IOException {
    byte [] buf = new byte [1024];
    File [] children = dir.listFiles ();
    for (File f : children) {
        if (f.isDirectory ()) {
            out.putNextEntry (new ZipEntry (path + f.getName () + '/'));
            out.closeEntry ();
            addDirectoryToZip (out, f, path + f.getName () + '/');
        }
        else {
            FileInputStream in = new FileInputStream (f);
            out.putNextEntry (new ZipEntry (path + f.getName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
            f.deleteOnExit ();
        }
    }
}


private static void zipFile (String folder, File file, ZipOutputStream zipOutputStream, FileFilter filter) throws IOException {
    if (file.isFile ()) {
        if (logger.isDebugEnabled ()) {
            logger.debug ("zipFile(File, ZipOutputStream, FileFilter) - handel file=" + file);
        }
        FileInputStream in = new FileInputStream (file.getPath ());
        zipOutputStream.putNextEntry (new ZipEntry (folder + file.getName ()));
        int len;
        byte [] buf = new byte [1024];
        while ((len = in.read (buf)) > 0) {
            zipOutputStream.write (buf, 0, len);
        }
        zipOutputStream.closeEntry ();
        in.close ();
    }
    else {
        if (logger.isDebugEnabled ()) {
            logger.debug ("zipFile(File, ZipOutputStream, FileFilter) - handel folder=" + file);
        }
        zipOutputStream.putNextEntry (new ZipEntry (folder + file.getName () + "/"));
        zipOutputStream.closeEntry ();
        for (File subFile : file.listFiles (filter)) {
            zipFile (folder + file.getName () + "/", subFile, zipOutputStream, filter);
        }
    }
}


-----Function Pair=201=-----==

public static void zip (File zipFile, List < File > filesToZip, boolean useAbsolutePath, String removePrefix) throws IOException {
    byte [] buffer = new byte [BUFFER];
    zipFile.createNewFile ();
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    out.setLevel (Deflater.DEFAULT_COMPRESSION);
    for (File file : filesToZip) {
        String name = file.getName ();
        if (useAbsolutePath) {
            name = file.getAbsolutePath ();
            if (removePrefix != null) {
                name = name.replace (removePrefix, "");
            }
        }
        FileInputStream in = new FileInputStream (file);
        try {
            out.putNextEntry (new ZipEntry (name));
            System.out.println (name);
            int len;
            while ((len = in.read (buffer)) > 0) {
                out.write (buffer, 0, len);
            }
            out.closeEntry ();
        } catch (Exception ex) {
            Log.exception (ex);
            try {
                out.closeEntry ();
            } catch (Exception ex2) {
            }
        } finally {
            in.close ();
        }
    }
    out.close ();
}


private static ArrayList pathNames (File dir) throws FileNotFoundException, IOException {
    ArrayList names = new ArrayList ();
    try {
        String parentName = dir.getPath ();
        String [] list = dir.list ();
        File [] files = new File [list.length];
        for (int i = 0; i < list.length; i ++) {
            String pathName = parentName + File.separator + list [i];
            files [i] = new File (pathName);
            if (files [i].isFile ()) names.add (files [i].getPath ());
        }
        for (int i = 0; i < list.length; i ++) {
            if (files [i].isDirectory ()) {
                String name = parentName + File.separator + list [i];
                ArrayList sub = pathNames (files [i]);
                Iterator it = sub.iterator ();
                while (it.hasNext ()) names.add (it.next ());
            }
        }
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
        throw e;
    }
    return names;
}


-----Function Pair=202=-----==

private void showViewImportDialog () {
    JPanel dialogPanel = new JPanel ();
    dialogPanel.setLayout (new FLGColumnLayout ());
    JRadioButton localViewImport_radioButton = new JRadioButton (internationalization.getString ("dialog.viewImport.radioButton.localViewImport"));
    localViewImport_radioButton.setSelected (true);
    JRadioButton serverViewImport_radioButton = new JRadioButton (internationalization.getString ("dialog.viewImport.radioButton.serverViewImport"));
    ButtonGroup buttonGroup = new ButtonGroup ();
    buttonGroup.add (localViewImport_radioButton);
    buttonGroup.add (serverViewImport_radioButton);
    dialogPanel.add (localViewImport_radioButton, FLGColumnLayout.LEFTEND);
    dialogPanel.add (serverViewImport_radioButton, FLGColumnLayout.LEFTEND);
    int returnValue = FLGOptionPane.showConfirmDialog (dialogPanel, internationalization.getString ("dialog.viewImport.title"), FLGOptionPane.OK_CANCEL_OPTION, FLGOptionPane.PLAIN_MESSAGE);
    if (returnValue == FLGOptionPane.OK_OPTION) {
        FSLLearningUnitsManager learningUnitsManager = (FSLLearningUnitsManager) learningUnitEventGenerator;
        if (localViewImport_radioButton.isSelected ()) {
            JFileChooser fileDialog = new JFileChooser ();
            fileDialog.setDialogTitle (internationalization.getString ("fileDialog.viewImport.title"));
            java.awt.Dimension screenDim = java.awt.Toolkit.getDefaultToolkit ().getScreenSize ();
            fileDialog.setLocation ((int) (screenDim.getWidth () - fileDialog.getWidth ()) / 2, (int) (screenDim.getHeight () - fileDialog.getHeight ()) / 2);
            String [] fileExtensions = {".fslv"};
            fileDialog.setFileFilter (new FLGUIUtilities.FLGFileFilter (fileExtensions, ".fslv"));
            if (fileDialog.showOpenDialog (new JPanel ()) == JFileChooser.APPROVE_OPTION) {
                File selectedFile = fileDialog.getSelectedFile ();
                FSLLearningUnitViewSynchronizeManager manager = new FSLLearningUnitViewSynchronizeManager (learningUnitsManager, learningUnitViewManager, learningUnitViewElementsManager, null);
                if (manager.showSynchronizeManagerDialog (selectedFile.getAbsolutePath (), true, true)) {
                    if (manager.getImportStructure ()) {
                        returnValue = FLGOptionPane.showConfirmDialog (internationalization.getString ("dialog.viewImport.viewOverwriteMessage.message"), internationalization.getString ("dialog.viewImport.viewOverwriteMessage.title"), FLGOptionPane.OK_CANCEL_OPTION, FLGOptionPane.QUESTION_MESSAGE);
                        if (returnValue == FLGOptionPane.OK_OPTION) {
                            FSLLearningUnitViewLinkCheckerDialog linkCheckerDialog = new FSLLearningUnitViewLinkCheckerDialog ();
                            if (linkCheckerDialog.showDialog () == FLGOptionPane.OK_OPTION) {
                                importLearningUnitView (false, selectedFile, linkCheckerDialog.checkLinkInOtherUnits (), linkCheckerDialog.checkLinkInOtherViews (), linkCheckerDialog.checkLinksOnlyOnExistingElements ());
                            }
                        }
                    }
                }
            }
        }
        else {
            FSLLearningUnitsDescriptor learningUnitsDescriptor = learningUnitsManager.getLearningUnitsDescriptor ();
            FSLLearningUnitDescriptor learningUnitDescriptor = learningUnitsDescriptor.getDescriptorById (learningUnitsManager.getActiveLearningUnitId ());
            String serverName = learningUnitDescriptor.getOpenUssServerName ();
            if (serverName != null) {
                if (! serverName.equals ("")) {
                    if (learningUnitsManager.openUSSServerConnectionIsEstablished ()) {
                        FSLLearningUnitViewOpenUSSWebServiceClient webServiceClient = new FSLLearningUnitViewOpenUSSWebServiceClient (learningUnitViewManager, learningUnitViewElementsManager, serverName, learningUnitsManager.getOpenussUserName (), learningUnitsManager.getOpenussPassword ());
                        FSLLearningUnitViewSynchronizeManager synchronizeManager = new FSLLearningUnitViewSynchronizeManager (learningUnitsManager, learningUnitViewManager, learningUnitViewElementsManager, webServiceClient);
                        if (synchronizeManager.showSynchronizeManagerDialog (null, true, false)) {
                            if (synchronizeManager.getImportStructure ()) {
                                returnValue = FLGOptionPane.showConfirmDialog (internationalization.getString ("dialog.viewImport.viewOverwriteMessage.message"), internationalization.getString ("dialog.viewImport.viewOverwriteMessage.title"), FLGOptionPane.OK_CANCEL_OPTION, FLGOptionPane.QUESTION_MESSAGE);
                                if (returnValue == FLGOptionPane.OK_OPTION) {
                                    File fslvFile = webServiceClient.downloadLearningUnitView (learningUnitDescriptor.getEnrollmentId (), learningUnitsManager.getActiveLearningUnitId (), learningUnitViewManager.getLearningUnitViewOriginalDataDirectory ().getName ());
                                    FSLLearningUnitViewLinkCheckerDialog linkCheckerDialog = new FSLLearningUnitViewLinkCheckerDialog ();
                                    if (linkCheckerDialog.showDialog () == FLGOptionPane.OK_OPTION) {
                                        importLearningUnitView (true, fslvFile, linkCheckerDialog.checkLinkInOtherUnits (), linkCheckerDialog.checkLinkInOtherViews (), linkCheckerDialog.checkLinksOnlyOnExistingElements ());
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    returnValue = FLGOptionPane.showConfirmDialog (internationalization.getString ("dialog.viewImport.noSeverConfiguration.message"), internationalization.getString ("dialog.viewImport.noSeverCOnfiguration.title"), FLGOptionPane.OK_OPTION, FLGOptionPane.ERROR_MESSAGE);
                }
            }
            else {
                returnValue = FLGOptionPane.showConfirmDialog (internationalization.getString ("dialog.viewImport.noSeverConfiguration.message"), internationalization.getString ("dialog.viewImport.noSeverCOnfiguration.title"), FLGOptionPane.OK_OPTION, FLGOptionPane.ERROR_MESSAGE);
            }
        }
    }
}


public void actionPerformed (ActionEvent e) {
    Object source = e.getSource ();
    if (source == create_card) {
        if (left_type == Side.NUM_CARD_TYPES) {
            CardDialog d = new CardDialog (- 1, Side.TEXT, Side.TEXT, sets, default_sets);
            d.show ();
            if (d.isOKPressed ()) {
                left_type = d.getLeftType ();
                right_type = d.getRightType ();
                default_sets = d.member;
            }
            else {
                updatePosition ();
                return;
            }
        }
        Card card = new Card (left_type, right_type);
        insertCard (card, current_card + 1, default_sets);
        undo_manager.addEdit (new CreateCard (card, current_card, default_sets));
        updateEditMenu ();
    }
    else if (source == defaults) {
        CardDialog d;
        if (left_type == Side.NUM_CARD_TYPES) d = new CardDialog (- 1, Side.TEXT, Side.TEXT, sets, default_sets);
        else d = new CardDialog (- 1, left_type, right_type, sets, default_sets);
        d.show ();
        if (d.isOKPressed ()) {
            left_type = d.getLeftType ();
            right_type = d.getRightType ();
            default_sets = d.member;
        }
    }
    else if (source == delete_card) {
        int cardNum = current_card;
        Card c = (Card) cards.elementAt (cardNum);
        boolean member [] = new boolean [sets.size ()];
        deleteCard (current_card, member);
        undo_manager.addEdit (new DeleteCard (c, cardNum, member));
        updateEditMenu ();
    }
    else if (source == drop) {
        int numLeft = goRandom (false);
        if (numLeft == 0) done.doClick ();
        else if (numLeft == 1) keep.setEnabled (false);
    }
    else if (source == find) find ();
    else if (source == find_next) if (find_text != null) find_next ();
    else find ();
    else if (source == first) goFirst ();
    else if (source == import_text_file) importFile ();
    else if (source == keep) goRandom (true);
    else if (source == last) goLast ();
    else if (source == learned) {
        ((Card) cards.elementAt (current_card)).learned = learned.isSelected ();
        dirty = true;
    }
    else if (source == location) {
        GoToDialog d = new GoToDialog (current_index + 1, numCardsViewable ());
        d.show ();
        if (d.isOKPressed ()) {
            current_index = d.getNumber () - 1;
            closeCard ();
            current_card = ((Integer) set_members.elementAt (current_index)).intValue ();
            openCard ();
        }
    }
    else if (source == move_bottom) {
        undo_manager.addEdit (new MoveCard (current_card, cards.size () - 1));
        updateEditMenu ();
        moveCard (current_card, cards.size () - 1);
    }
    else if (source == move_down) {
        undo_manager.addEdit (new MoveCard (current_card, current_card + 1));
        updateEditMenu ();
        moveCard (current_card, current_card + 1);
    }
    else if (source == move_top) {
        undo_manager.addEdit (new MoveCard (current_card, 0));
        updateEditMenu ();
        moveCard (current_card, 0);
    }
    else if (source == move_up) {
        undo_manager.addEdit (new MoveCard (current_card, current_card - 1));
        updateEditMenu ();
        moveCard (current_card, current_card - 1);
    }
    else if (source == next) goNext ();
    else if (source == prev) goPrev ();
    else if (source == properties) {
        Card card = (Card) cards.elementAt (current_card);
        CardDialog d = new CardDialog (current_card, card.left_side.getType (), card.right_side.getType (), sets);
        d.show ();
        if (d.isOKPressed ()) {
            Side left_side = card.left_side, right_side = card.right_side;
            if (left_side.getType () != d.getLeftType ()) left_side = Side.newSide (d.getLeftType (), true);
            if (right_side.getType () != d.getRightType ()) right_side = Side.newSide (d.getRightType (), false);
            undo_manager.addEdit (new CardProperties (current_card, sets, card.left_side, card.right_side, left_side, right_side));
            updateEditMenu ();
            setCardSides (current_card, left_side, right_side);
            sets.setCardSets (current_card, d.member);
            validate ();
            repaint ();
        }
    }
    else if (source == redo) {
        undo_manager.redo ();
        updateEditMenu ();
    }
    else if (source == show) {
        Card card = (Card) cards.elementAt (current_card);
        card.left_side.setVisible (true);
        card.right_side.setVisible (true);
        keep.requestFocus ();
    }
    else if (source == undo) {
        undo_manager.undo ();
        updateEditMenu ();
    }
}


-----Function Pair=203=-----==

private List getMediafileByCd (final int cdId) {
    final EntityManager em = GenericDAO.getEntityManager ();
    Query q;
    switch (_version) {
        case 1 :
            q = em.createNativeQuery ("SELECT id, title, artist, albumnr, cdnr, laenge, bitrate, groesse, path FROM mediafile WHERE cdnr = ?");
            break;
        case 2 :
        case 3 :
            q = em.createNativeQuery ("SELECT id, title, artist, albumnr, cdnr, playtime, bitrate, size, path FROM mediafile WHERE cdnr = ?");
            break;
        case 4 :
            q = em.createNativeQuery ("SELECT mfid, title, artist, albumnr, cdnr, playtime, bitrate, filesize, path FROM mediafile WHERE cdnr = ?");
            break;
        default :
            q = null;
            break;
    }
    q.setParameter (1, cdId);
    final List result = q.getResultList ();
    em.close ();
    return result;
}


private byte [] updateDeleteAfter (HTTPurl urlData) throws Exception {
    int deleteAfter = 0;
    try {
        deleteAfter = Integer.parseInt (urlData.getParameter ("deleteafter"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.time", new Integer (deleteAfter).toString ());
    int deleteAction = 0;
    try {
        deleteAction = Integer.parseInt (urlData.getParameter ("deleteaction"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.action", new Integer (deleteAction).toString ());
    System.out.println ("Action After : " + deleteAfter);
    System.out.println ("Action : " + deleteAction);
    String redirect = "HTTP/1.0 302 Moved Temporarily\n";
    redirect += "Location: /servlet/ScheduleDataRes\n\n";
    return redirect.getBytes ();
}


-----Function Pair=204=-----==

private static void copyFile (File output, InputStream input) throws CaughtException {
    try {
        logger.info ("Coping file " + input);
        BufferedInputStream is = new BufferedInputStream (input);
        logger.info ("Using " + is);
        logger.info ("going To " + output);
        checkExists (output.getParentFile ());
        FileOutputStream fos = new FileOutputStream (output);
        logger.info ("To " + fos);
        BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
        logger.info ("reading to copy to " + dest);
        int count;
        byte data [] = new byte [BUFFER];
        while ((count = is.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        is.close ();
        dest.flush ();
        dest.close ();
    } catch (IOException e) {
        throw new CaughtException (e, logger);
    }
}


SXCParser () {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    dbf.setValidating (true);
    dbf.setIgnoringComments (true);
    dbf.setIgnoringElementContentWhitespace (true);
    DocumentBuilder db = null;
    try {
        db = dbf.newDocumentBuilder ();
        Document doc = null;
        InputStream istr = new ZipFile ("essai1.sxc").getInputStream (new ZipEntry ("content.xml"));
        doc = db.parse (istr, "file:///home/raph/DOM/SXC/nulldtd/office.dtd");
        FileWriter f1 = new FileWriter ("save.xml");
        new org.apache.soap.util.xml.DOM2Writer ().serializeAsXML (doc, f1);
        f1.close ();
        ZipOutputStream zostr = new ZipOutputStream (new FileOutputStream ("essai2.sxc"));
        zostr.putNextEntry (new ZipEntry ("content.xml"));
        OutputStreamWriter osw = new OutputStreamWriter (zostr);
        new org.apache.soap.util.xml.DOM2Writer ().serializeAsXML (doc, osw);
        osw.close ();
        DisplayNotes (doc);
    } catch (ParserConfigurationException pce) {
        System.err.println (pce);
        System.exit (1);
    } catch (org.xml.sax.SAXException se) {
        System.err.println (se.getMessage ());
        System.exit (1);
    } catch (IOException ioe) {
        System.err.println (ioe);
        System.exit (1);
    }
}


-----Function Pair=205=-----==

public static long sumMBeanAttributes (MBeanServer server, ObjectName queryName, String attrName) {
    long result = 0;
    Iterator < ObjectName > itr = server.queryNames (appendWildCard (queryName), null).iterator ();
    while (itr.hasNext ()) {
        ObjectName objName = itr.next ();
        try {
            Object obj = server.getAttribute (objName, attrName);
            if (obj instanceof Number) {
                result += ((Number) obj).longValue ();
            }
        } catch (Exception e) {
            logger.logWarn ("Unable to retrieve attribute: " + attrName + " from Object: " + objName.toString (), e);
        }
    }
    return result;
}


public static void addFileToZip (ZipOutputStream zos, File file, String leadPath) throws IOException {
    if (leadPath == null) {
        leadPath = new String ("");
    }
    if (file.isDirectory ()) {
        return;
    }
    ZipEntry ze = new ZipEntry (leadPath + file.getName ());
    zos.putNextEntry (ze);
    FileInputStream in = new FileInputStream (file);
    int c;
    byte [] b = new byte [1024];
    while ((c = in.read (b)) != - 1) {
        zos.write (b, 0, c);
    }
    in.close ();
    zos.closeEntry ();
}


-----Function Pair=206=-----==

private synchronized void fetchGeometriesFromCache () {
    System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " from cache...");
    loading = true;
    loaded = false;
    try {
        if (parent != null) {
            parent.setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
        }
        FileInputStream inFile = new FileInputStream (new File (getFileName ()));
        ObjectInputStream inObject = new ObjectInputStream (inFile);
        Object cachedObject = inObject.readObject ();
        if (cachedObject instanceof Vector [] []) {
            matrix = (Vector [] []) cachedObject;
            if (parent != null) {
                parent.repaint ();
            }
        }
        else {
            System.out.println (cachedObject.getClass ());
        }
        loaded = true;
    } catch (InvalidClassException e) {
        e.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    if (! loaded) {
        fetchGeometriesFromDatabase ();
    }
    loading = false;
    if (parent != null) {
        parent.setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));
    }
    System.out.println ("Fetching geometries " + geometrySetConfig.getSqlScheme () + "." + geometrySetConfig.getSqlTable () + " done...");
}


protected Zipper (OutputStream out, List < FileEntry > fileEntrys) {
    Assert.notEmpty (fileEntrys);
    long begin = System.currentTimeMillis ();
    log.debug ("��ʼ����ѹ����");
    try {
        try {
            zipOut = new ZipOutputStream (out);
            for (FileEntry fe : fileEntrys) {
                zip (fe.getFile (), fe.getFilter (), fe.getZipEntry (), fe.getPrefix ());
            }
        } finally {
            zipOut.close ();
        }
    } catch (IOException e) {
        throw new RuntimeException ("����ѹ����ʱ������IO�쳣��", e);
    }
    long end = System.currentTimeMillis ();
    log.info ("����ѹ����ɹ�����ʱ��{}ms��", end - begin);
}


-----Function Pair=207=-----==

public void decodeXMLForm (String vs, XMLForm xform) {
    if (log.isDebugEnabled ()) {
        log.debug ("processing viewstate size:" + vs.length ());
    }
    try {
        byte [] zipped = Base64.decode (vs.getBytes ());
        ByteArrayInputStream bin = new ByteArrayInputStream (zipped);
        ZipInputStream zin = new ZipInputStream (bin);
        byte [] buffer = new byte [128];
        int len = 0;
        ZipEntry entry = zin.getNextEntry ();
        if ("phase".equals (entry.getName ())) {
            len = zin.read (buffer, 0, buffer.length);
            xform.setPhase (new String (buffer, 0, len));
            entry = zin.getNextEntry ();
        }
        if ("xml".equals (entry.getName ())) {
            xform.loadState (zin);
        }
        else {
            log.warn ("Cannot find xml zip entry");
        }
    } catch (IOException ex) {
        throw new XMLException ("Unable to load viewstate: " + ex);
    }
}


public String getCustomColumns (String libraryId, String category) {
    Integer libraryIdInt = new Integer (libraryId);
    String xml = "";
    try {
        LocalGENERAL_SETUP_PMT local = ((LocalGENERAL_SETUP_PMTHome) HomeFactory.getInstance ().getHome ("GENERAL_SETUP_PMT")).findByLibraryID (libraryIdInt);
        String s1 = local.getPat_Field_Cust ();
        String s2 = local.getHold_Field_Cust ();
        ejb.bprocess.util.Utility utility = ejb.bprocess.util.Utility.getInstance ();
        if (category.trim ().equals ("PATRON")) {
            xml = utility.getTestedString (s1);
        }
        else if (category.trim ().equals ("HOLDINGS")) {
            xml = utility.getTestedString (s2);
        }
    } catch (Exception exp) {
        exp.printStackTrace ();
    }
    return xml;
}


-----Function Pair=208=-----==

private void importFile (File file, String parent) throws Exception {
    List < HttpFormEntry > postEntries = new ArrayList < HttpFormEntry > ();
    addUrlArgs (postEntries);
    postEntries.add (HttpFormEntry.hidden (ARG_GROUP, parent));
    postEntries.add (new HttpFormEntry (ARG_FILE, IOUtil.getFileTail (file.toString ()), IOUtil.readBytes (new FileInputStream (file))));
    String [] result = doPost (URL_ENTRY_XMLCREATE, postEntries);
    if (result [0] != null) {
        System.err.println ("Error:" + result [0]);
        return;
    }
    System.err.println ("result:" + result [1]);
    Element response = XmlUtil.getRoot (result [1]);
    String body = XmlUtil.getChildText (response).trim ();
    if (responseOk (response)) {
        System.err.println ("OK:" + body);
    }
    else {
        System.err.println ("Error:" + body);
    }
}


void test (JavaFileObject fo, File dir, String p) {
    System.err.println ("Test: " + fo);
    String expect = dir.isDirectory () ? new File (dir, p).getPath () : (dir.getPath () + "(" + p + ")");
    String found = fo.getName ();
    String found2 = found.replaceAll ("lib([\\\\/])ct.sym\\(META-INF/sym/rt.jar/", "jre$1lib$1rt.jar(");
    if (! expect.equals (found2)) {
        System.err.println ("expected: " + expect);
        System.err.println ("   found: " + found);
        if (! found.equals (found2)) System.err.println ("  found2: " + found2);
        error ("Failed: " + fo);
    }
    foundClasses.add (fo.getClass ().getSimpleName ());
    if (found.contains ("(")) {
        foundJars.add (new File (found.substring (0, found.indexOf ("("))).getName ());
    }
}


-----Function Pair=209=-----==

public byte [] getMD5 (FileType file) {
    byte [] hash = null;
    InputStream input = null;
    try {
        MessageDigest digest = MessageDigest.getInstance ("MD5");
        File appFile = new File (this.getFilePath (file));
        if (appFile.exists () && appFile.canRead ()) {
            int read = 0;
            byte [] buffer = new byte [4096];
            input = new FileInputStream (appFile);
            while ((read = input.read (buffer)) > 0) {
                digest.update (buffer, 0, read);
            }
            hash = digest.digest ();
        }
    } catch (Exception ex) {
        logger.warn (ex);
    } finally {
        try {
            if (input != null) input.close ();
        } catch (Exception ex) {
            logger.warn (ex);
        }
    }
    return hash;
}


public static void decimalFormatTest () {
    DecimalFormat df1 = new DecimalFormat ("0000000.0");
    DecimalFormat df2 = new DecimalFormat ("#.#");
    DecimalFormat df3 = new DecimalFormat ("000.000");
    DecimalFormat df4 = new DecimalFormat ("###.###");
    DecimalFormat df5 = new DecimalFormat ("0.000%");
    DecimalFormat df6 = new DecimalFormat (",###");
    System.out.println (df1.format (12.34));
    System.out.println (df2.format (12.34));
    System.out.println (df3.format (12.345578));
    System.out.println (df4.format (12.34));
    System.out.println (df5.format (.0012));
    System.out.println (df6.format (1234567.89));
    BigDecimal bd = new BigDecimal (12345.67890);
    System.out.println (df6.format (bd));
}


-----Function Pair=210=-----==

private Node normalizeXML (Node node) {
    Node ret = node;
    try {
        TransformerFactory tFactory = TransformerFactory.newInstance ();
        Transformer transformer = tFactory.newTransformer (new DOMSource (xslNormalize));
        DOMResult dr = new DOMResult ();
        transformer.transform (new DOMSource (node), dr);
        ret = dr.getNode ();
        tFactory = null;
        transformer = null;
    } catch (TransformerException te) {
        te.printStackTrace ();
        writeHistory (STATUS_FAILED, "The 'Normalized XML' is not valid.  Reason:  " + te.getMessage ());
    }
    return ret;
}


private void addPatientName (Element parent, String patientXPath) {
    try {
        Element el = mCDA.createElement ("name");
        parent.appendChild (el);
        Element el2 = mCDA.createElement ("prefix");
        el.appendChild (el2);
        XPathExpression expression = mXPath.compile ((new StringBuilder (String.valueOf (patientXPath))).append ("/ns0:Person/ns0:Name/ns0:CurrentName/ns0:Given").toString ());
        el2 = mCDA.createElement ("given");
        el2.setTextContent ((String) expression.evaluate (mCCR, XPathConstants.STRING));
        el.appendChild (el2);
        expression = mXPath.compile ((new StringBuilder (String.valueOf (patientXPath))).append ("/ns0:Person/ns0:Name/ns0:CurrentName/ns0:Family").toString ());
        el2 = mCDA.createElement ("family");
        el2.setTextContent ((String) expression.evaluate (mCCR, XPathConstants.STRING));
        el.appendChild (el2);
        el2 = mCDA.createElement ("suffix");
        el.appendChild (el2);
    } catch (XPathExpressionException exp) {
        exp.printStackTrace ();
    }
}


-----Function Pair=211=-----=1=

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    boolean started = false;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken ());
        if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) cache = new Cache (st.nextToken ());
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) {
            short port = Short.parseShort (st.nextToken ());
            addUDP (port);
            addTCP (port);
            started = true;
        }
    }
    if (cache == null) cache = new Cache ();
    if (! started) {
        addUDP ((short) 53);
        addTCP ((short) 53);
    }
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken ());
        else if (keyword.equals ("cache")) cache = new Cache (st.nextToken ());
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


-----Function Pair=212=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=213=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=214=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=215=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=216=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=217=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=218=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=219=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=220=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=221=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=222=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=223=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


-----Function Pair=224=-----==

public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


-----Function Pair=225=-----==

public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


public static void main (String [] args) {
    MuServer s = new MuServer ();
    new Launcher (s).launch (args, 1);
    ClassSpace shared = s.getSharedClassSpace ();
    try {
        System.out.println ("I need " + CLASSNAME + ".class to proceed with execution.");
        System.out.println ("I'm going to fetch it from " + args [0]);
        new Relocator (s).fetchClasses (args [0], new String [] {CLASSNAME}, Relocator.FULLCLOSURE, false);
        while (! shared.containsClass (CLASSNAME)) {
            Thread.sleep (3000);
            System.out.println ("Waiting for the class ...");
        }
        System.out.println ("Class " + CLASSNAME + " is now in my shared class space.");
        Class c = shared.getClass (CLASSNAME);
        c.getMethod ("perform", null).invoke (c.newInstance (), null);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=226=-----==

public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


-----Function Pair=227=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=228=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=229=-----==

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public void _initKeyboard (final double sec) {
    log ("> initKeyboard");
    if (charMap != null) {
        dohrobot.call ("_onKeyboard", new Object [] {});
        return;
    }
    Thread thread = new Thread () {
        public void run () {
            if (! isSecure (sec)) return;
            AccessController.doPrivileged (new PrivilegedAction () {
                public Object run () {
                    charMap = new HashMap ();
                    KeyEvent event = new KeyEvent (applet (), 0, 0, 0, KeyEvent.VK_SPACE, ' ');
                    charMap.put (new Integer (32), event);
                    try {
                        vkKeys = new Vector ();
                        for (char i = 'a'; i <= 'z'; i ++) {
                            vkKeys.add (new Integer (KeyEvent.class.getField ("VK_" + Character.toUpperCase ((char) i)).getInt (null)));
                        }
                        for (char i = '0'; i <= '9'; i ++) {
                            vkKeys.add (new Integer (KeyEvent.class.getField ("VK_" + Character.toUpperCase ((char) i)).getInt (null)));
                        }
                        int [] mykeys = new int [] {KeyEvent.VK_COMMA, KeyEvent.VK_MINUS, KeyEvent.VK_PERIOD, KeyEvent.VK_SLASH, KeyEvent.VK_SEMICOLON, KeyEvent.VK_LEFT_PARENTHESIS, KeyEvent.VK_NUMBER_SIGN, KeyEvent.VK_PLUS, KeyEvent.VK_RIGHT_PARENTHESIS, KeyEvent.VK_UNDERSCORE, KeyEvent.VK_EXCLAMATION_MARK, KeyEvent.VK_DOLLAR, KeyEvent.VK_CIRCUMFLEX, KeyEvent.VK_AMPERSAND, KeyEvent.VK_ASTERISK, KeyEvent.VK_QUOTEDBL, KeyEvent.VK_LESS, KeyEvent.VK_GREATER, KeyEvent.VK_BRACELEFT, KeyEvent.VK_BRACERIGHT, KeyEvent.VK_COLON, KeyEvent.VK_BACK_QUOTE, KeyEvent.VK_QUOTE, KeyEvent.VK_OPEN_BRACKET, KeyEvent.VK_BACK_SLASH, KeyEvent.VK_CLOSE_BRACKET, KeyEvent.VK_EQUALS};
                        for (int i = 0; i < mykeys.length; i ++) {
                            vkKeys.add (new Integer (mykeys [i]));
                        }
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                    robot.setAutoDelay (1);
                    int count = 0;
                    boolean waitingOnSpace = true;
                    do {
                        log ("Pressed space");
                        robot.keyPress (KeyEvent.VK_SPACE);
                        robot.keyRelease (KeyEvent.VK_SPACE);
                        count ++;
                        waitingOnSpace = ((Boolean) window.eval ("doh.robot._spaceReceived")).equals (Boolean.FALSE);
                        log ("JS still waiting on a space? " + waitingOnSpace);
                    }
                    while (count < 500 && waitingOnSpace);
                    robot.keyPress (KeyEvent.VK_ENTER);
                    robot.keyRelease (KeyEvent.VK_ENTER);
                    robot.setAutoDelay (0);
                    log ("< initKeyboard");
                    pressNext ();
                    return null;
                }
            }
            );
        }
    }
    ;
    thread.start ();
}


-----Function Pair=230=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=231=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=232=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=233=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=234=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=235=-----==

public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


-----Function Pair=236=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=237=-----==

public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


-----Function Pair=238=-----==

public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


-----Function Pair=239=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=240=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=241=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=242=-----==

public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


-----Function Pair=243=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=244=-----=1=

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=245=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=246=-----==

public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=247=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=248=-----==

public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=249=-----==

public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=250=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=251=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=252=-----==

public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=253=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=254=-----==

public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


-----Function Pair=255=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


-----Function Pair=256=-----==

public static void main (String [] args) {
    final String version = System.getProperty ("java.version");
    if (version.startsWith ("1.0") || version.startsWith ("1.1") || version.startsWith ("1.2")) {
        System.err.println ("");
        System.err.print ("J requires Java 1.3 or later.");
        System.err.println (" (Java 1.4.1 is recommended.)");
        System.err.println ("");
        System.exit (1);
    }
    try {
        Class c = Class.forName ("org.armedbear.j.Editor");
        Class [] parameterTypes = new Class [1];
        parameterTypes [0] = String [].class;
        Method method = c.getMethod ("main", parameterTypes);
        Object [] parameters = new Object [1];
        parameters [0] = args;
        method.invoke (null, parameters);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public static void boot () {
    if (initialized) return;
    setNames ();
    try {
        VM_Class cls = VM_Class.forName ("VM_JNIFunctions");
        VM_Method [] mths = cls.getDeclaredMethods ();
        for (int i = 0; i < mths.length; i ++) {
            String methodName = mths [i].getName ().toString ();
            int jniIndex = indexOf (methodName);
            if (jniIndex != - 1) {
                JNIFunctions [jniIndex] = mths [i].getMostRecentlyGeneratedInstructions ();
            }
        }
    } catch (VM_ResolutionException e) {
        throw new InternalError ("VM_JNIEnvironment fails to initialize, has the class been renamed\n");
    }
    VM_Magic.setMemoryWord (VM_Magic.objectAsAddress (JNIFunctions) + JNIFUNCTIONS_JTOC_OFFSET, VM_Magic.getTocPointer ());
    initialized = true;
}


-----Function Pair=257=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=258=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=259=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=260=-----==

public MeldungsLeiste () {
    setLayout (new BorderLayout (5, 5));
    hilfeButton = new JButton ("Hilfe");
    hilfeButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent e) {
            if (Desktop.isDesktopSupported () && Desktop.getDesktop ().isSupported (Desktop.Action.BROWSE)) {
                try {
                    java.awt.Desktop.getDesktop ().open (new File ("resources/hilfe/index.html"));
                } catch (final IOException ex) {
                    System.err.println ("Die Hilfeseite von BAUS! konnte nicht gefunden werden");
                }
            }
        }
    }
    );
    westPanel.add (hilfeButton);
    auftragButton = new JButton ("Auftrag");
    auftragButton.addActionListener (new ActionListener () {
        public void actionPerformed (final ActionEvent e) {
            if (Desktop.isDesktopSupported () && Desktop.getDesktop ().isSupported (Desktop.Action.OPEN)) {
                try {
                    java.awt.Desktop.getDesktop ().open (new File ("auftraege/test.pdf"));
                } catch (final IOException ex) {
                    System.err.println ("Der Auftrag konnte nicht angezeigt werden.");
                }
            }
        }
    }
    );
    westPanel.add (auftragButton);
    westPanel.add (new Uhr ());
    add (westPanel, BorderLayout.WEST);
    meldungen = new JTextArea (4, 40);
    meldungen.setEditable (false);
    add (new JScrollPane (meldungen), BorderLayout.CENTER);
}


public void doSearch () {
    try {
        model.clear ();
        results = Engine.search (searchTextField.getText ());
        model.populate (results);
    } catch (IndexNotExistsException e) {
        int response = JOptionPane.showConfirmDialog (this, e.getMessage () + "\nWould you like to create it now?", "Error", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
        if (response == JOptionPane.YES_OPTION) doIndex (false);
    } catch (Exception e) {
        log.log (Level.WARNING, "Error", e);
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
    } finally {
        SwingUtilities.invokeLater (new Runnable () {
            @Override
            public void run () {
                jScrollPane.getViewport ().setViewPosition (new Point (0, 0));
                searchTextField.selectAll ();
                setStatusText ("Documents found: " + (results != null ? results.size () : 0));
                setSearchRunning (false);
            }
        }
        );
    }
}


-----Function Pair=261=-----==

protected void done () {
    NBTBranch branch = null;
    try {
        branch = get ();
    } catch (InterruptedException e) {
        e.printStackTrace ();
    } catch (ExecutionException e) {
        e.printStackTrace ();
        Throwable cause = ExceptionUtils.getRootCause (e);
        showErrorDialog (cause.getMessage ());
        return;
    }
    textFile.setText (base.getAbsolutePath ());
    updateTreeTable (branch);
    Cursor defaultCursor = Cursor.getDefaultCursor ();
    setCursor (defaultCursor);
}


private void copyToClipboard (final boolean getAll) {
    final List < String > items = getItems (getAll);
    if (items == null) {
        return;
    }
    String text;
    if (items.size () > 1) {
        final StringBuilder textToCopy = new StringBuilder ();
        for (final String key : items) {
            textToCopy.append (key).append ("\n");
        }
        text = textToCopy.toString ();
    }
    else {
        text = items.get (0);
    }
    CopyToClipboard.copyText (text);
}


-----Function Pair=262=-----==

public void wrapLabelText () {
    FontMetrics fm = getFontMetrics (getFont ());
    BreakIterator boundary = BreakIterator.getWordInstance ();
    boundary.setText (text);
    StringBuffer trial = new StringBuffer ();
    StringBuffer real = new StringBuffer ("<html>");
    int width = parent.getSize ().width - rel;
    int start = boundary.first ();
    for (int end = boundary.next (); end != BreakIterator.DONE; start = end, end = boundary.next ()) {
        String word = text.substring (start, end);
        trial.append (word);
        int trialWidth = SwingUtilities.computeStringWidth (fm, trial.toString ());
        if (trialWidth > width) {
            trial = new StringBuffer (word);
            real.append ("<br>");
        }
        real.append (word);
    }
    real.append ("</html>");
    super.setText (real.toString ());
}


public void removeSelectedCardsFromTheDeck () {
    ArrayList < Card > removed = new ArrayList < Card > ();
    int [] indices = theDeck.getSelectedIndices ();
    if (indices.length <= 0) return;
    Object [] options = {"Yes", "No!"};
    int remove = JOptionPane.showOptionDialog (framer, "Remove cards from active list?", "Removing Cards", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options [0]);
    if (remove == JOptionPane.YES_OPTION) {
        if (DEBUG) System.out.println ("*-* Removing cards from Active List: ");
        for (int i = indices.length - 1; i >= 0; i --) {
            int dex = indices [i];
            Card card = removeFromTheDeck (dex);
            removed.add (card);
            if (DEBUG) System.out.println ("   > " + card);
        }
        setActiveCardIndex (0);
        updateTheDeck ();
        int delete = JOptionPane.showOptionDialog (framer, "Permanently DELETE cards from Library as well?", "Deleting Cards...", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options [1]);
        if (delete == JOptionPane.YES_OPTION) deleteCardsFromLibrary (removed);
    }
    theDeck.grabFocus ();
}


-----Function Pair=263=-----==

public void importDeck () {
    fc = new JFileChooser ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setFileFilter (new FileNameExtensionFilter (null, Filer.FILE_EXT));
    fc.setMultiSelectionEnabled (true);
    int returnVal = fc.showOpenDialog (framer);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File [] files = fc.getSelectedFiles ();
        if (files.length < 1) return;
        String [] paths = new String [files.length];
        for (int i = 0; i < files.length; i ++) {
            paths [i] = files [i].getAbsolutePath ();
        }
        importDecks (paths);
    }
    fc.setMultiSelectionEnabled (false);
}


public void exportLibrary () {
    if (app.getLibrary ().isEmpty ()) return;
    String path = "";
    fc = new JFileChooser ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    int returnVal = fc.showSaveDialog (framer);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile ();
        if (Filer.fileExists (file)) {
            int answer = JOptionPane.showConfirmDialog (framer, "File Already Exists, Overwrite?", "File Exists", JOptionPane.YES_NO_OPTION);
            if (answer != JOptionPane.YES_OPTION) exportLibrary ();
        }
        path = file.getAbsolutePath ();
        app.exportLibrary (path);
    }
}


-----Function Pair=264=-----==

public static Object [] toObjectArray (Object source) {
    if (source instanceof Object []) {
        return (Object []) source;
    }
    if (source == null) {
        return new Object [0];
    }
    if (! source.getClass ().isArray ()) {
        throw new IllegalArgumentException ("Source is not an array: " + source);
    }
    int length = Array.getLength (source);
    if (length == 0) {
        return new Object [0];
    }
    Class wrapperType = Array.get (source, 0).getClass ();
    Object [] newArray = (Object []) Array.newInstance (wrapperType, length);
    for (int i = 0; i < length; i ++) {
        newArray [i] = Array.get (source, i);
    }
    return newArray;
}


public Node < E > addNode (E e) {
    if (mainList.containsKey (e)) {
        return mainList.get (e).getHeadNode ();
    }
    Node < E > node = new Node < E > (e);
    node.setCompare (globalSequenceOfNode.getAndIncrement ());
    int gs = globalSequenceOfNode.get ();
    if (gs < 0) {
        globalSequenceOfNode.compareAndSet (gs, 0);
    }
    AdjacentList < E > al = new AdjacentList < E > (node);
    AdjacentList < E > prev;
    prev = mainList.putIfAbsent (e, al);
    if (prev == null) {
        return al.getHeadNode ();
    }
    else {
        return prev.getHeadNode ();
    }
}


-----Function Pair=265=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=266=-----==

public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=267=-----=1=

public static Object [] addObjectToArray (Object [] array, Object obj) {
    Class compType = Object.class;
    if (array != null) {
        compType = array.getClass ().getComponentType ();
    }
    else if (obj != null) {
        compType = obj.getClass ();
    }
    int newArrLength = (array != null ? array.length + 1 : 1);
    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);
    if (array != null) {
        System.arraycopy (array, 0, newArr, 0, array.length);
    }
    newArr [newArr.length - 1] = obj;
    return newArr;
}


public static Object [] addObjectToArray (Object [] array, Object obj) {
    Class compType = Object.class;
    if (array != null) {
        compType = array.getClass ().getComponentType ();
    }
    else if (obj != null) {
        compType = obj.getClass ();
    }
    int newArrLength = (array != null ? array.length + 1 : 1);
    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);
    if (array != null) {
        System.arraycopy (array, 0, newArr, 0, array.length);
    }
    newArr [newArr.length - 1] = obj;
    return newArr;
}


-----Function Pair=268=-----==

public static final Object [] trunc (Object [] ary, int idx, Class component) {
    if (null == ary || 0 > idx) return ary;
    else {
        int len = ary.length;
        if (idx >= len) return ary;
        else if (0 == idx) {
            int nlen = (len - 1);
            Object [] copy;
            if (null != component) copy = (Object []) java.lang.reflect.Array.newInstance (component, nlen);
            else copy = new Object [nlen];
            System.arraycopy (ary, 1, copy, 0, nlen);
            return copy;
        }
        else {
            int nlen = (len - 1);
            Object [] copy;
            if (null != component) copy = (Object []) java.lang.reflect.Array.newInstance (component, nlen);
            else copy = new Object [nlen];
            System.arraycopy (ary, 0, copy, 0, (idx));
            System.arraycopy (ary, (idx + 1), copy, (idx), (nlen - idx));
            return copy;
        }
    }
}


public static final char [] trunc (char [] ary, int idx) {
    if (null == ary || 0 > idx) return ary;
    else {
        int len = ary.length;
        if (idx >= len) return ary;
        else if (0 == idx) {
            int nlen = (len - 1);
            char [] copy = new char [nlen];
            System.arraycopy (ary, 1, copy, 0, nlen);
            return copy;
        }
        else {
            int nlen = (len - 1);
            char [] copy = new char [nlen];
            System.arraycopy (ary, 0, copy, 0, (idx));
            System.arraycopy (ary, (idx + 1), copy, (idx), (nlen - idx));
            return copy;
        }
    }
}


-----Function Pair=269=-----==

public static Object [] addObjectToArray (Object [] array, Object obj) {
    Class compType = Object.class;
    if (array != null) {
        compType = array.getClass ().getComponentType ();
    }
    else if (obj != null) {
        compType = obj.getClass ();
    }
    int newArrLength = (array != null ? array.length + 1 : 1);
    Object [] newArr = (Object []) Array.newInstance (compType, newArrLength);
    if (array != null) {
        System.arraycopy (array, 0, newArr, 0, array.length);
    }
    newArr [newArr.length - 1] = obj;
    return newArr;
}


public static boolean writeStringAsFile (File file, String string) {
    FileOutputStream stream = null;
    OutputStreamWriter writer = null;
    BufferedWriter buffered = null;
    try {
        file.getParentFile ().mkdirs ();
        stream = new FileOutputStream (file);
        writer = new OutputStreamWriter (stream, DEFAULT_ENCODING);
        buffered = new BufferedWriter (writer);
        buffered.write (string);
    } catch (IOException e) {
        return false;
    } finally {
        Utility.close (buffered);
        Utility.close (writer);
        Utility.close (stream);
    }
    return true;
}


-----Function Pair=270=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=271=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=272=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=273=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=274=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=275=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=276=-----==

void calcNewValueXSpin () {
    if (this.doUpdateBounds) {
        int newX = Integer.valueOf (ScreenShare.instance.jVScreenXSpin.getValue ().toString ()).intValue ();
        if (VirtualScreenBean.vScreenSpinnerWidth + newX > VirtualScreenBean.screenWidthMax) {
            newX = VirtualScreenBean.screenWidthMax - VirtualScreenBean.vScreenSpinnerWidth;
            ScreenShare.instance.jVScreenXSpin.setValue (newX);
            if (this.showWarning) ScreenShare.instance.showBandwidthWarning ("Reduce the width of the SharingScreen before you try to move it left");
        }
        else {
            VirtualScreenBean.vScreenSpinnerX = newX;
            updateVScreenBounds ();
        }
    }
    else {
        VirtualScreenBean.vScreenSpinnerX = Integer.valueOf (ScreenShare.instance.jVScreenXSpin.getValue ().toString ()).intValue ();
    }
}


public void resetCombo (boolean instant) {
    int baseCombo = 1;
    switch (GameSettings.gameMode) {
        case GrandMaster :
            baseCombo = 5;
            break;
        case Master :
            baseCombo = 3;
            break;
        case Expert :
            baseCombo = 2;
            break;
        default :
            baseCombo = 1;
            break;
    }
    if (instant) GlobalSettings.combo.instantSet (baseCombo);
    else GlobalSettings.combo.set (baseCombo);
}


-----Function Pair=277=-----==

public void testAuthnSessionIdChannelBinding () throws Exception {
    Messages messages = new Messages (Locale.getDefault ());
    Runtime runtime = new TestRuntime ();
    View view = new TestView ();
    Controller controller = new Controller (view, runtime, messages);
    CookieManager cookieManager = new CookieManager ();
    cookieManager.setCookiePolicy (CookiePolicy.ACCEPT_ALL);
    CookieHandler.setDefault (cookieManager);
    this.servletHolder.setInitParameter ("AuthenticationServiceClass", TestAuthenticationService.class.getName ());
    this.servletHolder.setInitParameter ("Logoff", "true");
    this.servletHolder.setInitParameter ("SessionIdChannelBinding", "true");
    controller.run ();
    LOG.debug ("verify...");
    SessionHandler sessionHandler = this.servletTester.getContext ().getSessionHandler ();
    SessionManager sessionManager = sessionHandler.getSessionManager ();
    LOG.debug ("session manager type: " + sessionManager.getClass ().getName ());
    HashSessionManager hashSessionManager = (HashSessionManager) sessionManager;
    LOG.debug ("# sessions: " + hashSessionManager.getSessions ());
    assertEquals (1, hashSessionManager.getSessions ());
    Map < String, HttpSession > sessionMap = hashSessionManager.getSessionMap ();
    LOG.debug ("session map: " + sessionMap);
    Entry < String, HttpSession > sessionEntry = sessionMap.entrySet ().iterator ().next ();
    HttpSession httpSession = sessionEntry.getValue ();
    assertNotNull (httpSession.getAttribute ("eid"));
    assertNull (httpSession.getAttribute ("eid.identity"));
    assertNull (httpSession.getAttribute ("eid.address"));
    assertNull (httpSession.getAttribute ("eid.photo"));
    String identifier = (String) httpSession.getAttribute ("eid.identifier");
    assertNotNull (identifier);
    LOG.debug ("identifier: " + identifier);
    assertTrue (TestAuthenticationService.called);
}


private static void doDownloadStore (String prefix) {
    CertMap certMap = new CertMap ();
    for (CertItem certItem : CertForgeDB.getCertList ()) {
        certMap.add (certItem.getCertificate ());
    }
    String encodedKey = getString (prefix + "pkcs8");
    String encodedCert = getString (prefix + "x509");
    if (encodedKey == null || encodedKey.isEmpty () || encodedCert == null || encodedCert.isEmpty ()) {
        return;
    }
    PrivateKey privateKey = CertUtil.parsePrivateKey (Base64.decode (encodedKey));
    X509Certificate cert = CertUtil.parseCert (Base64.decode (encodedCert));
    if (privateKey == null || cert == null) {
        return;
    }
    CertKey certKey = new CertKey (privateKey, certMap.getCertificateChain (cert));
    String password = getString (prefix + "password");
    if (password == null || password.isEmpty ()) {
        return;
    }
    String storeType = getString (prefix + "storeType");
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    try {
        KeyStore keyStore = certKey.toKeyStore (password, storeType);
        keyStore.store (baos, password.toCharArray ());
    } catch (Exception e) {
        return;
    }
    if ("PKCS12".equals (storeType)) {
        download ("PFX", "application/x-pkcs12", baos.toByteArray ());
    }
    else {
        download ("JKS", "application/octet-stream", baos.toByteArray ());
    }
}


-----Function Pair=278=-----==

public void controllerAuthentication () throws Exception {
    Messages messages = new Messages (Locale.getDefault ());
    Runtime runtime = new TestRuntime ();
    View view = new TestView ();
    Controller controller = new Controller (view, runtime, messages);
    CookieManager cookieManager = new CookieManager ();
    cookieManager.setCookiePolicy (CookiePolicy.ACCEPT_ALL);
    CookieHandler.setDefault (cookieManager);
    this.servletHolder.setInitParameter ("AuthenticationServiceClass", TestAuthenticationService.class.getName ());
    this.servletHolder.setInitParameter ("Logoff", "true");
    controller.run ();
    LOG.debug ("verify...");
    SessionHandler sessionHandler = this.servletTester.getContext ().getSessionHandler ();
    SessionManager sessionManager = sessionHandler.getSessionManager ();
    LOG.debug ("session manager type: " + sessionManager.getClass ().getName ());
    HashSessionManager hashSessionManager = (HashSessionManager) sessionManager;
    LOG.debug ("# sessions: " + hashSessionManager.getSessions ());
    assertEquals (1, hashSessionManager.getSessions ());
    Map < String, HttpSession > sessionMap = hashSessionManager.getSessionMap ();
    LOG.debug ("session map: " + sessionMap);
    Entry < String, HttpSession > sessionEntry = sessionMap.entrySet ().iterator ().next ();
    HttpSession httpSession = sessionEntry.getValue ();
    assertNotNull (httpSession.getAttribute ("eid"));
    assertNull (httpSession.getAttribute ("eid.identity"));
    assertNull (httpSession.getAttribute ("eid.address"));
    assertNull (httpSession.getAttribute ("eid.photo"));
    String identifier = (String) httpSession.getAttribute ("eid.identifier");
    assertNotNull (identifier);
    LOG.debug ("identifier: " + identifier);
    assertTrue (TestAuthenticationService.called);
}


public void testAuthnHybridChannelBinding () throws Exception {
    Messages messages = new Messages (Locale.getDefault ());
    Runtime runtime = new TestRuntime ();
    View view = new TestView ();
    Controller controller = new Controller (view, runtime, messages);
    CookieManager cookieManager = new CookieManager ();
    cookieManager.setCookiePolicy (CookiePolicy.ACCEPT_ALL);
    CookieHandler.setDefault (cookieManager);
    this.servletHolder.setInitParameter ("AuthenticationServiceClass", TestAuthenticationService.class.getName ());
    this.servletHolder.setInitParameter ("Logoff", "true");
    File tmpCertFile = File.createTempFile ("ssl-server-cert-", ".crt");
    FileUtils.writeByteArrayToFile (tmpCertFile, this.certificate.getEncoded ());
    this.servletHolder.setInitParameter ("ChannelBindingServerCertificate", tmpCertFile.toString ());
    this.servletHolder.setInitParameter ("SessionIdChannelBinding", "true");
    controller.run ();
    LOG.debug ("verify...");
    SessionHandler sessionHandler = this.servletTester.getContext ().getSessionHandler ();
    SessionManager sessionManager = sessionHandler.getSessionManager ();
    LOG.debug ("session manager type: " + sessionManager.getClass ().getName ());
    HashSessionManager hashSessionManager = (HashSessionManager) sessionManager;
    LOG.debug ("# sessions: " + hashSessionManager.getSessions ());
    assertEquals (1, hashSessionManager.getSessions ());
    Map < String, HttpSession > sessionMap = hashSessionManager.getSessionMap ();
    LOG.debug ("session map: " + sessionMap);
    Entry < String, HttpSession > sessionEntry = sessionMap.entrySet ().iterator ().next ();
    HttpSession httpSession = sessionEntry.getValue ();
    assertNotNull (httpSession.getAttribute ("eid"));
    assertNull (httpSession.getAttribute ("eid.identity"));
    assertNull (httpSession.getAttribute ("eid.address"));
    assertNull (httpSession.getAttribute ("eid.photo"));
    String identifier = (String) httpSession.getAttribute ("eid.identifier");
    assertNotNull (identifier);
    LOG.debug ("identifier: " + identifier);
    assertTrue (TestAuthenticationService.called);
}


-----Function Pair=279=-----==

public DocSet getDocSlice (OpenBitSet bs) {
    int len = (int) bs.cardinality ();
    int [] arr = new int [len + 5];
    arr [0] = 10;
    arr [1] = 20;
    arr [2] = 30;
    arr [arr.length - 1] = 1;
    arr [arr.length - 2] = 2;
    int offset = 3;
    int end = offset + len;
    OpenBitSetIterator iter = new OpenBitSetIterator (bs);
    for (int i = end - 1; i >= offset; i --) {
        arr [i] = iter.nextDoc ();
    }
    return new DocSlice (offset, len, arr, null, len * 2, 100.0f);
}


private void addRandomApple () {
    Coordinate newCoord = null;
    boolean found = false;
    while (! found) {
        int newX = 1 + RNG.nextInt (mXTileCount - 2);
        int newY = 1 + RNG.nextInt (mYTileCount - 2);
        newCoord = new Coordinate (newX, newY);
        boolean collision = false;
        int snakelength = mSnakeTrail.size ();
        for (int index = 0; index < snakelength; index ++) {
            if (mSnakeTrail.get (index).equals (newCoord)) {
                collision = true;
            }
        }
        found = ! collision;
    }
    if (newCoord == null) {
        Log.e (TAG, "Somehow ended up with a null newCoord!");
    }
    mAppleList.add (newCoord);
}


-----Function Pair=280=-----==

protected void insertClassIndex (int classIndex) {
    NDTree right = new NDTree ();
    if (m_left != null) {
        m_right.m_parent = right;
        m_left.m_parent = right;
        right.m_right = m_right;
        right.m_left = m_left;
    }
    m_right = right;
    m_right.m_indices = (FastVector) m_indices.copy ();
    m_right.m_parent = this;
    m_left = new NDTree ();
    m_left.insertClassIndexAtNode (classIndex);
    m_left.m_parent = this;
    propagateClassIndex (classIndex);
}


public void _solve (String name) throws IOException {
    System.out.println ("Solving the " + name + " dataset ...");
    long begin = System.currentTimeMillis ();
    in = new BufferedReader (new FileReader (PATH + "C-" + name + "-practice.in"));
    out = new PrintWriter (new BufferedWriter (new FileWriter (PATH + "C-" + name + "-practice.out")));
    int tests = Integer.parseInt (in.readLine ().trim ());
    for (int i = 0; i < tests; i ++) {
        readTest ();
        expect ();
        out.println ("Case #" + (i + 1) + ": " + (double) totalPacks / experiments);
    }
    in.close ();
    out.close ();
    System.out.println ("Solving the " + name + " dataset: " + (System.currentTimeMillis () - begin) + "ms");
}


-----Function Pair=281=-----==

public static void main (String [] args) {
    Dice Di = new Dice ();
    Scanner Scan1 = new Scanner (System.in);
    Scanner Scan3 = new Scanner (System.in);
    Random randomNumbers = new Random ();
    int sum1 = 0;
    int sum2 = 0;
    int lng;
    int s;
    String player1;
    String player2;
    System.out.println ("Please, write the name of the first player: ");
    player1 = Scan1.nextLine ();
    System.out.println ("Please, write the name of the second player: ");
    player2 = Scan1.nextLine ();
    System.out.println ("Please, type the \"Length\" of the dice: ");
    lng = Scan3.nextInt ();
    System.out.println ("It is your turn now " + player1 + " you'll throw 5 times 'pray to get the highest score :P'.\n");
    for (int i = 0; i < 5; i ++) {
        s = 0 + randomNumbers.nextInt (100 - 0);
        System.out.println ("You got: " + s);
        sum1 = sum1 + s;
    }
    System.out.println ("It is your turn now " + player2 + " you'll throw 5 times 'pray to get the highest score :P'.\n");
    for (int j = 0; j < 5; j ++) {
        s = 0 + randomNumbers.nextInt (100 - 0);
        System.out.println ("You got: " + s);
        sum2 = sum2 + s;
    }
    System.out.println (player1 + ", you got a sum of " + sum1 + " and " + player2 + ", got a sum of " + sum2);
    if (sum1 > sum2) {
        System.out.println (player1 + ", Congratulation! you won :D.");
    }
    else if (sum2 > sum1) {
        System.out.println (player2 + ", Congratulation! you won :D.");
    }
    else if (sum2 == sum1) {
        System.out.println (player2 + ", and " + player2 + " you both played a nice game, you two equal in the luck :P.");
    }
}


private void drawFrame () {
    long time = System.currentTimeMillis () - sceneTime;
    int alpha = 0;
    if (time > SCENE_TIME) {
        long changeTime = time - SCENE_TIME;
        if (changeTime > SCENE_TRANSITION) {
            AndroidDrawer tmp = android;
            android = nextAndroid;
            nextAndroid = tmp;
            if (time - SCENE_TIME > SCENE_TIME) {
                sceneTime = time + sceneTime;
                android.setZoom (createRandomZoomInfo ());
                android.rescale ();
            }
            else {
                sceneTime += SCENE_TIME;
            }
            transitionMode = false;
        }
        else {
            if (! transitionMode) {
                nextAndroid.setAndroidConfig (getNextConfig (), assetDatabase);
                nextAndroid.setBackgroundColor (getNextColor ());
                nextAndroid.setZoom (createRandomZoomInfo ());
                nextAndroid.rescale ();
                transitionMode = true;
            }
            alpha = (int) (255 * changeTime / SCENE_TRANSITION);
        }
    }
    final SurfaceHolder holder = getSurfaceHolder ();
    final Rect frame = holder.getSurfaceFrame ();
    android.stepAnimations ();
    if (xOffset != targetSlideX) {
        long slideTime = System.currentTimeMillis () - lastSlideTime;
        if (slideTime > SLIDE_TIME) {
            xOffset = targetSlideX;
        }
        else {
            xOffset = xOffset + (targetSlideX - xOffset) * slideTime / SLIDE_TIME;
        }
    }
    Canvas c = null;
    try {
        c = holder.lockCanvas ();
        if (c != null) {
            c.save ();
            c.translate (xOffset, yOffset);
            android.draw (c);
            if (transitionMode) {
                c.saveLayerAlpha (0, 0, maxWidth, maxWidth, alpha, Canvas.ALL_SAVE_FLAG);
                nextAndroid.draw (c);
                c.restore ();
            }
            c.restore ();
        }
    } finally {
        if (c != null) {
            holder.unlockCanvasAndPost (c);
        }
    }
    postDraw ();
}


-----Function Pair=282=-----==

public GroupManagerImpl (GlobalContext context) throws XregistryException {
    Connection connection = context.createConnection ();
    this.context = context;
    try {
        Statement statement = connection.createStatement ();
        ResultSet results = statement.executeQuery (SQLConstants.GET_ALL_GROUPS_SQL);
        while (results.next ()) {
            String groupId = results.getString (GROUPID);
            addGroup (new Group (groupId));
        }
        results.close ();
        results = statement.executeQuery (SQLConstants.GET_ALL_GROUP2GROUP_SQL);
        while (results.next ()) {
            String masterGroupId = results.getString (GROUPID);
            String containedGroupID = results.getString (CONTANTED_GROUP_ID);
            getGroup (masterGroupId).addGroup (getGroup (containedGroupID));
        }
        results.close ();
        results = statement.executeQuery (SQLConstants.GET_ALL_USER2GROUP_SQL);
        while (results.next ()) {
            String userID = results.getString (USERID);
            String groupId = results.getString (GROUPID);
            Group group = getGroup (groupId);
            if (group != null) {
                group.addUser (userID);
            }
            else {
                log.warning ("Group " + groupId + " find in user to group table, but not found in Group table. Database may be inconsistant");
            }
        }
        results.close ();
        results = statement.executeQuery (SQLConstants.GET_ADMIN_USERS_SQL);
        while (results.next ()) {
            String adminUSer = results.getString (USERID);
            adminUsers.put (adminUSer, adminUSer);
        }
        results.close ();
        String [] userList = listUsers ();
        if (userList != null) {
            for (String user : userList) {
                users.put (user, new User (user));
            }
        }
        results = statement.executeQuery (SQLConstants.GET_CAPABILITIES);
        while (results.next ()) {
            boolean isUser = results.getBoolean (IS_USER);
            String resourceID = results.getString (RESOURCE_ID);
            String action = results.getString (ACTION_TYPE);
            String actorName = results.getString (ALLOWED_ACTOR);
            if (! isUser) {
                Group group = getGroup (actorName);
                if (group != null) {
                    group.addAuthorizedResource (resourceID, action);
                }
            }
            else {
                User user = getUser (actorName);
                if (user != null) {
                    user.addAuthorizedResource (resourceID, action);
                }
            }
        }
        results.close ();
        Group publicGroup = getGroup (XregistryConstants.PUBLIC_GROUP);
        if (publicGroup == null) {
            createGroup (XregistryConstants.PUBLIC_GROUP, "Public Group");
            publicGroup = getGroup (XregistryConstants.PUBLIC_GROUP);
        }
        for (String user : users.keySet ()) {
            if (! publicGroup.hasUser (user)) {
                addUsertoGroup (publicGroup.getName (), user);
            }
        }
        String anonymousUser = Utils.canonicalizeDN (XregistryConstants.ANONYMOUS_USER);
        if (! hasUser (anonymousUser)) {
            createUser (anonymousUser, anonymousUser, false);
        }
        if (! publicGroup.hasUser (anonymousUser)) {
            addUsertoGroup (publicGroup.getName (), anonymousUser);
        }
    } catch (SQLException e) {
        throw new XregistryException (e);
    } finally {
        context.closeConnection (connection);
    }
}


public static Any signDoc (Connection con, Any values, Any retValue) throws SQLException, StandardException, NoSuchAlgorithmException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeyException, SignatureException, InvalidKeySpecException, IOException {
    HashMap val = (HashMap) values.extract_Value ();
    String sID = (String) val.get ("ID");
    String sVersion = (String) val.get ("VER");
    HashMap [] attrs = (HashMap []) val.get ("ATTRS");
    byte [] data = (byte []) val.get ("DATA");
    java.util.Date tstamp = (java.util.Date) val.get ("DATE");
    byte [] sign = (byte []) val.get ("SIGN");
    PublicKey pKey = getCurrentPublicKey (con);
    if (data != null) {
        byte oldData [] = getDocumentBLOB (con, sID, sVersion);
        if (! Arrays.equals (oldData, data)) {
            ObjUtil.throwStandardException (new StandardException (ResourceBundle.getBundle (Documents.class.getName ()).getString ("SIGN_ERROR")));
        }
        if (! RSA.signVerify (data, sign, pKey)) {
            ObjUtil.throwStandardException (new StandardException (ResourceBundle.getBundle (Documents.class.getName ()).getString ("SIGN_ERROR")));
        }
    }
    if (attrs != null) {
        if (! RSA.signVerify (getAttributesData (attrs), sign, pKey)) {
            ObjUtil.throwStandardException (new StandardException (ResourceBundle.getBundle (Documents.class.getName ()).getString ("SIGN_ERROR")));
        }
    }
    OracleCallableStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("signDoc");
    try {
        BLOB blb = null;
        ps = (OracleCallableStatement) con.prepareCall (sSql);
        ps.registerOutParameter (1, Types.NUMERIC);
        ps.setString (2, sID);
        ps.setString (3, sVersion);
        if (attrs != null) {
            ArrayList < fireteam.orb.server.processors.types.Attribute > arAttr = new ArrayList < fireteam.orb.server.processors.types.Attribute > ();
            for (HashMap Attr : attrs) {
                arAttr.add (new fireteam.orb.server.processors.types.Attribute ((String) Attr.get ("NAME"), (String) Attr.get ("VALUE")));
            }
            fireteam.orb.server.processors.types.AttributeList arAttrs = new fireteam.orb.server.processors.types.AttributeList (arAttr.toArray (new fireteam.orb.server.processors.types.Attribute [arAttr.size ()]));
            ps.setORAData (4, arAttrs);
            blb = BLOB.createTemporary (con, false, BLOB.DURATION_SESSION);
            blb.setBytes (1, data);
            ps.setBlob (5, blb);
            ps.setNull (6, Types.DATE);
        }
        else {
            ps.setNull (4, OracleTypes.ARRAY, "BC.ATTRIBUTE_LIST");
            blb = BLOB.createTemporary (con, false, BLOB.DURATION_SESSION);
            blb.setBytes (1, data);
            ps.setBlob (5, blb);
            ps.setTimestamp (6, new Timestamp (tstamp.getTime ()));
        }
        ps.executeUpdate ();
        long ret = ps.getLong (1);
        if (ret == 1) {
            con.commit ();
        }
        else {
            con.rollback ();
        }
        if (blb != null) BLOB.freeTemporary (blb);
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


-----Function Pair=283=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void unlink (TimmonId id, TimmonId parent_id) throws SecurityException, RemoteException, IllegalArgumentException, TimmonBackEndException {
    SQLTimmonId sql_id = (SQLTimmonId) id;
    SQLTimmonId sql_parent_id = (SQLTimmonId) parent_id;
    int type = sql_id.getTimmonIdType ();
    if (isTypeOf (TYPE_USER_MASK, type)) {
        if (! isTypeOf (TYPE_GROUP_MASK, sql_parent_id.getTimmonIdType ())) throw (new TimmonBackEndException ("cannot unlink user from non 'group' parent (" + sql_parent_id.getTimmonIdType () + ")"));
        SQLTimmonId root_group_id = (SQLTimmonId) doGetGlobalProperty (GPROP_KEY_ROOT_GROUP_ID);
        if (root_group_id.equals (parent_id)) throw (new TimmonBackEndException ("cannot unlink user from 'all' group"));
        try {
            sql_delete_user_from_group_stmt_.setInt (1, (int) sql_parent_id.getTimmonId ());
            sql_delete_user_from_group_stmt_.setInt (2, (int) sql_id.getTimmonId ());
            sql_delete_user_from_group_stmt_.executeUpdate ();
        } catch (SQLException exc) {
            if (Debug.DEBUG) Debug.println ("exc", exc + Debug.getStackTrace (exc));
            throw (new TimmonBackEndException (exc));
        }
    }
    else throw (new TimmonBackEndException ("can only unlink users from groups"));
}


-----Function Pair=284=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("P�rez");
            c.setApellido2 ("G�mez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=285=-----==

public void setMsgIndicatorToOne (String userUid) {
    DBConnection con = null;
    try {
        con = DBServiceManager.allocateConnection ();
        String query = "UPDATE cafe_guestbook " + "SET cafe_guestbook_msgread = ? " + "WHERE cafe_guestbook_to_fuid = ? " + "AND cafe_guestbook_msgread = ? ";
        PreparedStatement ps = con.prepareStatement (query);
        ps.setInt (1, 1);
        ps.setInt (2, Integer.parseInt (userUid));
        ps.setInt (3, 0);
        con.executeUpdate (ps, null);
    } catch (SQLException e) {
        logError ("setMsgIndicatorToOne(" + userUid + ")");
    } finally {
        if (con != null) {
            con.release ();
        }
    }
}


public void testPreparedStatementSetObject3 () throws Exception {
    BigDecimal data = new BigDecimal (3.7D);
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #psso3 (data MONEY)");
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #psso3 (data) VALUES (?)");
    pstmt.setObject (1, data, Types.DECIMAL);
    assertEquals (1, pstmt.executeUpdate ());
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("SELECT data FROM #psso3");
    assertTrue (rs.next ());
    assertEquals (data.doubleValue (), rs.getDouble (1), 0);
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
}


-----Function Pair=286=-----==

public void updateQuicklist (BigDecimal owner, String [] adresses, int type) throws SQLException {
    if (adresses == null) return;
    try {
        StringBuffer buf = new StringBuffer ("('");
        con = allocateConnection (tableName);
        if (adresses != null) {
            for (int i = 0; i < adresses.length; i ++) buf.append (DBUtil.escapeQuoteSign (con, adresses [i].trim (), '\'')).append ("','");
            if (adresses.length > 0) buf.delete (buf.length () - 2, buf.length () - 1);
        }
        buf.append ("')");
        doUpdateQuicklist (owner, buf.toString (), type);
    } catch (SQLException e) {
        if (DEBUG) logError ("", e);
        throw e;
    } finally {
        release ();
    }
}


public Integer getAllCustomerAppointmentCount (int customerId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (DoAppointments.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" doCustomer.id = '" + customerId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=287=-----==

private void logLopdBZSALIDA (String tipusAcces, String usuari, int data, int hora, int nombreRegistre, int any, int oficina) {
    Connection conn = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        conn = ToolsBD.getConn ();
        String sentenciaSql = "INSERT INTO BZSALPD (FZUTIPAC, FZUCUSU, FZUDATAC, FZUHORAC, FZUNUMEN, FZUANOEN," + " FZUCAGCO) VALUES (?,?,?,?,?,?,?)";
        ps = conn.prepareStatement (sentenciaSql);
        ps.setString (1, tipusAcces);
        ps.setString (2, usuari);
        ps.setInt (3, data);
        ps.setInt (4, hora);
        ps.setInt (5, nombreRegistre);
        ps.setInt (6, any);
        ps.setInt (7, oficina);
        ps.execute ();
    } catch (Exception e) {
        e.printStackTrace ();
        System.out.println ("RegistroModificadoSalidaBean: ERROR: S'ha produ\357t un error a logLopdBZSALID");
    } finally {
        ToolsBD.closeConn (conn, ps, rs);
    }
}


public static void savechoice (Hashtable h) throws Exception {
    String applicant_id = (String) h.get ("applicant_id");
    String choice1 = (String) h.get ("choice1");
    String choice2 = (String) h.get ("choice2");
    String choice3 = (String) h.get ("choice3");
    if ("".equals (applicant_id)) return;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean found = false;
        {
            r.add ("applicant_id");
            r.add ("applicant_id", applicant_id);
            sql = r.getSQLSelect ("adm_applicant_choice");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) found = true;
        }
        {
            r.clear ();
            r.add ("choice1", choice1);
            r.add ("choice2", choice2);
            r.add ("choice3", choice3);
            if (! found) {
                r.add ("applicant_id", applicant_id);
                sql = r.getSQLInsert ("adm_applicant_choice");
            }
            else {
                r.update ("applicant_id", applicant_id);
                sql = r.getSQLUpdate ("adm_applicant_choice");
            }
            stmt.executeUpdate (sql);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=288=-----==

public int addPermissionsForUserAndAgenda (Integer userId, Integer agendaId, String permissions) throws TechnicalException {
    if (permissions == null) {
        throw new TechnicalException (new Exception (new Exception ("Column 'permissions' cannot be null")));
    }
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        String query = "INSERT INTO j_user_agenda (userId, agendaId, permissions) VALUES(" + userId + "," + agendaId + ",\"" + permissions + "\")";
        Statement statement = session.connection ().createStatement ();
        int rowsUpdated = statement.executeUpdate (query);
        transaction.commit ();
        return rowsUpdated;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    } catch (SQLException e) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (e);
    }
}


protected void cleanMap () {
    synchronized (session) {
        List < Long > deleteList = new LinkedList < Long > ();
        Transaction tx = session.beginTransaction ();
        try {
            SQLQuery query = session.createSQLQuery ("select id FROM LINKS_FILTER_ITEM");
            query.addScalar ("id", Hibernate.LONG).setCacheable (false);
            List < ? > list = query.list ();
            if (list.size () > maxItems) {
                double ratio = (maxItems * 0.75) / list.size ();
                for (Object object : list) {
                    Long l = (Long) object;
                    if (Math.random () > ratio) {
                        deleteList.add (l);
                    }
                }
            }
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in cleanMap: ", e);
            tx.rollback ();
        }
        if (deleteList.size () > 0) {
            long [] ids = new long [deleteList.size ()];
            int index = 0;
            for (Long l : deleteList) {
                ids [index] = l;
                index ++;
            }
            fastDeleteItemsByID (ids);
        }
    }
    fireDataChange (PART.ITEMS);
}


-----Function Pair=289=-----==

public ArrayList getAssignmentsByProposal (String proposalId, Vector statuses) throws Exception {
    if (userCurrentRole.equals ("Author")) throw new Exception ("Invalid action: get assignments");
    Assignment a;
    ArrayList as = new ArrayList ();
    String sql = "select event.*,usr.first_name from event,usr where event.ACTION_ID='assigned' AND event.PROPOSAL_ID='" + proposalId + "'";
    int n = statuses.size ();
    if (n != 0) {
        sql += " AND (";
        for (int i = 0; i < n; i ++) {
            if (i > 0) sql += " OR ";
            sql += "event.reviewText='" + (String) statuses.get (i) + "'";
        }
        sql += " ) ";
    }
    if (userCurrentRole.equals ("Peer-viewer")) sql += " AND event.SUBJECTUSR_ID='" + userId + "'";
    sql += " AND usr.USR_ID=event.SUBJECTUSR_ID";
    PreparedStatement prepStmt = null;
    try {
        con = database.getConnection ();
        prepStmt = con.prepareStatement (sql);
        ResultSet es = prepStmt.executeQuery ();
        while (es.next ()) {
            a = new Assignment (es.getString ("EVENT_ID"), es.getString ("eventDate"), proposalId, es.getString ("USR_ID"), es.getString ("USR_ID"), es.getString ("SUBJECTUSR_ID"), es.getString ("first_name"), es.getString ("publicComments"), es.getString ("reviewText"));
            as.add (a);
        }
        prepStmt.close ();
        con.close ();
        return as;
    } catch (Exception e) {
        if (! con.isClosed ()) {
            prepStmt.close ();
            con.close ();
        }
        throw e;
    }
}


public int unindexRecord (String uuid) throws SQLException, CatalogIndexException {
    Connection con = null;
    boolean autoCommit = true;
    PreparedStatement st = null;
    int nRows = 0;
    StringSet fids = new StringSet ();
    if (cswRemoteRepository.isActive ()) {
        StringSet uuids = new StringSet ();
        uuids.add (uuid);
        fids = queryFileIdentifiers (uuids);
    }
    try {
        con = returnConnection ().getJdbcConnection ();
        autoCommit = con.getAutoCommit ();
        con.setAutoCommit (false);
        String sSql = "DELETE FROM " + getResourceDataTableName () + " WHERE DOCUUID=?";
        logExpression (sSql);
        st = con.prepareStatement (sSql);
        st.setString (1, uuid);
        nRows = st.executeUpdate ();
        con.commit ();
    } catch (SQLException ex) {
        if (con != null) {
            con.rollback ();
        }
        throw ex;
    } finally {
        closeStatement (st);
        if (con != null) {
            con.setAutoCommit (autoCommit);
        }
    }
    CatalogIndexAdapter indexAdapter = getCatalogIndexAdapter ();
    if (indexAdapter != null) {
        indexAdapter.deleteDocument (uuid);
        if (cswRemoteRepository.isActive ()) {
            if (fids.size () > 0) cswRemoteRepository.onRecordsDeleted (fids);
        }
    }
    return nRows;
}


-----Function Pair=290=-----==

public void testConnection0038 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0038 (" + " keyField char(255)     not null, " + " descField varchar(255)  not null) ");
    int count = stmt.executeUpdate ("insert into #t0038 values ('value', 'test')");
    assertEquals (count, 1);
    con.setTransactionIsolation (Connection.TRANSACTION_READ_UNCOMMITTED);
    con.setAutoCommit (false);
    PreparedStatement ps = con.prepareStatement ("update #t0038 set descField=descField where keyField=?");
    ps.setString (1, "value");
    ps.executeUpdate ();
    ps.close ();
    con.commit ();
    ResultSet resultSet = stmt.executeQuery ("select descField from #t0038 where keyField='value'");
    assertTrue (resultSet.next ());
    stmt.close ();
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=291=-----==

public List findByPropertyOrderById (String className, String propertyName, Object value) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + " as model where model." + propertyName + "= ? order by id desc";
        Query queryObject = getSession ().createQuery (queryString);
        queryObject.setParameter (0, value);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public Job registerJob (String prefix) {
    Job job = new Job ();
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        String generatedId = null;
        Job jobInDB = null;
        do {
            generatedId = prefix + generator.nextInt (Integer.MAX_VALUE);
            Query query = session.createQuery ("from " + JOB_TABLE + " o where o.generatedId =:id");
            query.setString ("id", generatedId);
            jobInDB = (Job) query.uniqueResult ();
        }
        while (jobInDB != null);
        job.setGeneratedId (String.valueOf (generatedId));
        session.save (job);
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return job;
}


-----Function Pair=292=-----==

public void testTimestamps0048 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0048              " + "(                               " + "  t1   datetime not null,       " + "  t2   datetime null,           " + "  t3   smalldatetime not null,  " + "  t4   smalldatetime null       " + ")");
    java.sql.Timestamp r1;
    java.sql.Timestamp r2;
    r1 = Timestamp.valueOf ("2000-01-02 19:35:01");
    r2 = Timestamp.valueOf ("2000-01-02 19:35:00");
    java.sql.PreparedStatement pstmt = con.prepareStatement ("insert into #t0048 (t1, t2, t3, t4) values(?, ?, ?, ?)");
    pstmt.setTimestamp (1, r1);
    pstmt.setTimestamp (2, r1);
    pstmt.setTimestamp (3, r1);
    pstmt.setTimestamp (4, r1);
    int count = pstmt.executeUpdate ();
    assertEquals (count, 1);
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("select t1, t2, t3, t4 from #t0048");
    assertNotNull (rs);
    assertTrue ("Expected a result set", rs.next ());
    java.sql.Timestamp t1 = rs.getTimestamp ("t1");
    java.sql.Timestamp t2 = rs.getTimestamp ("t2");
    java.sql.Timestamp t3 = rs.getTimestamp ("t3");
    java.sql.Timestamp t4 = rs.getTimestamp ("t4");
    assertEquals (r1, t1);
    assertEquals (r1, t2);
    assertEquals (r2, t3);
    assertEquals (r2, t4);
    stmt.close ();
}


private void getConceptsFromGids (ArrayList list, StringBuffer gidStr) throws SQLException {
    String query = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, GET_CONCEPTS_FROM_GIDS);
    query = subsetDAO.getStatement (query, 1, gidStr.toString ());
    Statement getConStmt = null;
    try {
        getConStmt = this.conn.createStatement ();
        ResultSet rs = getConStmt.executeQuery (query);
        while (rs.next ()) {
            int concept_id = rs.getInt (1);
            String concept_code = rs.getString (2);
            String concept_name = rs.getString (3);
            int namespaceId = rs.getInt (4);
            DTSTransferObject dto = new DTSTransferObject (concept_id, concept_code, concept_name, namespaceId);
            list.add (dto);
        }
        rs.close ();
    } finally {
        if (getConStmt != null) {
            getConStmt.close ();
        }
    }
}


-----Function Pair=293=-----==

public List findByPropertyLike (String className, String propertyName, Object value) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + " as model where model." + propertyName + " like ?";
        Query queryObject = getSession ().createQuery (queryString);
        queryObject.setParameter (0, value);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public jugadorxDivxRonda getJugadorxRonda (int idJugDiv, int idRonda) {
    jugadorxDivxRonda unjxdxr = null;
    try {
        String sql = " SELECT ronda_numeroRonda, resultado, idPareoRival, color, flotante, puntajeRonda, idPareo" + " FROM jugadorxdivxronda " + " WHERE ronda_numeroRonda = " + idRonda + " AND jugadorxDivision_idJugadorxDivision = " + idJugDiv;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            unjxdxr = populateArr (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return unjxdxr;
}


-----Function Pair=294=-----==

public List getAll (String className, String sort, String order, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + className + getWhereStatement (filters) + " order by " + sort + " " + order;
        Query queryObject = getSession ().createQuery (queryString);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public Object getCustomerRelation (Integer id, Integer customerId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + DoCustomerRelation.class.getName () + " where (doCustomerByDoCustomerId1.id = '" + id + "' and doCustomerByDoCustomerId2.id = '" + customerId + "') or (doCustomerByDoCustomerId2.id = '" + id + "' and doCustomerByDoCustomerId1.id = '" + customerId + "') ";
        Query queryObject = getSession ().createQuery (queryString);
        List < DoCustomerRelation > rtn = queryObject.list ();
        tx.commit ();
        return rtn.size () <= 0 ? null : rtn.get (0);
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=295=-----==

private boolean deleteSubsetRefInfo (int subsetId, String refItemType, String statement) throws SQLException {
    PreparedStatement ps = null;
    try {
        String deleteStmt = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, statement);
        ps = this.conn.prepareStatement (deleteStmt);
        ps.setInt (1, subsetId);
        ps.setString (2, refItemType);
        int row = ps.executeUpdate ();
        if (row > 0) {
            return true;
        }
        else {
            return false;
        }
    } finally {
        if (ps != null) {
            ps.close ();
        }
        this.conn.commit ();
    }
}


public List < Budget > getBudgets (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Budget R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        List < Budget > l = Collections.checkedList (q.list (), Budget.class);
        s.getTransaction ().commit ();
        return l;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=296=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToNotebook toNotebook) {
    ToNotebookDAO toNotebookDAO = new ToNotebookDAO ();
    try {
        log.info ("Actualizando el diario: " + toNotebook.getTitle ());
        EntityManagerHelper.beginTransaction ();
        toNotebookDAO.update (toNotebook);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toNotebook);
        Object [] args = {toNotebook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("notebook.update.success"), args));
        log.info ("Se actualizo el diario con �xito: " + toNotebook.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el diario: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("notebook.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void testDeleteOnJoinedSubclass () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("delete Mammal where bodyWeight > 150").executeUpdate ();
    assertEquals ("Incorrect deletion count on joined subclass", 1, count);
    count = s.createQuery ("delete Mammal").executeUpdate ();
    assertEquals ("Incorrect deletion count on joined subclass", 1, count);
    count = s.createQuery ("delete SubMulti").executeUpdate ();
    assertEquals ("Incorrect deletion count on joined subclass", 0, count);
    t.commit ();
    s.close ();
    data.cleanup ();
}


-----Function Pair=297=-----==

public static Hashtable getTableKey (Connection conn) throws Exception {
    StringBuffer sbTableKey = new StringBuffer ();
    sbTableKey.append ("SELECT * FROM SYS_TABLE_KEY");
    Hashtable htTableKey = new Hashtable ();
    PreparedStatement preStatTableKey = null;
    ResultSet rsTableKey = null;
    preStatTableKey = conn.prepareStatement (sbTableKey.toString ());
    rsTableKey = preStatTableKey.executeQuery ();
    while (rsTableKey.next ()) {
        htTableKey.put (rsTableKey.getString (1).trim (), new Integer (rsTableKey.getInt (2)));
    }
    preStatTableKey.close ();
    rsTableKey.close ();
    return htTableKey;
}


public void testSimpleDeleteOnAnimal () {
    if (getDialect ().hasSelfReferentialForeignKeyBug ()) {
        reportSkip ("self referential FK bug", "HQL delete testing");
        return;
    }
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("delete from Animal as a where a.id = :id").setLong ("id", data.polliwog.getId ().longValue ()).executeUpdate ();
    assertEquals ("Incorrect delete count", 1, count);
    count = s.createQuery ("delete Animal where id = :id").setLong ("id", data.catepillar.getId ().longValue ()).executeUpdate ();
    assertEquals ("incorrect delete count", 1, count);
    if (supportsSubqueryOnMutatingTable ()) {
        count = s.createQuery ("delete from User u where u not in (select u from User u)").executeUpdate ();
        assertEquals (0, count);
    }
    count = s.createQuery ("delete Animal a").executeUpdate ();
    assertEquals ("Incorrect delete count", 4, count);
    List list = s.createQuery ("select a from Animal as a").list ();
    assertTrue ("table not empty", list.isEmpty ());
    t.commit ();
    s.close ();
    data.cleanup ();
}


-----Function Pair=298=-----==

public HashSet < YearOfStudy > findByDepartment (Integer departmentId) throws DBConnectionException, SelectException {
    HashSet < YearOfStudy > yosSet = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("DEPARTMENT_ID", departmentId);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (YearOfStudyDAO.TABLE_NAME, critWhere).toString ());
        if (result != null) {
            yosSet = new HashSet < YearOfStudy > ();
            while (result.next ()) {
                YearOfStudy yos = new YearOfStudy (result.getString ("YEAR_STUDY_NAME"));
                yos.setAcaYear (null);
                yos.setDescription (result.getString ("YEAR_STUDY_DESCRIPTION"));
                yos.setDurationSession (result.getFloat ("YEAR_STUDY_DURATION_SESSION"));
                yos.setGroupList (null);
                yos.setHolidays (null);
                yos.setId (result.getInt ("YEAR_STUDY_ID"));
                yos.setNbSessionPM (result.getInt ("YEAR_STUDY_NB_SESSIONPM"));
                yos.setNbSessionsAM (result.getInt ("YEAR_STUDY_NB_SESSIONAM"));
                yosSet.add (yos);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return yosSet;
}


public List < Igreja > listar () throws Exception {
    Connection connection = criaConexao (false);
    String sql = "SELECT * FROM Igreja";
    PreparedStatement stmt = null;
    ResultSet rs = null;
    Igreja igreja = null;
    List < Igreja > listaIgreja = new ArrayList < Igreja > ();
    try {
        stmt = connection.prepareStatement (sql);
        rs = stmt.executeQuery ();
        while (rs.next ()) {
            igreja = new Igreja ();
            igreja.setIdLocal (rs.getInt ("idlocal"));
            listaIgreja.add (igreja);
        }
    } catch (SQLException e) {
        throw e;
    } finally {
        try {
            stmt.close ();
            rs.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
    return listaIgreja;
}


-----Function Pair=299=-----==

protected boolean isExist (Connection con) throws Exception {
    boolean returnValue = false;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT organize_id FROM " + Common.ORGANIZE_TABLE + " WHERE organize_id = ? AND organize_type_id = ?";
    try {
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.organizeID);
        ps.setString (2, this.organizeTypeID);
        result = ps.executeQuery ();
        if (! result.next ()) {
            returnValue = false;
        }
        else {
            int nTemp = result.getInt (1);
            returnValue = true;
        }
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.isExist(): SQLException: \n\t" + se);
    } finally {
        closeResultSet (result);
        closePreparedStatement (ps);
    }
    return returnValue;
}


protected boolean isExist () throws Exception {
    boolean returnValue = false;
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT role_id FROM " + Common.ROLE_AUTHORITY_TABLE + " WHERE role_id = ? " + "AND authority_id = ?";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.role.getRoleID ());
        ps.setInt (2, this.authority.getAuthorityID ());
        result = ps.executeQuery ();
        if (! result.next ()) {
            returnValue = false;
        }
        else {
            int nTemp = result.getInt (1);
            returnValue = true;
        }
    } catch (SQLException se) {
        throw new CesSystemException ("RoleAuthority.isExist(): SQLException: \n\t" + se);
    } finally {
        close (dbo, ps, result);
    }
    return returnValue;
}


-----Function Pair=300=-----==

public Members findMemberById (int memberId) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Members member = (Members) session.get (Members.class, memberId);
        tr.commit ();
        return member;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public RestServiceResult logout (HttpSession session, RestServiceResult serviceResult, MaUser maUser) {
    log.info ("Starting logout sequence");
    session.removeAttribute ("user");
    session.invalidate ();
    if (maUser != null) {
        Object [] args = {maUser.getIdentification ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.logout.success"), args));
        log.info ("Usuario " + maUser.getUserName () + " sali� de la aplicaci�n!");
    }
    else {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("user.logout.notLoggedIn"));
        log.info ("Attempted to logout when not logged in");
    }
    return serviceResult;
}


-----Function Pair=301=-----==

public boolean deleteMember (Members member) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.delete (member);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        person.getAddresses ().add ("Main Road 12 - Oakwood");
        person.getAddresses ().add ("Sunshine Boulevard 211 - Austin");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=302=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public boolean insertRanks (Ranks rank) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.save (rank);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=303=-----==

public boolean insertValidating (Validating validating) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (validating);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=304=-----==

public Vector getUserOfOrg () throws Exception {
    Vector vUser = null;
    try {
        Vector allUser = getJuniorUser ();
        for (int i = 0; i < allUser.size (); i ++) {
            User uTemp = (User) allUser.get (i);
            if (uTemp.getPartTime ().equals ("no")) {
                vUser.addElement (uTemp);
            }
        }
    } catch (Exception e) {
        throw new CesSystemException ("Organize.getUserOfOrg(): Exception:  " + e);
    }
    return vUser;
}


public boolean deleteSessionsBySid (String sid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Sessions as s where s.sid=?");
        query.setParameter (0, sid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=305=-----==

public String addAssociationType (Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException {
    NodeList children = root.getChildNodes ();
    int len = children.getLength ();
    Node node = children.item (0);
    String name = getAttribute (node, NAME);
    String id = getAttribute (node, ID);
    String code = getAttribute (node, CODE);
    String namespaceId = getAttribute (node, NAMESPACE_ID);
    String connectType = getAttribute (node, CONNECT_TYPE);
    String purpose = getAttribute (node, PURPOSE);
    String inverseName = getAttribute (node, INVERSE_NAME);
    checkPermission (permit, namespaceId);
    int namespaceIdInt = Integer.parseInt (namespaceId);
    int idInt = Integer.parseInt (id);
    if (idInt == - 1) {
        idInt = getNextFormId (TABLE_KEY, namespaceId);
    }
    if ((code == null) || code.equals ("") || code.equals ("null")) {
        code = generateCode (idInt);
    }
    insertSt.setLong (1, getGID (namespaceIdInt, idInt));
    insertSt.setInt (2, idInt);
    insertSt.setString (3, code);
    insertSt.setString (4, name);
    insertSt.setInt (5, Integer.parseInt (namespaceId));
    insertSt.setString (6, connectType);
    insertSt.setString (7, purpose);
    insertSt.setString (8, inverseName);
    insertSt.setNull (9, Types.INTEGER);
    int result = insertSt.executeUpdate ();
    StringBuffer buff = new StringBuffer (200);
    appendDtd (buff, com.apelon.dts.dtd.common.DTD.ASSOCIATIONTYPE, "associationType");
    getAssociationType ("ID", Integer.toString (idInt), namespaceId, buff);
    return buff.toString ();
}


public Collection getUserAndRolePerm (long userID, Collection userOpts, Collection roleOpts) {
    Collection userAndRolePerm = userOpts;
    if ((roleOpts == null) || (roleOpts.size () == 0)) {
        return userAndRolePerm;
    }
    Iterator roleOpts_ir = roleOpts.iterator ();
    Iterator userOpts_ir = null;
    if ((userOpts != null)) {
        userOpts_ir = userOpts.iterator ();
    }
    if (userOpts != null && userOpts.size () > 0) {
        while (roleOpts_ir.hasNext ()) {
            RolePermission roleperm = (RolePermission) roleOpts_ir.next ();
            long role_opt_id = roleperm.getResopid ();
            long role_res_id = roleperm.getResourceid ();
            boolean addIndex = true;
            while (userOpts_ir.hasNext ()) {
                UserPermission userperm = (UserPermission) userOpts_ir.next ();
                long user_opt_id = userperm.getResop_id ();
                long user_res_id = userperm.getResource_id ();
                if ((user_opt_id == role_opt_id) && (user_res_id == role_res_id)) {
                    addIndex = false;
                    break;
                }
            }
            if (addIndex) {
                UserPermission userperm_t = PrivilegeFactory.getInstance ().createUserPermission ();
                userperm_t.setUser_id (userID);
                userperm_t.setResop_id (role_opt_id);
                userperm_t.setResource_id (role_res_id);
                userperm_t.setRes_code (roleperm.getRes_code ());
                userperm_t.setOpt_code (roleperm.getOpt_code ());
                userperm_t.setRolePerm (true);
                userAndRolePerm.add (userperm_t);
            }
            userOpts_ir = userOpts.iterator ();
        }
    }
    else {
        if (userAndRolePerm == null) {
            userAndRolePerm = new ArrayList ();
        }
        String role_res_code;
        String role_opt_code;
        while (roleOpts_ir.hasNext ()) {
            RolePermission roleperm = (RolePermission) roleOpts_ir.next ();
            long role_opt_id = roleperm.getResopid ();
            long role_res_id = roleperm.getResourceid ();
            role_opt_code = roleperm.getOpt_code ();
            role_res_code = roleperm.getRes_code ();
            UserPermission userperm_t = PrivilegeFactory.getInstance ().createUserPermission ();
            userperm_t.setUser_id (userID);
            userperm_t.setResop_id (role_opt_id);
            userperm_t.setResource_id (role_res_id);
            userperm_t.setRes_code (role_res_code);
            userperm_t.setOpt_code (role_opt_code);
            userperm_t.setRolePerm (true);
            userAndRolePerm.add (userperm_t);
        }
    }
    return userAndRolePerm;
}


-----Function Pair=306=-----==

public static Object executeMerge (Object o, Session em) throws Exception {
    Transaction t = null;
    Object o2 = null;
    try {
        t = em.beginTransaction ();
        o2 = em.merge (o);
        t.commit ();
        return o2;
    } catch (Exception e) {
        try {
            t.rollback ();
        } catch (Exception ee) {
        }
        throw e;
    }
}


public Projects findProjectsById (Short projectsId) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Projects project = (Projects) session.get (Projects.class, projectsId);
        tr.commit ();
        return project;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=307=-----==

public Vector getPerson (String authId) throws Exception {
    Vector vec = new Vector ();
    Connection con = null;
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT c.user_name,c.login_name,d.organize_name " + "FROM (SELECT a.user_id,a.user_name,a.login_name,b.organize_id " + "FROM " + Common.USER_TABLE + " A," + Common.ORGANIZE_RELATION_TABLE + " B WHERE a.user_id = b.child_id " + "AND a.user_id in ((select user_id from (select operator_id FROM " + Common.AUTHORITY_ASSIGN_TABLE + " " + "WHERE authority_id = '2002')))) C," + Common.ORGANIZE_TABLE + " D WHETE c.organize_id = d.organize_id";
    DBOperation dbo = factory.createDBOperation (POOL_NAME);
    try {
        con = dbo.getConnection ();
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        while (result.next ()) {
            String [] obj = new String [3];
            obj [0] = (String) result.getObject (1);
            obj [1] = (String) result.getObject (2);
            obj [2] = (String) result.getObject (3);
            vec.add (obj);
        }
    } catch (SQLException se) {
        throw new CesSystemException (" SQLException:  " + se);
    } finally {
        close (dbo, ps, result);
    }
    return vec;
}


public void testStaleNonVersionedInstanceFoundOnLock () {
    if (! readCommittedIsolationMaintained ("repeatable read tests")) {
        return;
    }
    if (getDialect ().doesReadCommittedCauseWritersToBlockReaders ()) {
        reportSkip ("lock blocking", "stale versioned instance");
        return;
    }
    String check = "Lock Modes";
    Session s1 = getSessions ().openSession ();
    Transaction t1 = s1.beginTransaction ();
    Part part = new Part (new Item ("EJB3 Specification"), check, "3.3.5.3", new BigDecimal (0.0));
    s1.save (part);
    t1.commit ();
    s1.close ();
    Long partId = part.getId ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    part = (Part) s1.get (Part.class, partId);
    Session s2 = getSessions ().openSession ();
    Transaction t2 = s2.beginTransaction ();
    Part part2 = (Part) s2.get (Part.class, partId);
    part2.setName ("Lock Mode Types");
    t2.commit ();
    s2.close ();
    s1.lock (part, LockMode.READ);
    part2 = (Part) s1.get (Part.class, partId);
    assertTrue (part == part2);
    assertEquals ("encountered non-repeatable read", check, part2.getName ());
    try {
        s1.lock (part, LockMode.UPGRADE);
    } catch (Throwable t) {
        t1.rollback ();
        t1 = s1.beginTransaction ();
    }
    part2 = (Part) s1.get (Part.class, partId);
    assertTrue (part == part2);
    assertEquals ("encountered non-repeatable read", check, part2.getName ());
    t1.commit ();
    s1.close ();
    s1 = getSessions ().openSession ();
    t1 = s1.beginTransaction ();
    s1.delete (part);
    s1.delete (part.getItem ());
    t1.commit ();
    s1.close ();
}


-----Function Pair=308=-----==

protected boolean update (String sql, int requiredRows, int maxRows) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("executing " + sql + "...");
    }
    Connection connection = null;
    boolean oldAutoCommit = true;
    try {
        connection = dataSource.getConnection ();
        connection.clearWarnings ();
        oldAutoCommit = connection.getAutoCommit ();
        connection.setAutoCommit (false);
        Statement statement = connection.createStatement ();
        int rowsAffected = statement.executeUpdate (sql);
        if (requiredRows != - 1 && rowsAffected < requiredRows) {
            LOG.warn ("(" + rowsAffected + ") less than " + requiredRows + " rows affected, rolling back...");
            connection.rollback ();
            return false;
        }
        if (maxRows != - 1 && rowsAffected > maxRows) {
            LOG.warn ("(" + rowsAffected + ") more than " + maxRows + " rows affected, rolling back...");
            connection.rollback ();
            return false;
        }
        connection.commit ();
        return true;
    } catch (SQLException e) {
        LOG.error ("Unable to update database using: " + sql, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.setAutoCommit (oldAutoCommit);
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


private boolean canAuth (Connection conn, int partner, String id, int host, int property) throws GeneralFault, SQLException {
    PreparedStatement stmt = null;
    try {
        stmt = conn.prepareStatement ("SELECT value FROM auth " + "WHERE id = ? AND host = ? AND prop = ? AND dir = ? AND partner = ?");
        stmt.setString (1, id);
        stmt.setInt (2, host);
        stmt.setInt (3, property);
        stmt.setBoolean (4, Direction.ORDINARY);
        stmt.setInt (5, partner);
        ResultSet rs = stmt.executeQuery ();
        return rs.next () && PropertyRight.contains (rs.getInt ("value"), PropertyRight.convert (Value.AUTH), true);
    } catch (SQLException ex) {
        throw new GeneralFault ("Could not check authorization of sending partner.", ex);
    } finally {
        StorageUtils.close (stmt);
    }
}


-----Function Pair=309=-----==

protected List < List < Object > > retrieveAsList (String sql) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("querying " + sql + "...");
    }
    List < List < Object > > list = new ArrayList < List < Object > > ();
    Connection connection = null;
    try {
        connection = dataSource.getConnection ();
        connection.clearWarnings ();
        Statement statement = connection.createStatement ();
        ResultSet rs = statement.executeQuery (sql);
        ResultSetMetaData metadata = rs.getMetaData ();
        while (rs.next ()) {
            List < Object > oneRow = new ArrayList < Object > ();
            for (int i = 0; i < metadata.getColumnCount (); i ++) {
                oneRow.add (rs.getObject (i + 1));
            }
            list.add (oneRow);
        }
        return list;
    } catch (SQLException e) {
        LOG.error ("Unable to retrive data via: " + sql, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


protected static void executePostHibernateStartUpSQL (final ServletConfig config, final Lifecycle lc) {
    Session s = lc.getHibernateDatasourceDirectly ().createNewSession ();
    Transaction tx = null;
    Level oldLevel = Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").getLevel ();
    try {
        Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").setLevel (Level.OFF);
        for (Element statement : (List < Element >) config.getPostHibernateStartUpSQL ().getChildren ("statement")) {
            boolean ignoreErrors = false;
            String sql = statement.getText ().trim ();
            if (statement.getAttributeValue ("ignoreErrors").equalsIgnoreCase ("true")) {
                ignoreErrors = true;
            }
            try {
                tx = s.beginTransaction ();
                s.createSQLQuery (sql).executeUpdate ();
                tx.commit ();
            } catch (Exception e) {
                if (tx != null) {
                    tx.rollback ();
                }
                if (! ignoreErrors) {
                    LOGGER.warn (sql + System.getProperty ("line.separator") + e.getLocalizedMessage ());
                }
            }
        }
    } catch (Exception e) {
        throw new PulseException ("Error: " + e.getLocalizedMessage (), e);
    } finally {
        s.close ();
        Logger.getLogger ("org.hibernate.util.JDBCExceptionReporter").setLevel (oldLevel);
    }
}


-----Function Pair=310=-----==

private static void insert (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address = new Address ();
        address.setStreet ("Main Road 12");
        address.setCity ("Oakwood");
        person.setAddress (address);
        session.save (person);
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public List getOperationParams (long operationRefId) throws Exception {
    Session session = null;
    try {
        session = sessionFactory.openSession ();
        Query query = session.createQuery ("from RlxOperationParam where operationRefId = ? order by refId");
        query.setLong (0, operationRefId);
        List list = query.list ();
        Hibernate.initialize (list);
        return list;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


-----Function Pair=311=-----==

protected Object retrieveOneValue (String sql, String columnName) throws SQLException {
    if (LOG.isDebugEnabled ()) {
        LOG.debug ("querying " + sql + "...");
    }
    Connection connection = null;
    try {
        connection = dataSource.getConnection ();
        Statement statement = connection.createStatement ();
        ResultSet rs = statement.executeQuery (sql);
        if (! rs.next ()) {
            return null;
        }
        else {
            return rs.getObject (columnName);
        }
    } catch (SQLException e) {
        LOG.error ("Error while calling retrieve(): " + e, e);
        throw e;
    } finally {
        try {
            if (connection != null) {
                connection.close ();
            }
        } catch (SQLException e) {
            LOG.error ("Unable to close connection: " + e, e);
        }
    }
}


public Collection listTags () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select TagName from MorphologyTags order by TagName";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector tags = new Vector ();
            while (rs.next () == true) tags.add (rs.getString (1));
            return tags;
        } finally {
            try {
                if (rs != null) rs.close ();
                if (stmt != null) stmt.close ();
                if (conn != null) conn.close ();
            } catch (SQLException e) {
            }
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=312=-----==

private String updateConceptTermAssociation (Node node, Entry oldEntry, Entry newEntry) throws SQLException {
    conn.setAutoCommit (false);
    int defaultLevel = conn.getTransactionIsolation ();
    conn.setTransactionIsolation (Connection.TRANSACTION_READ_COMMITTED);
    try {
        boolean success = false;
        if ((oldEntry.associationGID == newEntry.associationGID) && (oldEntry.fromGID == newEntry.fromGID) && (oldEntry.toGID == newEntry.toGID)) {
            NodeList qualifierChildren = node.getChildNodes ();
            long instanceID = this.getInstanceId (oldEntry.fromGID, oldEntry.associationGID, oldEntry.toGID, oldEntry.mode + "_ASSOCIATION");
            success = updateQualifiers (TABLE_KEY, instanceID, oldEntry.mode + "_ASSOCIATION", qualifierChildren);
        }
        else {
            success = updateConceptTermAssociationNT (node, oldEntry, newEntry);
        }
        if (! success) {
            conn.rollback ();
            return getFalseResult ();
        }
        WFPlugin wf = oldEntry.getWF (this);
        wf.update (oldEntry.fromId, oldEntry.fromNamespaceId, oldEntry.permit, WFPlugin.ATTR_ASSOCIATION, WFPlugin.EDIT_UPDATE);
        conn.commit ();
        return getTrueResult ();
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } catch (Exception e) {
        conn.rollback ();
        throw new SQLException ("unable to update association " + e.getMessage ());
    } finally {
        conn.setTransactionIsolation (defaultLevel);
        conn.setAutoCommit (true);
    }
}


private boolean createTables (Connection conn) {
    logger.info ("Going to create tables...");
    String dbType = this.getFromSession ("database");
    if ("postgresql".equals (dbType) || "oracle".equals (dbType)) {
        this.dropOracleOrPostgreSQLTables (dbType, conn);
    }
    try {
        boolean status = true;
        boolean autoCommit = conn.getAutoCommit ();
        conn.setAutoCommit (false);
        List statements = ParseDBStructFile.parse (SystemGlobals.getValue (ConfigKeys.CONFIG_DIR) + "/database/" + dbType + "/" + dbType + "_db_struct.sql");
        for (Iterator iter = statements.iterator (); iter.hasNext ();) {
            String query = (String) iter.next ();
            if (query == null || "".equals (query.trim ())) {
                continue;
            }
            Statement s = null;
            try {
                s = conn.createStatement ();
                s.executeUpdate (query);
            } catch (SQLException ex) {
                status = false;
                logger.error ("Error executing query: " + query + ": " + ex, ex);
                this.context.put ("exceptionMessage", ex.getMessage () + "\n" + query);
                break;
            } finally {
                DbUtils.close (s);
            }
        }
        conn.setAutoCommit (autoCommit);
        return status;
    } catch (Exception e) {
        throw new ForumException (e);
    }
}


-----Function Pair=313=-----==

public List < Members > findByProperty (String propertyName, Object value) {
    Session session = null;
    Transaction tran = null;
    Query query = null;
    List < Members > members = null;
    try {
        members = new ArrayList < Members > ();
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tran = session.beginTransaction ();
        query = session.createQuery ("from Members as m where m." + propertyName + "=?");
        query.setString (0, value.toString ());
        members = query.list ();
        tran.commit ();
    } catch (HibernateException e) {
        if (tran != null) {
            tran.rollback ();
        }
        e.printStackTrace ();
    }
    return members;
}


public void delete (String language, String tag, int row) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            String sql = "delete from LanguageMorphologies " + "where LanguageName = '" + language + "' and MorphologyTag = '" + tag + "' and " + "      Rank = " + row;
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            stmt.executeUpdate (sql);
            bumpAllRowsUp (stmt, language, tag, row);
            conn.commit ();
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=314=-----==

public int executeUpdate (String sql, Object [] params) {
    if (debug) {
        System.out.println (sql);
    }
    Connection connection = null;
    connection = this.getConnection ();
    int temp = - 1;
    try {
        if (connection != null && ! connection.isClosed ()) {
            PreparedStatement preparedStatement = connection.prepareStatement (sql);
            InputStream is = null;
            if (params.length > 0) {
                for (int i = 0; i < params.length; i ++) {
                    Object obj = params [i];
                    if (obj.getClass ().equals (Class.forName ("java.io.File"))) {
                        File file = (File) obj;
                        is = new FileInputStream (file);
                        preparedStatement.setBinaryStream (i + 1, is, (int) file.length ());
                    }
                    else {
                        preparedStatement.setObject (i + 1, obj);
                    }
                }
            }
            temp = preparedStatement.executeUpdate ();
            if (is != null) {
                is.close ();
            }
            preparedStatement.close ();
            return temp;
        }
        else {
            log.error ("空连接或关闭的连接！");
            System.out.println ("空连接或关闭的连接！");
            return temp;
        }
    } catch (Exception e) {
        e.printStackTrace ();
        log.error ("执行sql语句错误！", e);
        System.out.println (this.inEncodeing (sql));
        System.out.println ("执行sql语句错误！");
        return temp;
    } finally {
        try {
            connection.close ();
        } catch (SQLException e) {
            log.error ("关闭连接失败！", e);
            System.out.println ("关闭连接失败！");
        }
    }
}


public static boolean tableExistsAndHaveQuery (EboContext p_eboctx, String tablename, String query) throws boRuntimeException {
    boolean ret = false;
    try {
        Connection cn = p_eboctx.getConnectionData ();
        PreparedStatement pstm = cn.prepareStatement ("SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME=?");
        pstm.setString (1, tablename);
        ResultSet rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            ret = true;
        }
        if (ret) {
            if ((query != null) && (query.length () > 0)) {
                PreparedStatement pstm2 = cn.prepareStatement ("SELECT COUNT(*) FROM " + tablename + " WHERE " + query);
                ResultSet rslt2 = pstm2.executeQuery ();
                while (rslt2.next ()) {
                    ret = rslt2.getLong (1) > 0;
                }
                rslt2.close ();
                pstm2.close ();
            }
        }
        rslt.close ();
        pstm.close ();
    } catch (Exception e) {
        throw new boRuntimeException ("dbmagf.tableExists", "BO-1304", e);
    } finally {
    }
    return ret;
}


-----Function Pair=315=-----==

public boolean deleteSpacecaches (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Spacecaches s where s.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=316=-----==

public String queryForString (String sql, Object [] params) {
    if (this.debug) {
        System.out.println (sql);
    }
    Connection connection = null;
    connection = this.getConnection ();
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        String str = null;
        if (connection != null && ! connection.isClosed ()) {
            ps = connection.prepareStatement (sql);
            if (params.length > 0) {
                for (int i = 0; i < params.length; i ++) {
                    String param = params [i].toString ();
                    ps.setObject (i + 1, param);
                }
            }
            rs = ps.executeQuery ();
            while (rs.next ()) {
                str = rs.getString (1);
                rs.close ();
                break;
            }
        }
        return str;
    } catch (SQLException e) {
        log.error ("执行查询语句错误！", e);
        System.out.println (sql);
        System.out.println ("执行查询语句错误！");
    } finally {
        try {
            ps.close ();
        } catch (SQLException e) {
            log.error ("未能正确关闭数据库连接！", e);
            System.out.println ("未能正确关闭数据库连接！");
        }
        try {
            connection.close ();
        } catch (SQLException e) {
            log.error ("未能正确关闭数据库连接！", e);
            System.out.println ("未能正确关闭数据库连接！");
            e.printStackTrace ();
        }
    }
    return null;
}


public void ChangePassword (String oldpass, String newpass) throws NpsException {
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        conn = Database.GetDatabase ("fly").GetConnection ();
        String sql = "select password from users where id=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (! rs.next ()) throw new NpsException ("û���ҵ�" + name + "���û���Ϣ", ErrorHelper.SYS_NOUSER);
        String dbpass = rs.getString ("password");
        if (oldpass != null && dbpass != null) {
            if (! oldpass.equals (dbpass)) throw new NpsException ("ԭ���벻��ȷ", ErrorHelper.SYS_PASSWORD_ERROR);
        }
        else if ((oldpass != null && dbpass == null) || (oldpass == null && dbpass != null)) {
            throw new NpsException ("ԭ���벻��ȷ", ErrorHelper.SYS_PASSWORD_ERROR);
        }
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e2) {
        }
        ChangePassword (conn, id, newpass);
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=317=-----==

public void updateMembers (List < Members > memberList) {
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        for (int i = 0; i < memberList.size (); i ++) {
            Members members = memberList.get (i);
            if (members != null) {
                session.update (members);
            }
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    }
}


public Forums getHotForumsInfo () {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        String hql = "FROM Forums as fo WHERE fo.status>0 ORDER BY fo.posts DESC";
        Query query = session.createQuery (hql);
        query.setMaxResults (1);
        List < Forums > list = query.list ();
        tr.commit ();
        if (list.size () > 0) {
            return list.get (0);
        }
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=318=-----==

public AcademicYear findById (Integer holidaysId) throws SelectException, DBConnectionException {
    AcademicYear acaYear = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (AcademicYearDAO.TABLE_NAME + " ay"));
    tablesFrom.add (new SQLWord (HolidaysDAO.TABLE_NAME + " holy"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("holy.ACADEMIC_YEAR_ID", new SQLWord ("ay.ACADEMIC_YEAR_ID"));
    critWhere.addCriterion ("holy.HOLIDAYS_ID", holidaysId);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                acaYear = new AcademicYear ();
                acaYear.setId (result.getInt ("ACEDEMIC_YEAR_ID"));
                acaYear.setName (result.getString ("ACEDEMIC_YEAR_NAME"));
                acaYear.setYos (null);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return acaYear;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        Person jesse = null;
        Person anne = null;
        for (Person person : collection) {
            if ("Jesse".equals (person.getFirstName ())) {
                jesse = person;
            }
            else if ("Anne".equals (person.getFirstName ())) {
                anne = person;
            }
        }
        anne.getFriends ().add (jesse);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=319=-----==

public ProgramProfilingMessageSymbol deleteProfilingMessageSymbol (int id) throws AdaptationException {
    ProgramProfilingMessageSymbol profilingMessageSymbol = null;
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM ProgramProfilingMessageSymbols " + "WHERE id = " + id;
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        if (! resultSet.next ()) {
            connection.rollback ();
            String msg = "Attempt to delete program profiling message " + "symbol failed.";
            log.error (msg);
            throw new AdaptationException (msg);
        }
        profilingMessageSymbol = getProfilingMessageSymbol (resultSet);
        query = "DELETE FROM ProgramProfilingMessageSymbols " + "WHERE id = " + id;
        statement.executeUpdate (query);
        connection.commit ();
    } catch (SQLException ex) {
        try {
            connection.rollback ();
        } catch (Exception e) {
        }
        String msg = "SQLException in deleteProfilingMessageSymbol";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return profilingMessageSymbol;
}


private String bidStateInsert (Context row) {
    StringBuffer q = new StringBuffer ("insert into BIDSTATE (");
    boolean coma = false;
    for (int field = 0; field < bidStateFields.length; field ++) {
        String n = bidStateFields [field];
        if (row.get (n) != null) {
            if (coma) {
                q.append (", ");
            }
            q.append (n);
            coma = true;
        }
    }
    q.append (") values (");
    coma = false;
    for (int field = 0; field < bidStateFields.length; field ++) {
        String n = bidStateFields [field];
        Integer i = row.getValueAsInteger (n);
        String s = row.getValueAsString (n);
        if (s != null) {
            if (coma) {
                q.append (", ");
            }
            if (i != null) {
                q.append (i);
            }
            else {
                q.append ("'").append (s).append ("'");
            }
            coma = true;
        }
    }
    q.append (")");
    System.err.println (q.toString ());
    return q.toString ();
}


-----Function Pair=320=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query with parameter ***");
        querywithparameter (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=321=-----==

public Collection < Produto > listarProdutosPorEmpresa (Empresa empresa) throws PersistenciaException {
    EntityManager em = getEntityManager ();
    try {
        em.getTransaction ().begin ();
        Query query = em.createQuery ("select p from Produto p where p.empresa = :empresa");
        query.setParameter ("empresa", empresa);
        return query.getResultList ();
    } catch (Exception e) {
        String erro = "Erro ao tentar listar produtos da empresa";
        logger.error (erro);
        em.getTransaction ().rollback ();
        throw new PersistenciaException (e);
    } finally {
        em.close ();
    }
}


public HashSet < Department > findAllDepartment () throws DBConnectionException, SelectException {
    HashSet < Department > dptList = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (DepartmentDAO.TABLE_NAME).toString ());
        if (result != null) {
            dptList = new HashSet < Department > ();
            while (result.next ()) {
                Department dpt = new Department (result.getString ("DEPARTMENT_NAME"), result.getString ("DEPARTMENT_DESCRIPTION"), result.getString ("DEPARTMENT_ACRONYM"), null);
                dpt.setId (result.getInt ("DEPARTMENT_ID"));
                dptList.add (dpt);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return dptList;
}


-----Function Pair=322=-----==

public void clearSettingsStartingWith (String prefix) {
    String qry = "DELETE FROM settings WHERE var LIKE ? ESCAPE '\\'";
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement (qry);
        pstmt.setString (1, prefix.replace ("_", "\\_").replace ("%", "\\%") + "%");
        pstmt.executeUpdate ();
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


public boolean modifyRanks (Ranks rank) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (rank);
        tr.commit ();
        return true;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=323=-----==

public int getNdivTorneo (int idTorneo) {
    int intResult = 0, dato = 0;
    try {
        String sql = "SELECT * FROM torneo WHERE idTorneo=" + idTorneo;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        if (resultSet.next ()) {
            intResult = 1;
            dato = otropopulate (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return dato;
}


public RestServiceResult createPublicationMaterial (RestServiceResult serviceResult, String sArrayMaterialId, ToPublication coPublication) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_PUBLICATION_MATERIAL);
        query.setParameter (1, coPublication.getPublicationId ());
        query.executeUpdate ();
        StringTokenizer stringTokenizer = new StringTokenizer (sArrayMaterialId, ",");
        while (stringTokenizer.hasMoreTokens ()) {
            long nMaterialId = Long.parseLong (stringTokenizer.nextToken ());
            query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_PUBLICATION_MATERIAL);
            query.setParameter (1, coPublication.getPublicationId ());
            query.setParameter (2, nMaterialId);
            query.executeUpdate ();
        }
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coPublication.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("unit.create.success"), arrayParam));
    } catch (PersistenceException e) {
        e.printStackTrace ();
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la asociaci�n - Publicacion - Material: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("unit.create.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


-----Function Pair=324=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToComment toComment) {
    ToCommentDAO coNewsDAO = new ToCommentDAO ();
    try {
        log.info ("Actualizando la publicaci�n: " + toComment.getCommentId ());
        EntityManagerHelper.beginTransaction ();
        coNewsDAO.update (toComment);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toComment);
        Object [] args = {toComment.getCommentId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.update.success"), args));
        log.info ("Se actualizo la publicaci�n con �xito: " + toComment.getCommentId ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la publicacion: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


private boolean isReloadConfigEvent (Event event) {
    boolean isTarget = false;
    if (EventConstants.RELOAD_DAEMON_CONFIG_UEI.equals (event.getUei ())) {
        List < Parm > parmCollection = event.getParms ().getParmCollection ();
        for (Parm parm : parmCollection) {
            if (EventConstants.PARM_DAEMON_NAME.equals (parm.getParmName ()) && "Vacuumd".equalsIgnoreCase (parm.getValue ().getContent ())) {
                isTarget = true;
                break;
            }
        }
    }
    else if (EventConstants.RELOAD_VACUUMD_CONFIG_UEI.equals (event.getUei ())) {
        isTarget = true;
    }
    return isTarget;
}


-----Function Pair=325=-----==

public FileBean create (MimeTypeBean mimeType, SanBean san) throws SQLException {
    long fileId = 0;
    DataSource ds = getDataSource (DEFAULT_DATASOURCE);
    Connection conn = ds.getConnection ();
    try {
        conn.setAutoCommit (false);
        Statement stmt = conn.createStatement ();
        stmt.execute (NEXT_FILE_ID);
        ResultSet rs = stmt.getResultSet ();
        while (rs.next ()) {
            fileId = rs.getLong (NEXTVAL);
        }
        PreparedStatement pstmt = conn.prepareStatement (INSERT_FILE);
        pstmt.setLong (1, fileId);
        pstmt.setLong (2, mimeType.getId ());
        pstmt.setLong (3, san.getId ());
        pstmt.setLong (4, WORKFLOW_ATTENTE_VALIDATION);
        int nbrow = pstmt.executeUpdate ();
        if (nbrow == 0) {
            throw new SQLException ();
        }
        conn.commit ();
        closeRessources (conn, pstmt);
    } catch (SQLException e) {
        log.error ("Can't FileDAOImpl.create " + e.getMessage ());
        conn.rollback ();
        throw e;
    }
    FileBean fileBean = new FileBean ();
    return fileBean;
}


public final boolean exists (Integer id) throws RecordException {
    Connection conn = ConnectionManager.getConnection ();
    LoggableStatement pStat = null;
    Class < ? extends RecordBase > actualClass = this.getClass ();
    String tableName = TableNameResolver.getTableName (actualClass);
    String sql = "select * from " + tableName + " where id = :id";
    StatementBuilder builder = new StatementBuilder (sql);
    builder.set ("id", id);
    try {
        pStat = builder.getPreparedStatement (conn);
        log.log (pStat.getQueryString ());
        ResultSet rs = pStat.executeQuery ();
        boolean exists = rs.next ();
        return exists;
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            throw new RecordException ("Error executing rollback");
        }
        throw new RecordException (e);
    } finally {
        try {
            if (pStat != null) {
                pStat.close ();
            }
            conn.commit ();
            conn.close ();
        } catch (SQLException e) {
            throw new RecordException ("Error closing connection");
        }
    }
}


-----Function Pair=326=-----==

private static void delete (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("DELETE FROM Person");
        query.executeUpdate ();
        query = session.createQuery ("DELETE FROM Address");
        query.executeUpdate ();
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public boolean deleteTags (Tags tags) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.delete (tags);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=327=-----==

public boolean changePassword (String userDocument) {
    boolean ret = false;
    DBHelper helper = null;
    PreparedStatement psRollback = null;
    try {
        UserDocument doc = UserDocument.Factory.parse (userDocument);
        helper = new DBHelper ();
        PreparedStatement psPassword = helper.prepareStatement (SQL.getUpdatePassword ());
        PreparedStatement psCommit = helper.prepareStatement (SQL.commit ());
        psRollback = helper.prepareStatement (SQL.rollback ());
        psPassword.setString (1, doc.getUser ().getPassword ());
        psPassword.setString (2, doc.getUser ().getUserno ());
        psPassword.executeUpdate ();
        psCommit.executeUpdate ();
        ret = true;
    } catch (Exception e) {
        try {
            if (psRollback != null) {
                psRollback.executeUpdate ();
            }
        } catch (SQLException ee) {
            ee.printStackTrace ();
        }
        e.printStackTrace ();
    } finally {
        try {
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return ret;
}


public NameMap getReference (String pTableName) {
    NameMap tOut = new NameMap ();
    ResultSet tRS = null;
    try {
        tRS = getConnection ().getMetaData ().getImportedKeys (loginInfo.getSchema (), SCHEMA_PATTERN, pTableName);
        while (tRS.next ()) {
            String tFkName = tRS.getString ("FK_NAME").intern ();
            String tFkColumnName = tRS.getString ("FKCOLUMN_NAME").intern ();
            String tRefTableName = tRS.getString ("PKTABLE_NAME").intern ();
            String tRefColumnName = tRS.getString ("PKCOLUMN_NAME").intern ();
            tOut.addColumn (tFkName, new NameMapCell (tFkColumnName, tRefTableName, tRefColumnName));
        }
    } catch (Exception e) {
        LOG.error ("", e);
    } finally {
        close (tRS);
    }
    return tOut;
}


-----Function Pair=328=-----==

public RestServiceResult delete (RestServiceResult serviceResult, MaSyntaticError maSyntaticError) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_MA_SYNTACTIC_ERROR);
        query.setParameter (1, maSyntaticError.getErrorId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el error sintactico: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public List < Ranks > findAllRanks () {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Ranks");
        List < Ranks > rankList = query.list ();
        tr.commit ();
        return rankList;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=329=-----==

private AID getAID (String aidN) throws SQLException {
    ResultSet rs = null;
    AID id = new AID (aidN, AID.ISGUID);
    PreparedStatements pss = getPreparedStatements ();
    pss.stm_selAgentAddresses.setString (1, aidN);
    rs = pss.stm_selAgentAddresses.executeQuery ();
    while (rs.next ()) {
        id.addAddresses (rs.getString (1));
    }
    Collection resolvers = getResolverAIDs (aidN);
    Iterator iter = resolvers.iterator ();
    while (iter.hasNext ()) {
        id.addResolvers (getAID ((String) iter.next ()));
    }
    pss.stm_selAgentUserDefSlot.setString (1, aidN);
    rs = pss.stm_selAgentUserDefSlot.executeQuery ();
    while (rs.next ()) {
        String key = rs.getString ("slotkey");
        String value = rs.getString ("slotval");
        id.addUserDefinedSlot (key, value);
    }
    return id;
}


public RestServiceResult listUserForExerciseGroup (RestServiceResult serviceResult, Long nQuestionGroupId) {
    List < CoUserQuestionGroup > listUserGroup = null;
    List < MaUser > listUser = new ArrayList < MaUser > ();
    try {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_USER_QUESTION_GROUP, CoUserQuestionGroup.class);
        query.setParameter (1, nQuestionGroupId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        listUserGroup = query.getResultList ();
        serviceResult.setObjResult (listUserGroup);
        if (listUserGroup.size () == 0) {
            serviceResult.setMessage (bundle.getString ("user.list.notFound"));
        }
        else {
            for (Iterator < CoUserQuestionGroup > iterator = listUserGroup.iterator (); iterator.hasNext ();) {
                CoUserQuestionGroup coUserQuestionGroup = (CoUserQuestionGroup) iterator.next ();
                listUser.add (coUserQuestionGroup.getMaUser ());
            }
            Object [] arrayParam = {listUser.size ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.list.success"), arrayParam));
        }
        serviceResult.setObjResult (listUser);
    } catch (Exception e) {
        serviceResult.setError (true);
        log.info ("Error buscando el estado para usuarios por grupo ");
    }
    return serviceResult;
}


-----Function Pair=330=-----==

public int hashCode (String rank) throws FidoDatabaseException, ClassificationNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Pattern, GrammarString, ObjectId, Description " + "from WordClassifications where Rank = " + rank;
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            if (rs.next () == false) throw new ClassificationNotFoundException (rank);
            list.add (rs.getString (1));
            list.add (rs.getString (2));
            list.add (rs.getString (3));
            list.add (rs.getString (4));
            return list.hashCode ();
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public LinkedList < String > getCitiesNames (String sName) {
    String query = "Select city from stadium where name like '%" + sName + "%' order by name";
    LinkedList < String > cList = new LinkedList < String > ();
    Connection conn = ConnectionManager.getManager ().getConnection ();
    try {
        Statement st = conn.createStatement ();
        ResultSet rs = st.executeQuery (query);
        while (rs.next ()) {
            cList.add (rs.getString ("city"));
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return cList;
}


-----Function Pair=331=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=332=-----==

public Vector getAllSubmissionsHere (int cid) {
    Vector vSubs = new Vector ();
    DBConnection con = null;
    try {
        con = DBServiceManager.allocateConnection ();
        StringBuffer query = new StringBuffer ();
        query.append ("SELECT DISTINCT di_submission_name,di_submission_email,");
        query.append ("di_submission_url, di_submission_date, di_submission_description, ");
        query.append ("di_submission_cid,di_submission_language_id,di_submission_id FROM mdir_Submission ");
        query.append ("WHERE di_submission_cid=" + cid + " ORDER BY  di_submission_date ASC");
        ResultSet rs = con.executeQuery (query.toString ());
        while (rs.next ()) {
            int sid = rs.getInt (8);
            Integer in = new Integer (sid);
            vSubs.add (in);
        }
    } catch (SQLException e) {
    } finally {
        if (con != null) {
            con.release ();
        }
    }
    return vSubs;
}


public RestServiceResult createQuestionMaterial (RestServiceResult serviceResult, String sArrayMaterialId, CoQuestion coQuestion) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_QUESTION_MATERIAL);
        query.setParameter (1, coQuestion.getQuestionId ());
        query.executeUpdate ();
        StringTokenizer stringTokenizer = new StringTokenizer (sArrayMaterialId, ",");
        while (stringTokenizer.hasMoreTokens ()) {
            long nMaterialId = Long.parseLong (stringTokenizer.nextToken ());
            query = EntityManagerHelper.createNativeQuery (Statements.INSERT_CO_QUESTION_MATERIAL);
            query.setParameter (1, coQuestion.getQuestionId ());
            query.setParameter (2, nMaterialId);
            query.executeUpdate ();
        }
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coQuestion.getQuestionName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("question.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar la asociaci�n - Pregunta- Material: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("question.create.error"), e.getMessage ()));
        Util.printStackTrace (log, e.getStackTrace ());
    }
    return serviceResult;
}


-----Function Pair=333=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            if (person.getHomeState () == State.AZ) {
                person.setIncome (IncomeGroup.aboveaverage);
            }
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void unlock (String oid, String key) throws PersisterException {
    String lock = getLock (oid);
    if (lock == null) {
        throw new PersisterException ("Object does not exist: OID = " + oid);
    }
    else if (! NULL.equals (lock) && (! lock.equals (key))) {
        throw new PersisterException ("The object is currently locked with another key: OID = " + oid + ", LOCK = " + lock + ", KEY = " + key);
    }
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("update " + _table_name + " set " + _key_col + " = NULL, " + _ts_col + " = ? where " + _oid_col + " = ?");
        ps.setLong (1, System.currentTimeMillis ());
        ps.setString (2, oid);
        ps.executeUpdate ();
    } catch (Throwable th) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (Throwable th2) {
            }
        }
        throw new PersisterException ("Failed to unlock object: OID = " + oid + ", KEY = " + key, th);
    } finally {
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=334=-----==

private void setUpTables (String tempTableName) throws SQLException {
    if (! SQL.checkTableExists (conn, tempTableName)) {
        String createTableStmt = "CREATE TABLE " + tempTableName + " (con numeric NOT NULL)";
        Statement stmt = null;
        try {
            stmt = this.conn.createStatement ();
            int res = stmt.executeUpdate (createTableStmt);
            if (res > 0) {
                Categories.dataDb ().debug ("Successfully created temp table [" + tempTableName + "]");
            }
        } finally {
            if (stmt != null) {
                stmt.close ();
            }
        }
    }
    else {
        String createTableStmt = "TRUNCATE TABLE " + tempTableName;
        Statement stmt = null;
        try {
            stmt = this.conn.createStatement ();
            int res = stmt.executeUpdate (createTableStmt);
            if (res > 0) {
                Categories.dataDb ().debug ("Successfully truncated temp table [" + tempTableName + "]");
            }
        } finally {
            if (stmt != null) {
                stmt.close ();
            }
        }
    }
}


public static File [] chooseFileOpenMultiple (JFrame frame) {
    File retval [];
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (true);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFiles ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


-----Function Pair=335=-----==

public boolean editEvent (event e) {
    boolean result = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("update event set event_name=?,event_date=?, event_time=?,status=?,event_description=?,group_name=? where event_id=?");
        stmt.setString (1, e.getEname ());
        stmt.setString (2, e.getEdate ());
        stmt.setString (3, e.getEtime ());
        stmt.setString (4, e.getStat ());
        stmt.setString (5, e.getDesc ());
        stmt.setString (6, e.getGname ());
        stmt.setInt (7, e.getEid ());
        int num = stmt.executeUpdate ();
        if (num == 1) {
            result = true;
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return result;
}


private void setCriteriaForDBID (String id, Criteria criteria) {
    if (id == null) return;
    HibernateItemPath type = getTypeFromId (id);
    Long dbId = getDBIdFromID (id);
    if (dbId == null) return;
    switch (type) {
        case ALBUM :
            criteria.add (Restrictions.eq ("album.id", dbId));
            return;
        case ARTIST :
            criteria.add (Restrictions.eq ("artist.id", dbId));
            return;
        case GENRE :
            criteria.add (Restrictions.eq ("genre.id", dbId));
            return;
        case TVSEASON :
            criteria.add (Restrictions.eq ("tvSeason.id", dbId));
            return;
        case TVSHOW :
            criteria.add (Restrictions.eq ("tvShow.id", dbId));
            return;
        case AUDIOPLAYLIST :
            criteria.createAlias ("playlist", "plist");
            criteria.add (Restrictions.eq ("plist.id", dbId));
            return;
        default :
            logger.error ("Unsupported type for setting criteria:{}", id);
    }
}


-----Function Pair=336=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    Person person = new Person ();
    try {
        entityManager.getTransaction ().begin ();
        person.setFirstName ("Jesse");
        person.setLastName ("Clark");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=337=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoWordsCompleteE1 coWordsCompleteE1) {
    CoWordsCompleteE1DAO coWordsCompleteE1DAO = new CoWordsCompleteE1DAO ();
    try {
        coWordsCompleteE1.setWordsCompleteE1Id (getSequence ("sq_co_words_complete_e1"));
        EntityManagerHelper.beginTransaction ();
        coWordsCompleteE1DAO.save (coWordsCompleteE1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coWordsCompleteE1);
        log.info ("Palabra creada con �xito: " + coWordsCompleteE1.getWord ());
        Object [] arrayParam = {coWordsCompleteE1.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public boolean resultSetHasRequiredActionColumns (ResultSet rs, Collection actionColumns) {
    boolean verified = false;
    Iterator it = actionColumns.iterator ();
    while (it.hasNext ()) {
        try {
            if (rs.findColumn ((String) it.next ()) > 0) {
                verified = true;
            }
        } catch (SQLException e) {
            MockUtil.println (e.getMessage ());
            verified = false;
        }
    }
    return verified;
}


-----Function Pair=338=-----==

public boolean checkUser (String name, String password) {
    boolean valid = false;
    user myUser = new user ();
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("Select * from user where uname = ?");
        stmt.setString (1, name);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                myUser.setUname (rs.getString ("uname"));
                myUser.setUpass (rs.getString ("upass"));
            }
            if (name.equals (myUser.getUname ()) && password.equals (myUser.getUpass ())) {
                valid = true;
            }
            return valid;
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return valid;
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=339=-----==

public List < SmsRecptn > selectSmsRecptnInfs (SmsRecptn vo) throws Exception {
    List < SmsRecptn > list = new ArrayList < SmsRecptn > ();
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    StringBuffer buffer = new StringBuffer ();
    try {
        buffer.append ("SELECT\n");
        buffer.append ("  a.SMS_ID, a.RECPTN_TELNO, a.RESULT_CODE, a.RESULT_MSSAGE\n");
        buffer.append ("FROM COMTNSMSRECPTN a\n");
        buffer.append ("WHERE a.SMS_ID = ?");
        conn = SmsBasicDBUtil.getConnection ();
        pstmt = conn.prepareStatement (buffer.toString ());
        int index = 0;
        pstmt.setString (++ index, vo.getSmsId ());
        rs = pstmt.executeQuery ();
        SmsRecptn result = null;
        while (rs.next ()) {
            result = new SmsRecptn ();
            result.setSmsId (rs.getString ("SMS_ID"));
            result.setRecptnTelno (rs.getString ("RECPTN_TELNO"));
            result.setResultCode (rs.getString ("RESULT_CODE"));
            result.setResultMssage (rs.getString ("RESULT_MSSAGE"));
            list.add (result);
        }
        return list;
    } finally {
        SmsBasicDBUtil.close (rs, pstmt, conn);
    }
}


private void moveNode (SimpleTreeNode movingNode, SimpleTreeNode toNode) {
    log.info (movingNode.toString () + " to " + toNode.toString ());
    if (movingNode == toNode) return;
    CTreeNode toMNode = (CTreeNode) toNode.getData ();
    if (! toMNode.isSummary ()) {
        moveNode (movingNode, toNode, false);
    }
    else {
        int path [] = treeModel.getPath (treeModel.getRoot (), toNode);
        Treeitem toItem = tree.renderItemByPath (path);
        tree.setSelectedItem (toItem);
        Events.sendEvent (tree, new Event (Events.ON_SELECT, tree));
        MenuListener listener = new MenuListener (movingNode, toNode);
        Menupopup popup = new Menupopup ();
        Menuitem menuItem = new Menuitem ("Insert After");
        menuItem.setValue ("InsertAfter");
        menuItem.setParent (popup);
        menuItem.addEventListener (Events.ON_CLICK, listener);
        menuItem = new Menuitem ("Move Into");
        menuItem.setValue ("MoveInto");
        menuItem.setParent (popup);
        menuItem.addEventListener (Events.ON_CLICK, listener);
        popup.setPage (tree.getPage ());
        popup.open (toItem.getTreerow ());
    }
}


-----Function Pair=340=-----==

public Flags getFlags () throws MessagingException {
    Object oFlag;
    if (oFolder == null) return super.getFlags ();
    else {
        Flags oRetVal = null;
        Statement oStmt = null;
        ResultSet oRSet = null;
        try {
            Flags.Flag [] aFlags = new Flags.Flag [] {Flags.Flag.RECENT, Flags.Flag.ANSWERED, Flags.Flag.DELETED, Flags.Flag.DRAFT, Flags.Flag.FLAGGED, Flags.Flag.SEEN};
            oStmt = ((DBFolder) oFolder).getConnection ().createStatement (ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
            oRSet = oStmt.executeQuery ("SELECT " + DB.bo_recent + "," + DB.bo_answered + "," + DB.bo_deleted + "," + DB.bo_draft + "," + DB.bo_flagged + "," + DB.bo_recent + "," + DB.bo_seen + " FROM " + DB.k_mime_msgs + " WHERE " + DB.gu_mimemsg + "='" + getMessageGuid () + "'");
            if (oRSet.next ()) {
                oRetVal = new Flags ();
                for (int f = 1; f <= 6; f ++) {
                    oFlag = oRSet.getObject (f);
                    if (! oRSet.wasNull ()) {
                        if (oFlag.getClass ().equals (Short.TYPE)) {
                            if (((Short) oFlag).shortValue () == (short) 1) oRetVal.add (aFlags [f - 1]);
                        }
                        else {
                            if (Integer.parseInt (oFlag.toString ()) != 0) oRetVal.add (aFlags [f - 1]);
                        }
                    }
                }
            }
            oRSet.close ();
            oRSet = null;
            oStmt.close ();
            oStmt = null;
            return oRetVal;
        } catch (SQLException sqle) {
            if (oStmt != null) {
                try {
                    oStmt.close ();
                } catch (Exception ignore) {
                }
            }
            if (oRSet != null) {
                try {
                    oRSet.close ();
                } catch (Exception ignore) {
                }
            }
        }
    }
    return null;
}


public boolean insertCalculatedHand (CalculateTransferObject to, BasicStartingHandTransferObject [] hands) throws CalculateDAOException {
    boolean result = false;
    Connection connection = null;
    PreparedStatement prep = null;
    try {
        connection = getDataSource ().getConnection ();
        connection.setAutoCommit (false);
        prep = connection.prepareStatement (INSERT_CALC_SQL);
        prep.setString (1, to.getHandsAsString ());
        prep.setString (2, to.getBoardAsString ());
        prep.setString (3, to.getDeadAsString ());
        result = prep.execute ();
    } catch (SQLException sqle) {
        try {
            connection.rollback ();
        } catch (SQLException e) {
            e.setNextException (sqle);
            throw new CalculateDAOException (e);
        }
        throw new CalculateDAOException (sqle);
    } finally {
        if (prep != null) {
            try {
                prep.close ();
            } catch (SQLException e) {
                throw new CalculateDAOException (e);
            }
        }
    }
    try {
        prep = connection.prepareStatement (INSERT_HAND_SQL);
        for (int i = 0; i < hands.length; i ++) {
            prep.setString (1, hands [i].getHand ());
            prep.setInt (2, hands [i].getWins ());
            prep.setInt (3, hands [i].getDraws ());
            prep.setInt (4, hands [i].getLoses ());
            result = prep.execute ();
        }
        connection.commit ();
    } catch (SQLException sqle) {
        try {
            connection.rollback ();
        } catch (SQLException e) {
            e.setNextException (sqle);
            throw new CalculateDAOException (e);
        }
        throw new CalculateDAOException (sqle);
    } finally {
        if (prep != null) {
            try {
                prep.close ();
            } catch (SQLException e) {
                throw new CalculateDAOException (e);
            }
        }
    }
    return result;
}


-----Function Pair=341=-----==

public RecordMap readMapping (String source, String target, String uid, boolean isServerId) {
    RecordMap recordMap = null;
    Session session = this.hibernateManager.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query query = null;
        if (isServerId) {
            query = session.createQuery ("from RecordMap as recordmap where recordmap.source=? and recordmap.target=? and recordmap.guid=?").setString (0, source).setString (1, target).setString (2, uid);
        }
        else {
            query = session.createQuery ("from RecordMap as recordmap where recordmap.source=? and recordmap.target=? and recordmap.luid=?").setString (0, source).setString (1, target).setString (2, uid);
        }
        List cour = query.list ();
        if (cour != null && ! cour.isEmpty ()) {
            recordMap = (RecordMap) cour.get (0);
        }
        tx.commit ();
    } catch (Exception e) {
        tx.rollback ();
        throw new SyncException (e);
    }
    return recordMap;
}


public boolean isCached (GetPropertyValues gpv) {
    if (gpv.sizeProperty () == 0) {
        return true;
    }
    Date from = null, till = null;
    boolean onlyNeedsOneValidPeriod = (gpv.ifAt () && gpv.getTime () == null) || (gpv.ifDuring () && gpv.getDuring ().getTill () == null) || (! gpv.ifAt () && ! gpv.ifDuring ());
    if (gpv.ifAt ()) {
        from = till = gpv.getTime ();
    }
    else if (gpv.ifDuring ()) {
        from = gpv.getDuring ().getFrom ();
        till = gpv.getDuring ().getTill ();
    }
    Connection conn = null;
    Iterable < Integer > props = representer.getInternalReps (gpv.getProperties ());
    try {
        conn = getConnection ();
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement ("SELECT COUNT(*) FROM cachedperiods WHERE " + "id = ? AND host = ? AND " + "prop IN (" + StringUtils.join (props.iterator (), ",") + ") AND " + "starttime < ? AND endtime > ? AND hasvalues >= ?");
            stmt.setString (1, gpv.getItem ().getResolved ().getId ());
            Integer hostIndex = representer.lookUpInternalRep (gpv.getItem ().getResolved ().getHost ());
            stmt.setInt (2, hostIndex);
            stmt.setLong (3, onlyNeedsOneValidPeriod ? Long.MAX_VALUE : from.getTime ());
            stmt.setLong (4, onlyNeedsOneValidPeriod ? 0 : till.getTime ());
            stmt.setInt (5, onlyNeedsOneValidPeriod ? 1 : 0);
            ResultSet rs = stmt.executeQuery ();
            return rs.next () && rs.getInt (1) > 0;
        } finally {
            StorageUtils.close (stmt);
        }
    } catch (SQLException ex) {
        Logger.getLogger (MetaDataStoragerImpl.class.getName ()).log (Level.SEVERE, "Cannot determine cache status, assuming not cached.", ex);
        return false;
    } finally {
        StorageUtils.close (conn);
    }
}


-----Function Pair=342=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
            person.getAddresses ().add ("Camino De Las Cabras 212 - San Jose");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static double getCDiscount (Connection con, int c_id) {
    double c_discount = 0.0;
    try {
        PreparedStatement statement = con.prepareStatement ("SELECT c_discount FROM customer WHERE customer.c_id = ?");
        statement.setInt (1, c_id);
        ResultSet rs = statement.executeQuery ();
        rs.next ();
        c_discount = rs.getDouble (1);
        rs.close ();
        statement.close ();
    } catch (java.lang.Exception ex) {
        ex.printStackTrace ();
    }
    return c_discount;
}


-----Function Pair=343=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public Collection listTags () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select TagName from MorphologyTags order by TagName";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector tags = new Vector ();
            while (rs.next () == true) tags.add (rs.getString (1));
            return tags;
        } finally {
            try {
                if (rs != null) rs.close ();
                if (stmt != null) stmt.close ();
                if (conn != null) conn.close ();
            } catch (SQLException e) {
            }
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=344=-----==

public static Vector retrieve2 (String usrlogin, String tab) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        sql = "SELECT m.module_id, m.module_title, m.module_class " + "FROM module m, user_module u " + "WHERE m.module_id = u.module_id " + "AND u.user_login = '" + usrlogin + "' " + "AND u.tab_id = '" + tab + "' order by u.sequence";
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            String id = rs.getString ("module_id");
            String title = rs.getString ("module_title");
            String mclass = rs.getString ("module_class");
            v.addElement (new Module (id, title, mclass));
        }
        return v;
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public static void unzip2 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    ZipFile zip = new ZipFile (zipfile);
    Enumeration < ZipArchiveEntry > files = zip.getEntries ();
    while (files.hasMoreElements ()) {
        ZipArchiveEntry ze = files.nextElement ();
        File newFile = new File (outputdir + File.separator + ze.getName ());
        newFile.getParentFile ().mkdirs ();
        if (ze.isDirectory ()) {
            newFile.mkdir ();
        }
        else {
            InputStream is = zip.getInputStream (ze);
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = is.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
            is.close ();
        }
    }
    zip.close ();
}


-----Function Pair=345=-----==

public MediaItem getMediaForID (String id) {
    logger.debug ("Getting media for id:{}", id);
    HibernateItemPath mediaType = getTypeFromId (id);
    switch (mediaType) {
        case AUDIOITEM :
            return getAudioItemForID (id);
        case VIDEOITEM :
            return getVideoItemForID (id);
        case IMAGEITEM :
            return getImageItemForID (id);
        default :
            logger.error ("Got request for media Item of unsupported type:{}", id);
    }
    return null;
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update and query with jpa ***");
        updateandquerywithjpa (entityManagerFactory);
        System.out.println ("*** update and query with native criteria api ***");
        updateandquerywithcriteria (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=346=-----==

public static Vector < String > retornaCapituloID (final Connection con) {
    Vector < String > v = new Vector < String > ();
    Vector < String > v2 = new Vector < String > ();
    Vector < String > v3 = new Vector < String > ();
    String s = "";
    try {
        Statement smt = con.createStatement ();
        ResultSet rs = smt.executeQuery ("SELECT codCapitulo, titulo FROM capitulo");
        while (rs.next ()) {
            v.addElement (rs.getString ("codCapitulo"));
            v2.addElement (rs.getString ("titulo"));
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    int i = 0;
    while (i < v.size ()) {
        s = v.get (i).toString ();
        s = s + " - ";
        s = s + v2.get (i).toString ();
        v3.addElement (s);
        i ++;
    }
    return v3;
}


public void testPrimaryKeyFloat0023 () throws Exception {
    Double d [] = {new Double (- 1.0), new Double (1234.543), new Double (0.0), new Double (1), new Double (- 2.0), new Double (0.14), new Double (0.79), new Double (1000000.12345), new Double (- 1000000.12345), new Double (1000000), new Double (- 1000000), new Double (1.7E+308), new Double (1.7E-307)};
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("" + "create table #t0023 " + "  (pk   float not null, " + "   type char(30) not null, " + "   b    bit, " + "   str  char(30) not null, " + "   t int identity(1,1), " + "   primary key (pk, type))    ");
    PreparedStatement pstmt = con.prepareStatement ("insert into #t0023 (pk, type, b, str) values(?, 'prepared', 0, ?)");
    for (int i = 0; i < d.length; i ++) {
        pstmt.setDouble (1, d [i].doubleValue ());
        pstmt.setString (2, (d [i]).toString ());
        int preparedCount = pstmt.executeUpdate ();
        assertEquals (preparedCount, 1);
        int adhocCount = stmt.executeUpdate ("" + "insert into #t0023        " + " (pk, type, b, str)      " + " values(" + "   " + d [i] + ",         " + "       'adhoc',          " + "       1,                " + "   '" + d [i] + "')       ");
        assertEquals (adhocCount, 1);
    }
    int count = 0;
    ResultSet rs = stmt.executeQuery ("select * from #t0023 where type='prepared' order by t");
    assertNotNull (rs);
    while (rs.next ()) {
        assertEquals (d [count].toString (), "" + rs.getDouble ("pk"));
        count ++;
    }
    assertEquals (count, d.length);
    count = 0;
    rs = stmt.executeQuery ("select * from #t0023 where type='adhoc' order by t");
    while (rs.next ()) {
        assertEquals (d [count].toString (), "" + rs.getDouble ("pk"));
        count ++;
    }
    assertEquals (count, d.length);
    stmt.close ();
    pstmt.close ();
}


-----Function Pair=347=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Person person1 : person.getSubordinates ()) {
                System.out.println ("\twith subordinate: " + person1);
                for (Person person2 : person1.getSubordinates ()) {
                    System.out.println ("\t\twith subordinate: " + person2);
                }
            }
        }
    } finally {
        entityManager.close ();
    }
}


public Account getAccountFromName (long uid, int acctType, String acctName) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Account R where R.ownerId=? and R.accountType=? and R.accountName=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setInteger (1, acctType);
        q.setString (2, acctName);
        Account a = (Account) q.uniqueResult ();
        s.getTransaction ().commit ();
        return a;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=348=-----==

public boolean findSessionByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Sessions as s where s.uid = ?");
        query.setParameter (0, uid);
        List list = query.list ();
        if (list != null && list.size () > 0) {
            return true;
        }
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
        }
        he.printStackTrace ();
    }
    return false;
}


public static void addAudit (String messageid, String message) throws Exception {
    log.debug ("Adding audit  message");
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Audit auditTable = new Audit ();
    auditTable.setMessageid (messageid);
    auditTable.setAction (message);
    try {
        session.saveOrUpdate (auditTable);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception (e);
    }
    return;
}


-----Function Pair=349=-----==

public DoProjectCustomer getProjectCustomer (Integer projectId, Integer customerId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + DoProjectCustomer.class.getName () + " where doProject.id = '" + projectId + "' and doCustomer.id = '" + customerId + "'";
        Query queryObject = getSession ().createQuery (queryString);
        List < DoProjectCustomer > rtn = queryObject.list ();
        tx.commit ();
        return rtn.size () <= 0 ? null : rtn.get (0);
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public void restore (Component component, String componentName, int currentPilot) {
    try {
        PreparedStatement psta = jdbc.prepareStatement ("SELECT size_height, size_width, pos_x, pos_y " + "FROM component_prop " + "WHERE pilot_id = ? " + "AND component_name = ?");
        psta.setInt (1, currentPilot);
        psta.setString (2, componentName);
        ResultSet resl = psta.executeQuery ();
        if (resl.next ()) {
            component.setSize (resl.getInt (2), resl.getInt (1));
            Point point = new Point (resl.getInt (3), resl.getInt (4));
            component.setLocation (point);
        }
    } catch (SQLException e) {
        log.debug (e);
    }
}


-----Function Pair=350=-----==

public AcUser getSeller (Integer projectId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select p.viewer from " + AcDataProject.class.getName () + " p ");
        hqlSB.append (" where p.data.id = '" + projectId + "' and");
        hqlSB.append (" p.isSeller = true");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        if (! queryObject.iterate ().hasNext ()) {
            return null;
        }
        tx.commit ();
        return (AcUser) queryObject.iterate ().next ();
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


-----Function Pair=351=-----==

public int findSessionsCountByType (boolean members) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        String hql = "select count(*) from Sessions as s where s.uid=0";
        if (members) {
            hql = "select count(*) from Sessions as s where s.uid=0";
        }
        else {
            hql = "select count(*) from Sessions";
        }
        Query query = session.createQuery (hql);
        List list = query.list ();
        tr.commit ();
        if (list != null && list.size () > 0) {
            return Integer.valueOf (list.get (0) + "");
        }
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return 0;
}


public RestServiceResult update (RestServiceResult serviceResult, CoExercises1 coExercises1, String sDeliveryDate) {
    CoExercises1DAO coExercises1DAO = new CoExercises1DAO ();
    Long nExerciseId = coExercises1.getExerciseId ();
    try {
        EntityManagerHelper.beginTransaction ();
        coExercises1DAO.update (coExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coExercises1);
        Object [] args = {coExercises1.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.update.success"), args));
        this.addDeliveryDate (nExerciseId, sDeliveryDate);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=352=-----==

private boolean existsIndex (EboContext ctx, String schemaName, String indexName) throws SQLException {
    Connection cn = null;
    ResultSet rslt = null;
    PreparedStatement pstm = null;
    try {
        cn = ctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("select count(*) from INFORMATION_SCHEMA.STATISTICS where INDEX_SCHEMA=database() and upper(INDEX_NAME)=? and upper(TABLE_NAME) = ?");
        pstm.setString (1, indexName.toUpperCase ());
        pstm.setString (2, schemaName.toUpperCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            if (rslt.getInt (1) > 0) {
                return true;
            }
        }
        return false;
    } catch (SQLException e) {
        throw (e);
    } finally {
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
}


public String getParaUidByProp (String propertyUid, int type) {
    String ret = null;
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        String sql = "select * from do_parameter  where ParaPropertyUid = ? and type = ?";
        PreparedStatement pstmt = con.prepareStatement (sql);
        pstmt.setString (1, propertyUid);
        pstmt.setInt (2, type);
        ResultSet rs = pstmt.executeQuery ();
        if (rs.next ()) {
            ret = rs.getString ("objUid");
        }
        rs.close ();
        pstmt.close ();
    } catch (SQLException ex) {
        try {
            con.rollback ();
        } catch (SQLException ex2) {
            ex2.printStackTrace ();
        }
        ex.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
    return ret;
}


-----Function Pair=353=-----==

public static void delete (String usrlogin) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        sql = "DELETE FROM users_module WHERE user_login = '" + usrlogin + "'";
        stmt.executeUpdate (sql);
        sql = "DELETE FROM users WHERE user_login = '" + usrlogin + "'";
        stmt.executeUpdate (sql);
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public ResultsAlignment getResultsAlignment (long id) {
    ResultsAlignment resultsAlignment = null;
    Transaction transaction = null;
    Session session = InitSessionFactory.getInstance ().getCurrentSession ();
    try {
        transaction = session.beginTransaction ();
        Query query = session.createQuery ("from " + RESULTS_ALIGNMENT_TABLE + " o where o.id =:id");
        query.setLong ("id", id);
        resultsAlignment = (ResultsAlignment) query.uniqueResult ();
        transaction.commit ();
    } catch (HibernateException e) {
        if (transaction != null) transaction.rollback ();
        throw e;
    }
    return resultsAlignment;
}


-----Function Pair=354=-----==

public long count (String sql) {
    long count = 0;
    this.result = null;
    Connection conn = null;
    try {
        conn = ConnectUtil.getConnect ();
        PreparedStatement ps = conn.prepareStatement ("select count(*) " + sql.substring (sql.toLowerCase ().indexOf ("from")));
        ResultSet rs = ps.executeQuery ();
        while (rs.next ()) {
            count = rs.getLong (1);
        }
        rs.close ();
        ps.close ();
    } catch (Exception e) {
        this.result = e.getMessage ();
    } finally {
        ConnectUtil.closeConn (conn);
    }
    return count;
}


public boolean deleteImcompleteCartsClient (String mailClient) {
    Connection conexion = null;
    PreparedStatement deleteHistorialCarros = null;
    PreparedStatement deleteProdCarro = null;
    boolean exito = false;
    try {
        conexion = pool.getConnection ();
        conexion.setAutoCommit (false);
        ArrayList < String > carrosIncompletos = this.requestIncompleteCarts (mailClient);
        if (carrosIncompletos != null) {
            deleteHistorialCarros = conexion.prepareStatement ("DELETE FROM " + nameBD + ".HistorialCarritos WHERE CodigoCarrito=?");
            deleteProdCarro = conexion.prepareStatement ("DELETE FROM " + nameBD + ".Carritos WHERE CodigoCarrito=?");
            for (int i = 0; i < carrosIncompletos.size (); i ++) {
                deleteHistorialCarros.setString (1, carrosIncompletos.get (i));
                deleteHistorialCarros.execute ();
                deleteHistorialCarros.clearParameters ();
                deleteProdCarro.setString (1, carrosIncompletos.get (i));
                deleteProdCarro.execute ();
                deleteProdCarro.clearParameters ();
            }
        }
        conexion.commit ();
        exito = true;
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error borrando los carritos incompletos de un usuario", ex);
        try {
            conexion.rollback ();
        } catch (SQLException ex1) {
            logger.log (Level.SEVERE, "Error haciendo rollback de la transacción para borrar carros incompletos de un usuario", ex1);
        }
    } finally {
        cerrarConexionYStatement (conexion, deleteHistorialCarros, deleteProdCarro);
    }
    return exito;
}


-----Function Pair=355=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoWordsCompleteE3 coWordsCompleteE3) {
    CoWordsCompleteE3DAO coWordsCompleteE3DAO = new CoWordsCompleteE3DAO ();
    try {
        coWordsCompleteE3.setWordsCompleteE3Id (getSequence ("sq_co_words_complete_e3"));
        EntityManagerHelper.beginTransaction ();
        coWordsCompleteE3DAO.save (coWordsCompleteE3);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coWordsCompleteE3);
        log.info ("Palabra creada con �xito: " + coWordsCompleteE3.getWord ());
        Object [] arrayParam = {coWordsCompleteE3.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, CoUnit coUnit) {
    try {
        log.info ("Eliminando la unidad: " + coUnit.getUnitName ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_CO_UNIT);
        query.setParameter (1, coUnit.getUnitId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {coUnit.getUnitName ()};
        log.info ("Unidad eliminada con �xito: " + coUnit.getUnitName ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("unit.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la unidad: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {coUnit.getUnitName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("unit.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=356=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoWordsCompleteE3 coWordsCompleteE3) {
    CoWordsCompleteE3DAO coWordsCompleteE3DAO = new CoWordsCompleteE3DAO ();
    try {
        coWordsCompleteE3.setWordsCompleteE3Id (getSequence ("sq_co_words_complete_e3"));
        EntityManagerHelper.beginTransaction ();
        coWordsCompleteE3DAO.save (coWordsCompleteE3);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coWordsCompleteE3);
        log.info ("Palabra creada con �xito: " + coWordsCompleteE3.getWord ());
        Object [] arrayParam = {coWordsCompleteE3.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public void addContact (Contact u, boolean existing) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        if (existing) {
            deleteContact (s, u.getId ());
        }
        long id = IDGenerator.getInstance ().generateId (s);
        u.setId (id);
        s.save (u);
        s.getTransaction ().commit ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=357=-----==

public List < Object > searchPage (String sql, int page, int size) {
    List < Object > list = null;
    this.result = null;
    Connection conn = null;
    try {
        conn = ConnectUtil.getConnect ();
        sql = SqlUtil.getQuerySql (sql);
        PreparedStatement ps = conn.prepareStatement (sql);
        ps.setInt (1, (page - 1) * size);
        if (ConnectUtil.getDatabaseName ().indexOf ("MYSQL") != - 1 || ConnectUtil.getDatabaseName ().indexOf ("HSQL") != - 1) ps.setInt (2, size);
        else ps.setInt (2, page * size);
        this.assembleObjToList (ps);
        list = this.getOrgList ();
    } catch (Exception e) {
        this.result = e.getMessage ();
    } finally {
        ConnectUtil.closeConn (conn);
    }
    return list;
}


private void getdata (HttpSession session, Hashtable periodData, String schema_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("period_schema_code");
        r.add ("path_no");
        r.add ("period_root_id", schema_id);
        sql = r.getSQLSelect ("period_root");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            periodData.put ("code", rs.getString ("period_schema_code"));
            periodData.put ("path_no", new Integer (rs.getInt ("path_no")));
            periodData.put ("id", schema_id);
        }
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=358=-----==

public static Any getDocTypes (Connection con, Any values, Any retValue) throws SQLException {
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getDocTypes");
    PreparedStatement stmt = con.prepareStatement (sSql);
    ResultSet rSet = stmt.executeQuery ();
    ArrayList < HashMap > arMaps = new ArrayList < HashMap > ();
    while (rSet.next ()) {
        HashMap map = new HashMap ();
        map.put ("ID", rSet.getString ("IDOCTID"));
        map.put ("NAME", rSet.getString ("CTYPNAME"));
        map.put ("AUTONUM", rSet.getString ("CAUTONUM"));
        arMaps.add (map);
    }
    rSet.close ();
    stmt.close ();
    retValue.insert_Value (arMaps.toArray (new HashMap [arMaps.size ()]));
    return retValue;
}


public MsgRecvInfo [] getMsgSearch (String sql) throws SQLException {
    Logger logger = Logger.getLogger (this.getClass ());
    MsgRecvInfo [] msgInfoArray = new ototype.MsgRecvInfo [0];
    ArrayList array = new ArrayList ();
    Connection conn = this.getJdbcTemplate ().getDataSource ().getConnection ();
    try {
        PreparedStatement pstmt = conn.prepareStatement (sql);
        ResultSet rs = pstmt.executeQuery ();
        while (rs.next ()) {
            MsgRecvInfo msgrcv = new MsgRecvInfo ();
            msgrcv.setContent (rs.getString ("mo_content"));
            msgrcv.setRecvDate (rs.getString ("receive_time"));
            msgrcv.setDestMobile (rs.getString ("mo_to"));
            msgrcv.setSendAddi (rs.getString ("mo_to"));
            array.add (msgrcv);
        }
        msgInfoArray = (MsgRecvInfo []) array.toArray (new MsgRecvInfo [array.size ()]);
    } catch (SQLException e) {
        logger.error ("error getMsgSearch", e);
        throw e;
    } finally {
        conn.close ();
    }
    return msgInfoArray;
}


-----Function Pair=359=-----==

public static Any getTemplateType (Connection con, Any values, Any retValue) throws SQLException {
    HashMap val = (HashMap) values.extract_Value ();
    String sID = (String) val.get ("ID");
    PreparedStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("getTemplateType");
    try {
        ps = con.prepareStatement (sSql);
        ps.setString (1, sID);
        OracleResultSet rSet = (OracleResultSet) ps.executeQuery ();
        if (rSet.next ()) {
            int iTempType = rSet.getInt ("ITEMPTYPE");
            HashMap ret = new HashMap ();
            ret.put ("TTYPE", iTempType);
            retValue.insert_Value (ret);
        }
        rSet.close ();
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


public static Tab getTab (String usrlogin, String tabid) throws DbException {
    Tab tab = null;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("tab_title");
        r.add ("display_type");
        r.add ("user_login", usrlogin);
        r.add ("tab_id", tabid);
        sql = r.getSQLSelect ("tab_template");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            String tab_title = rs.getString ("tab_title");
            String displaytype = rs.getString ("display_type");
            tab = new Tab (tabid, tab_title, displaytype);
        }
    } catch (SQLException sqlex) {
        throw new DbException (sqlex.getMessage () + " : " + sql);
    } finally {
        if (db != null) db.close ();
    }
    return tab;
}


-----Function Pair=360=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("P�rez");
            c.setApellido2 ("G�mez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=361=-----==

public HashSet < Status > findAllStatus () throws DBConnectionException, SelectException {
    HashSet < Status > statusSet = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME).toString ());
        if (result != null) {
            statusSet = new HashSet < Status > ();
            while (result.next ()) {
                Status status = new Status ();
                status.setId (result.getInt ("STATUS_ID"));
                status.setName (result.getString ("STATUS_NAME"));
                status.setNbHours (result.getInt ("STATUS_NB_HOURS"));
                statusSet.add (status);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return statusSet;
}


public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


-----Function Pair=362=-----==

public int setData (String mysql) {
    int mycount = 0;
    try {
        conn.setAutoCommit (false);
        mycount = 0;
        stmt = conn.createStatement ();
        mycount = stmt.executeUpdate (mysql);
    } catch (Exception e) {
        mycount = - 1;
    } finally {
        if (mycount > 0) {
            try {
                conn.commit ();
            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
        else {
            try {
                conn.rollback ();
            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
    }
    return mycount;
}


public void insertItems (List < ImageItem > toInsert) throws DatabaseException {
    if (toInsert == null) throw new NullPointerException ("toInsert");
    try {
        getConnection ().setAutoCommit (false);
    } catch (SQLException e) {
        LOGGER.warn ("Unable to set autocommit off", e);
    }
    try {
        int updated = 0;
        for (ImageItem item : toInsert) {
            getItemDeleteStatement (item.getIdentifier ()).executeUpdate ();
            updated += getItemInsertStatement (item).executeUpdate ();
        }
        if (updated == toInsert.size ()) {
            getConnection ().commit ();
            LOGGER.debug ("DB has been updated.");
        }
        else {
            getConnection ().rollback ();
            LOGGER.error ("DB has not been updated -> rollback!");
        }
    } catch (SQLException e) {
        LOGGER.error (e);
    } finally {
        closeConnection ();
    }
}


-----Function Pair=363=-----==

public boolean deleteRanks (Ranks rank) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.delete (rank);
        tr.commit ();
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return true;
}


public final void delete (final T obj) throws CannotConnectToDatabaseException {
    if (obj == null) {
        return;
    }
    final Session s = this.currentSession ();
    Transaction tx = null;
    try {
        tx = s.beginTransaction ();
        s.delete (obj);
        s.flush ();
        s.clear ();
        tx.commit ();
    } catch (HibernateException he) {
        tx.rollback ();
        LOGGER.error ("Failed to delete given entity - transaction was rolled back.", he);
        throw he;
    } finally {
        s.close ();
    }
}


-----Function Pair=364=-----==

public void run () {
    int count = ntrans;
    while (count -- > 0) {
        int account = TestBench.getRandomID (ACCOUNT);
        int branch = TestBench.getRandomID (BRANCH);
        int teller = TestBench.getRandomID (TELLER);
        int delta = TestBench.getRandomInt (- 1000, 1000);
        doOne (branch, teller, account, delta);
        incrementTransactionCount ();
    }
    try {
        if (pstmt1 != null) {
            pstmt1.close ();
        }
    } catch (Exception E) {
        System.out.println (E.getMessage ());
        E.printStackTrace ();
    }
    connectClose (Conn);
    Conn = null;
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            LOGGER.info ("found: " + person);
            for (Address address : person.getAddresses ()) {
                LOGGER.info ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=365=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nMultipleChoiceE1Id) {
    CoMultipleChoiceE1 coMultipleChoiceE1 = new CoMultipleChoiceE1DAO ().findById (nMultipleChoiceE1Id);
    if (coMultipleChoiceE1 == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("multipleChoice.search.notFound"));
    }
    else {
        List < CoMultipleChoiceE1 > list = new ArrayList < CoMultipleChoiceE1 > ();
        EntityManagerHelper.refresh (coMultipleChoiceE1);
        list.add (coMultipleChoiceE1);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public RestServiceResult listGroupForExercise (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises1);
    List < ToExercise1Group > list = new ArrayList < ToExercise1Group > ();
    Set < ToExercise1Group > set = coExercises1.getToExercise1Groups ();
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("exercise1group.search.notFound"));
    }
    else {
        list.addAll (set);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.search.success"), arrayParam));
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


-----Function Pair=366=-----==

public static ResultSet select (String database, String SQL) throws Exception {
    ResultSet Res = null;
    DBConnectionManager dbm = null;
    Connection bd = null;
    try {
        dbm = DBConnectionManager.getInstance ();
        bd = dbm.getConnection (database);
        Res = bd.createStatement ().executeQuery (SQL);
        dbm.freeConnection (database, bd);
    } catch (Exception e) {
        log.error ("SQL error: " + SQL, e);
        Exception excep;
        if (dbm == null) excep = new Exception ("Could not obtain pool object DbConnectionManager");
        else if (bd == null) excep = new Exception ("The Db connection pool could not obtain a database connection");
        else {
            excep = new Exception ("SQL Error : " + SQL + " error: " + e);
            dbm.freeConnection (database, bd);
        }
        throw excep;
    }
    return Res;
}


public RestServiceResult listGroupForExercise (RestServiceResult serviceResult, Long nExerciseId) {
    CoExercises1 coExercises1 = new CoExercises1DAO ().findById (nExerciseId);
    EntityManagerHelper.refresh (coExercises1);
    List < ToExercise1Group > list = new ArrayList < ToExercise1Group > ();
    Set < ToExercise1Group > set = coExercises1.getToExercise1Groups ();
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("exercise1group.search.notFound"));
    }
    else {
        list.addAll (set);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.search.success"), arrayParam));
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


-----Function Pair=367=-----==

public List < Usergroups > getUsergroupsList (List < Short > usergroupIdList) {
    Session session = null;
    Transaction tr = null;
    try {
        session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        List < Usergroups > list = new ArrayList < Usergroups > ();
        for (int i = 0; i < usergroupIdList.size (); i ++) {
            Usergroups userGroup = (Usergroups) session.get (Usergroups.class, usergroupIdList.get (i));
            if (userGroup != null) {
                list.add (userGroup);
            }
            else {
                try {
                    throw new Exception ("û�л���� usergroupId ƥ���Usergroupʵ��");
                } catch (Exception exception) {
                    exception.printStackTrace ();
                }
            }
        }
        tr.commit ();
        return list;
    } catch (Exception e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public List getLockList (String virtualWiki) throws Exception {
    List all = new ArrayList ();
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        PreparedStatement stmt = conn.prepareStatement (STATEMENT_GET_LOCK_LIST);
        stmt.setString (1, virtualWiki);
        ResultSet rs = stmt.executeQuery ();
        while (rs.next ()) {
            TopicLock lock = new TopicLock (rs.getString ("virtualWiki"), rs.getString ("topic"), rs.getTimestamp ("lockat"), rs.getString ("sessionkey"));
            all.add (lock);
        }
        rs.close ();
        stmt.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return all;
}


-----Function Pair=368=-----==

private void checkDupDoc (String typeOfDoc, Connection con) throws SQLException, Exception {
    String check = "SELECT * from " + typeOfDoc + " doc, courses c " + "WHERE doc.courseid = c.courseid AND " + "doc.admin = c.admin AND doc.title = ?";
    PreparedStatement prepStatement = con.prepareStatement (check);
    prepStatement.setString (1, this.getTitle ().trim ());
    ResultSet rs = prepStatement.executeQuery ();
    int resultsCounter = 0;
    while (rs.next ()) {
        resultsCounter ++;
    }
    prepStatement.close ();
    if (resultsCounter == 0) {
    }
    else {
        foundDupDocument = true;
        throw new Exception ();
    }
}


public void removeStadium (String name, String city) throws StadiumException {
    Connection conn = ConnectionManager.getManager ().getConnection ();
    int id = findStadiumBy_N_C (name, city);
    if (id == - 1) throw new StadiumException ("No such stadium");
    try {
        conn.setAutoCommit (false);
        PreparedStatement stm = conn.prepareStatement (Statements.SELECT_STAD_TRIBUNE);
        stm.setInt (1, id);
        ResultSet rs = stm.executeQuery ();
        TribuneLogic logic = TribuneLogic.getInstance ();
        while (rs.next ()) {
            logic.removeTribune (rs.getInt ("tribuneID"));
        }
        stm = conn.prepareStatement (Statements.DELETE_STADIUM);
        stm.setInt (1, id);
        stm.executeUpdate ();
    } catch (SQLException e) {
        try {
            conn.rollback ();
            conn.setAutoCommit (true);
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
        throw new StadiumException ("Removing stadium failed", e);
    }
    try {
        conn.commit ();
        conn.setAutoCommit (true);
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=369=-----==

public HashSet < Subject > findByTeachingUnit (int teachingUnitID) throws SelectException, DBConnectionException {
    HashSet < Subject > subjectSet = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to get statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("TEACHING_UNIT_ID", teachingUnitID);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            subjectSet = new HashSet < Subject > ();
            while (result.next ()) {
                Subject subject = new Subject ();
                subject.setName (result.getString ("SUBJECT_NAME"));
                subject.setDescription (result.getString ("SUBJECT_DESCRIPTION"));
                subject.setId (result.getInt ("SUBJECT_ID"));
                subject.setCoeff (result.getFloat ("SUBJECT_COEFFICIENT"));
                subject.setAlias (result.getString ("SUBJECT_ALIAS"));
                subject.setTeachingUnit (null);
                subjectSet.add (subject);
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return subjectSet;
}


public StringSet readUuidsForSynchronization (int maxUuids) throws SQLException {
    StringSet uuids = new StringSet ();
    PreparedStatement st = null;
    try {
        Connection con = returnConnection ().getJdbcConnection ();
        StringBuilder sbSql = new StringBuilder ();
        sbSql.append ("SELECT DOCUUID FROM ");
        sbSql.append (getResourceTableName ());
        sbSql.append (" WHERE ((APPROVALSTATUS = 'approved') OR (APPROVALSTATUS = 'reviewed'))");
        logExpression (sbSql.toString ());
        st = con.prepareStatement (sbSql.toString ());
        st.setMaxRows (maxUuids);
        ResultSet rs = st.executeQuery ();
        while (rs.next ()) {
            uuids.add (rs.getString (1));
        }
    } finally {
        closeStatement (st);
    }
    if (uuids.size () > 0) onRecordsSynchronized (uuids);
    return uuids;
}


-----Function Pair=370=-----==

public void cloneQuestion (long nQuestionOldId, long nQuestionNewId) {
    EntityManagerHelper.beginTransaction ();
    CoQuestion coQuestionOld = new CoQuestionDAO ().findById (nQuestionOldId);
    Set < OpenResponse3 > setOpenResponse = coQuestionOld.getOpenResponse3s ();
    log.info ("Ejercicio[" + nQuestionOldId + "] Cantidad de respuestas abiertas a clonar: " + setOpenResponse.size ());
    Query query = null;
    if (setOpenResponse.size () == 1) {
        CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionNewId);
        EntityManagerHelper.refresh (coQuestion);
        if (coQuestion != null) {
            if (coQuestion.getOpenResponse3s ().size () == 0) {
                query = EntityManagerHelper.createNativeQuery (Statements.CLONE_OPEN_RESPONSE3);
                query.setParameter (1, nQuestionNewId);
                query.setParameter (2, nQuestionOldId);
                int nUpdate = query.executeUpdate ();
                log.info ("\n\nClonaci�n OPEN-RESPONSE2-[" + nQuestionOldId + "] - NEWEXERCISES_1[" + nQuestionNewId + "]" + " - RESPONSE2  => " + nUpdate);
            }
            else {
                log.error ("El ejercicio2[" + nQuestionOldId + "] ya tiene clonado la respuesta abierta ");
            }
        }
        else {
            log.error ("El ejercicio2[" + nQuestionNewId + "] no existe...");
        }
    }
    else {
        log.error ("El ejercicio2[" + nQuestionOldId + "] tiene " + setOpenResponse.size () + " respuestas abiertas !!...");
    }
    query = EntityManagerHelper.createNativeQuery (Statements.CLONE_MULTIPLE_CHOISE_3);
    query.setParameter (1, nQuestionNewId);
    query.setParameter (2, nQuestionOldId);
    int nUpdate = query.executeUpdate ();
    log.info ("\n\nClonaci�n MULTIPLE_CHOICE_E3-Question[" + nQuestionOldId + "] - NEWQUESTION[" + nQuestionNewId + "]" + " - MultipleChoise " + nUpdate);
    query = EntityManagerHelper.createNativeQuery (Statements.CLONE_SINGLE_TEXT_TEACHER_3);
    query.setParameter (1, nQuestionNewId);
    query.setParameter (2, nQuestionOldId);
    nUpdate = query.executeUpdate ();
    log.info ("\n\nClonaci�n CO_SINGLE_TEXT_TEACHER3-Question[" + nQuestionOldId + "] - NEWQUESTION[" + nQuestionNewId + "]" + " - SINGLETEXTTEACHER " + nUpdate);
    query = EntityManagerHelper.createNativeQuery (Statements.CLONE_MATRIX_QUESTION);
    query.setParameter (1, nQuestionNewId);
    query.setParameter (2, nQuestionOldId);
    nUpdate = query.executeUpdate ();
    log.info ("\n\nClonaci�n CO_MATRIX_QUESTION-Question[" + nQuestionOldId + "] - NEWQUESTION[" + nQuestionNewId + "]" + " - MATRIX " + nUpdate);
    log.info ("\n\nCOMPLETE....");
    for (Iterator < CoCompleteE3 > iterator2 = coQuestionOld.getCoCompleteE3s ().iterator (); iterator2.hasNext ();) {
        CoCompleteE3 coCompleteE3Old = iterator2.next ();
        Long nCompleteE3Id = getSequence ("sq_co_complete_e3");
        query = EntityManagerHelper.createNativeQuery (Statements.CLONE_COMPLETE_E3);
        query.setParameter (1, nCompleteE3Id);
        query.setParameter (2, nQuestionNewId);
        query.setParameter (3, nQuestionOldId);
        nUpdate = query.executeUpdate ();
        log.info ("Clonaci�n co_complete_e3-Question[" + nQuestionOldId + "] - NEWQUESTION[" + nQuestionNewId + "]" + " - complete_e3 " + nUpdate);
        query = EntityManagerHelper.createNativeQuery (Statements.CLONE_WORDS_COMPLETE_E3);
        query.setParameter (1, nCompleteE3Id);
        query.setParameter (2, coCompleteE3Old.getCompleteE3Id ());
        nUpdate = query.executeUpdate ();
        log.info ("Clonaci�n CLONE_WORDS_COMPLETE_E3-Question[" + nCompleteE3Id + "] - NEW_COMPLETE_E3[" + coCompleteE3Old.getCompleteE3Id () + "]" + " - WORDS_COMPLETE_E3 " + nUpdate);
    }
    EntityManagerHelper.commit ();
}


public static Tab getTab (String usrlogin, String tabid) throws DbException {
    Tab tab = null;
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("tab_title");
        r.add ("display_type");
        r.add ("user_login", usrlogin);
        r.add ("tab_id", tabid);
        sql = r.getSQLSelect ("tab_template");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            String tab_title = rs.getString ("tab_title");
            String displaytype = rs.getString ("display_type");
            tab = new Tab (tabid, tab_title, displaytype);
        }
    } catch (SQLException sqlex) {
        throw new DbException (sqlex.getMessage () + " : " + sql);
    } finally {
        if (db != null) db.close ();
    }
    return tab;
}


-----Function Pair=371=-----==

public void atualizarImovel (final Imovel...imoveis) throws Exception {
    for (Imovel imovel : imoveis) {
        Session session = Hibernate.getSessionFactory ().getCurrentSession ();
        try {
            session.beginTransaction ();
            session.update (imovel);
            session.getTransaction ().commit ();
        } catch (HibernateException e) {
            if (session != null) {
                session.getTransaction ().rollback ();
            }
            throw new HibernateException ("HIBERNATE Erro no Atualizar Imovel: ", e);
        } catch (Exception e) {
            throw new Exception ("GERAL Erro no Atualizar Imovel: ", e);
        }
    }
}


public void insert () {
    DbRs rs = null;
    clearErr ();
    DbConn conn = new DbConn ();
    try {
        conn.setAutoCommit (false);
        String sql = "select * from sevgrade where sgid = ?";
        conn.prepare (sql);
        conn.setInt (1, getSgid ());
        rs = conn.executeQuery ();
        if (rs != null && rs.size () > 0) {
            setErr ("等级编号已经存在请重新输入");
            return;
        }
        sql = "insert into sevgrade(sgid,sgname)values(?,?)";
        conn.prepare (sql);
        conn.setInt (1, getSgid ());
        conn.setString (2, getSgname ());
        conn.executeUpdate ();
        conn.commit ();
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
        try {
            conn.rollback ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    } finally {
        conn.close ();
    }
}


-----Function Pair=372=-----==

private static void delete (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("DELETE FROM Address");
        query.executeUpdate ();
        query = session.createQuery ("DELETE FROM Person");
        query.executeUpdate ();
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


public boolean addSmilies (Smilies smilies) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.save (smilies);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=373=-----==

public LinkedList < Integer > getGameIDs () {
    String query = "Select gameID from game order by gameID";
    LinkedList < Integer > gList = new LinkedList < Integer > ();
    Connection conn = ConnectionManager.getManager ().getConnection ();
    try {
        Statement st = conn.createStatement ();
        ResultSet rs = st.executeQuery (query);
        while (rs.next ()) {
            gList.add (rs.getInt ("gameID"));
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return gList;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person1 = new Person ();
        person1.setFirstName ("Jesse");
        person1.setLastName ("James");
        Person person2 = new Person ();
        person2.setFirstName ("Brian");
        person2.setLastName ("Cox");
        Person person3 = new Person ();
        person3.setFirstName ("Anne");
        person3.setLastName ("Smith");
        person1.getSubordinates ().add (person2);
        person2.getSubordinates ().add (person3);
        entityManager.persist (person1);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=374=-----==

public static boolean insert (final Departamento ObjDepartamento) {
    int result = 0;
    final Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    if (c == null) {
        return false;
    }
    try {
        c.setAutoCommit (false);
        final String sql = "insert into departamento " + "(nome, sala, telefone, id_orgao)" + " values (?, ?, ?, ?)";
        pst = c.prepareStatement (sql);
        pst.setString (1, ObjDepartamento.getNome ());
        pst.setString (2, ObjDepartamento.getSala ());
        pst.setString (3, ObjDepartamento.getTelefone ());
        pst.setInt (4, (ObjDepartamento.getOrgao ()).getCodigo ());
        result = pst.executeUpdate ();
        c.commit ();
    } catch (final SQLException e) {
        try {
            c.rollback ();
        } catch (final SQLException e1) {
            e1.printStackTrace ();
        }
        System.out.println ("[DepartamentoDAO.insert] Erro ao inserir -> " + e.getMessage ());
    } finally {
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    if (result > 0) {
        return true;
    }
    else {
        return false;
    }
}


protected synchronized List getList () throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    List result = new ArrayList ();
    synchronized (dbConn) {
        try {
            sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD A ");
            sqlStat.append ("WHERE  A.RECORD_STATUS = ? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            this.setPrepareStatement (preStat, 1, GlobalConstant.RECORD_STATUS_ACTIVE);
            rs = preStat.executeQuery ();
            while (rs.next ()) {
                DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
                tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
                tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
                tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
                tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
                tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
                tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
                tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
                tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
                tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
                tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
                tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
                tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
                result.add (tmpDmsRelationalWord);
            }
            return (result);
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
        } finally {
            try {
                rs.close ();
            } catch (Exception ignore) {
            } finally {
                rs = null;
            }
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


-----Function Pair=375=-----==

public RestServiceResult listGroupForExercise (RestServiceResult serviceResult, Long nQuestionId) {
    CoQuestion coQuestion = new CoQuestionDAO ().findById (nQuestionId);
    EntityManagerHelper.refresh (coQuestion);
    List < ToQuestionGroup > list = new ArrayList < ToQuestionGroup > ();
    Set < ToQuestionGroup > set = coQuestion.getToQuestionGroups ();
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("questionGroup.search.notFound"));
    }
    else {
        list.addAll (set);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("questionGroup.search.success"), arrayParam));
    }
    serviceResult.setObjResult (list);
    return serviceResult;
}


public RestServiceResult percentMaterialForUser (RestServiceResult serviceResult, Long nUserId) {
    int nPercentMaterial = 0;
    try {
        log.info ("Obteniendo el total de materiales - Usuario: " + nUserId);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_PERCENT_MATERIAL);
        query.setParameter (1, nUserId);
        Vector vecResult = (Vector) query.getSingleResult ();
        log.info ("objResult => " + vecResult);
        if (vecResult.get (0) == null) {
            nPercentMaterial = 0;
        }
        else {
            nPercentMaterial = Integer.parseInt (vecResult.get (0).toString ());
        }
        EntityManagerHelper.commit ();
        Object [] arrayParam = {nPercentMaterial};
        log.info ("Total Porcentaje:" + nPercentMaterial + " %");
        serviceResult.setObjResult (nPercentMaterial);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("material.delete.success"), arrayParam));
    } catch (Exception e) {
        e.printStackTrace ();
        EntityManagerHelper.rollback ();
        log.error ("Error al calcular el poncentaje de material: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {nPercentMaterial};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("material.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=376=-----==

private static void insertConfigFiles (Connection con, File pfad) throws IOException, SQLException {
    File [] list = pfad.listFiles ();
    for (File file : list) {
        if (file.isFile ()) {
            String fileName = file.getName ();
            if (fileName.endsWith (".xml")) {
                StringBuilder builder = new StringBuilder ();
                BufferedReader bf = new BufferedReader (new FileReader (file));
                String line = bf.readLine ();
                while (line != null) {
                    builder.append (line);
                    line = bf.readLine ();
                    if (line != null) {
                        builder.append ("\n");
                    }
                }
                bf.close ();
                String fileOhneXml = fileName.substring (0, fileName.length () - 4);
                PreparedStatement q1 = con.prepareStatement ("delete from xmlconfiguration where key=?");
                q1.setString (1, fileOhneXml);
                q1.executeUpdate ();
                q1.close ();
                PreparedStatement q2 = con.prepareStatement ("Insert INTO xmlconfiguration (key,config) values (?,?)");
                q2.setString (1, fileOhneXml);
                q2.setString (2, builder.toString ());
                q2.executeUpdate ();
                q2.close ();
                con.commit ();
            }
        }
    }
}


public int transferOwnership (Publisher publisher, MmdQueryCriteria criteria, int localId) throws Exception {
    int nRows = 0;
    if (! publisher.getIsAdministrator ()) {
        throw new ImsServiceException ("TransferOwnershipRequest: not authorized.");
    }
    PreparedStatement st = null;
    try {
        ManagedConnection mc = returnConnection ();
        Connection con = mc.getJdbcConnection ();
        StringBuilder sbSql = new StringBuilder ();
        sbSql.append ("UPDATE ").append (getResourceTableName ()).append (" ");
        sbSql.append (" SET OWNER=? ");
        StringBuilder sbWhere = new StringBuilder ();
        Map < String, Object > args = criteria.appendWherePhrase (null, sbWhere, publisher);
        if (sbWhere.length () > 0) {
            sbSql.append (" WHERE ").append (sbWhere.toString ());
        }
        st = con.prepareStatement (sbSql.toString ());
        int n = 1;
        st.setInt (n ++, localId);
        criteria.applyArgs (st, n, args);
        logExpression (sbSql.toString ());
        nRows = st.executeUpdate ();
    } finally {
        closeStatement (st);
    }
    return nRows;
}


-----Function Pair=377=-----==

public Object execute (String query, int queryTimeOut, int type, int queryType, int autoGeneratedType, Object autoGenetatedValues) throws DException {
    try {
        Object parsedQuery = Parser.parseQuery (query);
        if (parsedQuery instanceof SQLdatastatement) {
            if (((String) getUserSession ().getTransactionAccessMode ()).equalsIgnoreCase ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            _StatementExecutionContext sec = getStatementExecutionContext ();
            sec.setAutoGeneratedInfo (autoGeneratedType, autoGenetatedValues);
            _Executer executer = (_Executer) ((SQLdatastatement) parsedQuery).run (sec);
            Object ob = executer.execute ((_VariableValues) null);
            saveModeHandler.write (saveModeSessionId, parsedQuery);
            return ob;
        }
        else {
            if (queryType == _Connection.EXECUTE) return execute (parsedQuery, queryTimeOut, type);
            else return executeUpdate (parsedQuery, queryTimeOut);
        }
    } catch (DException de) {
        throw de;
    } catch (RuntimeException de) {
        throw de;
    }
}


private int createDocType (String Name, String PrintName, String DocBaseType, String DocSubTypeSO, int C_DocTypeShipment_ID, int C_DocTypeInvoice_ID, int StartNo, int GL_Category_ID) {
    MSequence sequence = null;
    if (StartNo != 0) {
        sequence = new MSequence (m_ctx, getAD_Client_ID (), Name, StartNo, m_trx.getTrxName ());
        if (! sequence.save ()) {
            log.log (Level.SEVERE, "Sequence NOT created - " + Name);
            return 0;
        }
    }
    MDocType dt = new MDocType (m_ctx, DocBaseType, Name, m_trx.getTrxName ());
    if (PrintName != null && PrintName.length () > 0) dt.setPrintName (PrintName);
    if (DocSubTypeSO != null) dt.setDocSubTypeSO (DocSubTypeSO);
    if (C_DocTypeShipment_ID != 0) dt.setC_DocTypeShipment_ID (C_DocTypeShipment_ID);
    if (C_DocTypeInvoice_ID != 0) dt.setC_DocTypeInvoice_ID (C_DocTypeInvoice_ID);
    if (GL_Category_ID != 0) dt.setGL_Category_ID (GL_Category_ID);
    if (sequence == null) dt.setIsDocNoControlled (false);
    else {
        dt.setIsDocNoControlled (true);
        dt.setDocNoSequence_ID (sequence.getAD_Sequence_ID ());
    }
    dt.setIsSOTrx ();
    if (! dt.save ()) {
        log.log (Level.SEVERE, "DocType NOT created - " + Name);
        return 0;
    }
    return dt.getC_DocType_ID ();
}


-----Function Pair=378=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setSize (Length.create (6, LengthUnit.foot));
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=379=-----==

public void add (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            if (contains (name) == false) {
                String sql = "insert into AttributeCategories (CategoryName) " + "values ('" + name + "')";
                conn = FidoDataSource.getConnection ();
                stmt = conn.createStatement ();
                stmt.executeUpdate (sql);
            }
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public void elimina (Pedido pe) throws errorSQL, errorConexionBD {
    System.out.println ("GestorPedido.elimina()");
    int id = pe.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM pedido WHERE id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorPedido.elimina(): " + e);
    }
}


-----Function Pair=380=-----==

private Hashtable getApplicant (String id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        prepareRenderer (r, id);
        sql = r.getSQLSelect ("adm_applicant");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            return getApplicantData (rs);
        }
        else {
            return null;
        }
    } catch (DbException dbex) {
        throw dbex;
    } catch (SQLException sqlex) {
        throw sqlex;
    } finally {
        if (db != null) db.close ();
    }
}


private void oraclePrepUpdateNullClob (JDBCDataObject baseObject, String fieldName, DBConnection theConnection) throws DataException {
    try {
        String whereClause = JDBCUtil.getInstance ().buildWhereClause (baseObject, false);
        FastStringBuffer prepStatement = FastStringBuffer.getInstance ();
        String theSQL = null;
        try {
            prepStatement.append ("UPDATE ");
            prepStatement.append (baseObject.getJDBCMetaData ().getTargetTable ());
            prepStatement.append (" SET ");
            prepStatement.append (fieldName);
            prepStatement.append (" = null ");
            prepStatement.append (whereClause);
            theSQL = prepStatement.toString ();
        } finally {
            prepStatement.release ();
            prepStatement = null;
        }
        theConnection.createPreparedStatement (theSQL);
        finalizeUpdate (theConnection);
    } catch (DBException ex) {
        throw new DataException ("Error prepping CLOB update", ex);
    }
}


-----Function Pair=381=-----==

private void oraclePrepUpdateEmptyLob (JDBCDataObject baseObject, String fieldName, DBConnection theConnection) throws DataException {
    try {
        String whereClause = JDBCUtil.getInstance ().buildWhereClause (baseObject, false);
        FastStringBuffer prepStatement = FastStringBuffer.getInstance ();
        String theSQL = null;
        try {
            prepStatement.append ("UPDATE ");
            prepStatement.append (baseObject.getJDBCMetaData ().getTargetTable ());
            prepStatement.append (" SET ");
            prepStatement.append (fieldName);
            if (baseObject.getDataField (fieldName).getFieldMetaData ().isCharacterLongObjectType ()) {
                prepStatement.append (" = empty_clob() ");
            }
            else {
                prepStatement.append (" = empty_blob() ");
            }
            prepStatement.append (whereClause);
            theSQL = prepStatement.toString ();
        } finally {
            prepStatement.release ();
            prepStatement = null;
        }
        theConnection.createPreparedStatement (theSQL);
        finalizeUpdate (theConnection);
    } catch (DBException ex) {
        throw new DataException ("Error prepping LOB update", ex);
    }
}


public void store (Component component, String componentName, int currentPilot) {
    try {
        PreparedStatement psta = jdbc.prepareStatement ("UPDATE component_prop " + "SET size_height = ?, size_width = ?, pos_x = ?, pos_y = ? " + "WHERE pilot_id = ? " + "AND component_name = ?");
        psta.setInt (1, component.getHeight ());
        psta.setInt (2, component.getWidth ());
        Point point = component.getLocation ();
        psta.setInt (3, point.x);
        psta.setInt (4, point.y);
        psta.setInt (5, currentPilot);
        psta.setString (6, componentName);
        int update = psta.executeUpdate ();
        if (update == 0) {
            psta = jdbc.prepareStatement ("INSERT INTO component_prop " + "(size_height, size_width, pos_x, pos_y, pilot_id, component_name) " + "VALUES (?,?,?,?,?,?)");
            psta.setInt (1, component.getHeight ());
            psta.setInt (2, component.getWidth ());
            psta.setInt (3, point.x);
            psta.setInt (4, point.y);
            psta.setInt (5, currentPilot);
            psta.setString (6, componentName);
            psta.executeUpdate ();
        }
        jdbc.commit ();
    } catch (SQLException e) {
        jdbc.rollback ();
        log.debug (e);
    }
}


-----Function Pair=382=-----==

public Map < Integer, MoteDeploymentConfiguration > readMoteDeploymentConfigurations () throws AdaptationException {
    Map < Integer, MoteDeploymentConfiguration > moteDepConfigs = new HashMap < Integer, MoteDeploymentConfiguration > ();
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM MoteDeploymentConfigurations";
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        while (resultSet.next ()) {
            MoteDeploymentConfiguration moteDepConfiguration;
            moteDepConfiguration = getMoteDeploymentConfiguration (resultSet);
            moteDepConfigs.put (moteDepConfiguration.getID (), moteDepConfiguration);
        }
    } catch (SQLException ex) {
        String msg = "SQLException in readMoteDeploymentConfigurations";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return moteDepConfigs;
}


protected boolean isOwnAncestor (Context context) throws DataStoreException {
    boolean result = false;
    Integer category = context.getValueAsInteger (keyField);
    if (category != null) {
        int cat = category.intValue ();
        Connection db = null;
        PreparedStatement ps = null;
        try {
            db = context.getConnection ();
            ps = db.prepareStatement ("select parent from category where category = ?");
            while (cat != CATEGORYROOT) {
                ps.setInt (1, cat);
                ResultSet r = ps.executeQuery ();
                if (r.next ()) {
                    cat = r.getInt (1);
                }
                else {
                    throw new DataFormatException ("Serious: category ancestry is corrupt.");
                }
                if (cat == category.intValue ()) {
                    result = true;
                }
            }
        } catch (SQLException sex) {
            throw new DataStoreException ("Could not read category ancestry");
        } finally {
            try {
                if (db != null) {
                    context.releaseConnection (db);
                }
            } catch (Exception e1) {
            }
        }
    }
    return result;
}


-----Function Pair=383=-----==

public int transferOwnership (Publisher publisher, MmdQueryCriteria criteria, int localId) throws Exception {
    int nRows = 0;
    if (! publisher.getIsAdministrator ()) {
        throw new ImsServiceException ("TransferOwnershipRequest: not authorized.");
    }
    PreparedStatement st = null;
    try {
        ManagedConnection mc = returnConnection ();
        Connection con = mc.getJdbcConnection ();
        StringBuilder sbSql = new StringBuilder ();
        sbSql.append ("UPDATE ").append (getResourceTableName ()).append (" ");
        sbSql.append (" SET OWNER=? ");
        StringBuilder sbWhere = new StringBuilder ();
        Map < String, Object > args = criteria.appendWherePhrase (null, sbWhere, publisher);
        if (sbWhere.length () > 0) {
            sbSql.append (" WHERE ").append (sbWhere.toString ());
        }
        st = con.prepareStatement (sbSql.toString ());
        int n = 1;
        st.setInt (n ++, localId);
        criteria.applyArgs (st, n, args);
        logExpression (sbSql.toString ());
        nRows = st.executeUpdate ();
    } finally {
        closeStatement (st);
    }
    return nRows;
}


public User getUser (String userID) throws SQLException, IOException, ClassNotFoundException {
    Statement stmt = con.createStatement ();
    String dbUserID;
    String dbLastName;
    String dbFirstName;
    Password dbPswd;
    boolean isAdmin;
    byte [] buf = null;
    User user = null;
    ResultSet rs = stmt.executeQuery ("SELECT * FROM Users WHERE userID = '" + userID + "'");
    if (rs.next ()) {
        dbUserID = rs.getString ("userID");
        dbLastName = rs.getString ("lastName");
        dbFirstName = rs.getString ("firstName");
        buf = rs.getBytes ("pswd");
        dbPswd = (Password) deserializeObj (buf);
        isAdmin = rs.getBoolean ("admin");
        user = new User (dbUserID, dbFirstName, dbLastName, dbPswd, isAdmin);
    }
    rs.close ();
    stmt.close ();
    return user;
}


-----Function Pair=384=-----==

public boolean isCached (GetPropertyValues gpv) {
    if (gpv.sizeProperty () == 0) {
        return true;
    }
    Date from = null, till = null;
    boolean onlyNeedsOneValidPeriod = (gpv.ifAt () && gpv.getTime () == null) || (gpv.ifDuring () && gpv.getDuring ().getTill () == null) || (! gpv.ifAt () && ! gpv.ifDuring ());
    if (gpv.ifAt ()) {
        from = till = gpv.getTime ();
    }
    else if (gpv.ifDuring ()) {
        from = gpv.getDuring ().getFrom ();
        till = gpv.getDuring ().getTill ();
    }
    Connection conn = null;
    Iterable < Integer > props = representer.getInternalReps (gpv.getProperties ());
    try {
        conn = getConnection ();
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement ("SELECT COUNT(*) FROM cachedperiods WHERE " + "id = ? AND host = ? AND " + "prop IN (" + StringUtils.join (props.iterator (), ",") + ") AND " + "starttime < ? AND endtime > ? AND hasvalues >= ?");
            stmt.setString (1, gpv.getItem ().getResolved ().getId ());
            Integer hostIndex = representer.lookUpInternalRep (gpv.getItem ().getResolved ().getHost ());
            stmt.setInt (2, hostIndex);
            stmt.setLong (3, onlyNeedsOneValidPeriod ? Long.MAX_VALUE : from.getTime ());
            stmt.setLong (4, onlyNeedsOneValidPeriod ? 0 : till.getTime ());
            stmt.setInt (5, onlyNeedsOneValidPeriod ? 1 : 0);
            ResultSet rs = stmt.executeQuery ();
            return rs.next () && rs.getInt (1) > 0;
        } finally {
            StorageUtils.close (stmt);
        }
    } catch (SQLException ex) {
        Logger.getLogger (MetaDataStoragerImpl.class.getName ()).log (Level.SEVERE, "Cannot determine cache status, assuming not cached.", ex);
        return false;
    } finally {
        StorageUtils.close (conn);
    }
}


public Finance [] getFinances (int clubid) throws SQLException {
    Statement sm = cn.createStatement ();
    Finance [] finances;
    ResultSet rs = sm.executeQuery ("SELECT transaction_date, description, location, amount FROM Finance WHERE club_id=" + clubid + ";");
    if (rs.last ()) {
        finances = new Finance [rs.getRow ()];
        rs.first ();
        do {
            Finance f = new Finance ();
            f.date = rs.getDate ("transaction_date");
            f.description = rs.getString ("description");
            f.location = rs.getString ("location");
            f.amount = rs.getBigDecimal ("amount");
            finances [rs.getRow () - 1] = f;
        }
        while (rs.next ());
    }
    else {
        finances = new Finance [0];
    }
    return finances;
}


-----Function Pair=385=-----==

protected void doUpdate (Connection con) throws Exception {
    if (! isValidate ()) {
        throw new CesSystemException ("Organize_backup.doUpdate(): Illegal data values for update");
    }
    PreparedStatement ps = null;
    String strQuery = "UPDATE " + Common.ORGANIZE_BAK_RECORD_TABLE + " SET " + "version_no = ?, " + "operator = ?, " + "op_date = ?, " + "flag_op = ? " + "WHERE record_no = ?";
    try {
        ps = con.prepareStatement (strQuery);
        ps.setInt (1, this.versionNO);
        ps.setInt (2, this.operator.getUserID ());
        ps.setTimestamp (3, this.opDate);
        ps.setString (4, this.flagOp);
        ps.setInt (5, this.recordNO);
        int resultCount = ps.executeUpdate ();
        if (resultCount != 1) {
            throw new CesSystemException ("Organize_backup.doUpdate(): ERROR updating data in T_SYS_ORGANIZE_BAK_RECORD!! " + "resultCount = " + resultCount);
        }
    } catch (SQLException se) {
        throw new CesSystemException ("Organize_backup.doUpdate(): SQLException while updating Organize_backup; " + "record_no = " + this.recordNO + " :\n\t" + se);
    } finally {
        closePreparedStatement (ps);
    }
}


public List getDocumentsMetadata (long quakeID) {
    PreparedStatement stmt = null;
    ResultSet rs = null;
    List result = new ArrayList ();
    try {
        stmt = DB.prepare (DOCS_METADATA);
        stmt.setLong (1, quakeID);
        rs = stmt.executeQuery ();
        while (rs.next ()) {
            result.add (load (rs));
        }
        return result;
    } catch (SQLException e) {
        throw new SeismoException (e);
    } finally {
        DB.cleanUp (stmt, rs);
    }
}


-----Function Pair=386=-----==

public void configureSession (String dialect, String driver, String url, String username, String password, List < Class > classes) throws HibernateException {
    Properties props = new Properties ();
    props.setProperty ("hibernate.dialect", dialect);
    props.setProperty ("hibernate.connection.driver_class", driver);
    props.setProperty ("hibernate.connection.url", url);
    props.setProperty ("hibernate.connection.username", username);
    props.setProperty ("hibernate.connection.password", password);
    props.setProperty ("hibernate.query.substitutions", "true 1, false 0, yes 'Y', no 'N'");
    props.setProperty ("hibernate.connection.pool_size", "5");
    props.setProperty ("hibernate.show_sql", "false");
    props.setProperty ("hibernate.current_session_context_class", "thread");
    props.setProperty ("hibernate.jdbc.batch_size", "0");
    props.setProperty ("hibernate.jdbc.use_streams_for_binary", "true");
    props.setProperty ("hibernate.max_fetch_depth", "1");
    props.setProperty ("hibernate.cache.region_prefix", "hibernate.test");
    props.setProperty ("hibernate.cache.use_query_cache", "true");
    props.setProperty ("hibernate.cache.provider_class", "org.hibernate.cache.EhCacheProvider");
    configureSession (props, classes);
}


List getTableMetadata (String tableType) throws PXObjectStoreException {
    List getTableMetadata = null;
    try {
        Session aSession = this.createSession ();
        LOG.debug ("aSession: " + aSession);
        if (aSession != null) {
            Connection aConnection = aSession.connection ();
            if (aConnection != null) {
                DatabaseMetaData aMetaData = aConnection.getMetaData ();
                String [] someTableTypes = null;
                if (tableType != null) {
                    someTableTypes = new String [] {tableType};
                }
                ResultSet someTables = aMetaData.getTables (null, null, null, someTableTypes);
                getTableMetadata = PXSqlUtility.asDictionaries (someTables);
                LOG.debug ("getTableMetadata: " + getTableMetadata);
            }
            aSession.close ();
        }
    } catch (HibernateException e) {
        throw new PXObjectStoreException (e);
    } catch (SQLException e) {
        throw new PXObjectStoreException (e);
    }
    return getTableMetadata;
}


-----Function Pair=387=-----=1=

public MoteDeploymentConfiguration deleteMoteDeploymentConfiguration (int id) throws AdaptationException {
    MoteDeploymentConfiguration mdc = null;
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM MoteDeploymentConfigurations " + "WHERE id = " + id;
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        if (! resultSet.next ()) {
            String msg = "Unable to select config to delete.";
            log.error (msg);
            throw new AdaptationException (msg);
        }
        mdc = getMoteDeploymentConfiguration (resultSet);
        query = "DELETE FROM MoteDeploymentConfigurations " + "WHERE id = " + id;
        statement.executeUpdate (query);
        connection.commit ();
    } catch (SQLException ex) {
        try {
            connection.rollback ();
        } catch (Exception e) {
        }
        String msg = "SQLException in deleteMoteDeploymentConfiguration";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return mdc;
}


public static synchronized String getSequenceNumber (String SequenceName) {
    String result = "0";
    Connection conn = null;
    Statement ps = null;
    ResultSet rs = null;
    try {
        conn = TPCW_Database.getConnection ();
        conn.setAutoCommit (false);
        String sql = "select num from sequence where name='" + SequenceName + "'";
        ps = conn.createStatement (ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
        rs = ps.executeQuery (sql);
        long num = 0;
        while (rs.next ()) {
            num = rs.getLong (1);
            result = new Long (num).toString ();
        }
        num ++;
        sql = "update sequence set num=" + num + " where name='" + SequenceName + "'";
        int res = ps.executeUpdate (sql);
        if (res == 1) {
            conn.commit ();
        }
        else conn.rollback ();
    } catch (Exception e) {
        System.out.println ("Error Happens when trying to obtain the senquence number");
        e.printStackTrace ();
    } finally {
        try {
            if (conn != null) conn.close ();
            if (rs != null) rs.close ();
            if (ps != null) ps.close ();
        } catch (SQLException se) {
            se.printStackTrace ();
        }
    }
    return result;
}


-----Function Pair=388=-----==

public int deleteUnreferencedRecords (int maxValuesForIndex) throws SQLException, CatalogIndexException {
    StringSet uuids = new StringSet ();
    PreparedStatement st = null;
    int nRows = 0;
    try {
        StringBuilder sbSql = new StringBuilder ();
        sbSql.append ("SELECT DOCUUID FROM ").append (getResourceDataTableName ());
        sbSql.append (" WHERE DOCUUID NOT IN (SELECT DOCUUID FROM ");
        sbSql.append (getResourceTableName ()).append (")");
        logExpression (sbSql.toString ());
        Connection con = returnConnection ().getJdbcConnection ();
        st = con.prepareStatement (sbSql.toString ());
        st.setMaxRows (maxValuesForIndex);
        ResultSet rs = st.executeQuery ();
        while (rs.next ()) {
            uuids.add (rs.getString (1));
        }
    } finally {
        closeStatement (st);
        st = null;
    }
    StringSet fids = new StringSet ();
    if (cswRemoteRepository.isActive ()) {
        fids = queryFileIdentifiers (uuids);
    }
    try {
        if (uuids.size () > 0) {
            String sMsg = "Deleting " + uuids.size () + " unreferenced documents from table: " + getResourceDataTableName ();
            LogUtil.getLogger ().info (sMsg);
            StringBuilder sbSql = new StringBuilder ();
            sbSql.append ("DELETE FROM ").append (getResourceDataTableName ());
            sbSql.append (" WHERE DOCUUID IN (").append (uuidsToInClause (uuids)).append (")");
            logExpression (sbSql.toString ());
            Connection con = returnConnection ().getJdbcConnection ();
            st = con.prepareStatement (sbSql.toString ());
            nRows = st.executeUpdate ();
        }
    } finally {
        closeStatement (st);
    }
    if (uuids.size () > 0) {
        CatalogIndexAdapter indexAdapter = getCatalogIndexAdapter ();
        if (indexAdapter != null) {
            String sMsg = "Deleting " + uuids.size () + " unreferenced documents from the catalog index.";
            LogUtil.getLogger ().info (sMsg);
            indexAdapter.deleteDocuments (uuids.toArray (new String [0]));
            if (cswRemoteRepository.isActive ()) {
                if (fids.size () > 0) cswRemoteRepository.onRecordsDeleted (fids);
            }
        }
    }
    return nRows;
}


public int updateApprovalStatus (Publisher publisher, MmdQueryCriteria criteria, MmdEnums.ApprovalStatus approvalStatus) throws Exception {
    int nRows = 0;
    if (! publisher.getIsAdministrator ()) {
        throw new ImsServiceException ("UpdateApprovalStatusRequest: not authorized.");
    }
    PreparedStatement st = null;
    try {
        ManagedConnection mc = returnConnection ();
        Connection con = mc.getJdbcConnection ();
        StringBuilder sbSql = new StringBuilder ();
        sbSql.append ("UPDATE ").append (getResourceTableName ()).append (" ");
        sbSql.append (" SET APPROVALSTATUS=? ");
        StringBuilder sbWhere = new StringBuilder ();
        Map < String, Object > args = criteria.appendWherePhrase (null, sbWhere, publisher);
        if (sbWhere.length () > 0) {
            sbSql.append (" WHERE ").append (sbWhere.toString ());
        }
        st = con.prepareStatement (sbSql.toString ());
        int n = 1;
        st.setString (n ++, approvalStatus.name ());
        criteria.applyArgs (st, n, args);
        logExpression (sbSql.toString ());
        nRows = st.executeUpdate ();
    } finally {
        closeStatement (st);
    }
    return nRows;
}


-----Function Pair=389=-----==

public RestServiceResult update (RestServiceResult serviceResult, CoScoreExercises1 coScoreExercises1) {
    CoScoreExercises1DAO coScoreExercises1DAO = new CoScoreExercises1DAO ();
    try {
        log.info ("Actualizando la calificaci�n para el ejecicio1: " + coScoreExercises1.getScore ());
        EntityManagerHelper.beginTransaction ();
        coScoreExercises1DAO.update (coScoreExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coScoreExercises1);
        Object [] arrayParam = {coScoreExercises1.getMaUser ().getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.update.success"), arrayParam));
        log.info ("Se actualizo la calificaci�n con �xito para el usuario: " + coScoreExercises1.getMaUser ().getUserName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la t�cnica: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


public void testTransform () {
    final InteractionRelationDAO iaDAO = new InteractionRelationDAO ();
    Integer existingCollCount = null;
    try {
        existingCollCount = iaDAO.count (infoSpace, Collaboration.class);
    } catch (final CannotConnectToDatabaseException e1) {
        fail ("Persistence store is not available.");
    }
    if (existingCollCount != null && existingCollCount > 0) {
        Session s = null;
        Transaction tx = null;
        try {
            s = ModelManager.getInstance ().getCurrentSession ();
            tx = s.beginTransaction ();
            s.createSQLQuery ("DELETE FROM infospaceitem, interactionrelation" + "USING infospaceitem LEFT JOIN interactionrelation " + "ON interactionrelation.id = infospaceitem.id " + "WHERE infospaceitem.type LIKE '%Collaboration'").executeUpdate ();
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (final HibernateException he) {
            tx.rollback ();
            if (LOGGER.isErrorEnabled ()) {
                LOGGER.error ("Exception when attempting to remove all existing collaborations - transaction rolled back!", he);
            }
            fail ("Unable to remove existing Collaboration entities in persistence store before running method under test.");
        } catch (final CannotConnectToDatabaseException e) {
            fail ("Persistence store is not available.");
        } finally {
            s.close ();
        }
    }
    try {
        new CollaborationTransformer ().transform (this.infoSpace.getExtractorFQN (), this.infoSpace, new NullProgressMonitor ());
    } catch (final CannotConnectToDatabaseException e) {
        fail ("Persistence store is not available.");
    }
    try {
        existingCollCount = iaDAO.count (infoSpace, Collaboration.class);
    } catch (final CannotConnectToDatabaseException e1) {
        fail ("Persistence store is not available.");
    }
    if (existingCollCount == null || existingCollCount == 0) {
        fail ("Persistence store does not contain any Collaboration entities after running the method under test. This might not actually be wrong but is unexpected.");
    }
}


-----Function Pair=390=-----==

public static void setAuditRecord (String messageid, String message) throws Exception {
    log.debug ("Adding audit  message");
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Audit auditTable = new Audit ();
    auditTable.setMessageid (messageid);
    auditTable.setAction (message);
    try {
        session.saveOrUpdate (auditTable);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception (e);
    }
    return;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        Address address1 = new Address ();
        address1.setStreet ("Main Road 12");
        address1.setCity ("Oakwood");
        address1.setPerson (person);
        person.getAddresses ().add (address1);
        Address address2 = new Address ();
        address2.setStreet ("Sunshine Boulevard 211");
        address2.setCity ("Austin");
        address2.setPerson (person);
        person.getAddresses ().add (address2);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=391=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update and query with jpa ***");
        updateandquerywithjpa (entityManagerFactory);
        System.out.println ("*** update and query with native criteria api ***");
        updateandquerywithcriteria (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update and query with jpa ***");
        updateandquerywithjpa (entityManagerFactory);
        System.out.println ("*** update and query with native criteria api ***");
        updateandquerywithcriteria (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=392=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public TxDecorator getTxDecorator (long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from TxDecorator R where R.txId=?";
        Query q = s.createQuery (query);
        q.setLong (0, txId);
        return (TxDecorator) q.uniqueResult ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=393=-----==

public List < Transaction > getChildTransactions (long uid, long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Transaction R where R.initiatorId=? and R.parentTxId=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setLong (1, txId);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public Threadsmod findByThreadsBytidTop1 (int tid) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Threadsmod as m where m.id.tid=? order by m.id.dateline desc");
        query.setParameter (0, tid);
        query.setMaxResults (1);
        List < Threadsmod > modlist = query.list ();
        tr.commit ();
        if (modlist != null && modlist.size () > 0) {
            return modlist.get (0);
        }
    } catch (HibernateException e) {
        if (tr != null) tr.rollback ();
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=394=-----==

public int getMessageCount (Board board) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps;
    if (board == null) {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM UNSENDMESSAGES");
    }
    else {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM UNSENDMESSAGES WHERE board=?");
        ps.setInt (1, board.getPrimaryKey ().intValue ());
    }
    int count = 0;
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        count = rs.getInt (1);
    }
    rs.close ();
    ps.close ();
    return count;
}


public Department findByName (String name) throws DBConnectionException, SelectException {
    Department dpt = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("DEPARTMENT_NAME", name);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (DepartmentDAO.TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                dpt = new Department (result.getString ("DEPARTMENT_NAME"), result.getString ("DEPARTMENT_DESCRIPTION"), result.getString ("DEPARTMENT_ACRONYM"), null);
                dpt.setId (result.getInt ("DEPARTMENT_ID"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return dpt;
}


-----Function Pair=395=-----==

public Component getComponent (Integer componentId) {
    try {
        Component component = null;
        ResultSet resultSet = executeQuery (GET_COMPONENT_BY_ID, componentId);
        if (resultSet.next ()) {
            component = getOrCreateComponent (resultSet);
        }
        resultSet.close ();
        resultSet.getStatement ().close ();
        return component;
    } catch (SQLException e) {
        ProblemManager.reportException (e);
        return null;
    }
}


private String GenerateUserID (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        pstmt = conn.prepareStatement ("select seq_user.nextval userid from dual");
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            return rs.getString ("userid");
        }
        return null;
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
    return null;
}


-----Function Pair=396=-----==

public List getCollectionBitstreams (int collectionId) {
    List ids = new ArrayList ();
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        conn = DatabaseManager.getConnection ();
        ps = conn.prepareStatement (COLLECTION_BITSTREAMS);
        ps.setInt (1, collectionId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            ids.add (new Integer (rs.getInt (1)));
        }
    } catch (SQLException e) {
        LOG.error ("get item bitstreams " + e.getMessage (), e);
        throw new RuntimeException ("get item bitstreams. " + e.getMessage (), e);
    } finally {
        cleanup (ps, conn, rs);
    }
    return ids;
}


public Map < String, Usuario > getUsers () {
    Map < String, Usuario > usuarios = new HashMap < String, Usuario > ();
    Connection conexion = null;
    PreparedStatement select = null;
    ResultSet rs = null;
    try {
        conexion = pool.getConnection ();
        select = conexion.prepareStatement ("SELECT* FROM " + nameBD + ".Usuarios");
        rs = select.executeQuery ();
        while (rs.next ()) {
            Usuario user = new Usuario (rs.getString ("Nombre"), rs.getString ("Direccion"), rs.getString ("Email"), rs.getString ("Pass"), rs.getString ("Permisos").charAt (0));
            usuarios.put (user.getMail (), user);
        }
        if (usuarios.size () <= 0) {
            usuarios = null;
        }
    } catch (SQLException ex) {
        logger.log (Level.SEVERE, "Error obteniendo los usuarios", ex);
        usuarios = null;
    } finally {
        cerrarConexionYStatement (conexion, select);
        cerrarResultSet (rs);
    }
    return usuarios;
}


-----Function Pair=397=-----==

public List getCollectionBitstreams (int collectionId) {
    List ids = new ArrayList ();
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        conn = DatabaseManager.getConnection ();
        ps = conn.prepareStatement (COLLECTION_BITSTREAMS);
        ps.setInt (1, collectionId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            ids.add (new Integer (rs.getInt (1)));
        }
    } catch (SQLException e) {
        LOG.error ("get item bitstreams " + e.getMessage (), e);
        throw new RuntimeException ("get item bitstreams. " + e.getMessage (), e);
    } finally {
        cleanup (ps, conn, rs);
    }
    return ids;
}


public List < Outwuliao > findallout () {
    List < Outwuliao > ls = new ArrayList < Outwuliao > ();
    Connection conn = null;
    PreparedStatement pm = null;
    ResultSet rs = null;
    try {
        conn = Pool.getConnection ();
        pm = conn.prepareStatement ("select * from delwuliao");
        rs = pm.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                Outwuliao ow = setproperty (rs);
                ls.add (ow);
            }
        }
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } catch (Exception e) {
        e.printStackTrace ();
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    } finally {
        Pool.close (rs);
        Pool.close (pm);
        Pool.close (conn);
    }
    return ls;
}


-----Function Pair=398=-----==

public void deletarLocador (final Locador...locadors) throws Exception {
    for (Locador locador : locadors) {
        Session session = Hibernate.getSessionFactory ().getCurrentSession ();
        try {
            session.beginTransaction ();
            String sqlDeletaLocador = "DELETE FROM locadorimovelpk WHERE codLocador = :id ;";
            SQLQuery createSQLQuery = session.createSQLQuery (sqlDeletaLocador);
            createSQLQuery.setInteger ("id", locador.getCodLocador ());
            System.out.println (createSQLQuery.executeUpdate ());
            session.delete (locador);
            session.getTransaction ().commit ();
        } catch (HibernateException e) {
            if (session != null) {
                session.getTransaction ().rollback ();
            }
            throw new HibernateException ("HIBERNATE Erro no Deletar Locador: ", e);
        } catch (Exception e) {
            throw new Exception ("GERAL Erro no Deletar Locador: ", e);
        }
    }
}


public static String getCategoryName (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.categoryName from AccountCategory R where R.categoryId=(select A.categoryId from Account A where A.accountId=?)";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        String aname = (String) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=399=-----==

public static AddressFilterData loadFromDB () {
    Session session = DB.createSession ();
    synchronized (session) {
        Transaction tx = session.beginTransaction ();
        AddressFilterData data;
        try {
            Criteria criteria = session.createCriteria (AddressFilterData.class);
            data = (AddressFilterData) criteria.uniqueResult ();
            if (data == null) {
                data = new AddressFilterData ();
                session.save (data);
            }
            tx.commit ();
            data.setSession (session);
            return data;
        } catch (HibernateException e) {
            log.warn ("Exception in loadFromDB: ", e);
            tx.rollback ();
            throw (e);
        }
    }
}


public void testNotBetweenQuery () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 NOT BETWEEN 1 AND 3").getResultList ();
        assertEquals (0, result.size ());
        result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 NOT BETWEEN 3 AND 4").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=400=-----==

public void testConnection0038 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0038 (" + " keyField char(255)     not null, " + " descField varchar(255)  not null) ");
    int count = stmt.executeUpdate ("insert into #t0038 values ('value', 'test')");
    assertEquals (count, 1);
    con.setTransactionIsolation (Connection.TRANSACTION_READ_UNCOMMITTED);
    con.setAutoCommit (false);
    PreparedStatement ps = con.prepareStatement ("update #t0038 set descField=descField where keyField=?");
    ps.setString (1, "value");
    ps.executeUpdate ();
    ps.close ();
    con.commit ();
    ResultSet resultSet = stmt.executeQuery ("select descField from #t0038 where keyField='value'");
    assertTrue (resultSet.next ());
    stmt.close ();
}


public void testLikeQuery () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p);
        em.flush ();
        List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T WHERE firstName like '%Fred%'").getResultList ();
        assertEquals (1, result.size ());
        result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T WHERE T.firstName like '%Fred%'").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


