Found 8/400 pairs as clones in the BCB
-----Function Pair=1=-----==

protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    Composite model = createInitialModel ();
    attachModelToResource (model, modelResource);
    Diagram diagram = ViewService.createDiagram (model, CompositeEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        modelResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
        diagramResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    org.germinus.telcoblocks.RED model = createInitialModel ();
    attachModelToResource (model, diagramResource);
    Diagram diagram = ViewService.createDiagram (model, REDEditPart.MODEL_ID, TelcoblocksInfraestructurasDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
    }
    try {
        diagramResource.save (org.germinus.telcoblocks.infraestructuras.diagram.part.TelcoblocksDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        TelcoblocksInfraestructurasDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


-----Function Pair=2=-----==

protected void performSaveAs (IProgressMonitor progressMonitor) {
    Shell shell = getSite ().getShell ();
    IEditorInput input = getEditorInput ();
    SaveAsDialog dialog = new SaveAsDialog (shell);
    IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile () : null;
    if (original != null) {
        dialog.setOriginalFile (original);
    }
    dialog.create ();
    IDocumentProvider provider = getDocumentProvider ();
    if (provider == null) {
        return;
    }
    if (provider.isDeleted (input) && original != null) {
        String message = NLS.bind (Messages.BmmDiagramEditor_SavingDeletedFile, original.getName ());
        dialog.setErrorMessage (null);
        dialog.setMessage (message, IMessageProvider.WARNING);
    }
    if (dialog.open () == Window.CANCEL) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IPath filePath = dialog.getResult ();
    if (filePath == null) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace ().getRoot ();
    IFile file = workspaceRoot.getFile (filePath);
    final IEditorInput newInput = new FileEditorInput (file);
    IEditorMatchingStrategy matchingStrategy = getEditorDescriptor ().getEditorMatchingStrategy ();
    IEditorReference [] editorRefs = PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getActivePage ().getEditorReferences ();
    for (int i = 0; i < editorRefs.length; i ++) {
        if (matchingStrategy.matches (editorRefs [i], newInput)) {
            MessageDialog.openWarning (shell, Messages.BmmDiagramEditor_SaveAsErrorTitle, Messages.BmmDiagramEditor_SaveAsErrorMessage);
            return;
        }
    }
    boolean success = false;
    try {
        provider.aboutToChange (newInput);
        getDocumentProvider (newInput).saveDocument (progressMonitor, newInput, getDocumentProvider ().getDocument (getEditorInput ()), true);
        success = true;
    } catch (CoreException x) {
        IStatus status = x.getStatus ();
        if (status == null || status.getSeverity () != IStatus.CANCEL) {
            ErrorDialog.openError (shell, Messages.BmmDiagramEditor_SaveErrorTitle, Messages.BmmDiagramEditor_SaveErrorMessage, x.getStatus ());
        }
    } finally {
        provider.changed (newInput);
        if (success) {
            setInput (newInput);
        }
    }
    if (progressMonitor != null) {
        progressMonitor.setCanceled (! success);
    }
}


protected void performSaveAs (IProgressMonitor progressMonitor) {
    Shell shell = getSite ().getShell ();
    IEditorInput input = getEditorInput ();
    SaveAsDialog dialog = new SaveAsDialog (shell);
    IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile () : null;
    if (original != null) {
        dialog.setOriginalFile (original);
    }
    dialog.create ();
    IDocumentProvider provider = getDocumentProvider ();
    if (provider == null) {
        return;
    }
    if (provider.isDeleted (input) && original != null) {
        String message = NLS.bind (Messages.PetriDiagramEditor_SavingDeletedFile, original.getName ());
        dialog.setErrorMessage (null);
        dialog.setMessage (message, IMessageProvider.WARNING);
    }
    if (dialog.open () == Window.CANCEL) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IPath filePath = dialog.getResult ();
    if (filePath == null) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace ().getRoot ();
    IFile file = workspaceRoot.getFile (filePath);
    final IEditorInput newInput = new FileEditorInput (file);
    IEditorMatchingStrategy matchingStrategy = getEditorDescriptor ().getEditorMatchingStrategy ();
    IEditorReference [] editorRefs = PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getActivePage ().getEditorReferences ();
    for (int i = 0; i < editorRefs.length; i ++) {
        if (matchingStrategy.matches (editorRefs [i], newInput)) {
            MessageDialog.openWarning (shell, Messages.PetriDiagramEditor_SaveAsErrorTitle, Messages.PetriDiagramEditor_SaveAsErrorMessage);
            return;
        }
    }
    boolean success = false;
    try {
        provider.aboutToChange (newInput);
        getDocumentProvider (newInput).saveDocument (progressMonitor, newInput, getDocumentProvider ().getDocument (getEditorInput ()), true);
        success = true;
    } catch (CoreException x) {
        IStatus status = x.getStatus ();
        if (status == null || status.getSeverity () != IStatus.CANCEL) {
            ErrorDialog.openError (shell, Messages.PetriDiagramEditor_SaveErrorTitle, Messages.PetriDiagramEditor_SaveErrorMessage, x.getStatus ());
        }
    } finally {
        provider.changed (newInput);
        if (success) {
            setInput (newInput);
        }
    }
    if (progressMonitor != null) {
        progressMonitor.setCanceled (! success);
    }
}


-----Function Pair=3=-----==

public static IMarker addMarker (IFile file, String elementId, String location, String message, int statusSeverity) {
    IMarker marker = null;
    try {
        marker = file.createMarker (MARKER_TYPE);
        marker.setAttribute (IMarker.MESSAGE, message);
        marker.setAttribute (IMarker.LOCATION, location);
        marker.setAttribute (org.eclipse.gmf.runtime.common.ui.resources.IMarker.ELEMENT_ID, elementId);
        int markerSeverity = IMarker.SEVERITY_INFO;
        if (statusSeverity == IStatus.WARNING) {
            markerSeverity = IMarker.SEVERITY_WARNING;
        }
        else if (statusSeverity == IStatus.ERROR || statusSeverity == IStatus.CANCEL) {
            markerSeverity = IMarker.SEVERITY_ERROR;
        }
        marker.setAttribute (IMarker.SEVERITY, markerSeverity);
    } catch (CoreException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Failed to create validation marker", e);
    }
    return marker;
}


public Iterable < Iterable < IAction > > buildToolbar (GraphicalViewer graphicalViewer) {
    ArrayList < Iterable < IAction > > toolbar = new ArrayList < Iterable < IAction > > ();
    ArrayList < IAction > navigateActions = new ArrayList < IAction > ();
    navigateActions.add (new RefreshAction (myRefreshPerformer));
    navigateActions.add (new ExpandAction (myModelProvider));
    navigateActions.add (new CollapseAction (myModelProvider));
    toolbar.add (navigateActions);
    ArrayList < IAction > zoomActions = new ArrayList < IAction > ();
    zoomActions.add (new ZoomInAction (editorContext.getElementEditor (), graphicalViewer));
    zoomActions.add (new ZoomOutAction (editorContext.getElementEditor (), graphicalViewer));
    zoomActions.add (new ZoomFitAction (editorContext.getElementEditor (), graphicalViewer));
    zoomActions.add (new ZoomOriginalAction (editorContext.getElementEditor (), graphicalViewer));
    toolbar.add (zoomActions);
    ArrayList < IAction > filterActions = new ArrayList < IAction > ();
    filterActions.add (new FilterAction (editorContext.getElementEditor (), FILTER_ITEMS));
    toolbar.add (filterActions);
    ArrayList < IAction > printActions = new ArrayList < IAction > ();
    printActions.add (new PrintAction (editorContext.getElementEditor (), graphicalViewer));
    toolbar.add (printActions);
    return toolbar;
}


-----Function Pair=4=-----==

protected String doCopy () throws Exception {
    String result = super.doCopy ();
    for (Object o : getEObjects ()) {
        if (o instanceof Node && ((Node) o).eContainer () instanceof DiagramImpl) {
            DiagramImpl diag = (DiagramImpl) ((Node) o).eContainer ();
            IEditorPart editor = AsteriskDiagramEditorPlugin.getInstance ().getWorkbench ().getActiveWorkbenchWindow ().getActivePage ().getActiveEditor ();
            if (editor instanceof AsteriskDiagramEditor) {
                AsteriskDiagramEditor asteriskDiagramEditor = (AsteriskDiagramEditor) editor;
                HandlerEditPart part = (HandlerEditPart) asteriskDiagramEditor.getDiagramGraphicalViewer ().getContents ();
                asteriskDiagramEditor.getDiagramGraphicalViewer ().select (part);
                break;
            }
        }
    }
    return result;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=5=-----==

public void doSave (IProgressMonitor monitor) {
    RootModel model = (RootModel) getGraphicalViewer ().getContents ().getModel ();
    IFile file = ((IFileEditorInput) getEditorInput ()).getFile ();
    if (DBPlugin.getDefault ().getPreferenceStore ().getBoolean (DBPlugin.PREF_VALIDATE_ON_SAVE)) {
        try {
            file.deleteMarkers (IMarker.PROBLEM, false, 0);
            DiagramErrors errors = new DiagramValidator (model).doValidate ();
            for (DiagramError error : errors.getErrors ()) {
                error.addMarker (file);
            }
        } catch (CoreException ex) {
            DBPlugin.logException (ex);
        }
    }
    try {
        needViewerRefreshFlag = false;
        file.setContents (VisualDBSerializer.serialize (model), true, true, monitor);
    } catch (Exception ex) {
        DBPlugin.logException (ex);
        throw new RuntimeException (ex);
    }
    getCommandStack ().markSaveLocation ();
}


protected PaletteRoot getPaletteRoot () {
    PaletteRoot root = new PaletteRoot ();
    UMLPlugin plugin = UMLPlugin.getDefault ();
    PaletteGroup tools = new PaletteGroup (plugin.getResourceString ("palette.tool"));
    ToolEntry tool = new SelectionToolEntry ();
    tools.add (tool);
    root.setDefaultEntry (tool);
    tool = new MarqueeToolEntry ();
    tools.add (tool);
    PaletteDrawer common = new PaletteDrawer (plugin.getResourceString ("palette.common"));
    common.add (createEntityEntry (plugin.getResourceString ("palette.common.note"), NoteModel.class, "icons/note.gif"));
    common.add (createConnectionEntry (plugin.getResourceString ("palette.common.anchor"), AnchorModel.class, "icons/anchor.gif"));
    PaletteDrawer entities = new PaletteDrawer (plugin.getResourceString ("palette.entity"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.action"), ActionModel.class, "icons/usecase.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.object"), ObjectModel.class, "icons/icon_object.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.initialState"), InitialStateModel.class, "icons/icon_init_state.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.finalState"), FinalStateModel.class, "icons/icon_final_state.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.decision"), DecisionModel.class, "icons/icon_decision.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.fork"), ForkNodeModel.class, "icons/icon_fork.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.join"), JoinNodeModel.class, "icons/icon_join.gif"));
    entities.add (createEntityEntry (plugin.getResourceString ("palette.activity.v_partition"), VerticalPartitionModel.class, "icons/partition_v.gif"));
    PaletteDrawer relations = new PaletteDrawer (plugin.getResourceString ("palette.relation"));
    relations.add (createConnectionEntry (plugin.getResourceString ("palette.activity.flow"), FlowModel.class, "icons/flow.gif"));
    root.add (tools);
    root.add (common);
    root.add (entities);
    root.add (relations);
    return root;
}


-----Function Pair=6=-----==

public static Resource createDiagram (URI diagramURI, final OwlsInitializerFacade facade, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.OwlsDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.OwlsDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            OwlsCompositeProcess model = createInitialModel (facade);
            attachModelToResource (model, diagramResource);
            Diagram diagram = ViewService.createDiagram (model, OwlsCompositeProcessEditPart.MODEL_ID, OwlsDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                diagramResource.save (owls.diagram.part.OwlsDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                OwlsDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        OwlsDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public void init (IHeightMatrix matrix, Vector < IBestMatch > bmList, ArrayList < Integer > clusterInfo, Vector < Vector < Integer > > clusterSurface) {
    this.clusterSurface = clusterSurface;
    this.colorMapChooser.setColorMap ("earthcolor");
    colors.add (Color.BLACK);
    colors.add (Color.BLUE);
    colors.add (Color.CYAN);
    colors.add (Color.GREEN);
    colors.add (Color.MAGENTA);
    colors.add (Color.ORANGE);
    colors.add (Color.PINK);
    colors.add (Color.RED);
    colors.add (Color.YELLOW);
    colors.add (Color.GRAY);
    this.bmList = (Vector < IBestMatch >) bmList.clone ();
    if (clusterInfo != null) {
        this.clusterInfo = clusterInfo;
        System.out.println ("UMatrix2D: Clusterinfo contains " + this.clusterInfo.size () + " Elements.");
    }
    else {
        this.clusterInfo = new ArrayList < Integer > ();
        for (int i = 0; i < bmList.size (); i ++) {
            this.clusterInfo.add (0);
        }
    }
    this.matrix = matrix;
    this.matrixMax = HeightMatrixUtils.getMax (this.matrix).floatValue ();
    this.setContourSteps (this.contourSteps);
    buildImage ();
}


-----Function Pair=7=-----==

public static Resource showDiagram (URI diagramURI, final Graph graph) throws PartInitException, IOException {
    if (graph == null || graph.getNodes () == null || graph.getNodes ().length == 0) return null;
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.CallGraphDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            Graph model = graph;
            attachModelToResource (model, diagramResource);
            Diagram diagram = ViewService.createDiagram (model, GraphEditPart.MODEL_ID, CallGraphDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
                CallGraphDiagramRegistry.getInstance ().addGraph (diagram, model);
            }
            try {
                diagramResource.save (it.unisannio.rcost.callgraphanalyzer.diagram.part.CallGraphDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                CallGraphDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, null, null);
        setCharset (WorkspaceSynchronizer.getFile (diagramResource));
        if (diagramResource == null) {
            System.out.println ("Errore nella creazione del documento");
        }
        else if (! openDiagram (diagramResource)) System.out.println ("Errore nell'apertura del documento");
        else return diagramResource;
    } catch (ExecutionException e) {
        CallGraphDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
        e.printStackTrace ();
        return null;
    }
    return diagramResource;
}


protected void doGotoMarker (IMarker marker) {
    String elementId = marker.getAttribute (org.eclipse.gmf.runtime.common.core.resources.IMarker.ELEMENT_ID, null);
    if (elementId == null || ! (getEditor () instanceof DiagramEditor)) {
        return;
    }
    DiagramEditor editor = (DiagramEditor) getEditor ();
    Map editPartRegistry = editor.getDiagramGraphicalViewer ().getEditPartRegistry ();
    EObject targetView = editor.getDiagram ().eResource ().getEObject (elementId);
    if (targetView == null) {
        return;
    }
    EditPart targetEditPart = (EditPart) editPartRegistry.get (targetView);
    if (targetEditPart != null) {
        se.mdh.mrtc.save.taEditor.diagram.part.TaEditorDiagramEditorUtil.selectElementsInDiagram (editor, Arrays.asList (new EditPart [] {targetEditPart}));
    }
}


-----Function Pair=8=-----==

public Object [] getParams (Object [] params, int ind, boolean [] disintegrate, boolean [] canHaveNulls) {
    if (! validateParams (params, ind, disintegrate, canHaveNulls)) return null;
    Vector v = new Vector ();
    for (int i = ind; i < params.length && getLastArgInd (i - ind) < cArgTypes.length; i ++) {
        if (disintegrate [getLastArgInd (i - ind)]) {
            if (params [i] != null && Vector.class.isInstance (params [i])) {
                Vector cv = (Vector) params [i];
                if (cv.size () > 0) v.add (cv.elementAt (0));
                else v.add (null);
            }
            else {
                v.add (params [i]);
            }
        }
        else v.add (params [i]);
    }
    return v.size () > 0 ? v.toArray () : new Object [0];
}


public SSLSocketChannel acceptConnection (String cmd) throws IOException {
    ServerSocketChannel ssc = ServerSocketChannel.open ();
    InetSocketAddress isa = new InetSocketAddress (localAddress, 0);
    InetAddress i;
    int port;
    SSLSocketChannel sc = null;
    if (proxy) {
        sc = wlFxp.proxyBind (isa);
        i = wlFxp.getProxyInetAddress ();
        port = wlFxp.getProxyBindPort ();
    }
    else {
        ssc.socket ().bind (isa);
        i = ssc.socket ().getInetAddress ();
        port = ssc.socket ().getLocalPort ();
    }
    port (i, port);
    if (rest > 0) {
        if (doCmd ("REST " + rest) > 3) {
            rest = 0;
        }
    }
    if (doCmd (cmd) > 3) {
        return null;
    }
    if (! proxy) {
        sc = new SSLSocketChannel (ssc.accept ());
        while (! sc.finishConnect () && ! abortConnect) {
            try {
                Thread.sleep (20);
            } catch (InterruptedException e) {
            }
        }
    }
    sc.socket ().setReceiveBufferSize (65536);
    sc.socket ().setSendBufferSize (65536);
    return sc;
}


-----Function Pair=9=-----==

private static void sendPacket (ECBClass sendecb) {
    byte [] outbuffer = new byte [IPXBUFFERSIZE];
    fragmentDescriptor tmpFrag = new fragmentDescriptor ();
    int i, fragCount, t;
    int packetsize;
    int result;
    sendecb.setInUseFlag (USEFLAG_AVAILABLE);
    packetsize = 0;
    fragCount = sendecb.getFragCount ();
    for (i = 0; i < fragCount; i ++) {
        sendecb.getFragDesc (i, tmpFrag);
        if (i == 0) {
            for (int m = 0; m < 4; m ++) {
                Memory.real_writeb (tmpFrag.segment, tmpFrag.offset + m + 18, localIpxAddr.netnum [m]);
            }
            for (int m = 0; m < 6; m ++) {
                Memory.real_writeb (tmpFrag.segment, tmpFrag.offset + m + 22, localIpxAddr.netnode [m]);
            }
            Memory.real_writew (tmpFrag.segment, tmpFrag.offset + 28, swapByte (sendecb.getSocket ()));
            Memory.real_writew (tmpFrag.segment, tmpFrag.offset, 0xffff);
        }
        for (t = 0; t < tmpFrag.size; t ++) {
            outbuffer [packetsize] = (byte) Memory.real_readb (tmpFrag.segment, tmpFrag.offset + t);
            packetsize ++;
            if (packetsize >= IPXBUFFERSIZE) {
                Log.log_msg ("IPX: Packet size to be sent greater than " + IPXBUFFERSIZE + " bytes.");
                sendecb.setCompletionFlag (COMP_UNDELIVERABLE);
                sendecb.NotifyESR ();
                return;
            }
        }
    }
    outbuffer [3] = (byte) (packetsize & 0xFF);
    outbuffer [2] = (byte) ((packetsize>> 8) & 0xFF);
    sendecb.getFragDesc (0, tmpFrag);
    Memory.real_writew (tmpFrag.segment, tmpFrag.offset + 2, swapByte (packetsize));
    byte [] immedAddr = new byte [6];
    sendecb.getImmAddress (immedAddr);
    boolean islocalbroadcast = true;
    boolean isloopback = true;
    for (int m = 0; m < 4; m ++) {
        if (localIpxAddr.netnum [m] != outbuffer [m + 0x6]) isloopback = false;
    }
    for (int m = 0; m < 6; m ++) {
        if (localIpxAddr.netnode [m] != outbuffer [m + 0xa]) isloopback = false;
        if (immedAddr [m] != (byte) 0xff) islocalbroadcast = false;
    }
    if (! isloopback) {
        DatagramPacket outPacket = new DatagramPacket (outbuffer, packetsize, ipxServConnIp, udpPort);
        try {
            ipxClientSocket.send (outPacket);
        } catch (Exception e) {
            e.printStackTrace ();
            Log.log_msg ("IPX: Could not send packet");
            sendecb.setCompletionFlag (COMP_HARDWAREERROR);
            sendecb.NotifyESR ();
            DisconnectFromServer (true);
            return;
        }
        sendecb.setCompletionFlag (COMP_SUCCESS);
        if (Config.IPX_DEBUGMSG) Log.log_msg ("Packet sent: size: " + packetsize);
    }
    else {
        sendecb.setCompletionFlag (COMP_SUCCESS);
    }
    if (isloopback || islocalbroadcast) {
        receivePacket (outbuffer, packetsize);
        if (Config.IPX_DEBUGMSG) Log.log_msg ("Packet back: loopback:" + isloopback + ", broadcast:" + islocalbroadcast);
    }
    sendecb.NotifyESR ();
}


static HashMap < String, Object > parseParamsElement (Element pe, HashMap < String, Object > h) {
    final boolean ignoreCase = true;
    HashMap < String, String > lc2name = new HashMap < String, String > ();
    if (ignoreCase) {
        for (String name : h.keySet ()) lc2name.put (name.toLowerCase (), name);
    }
    int cnt = 0;
    for (Node n = pe.getFirstChild (); n != null; n = n.getNextSibling ()) {
        int type = n.getNodeType ();
        if (type == Node.ELEMENT_NODE && n.getNodeName ().equals (PARAMETER)) {
            String aname = ((Element) n).getAttribute (NAME);
            String aval = ((Element) n).getAttribute (VALUE);
            if (aname == null) throw new IllegalArgumentException ("Found a parameter element with no name");
            if (aval == null) throw new IllegalArgumentException ("Found parameter element '" + aname + "' with no value");
            if (! h.containsKey (aname)) {
                String altName = lc2name.get (aname.toLowerCase ());
                if (altName != null) {
                    Logging.warning ("Parameter name '" + aname + "' permissively converted to '" + altName + "'");
                    aname = altName;
                }
                else throw new IllegalArgumentException ("Found parameter element with unexpected name '" + aname + "'");
            }
            Object o;
            try {
                o = Param.valueOf (aval);
            } catch (java.lang.IllegalArgumentException ex) {
                o = new Double (XMLUtil.parseDouble (aval));
            }
            h.put (aname, o);
            cnt ++;
        }
        else if (XMLUtil.isIgnorable (n)) {
        }
        else {
            throw new IllegalArgumentException ("Unexpected child found within a PARAMETERS element: " + n);
        }
    }
    return h;
}


-----Function Pair=10=-----==

public static void countClasses () {
    String filename = "C:/Projects/NAM/namgbs/allfusion_110401.LD/allLD/allfusion_110401.lh.ld.c4.dedupe.txt";
    Pattern tab = Pattern.compile ("\t");
    String input;
    String [] info;
    int [] [] popcounts = new int [27] [2];
    int [] pop;
    try {
        BufferedReader br = new BufferedReader (new FileReader (filename));
        info = tab.split (br.readLine ());
        int n = info.length;
        pop = new int [n - 11];
        for (int i = 11; i < n; i ++) {
            pop [i - 11] = Integer.parseInt (info [i].substring (2, 4));
        }
        while ((input = br.readLine ()) != null) {
            info = tab.split (input);
            for (int i = 11; i < n; i ++) {
                int taxon = i - 11;
                int popnum = pop [taxon];
                popcounts [popnum] [1] ++;
                if (! info [taxon].equals ("N")) popcounts [popnum] [0] ++;
            }
        }
        br.close ();
        for (int i = 0; i < 27; i ++) {
            int totalcount = popcounts [i] [1];
            int nonNcount = popcounts [i] [0];
            double prop;
            if (totalcount != 0) prop = ((double) nonNcount) / ((double) totalcount);
            else prop = Double.NaN;
            System.out.println ("pop " + i + ": " + nonNcount + ", " + totalcount + ", " + prop);
        }
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=11=-----==

private void readDBF () throws IOException {
    URL url = new URL (base, baseName + ".dbf");
    dbfStream = new DataInputStream (url.openStream ());
    dbfStream.skipBytes (4);
    int numRecs = readInt (dbfStream);
    short headerSize = readShort (dbfStream);
    short recordSize = readShort (dbfStream);
    dbfStream.skipBytes (20);
    int numFields = (headerSize - 33) / 32;
    for (int i = 0; i < numFields; i ++) {
        String fieldName = readString (dbfStream, 11);
        byte fieldType = dbfStream.readByte ();
        dbfStream.skipBytes (4);
        byte fieldLength = dbfStream.readByte ();
        dbfStream.skipBytes (15);
        ShapeFieldDescriptor field = new ShapeFieldDescriptor (fieldName, fieldType, fieldLength);
        descriptors.add (field);
    }
    dbfStream.skipBytes (2);
    byte records [] = new byte [recordSize * numRecs];
    dbfStream.read (records);
    for (int i = 0; i < numRecs; i ++) {
        DataRecord node = readShapeRecord (descriptors, records, i * recordSize);
        shapeRecords.add (node);
    }
    dbfStream.close ();
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=12=-----==

public void run () {
    e2colorpattern temppattern;
    e2piece temppiece;
    System.out.println (" backtracker started");
    while (killed == false) {
        while (solved == false && stop == false && level <= levelmax) {
            if (piecelisttab [level] == null) {
                temppattern = maingame.get_pattern_at (collist [level], rowlist [level]);
                piecelisttab [level] = maingame.get_unplaced_matching_pieces (temppattern);
                Collections.shuffle (piecelisttab [level].list);
                piecelisttab [level].restart ();
                if (piecelisttab [level].hasNext ()) {
                    currentpiecetab [level] = piecelisttab [level].next ();
                    currentpiecetab [level].reset_rotation ();
                    rotation [level] = - 1;
                }
                else {
                    currentpiecetab [level] = null;
                }
            }
            temppattern = maingame.get_pattern_at (collist [level], rowlist [level]);
            rotationfound = false;
            rotation [level] ++;
            while (currentpiecetab [level] != null && rotation [level] < 4 && rotationfound == false) {
                if (currentpiecetab [level].is_matching_pattern_with_rotation (temppattern)) {
                    rotationfound = true;
                }
                else {
                    rotation [level] ++;
                    currentpiecetab [level].reset_rotation ();
                    if (rotation [level] < 4) {
                        currentpiecetab [level].rotate (rotation [level]);
                    }
                }
            }
            if (rotationfound == true) {
                maingame.place_piece_at (currentpiecetab [level].id, collist [level], rowlist [level], 0);
                level ++;
                if (level > levelmax) {
                    solved = true;
                    System.out.println (" solution found");
                }
                if (level > best_level) {
                    best_level = level;
                }
                if (level > count_bestlevel) {
                    count_bestlevel = level;
                }
                count_from_start ++;
                count_from_last ++;
                if (count_from_last == display_every_count_nb) {
                    temp_time = (long) (new Date ()).getTime ();
                    time_between_count = temp_time - last_time_count;
                    System.out.println (count_from_last + " pieces placed in " + time_between_count + " ms (time=" + temp_time + ") (count=" + count_from_start + ") (bestlevel=" + best_level + ") (incrbestlevel=" + count_bestlevel + ") (incrworstlevel=" + count_worstlevel + ")");
                    count_from_last = 0;
                    last_time_count = temp_time;
                    count_bestlevel = level;
                    count_worstlevel = level;
                }
            }
            else {
                if (piecelisttab [level].hasNext ()) {
                    currentpiecetab [level] = piecelisttab [level].next ();
                    currentpiecetab [level].reset_rotation ();
                    rotation [level] = - 1;
                }
                else {
                    piecelisttab [level] = null;
                    level --;
                    if (level < count_worstlevel) {
                        count_worstlevel = level;
                    }
                    if (level < levelmin) {
                        stop = true;
                        System.out.println (" NO SOLUTION");
                    }
                    else {
                        maingame.unplace_piece_at (collist [level], rowlist [level]);
                    }
                }
            }
            try {
                Thread.sleep (0000);
            } catch (InterruptedException ex) {
            }
        }
    }
    System.out.println (" backtracker finished");
}


public void addPosterization (RasterFilterListManager filterManager, IRasterRendering rendering) throws FilterTypeException {
    EnhancementStretchListManager elm = new EnhancementStretchListManager (filterManager);
    LinearStretchParams leParams = new LinearStretchParams ();
    double min = data.getMin ();
    double max = data.getMax ();
    double [] stretchs = data.getStretchs ();
    double distance = max - min;
    for (int i = 0; i < stretchs.length; i ++) stretchs [i] = min + stretchs [i] * distance;
    double [] in = new double [(stretchs.length - 1) * 2 + 4];
    int [] out = new int [(stretchs.length - 1) * 2 + 4];
    in [0] = in [1] = min;
    out [0] = out [1] = 0;
    in [in.length - 1] = in [in.length - 2] = max;
    out [out.length - 1] = out [out.length - 2] = 255;
    boolean even = true;
    out [2] = 0;
    for (int i = 3; i < in.length - 2; i = i + 2) {
        if (even) out [i] = out [i + 1] = 255;
        else out [i] = out [i + 1] = 0;
        even = ! even;
    }
    out [out.length - 2] = 255;
    for (int i = 2; i < in.length - 2; i = i + 2) in [i] = in [i + 1] = stretchs [(int) (i / 2)];
    leParams.rgb = true;
    leParams.red.stretchIn = in;
    leParams.red.stretchOut = out;
    leParams.green.stretchIn = in;
    leParams.green.stretchOut = out;
    leParams.blue.stretchIn = in;
    leParams.blue.stretchOut = out;
    elm.addEnhancedStretchFilter (leParams, lyr.getDataSource ().getStatistics (), rendering.getRenderBands (), false);
}


-----Function Pair=13=-----==

protected void addNGrams (int pos, int off) {
    int len = 0;
    while (len < 5) {
        int start = pos - len;
        if (start < 0) break;
        len ++;
        NGram ng = NGramImpl.newNGram (bytes, start, len);
        int cng = grams.get (ng);
        if (off > 0) {
            if (cng != grams.getNullValue ()) {
                gtcount [cng] ++;
                eqcount [cng] --;
                cng += off;
                grams.put (ng, cng);
                eqcount [cng] ++;
            }
            else {
                eqcount [off] ++;
                grams.put (ng, off);
            }
        }
        else {
            if (cng != grams.getNullValue ()) {
                eqcount [cng] --;
                cng += off;
                grams.put (ng, cng);
                gtcount [cng] --;
                eqcount [cng] ++;
            }
        }
    }
}


public static < E > void parallelSort (final E [] elements, final Comparator < ? super E > comparator) {
    if (elements.length < 8192) {
        adaptiveMergesort (elements.clone (), elements, 0, elements.length, comparator, log2 (elements.length));
        return;
    }
    final E [] buffer = elements.clone ();
    final int bound, log2length = log2 (bound = elements.length);
    final int mid = bound>>> 1;
    final boolean [] board = new boolean [2];
    new Thread () {
        @Override
        public void run () {
            adaptiveMergesort (elements, buffer, mid, elements.length, comparator, log2length);
            board [1] = true;
            if (board [0]) {
                synchronized (board) {
                    board.notify ();
                }
            }
        }
    }
    .start ();
    adaptiveMergesort (elements, buffer, 0, mid, comparator, log2length);
    board [0] = true;
    if (! board [1]) {
        synchronized (board) {
            try {
                board.wait ();
            } catch (final InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
    if (comparator.compare (buffer [mid - 1], buffer [mid]) <= 0) System.arraycopy (buffer, mid, elements, mid, bound - mid);
    else {
        for (int l, i = l = 0, r = mid; i < bound; i ++) {
            if (r >= bound || l < mid && comparator.compare (buffer [l], buffer [r]) <= 0) {
                elements [i] = buffer [l];
                l ++;
            }
            else {
                elements [i] = buffer [r];
                r ++;
            }
        }
    }
}


-----Function Pair=14=-----==

private String getKnowledgePoints (String kp) {
    Table table = null;
    StringBuffer kp0 = new StringBuffer (kp);
    StringBuffer kp1 = new StringBuffer ();
    StringBuffer kp2 = new StringBuffer ();
    HashMap < String, String > map = new HashMap < String, String > ();
    String [] strings = kp.split (",");
    for (int i = 0; i < strings.length; i ++) {
        map.put (strings [i], strings [i]);
    }
    try {
        do {
            table = DataEngine.getInstance ().executeQuery ("select nKnowledgePointId from KnowledgePoint where  isDelete = 0 and  nParentId in(" + kp0.toString () + ")");
            if (table != null && table.getRowCount () > 0) {
                kp0 = new StringBuffer ();
                for (int i = 0; i < table.getRowCount (); i ++) {
                    map.put (table.getCellValue (i, 0), table.getCellValue (i, 0));
                    kp0.append ((i == 0 ? "" : ",") + table.getCellValue (i, 0));
                }
            }
        }
        while (table != null && table.getRowCount () != 0);
        Iterator < String > its = map.keySet ().iterator ();
        while (its.hasNext ()) {
            String next = its.next ();
            kp1.append (next + ",");
        }
        kp1.setLength (kp1.length () - 1);
        table = DataEngine.getInstance ().executeQuery ("select strKnowledgePointId from KnowledgePoint where  isDelete = 0 and  nKnowledgePointId in(" + kp1.toString () + ")");
        if (table != null && table.getRowCount () > 0) {
            for (int i = 0; i < table.getRowCount (); i ++) {
                kp2.append ("'" + table.getCellValue (i, 0) + "',");
            }
            kp2.setLength (kp2.length () - 1);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return kp2.toString ();
}


public static void main (String argv []) throws IOException {
    int i = 0;
    while (i < argv.length) {
        if (argv [i].equals ("-dbg")) {
            i ++;
            debugger.debugClass (argv [i], true);
        }
        else break;
        i ++;
    }
    Mediaserver [] servs = Synch.getMediaservers (argv, i);
    if (servs.length < 1) {
        pa ("Please supply a Mediaserver data pool directory containing" + "client space.");
        System.exit (1);
    }
    else if (servs.length == 1) {
        ms = servs [0];
    }
    else {
        Mediaserver first = servs [0];
        Mediaserver [] other = new Mediaserver [servs.length - 1];
        for (int j = 0; j < other.length; j ++) other [j] = servs [j + 1];
        ms = new MultiplexingMediaserver (first, null, other);
    }
    Mediaserver.Id spaceId = getPointer ();
    pa ("Starting with space\n" + spaceId.getString ());
    space = new PermanentSpace (ms, spaceId);
    clientCell = space.getHomeCell ().s (d1);
    if (clientCell == null) {
        pa ("No client cell in space");
        System.exit (1);
    }
    client.start ();
}


-----Function Pair=15=-----==

public void run () {
    try {
        Socket.setSocketImplFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        ServerSocket.setSocketFactory (new SocketImplFactory () {
            public SocketImpl createSocketImpl () {
                return new JikesRVMSocketImpl ();
            }
        }
        );
        DatagramSocket.setDatagramSocketImplFactory (new DatagramSocketImplFactory () {
            public DatagramSocketImpl createDatagramSocketImpl () {
                throw new VM_UnimplementedError ("Need to implement JikesRVMDatagramSocketImpl");
            }
        }
        );
    } catch (java.io.IOException e) {
        VM.sysWrite ("trouble setting socket impl factories");
    }
    VM_Controller.boot ();
    ClassLoader cl = VM_ClassLoader.getApplicationClassLoader ();
    setContextClassLoader (cl);
    VM_Class cls = null;
    try {
        VM_Atom mainAtom = VM_Atom.findOrCreateUnicodeAtom (args [0].replace ('.', '/'));
        VM_TypeReference mainClass = VM_TypeReference.findOrCreate (cl, mainAtom.descriptorFromClassName ());
        cls = mainClass.resolve ().asClass ();
        cls.resolve ();
        cls.instantiate ();
        cls.initialize ();
    } catch (ClassNotFoundException e) {
        VM.sysWrite (e + "\n");
        return;
    }
    mainMethod = cls.findMainMethod ();
    if (mainMethod == null) {
        VM.sysWrite (cls + " doesn't have a \"public static void main(String[])\" method to execute\n");
        return;
    }
    String [] mainArgs = new String [args.length - 1];
    for (int i = 0, n = mainArgs.length; i < n; ++ i) mainArgs [i] = args [i + 1];
    mainMethod.compile ();
    VM_Callbacks.notifyStartup ();
    VM.debugBreakpoint ();
    VM_Magic.invokeMain (mainArgs, mainMethod.getCurrentCompiledMethod ().getInstructions ());
}


protected void processPalette (RdpPacket_Localised data) {
    int n_colors = 0;
    IndexColorModel cm = null;
    byte [] palette = null;
    byte [] red = null;
    byte [] green = null;
    byte [] blue = null;
    int j = 0;
    data.incrementPosition (2);
    n_colors = data.getLittleEndian16 ();
    data.incrementPosition (2);
    palette = new byte [n_colors * 3];
    red = new byte [n_colors];
    green = new byte [n_colors];
    blue = new byte [n_colors];
    data.copyToByteArray (palette, 0, data.getPosition (), palette.length);
    data.incrementPosition (palette.length);
    for (int i = 0; i < n_colors; i ++) {
        red [i] = palette [j];
        green [i] = palette [j + 1];
        blue [i] = palette [j + 2];
        j += 3;
    }
    cm = new IndexColorModel (8, n_colors, red, green, blue);
    surface.registerPalette (cm);
}


-----Function Pair=16=-----==

public dfp multiply (int x) {
    int r, rh, rl;
    int excp;
    int lostdigit;
    dfp result = newInstance (this);
    if (nans != FINITE) {
        if (nans == QNAN || nans == SNAN) return this;
        if (nans == INFINITE && x != 0) {
            result = newInstance (this);
            return result;
        }
        if (nans == INFINITE && x == 0) {
            ieeeFlags |= FLAG_INVALID;
            result = newInstance (zero);
            result.nans = QNAN;
            result = dotrap (FLAG_INVALID, "multiply", newInstance (zero), result);
            return result;
        }
    }
    if (x < 0 || x >= radix) {
        ieeeFlags |= FLAG_INVALID;
        result = newInstance (zero);
        result.nans = QNAN;
        result = dotrap (FLAG_INVALID, "multiply", result, result);
        return result;
    }
    rh = 0;
    for (int i = 0; i < DIGITS; i ++) {
        r = mant [i] * x + rh;
        rl = r % radix;
        rh = r / radix;
        result.mant [i] = rl;
    }
    lostdigit = 0;
    if (rh != 0) {
        lostdigit = result.mant [0];
        result.shiftRight ();
        result.mant [DIGITS - 1] = rh;
    }
    if (result.mant [DIGITS - 1] == 0) result.exp = 0;
    excp = result.round (lostdigit);
    if (excp != 0) result = dotrap (excp, "multiply", result, result);
    return result;
}


public void setSize (double xsize, double ysize, double zsize) {
    Vec3 size = bounds.getSize ();
    double xscale, yscale, zscale;
    if (size.x == 0.0) xscale = 1.0;
    else xscale = xsize / size.x;
    if (size.y == 0.0) yscale = 1.0;
    else yscale = ysize / size.y;
    if (size.z == 0.0) zscale = 1.0;
    else zscale = zsize / size.z;
    for (int i = 0; i < vertex.length; i ++) {
        vertex [i].r.x *= xscale;
        vertex [i].r.y *= yscale;
        vertex [i].r.z *= zscale;
    }
    skeleton.scale (xscale, yscale, zscale);
    cachedMesh = null;
    cachedWire = null;
    bounds = null;
}


-----Function Pair=17=-----==

public OrderTO doTradeByPaper (int index, String idPaper) throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    int volume = quote.getVolume ();
    if (currTime < PERIODO) {
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, 0, preco, true);
    }
    else {
        double m = media (dias [index]);
        int v;
        if (Trend.trend (dias [index]) > 0 && dias [index] [PERIODO - 1] < m) v = VOLUME;
        else if (Trend.trend (dias [index]) < 0 && m < dias [index] [PERIODO - 1]) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, volume, dias [index]);
        return createSingleOrder (idPaper, Math.abs (v), preco, true);
    }
}


public double calculateBoundaryLength () {
    double bl = 0;
    int lastX = 0;
    int lastY = 0;
    for (int i = 0; i <= npoints; i ++) {
        int x;
        int y;
        if (i == npoints) {
            x = xpoints [0];
            y = ypoints [0];
        }
        else {
            x = xpoints [i];
            y = ypoints [i];
        }
        if (i > 0) {
            int xdiff = x - lastX;
            int ydiff = y - lastY;
            bl += Math.sqrt ((double) (xdiff * xdiff) + (double) (ydiff * ydiff));
        }
        lastX = x;
        lastY = y;
    }
    return bl;
}


-----Function Pair=18=-----==

public String [] getItemString (Component c, Element e, String [] tabTitle) {
    String [] out = new String [4];
    for (int i = 0; i < 4; i ++) {
        out [i] = null;
    }
    Element parent = e;
    String childName = null;
    AccessibleRole childRole = null;
    AccessibleContext menu = c.getAccessibleContext ();
    Accessible child = null;
    int count = menu.getAccessibleChildrenCount ();
    for (int k = 0; k < count; k ++) {
        child = menu.getAccessibleChild (k);
        childName = child.getAccessibleContext ().getAccessibleName ();
        childRole = child.getAccessibleContext ().getAccessibleRole ();
        if (childName == null) childName = "null";
        if (childName.matches (tabTitle [0])) break;
    }
    if (childName.matches (tabTitle [0])) {
        out [0] = childName;
        out [1] = childRole.toDisplayString (Locale.UK);
        out [2] = parent.getAttributeValue ("accessibleName");
        out [3] = parent.getAttributeValue ("accessibleRole");
    }
    else {
        out = null;
    }
    return out;
}


public void decodeNextScanline (int lineIndex) throws IIOException {
    int bits = 0, code = 0, isT = 0;
    int current, entry, twoBits;
    boolean isWhite = true;
    int dstEnd = 0;
    int bitOffset = 0;
    changingElemSize = 0;
    while (bitOffset < w) {
        int runOffset = bitOffset;
        while (isWhite && bitOffset < w) {
            current = nextNBits (10);
            entry = white [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x0f;
            if (bits == 12) {
                twoBits = nextLesserThan8Bits (2);
                current = ((current << 2) & 0x000c) | twoBits;
                entry = additionalMakeup [current];
                bits = (entry>>> 1) & 0x07;
                code = (entry>>> 4) & 0x0fff;
                bitOffset += code;
                updatePointer (4 - bits);
            }
            else if (bits == 0) {
                warning ("Error 0");
            }
            else if (bits == 15) {
                warning ("Premature EOL in white run of line " + lineIndex + ": read " + bitOffset + " of " + w + " expected pixels.");
                return;
            }
            else {
                code = (entry>>> 5) & 0x07ff;
                bitOffset += code;
                updatePointer (10 - bits);
                if (isT == 0) {
                    isWhite = false;
                    currChangingElems [changingElemSize ++] = bitOffset;
                }
            }
        }
        if (bitOffset == w) {
            int runLength = bitOffset - runOffset;
            if (isWhite && runLength != 0 && runLength % 64 == 0 && nextNBits (8) != 0x35) {
                warning ("Missing zero white run length terminating code!");
                updatePointer (8);
            }
            break;
        }
        runOffset = bitOffset;
        while (isWhite == false && bitOffset < w) {
            current = nextLesserThan8Bits (4);
            entry = initBlack [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x000f;
            code = (entry>>> 5) & 0x07ff;
            if (code == 100) {
                current = nextNBits (9);
                entry = black [current];
                isT = entry & 0x0001;
                bits = (entry>>> 1) & 0x000f;
                code = (entry>>> 5) & 0x07ff;
                if (bits == 12) {
                    updatePointer (5);
                    current = nextLesserThan8Bits (4);
                    entry = additionalMakeup [current];
                    bits = (entry>>> 1) & 0x07;
                    code = (entry>>> 4) & 0x0fff;
                    setToBlack (bitOffset, code);
                    bitOffset += code;
                    updatePointer (4 - bits);
                }
                else if (bits == 15) {
                    warning ("Premature EOL in black run of line " + lineIndex + ": read " + bitOffset + " of " + w + " expected pixels.");
                    return;
                }
                else {
                    setToBlack (bitOffset, code);
                    bitOffset += code;
                    updatePointer (9 - bits);
                    if (isT == 0) {
                        isWhite = true;
                        currChangingElems [changingElemSize ++] = bitOffset;
                    }
                }
            }
            else if (code == 200) {
                current = nextLesserThan8Bits (2);
                entry = twoBitBlack [current];
                code = (entry>>> 5) & 0x07ff;
                bits = (entry>>> 1) & 0x0f;
                setToBlack (bitOffset, code);
                bitOffset += code;
                updatePointer (2 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
            else {
                setToBlack (bitOffset, code);
                bitOffset += code;
                updatePointer (4 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
        }
        if (bitOffset == w) {
            int runLength = bitOffset - runOffset;
            if (! isWhite && runLength != 0 && runLength % 64 == 0 && nextNBits (10) != 0x37) {
                warning ("Missing zero black run length terminating code!");
                updatePointer (10);
            }
            break;
        }
    }
    currChangingElems [changingElemSize ++] = bitOffset;
}


-----Function Pair=19=-----==

private static void runAgent (Instrumentation instrumenter, ClassLoader cl, String agentJar, String agentOptions) {
    Manifest mf = null;
    try {
        JarFile jf = new JarFile (agentJar);
        mf = jf.getManifest ();
    } catch (Exception e) {
        VM.sysWriteln ("vm: IO Exception opening JAR file ", agentJar, ": ", e.getMessage ());
        VM.sysExit (VM.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
    }
    if (mf == null) {
        VM.sysWriteln ("The jar file is missing the manifest: ", agentJar);
        VM.sysExit (VM.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
    }
    String agentClassName = mf.getMainAttributes ().getValue ("Premain-Class");
    if (agentClassName == null) {
        VM.sysWriteln ("The jar file is missing the Premain-Class manifest entry for the agent class: ", agentJar);
        VM.sysExit (VM.EXIT_STATUS_BOGUS_COMMAND_LINE_ARG);
    }
    try {
        Class < ? > agentClass = cl.loadClass (agentClassName);
        Method agentPremainMethod = agentClass.getMethod ("premain", new Class < ? > [] {String.class, Instrumentation.class});
        agentPremainMethod.invoke (null, new Object [] {agentOptions, instrumenter});
    } catch (InvocationTargetException e) {
    } catch (Throwable e) {
        VM.sysWriteln ("Failed to run the agent's premain: " + e.getMessage ());
        e.printStackTrace ();
        System.exit (0);
    }
}


public Rating next () {
    if (! hasNext ()) return null;
    Rating l = new Rating (instances);
    Attribute [] attributes = getAttributes ();
    SparseInstance d = new SparseInstance (attributes.length - 2);
    Long start;
    try {
        l.setUserId (Utils.objectToInteger (records.getObject (1)));
        l.setObjectId (Utils.objectToInteger (records.getObject (2)));
        int flixId = Integer.parseInt (records.getObject (2).toString ());
        int i = 0;
        for (; i < this.attributes.length; i ++) {
            start = System.currentTimeMillis ();
            if (attributes [i].isNominal ()) d.setValue (i, records.getObject (i + 3).toString ());
            else d.setValue (i, Utils.objectToDouble (records.getObject (i + 3)));
            Oracle += System.currentTimeMillis () - start;
        }
        SparseInstance movie = imdb.getMovie (flixId);
        d = (SparseInstance) d.mergeInstance (movie);
        d.setDataset (instances);
        start = System.currentTimeMillis ();
        records.next ();
        Oracle += System.currentTimeMillis () - start;
    } catch (SQLException e) {
        e.printStackTrace ();
        return null;
    }
    l.setRecord (d);
    return l;
}


-----Function Pair=20=-----==

public static int [] getRoundKernel (int kernelWidth, int imagewidth, int bpp) {
    if (kernelWidth < 5 || kernelWidth % 2 == 0) return null;
    int [] rows = new int [kernelWidth];
    int r = 0;
    int kernelSize = 0;
    for (int i = 3; i < kernelWidth; i += 2) {
        rows [r ++] = i;
        kernelSize += i;
    }
    for (int i = 0; i < 3; i ++) {
        rows [r ++] = kernelWidth;
        kernelSize += kernelWidth;
    }
    for (int i = kernelWidth - 2; i > 1; i -= 2) {
        rows [r ++] = i;
        kernelSize += i;
    }
    int [] kernel = new int [kernelSize];
    int roundPart = (kernelWidth - 3) / 2;
    int rowcount = 0;
    int n = 0;
    int imagewidth2 = imagewidth * bpp;
    int distance = - (kernelWidth / 2);
    for (int i = 0; i < roundPart; i ++) {
        for (int j = - rows [rowcount] / 2; j <= rows [rowcount] / 2; j ++) {
            kernel [n ++] = j + imagewidth2 * distance;
        }
        rowcount ++;
        distance ++;
    }
    for (int i = 0; i < 3; i ++) {
        for (int j = - rows [rowcount] / 2; j <= rows [rowcount] / 2; j ++) {
            kernel [n ++] = j + imagewidth2 * distance;
        }
        rowcount ++;
        distance ++;
    }
    for (int i = 0; i < roundPart; i ++) {
        for (int j = - rows [rowcount] / 2; j <= rows [rowcount] / 2; j ++) {
            kernel [n ++] = j + imagewidth2 * distance;
        }
        rowcount ++;
        distance ++;
    }
    return kernel;
}


private static OracleSpatialDriver initDriverOracle (IConnection conn, String dburl, String dbuser, String dbpass, String dbtable) {
    try {
        String fidField = "rowid";
        String geomField = "geometry";
        String [] fields = new String [1];
        fields [0] = "rowid";
        String whereClause = "";
        OracleSpatialDriver driver = new OracleSpatialDriver ();
        String strEPSG = "23030";
        DBLayerDefinition lyrDef = new DBLayerDefinition ();
        lyrDef.setName (dbtable);
        lyrDef.setTableName (dbtable);
        lyrDef.setWhereClause (whereClause);
        lyrDef.setFieldNames (fields);
        lyrDef.setFieldGeometry (geomField);
        lyrDef.setFieldID (fidField);
        lyrDef.setSRID_EPSG (strEPSG);
        if (driver instanceof ICanReproject) {
            ((ICanReproject) driver).setDestProjection (strEPSG);
        }
        driver.setData (conn, lyrDef);
        IProjection proj = null;
        if (driver instanceof ICanReproject) {
            proj = CRSFactory.getCRS ("EPSG:" + ((ICanReproject) driver).getSourceProjection (conn, lyrDef));
        }
        return driver;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=21=-----=1=

public RobotList < Resource > sort_incr_Resource (RobotList < Resource > list, String field) {
    int length = list.size ();
    Index_value [] resource_dist = new Index_value [length];
    if (field.equals ("") || field.equals ("location")) {
        Location cur_loc = this.getLocation ();
        for (int i = 0; i < length; i ++) {
            resource_dist [i] = new Index_value (i, distance (cur_loc, list.get (i).location));
        }
    }
    else if (field.equals ("energy")) {
        for (int i = 0; i < length; i ++) {
            resource_dist [i] = new Index_value (i, list.get (i).energy);
        }
    }
    else if (field.equals ("ammostash")) {
        for (int i = 0; i < length; i ++) {
            resource_dist [i] = new Index_value (i, list.get (i).ammostash);
        }
    }
    else if (field.equals ("speed")) {
        for (int i = 0; i < length; i ++) {
            resource_dist [i] = new Index_value (i, list.get (i).speed);
        }
    }
    else if (field.equals ("health")) {
        for (int i = 0; i < length; i ++) {
            resource_dist [i] = new Index_value (i, list.get (i).health);
        }
    }
    else {
        say ("impossible to sort list - nothing modified");
        return list;
    }
    boolean permut;
    do {
        permut = false;
        for (int i = 0; i < length - 1; i ++) {
            if (resource_dist [i].value > resource_dist [i + 1].value) {
                Index_value a = resource_dist [i];
                resource_dist [i] = resource_dist [i + 1];
                resource_dist [i + 1] = a;
                permut = true;
            }
        }
    }
    while (permut);
    RobotList < Resource > new_resource_list = new RobotList < Resource > (Resource.class);
    for (int i = 0; i < length; i ++) {
        new_resource_list.addLast (list.get (resource_dist [i].index));
    }
    return new_resource_list;
}


public static int best (int r, int n, int s) {
    if ((n <= 0) || (r < 0) || (r > n) || (s < 0)) return 0;
    int [] rolls = new int [n];
    for (int i = 0; i < n; i ++) rolls [i] = d (s);
    boolean found;
    do {
        found = false;
        for (int x = 0; x < n - 1; x ++) {
            if (rolls [x] < rolls [x + 1]) {
                int t = rolls [x];
                rolls [x] = rolls [x + 1];
                rolls [x + 1] = t;
                found = true;
            }
        }
    }
    while (found);
    int sum = 0;
    for (int i = 0; i < r; i ++) sum += rolls [i];
    return sum;
}


-----Function Pair=22=-----==

public void relocate (int oldIndex, int newIndex) {
    if (oldIndex < 0 || oldIndex > tests.length - 1) {
        throw new java.lang.IllegalArgumentException ();
    }
    if (newIndex < 0 || newIndex > tests.length - 1) {
        throw new java.lang.IllegalArgumentException ();
    }
    else {
        if (newIndex > oldIndex) {
            Test temp = tests [oldIndex];
            for (int i = oldIndex; i < newIndex; i ++) tests [i] = tests [i + 1];
            tests [newIndex] = temp;
        }
        else if (oldIndex > newIndex) {
            Test temp = tests [oldIndex];
            for (int j = oldIndex; j > newIndex; j --) tests [j] = tests [j - 1];
            tests [newIndex] = temp;
        }
    }
}


void update_keyboard () {
    for (int i = 0; i < 8; i ++) keyboard [i] = 0xFF;
    kempston = 0;
    int m [] = new int [] {- 1, - 1, - 1, - 1, - 1};
    int s = 0;
    synchronized (keys) {
        for (int i = 0; i < keys.length; i ++) if (keys [i] != null) {
            int k = key (keys [i]);
            if (k < 0) continue;
            s |= k;
            if (k < 01000) pressed (k, m);
        }
    }
    if ((s & 0300) == 0) s |= s>>> 3 & 0300;
    if ((s & 0100) != 0) pressed (000, m);
    if ((s & 0200) != 0) pressed (017, m);
}


-----Function Pair=23=-----==

protected static void complexSqrt (float Re, float Im, float [] result) {
    float absRe, absIm, w, r;
    if ((Re == 0.0f) && (Im == 0.0f)) {
        result [0] = 0.0f;
        result [1] = 0.0f;
    }
    else {
        absRe = Math.abs (Re);
        absIm = Math.abs (Im);
        if (absRe >= absIm) {
            r = absIm / absRe;
            w = (float) (Math.sqrt (absRe) * Math.sqrt (0.5f * (1.0f + Math.sqrt (1.0f + r * r))));
        }
        else {
            r = absRe / absIm;
            w = (float) (Math.sqrt (absIm) * Math.sqrt (0.5f * (r + Math.sqrt (1.0f + r * r))));
        }
        if (Re >= 0.0) {
            result [0] = w;
            result [1] = Im / (2.0f * w);
        }
        else {
            result [1] = (Im >= 0.0f) ? w : - w;
            result [0] = Im / (2.0f * result [1]);
        }
    }
}


private String parseGrammar (String segment) {
    String output = "";
    try {
        String [] temp;
        String seg = replaceBrackets (module.getGrammar ().getProperty (segment, segment));
        if (seg.indexOf (";") == - 1) {
            temp = new String [1];
            temp [0] = seg.substring (1, seg.length () - 1);
        }
        else {
            temp = seg.substring (1, seg.length () - 1).split (";");
        }
        for (int i = 0; i < temp.length; i ++) {
            if (temp [i].indexOf ("#") != - 1) {
                String [] temp2 = temp [i].split ("#");
                temp [i] = temp2 [r.nextInt (temp2.length)];
            }
            if ((temp [i].startsWith ("(")) && (temp [i].endsWith (")"))) {
                temp [i] = temp [i].replace ('&', ';');
                temp [i] = temp [i].replace ('|', '#');
                temp [i] = "{" + temp [i].substring (1, temp [i].length () - 1) + "}";
                output += parseGrammar (temp [i]);
                if (i < temp.length - 1) {
                    output += "@";
                }
            }
            else if ((temp [i].startsWith ("*(")) && (temp [i].endsWith (")"))) {
                if (r.nextInt (2) == 1) {
                    temp [i] = temp [i].replace ('&', ';');
                    temp [i] = temp [i].replace ('|', '#');
                    temp [i] = "{" + temp [i].substring (2, temp [i].length () - 1) + "}";
                    output += parseGrammar (temp [i]);
                    if (i < temp.length - 1) {
                        output += "@";
                    }
                }
            }
            else if ((temp [i].startsWith ("'")) && (temp [i].endsWith ("'"))) {
                if (isWord (temp [i].substring (1, temp [i].length () - 1))) {
                    currentSyllables += getWordFromLists (temp [i].substring (1, temp [i].length () - 1)).getSyllables ();
                }
                output += temp [i];
                if (i < temp.length - 1) {
                    output += "@";
                }
            }
            else if ((temp [i].startsWith ("*'")) && (temp [i].endsWith ("'"))) {
                if (r.nextInt (2) == 1) {
                    if (isWord (temp [i].substring (2, temp [i].length () - 1))) {
                        currentSyllables += getWordFromLists (temp [i].substring (2, temp [i].length () - 1)).getSyllables ();
                    }
                    output += temp [i].substring (1, temp [i].length ());
                    if (i < temp.length - 1) {
                        output += "@";
                    }
                }
            }
            else if ((temp [i].startsWith ("[")) && (temp [i].endsWith ("]"))) {
                output += parseGrammar (temp [i].substring (1, temp [i].length () - 1));
                if (i < temp.length - 1) {
                    output += "@";
                }
            }
            else if ((temp [i].startsWith ("*[")) && (temp [i].endsWith ("]"))) {
                if (r.nextInt (2) == 1) {
                    output += parseGrammar (temp [i].substring (2, temp [i].length () - 1));
                    if (i < temp.length - 1) {
                        output += "@";
                    }
                }
            }
            else if (temp [i].startsWith ("*")) {
                if (r.nextInt (2) == 1) {
                    output += temp [i].substring (1, temp [i].length ());
                    if (i < temp.length - 1) {
                        output += "@";
                    }
                }
            }
            else {
                output += temp [i].substring (0, temp [i].length ());
                if (i < temp.length - 1) {
                    output += "@";
                }
            }
        }
    } catch (Exception e) {
        voice.sysout ("Error: Missing or illegal expression in grammar.dat - Segment:" + segment);
        voice.sysout (e.toString ());
    }
    if (output.endsWith ("@")) {
        output = output.substring (0, output.length () - 1);
    }
    return output;
}


-----Function Pair=24=-----==

private edu.cmu.sphinx.decoder.linguist.SentenceHMMState compileGrammarNode (edu.cmu.sphinx.decoder.linguist.GrammarNode grammarNode, Map compiledNodes) {
    edu.cmu.sphinx.decoder.linguist.GrammarState firstState = getGrammarState (grammarNode);
    allStates.add (firstState);
    compiledNodes.put (grammarNode, firstState);
    edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = expandGrammarState (firstState);
    for (int i = 0; i < grammarNode.getSuccessors ().length; i ++) {
        edu.cmu.sphinx.decoder.linguist.GrammarArc arc = grammarNode.getSuccessors () [i];
        edu.cmu.sphinx.decoder.linguist.GrammarNode nextNode = arc.getGrammarNode ();
        edu.cmu.sphinx.decoder.linguist.SentenceHMMState nextFirstState = null;
        if (compiledNodes.containsKey (nextNode)) {
            nextFirstState = (edu.cmu.sphinx.decoder.linguist.SentenceHMMState) compiledNodes.get (nextNode);
        }
        else {
            nextFirstState = compileGrammarNode (nextNode, compiledNodes);
        }
        attachState (lastState, nextFirstState, logMath.getLogOne (), arc.getProbability (), logMath.getLogOne ());
    }
    return firstState;
}


public void visitBinary (JCBinary tree) {
    OperatorSymbol operator = (OperatorSymbol) tree.operator;
    if (operator.opcode == string_add) {
        makeStringBuffer (tree.pos ());
        appendStrings (tree);
        bufferToString (tree.pos ());
        result = items.makeStackItem (syms.stringType);
    }
    else if (tree.getTag () == JCTree.AND) {
        CondItem lcond = genCond (tree.lhs, CRT_FLOW_CONTROLLER);
        if (! lcond.isFalse ()) {
            Chain falseJumps = lcond.jumpFalse ();
            code.resolve (lcond.trueJumps);
            CondItem rcond = genCond (tree.rhs, CRT_FLOW_TARGET);
            result = items.makeCondItem (rcond.opcode, rcond.trueJumps, code.mergeChains (falseJumps, rcond.falseJumps));
        }
        else {
            result = lcond;
        }
    }
    else if (tree.getTag () == JCTree.OR) {
        CondItem lcond = genCond (tree.lhs, CRT_FLOW_CONTROLLER);
        if (! lcond.isTrue ()) {
            Chain trueJumps = lcond.jumpTrue ();
            code.resolve (lcond.falseJumps);
            CondItem rcond = genCond (tree.rhs, CRT_FLOW_TARGET);
            result = items.makeCondItem (rcond.opcode, code.mergeChains (trueJumps, rcond.trueJumps), rcond.falseJumps);
        }
        else {
            result = lcond;
        }
    }
    else {
        Item od = genExpr (tree.lhs, operator.type.getParameterTypes ().head);
        od.load ();
        result = completeBinop (tree.lhs, tree.rhs, operator);
    }
}


-----Function Pair=25=-----==

public boolean addScore (DartScore dartScore) {
    boolean validScoreNumber = false;
    for (int i = 0; i < possibleScores.length; i ++) {
        if (possibleScores [i] == dartScore.getScore ()) {
            validScoreNumber = true;
            break;
        }
    }
    cat.debug ("addScore(" + dartScore.getPlayer () + ", " + dartScore.getScore () + ", " + dartScore.getHits () + ")");
    boolean scorable = isNumberScorable (dartScore.getScore (), dartScore.getPlayer ());
    int oldHits = getCountedHits (dartScore.getPlayer (), dartScore.getScore ());
    if (! validScoreNumber || oldHits >= closeNum && ! scorable) {
        dartScore.setCountedHits (0);
        dartScore.setScoredHits (0);
    }
    else {
        int newHits = oldHits + dartScore.getHits ();
        int countedHits = dartScore.getHits ();
        if (newHits > closeNum && ! scorable) {
            countedHits = closeNum - oldHits;
            newHits = closeNum;
        }
        dartScore.setCountedHits (countedHits);
        if (newHits > closeNum) {
            if (oldHits < closeNum) {
                oldHits = closeNum;
            }
            int scoredHits = newHits - oldHits;
            dartScore.setScoredHits (scoredHits);
        }
    }
    if (! super.addScore (dartScore)) {
        return false;
    }
    return true;
}


protected void decode_first_half () {
    int opcode;
    int optype, optypes;
    int optypes2 = 0;
    int optypebytes;
    int isextended = 0;
    opcode = zm.get_code_byte () & 0xFF;
    if (opcode == OP_EXTENDED) {
        isextended = 0xC0;
    }
    switch (isextended | opcode & 0xC0) {
        case 0xC0 :
            if (isextended != 0xC0) {
                opnum = opcode;
            }
            else {
                opnum = (0x100 | (zm.get_code_byte () & 0xFF));
            }
            if ((opcode & 0x20) == 0) {
                opnum = opcode & 0x1F;
            }
            count = 0;
            optypes = zm.get_code_byte ();
            if ((opnum == OP_CALL_VS2) || (opnum == OP_CALL_VN2)) {
                optypebytes = 2;
                optypes2 = zm.get_code_byte ();
            }
            else optypebytes = 1;
            while (optypebytes -- != 0) {
                optype = (optypes & 0xC0)>> 6;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x30)>> 4;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x0C)>> 2;
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optype = (optypes & 0x03);
                if (optype == zm.OP_OMITTED) break;
                operands [count ++] = zm.get_operand (optype);
                optypes = optypes2;
            }
            break;
        case 0x80 :
            optype = (opcode & 0x30)>> 4;
            if (optype == zm.OP_OMITTED) {
                opnum = opcode;
                count = 0;
            }
            else {
                opnum = opcode & 0x8F;
                count = 1;
                operands [0] = zm.get_operand (optype);
            }
            break;
        default :
            opnum = opcode & 0x1F;
            count = 2;
            optype = ((opcode & 0x40)>> 6) + 1;
            operands [0] = zm.get_operand (optype);
            optype = ((opcode & 0x20)>> 5) + 1;
            operands [1] = zm.get_operand (optype);
    }
}


-----Function Pair=26=-----==

ImageData (Object data, boolean isByRef) {
    this.data = data;
    dataIsByRef = isByRef;
    dataWidth = ((ImageData) data).dataWidth;
    dataHeight = ((ImageData) data).dataHeight;
    if (data == null) {
        imageDataType = ImageDataType.TYPE_NULL;
        length = 0;
    }
    else if (data instanceof byte []) {
        imageDataType = ImageDataType.TYPE_BYTE_ARRAY;
        length = ((byte []) data).length;
    }
    else if (data instanceof int []) {
        imageDataType = ImageDataType.TYPE_INT_ARRAY;
        length = ((int []) data).length;
    }
    else if (data instanceof ByteBuffer) {
        imageDataType = ImageDataType.TYPE_BYTE_BUFFER;
        length = ((ByteBuffer) data).limit ();
    }
    else if (data instanceof IntBuffer) {
        imageDataType = ImageDataType.TYPE_INT_BUFFER;
        length = ((IntBuffer) data).limit ();
    }
    else {
        assert false;
    }
}


public void visitTry (final JCTry tree) {
    final Env < GenContext > tryEnv = env.dup (tree, new GenContext ());
    final Env < GenContext > oldEnv = env;
    if (! useJsrLocally) {
        useJsrLocally = (stackMap == StackMapFormat.NONE) && (jsrlimit <= 0 || jsrlimit < 100 && estimateCodeComplexity (tree.finalizer) > jsrlimit);
    }
    tryEnv.info.finalize = new GenFinalizer () {
        void gen () {
            if (useJsrLocally) {
                if (tree.finalizer != null) {
                    Code.State jsrState = code.state.dup ();
                    jsrState.push (code.jsrReturnValue);
                    tryEnv.info.cont = new Chain (code.emitJump (jsr), tryEnv.info.cont, jsrState);
                }
                assert tryEnv.info.gaps.length () % 2 == 0;
                tryEnv.info.gaps.append (code.curPc ());
            }
            else {
                assert tryEnv.info.gaps.length () % 2 == 0;
                tryEnv.info.gaps.append (code.curPc ());
                genLast ();
            }
        } void genLast () {
            if (tree.finalizer != null) genStat (tree.finalizer, oldEnv, CRT_BLOCK);
        } boolean hasFinalizer () {
            return tree.finalizer != null;
        }
    }
    ;
    tryEnv.info.gaps = new ListBuffer < Integer > ();
    genTry (tree.body, tree.catchers, tryEnv);
}


-----Function Pair=27=-----==

private AudioFormat [] getOutputFormats (AudioFormat inputFormat) {
    Vector formats = new Vector ();
    AudioFormat format;
    int sampleSize = inputFormat.getSampleSizeInBits ();
    boolean isBigEndian = inputFormat.isBigEndian ();
    if (sampleSize == 8) {
        if (AudioFormat.Encoding.PCM_SIGNED.equals (inputFormat.getEncoding ())) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
        }
        if (AudioFormat.Encoding.PCM_UNSIGNED.equals (inputFormat.getEncoding ())) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
        }
    }
    else if (sampleSize == 16) {
        if (AudioFormat.Encoding.PCM_SIGNED.equals (inputFormat.getEncoding ()) && isBigEndian) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
        }
        if (AudioFormat.Encoding.PCM_UNSIGNED.equals (inputFormat.getEncoding ()) && isBigEndian) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
        }
        if (AudioFormat.Encoding.PCM_SIGNED.equals (inputFormat.getEncoding ()) && ! isBigEndian) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
        }
        if (AudioFormat.Encoding.PCM_UNSIGNED.equals (inputFormat.getEncoding ()) && ! isBigEndian) {
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), false);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_UNSIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
            format = new AudioFormat (AudioFormat.Encoding.PCM_SIGNED, inputFormat.getSampleRate (), inputFormat.getSampleSizeInBits (), inputFormat.getChannels (), inputFormat.getFrameSize (), inputFormat.getFrameRate (), true);
            formats.addElement (format);
        }
    }
    AudioFormat [] formatArray;
    synchronized (formats) {
        formatArray = new AudioFormat [formats.size ()];
        for (int i = 0; i < formatArray.length; i ++) {
            formatArray [i] = (AudioFormat) (formats.elementAt (i));
        }
    }
    return formatArray;
}


String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=28=-----==

void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=29=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


private boolean jdpCommand (String command, String [] args) {
    runstat = true;
    int addr, count;
    if (user == null) {
        if (command.equals ("run")) {
            switch (args.length) {
                case 0 :
                    restart (saved_args);
                    break;
                default :
                    restart (args);
            }
        }
        else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
            if (args.length == 0) printHelp ("");
            else printHelp (args [0]);
        }
        else {
            jdp_console.writeOutput ("No program running, enter:  run ... ");
        }
        return false;
    }
    if (command.equals ("step") || command.equals ("s")) {
        boolean skip_prolog = false;
        printMode = PRINTASSEMBLY;
        runstat = user.pstep (0, printMode, skip_prolog);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        jdp_console.writeOutput ("step instruction over call: not supported yet on Lintel");
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        printMode = PRINTASSEMBLY;
        runstat = user.pstepLine (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        printMode = PRINTSOURCE;
        runstat = user.pstepLineOverMethod (0);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("run")) {
        jdp_console.writeOutput ("Debuggee is running, kill before restarting");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        switch (debuggerEnvironment) {
            case EXTERNALCREATE :
                runstat = false;
                break;
            case EXTERNALATTACH :
                jdp_console.writeOutput ("Cannot kill attached process, type quit to detach debugger");
                break;
            case INTERNAL :
                jdp_console.writeOutput ("Debugger running inside JVM, type quit to exit debugger");
        }
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        if (debuggerEnvironment == EXTERNALATTACH && ! user.bpset.anyBreakpointExist ()) {
            jdp_console.writeOutput ("no breakpoint currently set, detaching process");
            return true;
        }
        else {
            runstat = user.pcontinue (0, printMode, true);
            if (runstat == true) refreshEnvironment ();
        }
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        jdp_console.writeOutput ("Continue thread not supported yet on Lintel");
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        runstat = user.pcontinueToReturn (0, printMode);
        if (runstat == true) refreshEnvironment ();
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        doThread (command, args);
    }
    else if (command.equals ("reg") || command.equals ("r")) {
        doRegisterRead (command, args);
    }
    else if (command.equals ("wreg") || command.equals ("wr")) {
        doRegisterWrite (command, args);
    }
    else if (command.equals ("memraw") || command.equals ("mraw")) {
        doMemoryReadRaw (command, args);
    }
    else if (command.equals ("mem") || command.equals ("m")) {
        doMemoryRead (command, args);
    }
    else if (command.equals ("wmem") || command.equals ("wm")) {
        doMemoryWrite (command, args);
    }
    else if (command.equals ("print") || command.equals ("p")) {
        doPrintCommand (command, args);
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        doPrintClassCommand (command, args);
    }
    else if (command.equals ("getclass")) {
        doGetClassCommand (command, args);
    }
    else if (command.equals ("getinstance")) {
        doGetInstanceCommand (command, args);
    }
    else if (command.equals ("getarray")) {
        doGetArrayCommand (command, args);
    }
    else if (command.equals ("getcl")) {
        doGetClassAndLine (command, args);
    }
    else if (command.equals ("getcia")) {
        doGetCurrentInstrAddr (command, args);
    }
    else if (command.equals ("getframes")) {
        doGetFrames (command, args);
    }
    else if (command.equals ("getlocals")) {
        doGetLocals (command, args);
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        jdp_console.writeOutput ("(this command has been removed because the Opt compiler does not generate the bytecode map)");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        doListInstruction (command, args);
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        doListThread (command, args);
    }
    else if (command.equals ("break") || command.equals ("b")) {
        doSetBreakpoint (command, args);
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        doClearBreakpoint (command, args);
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        doCurrentFrame (command, args);
    }
    else if (command.equals ("where") || command.equals ("w")) {
        doShortFrame (command, args);
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        doFullFrame (command, args);
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        doSetPreference (command, args);
    }
    else if (command.equals ("preference") || command.equals ("x2d")) {
        doConvertHexToInt (command, args);
    }
    else if (command.equals ("preference") || command.equals ("d2x")) {
        doConvertIntToHex (command, args);
    }
    else if (command.equals ("test")) {
        doTest (args);
    }
    else if (command.equals ("test1")) {
        doTest1 (args);
    }
    else if (command.equals ("count")) {
        doThreadCount (0);
    }
    else if (command.equals ("zerocount")) {
        doThreadCount (1);
    }
    else if (command.equals ("readmem")) {
        if (args.length != 0) {
            try {
                addr = parseHex32 (args [0]);
                int mydata = user.mem.read (addr);
                jdp_console.writeOutput ("true memory = x" + Integer.toHexString (mydata));
            } catch (NumberFormatException e) {
                jdp_console.writeOutput ("bad address: " + args [0]);
            }
        }
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        if (user.verbose) {
            jdp_console.writeOutput ("Verbose now OFF");
            user.verbose = false;
        }
        else {
            jdp_console.writeOutput ("Verbose now ON");
            user.verbose = true;
        }
    }
    else if (command.equals ("help") || command.equals ("h") || command.equals ("?")) {
        if (args.length == 0) printHelp ("");
        else printHelp (args [0]);
    }
    else if (macro.exists (command + ".jdp")) {
        macro.load (command + ".jdp");
    }
    else {
        jdp_console.writeOutput ("Command not implemented");
    }
    return false;
}


-----Function Pair=30=-----==

private static String extractText (final char [] chars, final int firstChar, int charCount) {
    final int maxIndex = Math.min (chars.length, firstChar + charCount);
    boolean anyChanges = true;
    while (anyChanges) {
        anyChanges = false;
        for (int i = firstChar; i < maxIndex - 1; i ++) {
            if (chars [i] == ' ' && chars [i + 1] == ' ') {
                for (int j = i + 1; j < maxIndex - 1; j ++) {
                    chars [j] = chars [j + 1];
                }
                charCount --;
                anyChanges = true;
            }
        }
    }
    final String returnValue = String.copyValueOf (chars, firstChar, charCount);
    return returnValue.trim ();
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=31=-----==

public void onModuleLoad () {
    rb = new RequestBuilder (RequestBuilder.POST, HOST);
    chat = new String [CHATLENGTH];
    for (int i = 0; i < chat.length; i ++) {
        chat [i] = "";
    }
    label = new Label ("Enter your nick:");
    nickField = new TextBox ();
    nickField.setMaxLength (8);
    button = new Button ("Submit");
    errorLabel = new Label ("");
    button.addClickListener (new ClickListener () {
        public void onClick (Widget w) {
            nick = nickField.getText ();
            nick = nick.replaceAll (" ", "");
            if (nick.length () > 0) {
                nick = nickField.getText ();
                send ("LOGIN", null);
            }
            else {
                errorLabel.setText ("Please enter a nick!");
            }
        }
    }
    );
    chatArea = new TextArea ();
    chatBox = new TextBox ();
    nickList = new ListBox ();
    nickList.setVisibleItemCount (15);
    chatArea.setSize ("640px", "480px");
    chatArea.setReadOnly (true);
    chatBox.setWidth ("640px");
    chatBox.addKeyboardListener (new KeyboardListener () {
        public void onKeyDown (Widget arg0, char arg1, int arg2) {
        } public void onKeyPress (Widget arg0, char arg1, int arg2) {
            if (arg1 == 13) {
                appendText (nick + ": " + chatBox.getText ());
                JSONObject o = new JSONObject ();
                o.put ("TEXT", new JSONString (chatBox.getText ()));
                chatBox.setText ("");
                send ("SAY", o);
            }
        } public void onKeyUp (Widget arg0, char arg1, int arg2) {
        }
    }
    );
    RootPanel.get ().add (label);
    RootPanel.get ().add (nickField);
    RootPanel.get ().add (button);
    RootPanel.get ().add (errorLabel);
}


public void read_wchar_array (char [] val, int voff, int vlen) {
    if (0 == vlen) {
        return;
    }
    if (m_wchar_enc == null) {
        if (m_version.minor == 0) {
            cancel (new org.omg.CORBA.BAD_OPERATION ("Wchar not supported in IIOP 1.0", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
        }
        else {
            cancel (new org.omg.CORBA.MARSHAL ("Missing wchar encoder.", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
        }
        return;
    }
    byte [] buf;
    int off;
    int len;
    switch (m_version.minor) {
        case 0 :
            cancel (new org.omg.CORBA.MARSHAL ("Wchar not supported in IIOP 1.0", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
            break;
        case 1 :
            alignment (2);
            m_tmp_len.value = 2 * vlen;
            len = m_tmp_len.value;
            next (m_tmp_buf, m_tmp_off, m_tmp_len);
            postread (len - m_tmp_len.value);
            if (m_tmp_len.value != 0) {
                buf = new byte [len];
                off = 0;
                System.arraycopy (m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                read_octet_array (buf, len - m_tmp_len.value, m_tmp_len.value);
                if (m_wchar_reverse) {
                    byte tmp;
                    for (int i = 0; i < len; i += 2) {
                        tmp = buf [i];
                        buf [i] = buf [i + 1];
                        buf [i + 1] = tmp;
                    }
                }
            }
            else if (m_wchar_reverse) {
                buf = new byte [len];
                off = 0;
                for (int i = 0; i < len; i += 2) {
                    buf [0] = m_tmp_buf.value [m_tmp_off.value + i + 1];
                    buf [1] = m_tmp_buf.value [m_tmp_off.value + i];
                }
            }
            else {
                buf = m_tmp_buf.value;
                off = m_tmp_off.value;
            }
            try {
                String s = new String (buf, off, len, m_wchar_enc);
                if (s.length () != vlen) {
                    cancel (new org.omg.CORBA.MARSHAL ("Unable to decode char value", IIOPMinorCodes.MARSHAL_CHAR, CompletionStatus.COMPLETED_MAYBE));
                }
                s.getChars (0, vlen, val, voff);
            } catch (final UnsupportedEncodingException ex) {
                getLogger ().error ("Unsupported encoding should be impossible.", ex);
            }
            return;
        case 2 :
            alignment (1);
            int post = 0;
            for (int c = 0; c < vlen; ++ c) {
                m_tmp_len.value = 1;
                next (m_tmp_buf, m_tmp_off, m_tmp_len);
                len = m_tmp_buf.value [m_tmp_off.value];
                m_tmp_len.value = m_tmp_buf.value [m_tmp_off.value];
                next (m_tmp_buf, m_tmp_off, m_tmp_len);
                if (m_tmp_len.value != 0) {
                    postread (post + len + 1 - m_tmp_len.value);
                    post = 0;
                    buf = new byte [len];
                    off = 0;
                    System.arraycopy (m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                    read_octet_array (buf, len - m_tmp_len.value, m_tmp_len.value);
                    if (m_wchar_reverse) {
                        byte tmp;
                        for (int i = 0; i < m_wchar_align / 2; ++ i) {
                            tmp = buf [off + i];
                            buf [off + i] = buf [off + m_wchar_align - i];
                            buf [off + m_wchar_align - i] = tmp;
                        }
                    }
                }
                else if (m_wchar_reverse) {
                    buf = new byte [len];
                    off = 0;
                    for (int i = 0; i < m_wchar_align; ++ i) {
                        buf [i] = m_tmp_buf.value [m_tmp_off.value + m_wchar_align - 1];
                    }
                }
                else {
                    post += len + 1;
                    buf = m_tmp_buf.value;
                    off = m_tmp_off.value;
                }
                try {
                    String s = new String (buf, off, len, m_wchar_enc);
                    if (s.length () != 1) {
                        cancel (new org.omg.CORBA.MARSHAL ("Unable to decode wchar value", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
                    }
                    val [voff + c] = s.charAt (0);
                } catch (final UnsupportedEncodingException ex) {
                    getLogger ().error ("Unsupported encoding should be impossible.", ex);
                }
            }
            if (post > 0) {
                postread (post);
            }
            break;
    }
}


-----Function Pair=32=-----==

private void init (DistanceMatrix m) {
    numClusters = m.getSize ();
    distance = m.getClonedDistances ();
    for (int i = 0; i < numClusters; i ++) {
        Node tmp = new SimpleNode ();
        tmp.setIdentifier (m.getIdentifier (i));
        getRoot ().addChild (tmp);
    }
    alias = new int [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        alias [i] = i;
    }
    height = new double [numClusters];
    oc = new int [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        height [i] = 0.0;
        oc [i] = 1;
    }
}


private void GenerateOpponentAddShields (int tries) {
    if (getShieldSlots () > 0) {
        int numShields = 0;
        if (Game.CurrentGame ().Difficulty () == Difficulty.Impossible) {
            numShields = getShieldSlots ();
        }
        else {
            numShields = Functions.GetRandom (getShieldSlots () + 1);
            if (numShields < getShieldSlots () && (tries > 3 || (tries > 1 && Functions.GetRandom (2) > 0))) {
                numShields ++;
            }
        }
        for (int i = 0; i < numShields; i ++) {
            int bestShieldType = 0;
            for (int j = 0; j < tries; j ++) {
                int x = Functions.GetRandom (100);
                int sum = Consts.Shields [0].Chance ();
                int shieldType = 0;
                while (sum < x && shieldType <= Consts.Shields.length - 1) {
                    shieldType ++;
                    sum += Consts.Shields [shieldType].Chance ();
                }
                if (! HasShield (Consts.Shields [shieldType].Type ()) && shieldType > bestShieldType) {
                    bestShieldType = shieldType;
                }
            }
            AddEquipment (Consts.Shields [bestShieldType]);
            _shields [i].setCharge (0);
            for (int j = 0; j < 5; j ++) {
                int charge = 1 + Functions.GetRandom (_shields [i].Power ());
                if (charge > _shields [i].getCharge ()) {
                    _shields [i].setCharge (charge);
                }
            }
        }
    }
}


-----Function Pair=33=-----==

public void send (String cmd, JSONObject object) {
    try {
        JSONObject json = new JSONObject ();
        json.put ("CMD", new JSONString (cmd));
        if (nick != null) {
            json.put ("NICK", new JSONString (nick));
        }
        if (hash > 0) {
            json.put ("HASH", new JSONNumber (hash));
        }
        if (object != null) {
            json.put ("BODY", object);
        }
        rb.sendRequest (json.toString (), new RequestCallback () {
            public void onResponseReceived (Request arg0, Response arg1) {
                if (arg1.getStatusCode () == 200) {
                    try {
                        command (JSONParser.parse (arg1.getText ()));
                    } catch (Exception e) {
                        appendText (e.toString ());
                    }
                }
                else if (arg1.getStatusCode () == 403) {
                    errorLabel.setText ("Username is already in use");
                }
            } public void onError (Request arg0, Throwable arg1) {
            }
        }
        );
    } catch (Throwable e) {
        Window.alert ("ERROR ON READ! " + e);
    }
}


private void printHelp (String command) {
    StringBuffer ret = new StringBuffer ();
    if (command.equals ("step") || command.equals ("s")) {
        ret.append ("Format:  < s | step > \n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping into all method invocations\n");
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        ret.append ("Format:  < sbr | stepbr >\n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping over method invocations\n");
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        ret.append ("Format:  < sl | stepline > \n");
        ret.append ("Single step only the current thread by one java source line, stepping into method invocations\n");
        ret.append ("(may need to hit enter twice to step one line because currently jdp may not be able to set precise breakpoints)\n");
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        ret.append ("Format:  < slo | steplineover >\n");
        ret.append ("Single step only the current thread by one java source line, stepping over method invocations\n");
    }
    else if (command.equals ("run")) {
        ret.append ("Format:  < run > <name ... >\n");
        ret.append ("Start a new program\n");
        ret.append ("If no program name is specified, rerun the last program\n");
        ret.append ("All current breakpoints will be set\n");
        ret.append ("The current program must be killed before restarting\n");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        ret.append ("Format:  < k | kill >\n");
        ret.append ("Terminate the current program without exiting the debugger\n");
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        ret.append ("Format:  < ct | cthread > \n");
        ret.append ("Continue only current thread, passing to the program any pending signal\n");
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        ret.append ("Format:  < c | cont > \n");
        ret.append ("Continue all threads, passing to the program any pending signal\n");
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        ret.append ("Format:  < cr | creturn >\n");
        ret.append ("continue only current thread to the end of this method \n");
        ret.append ("(i.e. go up one stack frame)\n");
    }
    else if (command.equals ("where") || command.equals ("w")) {
        ret.append ("Format:  < w | where > < from | to > <hexval>\n");
        ret.append ("Display stack trace\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
        ret.append ("If we are in the prolog code, the stack frame is being constructed\n");
        ret.append ("so a place holder will be shown for the frame\n");
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        ret.append ("Format:  < wf | whereframe > < from | to > <hexval>\n");
        ret.append ("Display stack trace with arguments, local variables, temporary variables for each stack frame\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
    }
    else if (command.equals ("reg") || command.equals ("r") || command.equals ("wreg") || command.equals ("wr")) {
        ret.append ("Format 1:  < r | reg > <num|name> <count>\n");
        ret.append ("Format 2:  < wr | wreg > <num|name> <hexval>\n");
        ret.append ("Display/update hardware registers (not thread context registers)\n");
        ret.append ("Specify register by number:  0-31, 128-136, 138, 148, 256-287\n");
        ret.append ("or by names: \n");
        String regname = "";
        for (int i = 0; i < VM_BaselineConstants.GPR_NAMES.length; i ++) regname += VM_BaselineConstants.GPR_NAMES [i] + " ";
        ret.append (regname);
        regname = "";
        for (int i = 0; i < VM_BaselineConstants.FPR_NAMES.length; i ++) regname += VM_BaselineConstants.FPR_NAMES [i] + " ";
        ret.append (regname);
        ret.append ("IP LR\n");
    }
    else if (command.equals ("mem") || command.equals ("m") || command.equals ("wmem") || command.equals ("wm") || command.equals ("memraw") || command.equals ("mraw")) {
        ret.append ("Format 1:  < m | mem > <hexaddr> <count>\n");
        ret.append ("Format 2:  < wm | wmem > <hexaddr> <hexvalue>\n");
        ret.append ("Format 3:  < mraw | memraw > <hexaddr> <hexvalue>\n");
        ret.append ("Display/update memory at this address\n");
        ret.append ("If count is not specified, 5 words will be displayed\n");
        ret.append ("For mem and wmem, the breakpoints are transparent\n");
        ret.append ("For memraw, the actual memory contents are shown with the breakpoints as is (intended for debugging jdp)\n");
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        ret.append ("Format 1:   < pc | printclass> <class><.field><[n]>\n");
        ret.append ("Print the static fields for this class\n");
        ret.append ("(including super classes up to but not including java.lang.Object)\n");
        ret.append ("For array, specify an individual element or omit the rightmost dimension \nto display the full dimension\n");
        ret.append ("The variable name can be nested arbitrarily\n");
        ret.append ("Example:\n");
        ret.append ("   pc class                         print the static variables\n");
        ret.append ("   pc class.field                   print this field\n");
        ret.append ("   pc class.array[2]                print this array element\n");
        ret.append ("   pc class.field1.array[4].field2  nested expression\n\n");
        ret.append ("Format 2:   < pc | printclass> <hexaddr>\n");
        ret.append ("   pc 01234567                      print the type for this address\n\n");
    }
    else if (command.equals ("print") || command.equals ("p")) {
        ret.append ("Format 1:   < p | print> frame<:localvar><.field><[n]>\n");
        ret.append ("Print the content of a local variable in this stack frame;\n");
        ret.append ("If no name is specified, all locals in the current scope are printed\n");
        ret.append ("The name can be the string this to print the current object\n");
        ret.append ("Example:\n");
        ret.append ("   p 0                             print all locals in frame 0\n");
        ret.append ("   p this                          print the current object in frame 0\n");
        ret.append ("   p 1:mylocal.field1              print this local variable in frame 1\n\n");
        ret.append ("Format 2:   < p | print> (classname) hexaddress\n");
        ret.append ("Cast the address as an instance of this class\n");
        ret.append ("and print the contents \n\n");
        ret.append ("Format 3:   < p | print><@class.staticvar>\n");
        ret.append ("Print the address of a static variable for this class\n");
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        ret.append ("Format:  < lb | listb > <hexaddr>\n");
        ret.append ("Dissassemble the bytecodes of the method containing this address\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("(this command has been removed because the Optimizing compiler does not generate the bytecode information)\n");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        ret.append ("Format:  < li | listi > <hexaddr><count>\n");
        ret.append ("Dissassemble the machine instruction in this range of addresses\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("Default count is 10\n");
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        ret.append ("Format:  < lt | listt > <all|byname|run|ready|wakeup|system|gc>\n");
        ret.append ("List the threads, select the type of thread by:\n");
        ret.append ("  all      all threads listed by top stack frame\n");
        ret.append ("  byname   all threads listed by thread class name\n");
        ret.append ("  run      threads currently loaded in the system threads\n");
        ret.append ("  ready    threads in the VM_Scheduler ready queue\n");
        ret.append ("  wakeup   threads in the VM_Scheduler wakeup queue\n");
        ret.append ("  system   dump the state of the system threads\n");
        ret.append ("  gc       garbage collector threads\n");
        ret.append ("Annotation: \n");
        ret.append ("  threads loaded in system thread are indicated by >\n");
        ret.append ("  the current thread in which the debugger stops is indicated by ->\n");
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        ret.append ("Format:  < th | thread > <threadID|off>\n");
        ret.append ("Select a thread context by its ID \n");
        ret.append ("(this is a small integer, get all current thread ID by the listt command)\n");
        ret.append ("The new thread context will be shown in the jdp prompt\n");
        ret.append ("and all future stack and local display will be for this thread\n");
        ret.append ("If no ID is specified, the context is returned to the current thread in which the debugger has stopped\n");
        ret.append ("To force jdp to use the context in the hardware register, specify an ID of 0 or OFF; jdp will stay there until the context is set manually to a valid thread ID\n");
        ret.append ("jdp will start in the OFF thread (i.e. no thread context)\n");
    }
    else if (command.equals ("break") || command.equals ("b")) {
        ret.append ("Format:  < b ><hexaddr><class.method:line sig>\n");
        ret.append ("Set breakpoint by hex address or symbolic name \n");
        ret.append ("With no argument, the list of current breakpoints is shown\n");
        ret.append ("For symbolic name, jdp will attempt to match partial names\n");
        ret.append ("The method prolog is skipped;  to break at the start of the prolog, \nspecify 0 for the line number\n");
        ret.append ("example:\n");
        ret.append ("   b                        list current breakpoints\n");
        ret.append ("   b 0123abcd               at this hex address\n");
        ret.append ("   b class:line             at java source line in class\n");
        ret.append ("   b method                 at start of method, skipping prolog\n");
        ret.append ("   b class.method           at start of method, skipping prolog\n");
        ret.append ("   b class.method sig       for overloaded method\n");
        ret.append ("   b class.method:0         at start of method prolog\n");
        ret.append ("the class file must be generated with -g to get the line number\n");
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        ret.append ("Format:  < cb ><hexaddr|all> \n");
        ret.append ("Clear breakpoint at the hex address or all breakpoint\n");
        ret.append ("(type b to get the list of current breakpoints)\n");
        ret.append ("If no address is specified, clear breakpoint at the current instruction\n");
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        ret.append ("Format:  < f | stack > <hexval> <n>\n");
        ret.append ("Display current JVM stack \n");
        ret.append ("showing n words at the top and bottom, the default is 4 words\n");
        ret.append ("The value for Frame Pointer may be specified in <hexval>\n");
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        ret.append ("Format:  < preference | pref> <string>\n");
        ret.append ("Set user preferences\n");
        ret.append ("To display integer in hex or decimal, specify:  int  < hex | x | dec | d > \n");
        ret.append ("To display stack with/without a decimal column, specify: stack < hex | x | dec | d > \n");
        ret.append ("To display floating point register in hex or float, specify:  fpr  < hex | x | float | f > ");
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        ret.append ("Format:  < v | verbose >\n");
        ret.append ("Toggle verbose mode on and off\n");
        ret.append ("In verbose, the current stack frame is automatically displayed\n");
    }
    else if (command.equals ("macro")) {
        ret.append ("Format:  <your macro name>\n");
        ret.append ("jdp will search for the named file with the .jdp suffix in the current class path\n");
        ret.append ("Each line is read and executed it as if it is entered from the command line\n");
        ret.append ("The file should contain normal jdp commands\n");
        ret.append ("On start up, jdp will look for the file startup.jdp in the current directory\n");
        ret.append ("If it exists, it will be loaded and executed automatically\n");
    }
    else if (command.equals ("q") || command.equals ("quit")) {
        ret.append ("Format:  <q | quit>\n");
        ret.append ("Exit debugger\n");
    }
    else if (command.equals ("enter")) {
        ret.append ("Format:  (enter)\n");
        ret.append ("Repeat last command\n");
    }
    else {
        ret.append ("step          step current thread by instruction, into method\n");
        ret.append ("stepbr        step current thread by instruction, over method\n");
        ret.append ("stepline      step current thread by java source line, into method \n");
        ret.append ("steplineover  step current thread by java source line, over method \n");
        ret.append ("creturn       continue to last caller \n");
        ret.append ("cthread       continue current thread only\n");
        ret.append ("cont          continue all threads\n");
        ret.append ("kill          terminate program \n");
        ret.append ("run           start new program \n");
        ret.append ("break         list/set breakpoint \n");
        ret.append ("clearbreak    clear breakpoints \n\n");
        ret.append ("thread        set or turn off thread context\n");
        ret.append ("where         print short stack trace \n");
        ret.append ("whereframe    print full stack trace \n");
        ret.append ("stack         display formatted stack \n");
        ret.append ("mem           display memory\n");
        ret.append ("memraw        display actual memory, jdp breakpoints visible\n");
        ret.append ("wmem          write memory \n");
        ret.append ("reg           display registers \n");
        ret.append ("wreg          write register \n");
        ret.append ("printclass    print the class statics or the type of an object address\n");
        ret.append ("print         print local variables or cast an address as an object\n");
        ret.append ("listi         list machine instruction\n");
        ret.append ("listt         list threads\n\n");
        ret.append ("quit          exit debugger\n");
        ret.append ("preference    set user preference\n");
        ret.append ("verbose       toggle verbose mode\n");
        ret.append ("(macro name)  load and execute this macro (a text file with suffix .jdp)\n");
        ret.append ("x2d, d2x      convert number between hex and decimal\n");
        ret.append ("(enter)       repeat last command\n\n");
        ret.append ("To get more information on a specific command, type: \n \thelp thiscommand\n");
    }
    jdp_console.writeOutput (ret.toString ());
}


-----Function Pair=34=-----==

private void insert (int left, int right, int index) {
    if (index > 0) {
        Scan prevScan = scans [index - 1];
        if (prevScan.right == left - 1) {
            prevScan.right = right;
            return;
        }
    }
    if (length == scans.length) {
        growCapacity ();
    }
    Scan last = scans [length];
    last.setTo (left, right);
    for (int i = length; i > index; i --) {
        scans [i] = scans [i - 1];
    }
    scans [index] = last;
    length ++;
}


private static final int partition (Sortable [] list, int p, int r) {
    int i = p - 1;
    Sortable tmp, x = list [r];
    for (int j = p; j < r; j ++) {
        if (x.greater_than (list [j])) {
            i ++;
            tmp = list [i];
            list [i] = list [j];
            list [j] = tmp;
        }
    }
    i ++;
    tmp = list [i];
    list [i] = list [r];
    list [r] = tmp;
    return i;
}


-----Function Pair=35=-----==

String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=36=-----==

private int nextLesserThan8Bits (int bitsToGet) {
    byte b, next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = data [bp + 1];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
        }
    }
    else {
        throw new Error ("TIFFFaxDecoder7");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int shift = bitsLeft - bitsToGet;
    int i1, i2;
    if (shift >= 0) {
        i1 = (b & table1 [bitsLeft])>>> shift;
        bitPointer += bitsToGet;
        if (bitPointer == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
    }
    else {
        i1 = (b & table1 [bitsLeft]) << (- shift);
        i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
        i1 |= i2;
        bytePointer ++;
        bitPointer = bitsFromNextByte;
    }
    return i1;
}


private static final void dremake_heap (double key [], double trail [], int parent_index, int last_index) {
    int last_parent_pos = (last_index - 1) / 2;
    int last_parent_index = last_parent_pos;
    int l_child, r_child, max_child_index;
    int parent_temp = parent_index;
    double tkey, ttrail;
    while (parent_temp <= last_parent_index) {
        l_child = parent_temp * 2 + 1;
        if (l_child == last_index) max_child_index = l_child;
        else {
            r_child = l_child + 1;
            max_child_index = key [l_child] > key [r_child] ? l_child : r_child;
        }
        if (key [max_child_index] > key [parent_temp]) {
            tkey = key [max_child_index];
            key [max_child_index] = key [parent_temp];
            key [parent_temp] = tkey;
            ttrail = trail [max_child_index];
            trail [max_child_index] = trail [parent_temp];
            trail [parent_temp] = ttrail;
            parent_temp = max_child_index;
        }
        else break;
    }
}


-----Function Pair=37=-----==

public boolean removeAll (double [] c) {
    HashMap < Double, Integer > table = new HashMap ();
    int [] indeces = new int [c.length];
    for (int i = 0; i < c.length; i ++) {
        int index;
        if (table.containsKey (c [i])) {
            index = indexOf (c [i], table.get (c [i]) + 1);
        }
        else {
            index = indexOf (c [i]);
        }
        table.put (c [i], index);
        indeces [i] = index;
    }
    int p = 0, q = 0, i = 0, count = 0;
    while (indeces [i] == - 1 && i < length) {
        i ++;
    }
    if (i < length) count ++;
    p = i;
    q = i + 1;
    while (i < indeces.length) {
        do {
            i ++;
        }
        while (indeces [i] == - 1 && i < length);
        if (i < length) count ++;
        while (q < i) {
            values [p] = values [q];
            q ++;
            p ++;
        }
    }
    length -= count;
    findMean ();
    findMedian ();
    findMode ();
    findDeviation ();
    return count > 0;
}


public int map (int b, int g, int r) {
    int i, j, dist, a, bestd;
    int [] p;
    int best;
    bestd = 1000;
    best = - 1;
    i = netindex [g];
    j = i - 1;
    while ((i < netsize) || (j >= 0)) {
        if (i < netsize) {
            p = network [i];
            dist = p [1] - g;
            if (dist >= bestd) i = netsize;
            else {
                i ++;
                if (dist < 0) dist = - dist;
                a = p [0] - b;
                if (a < 0) a = - a;
                dist += a;
                if (dist < bestd) {
                    a = p [2] - r;
                    if (a < 0) a = - a;
                    dist += a;
                    if (dist < bestd) {
                        bestd = dist;
                        best = p [3];
                    }
                }
            }
        }
        if (j >= 0) {
            p = network [j];
            dist = g - p [1];
            if (dist >= bestd) j = - 1;
            else {
                j --;
                if (dist < 0) dist = - dist;
                a = p [0] - b;
                if (a < 0) a = - a;
                dist += a;
                if (dist < bestd) {
                    a = p [2] - r;
                    if (a < 0) a = - a;
                    dist += a;
                    if (dist < bestd) {
                        bestd = dist;
                        best = p [3];
                    }
                }
            }
        }
    }
    return (best);
}


-----Function Pair=38=-----==

private static SkEdge2D find_appropriate_edge (LinkedList linkedlist, SkEdge2D skedge2d, SkVertex2D skvertex2d) {
    Vector2 vector2 = skedge2d.vector2 ();
    if (((Edge2D) (skedge2d)).start != skvertex2d) vector2.multiple_self (- 1D);
    SkEdge2D skedge2d1 = null;
    double d = 360D;
    for (Enumeration enumeration = linkedlist.elements (); enumeration.hasMoreElements ();) {
        SkEdge2D skedge2d2 = (SkEdge2D) enumeration.nextElement ();
        Vector2 vector2_1 = skedge2d2.vector2 ();
        if (((Edge2D) (skedge2d2)).start != skvertex2d) vector2_1.multiple_self (- 1D);
        double d1 = vector2.get_angle (vector2_1);
        if (d1 < d) {
            d = d1;
            skedge2d1 = skedge2d2;
        }
    }
    return skedge2d1;
}


public static Object newMsg (Object [] _p) {
    FooLib.checkClassArgument (Class.class, _p [0], 0);
    Class c = (Class) _p [0];
    if (c.isArray ()) {
        int l = _p.length - 1;
        int [] d = new int [l];
        for (int i = 0; i < l; i ++) {
            c = c.getComponentType ();
            d [i] = FooLib.toInteger (_p [i + 1]).intValue ();
        }
        return Array.newInstance (c, d);
    }
    Constructor m = FooLib.getConstructor (c, c.getName (), _p.length - 1);
    if (m == null) {
        StringBuffer s = new StringBuffer (c.getName () + "(");
        for (int j = 0; j < _p.length; j ++) {
            if (j > 0) s.append (',');
            s.append (FooLib.getClassName (_p [j]));
        }
        s.append (')');
        throw new RuntimeException ("constructor not found:" + s);
    }
    Object [] q = new Object [_p.length - 1];
    for (int i = 0; i < q.length; i ++) q [i] = _p [i + 1];
    return FooLib.invokeConstructor (m, q);
}


-----Function Pair=39=-----==

private void setToBlack (byte [] buffer, int lineOffset, int bitOffset, int numBits) {
    int bitNum = 8 * lineOffset + bitOffset;
    int lastBit = bitNum + numBits;
    int byteNum = bitNum>> 3;
    int shift = bitNum & 0x7;
    if (shift > 0) {
        int maskVal = 1 << (7 - shift);
        byte val = buffer [byteNum];
        while (maskVal > 0 && bitNum < lastBit) {
            val |= maskVal;
            maskVal>>= 1;
            ++ bitNum;
        }
        buffer [byteNum] = val;
    }
    byteNum = bitNum>> 3;
    while (bitNum < lastBit - 7) {
        buffer [byteNum ++] = (byte) 255;
        bitNum += 8;
    }
    while (bitNum < lastBit) {
        byteNum = bitNum>> 3;
        buffer [byteNum] |= 1 << (7 - (bitNum & 0x7));
        ++ bitNum;
    }
}


public void read_wchar_array (char [] val, int voff, int vlen) {
    if (0 == vlen) {
        return;
    }
    if (m_wchar_enc == null) {
        if (m_version.minor == 0) {
            cancel (new org.omg.CORBA.BAD_OPERATION ("Wchar not supported in IIOP 1.0", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
        }
        else {
            cancel (new org.omg.CORBA.MARSHAL ("Missing wchar encoder.", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
        }
        return;
    }
    byte [] buf;
    int off;
    int len;
    switch (m_version.minor) {
        case 0 :
            cancel (new org.omg.CORBA.MARSHAL ("Wchar not supported in IIOP 1.0", IIOPMinorCodes.BAD_OPERATION_IIOP_VERSION, CompletionStatus.COMPLETED_MAYBE));
            break;
        case 1 :
            alignment (2);
            m_tmp_len.value = 2 * vlen;
            len = m_tmp_len.value;
            next (m_tmp_buf, m_tmp_off, m_tmp_len);
            postread (len - m_tmp_len.value);
            if (m_tmp_len.value != 0) {
                buf = new byte [len];
                off = 0;
                System.arraycopy (m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                read_octet_array (buf, len - m_tmp_len.value, m_tmp_len.value);
                if (m_wchar_reverse) {
                    byte tmp;
                    for (int i = 0; i < len; i += 2) {
                        tmp = buf [i];
                        buf [i] = buf [i + 1];
                        buf [i + 1] = tmp;
                    }
                }
            }
            else if (m_wchar_reverse) {
                buf = new byte [len];
                off = 0;
                for (int i = 0; i < len; i += 2) {
                    buf [0] = m_tmp_buf.value [m_tmp_off.value + i + 1];
                    buf [1] = m_tmp_buf.value [m_tmp_off.value + i];
                }
            }
            else {
                buf = m_tmp_buf.value;
                off = m_tmp_off.value;
            }
            try {
                String s = new String (buf, off, len, m_wchar_enc);
                if (s.length () != vlen) {
                    cancel (new org.omg.CORBA.MARSHAL ("Unable to decode char value", IIOPMinorCodes.MARSHAL_CHAR, CompletionStatus.COMPLETED_MAYBE));
                }
                s.getChars (0, vlen, val, voff);
            } catch (final UnsupportedEncodingException ex) {
                getLogger ().error ("Unsupported encoding should be impossible.", ex);
            }
            return;
        case 2 :
            alignment (1);
            int post = 0;
            for (int c = 0; c < vlen; ++ c) {
                m_tmp_len.value = 1;
                next (m_tmp_buf, m_tmp_off, m_tmp_len);
                len = m_tmp_buf.value [m_tmp_off.value];
                m_tmp_len.value = m_tmp_buf.value [m_tmp_off.value];
                next (m_tmp_buf, m_tmp_off, m_tmp_len);
                if (m_tmp_len.value != 0) {
                    postread (post + len + 1 - m_tmp_len.value);
                    post = 0;
                    buf = new byte [len];
                    off = 0;
                    System.arraycopy (m_tmp_buf.value, m_tmp_off.value, buf, 0, len - m_tmp_len.value);
                    read_octet_array (buf, len - m_tmp_len.value, m_tmp_len.value);
                    if (m_wchar_reverse) {
                        byte tmp;
                        for (int i = 0; i < m_wchar_align / 2; ++ i) {
                            tmp = buf [off + i];
                            buf [off + i] = buf [off + m_wchar_align - i];
                            buf [off + m_wchar_align - i] = tmp;
                        }
                    }
                }
                else if (m_wchar_reverse) {
                    buf = new byte [len];
                    off = 0;
                    for (int i = 0; i < m_wchar_align; ++ i) {
                        buf [i] = m_tmp_buf.value [m_tmp_off.value + m_wchar_align - 1];
                    }
                }
                else {
                    post += len + 1;
                    buf = m_tmp_buf.value;
                    off = m_tmp_off.value;
                }
                try {
                    String s = new String (buf, off, len, m_wchar_enc);
                    if (s.length () != 1) {
                        cancel (new org.omg.CORBA.MARSHAL ("Unable to decode wchar value", IIOPMinorCodes.MARSHAL_WCHAR, CompletionStatus.COMPLETED_MAYBE));
                    }
                    val [voff + c] = s.charAt (0);
                } catch (final UnsupportedEncodingException ex) {
                    getLogger ().error ("Unsupported encoding should be impossible.", ex);
                }
            }
            if (post > 0) {
                postread (post);
            }
            break;
    }
}


-----Function Pair=40=-----==

private static double evaluateInternal (double x [], double y [], double z) {
    int nearest = 0;
    final int n = x.length;
    final double [] c = new double [n];
    final double [] d = new double [n];
    double min_dist = Double.POSITIVE_INFINITY;
    for (int i = 0; i < n; i ++) {
        c [i] = y [i];
        d [i] = y [i];
        final double dist = FastMath.abs (z - x [i]);
        if (dist < min_dist) {
            nearest = i;
            min_dist = dist;
        }
    }
    double value = y [nearest];
    for (int i = 1; i < n; i ++) {
        for (int j = 0; j < n - i; j ++) {
            final double tc = x [j] - z;
            final double td = x [i + j] - z;
            final double divider = x [j] - x [i + j];
            final double w = (c [j + 1] - d [j]) / divider;
            c [j] = tc * w;
            d [j] = td * w;
        }
        if (nearest < 0.5 * (n - i + 1)) {
            value += c [nearest];
        }
        else {
            nearest --;
            value += d [nearest];
        }
    }
    return value;
}


void copyByLine (BufferedImage bi, int depthIndex, boolean swapNeeded) {
    int h;
    int srcBegin, dstBegin;
    int unitsPerRow = width * unitsPerPixel;
    int copyUnits = unitsPerRow;
    if (yUp) {
        srcBegin = (depthIndex * width * height) * unitsPerPixel;
    }
    else {
        srcBegin = (depthIndex * width * height + (height - 1) * width) * unitsPerPixel;
        unitsPerRow = - 1 * unitsPerRow;
    }
    dstBegin = 0;
    switch (imageData.getType ()) {
        case TYPE_BYTE_ARRAY :
            byte [] dstByteBuffer = ((DataBufferByte) bi.getRaster ().getDataBuffer ()).getData ();
            byte [] srcByteBuffer = imageData.getAsByteArray ();
            for (h = 0; h < height; h ++) {
                if (! swapNeeded) {
                    System.arraycopy (srcByteBuffer, srcBegin, dstByteBuffer, dstBegin, copyUnits);
                }
                else {
                    if (imageFormatType == ImageFormatType.TYPE_BYTE_RGB) {
                        assert (unitsPerPixel == 3);
                        for (int w = 0; w < copyUnits; w += unitsPerPixel) {
                            dstByteBuffer [dstBegin + w] = srcByteBuffer [srcBegin + w + 2];
                            dstByteBuffer [dstBegin + w + 1] = srcByteBuffer [srcBegin + w + 1];
                            dstByteBuffer [dstBegin + w + 2] = srcByteBuffer [srcBegin + w];
                        }
                    }
                    else if (imageFormatType == ImageFormatType.TYPE_BYTE_RGBA) {
                        assert (unitsPerPixel == 4);
                        for (int w = 0; w < copyUnits; w += unitsPerPixel) {
                            dstByteBuffer [dstBegin + w] = srcByteBuffer [srcBegin + w + 3];
                            dstByteBuffer [dstBegin + w + 1] = srcByteBuffer [srcBegin + w + 2];
                            dstByteBuffer [dstBegin + w + 2] = srcByteBuffer [srcBegin + w + 1];
                            dstByteBuffer [dstBegin + w + 3] = srcByteBuffer [srcBegin + w];
                        }
                    }
                    else {
                        assert false;
                    }
                }
                dstBegin += copyUnits;
                srcBegin += unitsPerRow;
            }
            break;
        case TYPE_INT_ARRAY :
            assert (! swapNeeded);
            int [] dstIntBuffer = ((DataBufferInt) bi.getRaster ().getDataBuffer ()).getData ();
            int [] srcIntBuffer = imageData.getAsIntArray ();
            for (h = 0; h < height; h ++) {
                System.arraycopy (srcIntBuffer, srcBegin, dstIntBuffer, dstBegin, copyUnits);
                dstBegin += copyUnits;
                srcBegin += unitsPerRow;
            }
            break;
        default :
            assert false;
    }
}


-----Function Pair=41=-----==

public void insert (Widget w, int beforeIndex) {
    if ((beforeIndex < 0) || (beforeIndex > size)) {
        throw new IndexOutOfBoundsException ();
    }
    if (size == array.length) {
        Widget [] newArray = new Widget [array.length * 2];
        for (int i = 0; i < array.length; ++ i) {
            newArray [i] = array [i];
        }
        array = newArray;
    }
    ++ size;
    for (int i = size - 1; i > beforeIndex; -- i) {
        array [i] = array [i - 1];
    }
    array [beforeIndex] = w;
}


public static void pcm162alaw (byte [] buffer, int byteOffset, int sampleCount, boolean bigEndian) {
    int shortIndex = byteOffset;
    int alawIndex = shortIndex;
    if (bigEndian) {
        while (sampleCount > 0) {
            buffer [alawIndex ++] = linear2alaw (bytesToShort16 (buffer [shortIndex], buffer [shortIndex + 1]));
            shortIndex ++;
            shortIndex ++;
            sampleCount --;
        }
    }
    else {
        while (sampleCount > 0) {
            buffer [alawIndex ++] = linear2alaw (bytesToShort16 (buffer [shortIndex + 1], buffer [shortIndex]));
            shortIndex ++;
            shortIndex ++;
            sampleCount --;
        }
    }
}


-----Function Pair=42=-----==

private NodeValueList calculateHierarchicalTree (int [] features, int method, boolean genes, boolean experiments) throws AlgorithmException {
    NodeValueList nodeList = new NodeValueList ();
    AlgorithmData data = new AlgorithmData ();
    FloatMatrix experiment;
    if (kmcGenes) experiment = getSubExperiment (this.expMatrix, features);
    else experiment = getSubExperimentReducedCols (this.expMatrix, features);
    data.addMatrix ("experiment", experiment);
    data.addParam ("hcl-distance-function", String.valueOf (this.hcl_function));
    data.addParam ("hcl-distance-absolute", String.valueOf (this.hcl_absolute));
    data.addParam ("method-linkage", String.valueOf (method));
    HCL hcl = new HCL ();
    AlgorithmData result;
    if (genes) {
        data.addParam ("calculate-genes", String.valueOf (true));
        result = hcl.execute (data);
        validate (result);
        addNodeValues (nodeList, result);
    }
    if (experiments) {
        data.addParam ("calculate-genes", String.valueOf (false));
        result = hcl.execute (data);
        validate (result);
        addNodeValues (nodeList, result);
    }
    return nodeList;
}


private void parseRunArgs (String args []) {
    String bootimage = null;
    int i;
    for (i = 0; i < args.length; i ++) {
        if (args [i].equals ("-n")) {
            classesNeededFilename = args [++ i];
        }
        else if (args [i].equals ("-classpath")) {
            classpath = args [++ i];
        }
        else if (args [i].equals ("-i")) {
            bootimage = args [++ i];
        }
        else {
            break;
        }
    }
    if (classpath == null) {
        jdp_console.writeOutput ("ERROR:  no classpath, static fields will be incorrect");
    }
    if (classesNeededFilename == null) {
        jdp_console.writeOutput ("ERROR: no classesNeeded file, line number will not be correct");
        return;
    }
    if (bootimage != null) {
        saved_progname = bootimage;
        bi_args = new String [args.length - i + 2];
        int j = 0;
        bi_args [j ++] = bi_runner;
        bi_args [j ++] = "-X:i=" + bootimage;
        for (int k = i; k < args.length; k ++) {
            bi_args [j ++] = args [k];
        }
    }
    else {
        saved_progname = args [args.length - 1];
        bi_args = new String [2];
        bi_args [0] = bi_runner;
        bi_args [1] = saved_progname;
    }
}


-----Function Pair=43=-----==

private static LinkedList delauny (Vertex avertex []) {
    LinkedList linkedlist = new LinkedList ();
    for (int i = 0; i < steps * 3; i ++) {
        Vertex avertex1 [] = new Vertex [3];
        avertex1 [0] = avertex [i];
        avertex1 [1] = avertex [i + 1];
        avertex1 [2] = delauny_sub (avertex, avertex [i], avertex [i + 1]);
        if ((i <= 0 || ! avertex1 [2].same_position (avertex [i - 1])) && (i != 0 || ! avertex1 [2].same_position (avertex [steps * 3 - 1]))) linkedlist.append (avertex1);
    }
    if (linkedlist.size () == 10) return linkedlist;
    Enumeration enumeration = linkedlist.elements ();
    Vertex avertex5 [] = new Vertex [3];
    while (enumeration.hasMoreElements ()) {
        Vertex avertex2 [] = (Vertex []) enumeration.nextElement ();
        Vertex vertex = avertex2 [2];
        if (get_origin (avertex, vertex) == 1) {
            avertex5 [0] = avertex2 [0];
            break;
        }
    }
    while (enumeration.hasMoreElements ()) {
        Vertex avertex3 [] = (Vertex []) enumeration.nextElement ();
        Vertex vertex1 = avertex3 [2];
        if (get_origin (avertex, vertex1) == 2) {
            avertex5 [1] = avertex3 [0];
            break;
        }
    }
    while (enumeration.hasMoreElements ()) {
        Vertex avertex4 [] = (Vertex []) enumeration.nextElement ();
        Vertex vertex2 = avertex4 [2];
        if (get_origin (avertex, vertex2) == 0) {
            avertex5 [2] = avertex4 [0];
            linkedlist.append (avertex5);
            break;
        }
    }
    return linkedlist;
}


public Object clone () throws CloneNotSupportedException {
    IAtom [] newAtoms;
    IAtomContainer clone = (IAtomContainer) super.clone ();
    clone.removeAllElements ();
    for (int f = 0; f < getAtomCount (); f ++) {
        clone.addAtom ((IAtom) getAtom (f).clone ());
    }
    IBond bond;
    IBond newBond;
    for (int i = 0; i < getBondCount (); ++ i) {
        bond = getBond (i);
        newBond = (IBond) bond.clone ();
        newAtoms = new IAtom [bond.getAtomCount ()];
        for (int j = 0; j < bond.getAtomCount (); ++ j) {
            newAtoms [j] = clone.getAtom (getAtomNumber (bond.getAtom (j)));
        }
        newBond.setAtoms (newAtoms);
        clone.addBond (newBond);
    }
    ILonePair lp;
    ILonePair newLp;
    for (int i = 0; i < getLonePairCount (); ++ i) {
        lp = getLonePair (i);
        newLp = (ILonePair) lp.clone ();
        if (lp.getAtom () != null) {
            newLp.setAtom (clone.getAtom (getAtomNumber (lp.getAtom ())));
        }
        clone.addLonePair (newLp);
    }
    ISingleElectron se;
    ISingleElectron newSe;
    for (int i = 0; i < getSingleElectronCount (); ++ i) {
        se = getSingleElectron (i);
        newSe = (ISingleElectron) se.clone ();
        if (se.getAtom () != null) {
            newSe.setAtom (clone.getAtom (getAtomNumber (se.getAtom ())));
        }
        clone.addSingleElectron (newSe);
    }
    return clone;
}


-----Function Pair=44=-----==

public void layout () {
    if (mustRecalculate) recalculate ();
    Dimension external = getSize ();
    W = external.width;
    H = external.height;
    int x = lineWidth + internalMargin;
    int y = Z + 1 + internalMargin;
    int w = W - 2 * (lineWidth + internalMargin);
    int h = H - Z - 2 * (lineWidth + internalMargin);
    tabPanel.setBounds (x, y, w, h);
    tabPanel.validate ();
    Component [] c = getComponents ();
    int bx = external.width;
    for (int i = c.length - 1; i >= 0; -- i) if (c [i] != tabPanel && c [i].isVisible ()) {
        Dimension d = c [i].getPreferredSize ();
        bx -= d.width;
        c [i].setBounds (bx, 0, d.width, d.height);
        bx -= BUTTON_GUTTER;
    }
}


public double columnResponseExplanation (PaceMatrix b, IntVector pvt, int j, int ks) {
    int k, l;
    double [] xxx = new double [n];
    int [] p = pvt.getArray ();
    double val;
    if (j == ks - 1) val = b.A [j] [0];
    else if (j > ks - 1) {
        int jm = Math.min (n - 1, j);
        DoubleVector u = getColumn (ks, jm, p [j]);
        DoubleVector v = b.getColumn (ks, jm, 0);
        val = v.innerProduct (u) / u.norm2 ();
    }
    else {
        for (k = j + 1; k < ks; k ++) xxx [k] = A [j] [p [k]];
        val = b.A [j] [0];
        double [] cs;
        for (k = j + 1; k < ks; k ++) {
            cs = g1 (xxx [k], A [k] [p [k]]);
            for (l = k + 1; l < ks; l ++) xxx [l] = - cs [1] * xxx [l] + cs [0] * A [k] [p [l]];
            val = - cs [1] * val + cs [0] * b.A [k] [0];
        }
    }
    return val * val;
}


-----Function Pair=45=-----==

public double calcMassAlignmentError () {
    int totNrPeaks = 0;
    for (PeakList spectrum : spectra) {
        totNrPeaks += spectrum.size ();
    }
    double [] masses = new double [totNrPeaks];
    double [] mzDiffSingle = new double [totNrPeaks];
    double [] mzDiffComb = new double [totNrPeaks];
    int pos = 0;
    int j = 0;
    for (PeakList spectrum : spectra) {
        double [] mz = ((PeakListImpl) spectrum).getMzs (masses, pos);
        pos += spectrum.size ();
        for (int i = 1; i < mz.length; i ++) {
            mzDiffSingle [j] = mz [i] - mz [i - 1];
            j ++;
        }
    }
    for (; j < totNrPeaks; j ++) mzDiffSingle [j] = 10000.0;
    Arrays.sort (mzDiffSingle);
    Arrays.sort (masses);
    double lambda = 0;
    int cnt = 0;
    for (int i = 0; i < masses.length - 1; i ++) {
        mzDiffComb [i] = masses [i + 1] - masses [i];
        if (mzDiffComb [i] < specAlignMZTol) {
            lambda += mzDiffComb [i];
            cnt ++;
        }
    }
    lambda = lambda / cnt;
    if (cnt < 10) {
        throw new IllegalStateException ("Not enough matching peaks between spectra!");
    }
    double th = - lambda * Math.log (0.01);
    cnt = 0;
    for (int i = 0; mzDiffSingle [i] < th; i ++) cnt ++;
    if (cnt / spectra.size () > 5) {
        throw new IllegalStateException ("Peaks within same spectrum are too close!");
    }
    return th;
}


public Extremes getLocalExtremes (int windowsize) {
    Extremes extremes = new Extremes ();
    if (windowsize >= this.getSize () || windowsize <= 2) return extremes;
    int size = (int) (windowsize / 2.);
    double window1 [] = new double [size];
    double window2 [] = new double [size];
    for (int i = 0; i < size; ++ i) window1 [i] = yvals [0];
    for (int i = 0; i < size; ++ i) window2 [i] = yvals [i + 1];
    double prev = - 1;
    for (int i = 0; i < getSize (); ++ i) {
        double mean1 = 0;
        for (int j = 1; j < size; ++ j) mean1 += window1 [j - 1] - window1 [j];
        mean1 /= size;
        double mean2 = 0;
        for (int j = 1; j < size; ++ j) mean2 += window2 [j - 1] - window2 [j];
        mean2 /= size;
        double val = (mean1 + mean2) / 2.;
        if (prev != - 1 && prev > 0 && val < 0) extremes.minima.add (xvals [i - 1]);
        else if (prev != - 1 && prev < 0 && val > 0) extremes.maxima.add (xvals [i - 1]);
        prev = val;
        for (int j = 1; j < size; ++ j) {
            window1 [j - 1] = window1 [j];
            window2 [j - 1] = window2 [j];
        }
        window1 [size - 1] = yvals [i];
        if (i + size >= getSize () - 1) window2 [size - 1] = yvals [yvals.length - 1];
        else window2 [size - 1] = yvals [i + size + 1];
    }
    return extremes;
}


-----Function Pair=46=-----==

private int initCode (JCMethodDecl tree, Env < GenContext > env, boolean fatcode) {
    MethodSymbol meth = tree.sym;
    meth.code = code = new Code (meth, fatcode, lineDebugInfo ? toplevel.lineMap : null, varDebugInfo, stackMap, debugCode, genCrt ? new CRTable (tree, env.toplevel.endPositions) : null, syms, types, pool);
    items = new Items (pool, code, syms, types);
    if (code.debugCode) System.err.println (meth + " for body " + tree);
    if ((tree.mods.flags & STATIC) == 0) {
        Type selfType = meth.owner.type;
        if (meth.isConstructor () && selfType != syms.objectType) selfType = UninitializedType.uninitializedThis (selfType);
        code.setDefined (code.newLocal (new VarSymbol (FINAL, names._this, selfType, meth.owner)));
    }
    for (List < JCVariableDecl > l = tree.params; l.nonEmpty (); l = l.tail) {
        checkDimension (l.head.pos (), l.head.sym.type);
        code.setDefined (code.newLocal (l.head.sym));
    }
    int startpcCrt = genCrt ? code.curPc () : 0;
    code.entryPoint ();
    code.pendingStackMap = false;
    return startpcCrt;
}


protected Dfp (final DfpField field, long x) {
    mant = new int [field.getRadixDigits ()];
    nans = FINITE;
    this.field = field;
    boolean isLongMin = false;
    if (x == Long.MIN_VALUE) {
        isLongMin = true;
        ++ x;
    }
    if (x < 0) {
        sign = - 1;
        x = - x;
    }
    else {
        sign = 1;
    }
    exp = 0;
    while (x != 0) {
        System.arraycopy (mant, mant.length - exp, mant, mant.length - 1 - exp, exp);
        mant [mant.length - 1] = (int) (x % RADIX);
        x /= RADIX;
        exp ++;
    }
    if (isLongMin) {
        for (int i = 0; i < mant.length - 1; i ++) {
            if (mant [i] != 0) {
                mant [i] ++;
                break;
            }
        }
    }
}


-----Function Pair=47=-----==

private void paintCanvas (RepaintEvent ev) {
    Graphics2D g = ev.getGraphics ();
    Rectangle bounds = canvas.getBounds ();
    bounds.x += INSET;
    bounds.width -= 2 * INSET;
    RGBColor temp = new RGBColor (0.0f, 0.0f, 0.0f);
    double scale = 1.0 / (bounds.width);
    for (int i = 0; i < bounds.width; i ++) {
        calcColor (i * scale, temp);
        g.setColor (temp.getColor ());
        g.drawLine (bounds.x + i, 0, bounds.x + i, 30);
    }
    g.setColor (getBackground ());
    g.fillRect (0, 30, bounds.width, bounds.height);
    g.setColor (Color.black);
    for (int i = 0; i < index.length; i ++) {
        if (i == selected) g.setColor (Color.red);
        int x = handlePos [i].x, y = 30 + handlePos [i].y * HANDLE_SIZE;
        g.fillPolygon (new int [] {x, x + HANDLE_SIZE, x - HANDLE_SIZE}, new int [] {y, y + HANDLE_SIZE, y + HANDLE_SIZE}, 3);
        g.setColor (Color.black);
        g.drawLine (x, y, x, 30);
    }
}


static void checkWorld (DxWorld w) {
    DxBody b;
    DxJoint j;
    if (listHasLoops (w.firstbody)) dDebug (0, "body list has loops");
    if (listHasLoops (w.firstjoint)) dDebug (0, "joint list has loops");
    if (true) throw new UnsupportedOperationException ();
    int nn = 0;
    for (b = w.firstbody.get (); b != null; b = (DxBody) b.getNext ()) nn ++;
    if (w.nb != nn) dDebug (0, "body count incorrect");
    nn = 0;
    for (j = w.firstjoint.get (); j != null; j = (DxJoint) j.getNext ()) nn ++;
    if (w.nj != nn) dDebug (0, "joint count incorrect");
    int count = generateWorldCheckTag ();
    for (b = w.firstbody.get (); b != null; b = (DxBody) b.getNext ()) b.tag = count;
    for (j = w.firstjoint.get (); j != null; j = (DxJoint) j.getNext ()) j.tag = count;
    for (b = w.firstbody.get (); b != null; b = (DxBody) b.getNext ()) if (b.world != w) dDebug (0, "bad world pointer in body list");
    for (j = w.firstjoint.get (); j != null; j = (DxJoint) j.getNext ()) if (j.world != w) dDebug (0, "bad world pointer in joint list");
    for (j = w.firstjoint.get (); j != null; j = (DxJoint) j.getNext ()) {
        for (int i = 0; i < 2; i ++) {
            if (j.node [i].body != null) {
                int ok = 0;
                for (DxJointNode n = j.node [i].body.firstjoint.get (); n != null; n = n.next) {
                    if (n.joint == j) ok = 1;
                }
                if (ok == 0) dDebug (0, "joint not in joint list of attached body");
            }
        }
    }
    for (b = w.firstbody.get (); b != null; b = (DxBody) b.getNext ()) {
        for (DxJointNode n = b.firstjoint.get (); n != null; n = n.next) {
            if (n.joint.node [0] == n) {
                if (n.joint.node [1].body != b) dDebug (0, "bad body pointer in joint node of body list (1)");
            }
            else {
                if (n.joint.node [0].body != b) dDebug (0, "bad body pointer in joint node of body list (2)");
            }
            if (n.joint.tag != count) dDebug (0, "bad joint node pointer in body");
        }
    }
    for (j = w.firstjoint.get (); j != null; j = (DxJoint) j.getNext ()) {
        if (j.node [0].body != null && (j.node [0].body == j.node [1].body)) dDebug (0, "non-distinct body pointers in joint");
        if ((j.node [0].body != null && j.node [0].body.tag != count) || (j.node [1].body != null && j.node [1].body.tag != count)) dDebug (0, "bad body pointer in joint");
    }
}


-----Function Pair=48=-----==

void update_keyboard () {
    for (int i = 0; i < 8; i ++) keyboard [i] = 0xFF;
    kempston = 0;
    int m [] = new int [] {- 1, - 1, - 1, - 1, - 1};
    int s = 0;
    synchronized (keys) {
        for (int i = 0; i < keys.length; i ++) if (keys [i] != null) {
            int k = key (keys [i]);
            if (k < 0) continue;
            s |= k;
            if (k < 01000) pressed (k, m);
        }
    }
    if ((s & 0300) == 0) s |= s>>> 3 & 0300;
    if ((s & 0100) != 0) pressed (000, m);
    if ((s & 0200) != 0) pressed (017, m);
}


public static void toggleIntEndian (byte [] b, int off, int len) {
    if (b == null || len == 0) return;
    int end = off + len;
    if (off < 0 || len < 0 || end > b.length) throw new IndexOutOfBoundsException ("b.length = " + b.length + ", off = " + off + ", len = " + len);
    if ((len & 3) != 0) throw new IllegalArgumentException ("len = " + len);
    byte tmp;
    for (int i = off; i < end; i ++, i ++, i ++, i ++) {
        tmp = b [i];
        b [i] = b [i + 3];
        b [i + 3] = tmp;
        tmp = b [i + 1];
        b [i + 1] = b [i + 2];
        b [i + 2] = tmp;
    }
}


-----Function Pair=49=-----==

public void shrink (int size, int dim) {
    Object [] new_elements = new Object [size];
    long [] new_last_used = new long [size];
    int [] new_index = new int [size + 1];
    int i;
    double [] old_element;
    double [] element;
    if (size < cache_size) {
        cache_size = size;
    }
    for (i = 0; i < cache_size; i ++) {
        old_element = (double []) (elements [i]);
        if ((old_element != null) && (last_used [i] > 0)) {
            element = new double [dim];
            System.arraycopy (old_element, 0, element, 0, dim);
        }
        else {
            element = null;
        }
        new_elements [i] = element;
        new_last_used [i] = last_used [i];
        new_index [i] = index [i];
        elements [i] = null;
    }
    while (i < size) {
        new_elements [i] = null;
        new_last_used [i] = 0;
        new_index [i] = Integer.MAX_VALUE;
        i ++;
    }
    new_index [size] = Integer.MAX_VALUE;
    elements = new_elements;
    last_used = new_last_used;
    index = new_index;
    cache_size = size;
}


void registerCatch (DiagnosticPosition pos, int startpc, int endpc, int handler_pc, int catch_type) {
    if (startpc != endpc) {
        char startpc1 = (char) startpc;
        char endpc1 = (char) endpc;
        char handler_pc1 = (char) handler_pc;
        if (startpc1 == startpc && endpc1 == endpc && handler_pc1 == handler_pc) {
            code.addCatch (startpc1, endpc1, handler_pc1, (char) catch_type);
        }
        else {
            if (! useJsrLocally && ! target.generateStackMapTable ()) {
                useJsrLocally = true;
                throw new CodeSizeOverflow ();
            }
            else {
                log.error (pos, "limit.code.too.large.for.try.stmt");
                nerrs ++;
            }
        }
    }
}


-----Function Pair=50=-----==

public void shrink (int size, int dim) {
    Object [] new_elements = new Object [size];
    long [] new_last_used = new long [size];
    int [] new_index = new int [size + 1];
    int i;
    double [] old_element;
    double [] element;
    if (size < cache_size) {
        cache_size = size;
    }
    for (i = 0; i < cache_size; i ++) {
        old_element = (double []) (elements [i]);
        if ((old_element != null) && (last_used [i] > 0)) {
            element = new double [dim];
            System.arraycopy (old_element, 0, element, 0, dim);
        }
        else {
            element = null;
        }
        new_elements [i] = element;
        new_last_used [i] = last_used [i];
        new_index [i] = index [i];
        elements [i] = null;
    }
    while (i < size) {
        new_elements [i] = null;
        new_last_used [i] = 0;
        new_index [i] = Integer.MAX_VALUE;
        i ++;
    }
    new_index [size] = Integer.MAX_VALUE;
    elements = new_elements;
    last_used = new_last_used;
    index = new_index;
    cache_size = size;
}


String substitute (String input, String var, String [] fields, String [] fieldData) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        if (DEBUG) System.out.println ("checking for occurrence of " + var + " in :" + input.substring (oidx));
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        if (input.charAt (idx) != '.') throw new IOException ("no field");
        idx ++;
        int idx_save = idx;
        for (int i = 0; i < fields.length; i ++) {
            String fld = fields [i];
            int flen = fld.length ();
            if (DEBUG) System.out.println ("checking if it is field " + fld);
            if (input.regionMatches (idx, fld, 0, flen)) {
                String value = fieldData [i];
                if (DEBUG) System.out.println ("field matches. outputting data :" + value);
                out.append (value);
                idx += flen;
                break;
            }
        }
        if (idx == idx_save) throw new IOException ("unknown field");
        oidx = idx;
    }
    if (DEBUG) System.out.println ("no more variables left on this line");
    out.append (input.substring (oidx));
    return out.toString ();
}


-----Function Pair=51=-----==

public void run () {
    VM_Callbacks.notifyStartup ();
    VM_Controller.boot ();
    String [] mainArgs = null;
    INSTRUCTION [] mainCode = null;
    synchronized (VM_ClassLoader.lock) {
        VM_Class cls = null;
        try {
            cls = VM_Class.forName (args [0]);
        } catch (VM_ResolutionException e) {
            VM.sysWrite (e.getException () + "\n");
            return;
        }
        mainMethod = cls.findMainMethod ();
        if (mainMethod == null) {
            VM.sysWrite (cls.getName () + " doesn't have a \"public static void main(String[])\" method to execute\n");
            return;
        }
        mainArgs = new String [args.length - 1];
        for (int i = 0, n = mainArgs.length; i < n; ++ i) mainArgs [i] = args [i + 1];
        mainCode = mainMethod.compile ();
    }
    VM.debugBreakpoint ();
    VM_Magic.invokeMain (mainArgs, mainCode);
}


static void testRijndael_JCE () {
    byte [] aKey = new byte [32];
    byte [] aTest = new byte [16];
    byte [] aRef = new byte [16];
    int [] aRef_int = {0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89};
    int i;
    for (i = 0; i < 32; i ++) {
        aKey [i] = (byte) i;
    }
    for (i = 0; i < 16; i ++) {
        aTest [i] = (byte) ((i << 4) | i);
        aRef [i] = (byte) aRef_int [i];
    }
    try {
        BufferedBlockCipher cipher = new BufferedBlockCipher (new AESEngine ());
        cipher.init (true, new KeyParameter (aKey));
        cipher.processBytes (aTest, 0, aTest.length, aTest, 0);
    } catch (Exception ex) {
        ex.printStackTrace ();
        throw new RuntimeException ("JCE failed test");
    }
    if (PhoneIDUtil.compare (aTest, aRef) == false) throw new RuntimeException ("JCE failed test");
}


-----Function Pair=52=-----==

private static int varCountField (String name) {
    String shortname;
    int dot, numfield;
    shortname = name;
    numfield = 0;
    while (true) {
        dot = shortname.indexOf ('.');
        if (dot != - 1) {
            numfield ++;
            shortname = shortname.substring (dot + 1);
        }
        else {
            break;
        }
    }
    return numfield;
}


private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=53=-----==

public Dfp dotrap (int type, String what, Dfp oper, Dfp result) {
    Dfp def = result;
    switch (type) {
        case DfpField.FLAG_INVALID :
            def = newInstance (getZero ());
            def.sign = result.sign;
            def.nans = QNAN;
            break;
        case DfpField.FLAG_DIV_ZERO :
            if (nans == FINITE && mant [mant.length - 1] != 0) {
                def = newInstance (getZero ());
                def.sign = (byte) (sign * oper.sign);
                def.nans = INFINITE;
            }
            if (nans == FINITE && mant [mant.length - 1] == 0) {
                def = newInstance (getZero ());
                def.nans = QNAN;
            }
            if (nans == INFINITE || nans == QNAN) {
                def = newInstance (getZero ());
                def.nans = QNAN;
            }
            if (nans == INFINITE || nans == SNAN) {
                def = newInstance (getZero ());
                def.nans = QNAN;
            }
            break;
        case DfpField.FLAG_UNDERFLOW :
            if ((result.exp + mant.length) < MIN_EXP) {
                def = newInstance (getZero ());
                def.sign = result.sign;
            }
            else {
                def = newInstance (result);
            }
            result.exp = result.exp + ERR_SCALE;
            break;
        case DfpField.FLAG_OVERFLOW :
            result.exp = result.exp - ERR_SCALE;
            def = newInstance (getZero ());
            def.sign = result.sign;
            def.nans = INFINITE;
            break;
        default :
            def = result;
            break;
    }
    return trap (type, what, oper, def, result);
}


public static boolean equalsUnordered (Object o1, Object o2, EqualsChecker checker) {
    if (o1 == null) return o2 == null;
    if (o2 == null) return false;
    if (o1 instanceof Object [] && o2 instanceof Object []) return equalsUnordered ((Object []) o1, (Object []) o2, checker);
    if (o1.getClass ().isArray () && o2.getClass ().isArray ()) {
        if (! o1.getClass ().equals (o2.getClass ())) return false;
        int len = Array.getLength (o1);
        if (len != Array.getLength (o2)) return false;
        if (len == 0) return true;
        long [] bs = new long [(len - 1) / 64 + 1];
        long mask;
        int i, j, bsIdx;
        o1Loop : for (i = 0; i < len; i ++) {
            mask = 0;
            for (j = 0; j < len; j ++) {
                bsIdx = j / 64;
                if (mask == 0) mask = 0x8000000000000000L;
                if ((bs [bsIdx] & mask) == 0 && checker.equals (Array.get (o1, i), Array.get (o2, j))) {
                    bs [bsIdx] |= mask;
                    continue o1Loop;
                }
                mask>>>= 1;
            }
            return false;
        }
        return true;
    }
    return checker.equals (o1, o2);
}


-----Function Pair=54=-----==

public void mouseDragged (MouseEvent e) {
    if (enabled == false) {
        return;
    }
    double xpos = e.getX ();
    double x = toLocalX (xpos);
    if (x < getMinimum ()) {
        x = getMinimum ();
    }
    if (x > getMaximum ()) {
        x = getMaximum ();
    }
    if (pick == (PICK_MIN | PICK_MAX)) {
        if ((xpos - mouseX) > 2) {
            pick = PICK_MAX;
        }
        else if ((xpos - mouseX) < - 2) {
            pick = PICK_MIN;
        }
        else {
            return;
        }
    }
    mouseX = xpos;
    switch (pick) {
        case PICK_MIN :
            if (x < getHighValue ()) {
                setLowValue (x);
            }
            break;
        case PICK_MAX :
            if (x > getLowValue ()) {
                setHighValue (x);
            }
            break;
        case PICK_MID :
            double dx = toLocalX (xpos - pickOffset) - getLowValue ();
            if ((dx < 0) && ((getLowValue () + dx) < getMinimum ())) {
                dx = getMinimum () - getLowValue ();
            }
            if ((dx > 0) && ((getHighValue () + dx) > getMaximum ())) {
                dx = getMaximum () - getHighValue ();
            }
            if (dx != 0) {
                offset (dx);
            }
            break;
    }
}


public Expression inline (Environment env, Context ctx) {
    if (implementation != null) return implementation.inline (env, ctx);
    try {
        if (right != null) {
            right = field.isStatic () ? right.inline (env, ctx) : right.inlineValue (env, ctx);
        }
        for (int i = 0; i < args.length; i ++) {
            args [i] = args [i].inlineValue (env, ctx);
        }
        ClassDefinition ctxClass = ctx.field.getClassDefinition ();
        Expression e = this;
        if (env.opt () && field.isInlineable (env, clazz.isFinal ()) && ((right == null) || (right.op == THIS) || field.isStatic ()) && ctxClass.permitInlinedAccess (env, field.getClassDeclaration ()) && ctxClass.permitInlinedAccess (env, field) && (right == null || ctxClass.permitInlinedAccess (env, env.getClassDeclaration (right.type))) && ((id == null) || ! id.equals (idInit)) && (! ctx.field.isInitializer ()) && ctx.field.isMethod () && (ctx.getInlineMemberContext (field) == null)) {
            Statement s = (Statement) field.getValue (env);
            if ((s == null) || (s.costInline (MAXINLINECOST, env, ctx) < MAXINLINECOST)) {
                e = inlineMethod (env, ctx, s, false);
            }
        }
        return e;
    } catch (ClassNotFound e) {
        throw new CompilerError (e);
    }
}


-----Function Pair=55=-----==

protected void newCluster () {
    newCluster = new SimpleNode ();
    newCluster.setHeight (newNodeHeight ());
    newCluster.addChild (clusters [abi]);
    newCluster.addChild (clusters [abj]);
    clusters [abi] = newCluster;
    clusters [abj] = null;
    for (int k = 0; k < numClusters; k ++) {
        if (k != besti && k != bestj) {
            int ak = alias [k];
            distance [ak] [abi] = distance [abi] [ak] = updatedDistance (besti, bestj, k);
            distance [ak] [abj] = distance [abj] [ak] = - 1.0;
        }
    }
    distance [abi] [abi] = 0.0;
    distance [abj] [abj] = - 1.0;
    for (int i = bestj; i < numClusters - 1; i ++) {
        alias [i] = alias [i + 1];
    }
    tipCount [abi] += tipCount [abj];
    tipCount [abj] = 0;
    numClusters --;
}


public void rollDiceTurn () {
    boolean duplicate;
    diceSum = new int [playerNum];
    Dice dice = new Dice ();
    for (int i = 0; i < playerNum; i ++) {
        duplicate = true;
        while (duplicate) {
            duplicate = false;
            dice.rollDice ();
            this.diceSum [i] = dice.getNumber (1) + dice.getNumber (2);
            if (playerNum > 1) {
                for (int j = 0; j < i; j ++) {
                    if (j != i && diceSum [j] == diceSum [i]) duplicate = true;
                }
            }
        }
    }
    this.diceSumAlloc = true;
}


-----Function Pair=56=-----==

public void receivedMessage (ByteBuffer message) {
    byte [] messageBytes = new byte [message.remaining ()];
    message.get (messageBytes);
    MessageBuffer buf = new MessageBuffer (messageBytes);
    AppContext.getDataManager ().markForUpdate (this);
    reconnectKey = new BigInteger (1, buf.getByteArray ());
    byte [] bytes = buf.getByteArray ();
    if (bytes.length == 0) {
        return;
    }
    DummyClient client = dummyClients.get (reconnectKey);
    System.err.println ("DummyClientSessionListener[" + name + "] " + "receivedMessage: " + HexDumper.toHexString (bytes) + "\nthrow exception: " + receivedMessageException);
    if (receivedMessageException != null) {
        RuntimeException re = receivedMessageException;
        receivedMessageException = null;
        throw re;
    }
    synchronized (client.sessionListenerReceivedMessages) {
        client.sessionListenerReceivedMessages.add (bytes);
        if (client.sessionListenerReceivedMessages.size () == client.numSessionListenerExpectedMessages) {
            client.sessionListenerReceivedMessages.notifyAll ();
        }
    }
    ByteBuffer bbuf = ByteBuffer.allocate (bytes.length);
    bbuf.put (bytes).flip ();
    sessionRef.get ().send (bbuf);
}


void connect () {
    if (! this.conf.get ("XMPP.username").isEmpty ()) {
        if (this.conf.get ("XMPP.password").isEmpty ()) {
            this.passwordDialog.setVisible (true);
        }
        connected ();
        ConnectionConfiguration Configuration = new ConnectionConfiguration (this.conf.get ("XMPP.server"), Integer.valueOf (this.conf.get ("XMPP.port")));
        this.Connection = new XMPPConnection (Configuration);
        try {
            ServiceDiscoveryManager.setIdentityName ("Mapadeo");
            ServiceDiscoveryManager.setIdentityType ("pc");
            this.Connection.connect ();
            SDM = ServiceDiscoveryManager.getInstanceFor (this.Connection);
            SDM.addFeature ("http://mapadeo.zestflood.net/1.0/xhtml");
            this.ConnectionStateLabel.setText ("authenticating");
            if (this.conf.get ("XMPP.password").isEmpty ()) {
                this.Connection.login (this.conf.get ("XMPP.username"), this.passwordTextField.getText (), this.conf.get ("XMPP.location"));
            }
            else {
                this.Connection.login (this.conf.get ("XMPP.username"), this.conf.get ("XMPP.password"), this.conf.get ("XMPP.location"));
            }
            this.ConnectionStateLabel.setText ("connected");
            if (this.Connection.isUsingTLS ()) {
                this.ConnectionStateLabel.setText ("connected [TLS]");
            }
            else {
                this.ConnectionStateLabel.setText ("connected");
            }
            this.MUChats = new Vector < ChatInstanceHandlerMUC > ();
            this.Connection.addConnectionListener (this);
            this.IQListener = new XMLIQExtensionListener (this.Connection, this);
            this.Connection.addPacketListener (IQListener, new PacketTypeFilter (XMLIQExtension.class));
            this.RosterListModel.clear ();
            this.RosterMan = new RosterManager (this.Connection.getRoster (), this.RosterListModel);
            this.ChatListener = new ChatListener (this, Connection);
            this.Connection.getChatManager ().addChatListener (this.ChatListener);
            MultiUserChat.addInvitationListener (Connection, ChatListener);
        } catch (XMPPException e) {
            this.ConnectionStateLabel.setText (e.getMessage ());
            this.Connection.disconnect ();
            disconnected ();
        }
        this.passwordTextField.setText ("");
    }
}


-----Function Pair=57=-----==

private void doLogin () {
    if ((! midlet.getSettings ().loginNow) && (midlet.getSettings ().autoLogin)) {
        midlet.displayAttributesForm ();
        return;
    }
    midlet.setGaugeForm ("Logging in...");
    connector.connect (midlet.params);
    Hashtable response;
    try {
        response = connector.login ();
    } catch (IOException e) {
        midlet.displayError ("Logging error", "Error during sending data via GPRS");
        return;
    }
    if (response.get ("success").equals ("OK")) {
        if (response.get ("access_count") != null) {
            int journalsCount = Integer.parseInt ((String) response.get ("access_count")) + 1;
            midlet.journals = new String [journalsCount];
            midlet.journals [0] = UTFDecoder.decode ((String) response.get ("name"));
            for (int i = 1; i < journalsCount; i ++) {
                midlet.journals [i] = (String) response.get ("access_" + String.valueOf (i));
            }
        }
        else {
            midlet.journals = new String [1];
            midlet.journals [0] = UTFDecoder.decode ((String) response.get ("name"));
        }
        if (response.get ("pickw_count") != null) {
            int picsCount = Integer.parseInt ((String) response.get ("pickw_count"));
            if (picsCount > 0) {
                midlet.userpics = new String [picsCount];
                for (int i = 0; i < picsCount; i ++) {
                    midlet.userpics [i] = UTFDecoder.decode ((String) response.get ("pickw_" + String.valueOf (i + 1)));
                }
            }
        }
        else {
            midlet.userpics = null;
        }
    }
    else {
        midlet.displayError ("Logging error", (String) response.get ("errmsg"));
        return;
    }
    midlet.displayAttributesForm ();
}


protected static long getFileSize (FTPClient ftp, String remoteFile) {
    long size = 0;
    try {
        FTPFile [] files = ftp.listFiles (remoteFile);
        if (files.length == 1) {
            FTPFile ftpFile = files [0];
            if (ftpFile != null) {
                size = ftpFile.getSize ();
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return size;
}


-----Function Pair=58=-----==

private void flush () {
    setInit (true);
    SessionFactory hfactory = null;
    Session hsession = null;
    javax.mail.Session msession = null;
    try {
        hfactory = (SessionFactory) ctx.lookup (hibernateSessionFactory);
        hsession = hfactory.openSession ();
        msession = (javax.mail.Session) ctx.lookup (durotyMailFactory);
        String pop3Host = msession.getProperty ("mail.pop3.host");
        int port = 0;
        try {
            port = Integer.parseInt (msession.getProperty ("mail.pop3.port"));
        } catch (Exception ex) {
            port = 0;
        }
        Query query = hsession.getNamedQuery ("users-mail");
        query.setBoolean ("active", true);
        query.setString ("role", "mail");
        ScrollableResults scroll = query.scroll ();
        while (scroll.next ()) {
            POP3Client client = new POP3Client ();
            try {
                if (port > 0) {
                    client.connect (pop3Host, port);
                }
                else {
                    client.connect (pop3Host);
                }
                client.setState (POP3Client.AUTHORIZATION_STATE);
                Users user = (Users) scroll.get (0);
                String repositoryName = user.getUseUsername ();
                if (client.login (repositoryName, user.getUsePassword ())) {
                    POP3MessageInfo [] info = client.listUniqueIdentifiers ();
                    if ((info != null) && (info.length > 0)) {
                        for (int i = 0; i < info.length; i ++) {
                            if (pool.size () >= poolSize) {
                                break;
                            }
                            Reader reader = client.retrieveMessage (info [i].number);
                            boolean existMessage = existMessageName (hfactory.openSession (), user, info [i].identifier);
                            String key = info [i].identifier + "--" + repositoryName;
                            if (existMessage) {
                                client.deleteMessage (info [i].number);
                            }
                            else {
                                if (! poolContains (key)) {
                                    addPool (key);
                                    MimeMessage mime = buildMimeMessage (info [i].identifier, reader, user);
                                    if (! isSpam (user, mime)) {
                                        client.deleteMessage (info [i].number);
                                        Mailet mailet = new Mailet (this, info [i].identifier, repositoryName, mime);
                                        Thread thread = new Thread (mailet, key);
                                        thread.start ();
                                    }
                                    else {
                                        client.deleteMessage (info [i].number);
                                    }
                                }
                            }
                            Thread.sleep (100);
                        }
                    }
                }
                else {
                }
            } catch (Exception e) {
            } finally {
                System.gc ();
                try {
                    client.logout ();
                    client.disconnect ();
                } catch (Exception e) {
                }
            }
        }
    } catch (Exception e) {
        System.gc ();
        pool.clear ();
        DLog.log (DLog.ERROR, this.getClass (), e.getMessage ());
    } catch (OutOfMemoryError e) {
        System.gc ();
        pool.clear ();
        DLog.log (DLog.ERROR, this.getClass (), e.getMessage ());
    } catch (Throwable e) {
        System.gc ();
        pool.clear ();
        DLog.log (DLog.ERROR, this.getClass (), e.getMessage ());
    } finally {
        System.gc ();
        GeneralOperations.closeHibernateSession (hsession);
        setInit (false);
    }
}


private String getDnsKdc (String realm) {
    try {
        Hashtable < String, String > env = new Hashtable < String, String > ();
        env.put ("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
        DirContext context = new InitialDirContext (env);
        Attributes dnsLookup = context.getAttributes ("_kerberos._udp." + realm, new String [] {"SRV"});
        ArrayList < Integer > priorities = new ArrayList < Integer > ();
        HashMap < Integer, List < String > > records = new HashMap < Integer, List < String > > ();
        for (Enumeration e = dnsLookup.getAll (); e.hasMoreElements ();) {
            Attribute record = (Attribute) e.nextElement ();
            for (Enumeration e2 = record.getAll (); e2.hasMoreElements ();) {
                String sRecord = (String) e2.nextElement ();
                String [] sRecParts = sRecord.split (" ");
                Integer pri = Integer.valueOf (sRecParts [0]);
                if (priorities.contains (pri)) {
                    List < String > recs = records.get (pri);
                    if (recs == null) recs = new ArrayList < String > ();
                    recs.add (sRecord);
                }
                else {
                    priorities.add (pri);
                    List < String > recs = new ArrayList < String > ();
                    recs.add (sRecord);
                    records.put (pri, recs);
                }
            }
        }
        Collections.sort (priorities);
        List < String > l = records.get (priorities.get (0));
        String toprec = (String) l.get (0);
        String [] sRecParts = toprec.split (" ");
        return sRecParts [3];
    } catch (NamingException e) {
        return "";
    }
}


-----Function Pair=59=-----==

private Document getFilesDocument () {
    final String FILES_ELEMENT = "files";
    try {
        final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
        final DocumentBuilder db = dbf.newDocumentBuilder ();
        final Document document = db.newDocument ();
        final Element filesElement = document.createElement (FILES_ELEMENT);
        document.appendChild (filesElement);
        Collection files = getFiles ();
        for (final Iterator i = files.iterator (); i.hasNext ();) {
            final ArchiveFile file = (ArchiveFile) i.next ();
            final Element fileElement = file.getElement (document);
            filesElement.appendChild (fileElement);
        }
        return document;
    } catch (final ParserConfigurationException e) {
        final IllegalStateException ise = new IllegalStateException ();
        ise.initCause (e);
        throw ise;
    }
}


public synchronized File [] getFiles (File dir, boolean useFileHiding) {
    if (dir instanceof FTPFileFile && dir.isDirectory ()) {
        FTPFile ftpFile = ((FTPFileFile) dir).getFtpFile ();
        String name = ftpFile.getName ();
        try {
            checkConnection ();
            String pwd = ftpClient.printWorkingDirectory ();
            if (null == pwd || ! pwd.equals (name)) {
                ftpClient.changeWorkingDirectory (name);
            }
            pwd = ftpClient.printWorkingDirectory ();
            FTPListParseEngine ftpListParseEngine = ftpClient.initiateListParsing ();
            FTPFile [] files = ftpListParseEngine.getFiles ();
            FTPFileFile [] ftpFiles = new FTPFileFile [files.length];
            for (int i = 0; i < files.length; i ++) {
                files [i].setName (pwd + FILE_SEPERATOR + files [i].getName ());
                ftpFiles [i] = new FTPFileFile (files [i], this);
            }
            return ftpFiles;
        } catch (FTPBrowseException e) {
            logger.log (Level.WARNING, "Could not connect to host", e);
            return new FTPFileFile [0];
        } catch (IOException e) {
            logger.log (Level.WARNING, "Could not operate on host", e);
            return new FTPFileFile [0];
        }
    }
    logger.fine ("Calling Super with: " + dir.toString () + " " + String.valueOf (useFileHiding));
    return super.getFiles (dir, useFileHiding);
}


-----Function Pair=60=-----==

public static void main (String [] args) {
    System.out.println ("Chapter 2: example HelloWorldLandscape2");
    System.out.println ("-> Creates a PDF file with the text 'Hello World';");
    System.out.println ("   a Rectangle with width > height was used as PageSize.");
    System.out.println ("-> jars needed: iText.jar");
    System.out.println ("-> files generated in /results subdirectory:");
    System.out.println ("   HelloWorldLandscape2.pdf");
    Document document = new Document (new Rectangle (792, 612));
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapter02/HelloWorldLandscape2.pdf"));
        document.open ();
        document.add (new Paragraph ("Hello World"));
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


protected void writeClip (Shape s) throws IOException {
    if (s == null || ! isProperty (CLIP)) {
        return;
    }
    if (s instanceof Rectangle2D) {
        pageStream.move (((Rectangle2D) s).getMinX (), ((Rectangle2D) s).getMinY ());
        pageStream.line (((Rectangle2D) s).getMaxX (), ((Rectangle2D) s).getMinY ());
        pageStream.line (((Rectangle2D) s).getMaxX (), ((Rectangle2D) s).getMaxY ());
        pageStream.line (((Rectangle2D) s).getMinX (), ((Rectangle2D) s).getMaxY ());
        pageStream.closePath ();
        pageStream.clip ();
        pageStream.endPath ();
    }
    else {
        boolean eoclip = pageStream.drawPath (s);
        if (eoclip) {
            pageStream.clipEvenOdd ();
        }
        else {
            pageStream.clip ();
        }
        pageStream.endPath ();
    }
}


-----Function Pair=61=-----==

static void copyDirectory (File sourceLocation, File targetLocation) {
    if (sourceLocation.isDirectory ()) {
        if (! targetLocation.exists ()) {
            if (! targetLocation.mkdir ()) {
                String message = "It was not possible to create directory " + targetLocation.getAbsolutePath () + ". This application cannot continue.";
                throw new RuntimeException (message);
            }
        }
        String [] children = sourceLocation.list ();
        for (int i = 0; i < children.length; i ++) {
            copyDirectory (new File (sourceLocation, children [i]), new File (targetLocation, children [i]));
        }
    }
    else {
        try {
            InputStream in = new FileInputStream (sourceLocation);
            OutputStream out = new FileOutputStream (targetLocation);
            byte [] buf = new byte [1024];
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            in.close ();
            out.close ();
        } catch (IOException exception) {
            String message = "It was not possible to copy the source directory " + "to the chosen destiny due to the following cause: " + exception.getMessage ();
            throw new RuntimeException (message, exception);
        }
    }
}


private int parseSecs (String str) {
    if (str.equals ("-")) {
        return 0;
    }
    int pos = 0;
    if (str.startsWith ("-")) {
        pos = 1;
    }
    ParsePosition pp = new ParsePosition (pos);
    DateTimeParseContext cal = TIME_PARSER.parse (str, pp);
    if (pp.getErrorIndex () >= 0) {
        throw new IllegalArgumentException (str);
    }
    DateTimeField hour = (DateTimeField) cal.getParsed (HOUR_OF_DAY);
    DateTimeField min = (DateTimeField) cal.getParsed (MINUTE_OF_HOUR);
    DateTimeField sec = (DateTimeField) cal.getParsed (SECOND_OF_MINUTE);
    int secs = (int) (hour.getValue () * 60 * 60 + (min != null ? min.getValue () : 0) * 60 + (sec != null ? sec.getValue () : 0));
    if (pos == 1) {
        secs = - secs;
    }
    return secs;
}


-----Function Pair=62=-----==

public void fileLoadingInProgress () {
    try {
        String strFileLoadingInProgress = topframe.getParameter ("fileLoadingInProgress");
        if (strFileLoadingInProgress.equals (null) || "".equals (strFileLoadingInProgress)) return;
        String strFileNames = "";
        if (xferFileListNames != null) {
            for (int i = 0; i < xferFileListNames.size (); i ++) {
                if (! strFileNames.equals ("")) {
                    strFileNames += ", " + (String) xferFileListNames.get (i);
                }
                else {
                    strFileNames += (String) xferFileListNames.get (i);
                }
            }
        }
        JSObject win = JSObject.getWindow (topframe);
        String args [] = {strFileNames};
        Object foo = win.call (strFileLoadingInProgress, args);
        fileUploadInProgress = true;
    } catch (Exception ignored) {
    }
}


public static boolean copyFileRecursively (File src, File dest, boolean overwrite) {
    String destAbsPath = dest.getAbsolutePath ();
    if (! src.exists ()) return false;
    if (src.isDirectory ()) {
        if (! dest.exists ()) {
            if (! dest.mkdirs ()) {
                return false;
            }
        }
        File [] children = src.listFiles ();
        for (int i = 0; i < children.length; i ++) {
            String destPath = destAbsPath + "/" + children [i].getName ();
            MiscUtils.copyFileRecursively (children [i], new File (destPath), overwrite);
        }
    }
    else {
        try {
            MiscUtils.copy (src.getAbsolutePath (), dest.getAbsolutePath ());
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
    return true;
}


-----Function Pair=63=-----==

public static void deleteRecursively (File fileOrDirectory) {
    if (fileOrDirectory.isFile ()) {
        boolean success = fileOrDirectory.delete ();
        if (! success) {
            throw new RuntimeException ("The file '" + fileOrDirectory.getAbsolutePath () + "' could not be deleted");
        }
        else {
            log.debug ("Successfully deleted file '" + fileOrDirectory + "'.");
        }
    }
    else {
        File [] children = fileOrDirectory.listFiles ();
        for (int i = 0; i < children.length; i ++) {
            File file = children [i];
            deleteRecursively (file);
        }
        boolean success = fileOrDirectory.delete ();
        if (! success) {
            throw new RuntimeException ("The directory '" + fileOrDirectory.getAbsolutePath () + "' could not be deleted");
        }
        else {
            log.debug ("Successfully deleted directory '" + fileOrDirectory + "'.");
        }
    }
}


public void saveFavorites (String filename) {
    try {
        final PrintStream p = new PrintStream (filename, "ISO-8859-1");
        FavoritesModel model = (FavoritesModel) playListTable.getModel ();
        for (int i = 0; i < model.getRowCount (); i ++) {
            p.println (model.getValueAt (i, 0));
        }
        p.close ();
        this.playListFilename = filename;
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=64=-----==

private void addToClasspath (File jarFile) {
    try {
        URLClassLoader urlClassLoader = (URLClassLoader) ClassLoader.getSystemClassLoader ();
        Method m = URLClassLoader.class.getDeclaredMethod ("addURL", new Class [] {URL.class});
        m.setAccessible (true);
        m.invoke (urlClassLoader, jarFile.toURI ().toURL ());
        String cp = System.getProperty ("java.class.path");
        if (cp != null) {
            cp += File.pathSeparatorChar + jarFile.toURI ().getPath ();
        }
        else {
            cp = jarFile.toURI ().getPath ();
        }
        System.setProperty ("java.class.path", cp);
    } catch (Exception e) {
        throw new RuntimeException ("Can't add jar " + jarFile.getName () + " to classpath.", e);
    }
}


public void mouseClicked (final MouseEvent e) {
    int index = fileList.locationToIndex (e.getPoint ());
    fileList.setSelectedIndex (index);
    setControls (true);
    try {
        selected = (DFSFileInfo) fileList.getSelectedValue ();
        if (e.getClickCount () == 2) {
            if (selected.isDirectory ()) {
                open (new DFSFile ("JFS", selected.getPath ()));
            }
            else {
                FileDownloadTask task = new FileDownloadTask (explorer, current, selected, MAX_RW_LENGTH);
                task.start ();
            }
        }
    } catch (DFSException ex) {
        logger.debug (ex);
    }
}


-----Function Pair=65=-----==

public void doImportSourceFiles () {
    OmegaTFileChooser chooser = new OmegaTFileChooser ();
    chooser.setMultiSelectionEnabled (true);
    chooser.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    chooser.setDialogTitle (OStrings.getString ("TF_FILE_IMPORT_TITLE"));
    int result = chooser.showOpenDialog (this);
    if (result == OmegaTFileChooser.APPROVE_OPTION) {
        String projectsource = Core.getProject ().getProjectProperties ().getSourceRoot ();
        File sourcedir = new File (projectsource);
        File [] selFiles = chooser.getSelectedFiles ();
        try {
            for (int i = 0; i < selFiles.length; i ++) {
                File selSrc = selFiles [i];
                if (selSrc.isDirectory ()) {
                    List < String > files = new ArrayList < String > ();
                    StaticUtils.buildFileList (files, selSrc, true);
                    String selSourceParent = selSrc.getParent ();
                    for (String filename : files) {
                        String midName = filename.substring (selSourceParent.length ());
                        File src = new File (filename);
                        File dest = new File (sourcedir, midName);
                        LFileCopy.copy (src, dest);
                    }
                }
                else {
                    File dest = new File (sourcedir, selFiles [i].getName ());
                    LFileCopy.copy (selSrc, dest);
                }
            }
            ProjectUICommands.projectReload ();
        } catch (IOException ioe) {
            displayErrorRB (ioe, "MAIN_ERROR_File_Import_Failed");
        }
    }
}


private static void initRoots () {
    String roots = System.getProperty ("fconn.listenroots");
    if (roots != null) {
        StringTokenizer tokens = new StringTokenizer (roots, ";");
        listenRoots = new String [tokens.countTokens ()];
        int i = 0;
        while (tokens.hasMoreTokens ()) {
            listenRoots [i ++] = tokens.nextToken ();
        }
    }
    else {
        File [] fileroots = File.listRoots ();
        listenRoots = new String [fileroots.length];
        for (int c = 0; c < fileroots.length; c ++) {
            listenRoots [c] = fileroots [c].getAbsolutePath ();
        }
        File filesystem = new File (System.getProperty ("user.home"), "j2mewtk/2.5.2/appdb/DefaultColorPhone/filesystem");
        if (filesystem.exists () && filesystem.isDirectory ()) {
            File [] files = filesystem.listFiles ();
            Vector dirs = new Vector ();
            for (int c = 0; c < files.length; c ++) {
                if (files [c].isDirectory ()) {
                    String name = files [c].getName () + "/";
                    remap.put ("file:///" + name, files [c].getAbsolutePath () + "/");
                    dirs.add (name);
                }
            }
            String [] old = listenRoots;
            listenRoots = new String [old.length + dirs.size ()];
            System.arraycopy (old, 0, listenRoots, 0, old.length);
            for (int c = old.length; c < listenRoots.length; c ++) {
                listenRoots [c] = (String) dirs.elementAt (c - old.length);
            }
        }
        for (int c = 0; c < listenRoots.length; c ++) {
            listenRoots [c] = listenRoots [c].replaceAll ("\\\\", "/");
        }
    }
}


-----Function Pair=66=-----==

public static boolean createExampleProject (String projectName, IPath projectLocation, IProgressMonitor progressMonitor, IConfigurationElement configElement, String resourceFolder, boolean enableSyntaxChecking, Shell shell, ExampleProjectDefinition projDef, boolean createProject, boolean fireProjectSpecifics) {
    if (createProject) {
        final String status = ControlFactory.createProject (projectName, projectLocation, progressMonitor, configElement, resourceFolder, enableSyntaxChecking);
        if ((status != null) && ! status.trim ().equals ("")) {
            ControlFactory.showMessageDialog (status, "New XA-Designer Project", SWT.ICON_ERROR);
            return false;
        }
    }
    final IProject projectHandle = ResourcesPlugin.getWorkspace ().getRoot ().getProject (projectName);
    final String exampleFolder = projDef.getFolder ();
    final URL exampleUrl = FileLocator.find (HelpPlugin.getDefault ().getBundle (), new Path (exampleFolder), null);
    copyExample (exampleUrl, projectHandle, shell);
    final File antBuildFile = new File (projectHandle.getLocation ().toOSString () + "/build.xml");
    if (antBuildFile.exists ()) {
        final IProgressMonitor monitor = new NullProgressMonitor ();
        final AntRunner runner = new AntRunner ();
        runner.setBuildFileLocation (antBuildFile.getAbsolutePath ());
        runner.setArguments ("-DXAWARE_HOME=\"" + System.getProperty ("xaware.home") + "\"" + " -DProjectLocation=\"" + projectHandle.getLocation ().toOSString () + "\" -DProjectLocPropSafe=\"" + projectHandle.getLocation ().toOSString ().replace ('\\', '/') + "\" -logfile ./ant.log -verbose");
        try {
            runner.run (monitor);
            antBuildFile.delete ();
            projectHandle.refreshLocal (IResource.DEPTH_INFINITE, new NullProgressMonitor ());
        } catch (final CoreException e) {
            XAHelpLogger.logError ("Failed to run ANT example project preparation", e);
            return false;
        }
    }
    updateExampleElement (projectHandle, projDef.getHelpUrl (), EXAMPLE_HELP, HELP_UPDATE_ERROR);
    updateExampleElement (projectHandle, projDef.getCheatSheetId (), CHEAT_SHEET_ID, CHEAT_SHEET_UPDATE_ERROR);
    XAProjectExplorer.recordNewExampleProject (projectHandle, new ExampleProjectInfo (getQualifiedContextId (projDef.getHelpUrl ()), projDef.getCheatSheetId ()));
    if (projDef.getId ().equals (STARTER_EXAMPLE_PROJ_ID)) evaluateDerbyServiceStatus ();
    NavigatorView nv = XA_Designer_Plugin.getNavigatorView ();
    nv.recalculateExampleProjectStatus (projectHandle);
    if (fireProjectSpecifics && XA_Designer_Plugin.getActivePage ().isPartVisible (nv)) {
        try {
            XA_Designer_Plugin.getActivePage ().showView (GlobalConstants.ID_HELP_VIEW, null, IWorkbenchPage.VIEW_VISIBLE);
        } catch (PartInitException e) {
        }
        nv.getXawareResNav ().showDynamicHelp ();
        nv.getXawareResNav ().launchDerbyService ();
    }
    return true;
}


public static final List stringPlaceHolderDeepRemove (String pOriginalString, StringBuffer pStringBuffer, String pStartBrace, String pEndBrace, String pPlaceHolderStart, String pPlaceHolderEnd) throws ExTooFew {
    List lRestoreList = new ArrayList ();
    RestoreEntry lRestoreEntry;
    int lStartIndex, lEndIndex, lSeekIndex;
    int lCount = 0;
    END_LOOP : for (;;) {
        String lSeekString = pStringBuffer.toString ();
        lEndIndex = lSeekString.indexOf (pEndBrace);
        if (lEndIndex == - 1) {
            break END_LOOP;
        }
        lStartIndex = - 1;
        START_LOOP : while ((lSeekIndex = lSeekString.indexOf (pStartBrace, lStartIndex + 1)) != - 1 && lSeekIndex < lEndIndex) {
            lStartIndex = lSeekIndex;
        }
        if (lStartIndex == - 1) {
            throw new ExTooFew ("Mismatch of " + pStartBrace + "" + pEndBrace + " in: " + pOriginalString);
        }
        lRestoreEntry = new RestoreEntry ();
        lRestoreEntry.mHolder = pPlaceHolderStart + String.valueOf (lCount ++) + pPlaceHolderEnd;
        lRestoreEntry.mValue = pStringBuffer.substring (lStartIndex, lEndIndex + 1);
        lRestoreList.add (lRestoreEntry);
        pStringBuffer.replace (lStartIndex, lEndIndex + 1, lRestoreEntry.mHolder);
    }
    return lRestoreList;
}


-----Function Pair=67=-----==

private boolean jarSources (GlobalModel model, JarBuilder jar) {
    List < OpenDefinitionsDocument > srcs = model.getProjectDocuments ();
    Iterator < OpenDefinitionsDocument > iter = srcs.iterator ();
    while (iter.hasNext ()) {
        OpenDefinitionsDocument doc = iter.next ();
        if (doc.inProject () && ! doc.isAuxiliaryFile ()) {
            try {
                jar.addFile (doc.getFile (), packageNameToPath (doc.getPackageName ()), doc.getFileName ());
            } catch (IOException ioe) {
                _exceptions.add (ioe.getMessage ());
            }
        }
    }
    return true;
}


private static void recursiveFileDelete (String location) {
    File folder = new File (location);
    File [] listOfFiles = folder.listFiles ();
    Debug.print (FileSystem.class, folder.getAbsolutePath ());
    Debug.print (FileSystem.class, listOfFiles.length + "");
    for (int i = 0; i < listOfFiles.length; i ++) {
        File current = listOfFiles [i];
        if (listOfFiles [i].isDirectory ()) {
            recursiveFileDelete (current.getAbsolutePath ());
        }
        Debug.print (FileSystem.class, "Removing: " + current.getAbsolutePath ());
        while (current.exists ()) {
            current.delete ();
        }
    }
    folder.delete ();
    Debug.print (FileSystem.class, "Folder cleared");
}


-----Function Pair=68=-----==

public void run () {
    try {
        myDirectory = new File (MainFrame.class.getProtectionDomain ().getCodeSource ().getLocation ().toURI ());
        if (! myDirectory.isDirectory ()) {
            myDirectory = myDirectory.getParentFile ();
        }
        String path = myDirectory.getAbsolutePath ();
        String lafClassName = UIManager.getSystemLookAndFeelClassName ();
        ArrayList < String > otherArgs = new ArrayList < String > ();
        for (int i = 0; i < args.length; i ++) {
            if (args [i].equals ("--laf") && i + 1 < args.length) {
                lafClassName = args [i + 1];
                i ++;
            }
            else {
                otherArgs.add (args [i]);
            }
        }
        org.netbeans.swing.plaf.Startup.run (Class.forName (lafClassName), 0, null);
        String [] searchPath = PropertyEditorManager.getEditorSearchPath ();
        String [] newSearchPath = new String [searchPath.length + 1];
        newSearchPath [0] = "org.netbeans.beaninfo.editors";
        System.arraycopy (searchPath, 0, newSearchPath, 1, searchPath.length);
        PropertyEditorManager.setEditorSearchPath (newSearchPath);
        PropertyEditorManager.registerEditor (String [].class, StringArrayEditor.class);
        PropertyEditorManager.registerEditor (double [].class, DoubleArrayEditor.class);
        JFrame.setDefaultLookAndFeelDecorated (true);
        JDialog.setDefaultLookAndFeelDecorated (true);
        MainFrame w = new MainFrame (otherArgs.toArray (new String [0]));
        w.setLocationByPlatform (true);
        w.setVisible (true);
        w.messagesio = new NbIOProvider ().getIO ("Messages", new Action [0], IOContainer.getDefault ());
        w.messagesio.select ();
    } catch (Exception ex) {
        Logger.getLogger (MainFrame.class.getName ()).log (Level.SEVERE, "Could not start ProCamTracker", ex);
    }
}


private static boolean zipRecursively (File toBeZipped, File zipToCreate, List < String > filesToInclude) {
    if (zipToCreate.exists ()) {
        zipToCreate.delete ();
    }
    if (! zipToCreate.getParentFile ().exists ()) {
        if (! zipToCreate.getParentFile ().mkdirs ()) {
            return false;
        }
    }
    List < String > files = new ArrayList < String > ();
    MiscUtils.getAllFiles (files, toBeZipped);
    String parentDir = toBeZipped.getParentFile ().getAbsolutePath ();
    int entryNumber = 0;
    try {
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipToCreate));
        zos.setLevel (Deflater.BEST_COMPRESSION);
        for (ListIterator < String > li = files.listIterator (); li.hasNext ();) {
            File toBeAdded = new File ("" + li.next ());
            if (filesToInclude != null) {
                if (filesToInclude.contains (toBeAdded.getAbsolutePath ())) {
                    System.out.println ("MiscUtils.zipRecursively(..) -  contains, OK:" + toBeAdded.getAbsolutePath ());
                    MiscUtils.addToZip (parentDir, toBeAdded, zos);
                    entryNumber ++;
                }
            }
            else {
                MiscUtils.addToZip (parentDir, toBeAdded, zos);
                entryNumber ++;
            }
        }
        if (entryNumber == 0) {
            zos = null;
            zipToCreate.delete ();
            System.out.println ("MiscUtils.zipRecursively(..) - No entry added. Zip file have not been created.");
            return false;
        }
        zos.close ();
        return true;
    } catch (Exception ex) {
        ex.printStackTrace ();
        return false;
    }
}


-----Function Pair=69=-----==

public void handle (Request request, Response response) throws Exception {
    response.setContentType (ContentType.TEXT_HTML);
    String uri = request.getRequestUri ();
    File file = new File (ROOT + uri);
    if (file.isDirectory ()) {
        Writer writer = response.getWriter ();
        writer.write ("<ul>");
        File [] children = file.listFiles ();
        for (int i = 0; i < children.length; i ++) {
            File child = children [i];
            if (child.isDirectory ()) {
                writer.write ("<li><a href='" + child.getName () + "/'>" + child.getName () + "/</a>");
            }
            else {
                writer.write ("<li><a href='" + child.getName () + "'>" + child.getName () + "</a> ");
                writer.write (" (" + child.length () + " bytes)");
            }
        }
        writer.write ("</ul>");
    }
    else {
        String ext = IOUtil.getExtention (file.getName ()).toLowerCase ();
        String contentType = (String) mimeTypes.get (ext);
        OutputStream outputStream = response.getOutputStream ();
        InputStream inputStream = null;
        try {
            if (contentType == null) {
                contentType = ContentType.OCTET_STREAM;
            }
            response.setContentType (contentType);
            inputStream = IOUtil.openInputStream (file);
            IOUtil.copy (inputStream, outputStream);
        } finally {
            IOUtil.close (inputStream);
        }
    }
}


public static File createZip (File srcFolder, File destFolder, String zipName, boolean compress) {
    Zip64File zipFile = null;
    if (! srcFolder.isDirectory ()) {
        log.severe ("[createZip] The File object you have passed is NOT a folder! Nothing has been done, sorry.");
        return null;
    }
    if (zipName == null) {
        zipName = srcFolder.getName ();
        log.info ("[createZip] No zipName specified, using folder name instead: " + zipName);
    }
    try {
        File newZip = new File (destFolder, zipName);
        zipFile = new Zip64File (newZip);
        List < String > listOfFiles = listAllFilesAndFolders (srcFolder, new ArrayList < String > ());
        if (listOfFiles.size () == 0) {
            log.info ("[createZip] Found no files to put in the zip. Created empty Zip file anyway...");
            zipFile.close ();
            return new File (zipFile.getDiskFile ().getFileName ());
        }
        log.info ("[createZip] Working on zipFile: " + zipFile.getDiskFile ().getFileName ());
        log.info ("[createZip] Normalizing paths...");
        List < String > normalizedPaths = normalizePaths (srcFolder);
        for (int i = 0; i < normalizedPaths.size (); i ++) {
            String currentZipEntryPath = normalizedPaths.get (i);
            FileEntry entry = new FileEntry (currentZipEntryPath);
            File currentFile = new File (listOfFiles.get (i));
            writeEntry (zipFile, entry, currentFile, compress);
        }
        log.info ("[createZip] All Files written to zip file: " + zipFile.getDiskFile ().getFileName ());
        zipFile.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return new File (zipFile.getDiskFile ().getFileName ());
}


-----Function Pair=70=-----==

public void copyFiles (File src, File dest) throws IOException {
    if (! src.exists ()) {
        throw new IOException ("copyFiles: Can not find source: " + src.getAbsolutePath () + ".");
    }
    else if (! src.canRead ()) {
        throw new IOException ("copyFiles: No right to source: " + src.getAbsolutePath () + ".");
    }
    if (src.isDirectory ()) {
        if (! dest.exists ()) {
            if (! dest.mkdirs ()) {
                throw new IOException ("copyFiles: Could not create direcotry: " + dest.getAbsolutePath () + ".");
            }
        }
        String list [] = src.list ();
        for (int i = 0; i < list.length; i ++) {
            File dest1 = new File (dest, list [i]);
            File src1 = new File (src, list [i]);
            copyFiles (src1, dest1);
        }
    }
    else {
        FileInputStream fin = null;
        FileOutputStream fout = null;
        byte [] buffer = new byte [4096];
        int bytesRead;
        try {
            fin = new FileInputStream (src);
            fout = new FileOutputStream (dest);
            while ((bytesRead = fin.read (buffer)) >= 0) {
                fout.write (buffer, 0, bytesRead);
            }
        } catch (IOException e) {
            IOException wrapper = new IOException ("copyFiles: Unable to copy file: " + src.getAbsolutePath () + "to" + dest.getAbsolutePath () + ".");
            wrapper.initCause (e);
            wrapper.setStackTrace (e.getStackTrace ());
            throw wrapper;
        } finally {
            if (fin != null) {
                fin.close ();
            }
            if (fout != null) {
                fout.close ();
            }
        }
    }
}


public File createScript (String command, String dirName, Map < String, String > envVars) throws ExecutorException {
    File dir = new File (dirName);
    File commandFile = null;
    boolean isScript = false;
    if (dirName == null) {
        dirName = ".";
    }
    else if (! dirName.equals (".") && ! dir.isDirectory ()) {
        throw new ExecutorException (command, new FileNotFoundException (dir.getAbsolutePath ()));
    }
    try {
        commandFile = new File (dir, command);
        if (commandFile.exists () && commandFile.canRead ()) {
            FileInputStream commandFIS = new FileInputStream (commandFile);
            DataInputStream commandDIS = new DataInputStream (commandFIS);
            if (commandDIS.readChar () == '#' && commandDIS.readChar () == '!') {
                isScript = true;
            }
            commandFIS.close ();
            commandDIS.close ();
        }
    } catch (FileNotFoundException e) {
        throw new ExecutorException (command, new FileNotFoundException (commandFile.getAbsolutePath ()));
    } catch (IOException e) {
        throw new ExecutorException (command, e);
    }
    File temp;
    BufferedWriter writerTemp;
    String exportCommand = "export ";
    try {
        temp = TempFileManager.createTempFile ("broker", ".tmp", dir);
        writerTemp = new BufferedWriter (new FileWriter (temp));
        if (envVars != null) {
            if (! envVars.isEmpty ()) {
                for (String key : envVars.keySet ()) {
                    writerTemp.write (key + "=\'" + envVars.get (key) + "\'");
                    writerTemp.newLine ();
                    exportCommand = exportCommand + " " + key;
                }
            }
        }
        writerTemp.write ("PATH=$PATH:$PLAYPEN:$STORAGE:.");
        writerTemp.newLine ();
        exportCommand = exportCommand + " PATH";
        writerTemp.write (exportCommand);
        writerTemp.newLine ();
        if (isScript) {
            writerTemp.write ("sh ");
        }
        writerTemp.write (command);
        writerTemp.newLine ();
        writerTemp.flush ();
        writerTemp.close ();
        return temp;
    } catch (IOException ioe) {
        throw new ExecutorException (ioe);
    }
}


-----Function Pair=71=-----==

public OperatorDescription deserialize (String operatorName) throws SAXException, ParserConfigurationException, IOException, XMLParserException {
    OperatorDescription description = null;
    Enumeration < URL > opDescDirs = getClass ().getClassLoader ().getResources ("META-INF/operators");
    while (opDescDirs.hasMoreElements ()) {
        URL opDescDir = opDescDirs.nextElement ();
        File file = new File (opDescDir.getFile () + "/" + operatorName + ".xml");
        if (file.exists ()) {
            description = deserialize (file);
            break;
        }
    }
    if (description == null) {
        throw new IllegalArgumentException ("Descriptor for operator " + operatorName + " not found.");
    }
    else {
        return description;
    }
}


private void init () {
    setPreferredSize (new Dimension (600, 350));
    setTitle ("Regular Expression Match Tester");
    final Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    final int left = (int) screenSize.getWidth () / 2 - 300;
    final int right = (int) screenSize.getHeight () / 2 - 300;
    if (left > 0 && right > 0) {
        setLocation (left, right);
    }
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    textArea.getDocument ().addDocumentListener (new DocumentListener () {
        public void insertUpdate (DocumentEvent evt) {
            updateHighlighters ();
        } public void removeUpdate (DocumentEvent evt) {
            updateHighlighters ();
        } public void changedUpdate (DocumentEvent evt) {
            updateHighlighters ();
        }
    }
    );
    textField.getDocument ().addDocumentListener (new DocumentListener () {
        public void insertUpdate (DocumentEvent evt) {
            updateHighlighters ();
        } public void removeUpdate (DocumentEvent evt) {
            updateHighlighters ();
        } public void changedUpdate (DocumentEvent evt) {
            updateHighlighters ();
        }
    }
    );
    subSubPanel.add (toggle);
    toggle.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent arg0) {
            textArea.setLineWrap (toggle.isSelected ());
        }
    }
    );
    subPanel.add (label, BorderLayout.CENTER);
    subPanel.add (subSubPanel, BorderLayout.WEST);
    panel.add (subPanel, BorderLayout.NORTH);
    final Container contentPane = getContentPane ();
    contentPane.add (textField, BorderLayout.NORTH);
    contentPane.add (scrollPane, BorderLayout.CENTER);
    contentPane.add (panel, BorderLayout.SOUTH);
}


-----Function Pair=72=-----=1=

private void split () {
    this.length = 0;
    if (isEmptyString (this.stringToSplit)) {
        return;
    }
    if (isEmptyString (this.regexp)) {
        this.values = new String [] {this.stringToSplit};
        return;
    }
    final Pattern aPattern = Pattern.compile (this.regexp);
    final Matcher aMatcher = aPattern.matcher (this.stringToSplit);
    if (aMatcher.find () == false) {
        this.values = new String [] {this.stringToSplit};
        return;
    }
    aMatcher.reset ();
    final ArrayList < String > someValues = new ArrayList < String > ();
    int lastEnd = 0;
    while (aMatcher.find ()) {
        final String aDelimiter = this.stringToSplit.substring (aMatcher.start (), aMatcher.end ());
        if (aMatcher.start () > lastEnd) {
            someValues.add (this.stringToSplit.substring (lastEnd, aMatcher.start ()));
            if (lastEnd == 0) {
                someValues.add ("");
            }
            someValues.add (aDelimiter);
        }
        else {
            if (lastEnd > 0) {
                someValues.add ("");
            }
            someValues.add (aDelimiter);
        }
        lastEnd = aMatcher.end ();
    }
    if (lastEnd < this.stringToSplit.length ()) {
        someValues.add (this.stringToSplit.substring (lastEnd));
    }
    this.values = someValues.toArray (this.values);
    this.length = someValues.size ();
}


public LinkedList < Image > scanForMissingImages () {
    LinkedList < Image > undefinedImages = new LinkedList < Image > ();
    Pattern p = Pattern.compile (imagePattern);
    Matcher m = p.matcher (targetCode.toLowerCase ());
    while (m.find ()) {
        Pattern p1 = Pattern.compile (innerImagePattern);
        Matcher m1 = p1.matcher (m.group ().toLowerCase ());
        if (m1.find ()) {
            String [] src = null;
            if (m1.group ().contains ("\"")) src = m1.group ().split ("\"");
            else src = m1.group ().split ("'");
            if (! isImageAvailable (src [1])) {
                undefinedImages.add (new Image (src [1], m.start (), m.end ()));
                Activator.getDefault ().logDebuggingData ("[ImageScanner]: Added '" + src [1] + "' to the list of undefined images.");
            }
        }
    }
    return undefinedImages;
}


-----Function Pair=73=-----==

public String format (String string, VariableResolver resolver, List < Object > args) throws ParserException {
    StringBuffer sb = new StringBuffer ();
    Matcher m = Pattern.compile ("%\\{([^}]+)\\}").matcher (string);
    while (m.find ()) {
        m.appendReplacement (sb, resolver.getVariable (m.group (1)).toString ());
    }
    m.appendTail (sb);
    if (args == null) {
        return sb.toString ();
    }
    Object [] argArray = args.toArray ();
    for (int i = 0; i < argArray.length; i ++) {
        if (argArray [i] instanceof BigDecimal) {
            BigDecimal bd = (BigDecimal) argArray [i];
            if (bd.scale () < 1) {
                argArray [i] = bd.toBigInteger ();
            }
        }
    }
    try {
        return String.format (sb.toString (), argArray);
    } catch (IllegalFormatConversionException e) {
        throw new ParserException (e.getMessage ());
    }
}


public final ArrayList < Occurrence > findPattern (final String regExPatternToFind, final String stringToParse) {
    final Pattern COMPARISON_PATTERN = Pattern.compile (regExPatternToFind);
    final Matcher COMPARATOR = COMPARISON_PATTERN.matcher (stringToParse);
    final ArrayList < Occurrence > OCCURRENCE_LIST = new ArrayList < > ();
    while (COMPARATOR.find ()) {
        final String foundString = COMPARATOR.group ();
        final int startPosition = COMPARATOR.start ();
        final int endPosition = COMPARATOR.end ();
        final Occurrence occurrence = new Occurrence (foundString, startPosition, endPosition);
        OCCURRENCE_LIST.add (occurrence);
    }
    return OCCURRENCE_LIST;
}


-----Function Pair=74=-----==

private int getChildCount (String xpath, WidgetType widgetType) throws ToolkitRendererException, AuthenticationException {
    int amountOfChildren = 0;
    Document widgetTree = null;
    try {
        widgetTree = DocumentHelper.parseText (getObjectModelAsString ());
    } catch (DocumentException e1) {
        String message = "A DocumentException occurred during parsing of the object model: [" + getObjectModelAsString () + "]";
        LOGGER.error (message);
        throw new ToolkitRendererException (message, e1);
    }
    List < Node > nodes;
    try {
        Dom4jXPath expression = new Dom4jXPath (xpath);
        Node node = (Node) expression.selectSingleNode (widgetTree);
        if (LOGGER.isDebugEnabled ()) {
            LOGGER.debug ("found node: " + node.getUniquePath () + ";" + node.asXML ());
        }
        String xpathToChildWidgets = "./widget[@widgetType='" + widgetType.getName () + "']";
        expression = new Dom4jXPath (xpathToChildWidgets);
        nodes = expression.selectNodes (node);
    } catch (JaxenException e) {
        String message = "A JaxenException occurred in getChildCount(xpath, widgetType) for xpath '" + xpath + "' and widgetType '" + widgetType.getName ();
        LOGGER.error (message);
        throw new ToolkitRendererException (message, e);
    }
    amountOfChildren = nodes.size ();
    if (LOGGER.isDebugEnabled ()) {
        LOGGER.debug ("found " + nodes.size () + " child nodes");
    }
    return amountOfChildren;
}


protected LD getLD (Element ldElem) {
    if (ldElem != null && ldElem.getName ().equals ("LD")) {
        List content = ldElem.getChildren ();
        int size = content.size ();
        if (size > 0) {
            Hashtable < Integer, Rung > hashTable = new Hashtable < Integer, Rung > (size);
            Iterator iterator = content.iterator ();
            int count = 0;
            while (iterator.hasNext ()) {
                Element currentElement = (Element) iterator.next ();
                Rung rung = getRung (currentElement);
                hashTable.put (new Integer (count), rung);
                count ++;
            }
            LD ld = new LD (hashTable);
            return ld;
        }
        else {
            System.err.println ("Invalid child element size in getLD()");
            if (this.console != null) {
                console.setText ("Invalid child element size in getLD()");
            }
            return null;
        }
    }
    else {
        System.err.println ("Invalid element input in getLD()");
        if (this.console != null) {
            console.setText ("Invalid element input in getLD()");
        }
        return null;
    }
}


-----Function Pair=75=-----==

protected void ConvertSpotColors () {
    int pos = 0, lastPos = 0, prevLastPos = 0;
    String blobAsString = new String (mBlob);
    String rgbCommand = "";
    String cmykCommand = "";
    ByteArrayOutputStream theBlob = new ByteArrayOutputStream ();
    Pattern p = Pattern.compile ("\\d+.\\d+ \\d+.\\d+ \\d+.\\d+ setrgbcolor");
    Matcher m = p.matcher (blobAsString);
    while (m.find ()) {
        lastPos = m.end ();
        pos = m.start ();
        rgbCommand = blobAsString.substring (pos, lastPos);
        cmykCommand = GetCMYKCommand (rgbCommand);
        theBlob.write (mBlob, prevLastPos, pos - prevLastPos);
        theBlob.write (cmykCommand.getBytes (), 0, cmykCommand.length ());
        prevLastPos = lastPos;
    }
    theBlob.write (mBlob, prevLastPos, mBlob.length - prevLastPos);
    mBlob = theBlob.toByteArray ();
}


public String [] getIdSet (String query) {
    int setSize = getIdSetSize (query);
    String resultSet [] = new String [setSize];
    String fullURLStr = solrBaseURL + "/select/?q=" + query + "&wt=json&qt=standard&indent=on&fl=id&start=0&rows=" + setSize;
    if (verbose) System.err.println ("Full URL for search = " + fullURLStr);
    URL fullURL = null;
    try {
        fullURL = new URL (fullURLStr);
    } catch (MalformedURLException e1) {
        e1.printStackTrace ();
    }
    BufferedReader sIn = null;
    try {
        sIn = new BufferedReader (new InputStreamReader (fullURL.openStream (), "UTF-8"));
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    String line;
    int numFound = 0;
    int count = 0;
    try {
        while ((line = sIn.readLine ()) != null) {
            if (line.contains ("\"id\":")) {
                String id = line.replaceFirst (".*:[^\"]?\"([-A-Za-z0-9_]*).*", "$1");
                if (veryverbose) System.err.println ("record num = " + (count) + "  id = " + id);
                resultSet [count ++] = id;
            }
        }
    } catch (NumberFormatException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return (resultSet);
}


-----Function Pair=76=-----==

private void setResult () {
    PredictionModel model = selectedModel ();
    maxScore = result.getMaxPredictionScore (model);
    minScore = result.getMinPredictionScore (model);
    SpecificityEstimator est = model.getSpecEstimator ();
    if (est != null) {
        double spec1 = est.threshold (1.0);
        double spec0 = est.threshold (0.0);
        if (maxScore < spec1) {
            maxScore = spec1;
        }
        if (minScore > spec0) {
            minScore = spec0;
        }
        threshold = result.getThreshold (model);
        if (Double.isInfinite (threshold)) {
            threshold = est.threshold (0.95);
        }
        else {
            specificity = est.specificity (threshold);
        }
    }
    else {
        this.threshold = (maxScore + minScore) / 2;
    }
    result.setThreshold (model, threshold);
    double eps = (maxScore - minScore) / maxTick;
    maxScore += eps;
    minScore -= eps;
    ignoreSlideChangeEvent = true;
    setSliderTitleModel ();
    String textSpec;
    if (est == null) {
        textSpec = "N/A";
        specificityTextField.setEditable (false);
    }
    else {
        textSpec = String.format ("%.2f", specificity * 100);
    }
    specificityTextField.setText (textSpec);
    scoreCutoffTextField.setText (String.format ("%.2f", threshold));
    setSliderLabels ();
    setMapScoreColor ();
    specificitySlider.setValue ((int) Math.round (maxTick * (threshold - minScore) / (maxScore - minScore)));
    ignoreSlideChangeEvent = false;
}


public static void main (String [] args) {
    System.out.println ("Input any text with Unicode symbols: \\u**** (or &#****; if the program started with &#; parameter). Type 'stop' to exit");
    System.out.println ("If you want to read from and save to file, use < and > command line syntax");
    String unicode = "\\u";
    if (args.length > 0) unicode = args [0];
    try {
        BufferedReader reader = new BufferedReader (new InputStreamReader (System.in));
        Writer writer = new OutputStreamWriter (System.out);
        String delim = " ";
        Pattern pattern = Pattern.compile (delim);
        while (true) {
            String ss = reader.readLine ();
            if (ss == null || "stop".equalsIgnoreCase (ss)) break;
            Matcher m = pattern.matcher (ss);
            int i = 0;
            while (m.find ()) {
                String s = ss.substring (i, m.start ());
                i = m.end ();
                decode (writer, s, unicode);
                writer.write (delim);
            }
            if (i < ss.length ()) decode (writer, ss.substring (i), unicode);
            writer.write ("\r\n");
            writer.flush ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=77=-----==

public void parse (String input, String newDTD, boolean isFile, JTextPane console) throws IOException, JDOMException {
    this.console = console;
    this.isFile = isFile;
    input = removeInvalidChars (input);
    if (isFile) {
        if (newDTD != null) {
            try {
                xmlDocument = ParserLib.parser (new StringReader (changeDTD (input, isFile, newDTD).toString ()), false);
            } catch (Exception e) {
                System.out.println (input);
                e.printStackTrace ();
            }
        }
        else {
            xmlDocument = ParserLib.parser (input, false);
        }
        if (xmlDocument == null) {
            System.exit (0);
        }
        ParserLib.validator (xmlDocument);
        result = ParserLib.xmlOutputter.outputString (xmlDocument);
    }
    else {
        String in = new String (input);
        in = in.replace ("http://www.holobloc.com/xml/LibraryElement.dtd", newDTD);
        xmlDocument = preProcess (in);
        ParserLib.validator (xmlDocument);
        result = ParserLib.xmlOutputter.outputString (xmlDocument);
    }
    if (xmlDocument != null) {
    }
}


private void parseTemplate () {
    Pattern protocolPattern = Pattern.compile ("[^:]*:[^:]*:");
    String template2 = "";
    Matcher matcher = protocolPattern.matcher (template);
    if (matcher.find ()) {
        jdbcProtocol = template.substring (0, matcher.end ());
        template2 = template.substring (matcher.end (), template.length ());
    }
    matcher = PATTERN.matcher (template2);
    int start = 0;
    while (matcher.find ()) {
        String part = template2.substring (start, matcher.start ());
        parts.add (part);
        String var = matcher.group (1);
        variables.add (var);
        varMap.put (var, null);
        start = matcher.end ();
    }
    if (start < template2.length ()) {
        parts.add (template2.substring (start));
    }
}


-----Function Pair=78=-----==

public static String getHumanPresentation (String propertyName) {
    Pattern pattern = Pattern.compile ("\\p{Upper}+");
    Matcher matcher = pattern.matcher (propertyName);
    StringBuffer result = new StringBuffer (propertyName);
    int offset = 0;
    while (matcher.find ()) {
        String capitalsLetters = propertyName.substring (matcher.start (), matcher.end ());
        if (capitalsLetters.length () == 1) {
            capitalsLetters = capitalsLetters.toLowerCase ();
        }
        result.replace (matcher.start () + offset, matcher.end () + offset, " " + capitalsLetters);
        offset ++;
    }
    if (result.substring (0, 1).equals (" ")) {
        result.delete (0, 1);
    }
    String firstLetter = result.substring (0, 1).toUpperCase ();
    result.replace (0, 1, firstLetter);
    return result.toString ();
}


private void buildQuery (String [] split, SqlQuery sq) throws SqlParseException {
    Builder curBuilder = null;
    List < String > expr = new ArrayList < String > ();
    for (String s : split) {
        Builder builder = getBuilder (s);
        if (builder != null) {
            if (curBuilder != null) {
                curBuilder.build (sq, expr, quotedStrings);
            }
            curBuilder = builder;
            expr.clear ();
        }
        else {
            expr.add (s);
        }
    }
    if (expr.size () > 0) {
        if (curBuilder != null) curBuilder.build (sq, expr, quotedStrings);
        else throw new SqlParseException ("Invalid Query. No FROM part.");
    }
}


-----Function Pair=79=-----==

public void buildClusterer (Instances data) throws Exception {
    m_instances = data;
    int nInstances = m_instances.numInstances ();
    if (nInstances == 0) {
        return;
    }
    m_DistanceFunction.setInstances (m_instances);
    Vector < Integer > [] nClusterID = new Vector [data.numInstances ()];
    for (int i = 0; i < data.numInstances (); i ++) {
        nClusterID [i] = new Vector < Integer > ();
        nClusterID [i].add (i);
    }
    int nClusters = data.numInstances ();
    Node [] clusterNodes = new Node [nInstances];
    if (m_nLinkType == NEIGHBOR_JOINING) {
        neighborJoining (nClusters, nClusterID, clusterNodes);
    }
    else {
        doLinkClustering (nClusters, nClusterID, clusterNodes);
    }
    int iCurrent = 0;
    m_clusters = new Node [m_nNumClusters];
    m_nClusterNr = new int [nInstances];
    for (int i = 0; i < nInstances; i ++) {
        if (nClusterID [i].size () > 0) {
            for (int j = 0; j < nClusterID [i].size (); j ++) {
                m_nClusterNr [nClusterID [i].elementAt (j)] = iCurrent;
            }
            m_clusters [iCurrent] = clusterNodes [i];
            iCurrent ++;
        }
    }
}


static double [] [] normalizeColumns (double [] [] xs) {
    int numDims = xs.length;
    int order = xs [0].length;
    double [] [] result = new double [numDims] [order];
    for (int j = 0; j < order; ++ j) {
        double sumOfSquares = 0.0;
        for (int i = 0; i < numDims; ++ i) {
            double valIJ = xs [i] [j];
            result [i] [j] = valIJ;
            sumOfSquares += valIJ * valIJ;
        }
        double length = Math.sqrt (sumOfSquares);
        for (int i = 0; i < numDims; ++ i) result [i] [j] /= length;
    }
    return result;
}


-----Function Pair=80=-----==

public static Image [] loadSequenceImages (String fileName, String range) {
    try {
        int start_range = - 1;
        int end_range = - 1;
        int images_count = 1;
        int minusIndex = range.indexOf ('-');
        if ((minusIndex > 0) && (minusIndex < (range.length () - 1))) {
            try {
                start_range = Integer.parseInt (range.substring (0, minusIndex));
                end_range = Integer.parseInt (range.substring (minusIndex + 1));
                if (start_range < end_range) {
                    images_count = end_range - start_range + 1;
                }
            } catch (Exception ex) {
                ex.printStackTrace ();
            }
        }
        Image [] images = new Image [images_count];
        for (int i = 0; i < images_count; i ++) {
            String imageName = fileName;
            if (images_count > 1) {
                int dotIndex = fileName.lastIndexOf ('.');
                if (dotIndex >= 0) {
                    imageName = fileName.substring (0, dotIndex) + (start_range + i) + fileName.substring (dotIndex);
                }
            }
            images [i] = GraphicsUtils.loadImage (imageName);
        }
        return images;
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return null;
}


private void zoomOutLittle () {
    double midX = (zoomMinComp1 + zoomMaxComp1) / (double) 2.0;
    double midY = (zoomMinComp2 + zoomMaxComp2) / (double) 2.0;
    double tmpMinX, tmpMaxX;
    double tmpMinY, tmpMaxY;
    if (((midX - zoomMinComp1) > 0) && ((zoomMaxComp1 - midX) > 0)) {
        tmpMinX = (int) (java.lang.Math.round (midX - (midX - zoomMinComp1) * 1.5));
        tmpMaxX = (int) (java.lang.Math.round (midX + (zoomMaxComp1 - midX) * 1.5));
    }
    else {
        tmpMinX = zoomMinComp1 - 1;
        tmpMaxX = zoomMaxComp1 + 1;
    }
    if (((midY - zoomMinComp2) > 0) && ((zoomMaxComp2 - midY) > 0)) {
        tmpMinY = midY - (midY - zoomMinComp2) * (double) 1.5;
        tmpMaxY = midY + (zoomMaxComp2 - midY) * (double) 1.5;
    }
    else {
        tmpMinY = zoomMinComp2 - 1;
        tmpMaxY = zoomMaxComp2 + 1;
    }
    if (tmpMinX < minComp1) {
        tmpMinX = minComp1;
    }
    if (tmpMaxX > maxComp1) {
        tmpMaxX = maxComp1;
    }
    if (tmpMinY < minComp2) {
        tmpMinY = minComp2;
    }
    if (tmpMaxY > maxComp2) {
        tmpMaxY = maxComp2;
    }
    zoomMinComp1 = tmpMinX;
    zoomMaxComp1 = tmpMaxX;
    zoomMinComp2 = tmpMinY;
    zoomMaxComp2 = tmpMaxY;
}


-----Function Pair=81=-----==

public static void printCompare (PrintWriter f, String msg, float [] [] A, float [] [] B) {
    int nr = A.length;
    int nc = A [0].length;
    f.println (msg);
    for (int ir = 0; ir < nr; ir ++) {
        f.print ("[ ");
        if (nc <= 5) {
            for (int ic = 0; ic < nc; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
        }
        else {
            for (int ic = 0; ic < 4; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
            f.print (" ... ");
            for (int ic = nc - 2; ic < nc; ic ++) {
                f.print (_nf.format (A [ir] [ic]) + "  ");
            }
        }
        f.print ("] vs. [");
        if (nc <= 5) {
            for (int ic = 0; ic < nc; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
        }
        else {
            for (int ic = 0; ic < 4; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
            f.print (" ... ");
            for (int ic = nc - 2; ic < nc; ic ++) {
                f.print (_nf.format (B [ir] [ic]) + "  ");
            }
        }
        f.println ("]");
    }
    f.flush ();
}


final void drawFilter (final ClusterData cd, float [] [] [] fr, Color color) {
    int xp0 = 0;
    int xp2 = 0;
    int x0 = 0;
    int x2 = 0;
    if (! mapToRoad) {
        xp0 = Math.round (cd.xp [0]);
        x0 = Math.round (cd.x [0]);
        xp2 = Math.round (cd.xp [2]);
        x2 = Math.round (cd.x [2]);
    }
    else {
        Point2D.Float predXInPx = pixelYAtDist (new Point2D.Float (cd.xp [2], cd.xp [0]));
        Point2D.Float xInPx = pixelYAtDist (new Point2D.Float (cd.x [2], cd.x [0]));
        xp0 = Math.round (predXInPx.y);
        x0 = Math.round (xInPx.y);
        xp2 = Math.round (predXInPx.x);
        x2 = Math.round (xInPx.x);
    }
    colorPixel (x2, x0, fr, color);
    colorPixel (xp2 - 1, xp0, fr, color);
    colorPixel (xp2 + 1, xp0, fr, color);
    colorPixel (xp2, xp0 - 1, fr, color);
    colorPixel (xp2, xp0 + 1, fr, color);
}


-----Function Pair=82=-----==

public static float [] deriveCenterOfGravity (float [] [] system) {
    float x, y, z;
    x = 0.0f;
    y = 0.0f;
    z = 0.0f;
    for (int i = 0; i < system.length; i ++) {
        x += system [i] [0];
        y += system [i] [1];
        z += system [i] [2];
    }
    float [] result = new float [3];
    result [0] = x / system.length;
    result [1] = y / system.length;
    result [2] = z / system.length;
    return result;
}


private boolean nextPossibleNoise (int [] possibleNoise, int [] lowPossibleNoise, int [] hihPossibleNoise) {
    boolean possible = false;
    if (possibleNoise [0] == - 2) {
        for (int i = 0; i < possibleNoise.length; i ++) {
            if (hihPossibleNoise [i] != - 1) {
                possibleNoise [i] = lowPossibleNoise [i];
                possible = true;
            }
        }
    }
    else {
        for (int i = possibleNoise.length - 1; i >= 0; i --) {
            if (hihPossibleNoise [i] != - 1) {
                possibleNoise [i] ++;
                if (possibleNoise [i] <= hihPossibleNoise [i]) {
                    i = - 1;
                    possible = true;
                }
                else {
                    possibleNoise [i] = lowPossibleNoise [i];
                }
            }
        }
    }
    return possible;
}


-----Function Pair=83=-----==

public double [] [] getDataByDouble () {
    double [] [] fReturn = null;
    if (! isValid ()) return fReturn;
    int nRows;
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) nRows = 2;
    else nRows = sData.length;
    int nCols = sData [0].length;
    fReturn = new double [nRows] [nCols];
    if (this.sChartType.equals (CT_SCATTER2D) && this.sData.length < 2) {
        for (int j = 0; j < nCols; j ++) {
            fReturn [0] [j] = j + 1;
            try {
                fReturn [0] [j] = Double.parseDouble ((sData [0] [j] == null) ? "0" : sData [0] [j]);
            } catch (NumberFormatException ex) {
                fReturn [0] [j] = 0.0;
            }
        }
    }
    else for (int i = 0; i < nRows; i ++) for (int j = 0; j < nCols; j ++) {
        try {
            fReturn [i] [j] = Double.parseDouble ((sData [i] [j] == null) ? "0" : sData [i] [j]);
        } catch (NumberFormatException ex) {
            fReturn [i] [j] = 0.0;
        }
    }
    return fReturn;
}


private List < Tree > readTreesBlock (List < Taxon > taxonList) throws ImportException, IOException {
    List < Tree > trees = new ArrayList < Tree > ();
    String [] lastToken = new String [1];
    translationMap = readTranslationMap (taxonList, lastToken);
    while (true) {
        RootedTree tree = readNextTree (lastToken);
        if (tree == null) {
            break;
        }
        trees.add (tree);
    }
    if (trees.size () == 0) {
        throw new ImportException.BadFormatException ("No trees defined in TREES block");
    }
    nextBlock = NexusBlock.UNKNOWN;
    return trees;
}


-----Function Pair=84=-----==

public void copyFromEnv (EPlusWorkEnv env) {
    IDFDir = env.IDFDir;
    IDFTemplate = env.IDFTemplate;
    WeatherDir = env.WeatherDir;
    WeatherFile = env.WeatherFile;
    UseReadVars = env.UseReadVars;
    RVIDir = env.RVIDir;
    RVIFile = env.RVIFile;
    ProjectType = env.ProjectType;
    DCKDir = env.DCKDir;
    DCKTemplate = env.DCKTemplate;
    OutputFileNames = env.OutputFileNames;
    ExecSettings.setParentDir (env.ParentDir);
    ExecSettings.setKeepEPlusFiles (env.KeepEPlusFiles);
    ExecSettings.setKeepJEPlusFiles (env.KeepJEPlusFiles);
    ExecSettings.setKeepJobDir (env.KeepJobDir);
    ExecSettings.setRerunAll (env.ForceRerun);
}


public static float [] [] UpperTriangle (float [] [] m) {
    float f1 = 0;
    float temp = 0;
    int tms = m.length;
    int v = 1;
    iDF = 1;
    for (int col = 0; col < tms - 1; col ++) {
        for (int row = col + 1; row < tms; row ++) {
            v = 1;
            outahere : while (m [col] [col] == 0) {
                if (col + v >= tms) {
                    iDF = 0;
                    break outahere;
                }
                else {
                    for (int c = 0; c < tms; c ++) {
                        temp = m [col] [c];
                        m [col] [c] = m [col + v] [c];
                        m [col + v] [c] = temp;
                    }
                    v ++;
                    iDF = iDF * - 1;
                }
            }
            if (m [col] [col] != 0) {
                try {
                    f1 = (- 1) * m [row] [col] / m [col] [col];
                    for (int i = col; i < tms; i ++) {
                        m [row] [i] = f1 * m [col] [i] + m [row] [i];
                    }
                } catch (Exception e) {
                    System.out.println ("Still Here!!!");
                }
            }
        }
    }
    return m;
}


-----Function Pair=85=-----==

public static Element [] [] invertArray (Element [] [] D, int n) {
    Field field = D [0] [0].getField ();
    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            D [i] [j + n] = field.newZeroElement ();
        }
        D [i] [i + n] = field.newOneElement ();
    }
    int n2 = 2 * n;
    for (int i = 0; i < n; i ++) {
        Element alpha = D [i] [i].duplicate ();
        if (alpha.isZero ()) {
            throw new IllegalArgumentException ("Singular matrix, cannot invert");
        }
        else {
            for (int j = 0; j < n2; j ++) {
                D [i] [j].div (alpha);
            }
            for (int k = 0; k < n; k ++) {
                if ((k - i) != 0) {
                    Element beta = D [k] [i].duplicate ();
                    for (int j = 0; j < n2; j ++) {
                        D [k] [j].sub (beta.duplicate ().mul (D [i] [j]));
                    }
                }
            }
        }
    }
    return D;
}


public static Matrix read (BufferedReader input) throws java.io.IOException {
    StreamTokenizer tokenizer = new StreamTokenizer (input);
    tokenizer.resetSyntax ();
    tokenizer.wordChars (0, 255);
    tokenizer.whitespaceChars (0, ' ');
    tokenizer.eolIsSignificant (true);
    java.util.Vector v = new java.util.Vector ();
    while (tokenizer.nextToken () == StreamTokenizer.TT_EOL);
    if (tokenizer.ttype == StreamTokenizer.TT_EOF) throw new java.io.IOException ("Unexpected EOF on matrix read.");
    do {
        v.addElement (Double.valueOf (tokenizer.sval));
    }
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
    int n = v.size ();
    double row [] = new double [n];
    for (int j = 0; j < n; j ++) row [j] = ((Double) v.elementAt (j)).doubleValue ();
    v.removeAllElements ();
    v.addElement (row);
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD) {
        v.addElement (row = new double [n]);
        int j = 0;
        do {
            if (j >= n) throw new java.io.IOException ("Row " + v.size () + " is too long.");
            row [j ++] = Double.valueOf (tokenizer.sval).doubleValue ();
        }
        while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
        if (j < n) throw new java.io.IOException ("Row " + v.size () + " is too short.");
    }
    int m = v.size ();
    double [] [] A = new double [m] [];
    v.copyInto (A);
    return new Matrix (A);
}


-----Function Pair=86=-----==

private static int [] getIandJ (double c) {
    int [] result = new int [2];
    double rnd = Math.random ();
    if (rnd <= (1 - c)) {
        result [0] = 0;
    }
    else {
        rnd = Math.random ();
        if (rnd <= 0.25) result [0] = 1;
        if (rnd <= 0.50 && rnd > 0.25) result [0] = 2;
        if (rnd <= 0.75 && rnd > 0.50) result [0] = 3;
        if (rnd > 0.75) result [0] = 4;
    }
    rnd = Math.random ();
    if (rnd <= (1 - c)) {
        result [1] = 0;
    }
    else {
        rnd = Math.random ();
        if (rnd <= 0.25) result [1] = 1;
        if (rnd <= 0.50 && rnd > 0.25) result [1] = 2;
        if (rnd <= 0.75 && rnd > 0.50) result [1] = 3;
        if (rnd > 0.75) result [1] = 4;
    }
    return result;
}


protected int nonZeroNumL (int pos) {
    int count = 0;
    if (isDual) {
        for (int i = 0; i < ncols; i ++) {
            if ((data [0] [i] != null && this.pos [0] [i] == pos) || (data [1] [i] != null && this.pos [1] [i] == pos)) {
                count ++;
            }
        }
    }
    else {
        for (int i = 0; i < nrows; i ++) {
            if ((data [i] [0] != null && this.pos [i] [0] == pos) || (data [i] [1] != null && this.pos [i] [1] == pos)) {
                count ++;
            }
        }
    }
    return count;
}


-----Function Pair=87=-----==

public static void colvaxpy_j (int nrow, double a, double x [] [], double y [], int begin, int j) {
    int i, m, mpbegin, end;
    if (nrow <= 0) return;
    if (a == 0.0) return;
    m = nrow % 4;
    mpbegin = m + begin;
    end = begin + nrow - 1;
    for (i = begin; i < mpbegin; i ++) {
        y [i] += a * x [i] [j];
    }
    for (i = mpbegin; i <= end; i += 4) {
        y [i] += a * x [i] [j];
        y [i + 1] += a * x [i + 1] [j];
        y [i + 2] += a * x [i + 2] [j];
        y [i + 3] += a * x [i + 3] [j];
    }
    return;
}


private void resizeBs () {
    int newSize = (buildingXs.length * 2);
    int [] newXs = new int [newSize];
    int [] newYs = new int [newSize];
    int [] newEnt = new int [newSize];
    int [] newFloors = new int [newSize];
    int [] newTypes = new int [newSize];
    int [] [] [] newApi = new int [newSize] [] [];
    System.arraycopy (buildingXs, 0, newXs, 0, buildingCount);
    System.arraycopy (buildingYs, 0, newYs, 0, buildingCount);
    System.arraycopy (buildingEntrances, 0, newEnt, 0, buildingCount);
    System.arraycopy (buildingFloors, 0, newFloors, 0, buildingCount);
    System.arraycopy (buildingTypes, 0, newTypes, 0, buildingCount);
    for (int i = 0; i < buildingCount; i ++) newApi [i] = buildingApi [i];
    buildingXs = newXs;
    buildingYs = newYs;
    buildingEntrances = newEnt;
    buildingFloors = newFloors;
    buildingTypes = newTypes;
    buildingApi = newApi;
}


-----Function Pair=88=-----==

public void run () {
    Class c;
    Class [] actionTypes, parameterTypes;
    Constructor cc;
    int parameterCount;
    Method method;
    Object [] parameterObjects;
    String actionName, taskName, logText;
    String [] stringParameters;
    StringBuffer logBuffer;
    Task task;
    Assignment asgn = null;
    Document doc = null;
    try {
        asgn = new Assignment (username, assignmentName);
    } catch (IOException ex) {
        Throwable cause = ex.getCause ();
        log ("   There was a problem accessing your files.");
        log ("   Assignment: " + ex.toString ());
        if (cause != null) log ("      Cause: " + cause.toString ());
        return;
    }
    Actions acts = new Actions (this);
    Accounts.setRunStatus (username, "Assignment parsed");
    int taskCount = asgn.getTaskCount ();
    for (int tasknum = 1; tasknum <= taskCount; tasknum ++) {
        if (Thread.interrupted () == true) return;
        taskName = asgn.getTaskName (tasknum);
        logBuffer = new StringBuffer (taskName + "( ");
        parameterObjects = asgn.getParameters (tasknum, - 1);
        parameterCount = parameterObjects.length;
        for (int p = 0; p < parameterCount; p ++) {
            logBuffer.append (parameterObjects [p].toString () + ", ");
        }
        logBuffer.append (")");
        log ("");
        log (new String (logBuffer));
        if (localRun) System.out.println ("   " + logBuffer.toString ());
        if (taskName.compareTo ("Execute") == 0) {
            parameterCount ++;
            parameterObjects = exec (parameterObjects);
        }
        parameterTypes = new Class [parameterCount];
        for (int j = 0; j < parameterCount; j ++) parameterTypes [j] = String.class;
        try {
            logText = null;
            c = Class.forName (taskName);
            cc = c.getConstructor (parameterTypes);
            task = (Task) cc.newInstance (parameterObjects);
            doc = task.getResult ();
            if (task.getSuccessFlag () == false) logText = "Last status: " + task.getStatus ();
        } catch (ClassNotFoundException ex) {
            logText = "Could not find the task";
            log (logText);
            log (ex.toString ());
        } catch (InstantiationException ex) {
            logText = "The task couldn't be created";
            log (logText);
            log (ex.toString ());
        } catch (NoSuchMethodException ex) {
            logText = "The task tried to call a non-existent method";
            log (logText);
            log (ex.toString ());
        } catch (SecurityException ex) {
            logText = "The task tried to do something it isn't allowed to";
            log (logText);
            log (ex.toString ());
        } catch (IllegalAccessException ex) {
            logText = "The server is incorrectly configured";
            log (logText);
            log (ex.toString ());
        } catch (InvocationTargetException ex) {
            logText = "The task caused a target error";
            log (logText);
            log (ex.toString ());
        } catch (RuntimeException ex) {
            logText = "The task generated a runtime exception";
            StringWriter sw = new StringWriter ();
            ex.printStackTrace (new PrintWriter (sw));
            log (logText);
            log (ex.toString ());
            log ("");
            log (sw.toString ());
        }
        if (logText != null) {
            try {
                ResultHelper xml = new ResultHelper ("Failed: " + logText, taskName, "text/plain", "Colander Error", "Colander");
                doc = xml.getDocument ();
            } catch (ParserConfigurationException ex) {
                continue;
            }
            log (logText);
        }
        try {
            acts.setDocument (doc);
            c = acts.getClass ();
            if (ServerProperties.isDebugModeSet ()) {
                if (Thread.interrupted () == true) return;
                String [] sArray = {"debug_" + tasknum + "_result.log"};
                Class [] cArray = new Class [1];
                cArray [0] = String.class;
                method = c.getMethod ("toFile", cArray);
                method.invoke (acts, (Object []) sArray);
            }
            int actionCount = asgn.getActionCount (tasknum);
            for (int action = 1; action <= actionCount; action ++) {
                if (Thread.interrupted () == true) return;
                actionName = asgn.getActionName (tasknum, action);
                stringParameters = asgn.getParameters (tasknum, action);
                actionTypes = new Class [stringParameters.length];
                logBuffer = new StringBuffer ("   " + actionName + "( ");
                for (int apc = 0; apc < stringParameters.length; apc ++) {
                    actionTypes [apc] = String.class;
                    logBuffer.append (stringParameters [apc] + ", ");
                }
                logBuffer.append (")");
                log (new String (logBuffer));
                method = c.getMethod (actionName, actionTypes);
                method.invoke (acts, (Object []) stringParameters);
            }
        } catch (NoSuchMethodException ex) {
            log ("The assignment tried to call a non-existent action");
            log (ex.toString ());
        } catch (SecurityException ex) {
            log ("The action tried to do something it isn't allowed to");
            log (ex.toString ());
        } catch (IllegalAccessException ex) {
            log ("The server is incorrectly configured");
            log (ex.toString ());
        } catch (InvocationTargetException ex) {
            log ("The action caused the following error:");
            log ("thrown by: " + ex.getCause ().toString ());
        } catch (RuntimeException ex) {
            StringWriter sw = new StringWriter ();
            ex.printStackTrace (new PrintWriter (sw));
            log ("The action generated a runtime exception");
            log (ex.toString ());
            log ("");
            log (sw.toString ());
        }
        Accounts.setRunStatus (username, "Completed " + tasknum + " of " + taskCount + " tasks");
    }
    log ("");
    log ("All tasks have been run.");
}


void processForeachRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variable in FOREACH");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in FOREACH");
    String file_name = pst.nextToken ();
    String select = null;
    String start = null;
    String end = null;
    boolean inRange = false;
    if (pst.hasMoreTokens ()) {
        select = pst.nextToken ();
        if (! pst.hasMoreTokens ()) throw new IOException ("Missing field value in FOREACH");
        String fval = pst.nextToken ();
        int dotdot = fval.indexOf ("..");
        if (dotdot != - 1 && dotdot == fval.lastIndexOf ("..")) {
            start = fval.substring (0, dotdot);
            end = fval.substring (dotdot + 2);
        }
        else {
            start = fval;
        }
    }
    if (DEBUG) System.out.println ("doing foreach with varname " + var_name + " on data file :" + file_name);
    if (DEBUG && select != null) {
        System.out.print ("   selecting records with " + select);
        if (end == null) System.out.println (" equal to \"" + start + "\"");
        else System.out.println (" between \"" + start + "\" and \"" + end + "\"");
    }
    BufferedReader data;
    try {
        data = new BufferedReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        data = new BufferedReader (new FileReader (inDir + file_name));
    }
    Vector fields_v = new Vector ();
    Vector fpl_v = new Vector ();
    for (String inLine = getNextLine (data); (inLine != null && inLine.length () != 0); inLine = getNextLine (data)) {
        StringTokenizer st = new StringTokenizer (inLine);
        fpl_v.addElement (new Integer (st.countTokens ()));
        while (st.hasMoreTokens ()) {
            String tok = st.nextToken ();
            if (DEBUG) System.out.println ("read field " + fields_v.size () + " :" + tok);
            fields_v.addElement (tok);
        }
    }
    fields_v.addElement (indexField);
    int [] fieldsPerLine = new int [fpl_v.size ()];
    for (int i = 0; i < fieldsPerLine.length; i ++) fieldsPerLine [i] = ((Integer) fpl_v.elementAt (i)).intValue ();
    String [] fields = new String [fields_v.size ()];
    for (int i = 0; i < fields.length; i ++) fields [i] = (String) fields_v.elementAt (i);
    dataFileLoop : for (int curField = 0;; curField ++) {
        int i = 0;
        String [] fieldData = new String [fields.length];
        for (int j = 0; j < fieldsPerLine.length; j ++) {
            String line = getNextLine (data);
            if (line == null) break dataFileLoop;
            if (fieldsPerLine [j] == 1) {
                if (DEBUG) System.out.println ("read field " + fields [i] + " :" + line);
                fieldData [i ++] = line;
            }
            else {
                if (DEBUG) System.out.println ("reading " + fieldsPerLine [j] + " fields");
                StringTokenizer st = new StringTokenizer (line);
                try {
                    for (int k = 0; k < fieldsPerLine [j]; k ++) {
                        String tok = st.nextToken ();
                        if (DEBUG) System.out.println ("read field " + fields [i] + ": " + tok);
                        fieldData [i ++] = tok;
                    }
                } catch (NoSuchElementException x) {
                    throw new IOException ("Missing field " + fields [i]);
                }
            }
        }
        if (fieldsPerLine.length != 1) getNextLine (data);
        fieldData [i ++] = Integer.toString (curField);
        if (select != null) {
            for (int j = 0; j < fields.length; j ++) {
                if (DEBUG) System.out.println ("checking if select is field " + fields [j]);
                if (select.equals (fields [j])) {
                    String value = fieldData [j];
                    if (value.equals (start)) inRange = true;
                    else if (end == null) inRange = false;
                    else if (value.equals (end)) end = null;
                    if (DEBUG) System.out.println ("record in range; including");
                    break;
                }
            }
            if (! inRange) break dataFileLoop;
        }
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name, fields, fieldData);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name, fields, fieldData);
                processTemplateRegion (newRegion);
            }
        }
    }
    data.close ();
}


-----Function Pair=89=-----==

private void generateExList (String uid, PrintWriter out) throws IOException {
    File userMessage = new File (home + uid + ".msg");
    File msg4All = new File (home + "msg4all.msg");
    File [] exList = practicesList ();
    if (buildStatImage == null) {
        buildStatImage = new boolean [exList.length + 1] [];
        for (int i = 1; i < buildStatImage.length; i ++) {
            buildStatImage [i] = new boolean [((Integer) practices.get (exList [i - 1].getName ())).intValue () + 1];
            Arrays.fill (buildStatImage [i], 0, buildStatImage [i].length, true);
        }
    }
    else if (buildStatImage.length < exList.length + 1) {
        boolean [] [] tmp = new boolean [exList.length + 1] [];
        for (int i = 1; i < buildStatImage.length; i ++) {
            tmp [i] = new boolean [buildStatImage [i].length];
            for (int j = 0; j < tmp [i].length; j ++) tmp [i] [j] = buildStatImage [i] [j];
        }
        for (int i = buildStatImage.length; i < tmp.length; i ++) {
            tmp [i] = new boolean [((Integer) practices.get (exList [i - 1].getName ())).intValue () + 1];
            Arrays.fill (tmp [i], 0, tmp [i].length, true);
        }
        buildStatImage = tmp;
    }
    out.println (DOCTYPE + "<head>\n<title>Esercitazioni</title>\n" + STYLE + "</head>\n<body>\n" + NAVBAR1 + NAVBAR1b + "Esercitazioni" + NAVBAR2);
    if (userMessage.exists () || msg4All.exists ()) {
        out.println ("<div class=\"messaggio\">");
        if (userMessage.exists ()) {
            BufferedReader b = new BufferedReader (new FileReader (userMessage));
            String line;
            while ((line = b.readLine ()) != null) out.println (line);
            b.close ();
            userMessage.renameTo (new File (home + userMessage.getName () + ".read"));
        }
        if (msg4All.exists ()) {
            BufferedReader b = new BufferedReader (new FileReader (msg4All));
            String line;
            while ((line = b.readLine ()) != null) out.println (line);
            b.close ();
        }
        out.println ("</div>");
    }
    out.println ("<h1>Esercitazioni</h1>\n" + "<ul>");
    int i = 0;
    do {
        out.println ("<li><a href=\"Esercitazioni?mode=" + EX_LIST_MODE + "&uid=" + uid + "&ex=" + exList [i].getName () + "\">Esercitazione " + exList [i].getName ().substring (1, exList [i].getName ().indexOf (".html")) + "</a> (" + practices.get (exList [i].getName ()) + " esercizi) [<a href=\"Esercitazioni?mode=" + STAT_MODE + "&ex=" + exList [i].getName () + "\">statistiche</a> (" + "difficolt&agrave; media percepita: " + computeAverageExDifficult (exList [i].getName ()) + "%)]</li>");
        i ++;
    }
    while (i < exList.length && ! exList [i - 1].getName ().equals (((UserData) users.get (uid)).esercitaz));
    while (i < exList.length) {
        out.println ("<li>Esercitazione " + exList [i].getName ().substring (1, exList [i].getName ().indexOf (".html")) + "</li>");
        i ++;
    }
    out.println ("</ul></body></html>");
}


void readVolumetricData () throws Exception {
    System.err.println ("readVolumetricData");
    StringTokenizer st = new StringTokenizer ("");
    volumetricData = new float [countX] [] [];
    for (int x = 0; x < countX; ++ x) {
        float [] [] plane = new float [countY] [];
        volumetricData [x] = plane;
        for (int y = 0; y < countY; ++ y) {
            float [] strip = new float [countZ];
            plane [y] = strip;
            for (int z = 0; z < countZ; ++ z) {
                if (! st.hasMoreTokens ()) {
                    String line = br.readLine ();
                    if (line == null) {
                        System.err.println ("end of file in SqueezeCube?");
                        System.err.println ("x=" + x + " y=" + y + " z=" + z);
                        throw new NullPointerException ();
                    }
                    st = new StringTokenizer (line);
                }
                strip [z] = Float.parseFloat (st.nextToken ());
            }
        }
    }
    System.err.println ("Successfully read " + countX + " x " + countY + " x " + countZ + " data points");
}


-----Function Pair=90=-----==

private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


public boolean ErrorCheck (String fileName) {
    String line;
    StringTokenizer st;
    String testToken;
    boolean error = false;
    try {
        BufferedReader in = new BufferedReader (new FileReader (fileName));
        while ((line = in.readLine ()) != null) {
            if (line.equals (":-( /dev/dvd: media is not recognized as recordable DVD: 9")) {
                MessageBox ("Non-recoverable error occurred." + "\nClass Name: " + new Exception ().getStackTrace () [1].getClassName () + "\nMethod Name: " + new Exception ().getStackTrace () [1].getMethodName () + "\nError was: " + line, 0);
                return true;
            }
            st = new StringTokenizer (line, "*,;:'-~\t ");
            while (st.hasMoreTokens ()) {
                testToken = st.nextToken ();
                if (testToken.equalsIgnoreCase ("Error")) {
                    MessageBox ("Non-recoverable error occurred." + "\nClass Name: " + new Exception ().getStackTrace () [1].getClassName () + "\nMethod Name: " + new Exception ().getStackTrace () [1].getMethodName () + "\nError was: " + line, 0);
                    error = true;
                }
            }
        }
    } catch (FileNotFoundException ex) {
        SaveStackTrace.printTrace (strOutputDir, ex);
        MessageBox ("Can not find " + fileName + "\n" + ex.toString (), 0);
        ex.printStackTrace ();
        return true;
    } catch (IOException ex) {
        SaveStackTrace.printTrace (strOutputDir, ex);
        MessageBox ("IO Error\n" + ex.toString (), 0);
        ex.printStackTrace ();
        return true;
    }
    return error;
}


-----Function Pair=91=-----==

public void execute () {
    if (app.get_gui ().applet != null) {
        InfoDialog d = new InfoDialog (app.get_gui ().get_frame (), "I/O Error", AppText.no_applet_io);
        d.show ();
        return;
    }
    FileDialog fd = new FileDialog (app.get_gui ().get_frame (), "Load Tree", FileDialog.LOAD);
    fd.show ();
    if (fd.getFile () == null) {
        return;
    }
    String file_name = fd.getDirectory () + fd.getFile ();
    app.get_gui ().get_frame ().setCursor (Frame.WAIT_CURSOR);
    try {
        DataInputStream di;
        try {
            di = new DataInputStream (new BufferedInputStream (new FileInputStream (file_name)));
        } catch (java.io.IOException e) {
            app.get_gui ().get_frame ().setCursor (Frame.DEFAULT_CURSOR);
            InfoDialog d = new InfoDialog (app.get_gui ().get_frame (), "I/O Error", "The file " + file_name + "\n" + "does not exist or can't be opened due to security restrictions.");
            d.show ();
            return;
        }
        app.make_empty_tree ();
        String line;
        while ((line = di.readLine ()) != null) {
            StringTokenizer st = new StringTokenizer (line);
            if (st.hasMoreTokens ()) {
                char key = st.nextToken ().toUpperCase ().charAt (0);
                if (key >= 'A' && key <= 'Z') {
                    String info = "";
                    if (st.hasMoreTokens ()) {
                        info = String.valueOf (st.nextToken ());
                    }
                    try {
                        app.example_root = app.insert (app.example_root, key, info);
                    } catch (AlreadyThere a) {
                    }
                }
            }
        }
        di.close ();
        app.get_gui ().get_frame ().setCursor (Frame.DEFAULT_CURSOR);
    } catch (java.io.IOException e) {
        System.out.println ("i/o error");
        app.get_gui ().get_frame ().setCursor (Frame.DEFAULT_CURSOR);
    }
    app.get_gui ().main_window.repaint ();
}


public void TCPclient (Socket s) {
    try {
        int inLength;
        DataInputStream dataIn;
        DataOutputStream dataOut;
        byte [] in;
        InputStream is = s.getInputStream ();
        dataIn = new DataInputStream (is);
        inLength = dataIn.readUnsignedShort ();
        in = new byte [inLength];
        dataIn.readFully (in);
        Message query;
        byte [] response = null;
        try {
            query = new Message (in);
            response = generateReply (query, in, in.length, s);
            if (response == null) return;
        } catch (IOException e) {
            response = formerrMessage (in);
        }
        dataOut = new DataOutputStream (s.getOutputStream ());
        dataOut.writeShort (response.length);
        dataOut.write (response);
    } catch (IOException e) {
        System.out.println ("TCPclient(" + addrport (s.getLocalAddress (), s.getLocalPort ()) + "): " + e);
    } finally {
        try {
            s.close ();
        } catch (IOException e) {
        }
    }
}


-----Function Pair=92=-----==

public void processOutput (File file) throws IOException {
    ZipOutputStream zipOut = null;
    FileOutputStream out = null;
    try {
        out = new FileOutputStream (file);
        zipOut = new ZipOutputStream (out);
        zipOut.setLevel (1);
        Enumeration keys = zipentries.keys ();
        while (keys.hasMoreElements ()) {
            Object key = keys.nextElement ();
            byte [] data = (byte []) zipentries.get (key);
            ZipEntry entry = new ZipEntry ((String) key);
            zipOut.putNextEntry (entry);
            zipOut.write (data, 0, data.length);
        }
    } finally {
        try {
            zipOut.close ();
        } catch (Exception e) {
        }
        try {
            out.close ();
        } catch (Exception e) {
        }
    }
}


private JPopupMenu createContextMenu () {
    JPopupMenu popup = new JPopupMenu ();
    if (dataList.getSelectedRowCount () > 0) {
        JMenuItem saveItem = new JMenuItem ("Save As..");
        saveItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                saveSelectedFiles ();
            }
        }
        );
        popup.add (saveItem);
        JMenuItem openItem = new JMenuItem ("Open");
        openItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                openSelectedFiles ();
            }
        }
        );
        popup.add (openItem);
        JMenuItem editItem = new JMenuItem ("Edit");
        editItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                editSelectedFiles ();
            }
        }
        );
        popup.add (editItem);
        JMenuItem printItem = new JMenuItem ("Print");
        printItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                printSelectedFiles ();
            }
        }
        );
        popup.add (printItem);
        JMenuItem deleteItem = new JMenuItem ("Delete");
        deleteItem.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                deleteSelectedFiles ();
            }
        }
        );
        popup.add (deleteItem);
        popup.addSeparator ();
    }
    JMenuItem attachItem = new JMenuItem ("Attach New");
    attachItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openAttachBrowsePanel ();
        }
    }
    );
    popup.add (attachItem);
    return popup;
}


-----Function Pair=93=-----==

private void saveSelectedDataTreeMenuItem_actionPerformed (ActionEvent e) {
    Object [] data = theDataTreePanel.getSelectedData ();
    if (data.length != 1) {
        JOptionPane.showMessageDialog (this, "Please select one item on the data tree to save");
        return;
    }
    System.out.println ("data[0].getClass().getName(): " + data [0].getClass ().getName ());
    JFileChooser fileChooser = null;
    String preferredDir = theSettings.saveDir;
    if (preferredDir != null) {
        fileChooser = new JFileChooser (preferredDir);
    }
    File aFile = null;
    TasselFileFilter fileFilter = new TasselFileFilter ();
    AnnotationAlignment aa = null;
    if ((data [0] instanceof AnnotationAlignment) && ! (data [0] instanceof AminoAcidAnnotatedAlignment)) {
        aa = (AnnotationAlignment) data [0];
        fileFilter.addExtension (phylipFileSuffix);
        fileFilter.setDescription ("Phylip Format");
        fileChooser.setFileFilter (fileFilter);
        aFile = getFilenameFromUser (fileChooser, phylipFileSuffix);
        if (aFile != null) {
            PrintWriter out = null;
            try {
                out = new PrintWriter (new FileWriter (aFile));
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
            AlignmentUtils.printSequential (aa, out);
            out.flush ();
            out.close ();
        }
    }
    else if (data [0] instanceof Alignment) {
        Alignment anAlignment = (Alignment) data [0];
        fileFilter.addExtension (genericFileSuffix);
        fileFilter.setDescription ("Text Output");
        fileChooser.setFileFilter (fileFilter);
        aFile = getFilenameFromUser (fileChooser, genericFileSuffix);
        if (aFile != null) {
            PrintWriter out = null;
            try {
                out = new PrintWriter (new FileWriter (aFile));
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
            AlignmentUtils.printPlain (anAlignment, out);
            out.flush ();
            out.close ();
        }
    }
}


void testCommand (String [] args, int expect_rc) throws Exception {
    System.err.println ("Test command: " + Arrays.asList (args));
    File javaHome = new File (System.getProperty ("java.home"));
    if (javaHome.getName ().equals ("jre")) javaHome = javaHome.getParentFile ();
    List < String > command = new ArrayList < String > ();
    command.add (new File (new File (javaHome, "bin"), "javah").getPath ());
    command.add ("-J-Xbootclasspath:" + System.getProperty ("sun.boot.class.path"));
    command.addAll (Arrays.asList (args));
    ProcessBuilder pb = new ProcessBuilder (command);
    pb.redirectErrorStream (true);
    Process p = pb.start ();
    p.getOutputStream ().close ();
    StringWriter sw = new StringWriter ();
    String line;
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    while ((line = in.readLine ()) != null) sw.write (line + NEWLINE);
    int rc = p.waitFor ();
    expect ("testCommand", sw.toString (), rc, expect_rc);
}


-----Function Pair=94=-----==

private void saveSelectedDataTreeMenuItem_actionPerformed (ActionEvent e) {
    Object [] data = theDataTreePanel.getSelectedData ();
    if (data.length != 1) {
        JOptionPane.showMessageDialog (this, "Please select one item on the data tree to save");
        return;
    }
    System.out.println ("data[0].getClass().getName(): " + data [0].getClass ().getName ());
    JFileChooser fileChooser = null;
    String preferredDir = theSettings.saveDir;
    if (preferredDir != null) {
        fileChooser = new JFileChooser (preferredDir);
    }
    File aFile = null;
    TasselFileFilter fileFilter = new TasselFileFilter ();
    AnnotationAlignment aa = null;
    if ((data [0] instanceof AnnotationAlignment) && ! (data [0] instanceof AminoAcidAnnotatedAlignment)) {
        aa = (AnnotationAlignment) data [0];
        fileFilter.addExtension (phylipFileSuffix);
        fileFilter.setDescription ("Phylip Format");
        fileChooser.setFileFilter (fileFilter);
        aFile = getFilenameFromUser (fileChooser, phylipFileSuffix);
        if (aFile != null) {
            PrintWriter out = null;
            try {
                out = new PrintWriter (new FileWriter (aFile));
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
            AlignmentUtils.printSequential (aa, out);
            out.flush ();
            out.close ();
        }
    }
    else if (data [0] instanceof Alignment) {
        Alignment anAlignment = (Alignment) data [0];
        fileFilter.addExtension (genericFileSuffix);
        fileFilter.setDescription ("Text Output");
        fileChooser.setFileFilter (fileFilter);
        aFile = getFilenameFromUser (fileChooser, genericFileSuffix);
        if (aFile != null) {
            PrintWriter out = null;
            try {
                out = new PrintWriter (new FileWriter (aFile));
            } catch (IOException ioe) {
                ioe.printStackTrace ();
            }
            AlignmentUtils.printPlain (anAlignment, out);
            out.flush ();
            out.close ();
        }
    }
}


String [] getNamesStartingWith (String starting) {
    Vector < String > starts = new Vector < String > ();
    for (int x = 0; x < channelMap.size (); x ++) {
        String [] map = (String []) channelMap.get (x);
        HashMap < String, GuideItem > progs = (HashMap < String, GuideItem >) progList.get (map [1]);
        if (progs != null) {
            GuideItem [] items = (GuideItem []) progs.values ().toArray (new GuideItem [0]);
            for (int y = 0; y < items.length; y ++) {
                if (items [y].getName () != null && items [y].getName ().length () > 1) {
                    if (items [y].getName ().toUpperCase ().startsWith (starting.toUpperCase ())) {
                        if (! starts.contains (items [y].getName ())) {
                            starts.add (items [y].getName ());
                        }
                    }
                }
            }
        }
    }
    String [] result = (String []) starts.toArray (new String [0]);
    Arrays.sort (result);
    return result;
}


-----Function Pair=95=-----==

private void runReport () {
    boolean createTemporaryXmlFile = useTemporaryXmlFile.isSelected ();
    File xmlFile = null;
    try {
        prepareFilters ();
        reportCompleted = false;
        reportErrorMessage = layoutManager.getCoreString ("reports.configuration-window.run.unknownError");
        String debugMsg = layoutManager.getCoreString ("reports.configuration-window.action.run.debug");
        timeSlotTracker.debugLog (debugMsg);
        dataSource = timeSlotTracker.getDataSource ();
        if (dataSource == null) {
            reportErrorMessage = layoutManager.getCoreString ("reports.configuration-window.run.noDataSource");
            return;
        }
        String dataDirectory = configuration.getString (Configuration.DATASOURCE_DIRECTORY, ".");
        File resultFile = chooseFileResult.getFile ();
        if (resultFile == null) {
            reportErrorMessage = layoutManager.getCoreString ("reports.configuration-window.run.noResultFile.msg");
            return;
        }
        configuration.set (Configuration.LAST_RESULT_FILENAME, resultFile.getAbsolutePath ());
        if (createTemporaryXmlFile) {
            xmlFile = File.createTempFile ("tstXmlData_", ".xml");
        }
        else {
            xmlFile = chooseXmlFile.getFile ();
        }
        configuration.set (Configuration.LAST_USE_TMP_XML, createTemporaryXmlFile);
        configuration.set (Configuration.LAST_TMP_XML_FILE, xmlFile.getPath ());
        writer = new PrintWriter (new BufferedWriter (new OutputStreamWriter (new FileOutputStream (xmlFile), "UTF-8")));
        writer.println ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
        writer.println ("<!-- Generated: " + new Date () + " -->");
        writer.println ("");
        writer.println ("<TimeSlotTracker_Report>");
        writer.println ("");
        exportReportStrings ();
        writer.println ("");
        exportPeriodLoop ();
        writer.println ("");
        exportTask (dataSource.getRoot (), "  ");
        writer.println ("");
        writer.println ("</TimeSlotTracker_Report>");
        writer.flush ();
        writer.close ();
        String dataPath = dataDirectory + System.getProperty ("file.separator");
        Source xmlSource = new StreamSource (xmlFile);
        Source xsltSource = report.getXsltSource (dataPath);
        TransformerFactory transformerFactory = TransformerFactory.newInstance ();
        Transformer trans = transformerFactory.newTransformer (xsltSource);
        prepareFilters (trans);
        String encoding = (String) trans.getParameter (EncodingFilter.PARAMETER_REPORT_OUTPUT_ENCODING);
        if (encoding == null) {
            encoding = "UTF-8";
        }
        PrintWriter printWriter = null;
        try {
            printWriter = new PrintWriter (new BufferedWriter (new OutputStreamWriter (new FileOutputStream (resultFile), encoding)));
            Result result = new StreamResult (printWriter);
            trans.transform (xmlSource, result);
        } finally {
            if (printWriter != null) {
                printWriter.close ();
            }
        }
        String method = trans.getOutputProperties ().getProperty ("method");
        if (method != null && method.equalsIgnoreCase ("html")) {
            String destCssFileName = chooseFileResult.getFile ().getParent ();
            if (destCssFileName == null) {
                destCssFileName = "";
            }
            String reportFileName = "report.css";
            destCssFileName += File.separator + reportFileName;
            copyCssFile (reportFileName, new File (destCssFileName));
        }
        reportCompleted = true;
        openReport (resultFile);
    } catch (Exception e) {
        Object [] args = {e.getMessage ()};
        String errorMsg = timeSlotTracker.getString ("reports.configuration-window.action.run.Exception", args);
        timeSlotTracker.errorLog (errorMsg);
        timeSlotTracker.errorLog (e);
        reportErrorMessage = errorMsg;
        return;
    } finally {
        if (createTemporaryXmlFile && xmlFile != null) {
            xmlFile.delete ();
        }
    }
}


public void ReadSeriesFile () {
    xmlSeriesInfo = new ArrayList < XMLShowInfo > ();
    try {
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance ();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder ();
        Document doc = docBuilder.parse (new File ("JavaNZB.series"));
        doc.getDocumentElement ().normalize ();
        NodeList listOfShowInfo = doc.getElementsByTagName ("Show");
        ArrayList < String > elementNames = new ArrayList < String > ();
        elementNames.add ("Name");
        elementNames.add ("SearchBy");
        elementNames.add ("Episode");
        elementNames.add ("Format");
        elementNames.add ("Language");
        elementNames.add ("Next");
        elementNames.add ("Season");
        for (int s = 0; s < listOfShowInfo.getLength (); s ++) {
            Node showNode = listOfShowInfo.item (s);
            XMLShowInfo xmlShowInfo = new XMLShowInfo ();
            if (showNode.getNodeType () == Node.ELEMENT_NODE) {
                Element firstPersonElement = (Element) showNode;
                for (String CurElementName : elementNames) {
                    NodeList NameList = firstPersonElement.getElementsByTagName (CurElementName);
                    Element NameElement = (Element) NameList.item (0);
                    NodeList textFNList = NameElement.getChildNodes ();
                    if (textFNList.getLength () > 0) {
                        if (CurElementName.equals ("Name")) xmlShowInfo.showName = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("SearchBy")) xmlShowInfo.searchBy = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("Episode")) xmlShowInfo.episode = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("Format")) xmlShowInfo.format = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("Language")) xmlShowInfo.language = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("Next")) xmlShowInfo.next = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                        if (CurElementName.equals ("Season")) xmlShowInfo.season = ((Node) textFNList.item (0)).getNodeValue ().trim ();
                    }
                }
                xmlSeriesInfo.add (xmlShowInfo);
            }
        }
    } catch (SAXParseException err) {
        System.out.println ("** Parsing error" + ", line " + err.getLineNumber () + ", uri " + err.getSystemId ());
        System.out.println (" " + err.getMessage ());
    } catch (SAXException e) {
        Exception x = e.getException ();
        ((x == null) ? e : x).printStackTrace ();
    } catch (Throwable t) {
        t.printStackTrace ();
    }
}


-----Function Pair=96=-----=1=

private List < File > ungzipFile (File directory, File compressedFile) throws IOException {
    List < File > files = new ArrayList < File > ();
    TarArchiveInputStream in = new TarArchiveInputStream (new GZIPInputStream (new FileInputStream (compressedFile)));
    try {
        TarArchiveEntry entry = in.getNextTarEntry ();
        while (entry != null) {
            if (entry.isDirectory ()) {
                log.warn ("TAR archive contains directories which are being ignored");
                entry = in.getNextTarEntry ();
                continue;
            }
            String fn = new File (entry.getName ()).getName ();
            if (fn.startsWith (".")) {
                log.warn ("TAR archive contains a hidden file which is being ignored");
                entry = in.getNextTarEntry ();
                continue;
            }
            File targetFile = new File (directory, fn);
            if (targetFile.exists ()) {
                log.warn ("TAR archive contains duplicate filenames, only the first is being extracted");
                entry = in.getNextTarEntry ();
                continue;
            }
            files.add (targetFile);
            log.debug ("Extracting file: " + entry.getName () + " to: " + targetFile.getAbsolutePath ());
            OutputStream fout = new BufferedOutputStream (new FileOutputStream (targetFile));
            InputStream entryIn = new FileInputStream (entry.getFile ());
            IOUtils.copy (entryIn, fout);
            fout.close ();
            entryIn.close ();
        }
    } finally {
        in.close ();
    }
    return files;
}


public boolean clonarFichero (String rutaFicheroOrigen, String rutaFicheroDestino) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'clonarFichero' ***********");
    boolean estado = false;
    try {
        FileInputStream entrada = new FileInputStream (rutaFicheroOrigen);
        FileOutputStream salida = new FileOutputStream (rutaFicheroDestino);
        FileChannel canalOrigen = entrada.getChannel ();
        FileChannel canalDestino = salida.getChannel ();
        canalOrigen.transferTo (0, canalOrigen.size (), canalDestino);
        entrada.close ();
        salida.close ();
        estado = true;
    } catch (IOException e) {
        System.out.println ("No se encontro el archivo");
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


-----Function Pair=97=-----==

private void zipFiles (Set < File > files, File zipFile) throws IOException {
    if (files.isEmpty ()) {
        log.warn ("No files to zip.");
    }
    else {
        try {
            BufferedInputStream origin = null;
            FileOutputStream dest = new FileOutputStream (zipFile);
            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
            byte data [] = new byte [BUFFER];
            for (File f : files) {
                log.debug ("Adding file " + f + " to archive");
                FileInputStream fi = new FileInputStream (f);
                origin = new BufferedInputStream (fi, BUFFER);
                ZipEntry entry = new ZipEntry (f.getName ());
                out.putNextEntry (entry);
                int count;
                while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                    out.write (data, 0, count);
                }
                origin.close ();
            }
            out.finish ();
            out.close ();
        } catch (IOException e) {
            log.error ("IOException while zipping files: " + files);
            throw e;
        }
    }
}


private static int bruteforceBjwflate (String caption, File packFile, File packGzFile, int maxSplit) throws IOException {
    File min = packGzFile;
    int minSplit = - 1;
    List < File > dsts = new ArrayList < File > ();
    for (int splitSize = 4, i = 0; splitSize <= maxSplit; splitSize += (splitSize <= 12 ? 4 : (splitSize <= 32 ? 8 : (splitSize <= 128 ? 16 : 32))), i ++) {
        File dst = new File (packGzFile.getParentFile (), splitSize + "_" + packGzFile.getName ());
        if (bjwflate_deflopt_gz (caption, packFile, dst, splitSize, false)) {
            if (dst.length () != 0 && ((min == null || min.length () == 0) || dst.length () < min.length ())) {
                min = dst;
                minSplit = splitSize;
            }
        }
    }
    if (minSplit != - 1) {
        FileUtil.copyFile (min, packGzFile);
    }
    for (File dst : dsts) {
        dst.delete ();
    }
    return minSplit;
}


-----Function Pair=98=-----==

public static boolean copyInternal (File src, File dest, byte [] buf) {
    boolean result = true;
    String files [] = null;
    if (src.isDirectory ()) {
        files = src.list ();
        result = dest.mkdir ();
    }
    else {
        files = new String [1];
        files [0] = "";
    }
    if (files == null) {
        files = new String [0];
    }
    for (int i = 0; (i < files.length) && result; i ++) {
        File fileSrc = new File (src, files [i]);
        File fileDest = new File (dest, files [i]);
        if (fileSrc.isDirectory ()) {
            result = copyInternal (fileSrc, fileDest, buf);
        }
        else {
            FileInputStream is = null;
            FileOutputStream os = null;
            try {
                is = new FileInputStream (fileSrc);
                os = new FileOutputStream (fileDest);
                int len = 0;
                while (true) {
                    len = is.read (buf);
                    if (len == - 1) break;
                    os.write (buf, 0, len);
                }
            } catch (IOException e) {
                e.printStackTrace ();
                result = false;
            } finally {
                if (is != null) {
                    try {
                        is.close ();
                    } catch (IOException e) {
                    }
                }
                if (os != null) {
                    try {
                        os.close ();
                    } catch (IOException e) {
                    }
                }
            }
        }
    }
    return result;
}


public static Configuration migrateConfiguration (Configuration conf, String path, Map < String, String > renames) throws EDITSException {
    Configuration out = new Configuration ();
    Configurable c = (Configurable) ModuleLoader.initialize (conf.getClassName ());
    Map < String, OptionInfo > options = new HashMap < String, OptionInfo > ();
    for (OptionInfo s : c.info ().options ()) options.put (s.name (), s);
    out.setClassName (conf.getClassName ());
    out.setType (conf.getType ());
    out.setId (conf.getId ());
    for (Option a : conf.getOption ()) {
        Option na = new Option ();
        OptionInfo t = options.get (a.getName ());
        if (t.type ().equals (Type.FILE)) {
            na.setValue (copyFile (path, a.getValue (), renames));
        }
        else na.setValue (a.getValue ());
        na.setId (a.getId ());
        na.setName (a.getName ());
        out.getOption ().add (na);
    }
    for (Configuration cdd : conf.getModule ()) out.getModule ().add (migrateConfiguration (cdd, path, renames));
    return out;
}


-----Function Pair=99=-----==

public static void copyDirectoryContent (File sourceDirectory, File destinationDirectory) {
    Vector directoryContent = readDirectoryContent (sourceDirectory);
    for (int i = 0; i < directoryContent.size (); i ++) {
        String sourcePath = directoryContent.elementAt (i).toString ();
        int sourceDirectoryPathLength = sourceDirectory.getPath ().length ();
        StringBuffer relativePathBuffer = new StringBuffer ();
        for (int j = sourceDirectoryPathLength; j < sourcePath.length (); j ++) {
            relativePathBuffer.append (sourcePath.charAt (j));
        }
        String destinationPath = destinationDirectory.getPath () + new String (relativePathBuffer);
        File sourceFile = new File (sourcePath);
        File destinationFile = new File (destinationPath);
        if (! sourceFile.isDirectory ()) copyFile (sourceFile, destinationFile);
        else {
            if (! destinationFile.exists ()) {
                destinationFile.mkdirs ();
                destinationFile.mkdir ();
            }
        }
    }
}


public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


-----Function Pair=100=-----==

public static void UnZip (String zipLocation, String toDir) throws Exception {
    File zipFile = new File (zipLocation);
    File dir = new File (toDir);
    ZipInputStream zis = null;
    try {
        zis = new ZipInputStream (new FileInputStream (zipFile));
        for (ZipEntry ze = null; (ze = zis.getNextEntry ()) != null;) UnZipEntry (dir, zis, ze.getName (), ze.isDirectory ());
    } catch (IOException ioe) {
        throw ioe;
    } finally {
        if (zis != null) try {
            zis.close ();
        } catch (IOException e) {
            throw e;
        }
    }
}


public String [] read (File f) {
    ArrayList < String > al = new ArrayList < String > ();
    String currline = "";
    try {
        FileInputStream fis = new FileInputStream (f);
        InputStreamReader isr = new InputStreamReader (fis);
        BufferedReader reader = new BufferedReader (isr);
        while ((currline != null)) {
            currline = reader.readLine ();
            if (currline != null) al.add (currline);
        }
        reader.close ();
        isr.close ();
        fis.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return (String []) al.toArray (new String [0]);
}


-----Function Pair=101=-----==

public String [] getFilesInDir (String dir, String ext) {
    if (dir == null) return (null);
    String dirList [] = null;
    try {
        File f = new File (dir);
        if (f.isDirectory ()) {
            dirList = f.list ();
            if (dirList == null || dirList.length == 0) return (null);
            if (ext == null) return (dirList);
            int nAll = dirList.length, nExt = 0;
            String tmp [] = new String [nAll];
            for (int i = 0; i < nAll; i ++) if (dirList [i].endsWith (ext)) tmp [nExt ++] = dirList [i];
            if (nExt == 0) return (null);
            dirList = new String [nExt];
            for (int j = 0; j < nExt; j ++) dirList [j] = tmp [j];
        }
    } catch (Exception ef) {
        return (null);
    }
    return (dirList);
}


public boolean checkSessionID (String id) {
    String captcha = getProperty ("security.captcha");
    if ("0".equals (captcha)) return true;
    synchronized (this) {
        long sleepFor = (new Date ()).getTime () - lastCheched.getTime ();
        if (sleepFor < 10000) {
            try {
                Thread.sleep (10000 - sleepFor);
            } catch (Exception e) {
            }
        }
        lastCheched = new Date ();
        String [] ids = (String []) sessionIDs.keySet ().toArray (new String [0]);
        Date now = new Date ();
        for (int x = 0; x < ids.length; x ++) {
            Date createDate = (Date) sessionIDs.get (ids [x]);
            if ((createDate.getTime () + (1000 * 60 * 3)) < now.getTime ()) {
                System.out.println ("Removed Old Session ID : " + ids [x] + " - " + createDate);
                sessionIDs.remove (ids [x]);
            }
        }
        Date testDate = (Date) sessionIDs.get (id);
        if (testDate != null) {
            sessionIDs.remove (id);
            System.out.println ("Removed Used Session ID : " + id + " - " + testDate);
            return true;
        }
        else return false;
    }
}


-----Function Pair=102=-----==

private boolean writeEntry (File f, JarOutputStream out, String RelativePath) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            fPath = f.getPath ().substring (f.getPath ().lastIndexOf (FILESEPARATOR));
            en = RelativePath + fPath;
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, RelativePath);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


public Object parse (INode parent) throws IOException, ParseException {
    Document doc = parent.getDocument ();
    if (pdfr_ == null) init (doc);
    if (fail_ != null) {
        new LeafAscii ("Error opening PDF: " + fail_, null, parent);
        return parent;
    }
    StyleSheet ss = doc.getStyleSheet ();
    CLGeneral cl = (CLGeneral) ss.get ("pdf");
    if (cl == null) {
        cl = new CLGeneral ();
        ss.put ("pdf", cl);
    }
    cl.setStroke (Color.BLACK);
    cl.setBackground (Color.WHITE);
    cl.setForeground (Color.BLACK);
    PDFReader pdfr = pdfr_;
    pdfr.refresh ();
    if (! isAuthorized ()) {
        return new LeafAscii ("can handle encrypted PDFs only with null password for now", null, doc);
    }
    if (doc.getAttr (Document.ATTR_PAGECOUNT) == null) {
        doc.putAttr (Document.ATTR_PAGECOUNT, Integer.toString (pdfr.getPageCnt ()));
        Map info = pdfr.getInfo ();
        if (info != null) {
            Object o = null;
            for (int i = 0, imax = METADATA.length; i < imax; i ++) if ((o = pdfr.getObject (info.get (METADATA [i]))) != null) doc.putAttr (METADATA [i], o.toString ());
        }
    }
    if (doc.getAttr (Document.ATTR_PAGE) == null) return new LeafAscii ("Loading...", null, parent);
    INode pdf = new INode ("pdf", null, parent);
    FixedI mediabox = new FixedI ("MediaBox", null, pdf);
    Browser br = getBrowser ();
    Object z = br != null ? br.callSemanticEvent ("getZoom", null) : null;
    double zoom = (z instanceof Number ? ((Number) z).doubleValue () : 100.0) / 100.0;
    buildPage (Integers.parseInt (doc.getAttr (Document.ATTR_PAGE, "1"), 1), mediabox, AffineTransform.getScaleInstance (zoom, zoom));
    pdf.addObserver (this);
    pdfr.close ();
    return pdf;
}


-----Function Pair=103=-----==

public static void parseJcamp (SubmittingData subData, String jcamp) throws IOException, JCAMPException, NmrshiftdbException, Exception {
    Spectrum jcampSpectrum = JCAMPReader.getInstance ().createSpectrum (jcamp);
    if (! (jcampSpectrum instanceof NMRSpectrum)) {
        throw new NmrshiftdbException ("Spectrum in file is not an NMR spectrum!");
    }
    NMRSpectrum nmrspectrum = (NMRSpectrum) jcampSpectrum;
    ArrayList numberSpectrum = new ArrayList ();
    Vector oldSignalstable = null;
    if (subData.getSignalstable () != null) {
        oldSignalstable = subData.getSignalstable ();
    }
    if (nmrspectrum.hasPeakTable ()) {
        Peak [] peaks = nmrspectrum.getPeakTable ();
        for (int i = 0; i < peaks.length; i ++) {
            ValueTriple vt = new ValueTriple ();
            vt.value1 = (float) peaks [i].getPosition () [0];
            BigDecimal bd = new BigDecimal (vt.value1);
            bd = bd.setScale (2, BigDecimal.ROUND_HALF_UP);
            vt.value1 = bd.floatValue ();
            vt.value2 = (float) peaks [i].getHeight ();
            bd = new BigDecimal (vt.value2);
            bd = bd.setScale (2, BigDecimal.ROUND_HALF_UP);
            vt.value2 = bd.floatValue ();
            numberSpectrum.add (vt);
        }
    }
    else {
        Vector v = new MinHeightPeakPicking (0, 1).calculate (nmrspectrum);
        for (int i = 0; i < v.size (); i ++) {
            ValueTriple vt = new ValueTriple ();
            vt.value1 = (float) ((Peak) v.get (i)).getPosition () [0];
            BigDecimal bd = new BigDecimal (vt.value1);
            bd = bd.setScale (2, BigDecimal.ROUND_HALF_UP);
            vt.value1 = bd.floatValue ();
            vt.value2 = (float) ((Peak) v.get (i)).getHeight ();
            bd = new BigDecimal (vt.value2);
            bd = bd.setScale (2, BigDecimal.ROUND_HALF_UP);
            vt.value2 = bd.floatValue ();
            numberSpectrum.add (vt);
        }
    }
    ParseUtils.removeDuplicates (numberSpectrum);
    float maxIntensity = 0;
    for (int i = 0; i < numberSpectrum.size (); i ++) {
        if (((ValueTriple) numberSpectrum.get (i)).value2 > maxIntensity) {
            maxIntensity = ((ValueTriple) numberSpectrum.get (i)).value2;
        }
    }
    if (maxIntensity > 1) {
        for (int i = 0; i < numberSpectrum.size (); i ++) {
            BigDecimal bd = new BigDecimal (((ValueTriple) numberSpectrum.get (i)).value2 / maxIntensity);
            bd = bd.setScale (2, BigDecimal.ROUND_HALF_UP);
            ((ValueTriple) numberSpectrum.get (i)).value2 = bd.floatValue ();
        }
    }
    if (oldSignalstable != null) {
        Vector signalstable = subData.getSignalstable ();
        for (int i = 0; i < signalstable.size (); i ++) {
            for (int k = 0; k < oldSignalstable.size (); k ++) {
                if (((ValueTriple) signalstable.get (i)).value1 == ((ValueTriple) oldSignalstable.get (k)).value1) {
                    ((ValueTriple) signalstable.get (i)).atoms = ((ValueTriple) oldSignalstable.get (k)).atoms;
                }
            }
        }
    }
    subData.setKeepAssignmentEntries ("");
    for (int i = 0; i < numberSpectrum.size (); i ++) {
        subData.addToSignalstable (numberSpectrum.get (i));
    }
}


private byte [] addScheduleFromGuideItem (HTTPurl urlData) throws Exception {
    String channel = urlData.getParameter ("channel");
    String id = urlData.getParameter ("id");
    GuideStore guide = GuideStore.getInstance ();
    String epgChan = guide.getEpgChannelFromMap (channel);
    GuideItem guideItem = guide.getProgram (epgChan, id);
    if (epgChan == null || epgChan.length () == 0) throw new Exception ("WS Channel Not Found!");
    int captype = - 1;
    ScheduleItem schItem = new ScheduleItem (guideItem, channel, captype, store.rand.nextLong (), false);
    String task = store.getProperty ("Tasks.DefTask");
    schItem.setPostTask (task);
    int startBuff = 0;
    int endBuff = 0;
    int endBuffEpg = 0;
    try {
        startBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.start"));
        endBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.end"));
        endBuffEpg = Integer.parseInt (store.getProperty ("Schedule.buffer.end.epg"));
    } catch (Exception e) {
    }
    String [] patterns = store.getNamePatterns ();
    schItem.setFilePattern (patterns [0]);
    String keepFor = store.getProperty ("AutoDel.KeepFor");
    int keepInt = 30;
    try {
        keepInt = Integer.parseInt (keepFor);
    } catch (Exception e) {
    }
    schItem.setKeepFor (keepInt);
    schItem.setCapType (captype);
    Calendar cal = Calendar.getInstance ();
    cal.setTime (schItem.getStart ());
    cal.add (Calendar.MINUTE, (startBuff * - 1));
    if (endBuffEpg > 0) {
        endBuffEpg = endBuffEpg * (int) (guideItem.getDuration () / 60);
    }
    schItem.setDuration (guideItem.getDuration () + startBuff + endBuff + endBuffEpg);
    schItem.setStart (cal);
    schItem.setType (ScheduleItem.ONCE);
    schItem.log ("New Schedule added/edited");
    boolean isAlreadyInList = guide.isAlreadyInList (schItem, 1);
    if (! isAlreadyInList) {
        store.addScheduleItem (schItem);
    }
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    StringBuffer out = new StringBuffer (4096);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=104=-----==

public static final byte [] getDataSource (InputStream is) {
    if (is == null) {
        return null;
    }
    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ();
    byte [] arrayByte = null;
    try {
        byte [] bytes = new byte [8192];
        bytes = new byte [is.available ()];
        int read;
        while ((read = is.read (bytes)) >= 0) {
            byteArrayOutputStream.write (bytes, 0, read);
        }
        arrayByte = byteArrayOutputStream.toByteArray ();
    } catch (IOException e) {
        return null;
    } finally {
        try {
            if (byteArrayOutputStream != null) {
                byteArrayOutputStream.close ();
                byteArrayOutputStream = null;
            }
            if (is != null) {
                is.close ();
                is = null;
            }
        } catch (IOException e) {
        }
    }
    return arrayByte;
}


public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
        Platform.printbp ();
    }
}


-----Function Pair=105=-----==

private byte [] showEpgIndex (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    GuideStore guide = GuideStore.getInstance ();
    Vector < String [] > links = guide.getEPGlinks (null);
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = dbf.newDocumentBuilder ();
    DOMImplementation di = db.getDOMImplementation ();
    Document doc = di.createDocument ("", "files", null);
    Element root = doc.getDocumentElement ();
    root.setAttribute ("back", store.getTargetURL ("epg-sub", "/servlet/ApplyTransformRes?xml=root&xsl=kb-buttons"));
    Element button = null;
    Element elm = null;
    Text text = null;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Back");
    elm = doc.createElement ("url");
    text = doc.createTextNode (store.getTargetURL ("epg-sub", "/servlet/ApplyTransformRes?xml=root&xsl=kb-buttons"));
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    for (int x = 0; x < links.size (); x ++) {
        String [] item = (String []) links.get (x);
        button = doc.createElement ("button");
        button.setAttribute ("name", item [1]);
        elm = doc.createElement ("url");
        text = doc.createTextNode ("/servlet/" + urlData.getServletClass () + "?action=01&" + item [0]);
        elm.appendChild (text);
        button.appendChild (elm);
        root.appendChild (button);
    }
    XSL transformer = new XSL (doc, "kb-buttons.xsl", urlData, headers);
    return transformer.doTransform ();
}


public boolean copyCollection (User user, String name, String namedest) throws EXistException, PermissionDeniedException {
    RpcConnection con = pool.get ();
    try {
        createCollection (user, namedest);
        Hashtable parametri = new Hashtable ();
        parametri.put (OutputKeys.INDENT, "no");
        parametri.put (EXistOutputKeys.EXPAND_XINCLUDES, "no");
        parametri.put (OutputKeys.ENCODING, "UTF-8");
        Hashtable lista = getCollectionDesc (user, name);
        Vector collezioni = (Vector) lista.get ("collections");
        Vector documents = (Vector) lista.get ("documents");
        Iterator collezioniItr = collezioni.iterator ();
        String nome;
        while (collezioniItr.hasNext ()) {
            nome = collezioniItr.next ().toString ();
            createCollection (user, namedest + "/" + nome);
            copyCollection (user, name + "/" + nome, namedest + "/" + nome);
        }
        Hashtable hash;
        int p, dsize = documents.size ();
        for (int i = 0; i < dsize; i ++) {
            hash = (Hashtable) documents.elementAt (i);
            nome = (String) hash.get ("name");
            if ((p = nome.lastIndexOf ('/')) > - 1) nome = nome.substring (p + 1);
            byte [] xml = getDocument (user, name + "/" + nome, parametri);
            parse (user, xml, namedest + "/" + nome);
        }
        return true;
    } catch (Exception e) {
        handleException (e);
        return false;
    } finally {
        pool.release (con);
    }
}


-----Function Pair=106=-----==

public synchronized String find (String file, String regExpression, long maximumWaitTime) throws Exception {
    long startTime = System.currentTimeMillis ();
    String foundString = null;
    while (foundString == null) {
        try {
            foundString = this.find (file, regExpression);
        } catch (IOException e) {
            logger.fine ("Ignoring the exception '" + e.getMessage () + "' - while finding the regular expression '" + regExpression + "' in file '" + file + "'.");
        }
        if (foundString != null) {
            break;
        }
        long currentTime = System.currentTimeMillis ();
        long lapTime = currentTime - startTime;
        if (lapTime > maximumWaitTime) {
            break;
        }
        try {
            this.wait (500);
        } catch (InterruptedException ie) {
            logger.log (Level.WARNING, ie.getMessage (), ie);
        }
    }
    return foundString;
}


private void createToolBar (final Shell shell, Object layoutData) {
    toolBar = new ToolBar (shell, SWT.NULL);
    toolBar.setLayoutData (layoutData);
    ToolItem item = new ToolItem (toolBar, SWT.SEPARATOR);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdParent]);
    item.setToolTipText (getResourceString ("tool.Parent.tiptext"));
    item.addSelectionListener (new SelectionAdapter () {
        public void widgetSelected (SelectionEvent e) {
            doParent ();
        }
    }
    );
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdRefresh]);
    item.setToolTipText (getResourceString ("tool.Refresh.tiptext"));
    item.addSelectionListener (new SelectionAdapter () {
        public void widgetSelected (SelectionEvent e) {
            doRefresh ();
        }
    }
    );
    SelectionAdapter unimplementedListener = new SelectionAdapter () {
        public void widgetSelected (SelectionEvent e) {
            MessageBox box = new MessageBox (shell, SWT.ICON_INFORMATION | SWT.OK);
            box.setText (getResourceString ("dialog.NotImplemented.title"));
            box.setMessage (getResourceString ("dialog.ActionNotImplemented.description"));
            box.open ();
        }
    }
    ;
    item = new ToolItem (toolBar, SWT.SEPARATOR);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdCut]);
    item.setToolTipText (getResourceString ("tool.Cut.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdCopy]);
    item.setToolTipText (getResourceString ("tool.Copy.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdPaste]);
    item.setToolTipText (getResourceString ("tool.Paste.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.SEPARATOR);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdDelete]);
    item.setToolTipText (getResourceString ("tool.Delete.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdRename]);
    item.setToolTipText (getResourceString ("tool.Rename.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.SEPARATOR);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdSearch]);
    item.setToolTipText (getResourceString ("tool.Search.tiptext"));
    item.addSelectionListener (unimplementedListener);
    item = new ToolItem (toolBar, SWT.PUSH);
    item.setImage (iconCache.stockImages [iconCache.cmdPrint]);
    item.setToolTipText (getResourceString ("tool.Print.tiptext"));
    item.addSelectionListener (unimplementedListener);
}


-----Function Pair=107=-----==

public void insertStringInFile (String file, String textToInsert, long fromByte, long toByte) throws Exception {
    String tmpFile = file + ".tmp";
    BufferedInputStream in = null;
    BufferedOutputStream out = null;
    long byteCount = 0;
    try {
        in = new BufferedInputStream (new FileInputStream (new File (file)));
        out = new BufferedOutputStream (new FileOutputStream (tmpFile));
        long size = fromByte;
        byte [] buf = null;
        if (size == 0) {
        }
        else {
            buf = new byte [(int) size];
            int length = - 1;
            if ((length = in.read (buf)) != - 1) {
                out.write (buf, 0, length);
                byteCount = byteCount + length;
            }
            else {
                String msg = "Failed to read the first '" + size + "' bytes of file '" + file + "'. This might be a programming error.";
                logger.warning (msg);
                throw new Exception (msg);
            }
        }
        buf = textToInsert.getBytes ();
        int length = buf.length;
        out.write (buf, 0, length);
        byteCount = byteCount + length;
        long skipLength = toByte - fromByte;
        long skippedBytes = in.skip (skipLength);
        if (skippedBytes == - 1) {
        }
        else {
            buf = new byte [4096];
            length = - 1;
            while ((length = in.read (buf)) != - 1) {
                out.write (buf, 0, length);
                byteCount = byteCount + length;
            }
        }
        in.close ();
        in = null;
        out.close ();
        out = null;
        File fileToDelete = new File (file);
        boolean wasDeleted = fileToDelete.delete ();
        if (! wasDeleted) {
            String msg = "Failed to delete the original file '" + file + "' to replace it with the modified file after text insertion.";
            logger.warning (msg);
            throw new Exception (msg);
        }
        File fileToRename = new File (tmpFile);
        boolean wasRenamed = fileToRename.renameTo (fileToDelete);
        if (! wasRenamed) {
            String msg = "Failed to rename tmp file '" + tmpFile + "' to the name of the original file '" + file + "'";
            logger.warning (msg);
            throw new Exception (msg);
        }
    } catch (Exception e) {
        logger.log (Level.WARNING, "Failed to read/write file '" + file + "'.", e);
        throw e;
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (IOException e) {
                logger.log (Level.FINEST, "Ignoring error closing input file '" + file + "'.", e);
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
                logger.log (Level.FINEST, "Ignoring error closing output file '" + tmpFile + "'.", e);
            }
        }
    }
}


private byte [] nownextEPG (HTTPurl urlData) throws Exception {
    GuideStore guide = GuideStore.getInstance ();
    StringBuffer buff = new StringBuffer ();
    buff.append ("<b>Now Showing (" + (new Date ()).toString () + ")</b><p>\n");
    buff.append ("<a href='/servlet/EpgDataRes?action=21");
    buff.append ("'>Refresh This Screen</a><p>\n");
    buff.append ("<table>\n");
    buff.append ("<tr>");
    buff.append ("<td>&nbsp;</td>");
    buff.append ("<td>Program Name</td>");
    buff.append ("<td>Time</td>");
    buff.append ("</tr>");
    Vector chanMap = guide.getChannelMap ();
    Set wsChannels = store.getChannels ().keySet ();
    Calendar startTime = Calendar.getInstance ();
    Date Now = new Date ();
    for (int y = 0; y < chanMap.size (); y ++) {
        String [] map = (String []) chanMap.get (y);
        boolean bNext = false;
        if (wsChannels.contains (map [0])) {
            GuideItem [] items = guide.getProgramsForChannel (map [1]);
            buff.append ("<tr><td colspan='5' bgcolor=#000000>\n");
            buff.append ("<span class='areaTitle'>" + map [0] + "</span><br>\n");
            buff.append ("</td></tr\n");
            for (int x = 0; x < items.length; x ++) {
                GuideItem item = items [x];
                startTime.setTime (item.getStart ());
                if ((item.getStart ().before (Now) && item.getStop ().after (Now)) || bNext) {
                    boolean bNow = ! bNext;
                    if (! bNext) bNext = true;
                    else bNext = false;
                    int hour = startTime.get (Calendar.HOUR_OF_DAY);
                    if (hour > 12) hour = hour - 12;
                    else if (hour == 0) hour = 12;
                    String startString = intToStr (hour) + ":" + intToStr (startTime.get (Calendar.MINUTE)) + " " + store.ampm.get (new Integer (startTime.get (Calendar.AM_PM)));
                    buff.append ("<tr>\n");
                    buff.append ("<td class='epgSearchResults'><b>" + (bNow ? "NOW" : "NEXT") + "</b></td>");
                    buff.append ("<td class='epgSearchResults'>");
                    String infoUrl = "/servlet/EpgDataRes?action=06&id=" + item.toString () + "&channel=" + URLEncoder.encode (map [0], "UTF-8");
                    buff.append ("<span class='programName' onClick=\"openDetails('" + infoUrl + "')\">");
                    buff.append ("<b>" + item.getName () + "</b>");
                    buff.append ("</span>");
                    buff.append ("</td>");
                    buff.append ("<td class='epgSearchResults'>" + startString + " (" + item.getDuration () + ")</td>");
                    buff.append ("</tr>\n");
                    if (bNow) buff.append ("<tr><td colspan=5><font size=2>" + item.getDescription () + "</font></td></tr>\n");
                    if (! bNow) buff.append ("<tr><td colspan=5>&nbsp;</td></tr>\n");
                }
            }
        }
    }
    buff.append ("</table><p>\n");
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "epg-nownext.html");
    template.replaceAll ("$result", buff.toString ());
    template.addCookie ("backURL", urlData.getReqString ());
    return template.getPageBytes ();
}


-----Function Pair=108=-----==

public static InputStream getResourceAsStream (String url) throws BlogunityException {
    if (log.isDebugEnabled ()) {
        log.debug ("Getting InputStream for requested resource url=" + url);
    }
    if (url.charAt (0) != '/') url = "/" + url;
    String mainDataDirectory = BlogunityManager.getSystemConfiguration ().getDataDir ();
    File f = new File (mainDataDirectory, url);
    if (f.exists () && f.isFile () && f.canRead ()) {
        FileInputStream in;
        try {
            in = new FileInputStream (f);
            return in;
        } catch (FileNotFoundException e) {
            log.error ("getThemeResourceAsStream(String)", e);
            throw new BlogunityException (I18NStatusFactory.create (I18N.ERRORS.RESOURCE_NOT_FOUND, url));
        }
    }
    throw new BlogunityException (I18NStatusFactory.create (I18N.ERRORS.RESOURCE_NOT_FOUND, url));
}


public static String getHexColorTriplet (Color color) {
    String hexColorTriplet = null;
    final String ZERO_FLUFF = "0";
    if (color != null) {
        StringBuffer hexColorBuffer = new StringBuffer ();
        if (color.getRed () < HEX_RADIX) hexColorBuffer.append (ZERO_FLUFF);
        hexColorBuffer.append (Integer.toHexString (color.getRed ()));
        if (color.getGreen () < HEX_RADIX) hexColorBuffer.append (ZERO_FLUFF);
        hexColorBuffer.append (Integer.toHexString (color.getGreen ()));
        if (color.getBlue () < HEX_RADIX) hexColorBuffer.append (ZERO_FLUFF);
        hexColorBuffer.append (Integer.toHexString (color.getBlue ()));
        hexColorTriplet = hexColorBuffer.toString ();
    }
    return hexColorTriplet;
}


-----Function Pair=109=-----==

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


private byte [] updateEmailOptions (HTTPurl urlData) throws Exception {
    String out = "";
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String to = urlData.getParameter ("email.to");
    if (to == null) to = "";
    store.setServerProperty ("email.to", to.trim ());
    String from = urlData.getParameter ("email.from");
    if (from == null) from = "";
    store.setServerProperty ("email.from", from.trim ());
    String serverAddress = urlData.getParameter ("email.server.address");
    if (serverAddress == null) serverAddress = "";
    store.setServerProperty ("email.server.address", serverAddress.trim ());
    String serverPort = urlData.getParameter ("email.server.port");
    if (serverPort == null) serverPort = "";
    store.setServerProperty ("email.server.port", serverPort.trim ());
    String userAuth = urlData.getParameter ("email.auth.enabled");
    if (userAuth == null || "1".equals (userAuth) == false) userAuth = "0";
    store.setServerProperty ("email.auth.enabled", userAuth);
    String username = urlData.getParameter ("email.auth.user");
    if (username == null) username = "";
    store.setServerProperty ("email.auth.user", username.trim ());
    String password = urlData.getParameter ("email.auth.password");
    if (password == null) password = "";
    store.setServerProperty ("email.auth.password", password.trim ());
    String security = urlData.getParameter ("email.security");
    store.setServerProperty ("email.security", security.trim ());
    String serverStarted = urlData.getParameter ("email.send.serverstarted");
    if (serverStarted == null || "1".equals (serverStarted) == false) serverStarted = "0";
    store.setServerProperty ("email.send.serverstarted", serverStarted);
    String capFinished = urlData.getParameter ("email.send.capfinished");
    if (capFinished == null || "1".equals (capFinished) == false) capFinished = "0";
    store.setServerProperty ("email.send.capfinished", capFinished);
    String epgLoaded = urlData.getParameter ("email.send.epgloaded");
    if (epgLoaded == null || "1".equals (epgLoaded) == false) epgLoaded = "0";
    store.setServerProperty ("email.send.epgloaded", epgLoaded);
    String onWarning = urlData.getParameter ("email.send.onwarning");
    if (onWarning == null || "1".equals (onWarning) == false) onWarning = "0";
    store.setServerProperty ("email.send.onwarning", onWarning);
    String weeklyReport = urlData.getParameter ("email.send.weeklyreport");
    if (weeklyReport == null || "1".equals (weeklyReport) == false) weeklyReport = "0";
    store.setServerProperty ("email.send.weeklyreport", weeklyReport);
    String sendFreeSpaceLow = urlData.getParameter ("email.send.freespacelow");
    if (sendFreeSpaceLow == null || "1".equals (sendFreeSpaceLow) == false) sendFreeSpaceLow = "0";
    store.setServerProperty ("email.send.freespacelow", sendFreeSpaceLow);
    return out.getBytes ();
}


-----Function Pair=110=-----==

public static boolean copyFile (File sourceFile, File destinationFile) {
    boolean copySuccessfull = false;
    FileChannel source = null;
    FileChannel destination = null;
    try {
        source = new FileInputStream (sourceFile).getChannel ();
        destination = new FileOutputStream (destinationFile).getChannel ();
        long transferedBytes = destination.transferFrom (source, 0, source.size ());
        copySuccessfull = transferedBytes == source.size () ? true : false;
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        if (source != null) {
            try {
                source.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
        if (destination != null) {
            try {
                destination.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
    return copySuccessfull;
}


private void addObjectProperties () throws ObjectIntegrityException {
    String state = DOTranslationUtility.getStateAttribute (m_obj);
    String ownerId = m_obj.getOwnerId ();
    String label = m_obj.getLabel ();
    Date cdate = m_obj.getCreateDate ();
    Date mdate = m_obj.getLastModDate ();
    m_feed.setId (m_pid.toURI ());
    m_feed.setTitle (label == null ? "" : label);
    m_feed.setUpdated (mdate);
    m_feed.addAuthor (ownerId == null ? "" : StreamUtility.enc (ownerId));
    m_feed.addCategory (MODEL.STATE.uri, state, null);
    if (cdate != null) {
        m_feed.addCategory (MODEL.CREATED_DATE.uri, DateUtility.convertDateToString (cdate), null);
    }
    for (String extProp : m_obj.getExtProperties ().keySet ()) {
        m_feed.addCategory (MODEL.EXT_PROPERTY.uri, extProp, m_obj.getExtProperty (extProp));
    }
}


-----Function Pair=111=-----==

private int findLastLogEntryStart (byte [] histLog) {
    if (histLog == null || histLog.length == 0) return - 1;
    int dashcount = 0;
    for (int pos = histLog.length; pos -- > 0;) {
        if (histLog [pos] != '-') {
            dashcount = 0;
        }
        else if (++ dashcount > 60) {
            int result = pos + dashcount;
            while (result < histLog.length) {
                if (Character.isWhitespace (histLog [result])) result ++;
                else return result;
            }
            return - 1;
        }
    }
    return - 1;
}


private void testSFV (MyFile f) {
    if (Pattern.matches (".*.sfv", f.getName ().toLowerCase ())) {
        try {
            BufferedReader reader = new BufferedReader (new FileReader (f.getAbsolutePath ()));
            String line;
            while ((line = reader.readLine ()) != null) {
                if (! line.startsWith (";")) {
                    String [] t = Utilities.split (line, " ");
                    if (t.length > 1) {
                        crcCache.put (t [0], t [1].toLowerCase ());
                    }
                }
            }
        } catch (IOException e) {
        }
    }
}


-----Function Pair=112=-----==

public static Color getColor (String hexColorTriplet) {
    Color color = null;
    final int REQUIRED_LENGTH = 6;
    final int INVALID_VALUE = - 1;
    if (hexColorTriplet != null && hexColorTriplet.length () == REQUIRED_LENGTH) {
        String redString = hexColorTriplet.substring (0, 2);
        String greenString = hexColorTriplet.substring (2, 4);
        String blueString = hexColorTriplet.substring (4, 6);
        int redInt = INVALID_VALUE;
        int greenInt = INVALID_VALUE;
        int blueInt = INVALID_VALUE;
        try {
            redInt = Integer.parseInt (redString, HEX_RADIX);
            greenInt = Integer.parseInt (greenString, HEX_RADIX);
            blueInt = Integer.parseInt (blueString, HEX_RADIX);
        } catch (NumberFormatException e) {
        }
        if (redInt != INVALID_VALUE && greenInt != INVALID_VALUE && blueInt != INVALID_VALUE) color = new Color (redInt, greenInt, blueInt);
    }
    return color;
}


public static File [] extractFiles (String commaSeparList, String extension) {
    ArrayList filesAL = new ArrayList ();
    String [] items = commaSeparList.split (",");
    for (int i = 0; i < items.length; i ++) {
        File test = new File (items [i]);
        if (test.canRead () == false) return null;
        File [] files = extractFiles (test, extension);
        if (files == null) return null;
        for (int j = 0; j < files.length; j ++) {
            filesAL.add (files [j]);
        }
    }
    File [] collection = new File [filesAL.size ()];
    filesAL.toArray (collection);
    return collection;
}


-----Function Pair=113=-----==

public static int getLinkCount (File fileName) throws IOException {
    int len = getLinkCountCommand.length;
    String [] cmd = new String [len + 1];
    for (int i = 0; i < len; i ++) {
        cmd [i] = getLinkCountCommand [i];
    }
    cmd [len] = fileName.toString ();
    String inpMsg = "";
    String errMsg = "";
    int exitValue = - 1;
    BufferedReader in = null;
    BufferedReader err = null;
    Process process = Runtime.getRuntime ().exec (cmd);
    try {
        exitValue = process.waitFor ();
        in = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        inpMsg = in.readLine ();
        if (inpMsg == null) inpMsg = "";
        err = new BufferedReader (new InputStreamReader (process.getErrorStream ()));
        errMsg = err.readLine ();
        if (errMsg == null) errMsg = "";
        if (exitValue != 0) {
            throw new IOException (inpMsg + errMsg);
        }
        if (getOSType () == OSType.OS_TYPE_SOLARIS) {
            String [] result = inpMsg.split ("\\s+");
            return Integer.parseInt (result [1]);
        }
        else {
            return Integer.parseInt (inpMsg);
        }
    } catch (NumberFormatException e) {
        throw new IOException (StringUtils.stringifyException (e) + inpMsg + errMsg + " on file:" + fileName);
    } catch (InterruptedException e) {
        throw new IOException (StringUtils.stringifyException (e) + inpMsg + errMsg + " on file:" + fileName);
    } finally {
        process.destroy ();
        if (in != null) in.close ();
        if (err != null) err.close ();
    }
}


private byte [] loadJarData (String path, String fileName) {
    ZipFile zipFile = null;
    InputStream stream = null;
    File archive = new File (path);
    if (! archive.exists ()) return null;
    try {
        zipFile = new ZipFile (archive);
    } catch (IOException io) {
        return null;
    }
    ZipEntry entry = zipFile.getEntry (fileName);
    if (entry == null) return null;
    int size = (int) entry.getSize ();
    try {
        stream = zipFile.getInputStream (entry);
        byte [] data = new byte [size];
        int pos = 0;
        while (pos < size) {
            int n = stream.read (data, pos, data.length - pos);
            pos += n;
        }
        zipFile.close ();
        return data;
    } catch (IOException e) {
    } finally {
        try {
            if (stream != null) stream.close ();
        } catch (IOException e) {
        }
    }
    return null;
}


-----Function Pair=114=-----==

public static synchronized OpReportManager getReportManager (OpProjectSession s) {
    String sessionSpecificString = String.valueOf (s.getUserID ()).concat (XEnvironmentManager.FILE_SEPARATOR);
    OpReportManager instance = null;
    Set resourceInterceptors = s.getResourceInterceptors ();
    Iterator resourceInterceptorsIter = resourceInterceptors.iterator ();
    while (resourceInterceptorsIter.hasNext ()) {
        XResourceInterceptor interceptor = (XResourceInterceptor) resourceInterceptorsIter.next ();
        if (interceptor instanceof OpReportManager) {
            if (((OpReportManager) interceptor).userSpecificString.equalsIgnoreCase (sessionSpecificString)) {
                instance = (OpReportManager) interceptor;
            }
            else {
                resourceInterceptorsIter.remove ();
            }
        }
    }
    if (instance == null) {
        instance = new OpReportManager (s);
    }
    return instance;
}


public Map < String, PdfLayer > getPdfLayers () {
    if (documentOCG.isEmpty ()) {
        readOCProperties ();
    }
    HashMap < String, PdfLayer > map = new HashMap < String, PdfLayer > ();
    PdfLayer layer;
    String key;
    for (PdfOCG pdfOCG : documentOCG) {
        layer = (PdfLayer) pdfOCG;
        if (layer.getTitle () == null) {
            key = layer.getAsString (PdfName.NAME).toString ();
        }
        else {
            key = layer.getTitle ();
        }
        if (map.containsKey (key)) {
            int seq = 2;
            String tmp = key + "(" + seq + ")";
            while (map.containsKey (tmp)) {
                seq ++;
                tmp = key + "(" + seq + ")";
            }
            key = tmp;
        }
        map.put (key, layer);
    }
    return map;
}


-----Function Pair=115=-----==

private void handleBackspace () {
    Element elem;
    int pos = editor.getCaretPosition ();
    ExtendedHTMLDocument htmlDoc = (ExtendedHTMLDocument) editor.getStyledDocument ();
    try {
        if (pos > 0) {
            if ((editor.getSelectedText ()) != null) {
                ExtendedHTMLEditorKit.delete (editor);
                return;
            }
            int sOffset = htmlDoc.getParagraphElement (pos).getStartOffset ();
            if (sOffset == editor.getSelectionStart ()) {
                boolean content = true;
                if (ExtendedHTMLEditorKit.checkParentsTag (htmlDoc.getParagraphElement (editor.getCaretPosition ()), HTML.Tag.LI)) {
                    elem = ExtendedHTMLEditorKit.getListItemParent (htmlDoc.getCharacterElement (editor.getCaretPosition ()));
                    content = false;
                    int so = elem.getStartOffset ();
                    int eo = elem.getEndOffset ();
                    if ((so + 1) < eo) {
                        char [] temp = editor.getText (so, eo - so).toCharArray ();
                        for (int i = 0; i < temp.length; i ++) {
                            if (! Character.isWhitespace (temp [i])) {
                                content = true;
                            }
                        }
                    }
                    if (! content) {
                        elem.getParentElement ();
                        ExtendedHTMLEditorKit.removeTag (editor, elem, true);
                        editor.setCaretPosition (sOffset - 1);
                        return;
                    }
                    editor.setCaretPosition (editor.getCaretPosition () - 1);
                    editor.moveCaretPosition (editor.getCaretPosition () - 2);
                    editor.replaceSelection ("");
                    return;
                }
            }
            editor.replaceSelection ("");
            return;
        }
    } catch (BadLocationException ble) {
        Logging.errorPrint (ble.getMessage (), ble);
    }
}


private byte [] deleteChannel (HTTPurl urlData) throws Exception {
    GuideStore guide = GuideStore.getInstance ();
    String name = urlData.getParameter ("ID");
    if (name != null) {
        store.removeChannel (name);
        store.saveChannels (null);
        boolean save = false;
        Vector < String [] > chanMap = guide.getChannelMap ();
        for (int x = 0; x < chanMap.size (); x ++) {
            String [] map = (String []) chanMap.get (x);
            if (map [0].equals (name)) {
                chanMap.remove (x);
                x --;
                save = true;
            }
        }
        if (save) guide.saveChannelMap (null);
    }
    StringBuffer out = new StringBuffer (256);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: /servlet/" + urlData.getServletClass () + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=116=-----==

private boolean configureSharedLibraryProject64bit (IProject libProject, String spuProjectName) {
    boolean saveBuildStatus = false;
    try {
        IConfiguration [] configs = ManagedBuildManager.getBuildInfo (libProject).getManagedProject ().getConfigurations ();
        IConfiguration configuration = null;
        for (int i = 0; i < configs.length; i ++) {
            if (configs [i].getId ().startsWith ("celldt.managedbuild.config.cell.ppu.gnu64.so.debug")) {
                configuration = configs [i];
                break;
            }
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_OPEN, true);
        IToolChain toolChain = configuration.getToolChain ();
        ITool embedSpuTool = toolChain.getToolsBySuperClassId ("celldt.managedbuild.tool.cell.ppu.gnu64.embedspu") [0];
        IOption embedSpuInputOption = embedSpuTool.getOptionBySuperClassId ("cell.ppu.gnu.embedspu.option.inputs");
        ManagedBuildManager.setOption (configuration, embedSpuTool, embedSpuInputOption, new String [] {"\"${workspace_loc:/" + spuProjectName + "/spu-gnu-debug/" + spuProjectName + "}\""});
        saveBuildStatus = ManagedBuildManager.saveBuildInfo (libProject, true);
        IManagedBuildInfo bi = ManagedBuildManager.getBuildInfo (libProject);
        if (bi != null & bi instanceof ManagedBuildInfo) ((ManagedBuildInfo) bi).initializePathEntries ();
        if (is64bit) {
            ManagedBuildManager.setDefaultConfiguration (libProject, configuration);
            ManagedBuildManager.setSelectedConfiguration (libProject, configuration);
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_APPLY, true);
        if (! saveBuildStatus) throw new Exception ();
    } catch (Exception e) {
        wizard.openWarningMessage (Messages.ALFWizardCreationAction_queryTitle, Messages.ALFWizardCreationAction_errorConfiguringSharedLibraryProject);
    }
    return saveBuildStatus;
}


public void sendFileToZipStream (String userbaseDir, String fileStr, ZipOutputStream zipout) throws Exception {
    if (! userbaseDir.endsWith (sep)) {
        userbaseDir += sep;
    }
    BufferedInputStream in = null;
    byte dataBuff [] = new byte [bufferSize];
    String entryPath = fileStr;
    String entryFullPath = userbaseDir + entryPath;
    File sendFile = new File (entryFullPath);
    if ((sendFile.exists ()) && (! sendFile.isDirectory ())) {
        in = new BufferedInputStream (new FileInputStream (entryFullPath), bufferSize);
        ZipEntry zipEntry = new ZipEntry (entryPath);
        zipout.putNextEntry (zipEntry);
        int writeLen;
        while ((writeLen = in.read (dataBuff)) > 0) {
            zipout.write (dataBuff, 0, writeLen);
        }
        zipout.flush ();
        zipout.closeEntry ();
        in.close ();
    }
    else {
        throw new Exception ("file is not exist ! entryFullPath = (" + entryFullPath + ")");
    }
}


-----Function Pair=117=-----==

private File unzipArchive (File zipArchive, File outDir, String nameInZipArchive) throws IOException {
    File mainFile = null;
    ZipEntry entry = null;
    ZipInputStream zis = new ZipInputStream (new FileInputStream ((zipArchive)));
    FileOutputStream fos = null;
    byte buffer [] = new byte [4096];
    int bytesRead;
    while ((entry = zis.getNextEntry ()) != null) {
        File outFile = new File (outDir, entry.getName ());
        if (entry.getName ().equals (nameInZipArchive)) mainFile = outFile;
        fos = new FileOutputStream (outFile);
        while ((bytesRead = zis.read (buffer)) != - 1) fos.write (buffer, 0, bytesRead);
        fos.close ();
    }
    zis.close ();
    return mainFile;
}


public void sendStringToZipStream (String userbaseDir, String fileStr, String fileValueString, ZipOutputStream zipout) throws Exception {
    if (! userbaseDir.endsWith (sep)) {
        userbaseDir += sep;
    }
    BufferedInputStream in = null;
    byte dataBuff [] = new byte [bufferSize];
    String entryPath = fileStr;
    in = new BufferedInputStream (new ByteArrayInputStream (fileValueString.getBytes ()), bufferSize);
    ZipEntry zipEntry = new ZipEntry (entryPath);
    zipout.putNextEntry (zipEntry);
    int writeLen;
    while ((writeLen = in.read (dataBuff)) > 0) {
        zipout.write (dataBuff, 0, writeLen);
    }
    zipout.flush ();
    zipout.closeEntry ();
    in.close ();
}


-----Function Pair=118=-----==

private byte [] moveTunerDown (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount () - 1) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex + 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


void sendEmail (boolean wholeSession) {
    Intent emailSession = new Intent (Intent.ACTION_SEND);
    if (mEmailSubject == null || mEmailSubject.length () == 0) if (wholeSession) emailSession.putExtra (Intent.EXTRA_SUBJECT, mActivity.getString (R.string.rehearsal_assistant_session) + " \"" + mSessionCursor.getString (1) + "\"");
    else emailSession.putExtra (Intent.EXTRA_SUBJECT, mActivity.getString (R.string.rehearsal_assistant_recording) + " \"" + formatter.format (new Date (mAnnotationsCursor.getLong (ANNOTATIONS_START_TIME))) + "\"");
    else emailSession.putExtra (Intent.EXTRA_SUBJECT, mEmailSubject);
    String messageText = new String ();
    if (wholeSession && mEmailDetail) {
        messageText += mActivity.getString (R.string.session_title) + " " + mSessionCursor.getString (SESSIONS_TITLE) + "\n";
        messageText += mActivity.getString (R.string.session_start_time) + " " + DateFormat.getDateTimeInstance ().format (new Date (mSessionCursor.getLong (SESSIONS_START_TIME))) + "\n";
        messageText += mActivity.getString (R.string.session_end_time) + " " + DateFormat.getDateTimeInstance ().format (new Date (mSessionCursor.getLong (SESSIONS_END_TIME))) + "\n\n";
    }
    if (wholeSession) {
        String archiveFilename = Environment.getExternalStorageDirectory ().getAbsolutePath () + "/urbanstew.RehearsalAssistant/session.zip";
        if (mAnnotationsCursor.getCount () == 0 || createSessionArchive (archiveFilename)) {
            if (mAnnotationsCursor.getCount () == 0) {
                messageText += mActivity.getString (R.string.no_annotations) + "\n";
                emailSession.setType ("message/rfc822");
            }
            else {
                emailSession.putExtra (Intent.EXTRA_STREAM, Uri.parse ("file://" + archiveFilename));
                emailSession.setType ("application/zip");
            }
        }
        if (mEmailDetail) for (mAnnotationsCursor.moveToFirst (); ! mAnnotationsCursor.isAfterLast (); mAnnotationsCursor.moveToNext ()) messageText += annotationTextInfo (mActivity.getString (R.string.annotation));
    }
    else {
        emailSession.putExtra (Intent.EXTRA_STREAM, Uri.parse ("file://" + mAnnotationsCursor.getString (ANNOTATIONS_FILE_NAME)));
        emailSession.setType ("audio/3gpp");
        if (mEmailDetail) messageText += annotationTextInfo (mActivity.getString (R.string.recording));
    }
    messageText += "\n\n" + mActivity.getString (R.string.recorded_with_rehearsal_assistant);
    emailSession.putExtra (Intent.EXTRA_TEXT, messageText);
    if (mEmailTo != null) emailSession.putExtra (Intent.EXTRA_EMAIL, mEmailTo.split (","));
    emailSession = Intent.createChooser (emailSession, mActivity.getString (R.string.e_mail));
    try {
        mActivity.startActivity (emailSession);
    } catch (ActivityNotFoundException e) {
        Toast.makeText (mActivity, mActivity.getString (R.string.error_send) + " " + e.getMessage (), Toast.LENGTH_SHORT).show ();
    }
}


-----Function Pair=119=-----==

private byte [] showServerProperties (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (1024);
    String value = "";
    HashMap < String, String > options = null;
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Capture Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.deftype");
    options = new HashMap < String, String > ();
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int index = 0; index < capabilities.size (); index ++) {
        CaptureCapability capability = capabilities.get (index);
        options.put (new Integer (capability.getTypeID ()).toString (), capability.getName ());
    }
    out.append ("<tr><td align='left'>Default Capture Type</td><td>");
    out.append (htmlDropMenu (options, "Capture.deftype", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.deftype');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.path.details");
    out.append ("<tr><td align='left'>Capture Details Path</td><td>\n");
    out.append ("<input type='text' name='Capture.path.details' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.path.details');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Capture.CaptureFailedTimeout");
    options = new HashMap < String, String > ();
    options.put ("003", "15 Seconds");
    options.put ("006", "30 Seconds");
    options.put ("012", "60 Seconds");
    options.put ("024", "128 Seconds");
    out.append ("<tr><td align='left'>Failed Capture Timeout</td><td>");
    out.append (htmlDropMenu (options, "Capture.CaptureFailedTimeout", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Capture.CaptureFailedTimeout');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Schedule Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.end");
    out.append ("<tr><td align='left'>End Buffer Time</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.end' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.start");
    out.append ("<tr><td align='left'>Start Buffer Time</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.start' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.start');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.buffer.end.epg");
    out.append ("<tr><td align='left'>End Buffer EPG Addition</td><td>\n");
    out.append ("<input type='text' name='Schedule.buffer.end.epg' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.buffer.end.epg');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Email Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.server");
    out.append ("<tr><td align='left'>Email Server</td><td>\n");
    out.append ("<input type='text' name='email.server' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.server');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.from");
    out.append ("<tr><td align='left'>Email From Address</td><td>\n");
    out.append ("<input type='text' name='email.from' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.from.name");
    out.append ("<tr><td align='left'>Email From Name</td><td>\n");
    out.append ("<input type='text' name='email.from.name' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.from.name');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("email.to");
    out.append ("<tr><td align='left'>Email To</td><td>\n");
    out.append ("<input type='text' name='email.to' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('email.to');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>File Browser Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("filebrowser.DirsAtTop");
    options = new HashMap < String, String > ();
    options.put ("0", "Bottom");
    options.put ("1", "Top");
    out.append ("<tr><td align='left'>Directories Shown At</td><td>");
    out.append (htmlDropMenu (options, "filebrowser.DirsAtTop", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.DirsAtTop');\" width='24' height='24'></td></tr>\n");
    value = store.getProperty ("filebrowser.masks");
    out.append ("<tr><td align='left'>Show Extensions</td><td>\n");
    out.append ("<input type='text' name='filebrowser.masks' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.masks');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("filebrowser.ShowWsPlay");
    options = new HashMap < String, String > ();
    options.put ("0", "False");
    options.put ("1", "True");
    out.append ("<tr><td align='left'>Show Play Now Link</td><td>");
    out.append (htmlDropMenu (options, "filebrowser.ShowWsPlay", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('filebrowser.ShowWsPlay');\" width='24' height='24'></td></tr>\n");
    out.append ("<tr><td colspan='3' align='left' style='border: 1px solid rgb(255, 255, 255);'>");
    out.append ("<span class='areaTitle'>Server Settings</span>\n");
    out.append ("</td></tr>\n");
    value = store.getProperty ("server.kbLED");
    options = new HashMap < String, String > ();
    options.put ("0", "Disabled");
    options.put ("1", "Enabled");
    out.append ("<tr><td align='left'>Keyboard LED Control</td><td>");
    out.append (htmlDropMenu (options, "server.kbLED", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('server.kbLED');\" width='24' height='24'>");
    out.append ("</td></tr>\n");
    value = store.getProperty ("Schedule.wake.system");
    out.append ("<tr><td align='left'>Seconds for system wake up</td><td>\n");
    out.append ("<input type='text' name='Schedule.wake.system' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('Schedule.wake.system');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("AutoDel.KeepFor");
    out.append ("<tr><td align='left'>Default keep for</td><td>\n");
    out.append ("<input type='text' name='AutoDel.KeepFor' value='" + value + "' size='50'>\n");
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('AutoDel.KeepFor');\" width='24' height='24'></tr>\n");
    value = store.getProperty ("EPG.ShowUnlinked");
    options = new HashMap < String, String > ();
    options.put ("0", "False");
    options.put ("1", "True");
    out.append ("<tr><td align='left'>Show Unlinked Schedules</td><td>");
    out.append (htmlDropMenu (options, "EPG.ShowUnlinked", value));
    out.append ("</td><td><img style='cursor:hand;cursor:pointer;' border=0 src='/images/help24.png' alt='help' align='absmiddle' onClick=\"showHelp('EPG.ShowUnlinked');\" width='24' height='24'></tr>\n");
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "serverpropertie.html");
    template.replaceAll ("$properties", out.toString ());
    return template.getPageBytes ();
}


public byte [] showArchive (HTTPurl urlData, OutputStream outStream) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "ArchiveList.html");
    StringBuffer buff = new StringBuffer ();
    File outFile = new File (new DllWrapper ().getAllUserPath () + "archive");
    if (outFile.exists () == false) outFile.mkdirs ();
    File [] files = outFile.listFiles ();
    Arrays.sort (files);
    for (int x = files.length - 1; files != null && x >= 0; x --) {
        File archiveFile = files [x];
        if (archiveFile.isDirectory () == false && archiveFile.getName ().startsWith ("Schedule-")) {
            buff.append ("<tr>\n");
            buff.append ("<td><a class='noUnder' href='/servlet/ArchiveDataRes?action=showItemInfo&file=" + URLEncoder.encode (archiveFile.getCanonicalPath (), "UTF-8") + "'>" + archiveFile.getName () + "</a></td>\n");
            buff.append ("</tr>\n");
        }
    }
    template.replaceAll ("$ArchiveList", buff.toString ());
    return template.getPageBytes ();
}


-----Function Pair=120=-----==

private byte [] showRegionList (HTTPurl urlData) throws Exception {
    int country = 0;
    try {
        country = Integer.parseInt (urlData.getParameter ("country"));
    } catch (Exception e) {
        throw new Exception ("country code not valid: " + e.toString ());
    }
    ChannelList list = new ChannelList (store.getProperty ("path.data") + File.separator + "stationdata.list");
    StringBuffer buff = new StringBuffer (1024);
    String [] regionList = list.getRegions (country);
    list.close ();
    buff.append ("<table><tr><td><ul>\n");
    for (int x = 0; x < regionList.length; x ++) {
        if (regionList [x] != null) {
            buff.append ("<li>\n");
            buff.append ("<a href='/servlet/" + urlData.getServletClass () + "?action=03&country=" + country + "&region=" + x + "' class='noUnder'>" + regionList [x] + "</a>\n");
            buff.append ("</li>\n");
        }
    }
    buff.append ("</ul></td></tr></table>\n");
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "channel-regionlist.html");
    template.replaceAll ("$regions", buff.toString ());
    return template.getPageBytes ();
}


public static void openUrl (String url) {
    String os = System.getProperty ("os.name");
    Runtime runtime = Runtime.getRuntime ();
    try {
        if (os.startsWith ("Windows")) {
            String cmd = "rundll32 url.dll,FileProtocolHandler " + url;
            Process p = runtime.exec (cmd);
        }
        else if (os.startsWith ("Mac OS")) {
        }
        else {
            String [] browsers = {"firefox", "opera", "konqueror", "epiphany", "mozilla", "netscape"};
            String browser = null;
            for (int count = 0; count < browsers.length && browser == null; count ++) if (runtime.exec (new String [] {"which", browsers [count]}).waitFor () == 0) {
                browser = browsers [count];
                break;
            }
            if (browser != null) runtime.exec (new String [] {browser, url});
        }
    } catch (Exception x) {
        System.err.println ("Exception occurd while invoking Browser!");
        x.printStackTrace ();
    }
}


-----Function Pair=121=-----==

public void compress (String packageName) {
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    try {
        File oDestFile = new File (String.format (this.globalData.getData (IGlobalData.PROJECT_OUTPUT_PATH) + "%s.mnm", packageName));
        if (! oDestFile.exists ()) oDestFile.createNewFile ();
        oDestination = new FileOutputStream (oDestFile);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        oOutput.setLevel (9);
        for (Module module : modules) {
            String sRelativePath = module.getResource ().getProjectRelativePath ().toString ();
            ZipEntry oEntry = new ZipEntry (sRelativePath);
            oOutput.putNextEntry (oEntry);
            if (module.getDocument () == null) {
                writeBinary (module.getResource ().getLocation ().toString (), oOutput);
            }
            else {
                writeXml (module.getDocument (), oOutput);
            }
        }
        oOutput.close ();
    } catch (Exception e) {
        this.problems.add (new InternalError (null, e.getMessage ()));
    }
}


public static ByteBuffer readChannelToBuffer (ReadableByteChannel channel, boolean allocateDirect) throws IOException {
    if (channel == null) {
        String message = Logging.getMessage ("nullValue.ChannelIsNull");
        Logging.logger ().severe (message);
        throw new IllegalArgumentException (message);
    }
    final int PAGE_SIZE = (int) Math.round (Math.pow (2, 16));
    ByteBuffer buffer = WWBufferUtil.newByteBuffer (PAGE_SIZE, allocateDirect);
    int count = 0;
    while (count >= 0) {
        count = channel.read (buffer);
        if (count > 0 && ! buffer.hasRemaining ()) {
            ByteBuffer biggerBuffer = allocateDirect ? ByteBuffer.allocateDirect (buffer.limit () + PAGE_SIZE) : ByteBuffer.allocate (buffer.limit () + PAGE_SIZE);
            biggerBuffer.put ((ByteBuffer) buffer.rewind ());
            buffer = biggerBuffer;
        }
    }
    if (buffer != null) buffer.flip ();
    return buffer;
}


-----Function Pair=122=-----==

public void saveTaskList (StringBuffer output) throws Exception {
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = dbf.newDocumentBuilder ();
    DOMImplementation di = db.getDOMImplementation ();
    Document doc = di.createDocument ("", "tasks", null);
    Element root = doc.getDocumentElement ();
    String [] keys = (String []) tasks.keySet ().toArray (new String [0]);
    for (int x = 0; x < keys.length; x ++) {
        TaskCommand taskData = (TaskCommand) tasks.get (keys [x]);
        taskData.addXML (doc, root);
    }
    ByteArrayOutputStream buff = new ByteArrayOutputStream ();
    TransformerFactory factory = TransformerFactory.newInstance ();
    Transformer transformer = factory.newTransformer ();
    transformer.setOutputProperty (OutputKeys.METHOD, "xml");
    transformer.setOutputProperty (OutputKeys.INDENT, "yes");
    Source source = new DOMSource (doc);
    Result result = new StreamResult (buff);
    transformer.transform (source, result);
    if (output != null) {
        output.append (buff.toString ());
    }
    else {
        FileWriter out = new FileWriter (this.getProperty ("path.data") + File.separator + "Tasks.xml");
        out.write (buff.toString ());
        out.close ();
        System.out.println ("Tasks.xml saved.");
    }
}


public static void zipDir (String dir2zip, ZipOutputStream zos, String inFolder) throws IOException {
    File zipDir = new File (dir2zip);
    String [] dirList = zipDir.list ();
    byte [] readBuffer = new byte [BUFFER];
    int bytesIn = 0;
    for (String dir : dirList) {
        File f = new File (zipDir, dir);
        if (f.isDirectory ()) {
            String filePath = f.getPath ();
            zipDir (filePath, zos, inFolder);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        String fileZipPath = f.getPath ().replace (inFolder, "");
        ZipEntry anEntry = new ZipEntry (fileZipPath);
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            zos.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


-----Function Pair=123=-----==

private byte [] reloadXMLTVdata (HTTPurl urlData, HashMap headers) throws Exception {
    StringBuffer buff1 = new StringBuffer ();
    GuideStore guide = GuideStore.getInstance ();
    guide.loadXMLTV (buff1, 0);
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = dbf.newDocumentBuilder ();
    DOMImplementation di = db.getDOMImplementation ();
    Document doc = di.createDocument ("", "log", null);
    Element root = doc.getDocumentElement ();
    root.setAttribute ("id", "");
    Element logitem = null;
    Element elm = null;
    Text text = null;
    String [] lines = buff1.toString ().split ("\n");
    for (int x = 0; x < lines.length; x ++) {
        logitem = doc.createElement ("logitem");
        elm = doc.createElement ("line");
        text = doc.createTextNode (lines [x]);
        elm.appendChild (text);
        logitem.appendChild (elm);
        root.appendChild (logitem);
    }
    XSL transformer = new XSL (doc, "kb-redo.xsl", urlData, headers);
    return transformer.doTransform ();
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=124=-----==

private breakpoint setBreakpointAtStringClass (JDP_Field stringField) {
    JDP_Class stringClass = new JDP_Class ();
    stringClass.name = stringField.type;
    stringClass.address = stringField.address;
    try {
        user.bmap.classToJDPClass (stringClass.name, stringClass.address, false, stringClass);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    JDP_Field valueField = (JDP_Field) stringClass.fields.elementAt (0);
    String charArrayString = valueField.value;
    charArrayString = charArrayString.substring (1, charArrayString.indexOf ('}'));
    StringTokenizer st = new StringTokenizer (charArrayString, ", ", false);
    StringBuffer ret = new StringBuffer ();
    while (st.hasMoreTokens ()) {
        ret.append (st.nextToken ());
    }
    String className = ret.toString ();
    breakpoint bp = null;
    try {
        bp = user.bmap.findBreakpoint (className + ".main", null, user.reg.hardwareIP ());
    } catch (BmapMultipleException e1) {
        jdp_console.writeOutput (e1.getMessage ());
    } catch (BmapNotFoundException e2) {
        jdp_console.writeOutput (e2.getMessage ());
    }
    user.bpset.setBreakpoint (bp);
    return bp;
}


public void updateGroupPublicKey (Key privateKeyWrappingKey, java.util.Collection < Link > membersToAdd) throws InvalidKeyException, ContentDecodingException, AccessDeniedException, IOException {
    if ((null == membersToAdd) || (membersToAdd.size () == 0)) return;
    if (Log.isLoggable (Log.FAC_ACCESSCONTROL, Level.FINEST)) Log.finest (Log.FAC_ACCESSCONTROL, " {0} Group.updateGroupPublicKey()", _groupNamespace.prefix ());
    PrincipalKeyDirectory privateKeyDirectory = privateKeyDirectory (_groupManager.getAccessManager ());
    PublicKeyObject latestPublicKey = null;
    for (Link lr : membersToAdd) {
        ContentName mlName = lr.targetName ();
        ContentName pkName = null;
        if (_groupManager.getAccessManager ().isGroupName (mlName)) {
            pkName = _groupManager.getAccessManager ().groupPublicKeyName (mlName);
            Link backPointer = new Link (groupName (), friendlyName (), null);
            ContentName bpNamespace = GroupAccessControlProfile.groupPointerToParentGroupName (lr.targetName ());
            LinkObject bplo = new LinkObject (ContentName.fromNative (bpNamespace, friendlyName ()), backPointer, SaveType.REPOSITORY, _handle);
            bplo.save ();
        }
        else {
            pkName = _groupManager.getAccessManager ().userPublicKeyName (mlName);
        }
        latestPublicKey = new PublicKeyObject (pkName, _handle);
        if (! latestPublicKey.available ()) {
            if (Log.isLoggable (Log.FAC_ACCESSCONTROL, Level.WARNING)) {
                Log.warning (Log.FAC_ACCESSCONTROL, "Could not retrieve public key for " + pkName);
            }
            throw new CouldNotRetrievePublicKeyException ();
        }
        try {
            privateKeyDirectory.addWrappedKeyBlock (privateKeyWrappingKey, latestPublicKey.getVersionedName (), latestPublicKey.publicKey ());
        } catch (VersionMissingException e) {
            Log.warningStackTrace (e);
            throw new IOException (e.toString ());
        }
    }
}


-----Function Pair=125=-----==

private byte [] addTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    name = checkName (name);
    String [] keys = tasks.keySet ().toArray (new String [0]);
    for (int x = 0; x < keys.length; x ++) {
        if (name.equalsIgnoreCase (keys [x].toLowerCase ())) {
            String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/" + urlData.getServletClass () + "?action=08\n\n";
            return out.getBytes ();
        }
    }
    if (name != null && name.trim ().length () > 0) {
        TaskCommand taskCommand = new TaskCommand (name.trim ());
        tasks.put (taskCommand.getName (), taskCommand);
        store.saveTaskList (null);
        String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (name.trim (), "UTF-8") + "\n\n";
        return out.getBytes ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    return out.getBytes ();
}


public static String [] parseColumn (File file, int index) {
    ArrayList al = new ArrayList ();
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        String line;
        String [] tokens;
        while ((line = in.readLine ()) != null) {
            tokens = line.split ("\\t");
            if (tokens.length <= index) al.add ("");
            else al.add (tokens [index].trim ());
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        Misc.printExit ("\nError: problem parsing matcher file, aborting.\n");
    }
    String [] col = new String [al.size ()];
    al.toArray (col);
    return col;
}


-----Function Pair=126=-----==

private void compareFile (File fileA, File fileB, boolean skipIdentical, String basePath) {
    String filename = null;
    if (fileB != null) filename = fileB.getPath ();
    else if (fileA != null) filename = fileA.getPath ();
    if (filename != null && basePath != null && filename.startsWith (basePath)) {
        filename = filename.substring (basePath.length ());
        if (filename.startsWith (File.separator)) filename = filename.substring (1);
    }
    updateProgress (filename);
    if (! isFile (fileA)) fileA = null;
    if (! isFile (fileB)) fileB = null;
    examineFiles (fileA, fileB);
    if (skipIdentical && filesAreIdentical) return;
    StringBuffer fileTable;
    String label, htmlName;
    if (fileA == null) {
        fileTable = addedTable;
        label = "Added";
    }
    else if (fileB == null) {
        fileTable = deletedTable;
        label = "Deleted";
    }
    else {
        fileTable = modifiedTable;
        label = "Modified";
    }
    htmlName = HTMLUtils.escapeEntities (filename);
    if (filesAreBinary) {
        fileTable.append ("<tr><td nowrap>").append (htmlName);
        if (fileTable == modifiedTable) fileTable.append ("</td><td></td><td></td><td></td><td>");
        fileTable.append ("</td><td></td><td>Binary</td></tr>\n");
        return;
    }
    String contentsA = getContents (fileA);
    String contentsB = getContents (fileB);
    PSPDiff diff = new PSPDiff (webServer, contentsA, contentsB, filename, null);
    if (skipIdentical && (diff.getDeleted () + diff.getAdded () + diff.getModified () == 0)) return;
    base += diff.getBase ();
    deleted += diff.getDeleted ();
    added += diff.getAdded ();
    modified += diff.getModified ();
    total += diff.getTotal ();
    fileTable.append ("<tr><td nowrap><a href='#file").append (counter).append ("'>").append (htmlName).append ("</a>");
    if (fileTable == deletedTable) fileTable.append ("</td><td>").append (diff.getBase ());
    else if (fileTable == modifiedTable) fileTable.append ("</td><td>").append (diff.getBase ()).append ("</td><td>").append (diff.getDeleted ()).append ("</td><td>").append (diff.getModified ()).append ("</td><td>").append (diff.getAdded ());
    fileTable.append ("</td><td>").append (diff.getTotal ()).append ("</td><td>").append (AbstractLanguageFilter.getFilterName (diff.getFilter ())).append ("</td></tr>\n");
    redlinesOut.print ("<hr><DIV onMouseOver=\"window.defaultStatus='");
    redlinesOut.print (EscapeString.escape (htmlName, '\\', "\""));
    redlinesOut.print ("'\"><h1>");
    redlinesOut.print (label);
    redlinesOut.print (": <a name='file");
    redlinesOut.print (counter ++);
    redlinesOut.print ("'>");
    redlinesOut.print (htmlName);
    redlinesOut.print ("</a></h1>");
    diff.displayHTMLRedlines (redlinesOut);
    redlinesOut.print ("</DIV>\n\n\n");
    diff.dispose ();
}


private byte [] showAutoEpgAddForm (HTTPurl urlData, HashMap headers) throws Exception {
    Vector list = store.getEpgMatchList ();
    EpgMatch epgMatcher = null;
    String index = urlData.getParameter ("index");
    if (index == null) index = "";
    int indexOf = - 1;
    try {
        indexOf = Integer.parseInt (index);
    } catch (Exception e) {
    }
    if (indexOf > - 1 && indexOf < list.size ()) {
        epgMatcher = (EpgMatch) list.get (indexOf);
    }
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = dbf.newDocumentBuilder ();
    DOMImplementation di = db.getDOMImplementation ();
    Document doc = di.createDocument ("", "item_form", null);
    Element root = doc.getDocumentElement ();
    root.setAttribute ("index", new Integer (indexOf).toString ());
    root.setAttribute ("delete", "No");
    Element formEl = null;
    formEl = doc.createElement ("startBuffer");
    formEl.setAttribute ("Name", "Start");
    formEl.setAttribute ("max", "59");
    formEl.setAttribute ("min", "0");
    formEl.setAttribute ("amount", "1");
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", new Integer (epgMatcher.getStartBuffer ()).toString ());
    else formEl.setAttribute ("value", "5");
    root.appendChild (formEl);
    formEl = doc.createElement ("endBuffer");
    formEl.setAttribute ("Name", "End");
    formEl.setAttribute ("max", "400");
    formEl.setAttribute ("min", "0");
    formEl.setAttribute ("amount", "5");
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", new Integer (epgMatcher.getEndBuffer ()).toString ());
    else formEl.setAttribute ("value", "10");
    root.appendChild (formEl);
    formEl = doc.createElement ("referer");
    Text text = doc.createTextNode ("/servlet/KBAutoAddRes");
    formEl.appendChild (text);
    root.appendChild (formEl);
    formEl = doc.createElement ("captureType");
    getCaptureTypes (doc, formEl);
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", new Integer (epgMatcher.getCaptureType ()).toString ());
    else formEl.setAttribute ("value", store.getProperty ("Capture.deftype"));
    root.appendChild (formEl);
    formEl = doc.createElement ("autoDel");
    formEl.setAttribute ("Name", "Auto Delete");
    if (indexOf > - 1 && indexOf < list.size ()) if (epgMatcher.getAutoDel ()) formEl.setAttribute ("value", "True");
    else formEl.setAttribute ("value", "False");
    else formEl.setAttribute ("value", "False");
    root.appendChild (formEl);
    formEl = doc.createElement ("keepfor");
    formEl.setAttribute ("Name", "keep For");
    formEl.setAttribute ("max", "120");
    formEl.setAttribute ("min", "1");
    formEl.setAttribute ("amount", "1");
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", new Integer (epgMatcher.getKeepFor ()).toString ());
    else {
        String keep = store.getProperty ("AutoDel.KeepFor");
        formEl.setAttribute ("value", keep);
    }
    root.appendChild (formEl);
    formEl = doc.createElement ("posttask");
    getTaskList (doc, formEl);
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", epgMatcher.getPostTask ());
    else formEl.setAttribute ("value", "");
    root.appendChild (formEl);
    formEl = doc.createElement ("filenamePatterns");
    getNamePatterns (doc, formEl);
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", epgMatcher.GetFileNamePattern ());
    else formEl.setAttribute ("value", "");
    root.appendChild (formEl);
    formEl = doc.createElement ("capturePaths");
    getCapturePaths (doc, formEl);
    if (indexOf > - 1 && indexOf < list.size ()) formEl.setAttribute ("value", new Integer (epgMatcher.getCapturePathIndex ()).toString ());
    else formEl.setAttribute ("value", "-1");
    root.appendChild (formEl);
    XSL transformer = new XSL (doc, "kb-aa-details.xsl", urlData, headers);
    return transformer.doTransform ();
}


-----Function Pair=127=-----==

private byte [] addTime (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null) {
        Calendar cal = Calendar.getInstance ();
        cal.setTime (item.getStart ());
        int startBuff = 0;
        int endBuff = 0;
        try {
            startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
            endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
        } catch (Exception e) {
        }
        if (item.getState () != ScheduleItem.RUNNING) {
            System.out.println ("Not RUNNING");
            cal.add (Calendar.MINUTE, (startBuff * - 1));
            item.setDuration (item.getDuration () + startBuff + endBuff);
            item.setStart (cal);
        }
        else {
            System.out.println ("RUNNING");
            item.setDuration (item.getDuration () + endBuff);
        }
        store.saveSchedule (null);
    }
    StringBuffer out = new StringBuffer ();
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


public static void zipAllFile (File [] inputFile, ZipOutputStream zipOutputStream) throws IOException {
    byte [] readBuffer = new byte [1024];
    int bytesIn = 0;
    for (int i = 0; i < inputFile.length; i ++) {
        if (inputFile [i].isDirectory ()) {
            zipDirectory (inputFile [i], zipOutputStream);
            continue;
        }
        FileInputStream fileInputStream = new FileInputStream (inputFile [i]);
        ZipEntry zipEntry = new ZipEntry (inputFile [i].getPath ());
        zipOutputStream.putNextEntry (zipEntry);
        while ((bytesIn = fileInputStream.read (readBuffer)) != - 1) {
            zipOutputStream.write (readBuffer, 0, bytesIn);
        }
        fileInputStream.close ();
    }
}


-----Function Pair=128=-----==

private byte [] showCalendar (HTTPurl urlData) throws Exception {
    String id = urlData.getParameter ("id");
    int index = - 1;
    try {
        index = Integer.parseInt (urlData.getParameter ("index"));
    } catch (Exception e) {
    }
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    int month = - 1;
    int year = - 1;
    try {
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "calendar.html");
    template.replaceAll ("$calendar", getCalendarTable (month, year, id, index, urlData));
    return template.getPageBytes ();
}


public void copyFileToFileWithPaths (String sourcePath, String destinPath) throws Exception {
    BufferedInputStream in = null;
    BufferedOutputStream out = null;
    byte dataBuff [] = new byte [bufferSize];
    File file1 = new File (sourcePath);
    if (file1.exists () && (file1.isFile ())) {
        File file2 = new File (destinPath);
        if (file2.exists ()) {
            file2.delete ();
        }
        FileUtils.getInstance ().createDirectory (file2.getParent ());
        in = new BufferedInputStream (new FileInputStream (sourcePath), bufferSize);
        out = new BufferedOutputStream (new FileOutputStream (destinPath), bufferSize);
        int readLen;
        while ((readLen = in.read (dataBuff)) > 0) {
            out.write (dataBuff, 0, readLen);
        }
        out.flush ();
        in.close ();
        out.close ();
    }
    else {
        throw new Exception ("Source file not exist ! sourcePath = (" + sourcePath + ")");
    }
}


-----Function Pair=129=-----==

public static void decompress (final File file, final File folder, final boolean deleteZipAfter) throws IOException {
    final ZipInputStream zis = new ZipInputStream (new BufferedInputStream (new FileInputStream (file.getCanonicalFile ())));
    ZipEntry ze;
    try {
        while (null != (ze = zis.getNextEntry ())) {
            final File f = new File (folder.getCanonicalPath (), ze.getName ());
            if (f.exists ()) f.delete ();
            if (ze.isDirectory ()) {
                f.mkdirs ();
                continue;
            }
            f.getParentFile ().mkdirs ();
            final OutputStream fos = new BufferedOutputStream (new FileOutputStream (f));
            try {
                try {
                    final byte [] buf = new byte [8192];
                    int bytesRead;
                    while (- 1 != (bytesRead = zis.read (buf))) fos.write (buf, 0, bytesRead);
                } finally {
                    fos.close ();
                }
            } catch (final IOException ioe) {
                f.delete ();
                throw ioe;
            }
        }
    } finally {
        zis.close ();
    }
    if (deleteZipAfter) file.delete ();
}


private byte [] showChannels (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (4096);
    HashMap < String, Channel > channels = store.getChannels ();
    String [] keys = (String []) channels.keySet ().toArray (new String [0]);
    Arrays.sort (keys);
    Channel ch = null;
    for (int x = 0; x < keys.length; x ++) {
        ch = (Channel) channels.get (keys [x]);
        String channelName = "";
        try {
            channelName = URLEncoder.encode (keys [x], "UTF-8");
        } catch (Exception e) {
        }
        out.append ("<tr>");
        out.append ("<td nowrap><span class='channelName'>" + keys [x] + "</span></td>");
        out.append ("<td class='channelInfo'>" + ch.getFrequency () + "</td>\n");
        out.append ("<td class='channelInfo'>" + ch.getBandWidth () + "</td>\n");
        out.append ("<td class='channelInfo'>" + ch.getProgramID () + "</td>\n");
        out.append ("<td class='channelInfo'>" + ch.getVideoPid () + "</td>\n");
        out.append ("<td class='channelInfo'>" + ch.getAudioPid ());
        if (ch.getAudioType () == Channel.TYPE_AUDIO_AC3) out.append ("-AC3");
        else out.append ("-MPG");
        out.append ("</td>\n");
        if (ch.getCaptureType () == - 1) {
            out.append ("<td class='channelInfo'>AutoSelect</td>\n");
        }
        else {
            CaptureCapabilities caps = CaptureCapabilities.getInstance ();
            CaptureCapability cap = caps.getCapabiltyWithID (ch.getCaptureType ());
            String capName = "ERROR";
            if (cap != null) capName = caps.getCapabiltyWithID (ch.getCaptureType ()).getName ();
            out.append ("<td class='channelInfo'>" + capName + "</td>\n");
        }
        out.append ("<td class='channelInfo'>");
        out.append (" <a onClick='return confirmAction(\"Delete\");' href='/servlet/" + urlData.getServletClass () + "?action=06&ID=" + channelName + "'>");
        out.append ("<img border=0 src='/images/delete.png' alt='Delete Channel' align='absmiddle' width='24' height='24'>");
        out.append ("</a>");
        out.append (" <a href='/servlet/" + urlData.getServletClass () + "?action=09&ID=" + channelName + "'>");
        out.append ("<img border=0 src='/images/edit.png' alt='Edit Channel' align='absmiddle' width='24' height='24'>");
        out.append ("</a> ");
        out.append ("</td>\n");
        out.append ("<tr>");
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "channels.html");
    template.replaceAll ("$channels", out.toString ());
    return template.getPageBytes ();
}


-----Function Pair=130=-----==

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void testRoundTrip_1 (String resource) throws Exception {
    long start1 = System.currentTimeMillis ();
    File originalFile = File.createTempFile ("RoundTripTest", "testRoundTrip_1");
    FileOutputStream fos = new FileOutputStream (originalFile);
    IOUtils.copy (getClass ().getResourceAsStream (resource), fos);
    fos.close ();
    long start2 = System.currentTimeMillis ();
    IsoFile isoFile = new IsoFile (new FileInputStream (originalFile).getChannel ());
    long start3 = System.currentTimeMillis ();
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    WritableByteChannel wbc = Channels.newChannel (baos);
    long start4 = System.currentTimeMillis ();
    Walk.through (isoFile);
    long start5 = System.currentTimeMillis ();
    isoFile.getBox (wbc);
    wbc.close ();
    long start6 = System.currentTimeMillis ();
    System.err.println ("Preparing tmp copy took: " + (start2 - start1) + "ms");
    System.err.println ("Parsing took           : " + (start3 - start2) + "ms");
    System.err.println ("Writing took           : " + (start6 - start3) + "ms");
    System.err.println ("Walking took           : " + (start5 - start4) + "ms");
    byte [] a = IOUtils.toByteArray (getClass ().getResourceAsStream (resource));
    byte [] b = baos.toByteArray ();
    Assert.assertArrayEquals (a, b);
}


-----Function Pair=131=-----==

public void startUpdater (String fileName, String parameter) {
    try {
        log.info ("Updating Updater");
        URL fileUrl = new URL ("http://ossobook.svn.sourceforge.net/svnroot/ossobook/trunk/update/" + fileName);
        URLConnection filecon = fileUrl.openConnection ();
        ReadableByteChannel rbc = Channels.newChannel (fileUrl.openStream ());
        File testFile = new File (fileName);
        int size = filecon.getContentLength ();
        if (testFile.length () == size) {
        }
        else {
            FileOutputStream fos = new FileOutputStream (fileName);
            fos.getChannel ().transferFrom (rbc, 0, 1 << 24);
            fos.close ();
        }
        Runtime.getRuntime ().exec (new String [] {"java", "-jar", fileName, parameter});
        System.exit (0);
    } catch (IOException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
    }
}


public void createNewFile (InputStream is, String folderPath, String filename) {
    File path = new File (folderPath);
    if (! path.exists ()) {
        try {
            path.mkdirs ();
        } catch (Exception e) {
            logger.error ("Can't create directory...:" + path);
        }
    }
    String filepath = path + separator () + filename;
    File file = new File (filepath);
    FileOutputStream os = null;
    try {
        file.createNewFile ();
        os = new FileOutputStream (filepath);
        int c;
        while ((c = is.read ()) != - 1) {
            os.write (c);
        }
    } catch (IOException e) {
        logger.error (e, e);
    } finally {
        if (os != null) {
            try {
                os.flush ();
                os.close ();
            } catch (Throwable e) {
            }
        }
    }
}


-----Function Pair=132=-----==

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void rotate (File file, int angel) {
    BufferedImage i = null;
    IIOMetadata imeta = null;
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (file);
        ImageReader reader = ImageIO.getImageReadersByFormatName ("jpg").next ();
        reader.setInput (iis, true);
        ImageReadParam params = reader.getDefaultReadParam ();
        i = reader.read (0, params);
        imeta = reader.getImageMetadata (0);
    } catch (IOException e) {
        System.err.println ("Error while reading File: " + file.getAbsolutePath ());
        e.printStackTrace ();
        return;
    }
    try {
        int w = i.getWidth (null);
        int h = i.getHeight (null);
        rotateImage (i, 90);
        System.out.println ("Width: " + w + " Height :" + h);
        System.out.println ("Drehe Bild:" + file.getAbsolutePath ());
        i = rotateImage (i, angel);
        FileOutputStream fos = new FileOutputStream (file);
        ImageWriter writer = ImageIO.getImageWritersByFormatName ("jpg").next ();
        ImageOutputStream ios = ImageIO.createImageOutputStream (fos);
        writer.setOutput (ios);
        ImageWriteParam iwparam = new JPEGImageWriteParam (Locale.getDefault ());
        iwparam.setCompressionMode (ImageWriteParam.MODE_COPY_FROM_METADATA);
        iwparam.setCompressionQuality (0.92f);
        writer.write (imeta, new IIOImage (i, null, null), iwparam);
        ios.flush ();
        writer.dispose ();
        ios.close ();
        fos.close ();
        System.out.println ("Bild gespeichert!");
    } catch (Exception l) {
        m.error = true;
    }
}


-----Function Pair=133=-----==

public BufferedWriter createOutputStream (String inFile, String outFile) throws IOException {
    int k_blockSize = 1024;
    int byteCount;
    char [] buf = new char [k_blockSize];
    File ofp = new File (outFile);
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (ofp));
    zos.setMethod (ZipOutputStream.DEFLATED);
    OutputStreamWriter osw = new OutputStreamWriter (zos, "ISO-8859-1");
    BufferedWriter bw = new BufferedWriter (osw);
    ZipEntry zot = null;
    File ifp = new File (inFile);
    ZipInputStream zis = new ZipInputStream (new FileInputStream (ifp));
    InputStreamReader isr = new InputStreamReader (zis, "ISO-8859-1");
    BufferedReader br = new BufferedReader (isr);
    ZipEntry zit = null;
    while ((zit = zis.getNextEntry ()) != null) {
        if (zit.getName ().equals ("content.xml")) {
            continue;
        }
        zot = new ZipEntry (zit.getName ());
        zos.putNextEntry (zot);
        while ((byteCount = br.read (buf, 0, k_blockSize)) >= 0) bw.write (buf, 0, byteCount);
        bw.flush ();
        zos.closeEntry ();
    }
    zos.putNextEntry (new ZipEntry ("content.xml"));
    bw.flush ();
    osw = new OutputStreamWriter (zos, "UTF8");
    bw = new BufferedWriter (osw);
    return bw;
}


public static synchronized String createWebStartFile (HttpServletRequest req, String SRBFilename, String workingDir, String contextPath) throws UnknownHostException {
    ServletRequest sreq = (ServletRequest) req;
    File file = new File (workingDir + File.separator + "web-start" + File.separator + "webstart_template.jnlp");
    File webStartDir = new File (workingDir + File.separator + "web-start" + File.separator + createDate ());
    if (! webStartDir.exists ()) webStartDir.mkdir ();
    String filename = "" + Math.random () + ".jnlp";
    File webStartFile = new File (webStartDir, filename);
    BufferedReader in = null;
    BufferedWriter out = null;
    InetAddress host = InetAddress.getLocalHost ();
    String hostURL = sreq.getScheme () + "://" + host.getHostAddress () + ":" + sreq.getServerPort () + contextPath + "/web-start/" + createDate ();
    try {
        in = new BufferedReader (new FileReader (file));
        out = new BufferedWriter (new FileWriter (webStartFile));
        String str;
        while ((str = in.readLine ()) != null) {
            if (str.trim ().startsWith ("codebase")) {
                out.write ("codebase=\"" + hostURL + "\"\n");
            }
            else if (str.trim ().startsWith ("href")) {
                out.write ("href=\"" + filename + "\">\n");
            }
            else if (str.trim ().startsWith ("<application-desc")) {
                out.write (str);
                out.write ("\n<argument>" + hostURL + "/" + SRBFilename + "</argument>\n");
                out.write ("</application-desc>\n");
                out.write ("</jnlp>");
                break;
            }
            else out.write (str + "\n");
        }
    } catch (IOException e) {
        System.out.println (e);
    } finally {
        try {
            in.close ();
            out.close ();
            File dir = new File (workingDir + File.separator + "web-start");
            File [] webStartDatefiles = dir.listFiles ();
            for (File Sfile : webStartDatefiles) {
                log.trace ("File: " + Sfile.getAbsolutePath ());
                if (Sfile.isDirectory ()) {
                    if (! Sfile.getName ().equals (createDate ())) {
                        log.trace ("Deleting");
                        deleteDirectory (Sfile);
                    }
                    else log.trace ("Not deleting");
                }
            }
        } catch (IOException ex) {
            log.warn ("Error closing buffers", ex);
        }
    }
    return filename;
}


-----Function Pair=134=-----==

private void addToJar (JarOutputStream out, InputStream in, String entryName, long length) throws IOException {
    byte [] buf = new byte [2048];
    ZipEntry entry = new ZipEntry (entryName);
    CRC32 crc = new CRC32 ();
    entry.setSize (length);
    entry.setCrc (crc.getValue ());
    out.putNextEntry (entry);
    int read = in.read (buf);
    while (read > 0) {
        crc.update (buf, 0, read);
        out.write (buf, 0, read);
        read = in.read (buf);
    }
    entry.setCrc (crc.getValue ());
    in.close ();
    out.closeEntry ();
}


private void implantSelf () throws IOException {
    InputStream manifest = getClass ().getClassLoader ().getResourceAsStream ("META-INF/manifest.mf");
    log ("my classloader is " + getClass ().getClassLoader ().getClass ().getName ());
    ClassLoader loader = getClass ().getClassLoader ();
    if (manifest == null || loader == null || (loader.getClass ().getName ().indexOf ("Applet") == - 1 && loader.getClass ().getName ().indexOf ("Plugin") == - 1)) return;
    BufferedReader br = new BufferedReader (new InputStreamReader (manifest));
    Vector entries = new Vector ();
    String s = null;
    while ((s = br.readLine ()) != null) if (s.startsWith ("Name: ")) entries.addElement (s.substring (6));
    String ext_dirs = System.getProperty ("java.ext.dirs");
    log ("java.ext.dirs = " + ext_dirs);
    ext_dirs = ext_dirs + File.pathSeparatorChar + System.getProperty ("user.home") + File.separatorChar + ".vexi";
    StringTokenizer st = new StringTokenizer (ext_dirs, File.pathSeparatorChar + "");
    while (st.hasMoreTokens ()) {
        String dir = st.nextToken ();
        new File (dir).mkdirs ();
        try {
            if (! st.hasMoreTokens ()) modifyPolicyFile ();
            implantInDirectory (dir, entries);
            return;
        } catch (IOException e) {
            log ("Failed to implant in " + dir + " due to " + e);
        }
    }
    log ("Failed to implant self!");
}


-----Function Pair=135=-----==

private void copyInternalToJar (JarOutputStream out, String [] JAR_FILES) throws IOException {
    for (int i = 0; i < JAR_FILES.length; i ++) {
        String sourceName = JAR_FILES [i];
        if (sourceName.endsWith (".jar")) {
            copyJarFilesToJar (out, sourceName);
        }
        else {
            InputStream is = getClass ().getResourceAsStream ("/" + sourceName);
            if (is == null) {
                System.out.println ("Cannot add the resource " + sourceName + " to the jar, since it cannot be found (bummer!)");
            }
            else {
                addToJar (out, is, sourceName, is.available ());
            }
        }
    }
}


public void saveTemplateData (String templateId, InputStream stream, String contentType) {
    logger.debug ("saveTemplateData(%s, %s, %s)", templateId, stream, contentType);
    Connection connection = null;
    NamedParameterStatement statement = null;
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.INSERT_TEMPLATE_DATA));
        statement.setString (QueryStore.INSERT_TEMPLATE_DATA_PARAM_ID_TEMPLATE, templateId);
        statement.setBinaryStream (QueryStore.INSERT_TEMPLATE_DATA_PARAM_DATA, stream);
        statement.setString (QueryStore.INSERT_TEMPLATE_DATA_PARAM_CONTENT_TYPE, contentType);
        statement.executeUpdate ();
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (statement);
        close (connection);
    }
}


-----Function Pair=136=-----==

private String addScript (LineNumberReader files, Vector scripts) throws IOException {
    String destName = null;
    int blocLineNbr = files.getLineNumber ();
    String line = files.readLine ();
    String cmd = null;
    Hashtable keywords = new Hashtable ();
    if (line != null) cmd = line.trim ();
    System.out.println ("  script: " + cmd);
    line = files.readLine ();
    while ((line != null) && (! line.trim ().equals ("}"))) {
        line = line.trim ();
        int ind = line.indexOf ('=');
        if ((ind > 0) && ((ind + 1) < line.length ())) {
            keywords.put (line.substring (0, ind), line.substring (ind + 1));
        }
        line = files.readLine ();
    }
    if ((cmd == null) || (line == null)) throw new IOException ("Unterminated script bloc : line " + blocLineNbr);
    if (cmd.equals ("JavaLauncher")) {
        String k = (String) keywords.get ("Class");
        if (k == null) throw new IOException ("Invalid script bloc : line " + blocLineNbr + " (no Class)");
        System.out.println ("    Class=" + k);
    }
    else if (cmd.equals ("JarLauncher")) {
        String k = (String) keywords.get ("Jar");
        if (k != null) {
            System.out.println ("    Jar=" + k);
        }
        else throw new IOException ("Invalid script bloc : line " + blocLineNbr + " (no Jar)");
    }
    else {
        throw new IOException ("Unsupported script : line " + blocLineNbr + " (" + cmd + ")");
    }
    String k = (String) keywords.get ("ScriptName");
    if (k != null) {
        System.out.println ("    ScriptName=" + k);
        destName = k;
    }
    else throw new IOException ("Invalid script bloc : line " + blocLineNbr + " (no ScriptName)");
    String lineSep = "\n";
    StringBuffer buf = new StringBuffer ();
    buf.append ("CMD").append (lineSep).append (cmd);
    for (Iterator it = keywords.entrySet ().iterator (); it.hasNext ();) {
        Map.Entry e = (Map.Entry) it.next ();
        if (e.getValue () != null) {
            buf.append (lineSep).append ((String) e.getKey ()).append (lineSep).append ((String) e.getValue ());
        }
    }
    if (buf.length () > 0) scripts.add (buf.toString ());
    return destName;
}


public void open (String path) {
    beginOperation ();
    getDocument ().removeUndoableEditListener (this);
    getDocument ().removeDocumentListener (this);
    clean ();
    discard ();
    InputStream is;
    StringBuffer buffer = new StringBuffer ();
    try {
        File toLoad = new File (path);
        if (! toLoad.canWrite ()) setEditable (false);
        else if (! isEditable ()) setEditable (true);
        is = new FileInputStream (toLoad);
        InputStreamReader in = new InputStreamReader (is);
        char [] buf = new char [BUFFER_SIZE];
        int len;
        boolean lastWasCR = false;
        while ((len = in.read (buf, 0, buf.length)) != - 1) {
            int lastLine = 0;
            for (int i = 0; i < len; i ++) {
                switch (buf [i]) {
                    case '\r' :
                        if (lastWasCR) {
                        }
                        else lastWasCR = true;
                        buffer.append (buf, lastLine, i - lastLine);
                        buffer.append ('\n');
                        lastLine = i + 1;
                        break;
                    case '\n' :
                        if (lastWasCR) {
                            lastWasCR = false;
                            lastLine = i + 1;
                        }
                        else {
                            buffer.append (buf, lastLine, i - lastLine);
                            buffer.append ('\n');
                            lastLine = i + 1;
                        }
                        break;
                    default :
                        if (lastWasCR) {
                            lastWasCR = false;
                        }
                        break;
                }
            }
            buffer.append (buf, lastLine, len - lastLine);
        }
        in.close ();
        if (buffer.length () != 0 && buffer.charAt (buffer.length () - 1) == '\n') buffer.setLength (buffer.length () - 1);
        getDocument ().remove (0, getLength ());
        getDocument ().insertString (0, buffer.toString (), null);
        currentFile = path;
        setCaretPosition (0);
        newText = false;
        getDocument ().addUndoableEditListener (this);
        getDocument ().addDocumentListener (this);
    } catch (BadLocationException bl) {
        FuLog.error (bl);
    } catch (FileNotFoundException fnf) {
        showError (path + " not found !");
    } catch (IOException io) {
        showError (io.toString ());
    }
    endOperation ();
}


-----Function Pair=137=-----==

public static void unzip (String strZipFile, String folder) throws IOException {
    try {
        FileUtil.fileExists (strZipFile, true);
        File fSourceZip = new File (strZipFile);
        File zipPath = new File (folder);
        ZipFile zipFile = new ZipFile (fSourceZip);
        Enumeration e = zipFile.entries ();
        while (e.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) e.nextElement ();
            File destinationFilePath = new File (zipPath, entry.getName ());
            destinationFilePath.getParentFile ().mkdirs ();
            if (entry.isDirectory ()) {
                continue;
            }
            else {
                System.out.println ("Extracting " + destinationFilePath);
                BufferedInputStream bis = new BufferedInputStream (zipFile.getInputStream (entry));
                int b;
                byte buffer [] = new byte [1024];
                FileOutputStream fos = new FileOutputStream (destinationFilePath);
                BufferedOutputStream bos = new BufferedOutputStream (fos, 1024);
                while ((b = bis.read (buffer, 0, 1024)) != - 1) {
                    bos.write (buffer, 0, b);
                }
                bos.flush ();
                bos.close ();
                bis.close ();
            }
        }
    } catch (IOException ioe) {
        System.out.println ("IOError :" + ioe);
        throw ioe;
    }
}


public void testRoundTrip_1 (String resource) throws Exception {
    long start1 = System.currentTimeMillis ();
    File originalFile = File.createTempFile ("RoundTripTest", "testRoundTrip_1");
    FileOutputStream fos = new FileOutputStream (originalFile);
    IOUtils.copy (getClass ().getResourceAsStream (resource), fos);
    fos.close ();
    long start2 = System.currentTimeMillis ();
    IsoFile isoFile = new IsoFile (new FileInputStream (originalFile).getChannel ());
    long start3 = System.currentTimeMillis ();
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    WritableByteChannel wbc = Channels.newChannel (baos);
    long start4 = System.currentTimeMillis ();
    Walk.through (isoFile);
    long start5 = System.currentTimeMillis ();
    isoFile.getBox (wbc);
    wbc.close ();
    long start6 = System.currentTimeMillis ();
    System.err.println ("Preparing tmp copy took: " + (start2 - start1) + "ms");
    System.err.println ("Parsing took           : " + (start3 - start2) + "ms");
    System.err.println ("Writing took           : " + (start6 - start3) + "ms");
    System.err.println ("Walking took           : " + (start5 - start4) + "ms");
    byte [] a = IOUtils.toByteArray (getClass ().getResourceAsStream (resource));
    byte [] b = baos.toByteArray ();
    Assert.assertArrayEquals (a, b);
}


-----Function Pair=138=-----==

public long getFilesFromStreamOnlyRootFiles (InputStream in, String FilesDirStr, Hashtable newNamesTable) throws Exception {
    long plussQuotaSize = 0;
    if (! FilesDirStr.endsWith (sep)) {
        FilesDirStr += sep;
    }
    if (null == newNamesTable) {
        newNamesTable = new Hashtable ();
    }
    FileUtils.getInstance ().createDirectory (FilesDirStr);
    ZipInputStream zin = null;
    zin = new ZipInputStream (new BufferedInputStream (in));
    BufferedOutputStream out = null;
    ZipEntry zipEntry = null;
    while ((zipEntry = zin.getNextEntry ()) != null) {
        if (! zipEntry.isDirectory ()) {
            String zipEntryName = zipEntry.getName ();
            String oldName = zipEntryName;
            String newName = oldName;
            String newFileName = FilesDirStr + newName;
            if (newNamesTable.containsKey (oldName)) {
                newName = (String) newNamesTable.get (oldName);
                if ((newName != null) && (! "".equals (newName))) {
                    newFileName = FilesDirStr + newName;
                }
                else {
                    newName = oldName;
                }
            }
            boolean rootFile = true;
            if (new File (zipEntryName).getParentFile () != null) {
                rootFile = false;
            }
            File newFile = new File (newFileName);
            if (rootFile) {
                FileUtils.getInstance ().createDirectory (newFile.getParent ());
                if (newFile.exists ()) {
                    plussQuotaSize -= newFile.length ();
                    newFile.delete ();
                }
                out = new BufferedOutputStream (new FileOutputStream (newFile), bufferSize);
                int readLen;
                byte dataBuff [] = new byte [bufferSize];
                while ((readLen = zin.read (dataBuff)) > 0) {
                    out.write (dataBuff, 0, readLen);
                    plussQuotaSize += readLen;
                }
                out.flush ();
                out.close ();
            }
            else {
                byte dataBuff [] = new byte [bufferSize];
                while ((zin.read (dataBuff)) > 0) {
                }
            }
        }
    }
    zin.close ();
    return plussQuotaSize;
}


private byte [] updateChannel (HTTPurl urlData) throws Exception {
    int freq = 0;
    int band = 0;
    int progID = - 1;
    int videoid = - 1;
    int audioid = - 1;
    int audioType = - 1;
    int capType = - 1;
    String name = "";
    String oldName = urlData.getParameter ("oldName");
    name = urlData.getParameter ("name");
    if (name == null) name = "none";
    name = name.trim ();
    name = checkName (name);
    GuideStore guide = GuideStore.getInstance ();
    try {
        freq = Integer.parseInt (urlData.getParameter ("freq").trim ());
        band = Integer.parseInt (urlData.getParameter ("band").trim ());
        progID = Integer.parseInt (urlData.getParameter ("programid").trim ());
        videoid = Integer.parseInt (urlData.getParameter ("videoid").trim ());
        audioid = Integer.parseInt (urlData.getParameter ("audioid").trim ());
        audioType = Integer.parseInt (urlData.getParameter ("audioType").trim ());
        capType = Integer.parseInt (urlData.getParameter ("captureType").trim ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (progID > - 1) {
        Channel chan = new Channel (name, freq, band, progID, videoid, audioid);
        chan.setAudioType (audioType);
        chan.setCaptureType (capType);
        store.removeChannel (oldName);
        store.addChannel (chan);
        boolean save = false;
        Vector chanMap = guide.getChannelMap ();
        for (int x = 0; x < chanMap.size (); x ++) {
            String [] map = (String []) chanMap.get (x);
            if (map [0].equals (oldName)) {
                map [0] = name;
                save = true;
            }
        }
        if (save) guide.saveChannelMap (null);
    }
    store.saveChannels (null);
    StringBuffer out = new StringBuffer (256);
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: /servlet/" + urlData.getServletClass () + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=139=-----==

private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


public BufferedImage rotateImage (BufferedImage image, double rotate) {
    if (rotate == 0) return image;
    AffineTransform transform = new AffineTransform ();
    int width = image.getWidth (null);
    int height = image.getHeight (null);
    if (rotate == Generator.ROTATE_90) {
        transform.translate (height, 0);
        transform.rotate (Generator.ROTATE_90);
        width = image.getHeight ();
        height = image.getWidth ();
    }
    else if (rotate == Generator.ROTATE_270) {
        transform.translate (0, width);
        transform.rotate (Generator.ROTATE_270);
        width = image.getHeight (null);
        height = image.getWidth (null);
    }
    else {
        throw new IllegalArgumentException ("degree must be a mutiple of 90�!");
    }
    BufferedImage returnImage = new BufferedImage (width, height, image.getColorModel ().getColorSpace ().getType ());
    Graphics2D g = returnImage.createGraphics ();
    g.drawImage (image, transform, null);
    return returnImage;
}


-----Function Pair=140=-----==

private int numOverlaps (ScheduleItem schItem, StringBuffer buff) {
    DataStore store = DataStore.getInstance ();
    Vector < ScheduleItem > overlapping = new Vector < ScheduleItem > ();
    SimpleDateFormat df = new SimpleDateFormat ("EE d HH:mm");
    ScheduleItem [] itemsArray = store.getScheduleArray ();
    for (int x = 0; x < itemsArray.length; x ++) {
        ScheduleItem item = itemsArray [x];
        if (item.isOverlapping (schItem)) {
            overlapping.add (item);
            buff.append (item.getName () + " (" + df.format (item.getStart ()));
            buff.append (" " + item.getDuration () + " ");
            buff.append (item.getChannel () + ")<br>\n");
        }
    }
    if (overlapping.size () == 0) return 1;
    int overlapCount = getOverlapCount (schItem, overlapping);
    return overlapCount;
}


private int reindexTags (int count, Map < String, List < String > > tags, Folder root) throws IOException {
    List < Media > images = root.getMediaList ();
    for (Media i : images) {
        List < String > t = i.getTagsForIndex ();
        if (t != null) {
            for (String tag : t) {
                tag = tag.trim ().toLowerCase ();
                if (tag.length () > 0) {
                    List < String > taglist = tags.get (tag);
                    if (taglist == null) {
                        taglist = new ArrayList < String > ();
                        tags.put (tag, taglist);
                    }
                    taglist.add (String.valueOf (getImageIndex (i.getFile ().getAbsolutePath ())));
                }
            }
        }
        count ++;
        if (count % 1 == 0) {
            Utils.TAGS_REINDEX_STATUS [0] = theme.getLabel ("label.tags.reindexInProgress", count, (System.currentTimeMillis () - startTime) / 1000);
        }
    }
    List < Folder > folders = root.getFolders (false);
    for (Folder f : folders) {
        count = reindexTags (count, tags, f);
    }
    return count;
}


-----Function Pair=141=-----==

private String getResourcesForGrid (String aUserName, String aGridName, boolean isMonitored) {
    String returnStr = "";
    try {
        SZGJobManagerConfiguration [] resources;
        resources = this.getResourceConfigsForGrid (aUserName, aGridName, isMonitored);
        String line;
        if (resources != null && resources.length > 0) {
            for (int i = 0; i < resources.length; i ++) {
                line = resources [i].getContactString () + ";" + resources [i].getJobManager () + ";" + resources [i].isMonitorable () + "\n";
                returnStr += line;
            }
            this.printlnLog (this.getClass ().getName () + ".getResourcesForGrid()", "Status: Success.");
        }
        else {
            returnStr = "Error;No resource found for '" + aGridName + "'.";
            this.printlnLog (this.getClass ().getName () + ".getResourcesForGrid()", "Error: No resource.");
        }
    } catch (Exception ex) {
        returnStr = "Error;No resource for grid.";
        this.printlnLog (this.getClass ().getName () + ".getResourcesForGrid()", "Exception was catched: " + ex.getMessage ());
        ex.printStackTrace ();
    }
    return returnStr;
}


public ByteArray zip (Value request) throws FaultException {
    ByteArrayOutputStream bbstream = new ByteArrayOutputStream ();
    try {
        ZipOutputStream zipStream = new ZipOutputStream (bbstream);
        ZipEntry zipEntry;
        byte [] bb;
        for (Entry < String, ValueVector > entry : request.children ().entrySet ()) {
            zipEntry = new ZipEntry (entry.getKey ());
            zipStream.putNextEntry (zipEntry);
            bb = entry.getValue ().first ().byteArrayValue ().getBytes ();
            zipStream.write (bb, 0, bb.length);
            zipStream.closeEntry ();
        }
        zipStream.close ();
    } catch (IOException e) {
        throw new FaultException (e);
    }
    return new ByteArray (bbstream.toByteArray ());
}


-----Function Pair=142=-----==

public void process (Buffer buffer) throws IOException {
    if (! isReady) {
        buffer.setDiscard (true);
        return;
    }
    byte [] data = buffer.getData ();
    if (data == null) {
        data = new byte [frameSize];
    }
    buffer.setData (data);
    int len = readPacket (data, 0, frameSize);
    if (len == 0) {
        eom = true;
    }
    if (len < frameSize) {
        padding (data, frameSize - len);
        eom = true;
    }
    buffer.setOffset (0);
    buffer.setLength (frameSize);
    buffer.setEOM (eom);
    buffer.setDuration (20);
}


public static boolean copyDir (File srcDir, File dstDir) throws IOException {
    if (srcDir.isDirectory ()) {
        log.debug (srcDir.getAbsolutePath () + " is directory");
        if (! dstDir.exists ()) {
            log.debug (dstDir.getAbsolutePath () + " does not exist, so create it");
            if (! dstDir.mkdirs ()) {
                throw new IOException ("Can't create " + dstDir.getName ());
            }
        }
        String [] files = srcDir.list ();
        log.debug ("Copy " + files.length + " files.");
        for (int i = 0; i < files.length; i ++) {
            if (copyDir (new File (srcDir, files [i]), new File (dstDir, files [i])) == false) {
                return false;
            }
        }
        return true;
    }
    log.debug (srcDir.getAbsolutePath () + " is NOT directory");
    return copyFile (srcDir, dstDir);
}


-----Function Pair=143=-----==

private byte [] addTime (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null) {
        Calendar cal = Calendar.getInstance ();
        cal.setTime (item.getStart ());
        int startBuff = 0;
        int endBuff = 0;
        int endBuffEpg = 0;
        try {
            startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
            endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
            endBuffEpg = Integer.parseInt (store.getProperty ("schedule.buffer.end.epg"));
        } catch (Exception e) {
        }
        if (endBuffEpg > 0) {
            endBuffEpg = endBuffEpg * (int) (item.getDuration () / 60);
        }
        if (item.getState () != ScheduleItem.RUNNING) {
            System.out.println ("Not RUNNING");
            cal.add (Calendar.MINUTE, (startBuff * - 1));
            item.setDuration (item.getDuration () + startBuff + endBuff + endBuffEpg);
            item.setStart (cal);
        }
        else {
            System.out.println ("RUNNING");
            item.setDuration (item.getDuration () + endBuff + endBuffEpg);
        }
        store.saveSchedule (null);
    }
    StringBuffer out = new StringBuffer ();
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


public File createContentPackage () throws IOException {
    File dir = createTempDir ("constructr", null);
    int scount = 0;
    for (SectionModel sm : sections) {
        int icount = 0;
        for (ItemModel im : sm.items) {
            ContentPackage icp = im.item.resolveItem ();
            icp.unpack (new File (dir.toString () + File.separator + "S" + scount + "I" + icount));
            File [] items = icp.getItems ();
            if (items.length != 1) {
                System.err.println ("Error: invalid item content package - more than one item!");
                System.err.println (items);
                System.err.println (items.length);
                System.err.println (icp.getManifest ());
                return null;
            }
            im.itempath = items [0].getAbsolutePath ().replace (dir.getAbsolutePath (), "");
            if (im.itempath.startsWith (File.separator)) im.itempath = im.itempath.substring (1);
            System.out.println (im.itempath);
            icount ++;
        }
        scount ++;
    }
    System.out.println ("Temp CP dir: " + dir);
    FileWriter fw = new FileWriter (new File (dir.toString () + File.separator + "assessment.xml"));
    fw.write (convertToQTI ().toXmlString ());
    fw.close ();
    fw = new FileWriter (new File (dir.toString () + File.separator + "imsmanifest.xml"));
    fw.write ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fw.write ("<manifest xmlns=\"http://www.imsglobal.org/xsd/imscp_v1p1\" " + "identifier=\"" + java.util.UUID.randomUUID () + "\" >\n");
    fw.write ("\t<resources>\n");
    fw.write ("\t\t<resource identifier=\"RES-" + java.util.UUID.randomUUID () + "\" type=\"imsqti_test_xmlv2p1\" href=\"assessment.xml\" />\n");
    for (SectionModel sm : sections) {
        for (ItemModel im : sm.items) {
            fw.write ("\t\t<resource identifier=\"RES-" + java.util.UUID.randomUUID () + "\" type=\"imsqti_item_xmlv2p0\" href=\"" + im.itempath + "\" />\n");
        }
    }
    fw.write ("\t</resources>\n");
    fw.write ("</manifest>\n");
    fw.close ();
    File zipfile = new File (dir.toString () + ".zip");
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipfile));
    zipDir (dir, zos, dir);
    zos.close ();
    delete (dir);
    return zipfile;
}


-----Function Pair=144=-----==

private void showInfoDownloadPageArchive (HTTPurl urlData, OutputStream outStream) throws Exception {
    ScheduleItem item = null;
    try {
        File archivePath = new File (new DllWrapper ().getAllUserPath () + "archive" + File.separator + urlData.getParameter ("file"));
        FileInputStream in = new FileInputStream (archivePath);
        ObjectInputStream oin = new ObjectInputStream (in);
        item = (ScheduleItem) oin.readObject ();
        oin.close ();
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (item == null) {
        String redirect = "HTTP/1.0 302 Moved Temporarily\n";
        redirect += "Location: /servlet/ScheduleDataRes\n\n";
        outStream.write (redirect.getBytes ());
        return;
    }
    buildInfoZip (item, outStream);
    return;
}


public void concatFiles (final File directory, final File out) throws IOException {
    final String LINE_SEPARATOR = System.getProperty ("line.separator");
    OutputStream os = null;
    try {
        os = new BufferedOutputStream (new FileOutputStream (out, true));
        final File [] in = directory.listFiles ();
        for (int i = 0; i < in.length; i ++) {
            InputStream is = null;
            try {
                is = new FileInputStream (in [i]);
                new StreamReader (is, os).read ();
                os.write (LINE_SEPARATOR.getBytes (Charset.defaultCharset ()));
            } finally {
                if (is != null) {
                    is.close ();
                }
            }
        }
    } finally {
        if (os != null) {
            os.close ();
        }
    }
}


-----Function Pair=145=-----==

public static boolean copy (File from, File to) {
    if (from.isDirectory ()) {
        String [] contents = from.list ();
        for (int i = 0; contents != null && i < contents.length; i ++) {
            copy (from, to, contents [i]);
        }
    }
    else {
        try {
            OutputStream os = makeFile (to);
            InputStream is = new FileInputStream (from);
            pipe (is, os, false);
            is.close ();
            os.close ();
        } catch (IOException ex) {
            return false;
        }
    }
    long time = from.lastModified ();
    if (! to.setLastModified (time)) {
        return false;
    }
    long newtime = to.lastModified ();
    return time == newtime;
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=146=-----==

public byte [] showArchive (HTTPurl urlData, OutputStream outStream) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "ArchiveList.html");
    StringBuffer buff = new StringBuffer ();
    File outFile = new File (new DllWrapper ().getAllUserPath () + "archive");
    if (outFile.exists () == false) outFile.mkdirs ();
    File [] files = outFile.listFiles ();
    Arrays.sort (files);
    for (int x = files.length - 1; files != null && x >= 0; x --) {
        File archiveFile = files [x];
        if (archiveFile.isDirectory () == false && archiveFile.getName ().startsWith ("Schedule-")) {
            buff.append ("<tr>\n");
            buff.append ("<td><a class='noUnder' href='/servlet/ArchiveDataRes?action=showItemInfo&file=" + URLEncoder.encode (archiveFile.getCanonicalPath (), "UTF-8") + "'>" + archiveFile.getName () + "</a></td>\n");
            buff.append ("</tr>\n");
        }
    }
    template.replaceAll ("$ArchiveList", buff.toString ());
    return template.getPageBytes ();
}


public boolean requestNewTime (int time, TimePreference searchDirection) throws RemoteException {
    int lastTime = - 1;
    int foundTime = - 1;
    for (Integer timestep : this.timesteps.keySet ()) {
        if (searchDirection == TimePreference.EARLIER) {
            if (timestep >= time) {
                foundTime = lastTime;
                break;
            }
        }
        else {
            if (timestep >= time) {
                foundTime = timestep;
                break;
            }
        }
        lastTime = timestep;
    }
    if (foundTime == - 1) return false;
    this.nextTime = foundTime;
    this.actBuffer = null;
    return true;
}


-----Function Pair=147=-----==

private void completeNick () {
    char [] text = entry.getText ().toCharArray ();
    int pos = entry.getCaretPosition ();
    int begin = pos - 1;
    int end = pos;
    Collator collator = RFC1459.getCollator ();
    String [] list = nick_list.getNicks ();
    for (int i = 0; i < list.length; i ++) {
        for (int j = list.length - 1; j > i; j --) {
            if (collator.compare (list [i], list [j]) > 0) {
                String t = list [i];
                list [i] = list [j];
                list [j] = t;
            }
        }
    }
    while (begin >= 0 && RFC1459.isDeclaredChar (text [begin])) begin --;
    while (end < text.length && RFC1459.isDeclaredChar (text [end])) end ++;
    begin ++;
    if (complete_current.length () == 0) {
        complete_partial = String.valueOf (text, begin, end - begin);
    }
    int partial_length = complete_partial.length ();
    int first_match = - 1;
    boolean found = false;
    for (int i = 0; i < list.length; i ++) {
        if (list [i].length () < partial_length) {
            continue;
        }
        String partial_nick = list [i].substring (0, partial_length);
        if (collator.equals (partial_nick, complete_partial)) {
            if (first_match == - 1) {
                first_match = i;
            }
            int order = collator.compare (list [i], complete_current);
            if (order > 0) {
                complete_current = list [i];
                found = true;
                break;
            }
        }
    }
    if (first_match != - 1 && ! found) {
        complete_current = list [first_match];
        found = true;
    }
    if (found) {
        String new_text = String.valueOf (text, 0, begin).concat (complete_current).concat (String.valueOf (text, end, text.length - end));
        entry.setText (new_text);
        entry.setCaretPosition (begin + complete_current.length ());
    }
}


private int [] BreadthFirst (Graph g, int v1, int v2) {
    int node;
    int i, j;
    int child;
    float tempDist;
    int [] resultArray;
    if (! g.freshlyReset) {
        g.reset ();
        reset ();
    }
    if (msgLevel >= 2) System.out.println ("\nFinding path with \"Breadth First\", from node " + v1 + " to node " + v2);
    g.freshlyReset = false;
    enqueue (v1);
    while (readPtr != writePtr) {
        node = dequeue ();
        for (i = 0; i < g.nodeList [node].edges.length; i ++) {
            child = g.getOtherNode (node, g.nodeList [node].edges [i]);
            if (child == - 1) continue;
            tempDist = g.nodeList [node].accumDist + g.edgeList [g.nodeList [node].edges [i]].cost;
            if (! g.nodeList [child].visited || (g.nodeList [child].accumDist > tempDist)) {
                g.nodeList [child].bfParent = node;
                g.nodeList [child].bfDepth = g.nodeList [node].bfDepth + 1;
                g.nodeList [child].visited = true;
                g.nodeList [child].accumDist = tempDist;
                enqueue (child);
            }
        }
    }
    if (g.nodeList [v2].visited) {
        accumDist = g.nodeList [v2].accumDist;
        resultArray = new int [g.nodeList [v2].bfDepth + 1];
        node = v2;
        for (j = 0; j < resultArray.length; j ++) {
            resultArray [resultArray.length - j - 1] = node;
            node = g.nodeList [node].bfParent;
        }
    }
    else {
        if (msgLevel >= 1) System.out.println ("No connection between start node and end node");
        return null;
    }
    if (msgLevel >= 2) printResult (resultArray, accumDist);
    return resultArray;
}


-----Function Pair=148=-----==

public pspdiffDialog (TinyWebServer webServer) {
    this.webServer = webServer;
    frame = new JFrame ("Compare Files/Directories");
    frame.setIconImage (java.awt.Toolkit.getDefaultToolkit ().createImage (PSPDiff.class.getResource ("icon32.gif")));
    Box vBox = Box.createVerticalBox ();
    Box hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Original file/directory (optional):"));
    hBox.add (hBox.createHorizontalStrut (150));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileA = new JTextField ());
    dontStretchVertically (fileA);
    hBox.add (browseA = new JButton ("Browse..."));
    browseA.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Modified/new file/directory:"));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileB = new JTextField ());
    dontStretchVertically (fileB);
    hBox.add (browseB = new JButton ("Browse..."));
    browseB.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (compareButton = new JButton ("Compare"));
    compareButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (closeButton = new JButton ("Close"));
    closeButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    frame.getContentPane ().add (vBox);
    frame.pack ();
    frame.show ();
}


public synchronized boolean hasFileDisappeared (String file, long maximumWaitTime) {
    long startTime = System.currentTimeMillis ();
    boolean hasDisappeard = false;
    File f = new File (file);
    while (true) {
        boolean exists = f.exists ();
        if (! exists) {
            hasDisappeard = true;
            break;
        }
        long currentTime = System.currentTimeMillis ();
        long lapTime = currentTime - startTime;
        if (lapTime > maximumWaitTime) {
            break;
        }
        try {
            this.wait (500);
        } catch (InterruptedException ie) {
            this.logger.log (Level.WARNING, ie.getMessage (), ie);
        }
    }
    return hasDisappeard;
}


-----Function Pair=149=-----==

public static boolean writeZipFile (byte [] content, String entry, File file) {
    if (content == null || content.length == 0) {
        Exception e = new Exception ();
        e.fillInStackTrace ();
        logger.log (Level.SEVERE, "Tried to zip an empty file!  Send this output to a dev" + " and describe what you were doing.", e);
        return false;
    }
    try {
        ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (file));
        zos.setLevel (9);
        ZipEntry ze = new ZipEntry (entry);
        ze.setSize (content.length);
        zos.putNextEntry (ze);
        zos.write (content);
        zos.flush ();
        zos.closeEntry ();
        zos.close ();
        return true;
    } catch (Throwable e) {
        logger.log (Level.SEVERE, "Exception thrown in writeZipFile(byte[] content, String entry, File file)", e);
        return false;
    }
}


public String read (String virtualWiki, String topicName) throws Exception {
    if (virtualWiki == null || virtualWiki.length () == 0) {
        virtualWiki = Constants.DEFAULT_VWIKI;
    }
    String contents = null;
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        PreparedStatement readStatement = conn.prepareStatement (STATEMENT_READ);
        readStatement.setString (1, topicName);
        readStatement.setString (2, virtualWiki);
        ResultSet rs = readStatement.executeQuery ();
        if (! rs.next ()) {
            return "This is a new topic";
        }
        contents = readText (rs, "contents");
        rs.close ();
        readStatement.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    return (contents);
}


-----Function Pair=150=-----==

private byte [] showProgramDetails (HTTPurl urlData) throws Exception {
    GuideStore guide = GuideStore.getInstance ();
    String channel = urlData.getParameter ("channel");
    String id = urlData.getParameter ("id");
    String epgChan = guide.getEpgChannelFromMap (channel);
    GuideItem item = guide.getProgram (epgChan, id);
    StringBuffer buff = new StringBuffer (256);
    if (item == null) {
        buff.append ("No info available for the requested Item.");
        return buff.toString ().getBytes ();
    }
    buff.append ("<table align='center' border='0' cellpadding='4' cellspacing='2' width='90%'>");
    buff.append ("<tr><td align='right' valign='top' colspan='2'>");
    Calendar startTime = Calendar.getInstance ();
    startTime.setTime (item.getStart ());
    buff.append ("<a href='#' onClick=\"addItem('" + programAddURL (item, startTime, channel) + "');\">");
    buff.append ("<img align='absmiddle' src='/images/add.png' border='0' title='Add Schedule' alt='Add Schedule' width='24' height='24'>");
    buff.append ("</a>\n");
    String searchURL = "/servlet/EpgAutoAddDataRes?action=14" + "&itemID=" + URLEncoder.encode (item.toString (), "UTF-8") + "&chan=" + URLEncoder.encode (channel, "UTF-8");
    buff.append (" | <a href='#' onClick=\"doSearch('" + searchURL + "');\">");
    buff.append ("<img align='absmiddle' src='/images/reload.png' border='0' title='Create Auto-Add Item' alt='Create Auto-Add Item' width='24' height='24'>");
    buff.append ("</a>\n");
    String ignoreURL = "/servlet/EpgDataRes?action=26" + "&id=" + URLEncoder.encode (item.toString (), "UTF-8") + "&channel=" + URLEncoder.encode (channel, "UTF-8");
    String imageName = "";
    String ignoreTitle = "";
    if (item.getIgnored () == true) {
        ignoreURL += "&task=0";
        imageName = "addsch.png";
        ignoreTitle = "Remove ignore flag";
    }
    else {
        ignoreURL += "&task=1";
        imageName = "stopItem24.png";
        ignoreTitle = "Ignore this program in Auto-Add scans";
    }
    buff.append (" | <a href=\"" + ignoreURL + "\">");
    buff.append ("<img align='absmiddle' src='/images/" + imageName + "' border='0' title='" + ignoreTitle + "' alt='' width='24' height='24'>");
    buff.append ("</a>\n");
    String matchesURL = "/servlet/EpgAutoAddDataRes?action=37" + "&itemID=" + URLEncoder.encode (item.toString (), "UTF-8") + "&chan=" + URLEncoder.encode (channel, "UTF-8");
    buff.append (" | <a href='#' onClick=\"showMatchListMatches('" + matchesURL + "');\">");
    buff.append ("<img align='absmiddle' src='/images/log.png' border='0' title='Show match list item matches' alt='' width='24' height='24'>");
    buff.append ("</a>\n");
    buff.append ("</td></tr>\n");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Name:</b></td><td width='100%'>" + item.getName ());
    if (item.getSubName ().length () > 0) buff.append (" (" + item.getSubName () + ")");
    buff.append ("</td></tr>");
    SimpleDateFormat df = new SimpleDateFormat ("h:mm aa");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Time:</b></td><td>" + df.format (item.getStart ()) + "</td></tr>\n");
    df = new SimpleDateFormat ("EEE MMM d");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Date:</b></td><td>" + df.format (item.getStart ()) + "</td></tr>\n");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Duration:</b></td><td>" + item.getDuration () + " min</td></tr>\n");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Channel:</b></td><td>" + channel + "</td></tr>\n");
    buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Ignored:</b></td><td>");
    if (item.getIgnored () == false) {
        buff.append ("No");
    }
    else {
        buff.append ("<span style='color: #f9fa00; font-weight: bold;'>Yes (ignored in Auto-Add scans)</span>");
    }
    buff.append ("</td></tr>\n");
    if (item.getURL ().length () > 0) {
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Source:</b></td><td><font size=2><b>\n");
        buff.append ("<a href='" + item.getURL () + "' target='_sourceData'>More Info</a>");
        buff.append ("</b></font></td></tr>");
    }
    if (item.getCategory ().size () > 0) {
        String allCats = "";
        for (int x = 0; x < item.getCategory ().size (); x ++) {
            allCats += item.getCategory ().get (x);
            if (x < item.getCategory ().size () - 1) allCats += ", ";
        }
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Category:</b></td><td>" + allCats + "</td></tr>\n");
    }
    if (item.getActors ().size () > 0) {
        String allActs = "";
        for (int x = 0; x < item.getActors ().size (); x ++) {
            allActs += item.getActors ().get (x);
            if (x < item.getActors ().size () - 1) allActs += ", ";
        }
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Actors:</b></td><td>" + allActs + "</td></tr>\n");
    }
    if (item.getDirectors ().size () > 0) {
        String allDirect = "";
        for (int x = 0; x < item.getDirectors ().size (); x ++) {
            allDirect += item.getDirectors ().get (x);
            if (x < item.getDirectors ().size () - 1) allDirect += ", ";
        }
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Directors:</b></td><td>" + allDirect + "</td></tr>\n");
    }
    String sInfo = "";
    String externalSearchURL = store.getProperty ("guide.search.url");
    externalSearchURL = externalSearchURL.replaceAll ("\\$TITLE", URLEncoder.encode (item.getName (), "UTF-8"));
    externalSearchURL = externalSearchURL.replaceAll ("\\$SUB", URLEncoder.encode (item.getSubName (), "UTF-8"));
    String catForSearch = "";
    for (int x = 0; x < item.getCategory ().size (); x ++) {
        catForSearch += item.getCategory ().get (x);
        if (x < item.getCategory ().size () - 1) catForSearch += " ";
    }
    externalSearchURL = externalSearchURL.replaceAll ("\\$CAT", URLEncoder.encode (catForSearch, "UTF-8"));
    sInfo = "<a target='_epg_search' href='" + externalSearchURL + "'>SEARCH</a>&nbsp;\n";
    if (item.getHighDef ()) sInfo = sInfo + "HDTV ";
    if (item.getWidescreen ()) sInfo = sInfo + "WS ";
    if (item.getAC3 ()) sInfo = sInfo + "AC3 ";
    if (item.getSurround ()) sInfo = sInfo + "SRS ";
    if (item.getCaptions ()) sInfo = sInfo + "CC ";
    if (item.getInteractive ()) sInfo = sInfo + "*INTERACTIVE* ";
    if (item.getPremiere ()) sInfo = sInfo + "*PREMIERE* ";
    if (item.getLive ()) sInfo = sInfo + "*LIVE* ";
    if (item.getLastChance ()) sInfo = sInfo + "*FINAL* ";
    if (item.getRepeat ()) sInfo = sInfo + "(REPEAT)";
    if (sInfo.length () > 0) {
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Info:</b></td><td><font size=2><b>\n");
        buff.append (sInfo);
        buff.append ("</b></font></td></tr>");
    }
    if (item.getRatings ().length () > 0) {
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='right' valign='top'><b>Rating:</b></td><td><font size=2><b>\n");
        buff.append (item.getRatings ());
        buff.append ("</b></font></td></tr>");
    }
    if (item.getDescription () != null && item.getDescription ().length () > 0) {
        buff.append ("<tr><td style='border: 1px solid #FFFFFF;' align='left' valign='top' colspan='2'>" + item.getDescription () + "<br></td></tr>\n");
    }
    buff.append ("</table>\n");
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "epg-details.html");
    template.replaceAll ("$details", buff.toString ());
    return template.getPageBytes ();
}


public boolean replaceAll (String _searchStr, String _replaceStr, int start, int _end, boolean ignoreCase) throws REException {
    boolean found = false;
    try {
        String searchStr = _searchStr;
        if (searchStr == null || searchStr.equals ("")) return false;
        RE regexp = null;
        try {
            regexp = new RE (searchStr, (ignoreCase == true ? RE.REG_ICASE : 0) | RE.REG_MULTILINE, RESyntax.RE_SYNTAX_PERL5);
        } catch (Exception ex) {
        }
        if (regexp == null) {
            getToolkit ().beep ();
            return false;
        }
        String replaceStr = _replaceStr;
        if (replaceStr == null) replaceStr = "";
        beginCompoundEdit ();
        Element map = getDocument ().getDefaultRootElement ();
        int startLine = map.getElementIndex (start);
        int end = _end;
        int endLine = map.getElementIndex (end);
        for (int i = startLine; i <= endLine; i ++) {
            Element lineElement = map.getElement (i);
            int lineStart;
            int lineEnd;
            if (i == startLine) lineStart = start;
            else lineStart = lineElement.getStartOffset ();
            if (i == endLine) lineEnd = end;
            else lineEnd = lineElement.getEndOffset () - 1;
            lineEnd -= lineStart;
            String line = getText (lineStart, lineEnd);
            String newLine = regexp.substituteAll (line, replaceStr);
            if (line.equals (newLine)) continue;
            getDocument ().remove (lineStart, lineEnd);
            getDocument ().insertString (lineStart, newLine, null);
            end += (newLine.length () - lineEnd);
            found = true;
        }
    } catch (Exception ex) {
        FuLog.error (ex);
    }
    endCompoundEdit ();
    return found;
}


-----Function Pair=151=-----==

PdfStamperImp (PdfReader reader, OutputStream os, char pdfVersion, boolean append) throws DocumentException, IOException {
    super (new PdfDocument (), os);
    if (! reader.isOpenedWithFullPermissions ()) throw new BadPasswordException (MessageLocalization.getComposedMessage ("pdfreader.not.opened.with.owner.password"));
    if (reader.isTampered ()) throw new DocumentException (MessageLocalization.getComposedMessage ("the.original.document.was.reused.read.it.again.from.file"));
    reader.setTampered (true);
    this.reader = reader;
    file = reader.getSafeFile ();
    this.append = append;
    if (append) {
        if (reader.isRebuilt ()) throw new DocumentException (MessageLocalization.getComposedMessage ("append.mode.requires.a.document.without.errors.even.if.recovery.was.possible"));
        if (reader.isEncrypted ()) crypto = new PdfEncryption (reader.getDecrypt ());
        pdf_version.setAppendmode (true);
        file.reOpen ();
        byte buf [] = new byte [8192];
        int n;
        while ((n = file.read (buf)) > 0) this.os.write (buf, 0, n);
        file.close ();
        prevxref = reader.getLastXref ();
        reader.setAppendable (true);
    }
    else {
        if (pdfVersion == 0) super.setPdfVersion (reader.getPdfVersion ());
        else super.setPdfVersion (pdfVersion);
    }
    super.open ();
    pdf.addWriter (this);
    if (append) {
        body.setRefnum (reader.getXrefSize ());
        marked = new IntHashtable ();
        if (reader.isNewXrefType ()) fullCompression = true;
        if (reader.isHybridXref ()) fullCompression = false;
    }
    initialXrefSize = reader.getXrefSize ();
}


private static ByteArrayOutputStream replaceEntityMappings (ByteArrayOutputStream content, File entityMappingXML) throws IOException {
    JarInputStream jarInputStream = new JarInputStream (new ByteArrayInputStream (content.toByteArray ()));
    ByteArrayOutputStream retval = new ByteArrayOutputStream ();
    JarOutputStream tempJar = new JarOutputStream (retval);
    HashSet < String > insertedNames = new HashSet < String > ();
    JarEntry jarEntry = jarInputStream.getNextJarEntry ();
    while (jarEntry != null) {
        if (! insertedNames.contains (jarEntry.getName ())) {
            ByteArrayOutputStream baos = new ByteArrayOutputStream ();
            InputStream is = jarInputStream;
            if (jarEntry.getName ().equals ("META-INF/entity-mappings.xml")) {
                jarEntry = new JarEntry ("META-INF/entity-mappings.xml");
                is = new FileInputStream (entityMappingXML);
            }
            byte [] data = new byte [30000];
            int numberread;
            while ((numberread = is.read (data)) != - 1) {
                baos.write (data, 0, numberread);
            }
            tempJar.putNextEntry (jarEntry);
            insertedNames.add (jarEntry.getName ());
            tempJar.write (baos.toByteArray ());
        }
        jarEntry = jarInputStream.getNextJarEntry ();
    }
    tempJar.close ();
    return retval;
}


-----Function Pair=152=-----==

public static byte [] decrypt (String pass, String str) throws Exception {
    int iterationCount = 19;
    KeySpec keySpec = new PBEKeySpec (pass.toCharArray (), salt, iterationCount);
    SecretKey key = SecretKeyFactory.getInstance ("PBEWithMD5AndDES").generateSecret (keySpec);
    Cipher dcipher = Cipher.getInstance (key.getAlgorithm ());
    AlgorithmParameterSpec paramSpec = new PBEParameterSpec (salt, iterationCount);
    dcipher.init (Cipher.DECRYPT_MODE, key, paramSpec);
    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream (str.getBytes ("UTF8"));
    Base64InputStream decoder = new Base64InputStream (byteArrayInputStream);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    byte array [] = new byte [2048];
    int nbread = 0;
    while ((nbread = decoder.read (array)) > - 1) {
        baos.write (array, 0, nbread);
    }
    byte encoded [] = baos.toByteArray ();
    byte decoded [] = dcipher.doFinal (encoded);
    return decoded;
}


public void run () {
    super.setPriority (Thread.MIN_PRIORITY);
    JPanel comp = new JPanel ();
    comp.setMinimumSize (new Dimension (250, 75));
    comp.setPreferredSize (new Dimension (250, 75));
    comp.setLayout (new GridLayout (3, 1));
    cancel = new JButton ("Cancel");
    cancel.setFont (Core.Resources.Font);
    cancel.setMnemonic ('C');
    cancel.setFocusable (false);
    cancel.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent ae) {
            clock.stop ();
            stopped = true;
            DouzDialog window = (DouzDialog) cancel.getRootPane ().getParent ();
            window.dispose ();
        }
    }
    );
    progressbar_file = new JProgressBar (1, 100);
    progressbar_file.setStringPainted (true);
    progressbar_file.setFont (Core.Resources.Font);
    progressbar_overall = new JProgressBar (1, 100);
    progressbar_overall.setStringPainted (true);
    progressbar_overall.setFont (Core.Properties.get ("org.dyndns.doujindb.ui.font").asFont ());
    comp.add (progressbar_overall);
    comp.add (progressbar_file);
    comp.add (cancel);
    clock = new Timer (50, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent ae) {
            int file = (int) (progress_file_current * 100 / (progress_file_max == 0 ? 1 : progress_file_max));
            progressbar_file.setString (file + "%");
            progressbar_file.setValue (file);
            int overall = (int) (progress_overall_current * 100 / (progress_overall_max == 0 ? 1 : progress_overall_max));
            progressbar_overall.setString (label_file_current + " (" + overall + "%)");
            progressbar_overall.setValue (overall);
        }
    }
    );
    clock.start ();
    Vector < String > errors = new Vector < String > ();
    try {
        Core.UI.Desktop.showDialog (comp, Core.Resources.Icons.get ("JDesktop/Explorer/Book/Media/Upload"), "Uploading ...");
        progress_overall_max = 0;
        for (File file : files) if (file.isDirectory ()) progress_overall_max += count (file);
        else progress_overall_max += 1;
        for (File file : files) {
            try {
                upload (file, up_root);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    } catch (PropertyVetoException pve) {
        pve.printStackTrace ();
        Core.Logger.log (pve.getMessage (), Level.WARNING);
    }
    clock.stop ();
    DouzDialog window = (DouzDialog) comp.getRootPane ().getParent ();
    window.dispose ();
    if (errors.size () == 0) return;
    {
        JPanel panel = new JPanel ();
        panel.setBorder (BorderFactory.createEmptyBorder (15, 15, 15, 15));
        panel.setLayout (new BorderLayout (5, 5));
        JLabel lab = new JLabel ("<html><body>" + "The following entries were not uploaded.<br>" + "Make sure the upload directory is writable and empty.<br>" + "</body></html>");
        panel.add (lab, BorderLayout.NORTH);
        JList < String > list = new JList < String > (errors);
        list.setFont (Core.Properties.get ("org.dyndns.doujindb.ui.font").asFont ());
        list.setSelectionBackground (list.getSelectionForeground ());
        list.setSelectionForeground (Core.Properties.get ("org.dyndns.doujindb.ui.theme.background").asColor ());
        panel.add (new JScrollPane (list), BorderLayout.CENTER);
        JButton ok = new JButton ("Ok");
        ok.setFont (Core.Resources.Font);
        ok.setMnemonic ('O');
        ok.setFocusable (false);
        ok.addActionListener (new ActionListener () {
            @Override
            public void actionPerformed (ActionEvent ae) {
                DouzDialog window = (DouzDialog) ((JComponent) ae.getSource ()).getRootPane ().getParent ();
                window.dispose ();
            }
        }
        );
        JPanel centered = new JPanel ();
        centered.setLayout (new GridLayout (1, 3));
        centered.add (new JLabel ());
        centered.add (ok);
        centered.add (new JLabel ());
        panel.add (centered, BorderLayout.SOUTH);
        try {
            Core.UI.Desktop.showDialog (panel, Core.Resources.Icons.get ("JDesktop/Explorer/Book/Media/Upload"), "Uploading - Error");
        } catch (PropertyVetoException pve) {
        }
    }
}


-----Function Pair=153=-----==

public boolean descompactar (String destino) throws IOException {
    Enumeration entries;
    ZipEntry entry = null;
    entries = zip.entries ();
    int total = zip.size ();
    int numeroEntrie = 0;
    fora : while (entries.hasMoreElements ()) {
        numeroEntrie ++;
        entry = (ZipEntry) entries.nextElement ();
        if (listener != null) listener.unzipedInternalFile (total, numeroEntrie);
        File s = new File (destino + File.separator + entry.getName ());
        if (filtros != null) for (IFilterUnzip filtro : filtros) if (! filtro.descompactar (entry, s)) continue fora;
        if (entry.isDirectory ()) {
            if (s.isDirectory () && ! s.exists ()) s.mkdir ();
            continue;
        }
        else {
            if (! s.exists ()) {
                s.getParentFile ().mkdirs ();
                s.createNewFile ();
            }
        }
        descompactarArquivo (entry, destino + File.separator + entry.getName ());
    }
    concluido = true;
    return true;
}


protected Object createInstance (String locator) throws AxisException {
    Service locatorInstance;
    Iterator < ? > itr;
    Class < ? > clazz;
    Object instance;
    QName serviceName;
    int n;
    serviceName = null;
    instance = null;
    try {
        if ((n = locator.indexOf ('.')) > 0) {
            SicariSecurityManager.addTrusted (new WildcardedCharSequence (locator.substring (0, n) + ".*"));
        }
        else {
            log2_.warning ("Failed registering default package/class '" + locator + "' with " + SicariSecurityManager.class.getName ());
        }
        clazz = Class.forName (locator, true, new URLClassLoader (new URL [] {tmpdir_.toURL ()}));
        log2_.debug ("Successfully created service locator class '" + locator + "'");
        locatorInstance = (Service) clazz.newInstance ();
        log2_.debug ("Successfully created service locator instance '" + locator + "'");
        itr = locatorInstance.getPorts ();
        if (itr.hasNext ()) {
            serviceName = (QName) itr.next ();
            log2_.debug ("Retrieved port '" + serviceName.getLocalPart () + "' from service locator");
            instance = locatorInstance.getPort (serviceName, null);
            log2_.debug ("Successfully created '" + serviceName.getLocalPart () + "' client stub instance " + instance);
        }
    } catch (Exception e) {
        String msg = "Failed creating '" + serviceName + "' client stub instance from '" + locator + "'";
        log2_.caught (LogLevel.ERROR, msg, e);
        throw new AxisException (msg, e);
    }
    return instance;
}


-----Function Pair=154=-----==

private void setInlineXML (Entry entry, DatastreamXMLMetadata ds) throws UnsupportedEncodingException, StreamIOException {
    String content;
    if (m_obj.hasContentModel (Models.SERVICE_DEPLOYMENT_3_0) && (ds.DatastreamID.equals ("SERVICE-PROFILE") || ds.DatastreamID.equals ("WSDL"))) {
        content = DOTranslationUtility.normalizeInlineXML (new String (ds.xmlContent, m_encoding), m_transContext);
    }
    else {
        content = new String (ds.xmlContent, m_encoding);
    }
    if (m_format.equals (ATOM_ZIP1_1)) {
        String name = ds.DSVersionID + ".xml";
        try {
            m_zout.putNextEntry (new ZipEntry (name));
            InputStream is = new ByteArrayInputStream (content.getBytes (m_encoding));
            IOUtils.copy (is, m_zout);
            m_zout.closeEntry ();
            is.close ();
        } catch (IOException e) {
            throw new StreamIOException (e.getMessage (), e);
        }
        IRI iri = new IRI (name);
        entry.setSummary (ds.DSVersionID);
        entry.setContent (iri, ds.DSMIME);
    }
    else {
        entry.setContent (content, ds.DSMIME);
    }
}


private String readFile (File file) {
    if (file.length () == 0) {
        System.out.println ("Could not read file; debug: readFile()");
    }
    String sFile = null;
    try {
        FileReader input = new FileReader (file);
        BufferedReader bufRead = new BufferedReader (input);
        String line;
        int count = 0;
        line = bufRead.readLine ();
        sFile = line;
        count ++;
        while (line != null) {
            line = bufRead.readLine ();
            if (line != null) {
                sFile = sFile + line;
            }
            count ++;
        }
        bufRead.close ();
    } catch (ArrayIndexOutOfBoundsException e) {
        System.out.println ("Usage: java ReadFile filename\n");
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return sFile;
}


-----Function Pair=155=-----==

private byte [] showAutoEpgOptions (HTTPurl urlData, HashMap headers) throws Exception {
    int index = - 1;
    try {
        index = Integer.parseInt (urlData.getParameter ("index"));
    } catch (Exception e) {
    }
    EpgMatch epgMatcher = (EpgMatch) (store.getEpgMatchList ().get (index));
    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance ();
    DocumentBuilder db = dbf.newDocumentBuilder ();
    DOMImplementation di = db.getDOMImplementation ();
    Document doc = di.createDocument ("", "buttons", null);
    Element root = doc.getDocumentElement ();
    root.setAttribute ("back", "/servlet/KBAutoAddRes");
    Element button = null;
    Element elm = null;
    Text text = null;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Back");
    elm = doc.createElement ("url");
    text = doc.createTextNode ("/servlet/KBAutoAddRes");
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    button = doc.createElement ("button");
    String action = "/servlet/KBAutoAddRes?action=07&index=" + index;
    if (epgMatcher.isEnabled ()) {
        button.setAttribute ("name", "Disable");
        action += "&enabled=false";
    }
    else {
        button.setAttribute ("name", "Enable");
        action += "&enabled=true";
    }
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    elm = doc.createElement ("confirm");
    text = doc.createTextNode ("false");
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/" + urlData.getServletClass () + "?action=08&index=" + index;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Match Lists");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/" + urlData.getServletClass () + "?action=01&index=" + index;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Edit Options");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/" + urlData.getServletClass () + "?action=03&index=" + index;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Show Matches");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/" + urlData.getServletClass () + "?action=04&id=" + index + "&dir=0";
    button = doc.createElement ("button");
    button.setAttribute ("name", "Move Up");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    elm = doc.createElement ("confirm");
    text = doc.createTextNode ("false");
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/" + urlData.getServletClass () + "?action=04&id=" + index + "&dir=1";
    button = doc.createElement ("button");
    button.setAttribute ("name", "Move Down");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    elm = doc.createElement ("confirm");
    text = doc.createTextNode ("false");
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    action = "/servlet/KBAutoAddRes?action=05&id=" + index;
    button = doc.createElement ("button");
    button.setAttribute ("name", "Delete");
    elm = doc.createElement ("url");
    text = doc.createTextNode (action);
    elm.appendChild (text);
    button.appendChild (elm);
    elm = doc.createElement ("confirm");
    text = doc.createTextNode ("true");
    elm.appendChild (text);
    button.appendChild (elm);
    root.appendChild (button);
    XSL transformer = new XSL (doc, "kb-buttons.xsl", urlData, headers);
    return transformer.doTransform ();
}


private void oracleSaveClob (String fieldName, java.io.Reader data, int length) throws DataException {
    try {
        if (myConnection == null) {
            myConnection = DBConnectionPool.getInstance (getCriteria ().getMappedDataContext ()).getConnection ("LOB Field Connection");
        }
    } catch (DBException ex) {
        throw new DataException ("Error getting Database" + " Connection for CLOB Retrieval", ex);
    }
    if (data == null) {
        oraclePrepUpdateNullClob (getCriteria (), fieldName, myConnection);
        return;
    }
    oraclePrepUpdateEmptyLob (getCriteria (), fieldName, myConnection);
    try {
        oraclePrepSelectForUpdate (getCriteria (), fieldName, myConnection);
        if (myConnection.next ()) {
            Class oracleResultSetClass = Class.forName ("oracle.jdbc.driver.OracleResultSet");
            Class [] parameterTypes = new Class [] {int.class};
            Object [] arguments = new Object [] {new Integer (1)};
            Method getClobMethod = oracleResultSetClass.getMethod ("getClob", parameterTypes);
            Object clob = getClobMethod.invoke ((Object) myConnection.getResultSet (), arguments);
            parameterTypes = new Class [] {};
            arguments = new Object [] {};
            Class oracleClobClass = Class.forName ("oracle.sql.CLOB");
            Method getCharacterOutputStream = oracleClobClass.getMethod ("getCharacterOutputStream", parameterTypes);
            Writer oClob = (Writer) getCharacterOutputStream.invoke (clob, arguments);
            Method getChunkSizeMethod = oracleClobClass.getMethod ("getChunkSize", parameterTypes);
            char [] chunk = new char [((Integer) getChunkSizeMethod.invoke (clob, arguments)).intValue ()];
            int i = - 1;
            while ((i = data.read (chunk)) != - 1) oClob.write (chunk, 0, i);
            oClob.close ();
            data.close ();
            myConnection.commit ();
        }
        else {
            throw new DataException ("Error SELECTing record for update.");
        }
    } catch (DBException ex) {
        throw new DataException ("Error SELECTing record for update.", ex);
    } catch (NoSuchMethodException ex) {
        throw new DataException ("Reflection error on oracle classes.", ex);
    } catch (IllegalAccessException ex) {
        throw new DataException ("Reflection error on oracle classes.", ex);
    } catch (InvocationTargetException ex) {
        throw new DataException ("Reflection error on oracle classes.", ex);
    } catch (ClassNotFoundException ex) {
        throw new DataException ("Reflection error on oracle classes.", ex);
    } catch (IOException ex) {
        throw new DataException ("Error reading from InputStream.", ex);
    }
}


-----Function Pair=156=-----==

public static void saveEntry (ZipFile zf, ZipEntry target, String parentDir) throws Exception, IOException {
    try {
        if (target.isDirectory ()) {
        }
        else {
            File file = new File (parentDir + File.separator + target.getName ());
            file.getParentFile ().mkdirs ();
            try {
                file.createNewFile ();
            } catch (Exception e) {
                System.out.println ("�����ļ��������" + file.getAbsolutePath ());
                throw e;
            }
            InputStream in = zf.getInputStream (target);
            FileOutputStream out = new FileOutputStream (file);
            byte [] by = new byte [1024];
            int c;
            while ((c = in.read (by)) != - 1) {
                out.write (by, 0, c);
            }
            out.close ();
            in.close ();
        }
    } catch (Exception e) {
        throw e;
    }
    Thread.sleep (10);
}


public static Collection < File > getListeDirectory (File directory, boolean findSubDirectory) throws IOException {
    Collection < File > allDirectory = new ArrayList < File > ();
    FileFilter directoryFilter = new FileFilter () {
        public boolean accept (File file) {
            return file.isDirectory ();
        }
    }
    ;
    File [] listeDirectory = directory.listFiles (directoryFilter);
    for (int j = 0; j < listeDirectory.length; j ++) {
        File subDirectory = listeDirectory [j];
        if (findSubDirectory) {
            allDirectory.addAll (getListeDirectory (subDirectory, findSubDirectory));
        }
        allDirectory.add (subDirectory);
    }
    return allDirectory;
}


-----Function Pair=157=-----==

static MovieInfoXmlRpcResponse checkMovieHash (String hash) throws XmlRpcException, XmlRpcFault, TimeoutException, OsdbException, BadLoginException, InterruptedException {
    if (! isLoggedIn ()) {
        anonymousLogIn ();
    }
    XmlRpcArray param = new XmlRpcArray ();
    param.add (hash);
    XmlRpcStruct response = (XmlRpcStruct) client.invoke ("CheckMovieHash", new Object [] {token, param});
    String status = response.getString ("status");
    if (status.indexOf ("20") != 0) {
        throw new OsdbException (status);
    }
    Object object = response.getStruct ("data").get (hash);
    if (object instanceof XmlRpcStruct) {
        XmlRpcStruct dataStruct = XmlRpcStruct.class.cast (object);
        MovieInfoXmlRpcResponse returnStruct = new MovieInfoXmlRpcResponse ();
        returnStruct.setMovieImdbId (dataStruct.getString ("MovieImdbID"));
        returnStruct.setMovieName (dataStruct.getString ("MovieName"));
        returnStruct.setMovieYear (dataStruct.getString ("MovieYear"));
        return returnStruct;
    }
    return null;
}


public Document getDocument (String documentId) {
    logger.debug ("getDocument(%s)", documentId);
    Connection connection = null;
    NamedParameterStatement statement = null;
    ResultSet documentRS = null;
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.SELECT_DOCUMENT));
        statement.setString (QueryStore.SELECT_DOCUMENT_PARAM_ID_DOCUMENT, documentId);
        documentRS = statement.executeQuery ();
        if (documentRS != null && documentRS.next ()) {
            Document document = new Document ();
            document.setId (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_ID));
            document.setState (documentRS.getInt (QueryStore.SELECT_DOCUMENT_RESULTSET_STATE));
            document.setDeprecated (documentRS.getBoolean (QueryStore.SELECT_DOCUMENT_RESULTSET_IS_DEPRECATED));
            Template template = new Template ();
            template.setCode (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_TEMPLATE_CODE));
            template.setId (documentRS.getString (QueryStore.SELECT_DOCUMENT_RESULTSET_ID));
            document.setTemplate (template);
            return document;
        }
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (documentRS);
        close (statement);
        close (connection);
    }
    throw new ApplicationException (String.format ("Document '%s' not found", documentId));
}


-----Function Pair=158=-----==

private void zap () {
    fileHolder.srcFileList = listHolder.getList ();
    fileHolder.srcFirstFileIndex = listHolder.getIndex ();
    if (! setFileHolderIndex (fileHolder)) return;
    selectInputFiles (fileHolder);
    setDestinationFileName (fileHolder);
    if (fileHolder.destFileName != null) {
        fileHolder.destFiles = this.destWriter.generateDestFiles (new File (fileHolder.destFileName), null, null, false);
    }
    this.addFileNameExtension (fileHolder);
    if (this.zapType.equals (XmultraConfig.TAR_VALUE)) {
        this.tar (fileHolder, false);
    }
    else if (this.zapType.equals (XmultraConfig.TAR_GZIP_VALUE)) {
        this.tar (fileHolder, true);
    }
    else if (this.zapType.equals (XmultraConfig.GZIP_VALUE)) {
        this.gzip (fileHolder);
    }
    else if (this.zapType.equals (XmultraConfig.ZIP_VALUE)) {
        this.zip (fileHolder, this.zipCompressionLevel);
    }
    else return;
    copyAdditionalDestLocations (fileHolder);
    if (! Console.getConsoleMode ("9")) {
        for (int i = fileHolder.srcFirstFileIndex; i <= fileHolder.srcLastFileIndex; i ++) {
            File srcFile = (File) fileHolder.srcFileList.get (i);
            if (deleteProcessedFiles) {
                srcFile.delete ();
            }
            else {
                fileUtils.moveFileToDoneLocation (srcFile, srcDoneLocFile.toString ());
            }
        }
    }
    listHolder.setIndex (fileHolder.srcLastFileIndex);
    if (fileHolder.selectedFileList.size () > 0) {
        logEntries (fileHolder);
    }
    for (int j = 0; j < fileHolder.destFiles.length; j ++) {
        File destFile = new File (fileHolder.destFiles [j]);
        WakeAble wakeAble = CallbackRegistry.getFromWakeAbleRegistry (destFile.getParent ().toString ());
        if (wakeAble != null) {
            wakeAble.wakeUp ();
        }
    }
    if (Console.getConsoleMode ("9") && listHolder.getIndex () >= listHolder.getList ().size () - 1) {
        System.exit (0);
    }
    listHolder.setIndex (fileHolder.srcLastFileIndex + 1);
}


public static void copyDirectory (File sourceLocation, File targetLocation) throws IOException {
    if (sourceLocation.isDirectory ()) {
        if (! targetLocation.exists ()) {
            targetLocation.mkdir ();
        }
        String [] children = sourceLocation.list ();
        for (int i = 0; i < children.length; i ++) {
            copyDirectory (new File (sourceLocation, children [i]), new File (targetLocation, children [i]));
        }
    }
    else {
        InputStream in = new FileInputStream (sourceLocation);
        OutputStream out = new FileOutputStream (targetLocation);
        byte [] buf = new byte [1024];
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.close ();
    }
}


-----Function Pair=159=-----==

private static void sortBlock (File [] files, int start, int end, File [] mergeTemp) {
    final int length = end - start + 1;
    if (length < 8) {
        for (int i = end; i > start; -- i) {
            for (int j = end; j > start; -- j) {
                if (compareFiles (files [j - 1], files [j]) > 0) {
                    final File temp = files [j];
                    files [j] = files [j - 1];
                    files [j - 1] = temp;
                }
            }
        }
        return;
    }
    final int mid = (start + end) / 2;
    sortBlock (files, start, mid, mergeTemp);
    sortBlock (files, mid + 1, end, mergeTemp);
    int x = start;
    int y = mid + 1;
    for (int i = 0; i < length; ++ i) {
        if ((x > mid) || ((y <= end) && compareFiles (files [x], files [y]) > 0)) {
            mergeTemp [i] = files [y ++];
        }
        else {
            mergeTemp [i] = files [x ++];
        }
    }
    for (int i = 0; i < length; ++ i) files [i + start] = mergeTemp [i];
}


public File createContentPackage () throws IOException {
    File dir = createTempDir ("constructr", null);
    int scount = 0;
    for (SectionModel sm : sections) {
        int icount = 0;
        for (ItemModel im : sm.items) {
            ContentPackage icp = im.item.resolveItem ();
            icp.unpack (new File (dir.toString () + File.separator + "S" + scount + "I" + icount));
            File [] items = icp.getItems ();
            if (items.length != 1) {
                System.err.println ("Error: invalid item content package - more than one item!");
                System.err.println (items);
                System.err.println (items.length);
                System.err.println (icp.getManifest ());
                return null;
            }
            im.itempath = items [0].getAbsolutePath ().replace (dir.getAbsolutePath (), "");
            if (im.itempath.startsWith (File.separator)) im.itempath = im.itempath.substring (1);
            System.out.println (im.itempath);
            icount ++;
        }
        scount ++;
    }
    System.out.println ("Temp CP dir: " + dir);
    FileWriter fw = new FileWriter (new File (dir.toString () + File.separator + "assessment.xml"));
    fw.write (convertToQTI ().toXmlString ());
    fw.close ();
    fw = new FileWriter (new File (dir.toString () + File.separator + "imsmanifest.xml"));
    fw.write ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fw.write ("<manifest xmlns=\"http://www.imsglobal.org/xsd/imscp_v1p1\" " + "identifier=\"" + java.util.UUID.randomUUID () + "\" >\n");
    fw.write ("\t<resources>\n");
    fw.write ("\t\t<resource identifier=\"RES-" + java.util.UUID.randomUUID () + "\" type=\"imsqti_test_xmlv2p1\" href=\"assessment.xml\" />\n");
    for (SectionModel sm : sections) {
        for (ItemModel im : sm.items) {
            fw.write ("\t\t<resource identifier=\"RES-" + java.util.UUID.randomUUID () + "\" type=\"imsqti_item_xmlv2p0\" href=\"" + im.itempath + "\" />\n");
        }
    }
    fw.write ("\t</resources>\n");
    fw.write ("</manifest>\n");
    fw.close ();
    File zipfile = new File (dir.toString () + ".zip");
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipfile));
    zipDir (dir, zos, dir);
    zos.close ();
    delete (dir);
    return zipfile;
}


-----Function Pair=160=-----==

public static void copyFilesFromDirectory (File srcDirectory, File dstDirectory, boolean deleteOriginals, boolean replaceExistingFiles, boolean recursiveCopy, FileFilter filter) throws FileNotFoundException, IOException {
    if (! srcDirectory.exists () || ! dstDirectory.exists ()) throw new RuntimeException ("Both the src and dst directories must exist! Src: " + srcDirectory + " Dst: " + dstDirectory);
    File srcFiles [] = filter != null ? srcDirectory.listFiles (filter) : srcDirectory.listFiles ();
    if (srcFiles != null && srcFiles.length > 0) {
        for (int i = 0; i < srcFiles.length; i ++) {
            File srcFile = srcFiles [i];
            File dstFile = new File (dstDirectory, srcFile.getName ());
            if (srcFile.isDirectory () && recursiveCopy) {
                if (deleteOriginals) {
                    renameTo (srcFile, dstFile);
                }
                else {
                    dstFile.mkdirs ();
                    copyFilesFromDirectory (srcFile, dstFile, deleteOriginals, replaceExistingFiles, recursiveCopy, filter);
                }
            }
            else if (! srcFile.isDirectory ()) {
                if (replaceExistingFiles || ! dstFile.exists ()) {
                    copyFileToFile (srcFile, dstFile, deleteOriginals, true);
                }
                else if (log.isDebugEnabled ()) {
                    log.debug ("Destination file: " + dstFile + " skipped as it exists and replaceExistingFiles is set to false.");
                }
            }
            else if (log.isDebugEnabled ()) {
                log.debug ("Source file: " + srcFile + " is a directory inside: " + dstDirectory + " and recursive copy is set to false.");
            }
        }
    }
}


public boolean exportToOoWriter (File file, StringWriter writer, String xslts) throws IOException {
    boolean resultValue = true;
    ZipOutputStream zipout = new ZipOutputStream (new FileOutputStream (file));
    Result result = new StreamResult (zipout);
    StringTokenizer tokenizer = new StringTokenizer (xslts, ",");
    while (tokenizer.hasMoreTokens ()) {
        String token = tokenizer.nextToken ();
        String [] files = token.split ("->");
        if (files.length == 2) {
            ZipEntry entry = new ZipEntry (files [1]);
            zipout.putNextEntry (entry);
            if (files [0].endsWith (".xsl")) {
                logger.info ("Transforming with xslt " + files [0] + " to file " + files [1]);
                resultValue &= applyXsltFile (files [0], writer, result);
            }
            else {
                logger.info ("Copying resource from " + files [0] + " to file " + files [1]);
                resultValue &= copyFromResource (files [0], zipout);
            }
            zipout.closeEntry ();
        }
    }
    zipout.close ();
    return resultValue;
}


-----Function Pair=161=-----==

public String getFileContent (File file) throws Exception {
    StringBuilder buf = new StringBuilder ();
    BufferedReader in = null;
    try {
        in = new BufferedReader (new InputStreamReader (new FileInputStream (file)));
        char [] cbuf = new char [4096];
        while (in.read (cbuf) != - 1) {
            buf.append (cbuf);
        }
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (Exception ioe) {
            }
        }
    }
    char [] cArray = {(char) 0};
    String emptyChar = new String (cArray);
    String ret = null;
    int index = buf.indexOf (emptyChar);
    if (index != - 1) {
        ret = buf.substring (0, index);
    }
    else {
        ret = buf.toString ();
    }
    return ret;
}


protected void add (ZipEntry zipEntry, ZipFileEntryInputStream zipData, String password) throws IOException, UnsupportedEncodingException {
    AESEncrypter aesEncrypter = new AESEncrypterBC (password.getBytes ("iso-8859-1"));
    ExtZipEntry entry = new ExtZipEntry (zipEntry.getName ());
    entry.setMethod (zipEntry.getMethod ());
    entry.setSize (zipEntry.getSize ());
    entry.setCompressedSize (zipEntry.getCompressedSize () + 28);
    entry.setTime (zipEntry.getTime ());
    entry.initEncryptedEntry ();
    zipOS.putNextEntry (entry);
    zipOS.writeBytes (aesEncrypter.getSalt ());
    zipOS.writeBytes (aesEncrypter.getPwVerification ());
    byte [] data = new byte [1024];
    int read = zipData.read (data);
    while (read != - 1) {
        aesEncrypter.encrypt (data, read);
        zipOS.writeBytes (data, 0, read);
        read = zipData.read (data);
    }
    byte [] finalAuthentication = aesEncrypter.getFinalAuthentication ();
    if (LOG.isLoggable (Level.FINE)) {
        LOG.fine ("finalAuthentication=" + Arrays.toString (finalAuthentication) + " at pos=" + zipOS.getWritten ());
    }
    zipOS.writeBytes (finalAuthentication);
}


-----Function Pair=162=-----==

protected void truncate (File file) {
    LogLog.debug ("Compression of file: " + file.getAbsolutePath () + " started.");
    if (FileUtils.isFileOlder (file, ManagementFactory.getRuntimeMXBean ().getStartTime ())) {
        File backupRoot = new File (getBackupDir ());
        if (! backupRoot.exists () && ! backupRoot.mkdirs ()) {
            throw new AppenderInitializationError ("Can't create backup dir for backup storage");
        }
        SimpleDateFormat df;
        try {
            df = new SimpleDateFormat (getBackupDateFormat ());
        } catch (Exception e) {
            throw new AppenderInitializationError ("Invalid date formate for backup files: " + getBackupDateFormat (), e);
        }
        String date = df.format (new Date (file.lastModified ()));
        File zipFile = new File (backupRoot, file.getName () + "." + date + ".zip");
        ZipOutputStream zos = null;
        FileInputStream fis = null;
        try {
            zos = new ZipOutputStream (new FileOutputStream (zipFile));
            ZipEntry entry = new ZipEntry (file.getName ());
            entry.setMethod (ZipEntry.DEFLATED);
            entry.setCrc (FileUtils.checksumCRC32 (file));
            zos.putNextEntry (entry);
            fis = FileUtils.openInputStream (file);
            byte [] buffer = new byte [1024];
            int readed;
            while ((readed = fis.read (buffer)) != - 1) {
                zos.write (buffer, 0, readed);
            }
        } catch (Exception e) {
            throw new AppenderInitializationError ("Can't create zip file", e);
        } finally {
            if (zos != null) {
                try {
                    zos.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zip file", e);
                }
            }
            if (fis != null) {
                try {
                    fis.close ();
                } catch (IOException e) {
                    LogLog.warn ("Can't close zipped file", e);
                }
            }
        }
        if (! file.delete ()) {
            throw new AppenderInitializationError ("Can't delete old log file " + file.getAbsolutePath ());
        }
    }
}


public final void start () {
    build = getParameter ("build");
    coreurl = getParameter ("coreurl");
    core = getParameter ("core");
    path = getParameter ("path");
    if (getParameter ("log") != null) applog = true;
    new Thread () {
        public void run () {
            log ("ShoeHorn thread spawned");
            try {
                if (System.getProperty ("java.vendor", "").startsWith ("Netscape")) {
                    log ("Detected Navigator 4.x");
                    Method m = Class.forName ("netscape.security.PrivilegeManager").getMethod ("enablePrivilege", new Class [] {String.class});
                    m.invoke (null, new Object [] {"MarimbaInternalTarget"});
                    m.invoke (null, new Object [] {"UniversalExecAccess"});
                    m.invoke (null, new Object [] {"UniversalPropertyRead"});
                    go ();
                }
                else if (System.getProperty ("java.vendor", "").startsWith ("Microsoft")) {
                    Class permissionIdClass = Class.forName ("com.ms.security.PermissionID");
                    Object o = permissionIdClass.getField ("SYSTEM").get (null);
                    Method m = Class.forName ("com.ms.security.PolicyEngine").getMethod ("assertPermission", new Class [] {permissionIdClass});
                    m.invoke (null, new Object [] {o});
                    go ();
                }
                else {
                    log ("Detected non-Navigator JVM");
                    Method m = Class.forName ("org.vexi.shoehorn3.ShoeHorn$Java12").getMethod ("run", new Class [] {Object.class});
                    m.invoke (null, new Object [] {ShoeHorn.this});
                }
            } catch (Throwable e) {
                if (e instanceof InvocationTargetException) e = ((InvocationTargetException) e).getTargetException ();
                e.printStackTrace ();
                update (- 1.0, "Error; please check the Java console");
            }
        }
    }
    .start ();
}


-----Function Pair=163=-----==

private void copyDir (File dir, File dest) {
    File [] files = dir.listFiles ();
    for (File file : files) {
        File copy = new File (dest.getPath () + File.separator + file.getName ());
        if (file.isDirectory ()) {
            copy.mkdir ();
            copyDir (file, copy);
        }
        else {
            try {
                copyFile (file, copy);
            } catch (IOException e) {
            }
        }
    }
}


public static blue_h.mmapfile mmap_fopen (String filename) {
    logger.debug ("OPEN " + filename);
    blue_h.mmapfile new_mmapfile = null;
    try {
        new_mmapfile = new blue_h.mmapfile ();
        new_mmapfile.path = filename;
        new_mmapfile.current_line = 0L;
        new_mmapfile.fc = Channels.newChannel (new FileInputStream (filename));
        new_mmapfile.reader = new BufferedReader (Channels.newReader (new_mmapfile.fc, "ISO-8859-1"));
    } catch (IOException ioE) {
        logger.error ("SYSTEM: " + ioE.getMessage () + ";WARNING; File Set to null.");
        new_mmapfile = null;
    }
    return new_mmapfile;
}


-----Function Pair=164=-----==

public int obtenerCantidad () {
    try {
        BufferedOutputStream dest = null;
        BufferedInputStream is = null;
        ZipEntry entry;
        ZipFile zipfile = new ZipFile ("cantidadArchivos.zip");
        Enumeration e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            is = new BufferedInputStream (zipfile.getInputStream (entry));
            int count;
            byte data [] = new byte [buffer];
            FileOutputStream fos = new FileOutputStream (entry.getName ());
            dest = new BufferedOutputStream (fos, buffer);
            while ((count = is.read (data, 0, buffer)) != - 1) dest.write (data, 0, count);
            dest.flush ();
            dest.close ();
            is.close ();
        }
        DataInputStream input = new DataInputStream (new FileInputStream ("cantidadArchivos.txt"));
        int a = Integer.parseInt (input.readLine ());
        input.close ();
        return (a);
    } catch (Exception e) {
        return (0);
    }
}


private static void zipDir (final File zipDir, final String parentRelativePath, final ZipOutputStream zos) throws IOException {
    if (zipDir == null || zos == null) {
        throw new IllegalArgumentException ("directory and ZipOutputStream shouldn't be null");
    }
    final File [] dirChildren = zipDir.listFiles ();
    String entry = zipDir.getName ();
    if (parentRelativePath.length () > 0) {
        entry = parentRelativePath + ZIP_FILE_SEP + zipDir.getName ();
    }
    final ZipEntry anDirectoryEntry = new ZipEntry (entry + ZIP_FILE_SEP);
    zos.putNextEntry (anDirectoryEntry);
    final byte [] readBuffer = new byte [NB_BITE];
    int bytesIn = 0;
    for (final File element : dirChildren) {
        if (element.isDirectory ()) {
            zipDir (element, entry, zos);
        }
        else {
            final FileInputStream fis = new FileInputStream (element);
            final ZipEntry anFileEntry = new ZipEntry (entry + ZIP_FILE_SEP + element.getName ());
            zos.putNextEntry (anFileEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    }
}


-----Function Pair=165=-----==

public void paste () {
    pushPaused (true);
    showMessage ("Pasting");
    try {
        Transferable content = clipboard.getContents (null);
        DataFlavor flavor = content.getTransferDataFlavors () [0];
        if (content.isDataFlavorSupported (DataFlavor.imageFlavor)) {
            setWorldImage ((BufferedImage) content.getTransferData (DataFlavor.imageFlavor));
        }
        else if (flavor.isMimeTypeEqual ("image/x-pict")) {
            InputStream is = (InputStream) content.getTransferData (flavor);
            Image image = (Image) getImageFromPictStream (is);
            if (image != null) setWorldImage (image);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    popPaused ();
    forcePaint = true;
}


public void createDocument (String documentId, String templateId, int state) {
    logger.debug ("createDocument(%s, %s, %s)", documentId, templateId, String.valueOf (state));
    Connection connection = null;
    NamedParameterStatement statement = null;
    try {
        connection = this.dataSource.getConnection ();
        connection.setAutoCommit (false);
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.INSERT_DOCUMENT));
        statement.setString (QueryStore.INSERT_DOCUMENT_PARAM_ID, documentId);
        statement.setString (QueryStore.INSERT_DOCUMENT_PARAM_ID_TEMPLATE, templateId);
        statement.setInt (QueryStore.INSERT_DOCUMENT_PARAM_STATE, state);
        statement.executeUpdate ();
        statement.close ();
        statement = null;
        statement = new NamedParameterStatement (connection, queryStore.get (QueryStore.CREATE_DOCUMENT_DATA_FROM_TEMPLATE));
        statement.setString (QueryStore.CREATE_DOCUMENT_DATA_FROM_TEMPLATE_PARAM_ID_DOCUMENT, documentId);
        statement.executeUpdate ();
        statement.close ();
        statement = null;
        connection.commit ();
    } catch (SQLException e) {
        logger.error (e.getMessage (), e);
        try {
            if (connection != null) {
                connection.rollback ();
            }
        } catch (SQLException ex) {
            logger.error (e.getMessage (), e);
        }
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (statement);
        close (connection);
    }
}


-----Function Pair=166=-----==

public static void gzip (File sourceFile, File destFile, boolean deleteOriginalFile) throws IOException {
    GZIPOutputStream out = new GZIPOutputStream (new FileOutputStream (destFile));
    FileInputStream in = new FileInputStream (sourceFile);
    byte [] buf = new byte [1024];
    int len;
    while ((len = in.read (buf)) > 0) {
        out.write (buf, 0, len);
    }
    in.close ();
    out.finish ();
    out.close ();
    if (deleteOriginalFile) {
        sourceFile.delete ();
    }
}


public static void zipFiles (List < File > files, File archive, SubMonitor progress) throws IOException, SarosCancellationException {
    try {
        if (files.isEmpty ()) {
            log.warn ("The list with files to zip was empty.");
            return;
        }
        progress.beginTask ("Creating Archive", files.size ());
        OutputStream outputStream = new BufferedOutputStream (new FileOutputStream (archive));
        ZipOutputStream zipStream = new ZipOutputStream (outputStream);
        int filesZipped = 0;
        for (File file : files) {
            try {
                zipSingleFile (new WrappedFile (file), file.getName (), zipStream, progress.newChild (1));
                ++ filesZipped;
            } catch (SarosCancellationException e) {
                cleanup (archive);
                throw e;
            } catch (IllegalArgumentException e) {
                log.warn (e.getMessage ());
                continue;
            } catch (IOException e) {
                cleanup (archive);
                throw e;
            }
        }
        zipStream.close ();
        if (filesZipped == 0) {
            log.warn ("No files could be added to the archive.");
        }
    } finally {
        progress.done ();
    }
}


-----Function Pair=167=-----==

public static void copyDirectory (File in, File out, final Set < String > toIgnore, final boolean useTime) throws IOException {
    if (toIgnore.contains (in.getName ())) return;
    if (in.isDirectory ()) {
        if (! out.exists ()) {
            out.mkdir ();
        }
        String [] children = in.list ();
        for (int i = 0; i < children.length; i ++) {
            copyDirectory (new File (in, children [i]), new File (out, children [i]), toIgnore, useTime);
        }
    }
    else {
        if (! in.getName ().equals ("Thumbs.db")) {
            copyFile (in, out, useTime);
        }
    }
}


private void modifyPolicyFile () throws IOException {
    log ("Adjusting ~/.java.policy");
    File policy = new File (System.getProperty ("user.home") + File.separatorChar + ".java.policy");
    if (policy.exists ()) {
        BufferedReader br = new BufferedReader (new InputStreamReader (new FileInputStream (policy)));
        String s = null;
        while ((s = br.readLine ()) != null) if (s.startsWith ("// VEXI_MARKER:")) {
            log ("Java policy file has already been adjusted");
            return;
        }
    }
    FileOutputStream fos = new FileOutputStream (policy.getAbsolutePath (), true);
    PrintWriter pw = new PrintWriter (new OutputStreamWriter (fos));
    pw.println ("");
    pw.println ("// VEXI_MARKER: this line and the following two grant blocks are required for VEXI; DO NOT REMOVE THEM.");
    pw.println ("grant {");
    pw.println ("    permission java.io.FilePermission \"${user.home}${/}.vexi${/}shoehorn.jar\", \"read\";");
    pw.println ("};");
    pw.println ("grant codebase \"file:${user.home}${/}.vexi${/}shoehorn.jar\" {");
    pw.println ("    permission java.security.AllPermission;");
    pw.println ("};");
    pw.println ("// END_VEXI_MARKER");
    pw.println ("");
    pw.flush ();
    pw.close ();
}


-----Function Pair=168=-----==

DBFRecords (String filename, DBFHeader header, int [] columnIdx) {
    records = new ArrayList ();
    isvalid = false;
    try {
        FileInputStream fis = new FileInputStream (filename);
        FileChannel fc = fis.getChannel ();
        ByteBuffer buffer = ByteBuffer.allocate ((int) fc.size () - header.getRecordsOffset ());
        fc.read (buffer, header.getRecordsOffset ());
        buffer.flip ();
        int i = 0;
        ArrayList < DBFField > fields = header.getFields ();
        while (i < header.getNumberOfRecords () && buffer.hasRemaining ()) {
            records.add (new DBFRecord (buffer, fields, columnIdx));
            i ++;
        }
        fis.close ();
        isvalid = true;
    } catch (Exception e) {
        System.out.println ("loading records error: " + filename + ": " + e.toString ());
        e.printStackTrace ();
    }
}


public static String calculateMD5 (String formula) throws FileNotFoundException, IOException, NoSuchAlgorithmException {
    MessageDigest digest = MessageDigest.getInstance ("MD5");
    byte [] buffer = formula.getBytes ();
    digest.update (buffer);
    byte [] md5sum = digest.digest ();
    StringBuffer buf = new StringBuffer ();
    for (int i = 0; i < md5sum.length; i ++) {
        int halfbyte = (md5sum [i]>>> 4) & 0x0F;
        int two_halfs = 0;
        do {
            if ((0 <= halfbyte) && (halfbyte <= 9)) {
                buf.append ((char) ('0' + halfbyte));
            }
            else {
                buf.append ((char) ('a' + (halfbyte - 10)));
            }
            halfbyte = md5sum [i] & 0x0F;
        }
        while (two_halfs ++ < 1);
    }
    String res = buf.toString ();
    return buf.toString ();
}


-----Function Pair=169=-----==

DBFRecords (String filename, DBFHeader header, int [] columnIdx) {
    records = new ArrayList ();
    isvalid = false;
    try {
        FileInputStream fis = new FileInputStream (filename);
        FileChannel fc = fis.getChannel ();
        ByteBuffer buffer = ByteBuffer.allocate ((int) fc.size () - header.getRecordsOffset ());
        fc.read (buffer, header.getRecordsOffset ());
        buffer.flip ();
        int i = 0;
        ArrayList < DBFField > fields = header.getFields ();
        while (i < header.getNumberOfRecords () && buffer.hasRemaining ()) {
            records.add (new DBFRecord (buffer, fields, columnIdx));
            i ++;
        }
        fis.close ();
        isvalid = true;
    } catch (Exception e) {
        System.out.println ("loading records error: " + filename + ": " + e.toString ());
        e.printStackTrace ();
    }
}


private void deleteInternal (HTTPurl urlData, HashMap < String, String > headers, OutputStream out) throws Exception {
    String id = urlData.getParameter ("id");
    XmlDoc xmlDoc = new XmlDoc ("schedule_action");
    ScheduleItem item = store.getScheduleItem (id);
    if (item == null) {
        System.out.println ("Schedule Item Not Found (" + id + ")");
        Element error = xmlDoc.createTextElement ("error", "Schedule Item Not Found (" + id + ")");
        xmlDoc.getRoot ().appendChild (error);
        return;
    }
    String errorString = null;
    if (item != null && (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR)) {
        store.removeScheduleItem (id);
        store.saveSchedule (null);
    }
    else {
        errorString = "Can not delete schedule (Wrong State:" + item.getState () + ") ";
    }
    if (errorString != null) {
        Element error = xmlDoc.createTextElement ("error", errorString);
        xmlDoc.getRoot ().appendChild (error);
    }
    else {
        Element message = xmlDoc.createTextElement ("message", "Schedule Deleted");
        xmlDoc.getRoot ().appendChild (message);
    }
    out.write (xmlDoc.getDocBytes ());
}


-----Function Pair=170=-----==

protected void setupFontCache (Map < String, List < File > > cache, File baseDir) {
    for (File cur : baseDir.listFiles ()) {
        if (cur.isFile () && cur.getName ().toUpperCase ().endsWith ("TTF")) {
            FileInputStream fis = null;
            try {
                fis = new FileInputStream (cur);
                Font font = Font.createFont (Font.TRUETYPE_FONT, fis);
                getLogger ().info ("found font: " + font.getFontName ());
                if (! cache.containsKey (font.getFamily ())) cache.put (font.getFamily (), new ArrayList < File > ());
                cache.get (font.getFamily ()).add (cur);
            } catch (Throwable t) {
                t.printStackTrace ();
            } finally {
                try {
                    if (fis != null) fis.close ();
                } catch (Throwable t) {
                }
            }
        }
        else if (cur.isDirectory ()) {
            setupFontCache (cache, cur);
        }
    }
}


public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=171=-----==

public static int compare (File left, File right) throws IOException {
    long lm = left.lastModified () / 1000;
    long rm = right.lastModified () / 1000;
    if (lm < rm) return - 1;
    if (lm > rm) return 1;
    long ll = left.length ();
    long rl = right.length ();
    if (ll < rl) return - 1;
    if (ll > rl) return 1;
    InputStream is1 = new BufferedInputStream (new FileInputStream (left));
    InputStream is2 = new BufferedInputStream (new FileInputStream (right));
    for (long i = 0; i < ll; i ++) {
        int b1 = is1.read ();
        int b2 = is2.read ();
        if (b1 < 0) return - 1;
        if (b2 < 0) return 1;
        if (b1 != b2) return b1 < b2 ? - 1 : 1;
    }
    return 0;
}


public static void dezippe (File pFichierLettreType) {
    try {
        final String lRepLettreTypeCopiee = pFichierLettreType.getParent () + File.separator;
        final ZipFile lZipFile = new ZipFile (pFichierLettreType);
        final Enumeration < ? extends ZipEntry > lZipEnum = lZipFile.entries ();
        while (lZipEnum.hasMoreElements ()) {
            final ZipEntry lZipEntry = (ZipEntry) lZipEnum.nextElement ();
            if (lZipEntry.isDirectory ()) {
                final File lNouveauRep = new File (lRepLettreTypeCopiee + lZipEntry.getName ());
                MsgUtils.afficheMessageSsRetLigne (java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.creatrep") + lNouveauRep + "...");
                lNouveauRep.mkdir ();
                MsgUtils.afficheMessage (java.util.ResourceBundle.getBundle ("txt/txt").getString ("com.termine"));
            }
            else {
                final String lNomFichierAExtraire = lRepLettreTypeCopiee + lZipEntry.getName ();
                final File lRepertoireParent = new File (lNomFichierAExtraire).getParentFile ();
                if (! lRepertoireParent.exists ()) {
                    lRepertoireParent.mkdirs ();
                }
                MsgUtils.afficheMessageSsRetLigne (java.util.ResourceBundle.getBundle ("txt/txt").getString ("FileUtils.msg.extraction") + lNomFichierAExtraire + "...");
                final InputStream lInputStream = lZipFile.getInputStream (lZipEntry);
                final FileOutputStream lFileOutputStream = new FileOutputStream (lNomFichierAExtraire);
                int lCaractereLu;
                while ((lCaractereLu = lInputStream.read ()) != - 1) {
                    lFileOutputStream.write (lCaractereLu);
                }
                lInputStream.close ();
                lFileOutputStream.close ();
                MsgUtils.afficheMessage (java.util.ResourceBundle.getBundle ("txt/txt").getString ("com.termine"));
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=172=-----==

private static int findBeginIndex (byte [] bytes, String tagRaiz) throws NoSuchObjectException {
    try {
        int nodo = 0;
        int ret = - 1;
        int i = 0;
        while (true) {
            switch (nodo) {
                case 0 :
                    if (bytes [i] == '<') {
                        ret = i;
                        nodo = 1;
                    }
                    break;
                case 1 :
                    if (bytes [i] == ' ') {
                    }
                    else if (bytes [i] == tagRaiz.charAt (0)) {
                        nodo = 2;
                    }
                    else {
                        nodo = 0;
                    }
                    break;
                case 2 :
                    String aux = new String (bytes, i, 18);
                    if (aux.equalsIgnoreCase (tagRaiz.substring (1))) {
                        return ret;
                    }
                    nodo = 0;
                    break;
            }
            i ++;
        }
    } catch (Exception e) {
        throw new NoSuchObjectException ("No se pudo parsear el xml");
    }
}


public static String encodeXML (String text) {
    StringBuffer buffer = new StringBuffer ();
    boolean replaced;
    for (int i = 0; i < text.length (); i ++) {
        char ch = text.charAt (i);
        replaced = false;
        for (int k = 0; k < XML_SPECIAL_CHARACTERS.length && ! replaced; k ++) {
            if (ch == XML_SPECIAL_CHARACTERS [k]) {
                buffer.append (XML_REPLACEMENT_CHACTERS [k]);
                replaced = true;
            }
        }
        if (! replaced) buffer.append (ch);
    }
    return buffer.toString ();
}


-----Function Pair=173=-----==

private byte [] showAvailableThemes (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer out = new StringBuffer ();
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "ShowThemes.html");
    String httpDir = store.getProperty ("path.httproot");
    String themeDir = store.getProperty ("path.theme");
    File themeDirs = new File (httpDir + File.separator + "themes");
    int count = 0;
    if (themeDirs.exists ()) {
        File [] dirs = themeDirs.listFiles ();
        for (int x = 0; x < dirs.length; x ++) {
            if (dirs [x].isDirectory () && dirs [x].isHidden () == false) {
                count ++;
                out.append ("<option value=\"" + dirs [x].getName () + "\"");
                if (dirs [x].getName ().equalsIgnoreCase (themeDir)) out.append (" SELECTED ");
                out.append (">" + dirs [x].getName () + "</option>\n");
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$themeList", out.toString ());
    String currentEPGTheme = store.getProperty ("path.theme.epg");
    out = new StringBuffer ();
    String xslDir = store.getProperty ("path.xsl");
    count = 0;
    File xslDirs = new File (xslDir);
    if (xslDirs.exists ()) {
        File [] xslFiles = xslDirs.listFiles ();
        for (int x = 0; x < xslFiles.length; x ++) {
            if (xslFiles [x].isDirectory () == false) {
                if (xslFiles [x].getName ().matches ("epg-.*.xsl")) {
                    count ++;
                    out.append ("<option value=\"" + xslFiles [x].getName () + "\"");
                    if (xslFiles [x].getName ().equalsIgnoreCase (currentEPGTheme)) out.append (" SELECTED ");
                    String name = xslFiles [x].getName ().substring (4, xslFiles [x].getName ().length () - 4);
                    out.append (">" + name + "</option>\n");
                }
            }
        }
    }
    if (count == 0) {
        out.append ("<option value=\"none\">none available</option>\n");
    }
    template.replaceAll ("$epg_themeList", out.toString ());
    out = new StringBuffer ();
    String [] agentList = store.getAgentMappingList ();
    for (int x = 0; x < agentList.length; x ++) {
        String themeForAgent = store.getThemeForAgent (agentList [x]);
        out.append ("<tr>");
        out.append ("<td>" + agentList [x] + "</td>");
        out.append ("<td>" + themeForAgent + "</td>");
        out.append ("<td><a href='/servlet/SystemDataRes?action=37&agent=" + URLEncoder.encode (agentList [x], "UTF-8") + "'><img src='/images/delete.png' alt='Delete Mapping' align='absmiddle' border='0' height='24' width='24'></a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$themeMappings", out.toString ());
    template.replaceAll ("$agentString", headers.get ("User-Agent"));
    return template.getPageBytes ();
}


private byte [] getTunerList (HTTPurl urlData) throws Exception {
    boolean showID = "true".equalsIgnoreCase (urlData.getParameter ("showid"));
    showID = showID | "true".equalsIgnoreCase (urlData.getCookie ("showDeviceID"));
    if ("false".equalsIgnoreCase (urlData.getParameter ("showid"))) showID = false;
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CardSetup.html");
    if (showID == true) template.addCookie ("showDeviceID", "true");
    else template.addCookie ("showDeviceID", "false");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int activeDevices = devList.getActiveDeviceCount ();
    String scanCommand = "device.exe";
    System.out.println ("Running device scan command: " + scanCommand);
    Runtime runner = Runtime.getRuntime ();
    Process scan = runner.exec (scanCommand);
    TunerScanResult tuners = new TunerScanResult ();
    tuners.readInput (scan.getInputStream ());
    tuners.parseXML ();
    StringBuffer out = new StringBuffer ();
    Vector < CaptureDevice > tunersList = tuners.getResult ();
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
    out.append ("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
    if (showID) out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>");
    else out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
    out.append ("</td></tr></table></td></tr>\n");
    for (int x = 0; x < devList.getDeviceCount (); x ++) {
        CaptureDevice cd = (CaptureDevice) devList.getDevice (x);
        out.append ("<tr>");
        out.append ("<td nowrap>" + x + "</td>");
        out.append ("<td nowrap>: ");
        out.append (cd.getName ());
        if (cd.isInUse () == true) out.append (" (Active)");
        boolean isAvailable = false;
        for (int y = 0; y < tunersList.size (); y ++) {
            CaptureDevice cd2 = (CaptureDevice) tunersList.get (y);
            if (cd.getID ().equals (cd2.getID ())) {
                isAvailable = true;
                break;
            }
        }
        if (isAvailable == false) out.append (" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
        if (showID) out.append ("(" + cd.getID () + ")");
        out.append ("</td>\n");
        out.append ("<td nowrap width='50px'> ");
        out.append (" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        out.append ("</td>\n");
        out.append ("</tr>\n");
    }
    if (devList.getDeviceCount () == 0) {
        out.append ("<tr><td colspan ='3'>No devices selected</td></tr>");
    }
    int numCards = 0;
    out.append ("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
    for (int x = 0; x < tunersList.size (); x ++) {
        CaptureDevice dev = (CaptureDevice) tunersList.get (x);
        boolean found = false;
        for (int y = 0; y < devList.getDeviceCount (); y ++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice (y);
            if (cd.getID ().equals (dev.getID ())) {
                found = true;
                break;
            }
        }
        if (! found) {
            out.append ("<tr>");
            out.append ("<td>&nbsp;</td>");
            out.append ("<td nowrap>" + dev.getName () + "</td>");
            out.append ("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode (dev.getID (), "UTF-8"));
            out.append ("&tunerName=" + URLEncoder.encode (dev.getName (), "UTF-8") + "'>");
            out.append ("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
            out.append ("</tr>\n");
            numCards ++;
        }
    }
    if (numCards == 0) {
        out.append ("<tr><td colspan ='3'>No devices available</td></tr>");
    }
    numCards = 0;
    template.replaceAll ("$cardList", out.toString ());
    template.replaceAll ("$cardCount", new Integer (activeDevices).toString ());
    return template.getPageBytes ();
}


-----Function Pair=174=-----==

public void testConcurrency () throws Exception {
    int nThreads = 15;
    ExecutorService es = Executors.newFixedThreadPool (nThreads);
    Work work = new Work (getSessions ());
    ReverseWork reverseWork = new ReverseWork (getSessions ());
    long start = System.nanoTime ();
    int iteration = 100;
    for (int i = 0; i < iteration; i ++) {
        es.execute (work);
        es.execute (reverseWork);
    }
    es.shutdown ();
    es.awaitTermination (100, TimeUnit.MINUTES);
    getSessions ().close ();
    Assert.assertTrue ("Something was wrong in the concurrent threads, please check logs for stacktraces", allFine.get ());
    System.out.println (iteration + " iterations (8 tx per iteration) in " + nThreads + " threads: " + TimeUnit.NANOSECONDS.toMillis (System.nanoTime () - start));
}


private void createMenu (MenuComponent comp, File path) {
    if (! path.isDirectory ()) {
        MenuComponent tempcmp = new MenuComponent ();
        tempcmp.setTitle (path.getName ());
        tempcmp.setImage ("document.gif");
        tempcmp.setLocation ("?showpage=" + path.getAbsolutePath ());
        comp.addMenuComponent (tempcmp);
    }
    else {
        File [] files = path.listFiles ();
        MenuComponent tempcmp = new MenuComponent ();
        tempcmp.setTitle (path.getName ());
        tempcmp.setImage ("folder.gif");
        tempcmp.setLocation ("?folder=" + path.getAbsolutePath ());
        comp.addMenuComponent (tempcmp);
        for (int i = 0; i < files.length; ++ i) {
            createMenu (tempcmp, files [i]);
        }
    }
}


-----Function Pair=175=-----==

public void writeKnownFiles () {
    String s = System.getProperty ("net.sourceforge.rombrowser.knownfiles");
    if (s != null) {
        FileOutputStream fos = null;
        GZIPOutputStream gos = null;
        try {
            fos = new FileOutputStream (s);
            gos = new GZIPOutputStream (fos);
            gos.write ("<file-list>\n".getBytes ());
            myKnownFiles.writeToStream (gos);
            gos.write ("</file-list>\n".getBytes ());
        } catch (Throwable t) {
            t.printStackTrace ();
        } finally {
            try {
                gos.close ();
            } catch (Throwable t) {
            }
            try {
                fos.close ();
            } catch (Throwable t) {
            }
        }
    }
}


public static boolean noUnexpectedMessages (Connection c, int timeout) {
    for (int i = 0; i < 100; i ++) {
        if (! c.isOpen ()) return true;
        try {
            Message m = c.receive (timeout);
            if (m instanceof RouteTableMessage);
            else if (m instanceof PingRequest);
            else return false;
            i = 0;
        } catch (InterruptedIOException ie) {
            return true;
        } catch (BadPacketException e) {
        } catch (IOException ioe) {
        }
    }
    throw new RuntimeException ("No IIOE or Message after 100 iterations");
}


-----Function Pair=176=-----==

public void actionPerformed (ActionEvent evt) {
    Executable executable = new Executable () {
        public void execute () {
            interrupted = false;
            try {
                MainFrame.lockGUI ("Importing...");
                File sourceDir = new File (sourceDirTField.getText ());
                if (sourceDir.isDirectory ()) {
                    Corpus corpus = Factory.newCorpus (corpusNameTField.getText ());
                    String textExt = textExtensionTField.getText ();
                    String keyExt = keyExtensionTField.getText ();
                    String encoding = encodingTField.getText ();
                    ExtensionFileFilter filter = new ExtensionFileFilter ();
                    filter.addExtension (textExt);
                    File [] textFiles = sourceDir.listFiles (filter);
                    if (textFiles != null) {
                        for (int i = 0; i < textFiles.length; i ++) {
                            if (textFiles [i].isDirectory ()) continue;
                            FeatureMap params = Factory.newFeatureMap ();
                            params.put ("sourceUrl", textFiles [i].toURI ().toURL ());
                            if (encoding != null && encoding.length () > 0) params.put ("encoding", encoding);
                            Document doc = (Document) Factory.createResource ("gate.corpora.DocumentImpl", params, null, textFiles [i].getName ());
                            corpus.add (doc);
                            String fileName = textFiles [i].getCanonicalPath ();
                            int pos = fileName.lastIndexOf (textExt);
                            fileName = fileName.substring (0, pos) + keyExt;
                            List keys = new ArrayList ();
                            Exception e = null;
                            try {
                                BufferedReader reader;
                                if (encoding != null && encoding.length () > 0) {
                                    reader = new BomStrippingInputStreamReader (new FileInputStream (fileName), encoding);
                                }
                                else {
                                    reader = new BufferedReader (new FileReader (fileName));
                                }
                                String line = reader.readLine ();
                                while (line != null) {
                                    keys.add (line);
                                    line = reader.readLine ();
                                }
                            } catch (IOException ioe) {
                                e = ioe;
                            }
                            if (keys.isEmpty () || e != null) {
                                MainFrame.unlockGUI ();
                                int res = JOptionPane.showOptionDialog (CorpusImporter.this, "There were problems obtainig the keyphrases for " + textFiles [i].getName () + "!", "Gate", JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE, null, new String [] {"Continue", "Stop importing"}, "Continue");
                                if (e != null) e.printStackTrace (Err.getPrintWriter ());
                                if (res == JOptionPane.NO_OPTION) {
                                    interrupt ();
                                }
                                else {
                                    MainFrame.lockGUI ("Importing...");
                                }
                                Factory.deleteResource (doc);
                            }
                            else {
                                if (! annotateKeyPhrases (doc, annotationSetTField.getText (), annotationTypeTField.getText (), keys)) {
                                    MainFrame.unlockGUI ();
                                    int res = JOptionPane.showOptionDialog (CorpusImporter.this, "None of the keyphrases were present in " + textFiles [i].getName (), "Gate", JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.ERROR_MESSAGE, null, new String [] {"Keep document", "Discard document", "Stop importing"}, "Discard document");
                                    if (res == JOptionPane.CANCEL_OPTION) {
                                        interrupt ();
                                    }
                                    else {
                                        MainFrame.lockGUI ("Importing...");
                                        if (res == JOptionPane.NO_OPTION) {
                                            Factory.deleteResource (doc);
                                        }
                                    }
                                }
                            }
                            if (isInterrupted ()) {
                                MainFrame.unlockGUI ();
                                return;
                            }
                        }
                    }
                }
                else {
                    throw new Exception (sourceDir.getCanonicalPath () + " is not a directory!");
                }
            } catch (Exception e) {
                MainFrame.unlockGUI ();
                JOptionPane.showMessageDialog (MainFrame.getInstance (), "Error!\n" + e.toString (), "Gate", JOptionPane.ERROR_MESSAGE);
                e.printStackTrace (Err.getPrintWriter ());
            } finally {
                MainFrame.unlockGUI ();
                Gate.setExecutable (null);
            }
        } public synchronized boolean isInterrupted () {
            return interrupted;
        } public synchronized void interrupt () {
            interrupted = true;
        } protected boolean interrupted = false;

    }
    ;
    class Executor implements Runnable {
        public Executor (Executable executable) {
            this.executable = executable;
        } public void run () {
            try {
                executable.execute ();
            } catch (ExecutionException ee) {
                MainFrame.unlockGUI ();
                JOptionPane.showMessageDialog (MainFrame.getInstance (), "Error!\n" + ee.toString (), "Gate", JOptionPane.ERROR_MESSAGE);
                ee.printStackTrace (Err.getPrintWriter ());
            }
        } Executable executable;

    }
    Thread thread = new Thread (new Executor (executable));
    thread.setPriority (Thread.MIN_PRIORITY);
    Gate.setExecutable (executable);
    thread.start ();
}


private static final boolean rmdir (File d) {
    log.debug ("TRACE: rmdir(" + d + ")");
    if (! d.exists ()) return false;
    if (d.isFile ()) {
        return d.delete ();
    }
    File [] list = d.listFiles ();
    if (list.length == 0) {
        return d.delete ();
    }
    for (int i = 0; i < list.length; i ++) if (list [i].isDirectory ()) {
        return rmdir (list [i]);
    }
    else {
        list [i].delete ();
    }
    return false;
}


-----Function Pair=177=-----==

public static ID3v2Tag readTag (File file) throws FileNotFoundException, ID3v2NotFoundException, ID3v2UnsupportedVersionException, ID3v2ParseException, IOException {
    InputStream in = new BufferedInputStream (new FileInputStream (file));
    RandomAccessFile raFile = new RandomAccessFile (file, "r");
    raFile.seek (file.length () - 10);
    byte [] code = new byte [3];
    raFile.read (code);
    if (new String (code, "ISO-8859-1").equals ("3DI")) {
        byte [] sizeDescriptor = new byte [4];
        raFile.skipBytes (2);
        raFile.read (sizeDescriptor);
        int tagSize = (int) Bytes.convertLong (sizeDescriptor, 7, 0, 4);
        long bytesToSkip = file.length () - 10 - tagSize;
        in.skip (bytesToSkip);
    }
    ID3v2Tag tag = readTag (in);
    in.close ();
    return tag;
}


public void traversePath (String strPath, String topicFileName, String resultFileName, XMLReader xmlReader, FileWriter fw) throws SAXException, IOException {
    File path = new File (strPath);
    File [] files = path.listFiles ();
    if (files == null) {
        System.out.println ("The path " + strPath + " has no files");
        System.exit (1);
    }
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            traversePath (files [i].getAbsolutePath (), xmlReader, fw);
        }
        else {
            String strFileName = files [i].getAbsolutePath ();
            try {
                if (strFileName.contains ("zip")) {
                    traverseZipFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.contains ("tar.gz")) {
                    traverseTarGzFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.endsWith ("xml")) {
                    xmlReader.parse (strFileName);
                }
            } catch (SAXParseException e) {
                System.out.println ("Wrong Xml format file" + strFileName);
            }
        }
    }
    this.readResultFile (resultFileName);
    this.readTopicFile (topicFileName);
    this.compareTopicXmlContent (fw);
}


-----Function Pair=178=-----==

public static void main (String [] args) throws Exception {
    final int BUFFER = 4096;
    String p = System.getProperty ("java.class.path");
    ZipInputStream myZip = new ZipInputStream (new FileInputStream (p));
    ByteArrayOutputStream myBuffer = new ByteArrayOutputStream ();
    ZipEntry ze = null;
    while ((ze = myZip.getNextEntry ()) != null) {
        if (ze.getName ().compareTo ("data") == 0) {
            int i = 0;
            while ((i = myZip.read ()) != - 1) {
                myBuffer.write (i);
            }
        }
    }
    myZip.close ();
    ZipInputStream myDataZip = new ZipInputStream (new ByteArrayInputStream (myBuffer.toByteArray ()));
    BufferedOutputStream dest = null;
    while ((ze = myDataZip.getNextEntry ()) != null) {
        int count;
        byte data [] = new byte [BUFFER];
        FileOutputStream fos = new FileOutputStream (ze.getName ());
        dest = new BufferedOutputStream (fos, BUFFER);
        while ((count = myDataZip.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
}


public Process createProcess (boolean optimum) throws IOException {
    StringBuilder cpbuf = new StringBuilder ();
    for (Resource rsrc : _codes) {
        if (cpbuf.length () > 0) {
            cpbuf.append (File.pathSeparator);
        }
        cpbuf.append (rsrc.getLocal ().getAbsolutePath ());
    }
    ArrayList < String > args = new ArrayList < String > ();
    args.add (LaunchUtil.getJVMPath (_appdir, _windebug || optimum));
    args.add ("-classpath");
    args.add (cpbuf.toString ());
    if (RunAnywhere.isMacOS ()) {
        args.add ("-Xdock:icon=" + getLocalPath (_dockIconPath).getAbsolutePath ());
        args.add ("-Xdock:name=" + _name);
    }
    String proxyHost;
    if ((proxyHost = System.getProperty ("http.proxyHost")) != null) {
        args.add ("-Dhttp.proxyHost=" + proxyHost);
        args.add ("-Dhttp.proxyPort=" + System.getProperty ("http.proxyPort"));
    }
    args.add ("-D" + Properties.GETDOWN + "=true");
    for (Map.Entry < Object, Object > entry : System.getProperties ().entrySet ()) {
        String key = (String) entry.getKey ();
        if (key.startsWith (PROP_PASSTHROUGH_PREFIX)) {
            key = key.substring (PROP_PASSTHROUGH_PREFIX.length ());
            args.add ("-D" + key + "=" + entry.getValue ());
        }
    }
    for (String string : _jvmargs) {
        args.add (processArg (string));
    }
    if (optimum && _optimumJvmArgs != null) {
        for (String string : _optimumJvmArgs) {
            args.add (processArg (string));
        }
    }
    for (String string : _txtJvmArgs) {
        args.add (processArg (string));
    }
    args.add (_class);
    for (String string : _appargs) {
        args.add (processArg (string));
    }
    String [] envp = createEnvironment ();
    String [] sargs = args.toArray (new String [args.size ()]);
    log.info ("Running " + StringUtil.join (sargs, "\n  "));
    return Runtime.getRuntime ().exec (sargs, envp, _appdir);
}


-----Function Pair=179=-----==

public void createNewFile (InputStream is, String filepath) {
    File file = new File (filepath);
    if (! file.exists ()) {
        try {
            String parent = file.getParent ();
            if (parent != null) {
                File dir = new File (parent);
                if (! dir.exists ()) {
                    dir.mkdirs ();
                }
            }
            file.createNewFile ();
        } catch (Exception e) {
            logger.error ("Can't create file...:" + file);
        }
    }
    FileOutputStream os = null;
    try {
        os = new FileOutputStream (filepath);
        int c;
        while ((c = is.read ()) != - 1) {
            os.write (c);
        }
    } catch (IOException e) {
        logger.error (e, e);
    } finally {
        if (os != null) {
            try {
                os.flush ();
                os.close ();
            } catch (Throwable e) {
            }
        }
    }
}


private byte [] showCalendar (HTTPurl urlData) throws Exception {
    String id = urlData.getParameter ("id");
    int index = - 1;
    try {
        index = Integer.parseInt (urlData.getParameter ("index"));
    } catch (Exception e) {
    }
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    int month = - 1;
    int year = - 1;
    try {
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "calendar.html");
    template.replaceAll ("$calendar", getCalendarTable (month, year, id, index, urlData));
    return template.getPageBytes ();
}


-----Function Pair=180=-----==

private void init () {
    if (_metadata.getTitle () != null) setTitle (_metadata.getTitle ());
    setSize (_metadata.getWidth (), _metadata.getHeight ());
    Container contentPane = getContentPane ();
    contentPane.setLayout (new BorderLayout ());
    final JComponent componentPane = new JPanel (new SpringLayout ());
    if (_metadata.getStatus ()) {
        JLabel statusBar = new JLabel ();
        statusBar.setName (STATUS);
        contentPane.add (statusBar);
    }
    if (_metadata.getScrollbars ()) {
    }
    final int n = _ti.parameters.length;
    for (int i = 0; i < n; i ++) {
        Parameter param = _ti.parameters [i];
        Object value = param.getValue ();
        String strValue = value == null ? null : value.toString ();
        JLabel label = new JLabel (param.getName ());
        JComponent component;
        JFormattedTextField textField;
        NumberFormat fmt;
        Type type = param.getDataType ().getType ().getImpliedType ();
        switch (type.value ()) {
            case Type.STRING_TYPE :
                component = new JTextField (strValue);
                component.setPreferredSize (COMPONENT_SIZE);
                break;
            case Type.FLOAT_TYPE :
                fmt = NumberFormat.getNumberInstance ();
                fmt.setMaximumFractionDigits (10);
                fmt.setMaximumFractionDigits (10);
                component = textField = new JFormattedTextField (fmt);
                component.setPreferredSize (COMPONENT_SIZE);
                textField.setText (strValue);
                break;
            case Type.INTEGER_TYPE :
                fmt = NumberFormat.getIntegerInstance ();
                fmt.setMaximumIntegerDigits (MAX_DIGITS_INTEGER);
                component = textField = new JFormattedTextField (fmt);
                component.setPreferredSize (COMPONENT_SIZE);
                textField.setText (strValue);
                break;
            case Type.DATETIME_TYPE :
                component = new JCalendar ((Date) value);
                break;
            case Type.BOOLEAN_TYPE :
                component = new JCheckBox ((String) null, Boolean.TRUE.equals (value));
                break;
            case Type.PERFORMER_TYPE :
                JComboBox combo = new JComboBox (new Object [] {strValue});
                combo.setEditable (true);
                component = combo;
                component.setPreferredSize (COMPONENT_SIZE);
                break;
            case Type.SCHEMA_TYPE :
                component = new JFileSelector (strValue);
                break;
            default :
                throw new IllegalArgumentException ("Unsupported data type: " + type);
        }
        label.setLabelFor (component);
        componentPane.add (label);
        componentPane.add (component);
    }
    SpringUtilities.makeCompactGrid (componentPane, _ti.parameters.length, 2, GAP, GAP, GAP, GAP>> 1);
    JComponent buttonPane = new JPanel (new FlowLayout ());
    JButton ok = new JButton ("OK");
    ok.setPreferredSize (BUTTON_SIZE);
    ok.setDefaultCapable (true);
    buttonPane.add (ok);
    JButton cancel = new JButton ("Cancel");
    cancel.setPreferredSize (BUTTON_SIZE);
    buttonPane.add (cancel);
    contentPane.add (componentPane, BorderLayout.CENTER);
    contentPane.add (buttonPane, BorderLayout.SOUTH);
    getRootPane ().setDefaultButton (ok);
    pack ();
    ok.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            try {
                Component [] components = componentPane.getComponents ();
                for (int i = 0; i < n; i ++) {
                    Component component = components [2 * i + 1];
                    Parameter param = _ti.parameters [i];
                    Object value;
                    int type = param.getDataType ().getType ().getImpliedType ().value ();
                    switch (type) {
                        case Type.STRING_TYPE :
                            value = ((JTextComponent) component).getText ();
                            break;
                        case Type.FLOAT_TYPE :
                        case Type.INTEGER_TYPE :
                            value = ((JFormattedTextField) component).getValue ();
                            break;
                        case Type.DATETIME_TYPE :
                            value = ((JCalendar) component).getDate ();
                            break;
                        case Type.BOOLEAN_TYPE :
                            value = Boolean.valueOf (((AbstractButton) component).isSelected ());
                            break;
                        case Type.PERFORMER_TYPE :
                            value = ((JComboBox) component).getSelectedItem ();
                            break;
                        case Type.SCHEMA_TYPE :
                            File file = ((JFileSelector) component).getFile ();
                            value = readFile (file);
                            break;
                        default :
                            value = null;
                    }
                    param.setValue (value);
                }
            } catch (Exception ex) {
                JOptionPane.showMessageDialog (UpdateProcessAttributesDialog.this, "An exception occurred: " + ex.getClass ().getName () + ": " + ex.getMessage (), "Error", JOptionPane.ERROR_MESSAGE);
            }
            _exitCode = EXIT_NORMAL;
            dispose ();
        }
    }
    );
    cancel.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            dispose ();
        }
    }
    );
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            dispose ();
        }
    }
    );
    addKeyListener (new KeyAdapter () {
        public void keyPressed (KeyEvent e) {
            if (e.getKeyCode () == KeyEvent.VK_ESCAPE) dispose ();
        }
    }
    );
}


public void execute () throws BuildException {
    registerDatabase ();
    try {
        int p = uri.indexOf (DBBroker.ROOT_COLLECTION);
        if (p == Constants.STRING_NOT_FOUND) throw new BuildException ("invalid uri: '" + uri + "'");
        String baseURI = uri.substring (0, p);
        String path;
        if (p == uri.length () - 3) path = "";
        else path = uri.substring (p + 3);
        Collection root = null;
        if (createCollection) {
            root = DatabaseManager.getCollection (baseURI + DBBroker.ROOT_COLLECTION, user, password);
            root = mkcol (root, baseURI, DBBroker.ROOT_COLLECTION, path);
        }
        else root = DatabaseManager.getCollection (uri, user, password);
        XQueryService service = (XQueryService) root.getService ("XQueryService", "1.0");
        Source source = new StringSource (XQUERY);
        service.declareVariable ("collection", root.getName ());
        service.declareVariable ("uri", "");
        if (moduleURI != null) {
            service.declareVariable ("uri", moduleURI);
            service.declareVariable ("data", "");
            service.execute (source);
        }
        else {
            for (FileSet fileSet : fileSets) {
                DirectoryScanner scanner = fileSet.getDirectoryScanner (getProject ());
                scanner.scan ();
                String [] files = scanner.getIncludedFiles ();
                log ("Found " + files.length + " files to upload.\n");
                File baseDir = scanner.getBasedir ();
                for (int i = 0; i < files.length; i ++) {
                    File file = new File (baseDir, files [i]);
                    log ("Storing " + files [i] + " ...\n");
                    byte [] data = read (file);
                    try {
                        service.declareVariable ("name", file.getName ());
                        service.declareVariable ("data", data);
                        service.execute (source);
                    } catch (XMLDBException e) {
                        String msg = "XMLDB exception caught: " + e.getMessage ();
                        if (failonerror) throw new BuildException (msg, e);
                        else log (msg, e, Project.MSG_ERR);
                    }
                }
            }
        }
    } catch (XMLDBException e) {
        String msg = "XMLDB exception caught: " + e.getMessage ();
        if (failonerror) throw new BuildException (msg, e);
        else log (msg, e, Project.MSG_ERR);
    }
}


-----Function Pair=181=-----==

public Process createProcess (boolean optimum) throws IOException {
    StringBuilder cpbuf = new StringBuilder ();
    for (Resource rsrc : _codes) {
        if (cpbuf.length () > 0) {
            cpbuf.append (File.pathSeparator);
        }
        cpbuf.append (rsrc.getLocal ().getAbsolutePath ());
    }
    ArrayList < String > args = new ArrayList < String > ();
    args.add (LaunchUtil.getJVMPath (_appdir, _windebug || optimum));
    args.add ("-classpath");
    args.add (cpbuf.toString ());
    if (RunAnywhere.isMacOS ()) {
        args.add ("-Xdock:icon=" + getLocalPath (_dockIconPath).getAbsolutePath ());
        args.add ("-Xdock:name=" + _name);
    }
    String proxyHost;
    if ((proxyHost = System.getProperty ("http.proxyHost")) != null) {
        args.add ("-Dhttp.proxyHost=" + proxyHost);
        args.add ("-Dhttp.proxyPort=" + System.getProperty ("http.proxyPort"));
    }
    args.add ("-D" + Properties.GETDOWN + "=true");
    for (Map.Entry < Object, Object > entry : System.getProperties ().entrySet ()) {
        String key = (String) entry.getKey ();
        if (key.startsWith (PROP_PASSTHROUGH_PREFIX)) {
            key = key.substring (PROP_PASSTHROUGH_PREFIX.length ());
            args.add ("-D" + key + "=" + entry.getValue ());
        }
    }
    for (String string : _jvmargs) {
        args.add (processArg (string));
    }
    if (optimum && _optimumJvmArgs != null) {
        for (String string : _optimumJvmArgs) {
            args.add (processArg (string));
        }
    }
    for (String string : _txtJvmArgs) {
        args.add (processArg (string));
    }
    args.add (_class);
    for (String string : _appargs) {
        args.add (processArg (string));
    }
    String [] envp = createEnvironment ();
    String [] sargs = args.toArray (new String [args.size ()]);
    log.info ("Running " + StringUtil.join (sargs, "\n  "));
    return Runtime.getRuntime ().exec (sargs, envp, _appdir);
}


public static void unzip2 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    ZipFile zip = new ZipFile (zipfile);
    Enumeration < ZipArchiveEntry > files = zip.getEntries ();
    while (files.hasMoreElements ()) {
        ZipArchiveEntry ze = files.nextElement ();
        File newFile = new File (outputdir + File.separator + ze.getName ());
        newFile.getParentFile ().mkdirs ();
        if (ze.isDirectory ()) {
            newFile.mkdir ();
        }
        else {
            InputStream is = zip.getInputStream (ze);
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = is.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
            is.close ();
        }
    }
    zip.close ();
}


-----Function Pair=182=-----==

private void exportPathToKml (GraphDijkstra dij, Vertex sourceVertex, Vertex destVertex) {
    try {
        File kmlFile = new File ("ShortestPath.kml");
        PrintWriter fwriter = new PrintWriter (kmlFile);
        Point point;
        EdgeIterator eIter = dij.reportPath ();
        Vertex opposite = sourceVertex;
        int counter = 1;
        fwriter.print ("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
        fwriter.print ("<kml xmlns=\"http://earth.google.com/kml/2.2\">\n");
        fwriter.print ("<Document>\n");
        fwriter.print ("<name>Global Path Planning</name>\n");
        fwriter.print ("<description>The estimated path of HANS</description>\n");
        fwriter.print ("<ScreenOverlay>\n");
        fwriter.print ("<name>Permafrost Legend</name>\n");
        fwriter.print ("<color>aaffffff</color>\n");
        fwriter.print ("<visibility>1</visibility>\n");
        fwriter.print ("<Icon>\n");
        fwriter.print ("<href>http://www.cs.huji.ac.il/~keren_ha/hans.jpg</href>\n");
        fwriter.print ("</Icon>\n");
        fwriter.print ("<overlayXY x=\"0\" y=\"1\" xunits=\"fraction\" yunits=\"fraction\"/>\n");
        fwriter.print ("<screenXY x=\"5\" y=\"5\" xunits=\"pixels\" yunits=\"insetPixels\"/>\n");
        fwriter.print ("</ScreenOverlay>\n");
        fwriter.print ("<Placemark> \n");
        fwriter.print ("<name>Ross Building</name> \n");
        fwriter.print ("   <description>Ross Building</description> \n");
        fwriter.print ("    <Point> \n");
        fwriter.print ("      <coordinates>35.1970416667,31.7750805556</coordinates> \n");
        fwriter.print ("      </Point> \n");
        fwriter.print (" </Placemark> \n");
        fwriter.print (" <Placemark> \n");
        fwriter.print ("<name>Belgium House</name> \n");
        fwriter.print ("<description>Belgium House</description> \n");
        fwriter.print ("<Point> \n");
        fwriter.print ("<coordinates>35.1962530754,31.77487425</coordinates> \n");
        fwriter.print ("</Point> \n");
        fwriter.print ("</Placemark> \n");
        fwriter.print ("<Placemark> \n");
        fwriter.print ("<name>Jewish National and University Library</name> \n");
        fwriter.print ("<description>Jewish National and University Library</description> \n");
        fwriter.print ("<Point> \n");
        fwriter.print ("<coordinates>35.1967426645,31.7759226715</coordinates> \n");
        fwriter.print ("</Point> \n");
        fwriter.print ("</Placemark> \n");
        point = ((MyVertex) sourceVertex.element ()).getPoint ();
        printPointToKml (fwriter, point, "Start Point");
        Point lastPoint = point;
        while (eIter.hasNext ()) {
            Edge currEdge = eIter.nextEdge ();
            MyEdge edge = (MyEdge) currEdge.element ();
            int numOfPoints = edge.getLinePoints ().numPoints ();
            int currPoint = 0;
            int delta = 1;
            if (! ((MyVertex) opposite.element ()).getPoint ().equals (edge.getLinePoints ().getFirstPoint ())) {
                currPoint = numOfPoints - 1;
                delta = - 1;
            }
            int i = 0;
            while (i < numOfPoints) {
                point = edge.getLinePoints ().getPoint (currPoint);
                if (! point.equals (lastPoint)) {
                    if (point.equals (((MyVertex) destVertex.element ()).getPoint ())) {
                        printPointToKml (fwriter, point, "Destination");
                    }
                    else {
                        printPointToKml (fwriter, point, "" + counter);
                    }
                    ++ counter;
                    lastPoint = point;
                }
                currPoint += delta;
                i ++;
            }
        }
        fwriter.print ("  </Document> \n");
        fwriter.print ("</kml>  \n");
        fwriter.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}


public static void main (String [] args) {
    final String dbdriver = "org.postgresql.Driver";
    final String dbconnect = "jdbc:postgresql://prologdev1:5432/wdb";
    final String dbuser = "guest2";
    final String dbpasswd = "";
    Connection con = null;
    Statement statement = null;
    try {
        Class.forName (dbdriver);
        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);
        statement = con.createStatement ();
    } catch (Exception e) {
        System.out.println ("FATAL: cant load the database driver <" + dbdriver + ">!");
        System.exit (1);
    }
    String wdbInit = "SELECT wci.begin('" + dbuser + "')";
    String sql = " SELECT value, dataProviderName, placeName, placeGeometry," + "        referencetime, " + "        validFrom, validTo, " + "        valueParameterName, valueParameterUnit, " + "        levelParameterName, levelUnitName, levelFrom, levelTo, " + "        dataVersion, confidenceCode, storetime, valueid, valuetype " + " FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', " + "                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), " + "                NULL, " + "                array['instant temperature of air'], " + "                ( 2, 2, 'distance above ground', 'exact' ), " + "                array[-1], " + "                NULL::wci.returnOid )";
    final String colNames [] = {"value", "dataProviderName", "placeName", "referencetime", "validFrom", "validTo", "valueParameterName", "valueParameterUnit", "levelParameterName", "levelUnitName", "levelFrom", "levelTo"};
    ResultSet rs = null;
    try {
        con.setAutoCommit (false);
        statement.execute (wdbInit);
        LargeObjectManager lobj = ((org.postgresql.PGConnection) con).getLargeObjectAPI ();
        rs = statement.executeQuery (sql);
        ResultSetMetaData rsMetaData = rs.getMetaData ();
        String data;
        boolean first;
        while (rs.next ()) {
            first = true;
            for (String name : colNames) {
                data = rs.getString (name);
                if (first) {
                    first = false;
                }
                else {
                    System.out.print (", ");
                }
                if (data != null) System.out.print (data);
                else System.out.print ("\\N");
            }
            long oid = rs.getLong ("value");
            LargeObject obj = lobj.open (oid, LargeObjectManager.READ);
            byte buf [] = new byte [obj.size ()];
            obj.read (buf, 0, obj.size ());
            obj.close ();
            System.out.print ("  BLOB size: " + buf.length);
            System.out.println ();
        }
    } catch (Exception ex) {
        System.out.println ("SELECT error: " + ex);
    } finally {
        try {
            con.commit ();
            if (rs != null) rs.close ();
        } catch (SQLException ex) {
            System.out.println ("EXCEPTION: rs.close: " + ex);
        }
    }
}


-----Function Pair=183=-----==

private void mscapiDiagnosticTest (X509Certificate authnCertificate) {
    String osName = System.getProperty ("os.name");
    if (false == osName.startsWith ("Windows")) {
        this.view.addDetailMessage ("skipping MSCAPI test as we're not on windows");
        return;
    }
    KeyStore keyStore;
    Enumeration < String > aliases;
    try {
        keyStore = KeyStore.getInstance ("Windows-MY");
        keyStore.load (null, null);
        aliases = keyStore.aliases ();
    } catch (Exception e) {
        this.view.addDetailMessage ("error loading MSCAPI keystore: " + e.getMessage ());
        this.view.addTestResult (DiagnosticTests.MSCAPI, false, e.getMessage ());
        return;
    }
    String eIDSubjectName = null;
    while (aliases.hasMoreElements ()) {
        String alias = aliases.nextElement ();
        this.view.addDetailMessage ("alias: " + alias);
        X509Certificate certificate;
        try {
            certificate = (X509Certificate) keyStore.getCertificate (alias);
        } catch (KeyStoreException e) {
            this.view.addDetailMessage ("error loading MSCAPI certificate: " + e.getMessage ());
            this.view.addTestResult (DiagnosticTests.MSCAPI, false, e.getMessage ());
            return;
        }
        if (certificate.equals (authnCertificate)) {
            String subjectName = certificate.getSubjectX500Principal ().toString ();
            eIDSubjectName = subjectName;
        }
    }
    if (null == eIDSubjectName) {
        this.view.addTestResult (DiagnosticTests.MSCAPI, false, "No eID certificate found in the Windows keystore");
        return;
    }
    this.view.addTestResult (DiagnosticTests.MSCAPI, true, eIDSubjectName);
}


private static boolean writeResourceByPathAndStream (ServletResponse response, String path, InputStream inputStream) throws IOException {
    if (inputStream != null) {
        OutputStream outputStream = response.getOutputStream ();
        try {
            setupContentType (path, response);
            int size = 0;
            byte buffer [] = new byte [65536];
            while (true) {
                int readCount = inputStream.read (buffer);
                if (readCount >= 0) {
                    outputStream.write (buffer, 0, readCount);
                    size += readCount;
                }
                else {
                    break;
                }
            }
            response.setContentLength (size);
        } finally {
            outputStream.close ();
            inputStream.close ();
        }
        return true;
    }
    else {
        return false;
    }
}


-----Function Pair=184=-----==

public void sendResponseData () {
    try {
        if (store.timerStatus == - 1) {
            String timerError = "<html><head><title>Timer Thread Error</title></head><body>" + "<h1>Timer Thread Error</h1>The main timer thread is not running, it has crash with the following error:<p>" + "<pre>StackTrace:\n" + store.timerThreadErrorStack + "</pre><p>" + "Please post this error on the forum." + "</body>";
            outStream.write (timerError.getBytes ());
            return;
        }
        AccessControl ac = AccessControl.getInstance ();
        if (ac.authenticateUser (headers, urlData) == false) {
            System.out.println ("Access denied from IP : " + headers.get ("RemoteAddress"));
            StringBuffer out = new StringBuffer (4096);
            out.append ("HTTP/1.0 401 Unauthorized\r\n");
            out.append ("WWW-Authenticate: BASIC realm=\"TV Scheduler Pro\"\r\n");
            out.append ("Cache-Control: no-cache\r\n\r\nAccess denied for area.");
            outStream.write (out.toString ().getBytes ());
            return;
        }
        else if (urlData.getRequestType () == 3) {
            Class paramTypes [] = {};
            java.lang.reflect.Constructor c = Class.forName (urlData.getServletClass ()).getConstructor (paramTypes);
            Object params [] = {};
            HTTPResponse resp = (HTTPResponse) c.newInstance (params);
            resp.getResponse (urlData, outStream, headers);
            return;
        }
        else if (urlData.getRequestType () == 2) {
            returnFileContent (store.getProperty ("path.httproot") + urlData.getReqString ());
            return;
        }
        else if (urlData.getRequestType () == 1) {
            SystemStatusData sd = new SystemStatusData ();
            outStream.write (sd.getStatusXML (urlData, headers));
            return;
        }
        PageTemplate page = new PageTemplate (store.getProperty ("path.template") + File.separator + "error.html");
        page.replaceAll ("$error", "Request not known\n\n" + requestInfo ());
        outStream.write (page.getPageBytes ());
    } catch (Exception e) {
        ByteArrayOutputStream ba = new ByteArrayOutputStream ();
        PrintWriter err = new PrintWriter (ba);
        try {
            e.printStackTrace (err);
            err.flush ();
            PageTemplate page = new PageTemplate (store.getProperty ("path.template") + File.separator + "error.html");
            page.replaceAll ("$error", HTMLEncoder.encode (urlData.toString ()) + "\n\n" + HTMLEncoder.encode (ba.toString ()));
            outStream.write (page.getPageBytes ());
        } catch (Exception e2) {
            try {
                outStream.write (ba.toString ().getBytes ());
            } catch (Exception e3) {
            }
        }
        System.out.println ("HTTP Request Exception: " + e);
        e.printStackTrace ();
    }
}


public static Method getMethod (Class o_clazz, String name, Class [] arg_clazz, boolean [] arg_is_null) throws SecurityException, NoSuchMethodException {
    if (o_clazz == null) return null;
    if (arg_clazz == null || arg_clazz.length == 0) {
        return o_clazz.getMethod (name, (Class []) null);
    }
    Method met;
    try {
        met = o_clazz.getMethod (name, arg_clazz);
        if (met != null) return met;
    } catch (NoSuchMethodException e) {
    }
    met = null;
    Method [] ml = o_clazz.getMethods ();
    for (int k = 0; k < ml.length; k ++) {
        Method m = ml [k];
        if (! m.getName ().equals (name)) continue;
        Class [] param_clazz = m.getParameterTypes ();
        if (arg_clazz.length != param_clazz.length) continue;
        int n = arg_clazz.length;
        boolean ok = true;
        for (int i = 0; i < n; i ++) {
            if (arg_is_null [i]) {
                if (isPrimitive (arg_clazz [i])) {
                    ok = false;
                    break;
                }
            }
            else {
                if (arg_clazz [i] != null && ! param_clazz [i].isAssignableFrom (arg_clazz [i])) {
                    ok = false;
                    break;
                }
            }
        }
        if (ok && (met == null || isMoreSpecific (m, met))) met = m;
    }
    if (met == null) {
        throw new NoSuchMethodException ("No suitable method for the given parameters");
    }
    return met;
}


-----Function Pair=185=-----==

public void doExportXML () {
    try {
        BaseNodehandler bnh = (BaseNodehandler) gametree.getLastSelectedPathComponent ();
        File sf = new File (bnh.getNodeName () + ".xml");
        JFileChooser fc = referenceManager.getDefaultFileChooser ();
        fc.setSelectedFile (sf);
        int result = fc.showSaveDialog (referenceManager.getMainFrame ());
        if (result == fc.APPROVE_OPTION) {
            File f = fc.getSelectedFile ();
            Document d = new Document ((Element) bnh.getElement ().clone ());
            referenceManager.getCore ().writeDomToFile (d, f);
        }
    } catch (Exception ex) {
        ExceptionHandler.handleException (ex);
    }
}


public Object fromString (String value, Class < ? > toType, Class < ? >...genericTypes) throws Exception {
    if (! canConvert (toType)) {
        return null;
    }
    if (genericTypes == null || genericTypes.length == 0) {
        return createOGNLCollection (value, toType);
    }
    else if (genericTypes [0].equals (Object.class) || ReflectionUtils.isPrimitive (genericTypes [0])) {
        return createOGNLCollection (value, toType);
    }
    else {
        Collection values = createOGNLCollection (value, toType);
        TypeConverter converter = TypeConverterManager.getConverterFor (genericTypes [0]);
        if (converter == null) {
            return values;
        }
        else {
            Collection collection = newCollectionInstance (toType, null, Set.class.isAssignableFrom (toType) ? HashSet.class : ArrayList.class);
            for (Object object : values) {
                collection.add (converter.fromString (object.toString (), genericTypes [0]));
            }
            return collection;
        }
    }
}


-----Function Pair=186=-----==

public Collection < ? > newCollectionInstance (Class < ? > type, Collection < ? > values, Class < ? >...fallbacks) {
    Collection newCollection = null;
    try {
        if (values != null && type.getConstructor (Collection.class) != null) {
            newCollection = (Collection) ReflectionUtils.newInstance (type, values);
        }
        else {
            newCollection = (Collection) ReflectionUtils.newInstance (type);
            if (values != null) {
                newCollection.addAll (values);
            }
        }
    } catch (Exception e) {
        if (fallbacks != null && fallbacks.length > 0) {
            if (fallbacks.length == 1) {
                newCollection = newCollectionInstance (fallbacks [0], values);
            }
            else {
                Class < ? > [] theOtherFallbacks = new Class < ? > [fallbacks.length - 1];
                for (int i = 1; i < fallbacks.length; i ++) {
                    theOtherFallbacks [i - 1] = fallbacks [i];
                }
                newCollection = newCollectionInstance (fallbacks [0], values, theOtherFallbacks);
            }
        }
    }
    return newCollection;
}


public < T > T createThunk (Class < T > proxyType, ObjectCreator objectCreator, String description) {
    Defense.notNull (proxyType, "proxyType");
    Defense.notNull (objectCreator, "objectCreator");
    Defense.notBlank (description, "description");
    if (! proxyType.isInterface ()) throw new IllegalArgumentException (String.format ("Thunks may only be created for interfaces; %s is a class.", ClassFabUtils.toJavaClassName (proxyType)));
    final Class thunkClass = getThunkClass (proxyType);
    Throwable failure;
    try {
        return proxyType.cast (thunkClass.getConstructors () [0].newInstance (description, objectCreator));
    } catch (InvocationTargetException ex) {
        failure = ex.getTargetException ();
    } catch (Exception ex) {
        failure = ex;
    }
    throw new RuntimeException (String.format ("Exception instantiating thunk class %s: %s", thunkClass.getName (), InternalUtils.toMessage (failure)), failure);
}


-----Function Pair=187=-----==

protected void createFormContent (IManagedForm managedForm) {
    super.createFormContent (managedForm);
    FormToolkit toolkit = this.getEditor ().getToolkit ();
    ScrolledForm form = managedForm.getForm ();
    form.setText ("Tasks");
    GridLayout layout = new GridLayout ();
    layout.numColumns = 2;
    form.getBody ().setLayout (new ColumnLayout ());
    Dialog.applyDialogFont (form.getBody ());
    createTasksListSection (form, toolkit);
    tasksListSectionPart = new SectionPart (tasksListSection) {
        @Override
        public void refresh () {
            tasksListViewer.refresh ();
            super.refresh ();
        }
    }
    ;
    managedForm.addPart (tasksListSectionPart);
    createTaskSection (form, toolkit);
    taskSectionPart = new SectionPart (taskSection) {
        @Override
        public void refresh () {
            tasksListViewer.refresh ();
            super.refresh ();
        }
    }
    ;
    managedForm.addPart (taskSectionPart);
    Dialog.applyDialogFont (form.getBody ());
}


public < T > T getInstance (String key, Class < T > type, String defClsName) throws Exception {
    Class < ? > [] argTypes = CONFIG_ARGTYPES;
    Object [] args = CONFIG_ARGS;
    Class < ? > cls = getClass (key);
    String id = getIdPart (key);
    if (cls == null) {
        try {
            cls = loader.loadClass (defClsName);
        } catch (ClassNotFoundException cfx) {
            throw new Exception ("class not found " + defClsName);
        } catch (ExceptionInInitializerError ix) {
            throw new Exception ("class initialization of " + defClsName + " failed: " + ix, ix);
        }
    }
    return getInstance (key, cls, type, argTypes, args, id);
}


-----Function Pair=188=-----==

private static String getSimpleName (String s) {
    int lastsquare = s.lastIndexOf ('[');
    if (lastsquare >= 0) {
        if (s.charAt (s.lastIndexOf ('[') + 1) == 'L') {
            s = s.substring (s.lastIndexOf ('[') + 2, s.lastIndexOf (';'));
        }
        else {
            char first = s.charAt (0);
            if (first == 'I') {
                s = "int";
            }
            else if (first == 'D') {
                s = "double";
            }
            else if (first == 'Z') {
                s = "boolean";
            }
            else if (first == 'B') {
                s = "byte";
            }
            else if (first == 'J') {
                s = "long";
            }
            else if (first == 'F') {
                s = "float";
            }
            else if (first == 'S') {
                s = "short";
            }
            else if (first == 'C') {
                s = "char";
            }
        }
    }
    int lastdollar = s.lastIndexOf ('$');
    if (lastdollar >= 0) {
        s = s.substring (lastdollar + 1);
    }
    int lastdot = s.lastIndexOf ('.');
    if (lastdot >= 0) {
        s = s.substring (lastdot + 1);
    }
    if (lastsquare >= 0) {
        StringBuffer buf = new StringBuffer (s);
        int i;
        for (i = 0; i <= lastsquare; i ++) {
            buf.append ("[]");
        }
        return buf.toString ();
    }
    else {
        return s;
    }
}


public void updateVal (Configuration config) {
    updateValSuper (config);
    String value = field.getText ();
    Class [] params = new Class [1];
    Object [] args = new Object [1];
    params [0] = String.class;
    args [0] = value;
    Object o = null;
    try {
        Constructor c = mObj.getClass ().getConstructor (params);
        o = c.newInstance (args);
    } catch (Exception ex) {
        throw new IllegalStateException ("Problem writing unknown class to configuration");
    }
    config.put (key, o);
}


-----Function Pair=189=-----==

public PddlProblem generatePddl () throws Exception {
    PddlProblem result = new PddlProblem ();
    result.setMetric (this.getMetric ());
    result.addFact (String.format ("(= (satisfaction_coeff) %d)", this.getSatCoeff ()));
    result.addFact (String.format ("(= (work_load_coeff) %d)", this.getWorkloadCoeff ()));
    result.addObject ("foo", "t_gtype");
    for (Goal goal : Goals) {
        result.addObject (goal.getName (), "t_goal");
        result.addFact (String.format ("(= (max_satisfaction_degree %s) %s)", goal.getName (), goal.getMaxSat ()));
        for (Decomposition de : goal.Decomposition) {
            PddlPredicate p = result.addFact ((de.getType () == Decomposition.AND ? "and_subgoal" : "or_subgoal") + de.SubGoals.size (), goal.getName ());
            for (Goal sg : de.SubGoals) p.getArguments ().add (sg.getName ());
        }
    }
    for (Actor actor : Actors) if (actor.isEnabled ()) {
        result.addObject (actor.getName (), "t_actor");
        result.addFact (String.format ("(= (max_job_at_hand %s) %d)", actor.getName (), actor.getMaxJobs ()));
        result.addFact (String.format ("(= (max_work_load %s) %d)", actor.getName (), actor.getMaxWorkLoad ()));
        for (Capacity cap : actor.Capacity) {
            result.addFact ("can_provide", actor.getName (), cap.getGoal ().getName ());
            result.addFact (String.format ("(= (satisfaction_ability %s %s) %d)", actor.getName (), cap.getGoal ().getName (), cap.getSatisfaction ()));
            result.addFact (String.format ("(= (work_effort %s %s) %d)", actor.getName (), cap.getGoal ().getName (), cap.getEffort ()));
            result.addFact (String.format ("(= (time_effort %s %s) %d)", actor.getName (), cap.getGoal ().getName (), cap.getConsumeTime ()));
        }
        for (Goal goal : actor.Requests) {
            result.addGoalPredicate ("satisfied " + goal.getName ().toUpperCase ());
            result.addFact ("requests", actor.getName (), goal.getName ());
        }
    }
    return processPostCommand (result);
}


private void serializeString (StringBuffer buffer, String s) throws UnsupportedEncodingException {
    char baseChar = 'B';
    if (s != null) {
        byte [] bytes = s.getBytes ("utf-8");
        if (s.length () != bytes.length) {
            buffer.append ('u');
            s = Base64.byteArrayToBase64 (bytes);
        }
        else {
            buffer.append ('s');
        }
        int l4 = s.length ();
        if (l4 > 52) {
            buffer.append ((char) (baseChar - 2));
            String value = "" + l4;
            buffer.append ((char) (baseChar + value.length ()));
            buffer.append (l4);
        }
        else {
            buffer.append ((char) (baseChar + l4));
        }
        buffer.append (s);
    }
    else {
        buffer.append ('s');
        buffer.append ((char) (baseChar - 1));
    }
}


-----Function Pair=190=-----==

private void addSpectrumAttElement (JDObject jdo, String s) {
    String spectrumAttName = null;
    IAttribute att = null;
    int leftBracket = s.lastIndexOf ("[");
    if ((leftBracket <= 0) || (leftBracket >= s.length ())) return;
    spectrumAttName = s.substring (0, leftBracket);
    try {
        att = aFac.getAttribute (spectrumAttName);
        if (att == null) return;
        if (att instanceof IDevStateSpectrum) {
            addStateSpectrumAttributeElement (jdo, (IDevStateSpectrum) att);
            return;
        }
    } catch (ConnectionException connectionexception) {
        System.out.println ("Couldn't load device for attribute" + spectrumAttName + " " + connectionexception);
    } catch (DevFailed dfEx) {
        System.out.println ("Couldn't find the attribute" + spectrumAttName + " " + dfEx);
    }
}


public void actionPerformed (ActionEvent ev) {
    Object [] vars = variableGrabber.getSelectedValues ();
    if (vars.length <= 0) {
        return;
    }
    int row = - 1;
    String currText = "";
    RandomTermsTableModel model = (RandomTermsTableModel) randomTerms.getModel ();
    if (row < 0) {
        model.addRow (currText);
        row = model.getRowCount () - 1;
    }
    currText = (String) model.getValueAt (row, 0);
    currText = currText.trim ();
    if (currText.length () == 0) {
        currText = (String) vars [0];
    }
    else {
        currText = currText + vars [0];
    }
    for (int j = 1; j < vars.length; j ++) {
        currText = currText + vars [j];
    }
    model.setValueAt (currText, row, 0);
}


-----Function Pair=191=-----==

public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


public boolean componentsMatch (Component comp, ComponentReference ref) {
    if (comp == null || ref == null) return ref == null && comp == null;
    ComponentTester tester = getTester (comp);
    int weight = 0;
    boolean match = true;
    if (! ref.getRefClass ().isAssignableFrom (comp.getClass ())) match = false;
    String n1 = ref.getName ();
    String n2 = getComponentName (comp);
    if ((n1 != null && ! n1.equals (n2)) || (n1 == null && n1 != n2)) match = false;
    else if (n1 != null && n1.equals (n2)) ++ weight;
    String t1 = ref.getTag ();
    String t2 = getTag (comp);
    if (t1 != null && ! t1.equals (t2)) match = false;
    else if (t1 != null && t1.equals (t2)) ++ weight;
    if (ref.getParentID () != null) {
        if (componentsMatch (getComponentParent (comp), ref.getParentReference ())) {
            if (weight > 0) ++ weight;
        }
        else match = false;
    }
    if (ref.getWindowID () != null) {
        if (componentsMatch (getComponentWindow (comp), ref.getWindowReference ())) {
            if (weight > 0) ++ weight;
        }
        else match = false;
    }
    if (ref.getTitle () != null) {
        if (titlesMatch (ref.getTitle (), getComponentFrameTitle (comp))) {
            if (weight > 0) ++ weight;
        }
        else match = false;
    }
    if (! match && weight > 0) Log.warn ("Near match (weight=" + weight + "): " + ref + " vs. " + comp);
    return match;
}


-----Function Pair=192=-----==

public void comrun (String code, String name) {
    displayWait ();
    String comres = compile (code, name, false);
    System.out.println (comres);
    if (! comres.equals ("")) {
        displayResult ("Code compilation", comres);
    }
    else {
        String output = "";
        try {
            Process p2 = Runtime.getRuntime ().exec ("java " + name);
            InputStream in = p2.getInputStream ();
            int c = 0;
            c = in.read ();
            while (c != - 1) {
                output = output + (char) c;
                c = in.read ();
            }
            in.close ();
            displayResult ("Code output", "Compilation sucessful\n\n" + output);
        } catch (Exception e) {
            System.out.println ("error");
        }
    }
}


CompilationUnitTree removeRedundantImports (CompilationUnitTree t) {
    JCCompilationUnit tree = (JCCompilationUnit) t;
    tree.accept (this);
    ListBuffer < JCTree > defs = new ListBuffer < JCTree > ();
    for (JCTree def : tree.defs) {
        if (def.getTag () == JCTree.IMPORT) {
            JCImport imp = (JCImport) def;
            if (imp.qualid.getTag () == JCTree.SELECT) {
                JCFieldAccess qualid = (JCFieldAccess) imp.qualid;
                if (! qualid.name.toString ().equals ("*") && ! names.contains (qualid.name)) {
                    continue;
                }
            }
        }
        defs.add (def);
    }
    return m.TopLevel (tree.packageAnnotations, tree.pid, defs.toList ());
}


-----Function Pair=193=-----==

public String [] [] blast (Screen sc, Seq s) throws Exception {
    String database;
    String program;
    if (s.getNature () == Nature.DNA) {
        database = sc.get_dataN ();
        program = "blastn";
    }
    else {
        database = sc.get_dataP ();
        program = "blastp";
    }
    try {
        FileWriter fstream = new FileWriter (file_in);
        BufferedWriter out = new BufferedWriter (fstream);
        bb [num_frame] [num_sub_sequence].write ("sequence blasted: " + s.getSymbolList ().seqString ());
        bb [num_frame] [num_sub_sequence].newLine ();
        bb [num_frame] [num_sub_sequence].write ("Blast results:");
        bb [num_frame] [num_sub_sequence].newLine ();
        out.write (">seq");
        out.newLine ();
        out.write (s.getSymbolList ().seqString ());
        out.close ();
        fstream.close ();
    } catch (IOException e) {
        System.out.println ("**************************ERROR**************************");
        System.out.println ("error while writing the sequence on file");
        System.out.println ("sequence " + s.getSymbolList ().seqString ());
        throw e;
    }
    try {
        String [] commands = {"sh", "-c", "mpirun -np $NSLOTS mpiblast -d " + database + " -i " + file_in + " -p " + program + " -o " + file_out + " -F F -e 1e-3 -m 9 --removedb"};
        Process child = Runtime.getRuntime ().exec (commands);
        child.waitFor ();
        child.getErrorStream ().close ();
        child.getInputStream ().close ();
        child.getOutputStream ().close ();
        child.destroy ();
    } catch (InterruptedException e) {
        System.out.println ("**************************ERROR**************************");
        System.out.println ("interuption while executing the blast request");
        throw e;
    }
    ExtractMPI res = new ExtractMPI (1, 1, 1, 0, 0, 0, num_frame, num_sub_sequence, bb);
    return res.extract (file_out, s.getNature ());
}


public void writeMP3toStream (File file, OutputStream os) {
    System.out.println ("Writing mp3 to stream for file " + file);
    Process p = null;
    BufferedInputStream is = null;
    try {
        String convertcommand;
        if (System.getProperty ("os.name").toLowerCase ().contains ("windows")) {
            convertcommand = this.getScriptDir ().toString () + "\\" + getCommand () + ".bat";
        }
        else {
            convertcommand = this.getScriptDir ().toString () + "/" + getCommand ();
        }
        String [] cmd = {convertcommand, "\"" + file + "\""};
        byte input [] = new byte [1000];
        System.out.println (convertcommand);
        System.out.println (file.toString ());
        p = Runtime.getRuntime ().exec (cmd, null, this.getScriptDir ());
        is = new BufferedInputStream (p.getInputStream ());
        BufferedInputStream es = new BufferedInputStream (p.getErrorStream ());
        Consumer a = new Consumer (es);
        new Thread (a).start ();
        int count;
        while ((count = is.read (input)) != - 1) {
            os.write (input, 0, count);
        }
    } catch (Exception e) {
        System.out.println (e.toString ());
    } finally {
        if (p != null) p.destroy ();
        try {
            if (is != null) is.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=194=-----==

public void run () {
    try {
        Thread t1 = null;
        synchronized (threadpool) {
            if (threadpool.containsKey (url)) {
                t1 = threadpool.get (url);
            }
            threadpool.put (url, this);
        }
        try {
            if (t1 != null) t1.join ();
        } catch (InterruptedException e) {
            Log.e ("uiutil", "load image error", e);
        }
        if (useCache) {
            File cache = cacheFromURL (url, context);
            if (! cache.exists ()) {
                HTTPUtil.downloadFile (url, cache, client);
            }
            synchronized (context) {
                ch.imageFileLoadedCallback (cache, GIFOpenHelper.readImageType (cache));
            }
        }
        else {
            byte [] bs = HTTPUtil.downloadFileToByteArray (url, client);
            bh.imageFileLoadedCallback (bs, GIFOpenHelper.getImageType (bs));
        }
    } catch (NetworkException e) {
        Log.e ("uiutil", "load image error", e);
    } finally {
        synchronized (threadpool) {
            if (threadpool.containsValue (this)) threadpool.remove (url);
        }
    }
}


void process (SourceMetricsDataBuilder data) {
    data.set (SourceMetricsData.SIZE, size);
    Set < String > operators = new HashSet < String > ();
    int standAlone = 0;
    for (SourceTokens.Token token : sourceTokens) {
        if (token.isEOF ()) {
            SourceTokens.Token prev = token.previousToken ();
            if (null == prev) {
                data.set (SourceMetricsData.LINES, 0);
            }
            else if (prev.getTokenText ().endsWith ("\r") || prev.getTokenText ().endsWith ("\n")) {
                data.set (SourceMetricsData.LINES, token.getLineNumber () - 1L);
            }
            else {
                data.set (SourceMetricsData.LINES, token.getLineNumber ());
            }
            break;
        }
        if (token.isLineComment ()) {
            if (isFirstOnLine (token)) {
                data.bump (SourceMetricsData.LINE_COMMENT);
                if (endOfMultipleLineComments (token)) {
                    bumpCommentLocationMetrics (data, token);
                }
            }
        }
        else if (token.isBlockComment ()) {
            processMultilineComment (data, token, SourceMetricsData.BLOCK_COMMENT);
        }
        else if (token.isJavadocComment ()) {
            processMultilineComment (data, token, SourceMetricsData.DOC_COMMENT);
        }
        else if (token.isWhitespace ()) {
            int lineCount = token.getNewlineCount ();
            SourceTokens.Token prev = token.previousToken ();
            if ((null != prev) && prev.isLineComment ()) {
                lineCount ++;
            }
            if (1 < lineCount) {
                data.bump (SourceMetricsData.WHITESPACE, lineCount - 1L);
            }
        }
        else if (";".equals (token.getTokenText ())) {
            data.bump (SourceMetricsData.LOGICAL_LINES);
        }
        else if (- 1 != "(){}".indexOf (token.getTokenText ())) {
            if (isAloneOnLine (token)) {
                standAlone ++;
            }
        }
        if (token.isLiteral ()) {
            data.bump (SourceMetricsData.OPERANDS);
        }
        else if (! token.isComment () && ! token.isWhitespace ()) {
            data.bump (SourceMetricsData.OPERATORS);
            operators.add (token.getTokenText ());
        }
    }
    data.set (SourceMetricsData.UNIQUE_OPERATORS, operators.size ());
    data.set (SourceMetricsData.LOC, data.get (SourceMetricsData.LINES) - data.get (SourceMetricsData.WHITESPACE) - data.get (SourceMetricsData.LINE_COMMENT) - data.get (SourceMetricsData.BLOCK_COMMENT) - data.get (SourceMetricsData.DOC_COMMENT));
    data.set (SourceMetricsData.ELOC, data.get (SourceMetricsData.LOC) - standAlone);
    data.set (SourceMetricsData.COMMENTS, data.get (SourceMetricsData.LINE_COMMENT) + data.get (SourceMetricsData.BLOCK_COMMENT) + data.get (SourceMetricsData.DOC_COMMENT));
    String chunk = new String (sourceTokens.getChunk ());
    byte [] bytes = chunk.getBytes ();
    CRC32 crc = new CRC32 ();
    crc.update (bytes);
    data.set (SourceMetricsData.CRC, Double.longBitsToDouble (crc.getValue ()));
}


-----Function Pair=195=-----=1=

public boolean render (Vector shapes) throws ImageRenderException {
    String tempFile = renderToTempFile (shapes);
    Session session;
    MimeMessage msg;
    try {
        session = Session.getDefaultInstance (prop, null);
        msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (prop.getProperty ("mail.from", "gh@mbl.is")));
        msg.addRecipient (RecipientType.TO, new InternetAddress (address));
        msg.setSubject (prop.getProperty ("mail.subject", "Whiteboard image"));
        Multipart multipart = new MimeMultipart ();
        BodyPart msgBody = new MimeBodyPart ();
        msgBody.setText (prop.getProperty ("mail.body", "This message contains your whiteboard image"));
        multipart.addBodyPart (msgBody);
        BodyPart msgImg = new MimeBodyPart ();
        DataSource source = new FileDataSource (tempFile);
        msgImg.setDataHandler (new DataHandler (source));
        msgImg.setFileName ("whiteboard.png");
        multipart.addBodyPart (msgImg);
        msg.setContent (multipart);
    } catch (MessagingException e) {
        throw new ImageRenderException ("Couldn't initialize mail message: " + e);
    }
    try {
        Transport.send (msg);
    } catch (MessagingException e) {
        throw new ImageRenderException ("Couldn't send message: " + e);
    }
    new File (tempFile).delete ();
    return true;
}


public boolean sendTextMail (MailSenderInfo mailInfo) {
    MyAuthenticator authenticator = null;
    Properties pro = mailInfo.getProperties ();
    if (mailInfo.isValidate ()) {
        authenticator = new MyAuthenticator (mailInfo.getUserName (), mailInfo.getPassword ());
    }
    Session sendMailSession = Session.getDefaultInstance (pro, authenticator);
    try {
        Message mailMessage = new MimeMessage (sendMailSession);
        Address from = new InternetAddress (mailInfo.getFromAddress ());
        mailMessage.setFrom (from);
        Address to = new InternetAddress (mailInfo.getToAddress ());
        mailMessage.setRecipient (Message.RecipientType.TO, to);
        mailMessage.setSubject (mailInfo.getSubject ());
        mailMessage.setSentDate (new Date ());
        String mailContent = mailInfo.getContent ();
        mailMessage.setText (mailContent);
        Transport.send (mailMessage);
        return true;
    } catch (MessagingException ex) {
        ex.printStackTrace ();
    }
    return false;
}


-----Function Pair=196=-----==

void doShowHelp (int x, int y) {
    FontMetrics fm = listing.getFontMetrics (FONT);
    int row = y / fm.getHeight ();
    int col = x / fm.charWidth (' ');
    if (row >= lines.length || col >= lines [row].length ()) return;
    if (lines [row].charAt (col) != ' ') {
        int sc = col;
        while (sc > 0 && lines [row].charAt (sc - 1) != ' ') sc --;
        int ec = col;
        while (ec < lines [row].length () - 1 && lines [row].charAt (ec + 1) != ' ') ec ++;
        String text = lines [row].substring (sc, ec + 1);
        for (InsIndex insIndexEntry : InsIndex.values ()) if (insIndexEntry.name ().equalsIgnoreCase (text)) {
            try {
                new HelpViewer (this, insIndexEntry);
            } catch (IOException ioe) {
                JOptionPane.showMessageDialog (this, ioe.getMessage ());
            }
            break;
        }
    }
}


public ImageDisplay (ImageDisplayApplet applet, GraphicsConfiguration gc) {
    this.applet = applet;
    if (applet == null) {
        frame = new JFrame (gc);
        frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    }
    setLayout (new BorderLayout ());
    setPreferredSize (new Dimension (PREFERRED_WIDTH, PREFERRED_HEIGHT));
    Action openAction = new AbstractAction ("Open File", new ImageIcon (getClass ().getResource ("/open.gif"))) {
        public void actionPerformed (ActionEvent e) {
            if (filechooser == null) {
                filechooser = new JFileChooser ();
                filechooser.setFileSelectionMode (JFileChooser.FILES_ONLY);
            }
            if (filechooser.showOpenDialog (ImageDisplay.this) == JFileChooser.APPROVE_OPTION) {
                open (filechooser.getSelectedFile ());
            }
        }
    }
    ;
    JToolBar bar = new JToolBar ();
    bar.add (new ToolBarButton (openAction));
    add (bar, BorderLayout.NORTH);
    if (applet == null) {
        frame.setTitle ("Image Display - Control Panel");
        frame.getContentPane ().add (this, BorderLayout.CENTER);
        frame.pack ();
        frame.show ();
    }
}


-----Function Pair=197=-----==

private void renameFile () {
    boolean operationResult = false;
    boolean overallResult = true;
    int failCount = 0;
    String [] fileList = directory.list ();
    String Prefix = txtPrefix.getText ();
    String Rename = txtRename.getText ();
    String Suffix = txtSuffix.getText ();
    String digits = (String) cboSequence.getSelectedItem ();
    int StartingNum;
    String generatedSequence;
    File oldFile;
    if (cbxOutput.isSelected () && OUTPUT_ON == false) {
        buildOutput ();
        OUTPUT_ON = true;
    }
    for (int i = 0; i < fileList.length; i ++) {
        oldFile = new File (directory.getPath () + "/" + fileList [i]);
        String readability = fileList [i] + " - readable?: " + oldFile.canRead ();
        System.out.println (readability);
        if (OUTPUT_ON) txaOutput.append ("\n" + readability);
    }
    for (int i = 0; i < fileList.length; i ++) {
        oldFile = new File (directory.getPath () + "/" + fileList [i]);
        String fileExtension;
        if (cbxIgnoreExtension.isSelected () == true) {
            fileExtension = "";
        }
        else fileExtension = getFileExtension (fileList [i]);
        String fileName = getFileName (fileList [i]);
        String inputInfo = "The input filename->" + fileList [i] + "\nfile name->" + fileName + "\nextension->" + fileExtension;
        System.out.println (inputInfo);
        if (OUTPUT_ON) txaOutput.append ("\n" + inputInfo);
        if (digits.equals ("None") == true) {
            generatedSequence = "";
        }
        else {
            StartingNum = Integer.parseInt (txtSequence.getText ());
            generatedSequence = nameSequence (StartingNum + i, digits);
        }
        if (cbxRename.isSelected () == true) {
            fileName = Rename + generatedSequence;
        }
        else {
            fileName = fileName + generatedSequence;
        }
        String newFileName = Prefix + fileName + Suffix + fileExtension;
        String tentativeName = "new Filename will be ->" + newFileName + "\n";
        System.out.println (tentativeName);
        if (OUTPUT_ON) txaOutput.append ("\n" + tentativeName);
        if (cbxExperiment.isSelected () == false) {
            operationResult = oldFile.renameTo (new File (directory.getPath () + "/" + newFileName));
            String renameResult = "\t*Rename successfully?: " + operationResult + "\n\n";
            System.out.println (renameResult);
            if (operationResult == false) failCount ++;
            if (OUTPUT_ON) txaOutput.append ("\n" + renameResult);
            overallResult = (operationResult && overallResult);
        }
    }
    if (cbxExperiment.isSelected () == false) {
        System.out.println ("Overall Result: " + overallResult);
        if (overallResult) JOptionPane.showMessageDialog (null, "All files renamed successfully!");
        else JOptionPane.showMessageDialog (null, "File renamed with " + failCount + " failure(s)");
    }
}


private JMenuBar createMenu () {
    JMenuBar jMenuBar = new JMenuBar ();
    JMenu jMenuFile = new JMenu ("File");
    JMenu jMenuEdit = new JMenu ("Edit");
    JMenu jMenuView = new JMenu ("View");
    JMenu jMenuHelp = new JMenu ("Help");
    miOpen = new JMenuItem ("Open", createImageIcon ("img/open16.jpg"));
    miOpen.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            OpenSchedule ();
        }
    }
    );
    jMenuFile.add (miOpen);
    miSave = new JMenuItem ("Save", createImageIcon ("img/save16.jpg"));
    miSave.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            SaveSchedule (sxFileName);
        }
    }
    );
    jMenuFile.add (miSave);
    miSaveAs = new JMenuItem ("Save as ...", createImageIcon ("img/save_as16.jpg"));
    miSaveAs.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            SaveAsSchedule ();
        }
    }
    );
    jMenuFile.add (miSaveAs);
    jMenuFile.add (new JSeparator ());
    miExit = new JMenuItem ("Exit", createImageIcon ("img/exit16.jpg"));
    miExit.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            sxExit ();
        }
    }
    );
    jMenuFile.add (miExit);
    miUndo = new JMenuItem ("Undo", createImageIcon ("img/undo16.jpg"));
    miUndo.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            undo ();
        }
    }
    );
    miRedo = new JMenuItem ("Redo", createImageIcon ("img/redo16.jpg"));
    miRedo.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            redo ();
        }
    }
    );
    jMenuEdit.addSeparator ();
    miLayout = new JMenuItem ("Reset layout", createImageIcon ("img/layout16.jpg"));
    miLayout.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            resetLayout ();
        }
    }
    );
    jMenuEdit.add (miLayout);
    miViewSource = new JMenuItem ("View source", createImageIcon ("img/viewsource16.jpg"));
    miViewSource.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            viewSource ();
        }
    }
    );
    jMenuView.add (miViewSource);
    miZoomIn = new JMenuItem ("Zoom In", createImageIcon ("img/zoomin16.jpg"));
    miZoomIn.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            sxScale = Inc (sxScale);
            graphScale ();
        }
    }
    );
    jMenuView.add (miZoomIn);
    miZoomAct = new JMenuItem ("Zoom Actual size", createImageIcon ("img/zoomact16.jpg"));
    miZoomAct.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            sxScale = 1;
            graphScale ();
        }
    }
    );
    jMenuView.add (miZoomAct);
    miZoomOut = new JMenuItem ("Zoom Out", createImageIcon ("img/zoomout16.jpg"));
    miZoomOut.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            sxScale = Dec (sxScale);
            graphScale ();
        }
    }
    );
    jMenuView.add (miZoomOut);
    miHelp = new JMenuItem ("Help", createImageIcon ("img/help16.jpg"));
    miHelp.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            cxHelper hlp = new cxHelper ();
            hlp.show ();
        }
    }
    );
    jMenuHelp.add (miHelp);
    jMenuHelp.add (new JSeparator ());
    miAbout = new JMenuItem ("About", createImageIcon ("img/about16.jpg"));
    miAbout.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            String AboutStr = "gxTool version 1.0\n Created by Bulochnikova N.M.\n  powered by Swing";
            JOptionPane.showMessageDialog (sxJSchedule, AboutStr, "About", JOptionPane.INFORMATION_MESSAGE, createImageIcon ("img/gxTool.jpg"));
        }
    }
    );
    jMenuHelp.add (miAbout);
    jMenuBar.add (jMenuFile);
    jMenuBar.add (jMenuEdit);
    jMenuBar.add (jMenuView);
    jMenuBar.add (jMenuHelp);
    miSave.setEnabled (false);
    miSaveAs.setEnabled (false);
    miViewSource.setEnabled (false);
    miLayout.setEnabled (false);
    miZoomOut.setEnabled (false);
    miZoomAct.setEnabled (false);
    miZoomIn.setEnabled (false);
    miRedo.setEnabled (false);
    miUndo.setEnabled (false);
    return jMenuBar;
}


-----Function Pair=198=-----==

public ProjectGUI () {
    setSize (500, 450);
    setTitle ("Pascal Interpreter");
    cp = getContentPane ();
    area = new JTextArea ();
    scroll = new JScrollPane (area);
    cp.add (scroll, BorderLayout.CENTER);
    variables = new HashMap < String, Variable > ();
    JMenu file = new JMenu ("Plik");
    JMenuItem open = file.add (new OpenFileAction ("Otworz"));
    JMenuItem save = file.add (new SaveFileAction ("Zapisz"));
    file.addSeparator ();
    JMenuItem exit = file.add (new ExitAction ("Zakoncz"));
    JMenuBar menu = new JMenuBar ();
    setJMenuBar (menu);
    menu.add (file);
    JMenu action = new JMenu ("Uruchom");
    JMenuItem scanner = action.add (new RunScannerAction ("Uruchom.."));
    JMenuItem parser = action.add (new RunApp ("Info"));
    menu.add (action);
    wybor = new JFileChooser ();
    wybor.setCurrentDirectory (new File ("."));
    final FiltrRozszerzenia filtr = new FiltrRozszerzenia ();
    filtr.ustawRozszerzenie ("pas");
    wybor.setFileFilter (filtr);
    setVisible (true);
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
}


private void BFS (String t1name, String t2name) {
    Vector < Game > currentTeamGames = teams.get (t1name).games;
    Queue < Team > BFSqueue = new LinkedList < Team > ();
    boolean foundChain = true;
    Team tempTeam = null;
    Game tempGame = null;
    teams.get (t1name).tLabel = 'V';
    BFSqueue.offer (teams.get (t1name));
    while (tempTeam != teams.get (t2name)) {
        if (BFSqueue.isEmpty ()) {
            foundChain = false;
            break;
        }
        tempTeam = BFSqueue.poll ();
        currentTeamGames = tempTeam.games;
        java.util.Enumeration e = currentTeamGames.elements ();
        for (int i = 0; i < tempTeam.games.size (); i ++) {
            tempGame = (Game) e.nextElement ();
            if (tempGame.team1 == tempTeam) {
                if (tempGame.team2.tLabel != 'V') {
                    BFSqueue.offer (tempGame.team2);
                    tempGame.team2.tLabel = 'V';
                    tempGame.team2.parent = tempTeam;
                    tempGame.team2.movToParent = tempGame.team2score - tempGame.team1score;
                }
            }
            else if (tempGame.team2 == tempTeam) {
                if (tempGame.team1.tLabel != 'V') {
                    BFSqueue.offer (tempGame.team1);
                    tempGame.team1.tLabel = 'V';
                    tempGame.team1.parent = tempTeam;
                    tempGame.team1.movToParent = tempGame.team1score - tempGame.team2score;
                }
            }
        }
    }
    if (foundChain == true) {
        String firstTeam = tempTeam.name;
        textArea.append ("\nThe shortest path is: " + tempTeam.name);
        int expectedMov = tempTeam.movToParent;
        while (tempTeam.parent != null) {
            tempTeam = tempTeam.parent;
            expectedMov += tempTeam.movToParent;
            textArea.append (" who played " + tempTeam.name);
        }
        textArea.append ("\n  The expected margin of victory for " + firstTeam + " vs. " + tempTeam.name + " is " + expectedMov + " points");
    }
    else {
        textArea.append ("\nNo path discovered");
    }
}


-----Function Pair=199=-----==

public void removeSelectedCardsFromTheDeck () {
    ArrayList < Card > removed = new ArrayList < Card > ();
    int [] indices = theDeck.getSelectedIndices ();
    if (indices.length <= 0) return;
    Object [] options = {"Yes", "No!"};
    int remove = JOptionPane.showOptionDialog (framer, "Remove cards from active list?", "Removing Cards", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options [0]);
    if (remove == JOptionPane.YES_OPTION) {
        for (int i = indices.length - 1; i >= 0; i --) {
            int dex = indices [i];
            Card card = removeFromTheDeck (dex);
            removed.add (card);
        }
        setActiveCardIndex (0);
        updateTheDeck ();
        int delete = JOptionPane.showOptionDialog (framer, "Permanently DELETE cards from Library as well?", "Deleting Cards...", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options [1]);
        if (delete == JOptionPane.YES_OPTION) deleteCardsFromLibrary (removed);
    }
    theDeck.grabFocus ();
}


private static void list (final boolean isTested) {
    final JFileChooser fc = new JFileChooser ();
    fc.addChoosableFileFilter (new FileFilterCsv ());
    if (isTested) {
        fc.setSelectedFile (new File (HelperEnvironment.getUserHomeDirectory (), "JUnitTested" + EXTENSION_CSV));
    }
    else {
        fc.setSelectedFile (new File (HelperEnvironment.getUserHomeDirectory (), "JUnitUntested" + EXTENSION_CSV));
    }
    if (JFileChooser.APPROVE_OPTION == fc.showSaveDialog (null)) {
        final File output = fc.getSelectedFile ();
        output.delete ();
        try {
            final java.io.FileFilter filter = new java.io.FileFilter () {
                @Override
                public boolean accept (final File file) {
                    return HelperString.endsWith (file.getName (), EXTENSION_JAVA) && ! HelperString.contains (file.getName (), "svn");
                }
            }
            ;
            final Collection < File > listJava = HelperIO.getFiles (HelperEnvironment.getUserDirectory (), filter);
            HelperIO.writeLine (output, HelperString.concatenate (HelperString.SEMICOLON, "Class", "Method/Variable"));
            for (final File file : listJava) {
                if (file.getAbsolutePath ().contains ("/main/java/")) {
                    final Scanner scanner = new Scanner (file);
                    while (scanner.hasNextLine ()) {
                        final String line = scanner.nextLine ();
                        if (isTested) {
                            if (null != line && line.contains (MARKER)) {
                                HelperIO.writeLine (output, HelperString.concatenate (HelperString.SEMICOLON, file.getAbsolutePath (), line));
                            }
                        }
                        else {
                            if (null != line && ! line.contains (MARKER) && (line.contains (QUALIFIER_PUBLIC) || line.contains (QUALIFIER_PROTECTED)) && ! line.contains (QUALIFIER_CLASS) && ! line.contains (QUALIFIER_INTERFACE) && ! line.contains (HelperString.SEMICOLON)) {
                                HelperIO.writeLine (output, HelperString.concatenate (HelperString.SEMICOLON, file.getAbsolutePath (), line));
                            }
                        }
                    }
                    scanner.close ();
                }
            }
        } catch (IOException ex) {
            log.error ("Could not process files", ex);
        }
        if (JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog (null, "Open file with the default application?", "Open file", JOptionPane.YES_NO_OPTION)) {
            try {
                LauncherFile.open (output);
            } catch (IOException ex) {
                log.error ("Could not open output file", ex);
                System.exit (10);
            }
        }
    }
}


-----Function Pair=200=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public void CopyFile (File source, File destination) throws Exception {
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream (source);
        fos = new FileOutputStream (destination);
        byte [] buffer = new byte [4096];
        int read;
        while ((read = fis.read (buffer)) != - 1) {
            fos.write (buffer, 0, read);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (fis != null) {
                fis.close ();
            }
            if (fos != null) {
                fos.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=201=-----==

public static void timeTest2 () {
    SimpleDateFormat sdf = new SimpleDateFormat ("yyMM");
    for (int i = 0; i < 12; i ++) {
        Calendar cal = Calendar.getInstance ();
        cal.set (Calendar.DATE, 18);
        cal.set (Calendar.MONTH, i);
        if (cal.get (Calendar.WEEK_OF_MONTH) > 3) {
            cal.add (Calendar.MONTH, 1);
        }
        String thisMonth = sdf.format (cal.getTime ());
        cal.add (Calendar.MONTH, 1);
        String nextMonth = sdf.format (cal.getTime ());
        cal.add (Calendar.MONTH, (3 - (cal.get (Calendar.MONTH) + 1) % 3));
        String nextSeason = sdf.format (cal.getTime ());
        cal.add (Calendar.MONTH, 3);
        String nextHalfYear = sdf.format (cal.getTime ());
        System.out.println ((i + 1) + ": \t" + thisMonth + "\t" + nextMonth + "\t" + nextSeason + "\t" + nextHalfYear);
    }
}


public static File dump (InputStream is, File file) throws IOException {
    File parentFile = file.getParentFile ();
    if ((parentFile != null) && ! parentFile.exists () && ! parentFile.mkdirs ()) {
        throw new IOException ("Unable to create dir: " + parentFile.getAbsolutePath ());
    }
    BufferedOutputStream fos = new BufferedOutputStream (new FileOutputStream (file), BUFFER_SIZE);
    byte [] buffer = new byte [BUFFER_SIZE];
    int byteRead = - 1;
    while ((byteRead = is.read (buffer)) != - 1) {
        fos.write (buffer, 0, byteRead);
    }
    fos.close ();
    is.close ();
    return file;
}


-----Function Pair=202=-----==

public static void writeDBFile (Hashtable db, File file) throws IOException {
    File tmpFile = File.createTempFile ("galaxy-civilization", null, file.getParentFile ());
    Manifest manifest = new Manifest ();
    manifest.getMainAttributes ().putValue ("Application", Main.APPLICATION_NAME);
    manifest.getMainAttributes ().putValue ("Application-Version", Long.toString (Main.VERSION));
    manifest.getMainAttributes ().putValue ("Client-Serial-Number", Main.APPLICATION_NAME);
    ZipEntry entry = new ZipEntry ("db.data");
    FileOutputStream fout = new FileOutputStream (tmpFile);
    JarOutputStream jOut = new JarOutputStream (new BufferedOutputStream (fout), manifest);
    jOut.putNextEntry (entry);
    ObjectOutputStream out = new ObjectOutputStream (jOut);
    out.writeObject (db);
    out.flush ();
    jOut.finish ();
    jOut.close ();
    fout.close ();
    if (file.exists ()) file.delete ();
    if (! tmpFile.renameTo (file)) throw new IOException ("Cannot rename tmp-file to target file: " + file.getAbsolutePath ());
}


protected void writeTarget (Metadata metadata, PrintWriter writer) {
    writeAttribute (metadata.getTarget (), writer);
    writer.println ();
    ClassHierarchy hierarchy = metadata.getClassHierarchy ();
    if (hierarchy != null) {
        LinkedList < Node > nodes = new LinkedList < Node > ();
        LinkedList < Node > printed = new LinkedList < Node > ();
        nodes.add (hierarchy.getRoot ());
        while (! nodes.isEmpty ()) {
            Node node = nodes.removeFirst ();
            if (! printed.contains (node)) {
                writer.print ("@class " + node.getLabel ());
                if (! node.getParents ().isEmpty ()) {
                    StringBuffer parents = new StringBuffer ();
                    parents.append (" { ");
                    int index = 0;
                    for (Node parent : node.getParents ()) {
                        if (index > 0) {
                            parents.append (",");
                        }
                        parents.append (parent.getLabel ());
                        index ++;
                    }
                    parents.append (" }");
                    writer.println (parents.toString ());
                }
                else {
                    writer.println ();
                }
                printed.add (node);
                nodes.addAll (node.getChildren ());
            }
        }
    }
}


-----Function Pair=203=-----==

public static File [] listDirectories (File baseDir, boolean recursive) {
    File [] files = baseDir.listFiles (new FileFilter () {
        public boolean accept (File f) {
            return f.isDirectory ();
        }
    }
    );
    if (recursive) {
        NSMutableArray < File > a = new NSMutableArray < File > (files);
        for (int i = files.length; i -- > 0;) {
            File currentDir = files [i];
            File [] currentDirs = listDirectories (currentDir, true);
            a.addObjects (currentDirs);
        }
        Object [] objects = a.objects ();
        files = new File [objects.length];
        System.arraycopy (objects, 0, files, 0, objects.length);
    }
    return files;
}


public static final List < File > listFiles (final String basePath, int deep, final String...fileNameEndStr) {
    final List < File > list = new ArrayList < File > ();
    final File baseFile = new File (basePath);
    File [] files = baseFile.listFiles (new SampleFileFilter (fileNameEndStr));
    if (null != files && files.length > 0) {
        for (final File subFile : files) {
            if (subFile.isFile ()) list.add (subFile);
        }
    }
    if (deep <= 0) return list;
    files = baseFile.listFiles (IOUtils.DIR_FILTER);
    if (null != files && files.length > 0) {
        final int dp = -- deep;
        for (final File subFile : files) {
            list.addAll (IOUtils.listFiles (subFile.getAbsolutePath (), dp, fileNameEndStr));
        }
    }
    return list;
}


-----Function Pair=204=-----==

public Component getListCellRendererComponent (JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
    if (value.equals (list.getSelectedValue ())) {
        setBackground (list.getSelectionBackground ());
        setForeground (list.getSelectionForeground ());
        setOpaque (true);
    }
    else {
        setBackground (list.getBackground ());
        setForeground (list.getForeground ());
        setOpaque (list.isOpaque ());
    }
    String attachmentName = (String) value;
    UserMessageAttachment attachment = message.getAttachmentByName (attachmentName);
    if (attachment == null) {
        setIcon (null);
        setText ("NONEXISTANT: " + attachmentName);
    }
    else {
        setText (attachmentName);
        setIcon (attachment.isFolder () ? OpenGroove.Icons.FOLDER_16.getIcon () : OpenGroove.Icons.FILE_16.getIcon ());
    }
    return this;
}


public void finish () throws IOException {
    if (current != null) closeEntry ();
    long offset = bytes_written;
    int count = 0;
    int bytes = 0;
    while (chain != null) {
        bytes += write_entry (chain, false);
        ++ count;
        chain = chain.next;
    }
    put4 (0x06054b50);
    put2 (0);
    put2 (0);
    put2 (count);
    put2 (count);
    put4 (bytes);
    put4 (offset);
    byte [] c = comment.getBytes ("8859_1");
    put2 (c.length);
    if (c.length > 0) {
        out.write (c);
        out.write ((byte) 0);
    }
}


-----Function Pair=205=-----==

private void writeSchedules () throws IOException {
    Schedule.ScheduleChange schedules [];
    int cnt;
    short offset = 0;
    int i;
    int num;
    num = npcs.size ();
    OutputStream sfile = EUtil.U7create (EFile.GSCHEDULE);
    EUtil.Write4 (sfile, - 2);
    EUtil.Write4 (sfile, num);
    EUtil.Write2 (sfile, 0);
    EUtil.Write2 (sfile, 0);
    for (i = 1; i < num; i ++) {
        schedules = npcs.elementAt (i).getSchedules ();
        cnt = schedules == null ? 0 : schedules.length;
        offset += cnt;
        EUtil.Write2 (sfile, offset);
    }
    byte ent [] = new byte [20];
    for (i = 1; i < num; i ++) {
        schedules = npcs.elementAt (i).getSchedules ();
        cnt = schedules == null ? 0 : schedules.length;
        for (int j = 0; j < cnt; j ++) {
            schedules [j].write8 (ent);
            sfile.write (ent, 0, 8);
        }
    }
    sfile.close ();
}


private void onAdd () {
    String target;
    if (lastOpenLocation == null) target = ".";
    else target = lastOpenLocation;
    JFileChooser jfc = new JFileChooser (target);
    int status = jfc.showOpenDialog (this);
    if (status == JFileChooser.APPROVE_OPTION) {
        File f = jfc.getSelectedFile ();
        lastOpenLocation = f.getAbsolutePath ();
        Enumeration e = resFile.entries ();
        while (e.hasMoreElements ()) {
            if (((ZipEntry) e.nextElement ()).getName ().equals (f.getName ())) {
                JOptionPane.showMessageDialog (this, duplicateZipEntry.toString ());
                return;
            }
        }
        String comment = (String) JOptionPane.showInputDialog (this, msgNewComment, inputCaption.toString (), JOptionPane.QUESTION_MESSAGE, null, null, "");
        if (comment == null) return;
        addFile (f, comment);
        refreshTableContents ();
    }
}


-----Function Pair=206=-----==

private void init () {
    _setupPanel (_mainPanel);
    JScrollPane scrollPane = new JScrollPane (_mainPanel);
    Container cp = getContentPane ();
    GridBagLayout cpLayout = new GridBagLayout ();
    GridBagConstraints c = new GridBagConstraints ();
    cp.setLayout (cpLayout);
    c.fill = GridBagConstraints.BOTH;
    c.anchor = GridBagConstraints.NORTH;
    c.gridwidth = GridBagConstraints.REMAINDER;
    c.gridheight = GridBagConstraints.RELATIVE;
    c.weightx = 1.0;
    c.weighty = 1.0;
    cpLayout.setConstraints (scrollPane, c);
    cp.add (scrollPane);
    JPanel bottom = new JPanel ();
    bottom.setBorder (new EmptyBorder (5, 5, 5, 5));
    bottom.setLayout (new BoxLayout (bottom, BoxLayout.X_AXIS));
    bottom.add (Box.createHorizontalGlue ());
    bottom.add (_checkButton);
    bottom.add (_generateButton);
    bottom.add (_closeButton);
    bottom.add (Box.createHorizontalGlue ());
    c.fill = GridBagConstraints.NONE;
    c.anchor = GridBagConstraints.SOUTH;
    c.gridheight = GridBagConstraints.REMAINDER;
    c.weighty = 0.0;
    cpLayout.setConstraints (bottom, c);
    cp.add (bottom);
    Dimension dim = Toolkit.getDefaultToolkit ().getScreenSize ();
    if (dim.width > FRAME_WIDTH) {
        dim.width = FRAME_WIDTH;
    }
    else {
        dim.width -= 80;
    }
    if (dim.height > FRAME_HEIGHT) {
        dim.height = FRAME_HEIGHT;
    }
    else {
        dim.height -= 80;
    }
    setSize (dim);
    Utilities.setPopupLoc (this, _mainFrame);
    reset ();
}


private String addBarcode (String fieldName, Element record, String mergedFieldName, String imgWidth, String imgHeight, List < ImageToMerge > imagesToMerge) {
    List < Element > barcodeRecords = XMLUtil.getChildren (record, "barcodefield");
    for (int i = 0; i < barcodeRecords.size (); i ++) {
        Element barcodeRecord = (Element) barcodeRecords.get (i);
        String name = XMLUtil.getStringAttr (barcodeRecord, "name");
        if (name != null && fieldName.equals (name)) {
            String barcodeType = XMLUtil.getStringAttr (barcodeRecord, "type", "code39");
            boolean includeCaption = XMLUtil.getBooleanAttr (barcodeRecord, "caption", true);
            boolean checkDigit = XMLUtil.getBooleanAttr (barcodeRecord, "checkdigit", true);
            String barcodeValue = XMLUtil.getTextTrim (barcodeRecord);
            String mergedFileName = mergedFieldName + ".gif";
            imagesToMerge.add (new ImageToMerge (mergedFileName, barcodeValue, barcodeType, calcPixels (imgWidth), calcPixels (imgHeight), includeCaption, checkDigit));
            return mergedFileName;
        }
    }
    return null;
}


-----Function Pair=207=-----==

public static void zipFolder (File source, File destination, FileFilter filter) throws IOException {
    String ssource = source.getAbsolutePath ();
    String sdest = destination.getAbsolutePath ();
    if (sdest.contains (ssource)) {
        throw new AppRuntimeException ("The destination file cannot be a child of the source folder");
    }
    ZipOutputStream zo = new ZipOutputStream (new FileOutputStream (destination));
    if (source.isFile ()) {
        zip (zo, source, source);
    }
    else {
        File [] files;
        if (filter == null) {
            files = source.listFiles ();
        }
        else {
            files = source.listFiles (filter);
        }
        for (File f : files) {
            zip (zo, source, f);
        }
    }
    zo.close ();
}


public void UpdateTemplate (NpsContext ctxt, InputStream in) throws NpsException {
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        String sql = "update template set template=empty_clob() where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "select template from Template where id=? for update";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            oracle.sql.CLOB clob = (oracle.sql.CLOB) rs.getClob (1);
            java.io.Writer writer = clob.getCharacterOutputStream ();
            int i;
            while ((i = in.read ()) != - 1) {
                writer.write (i);
            }
            writer.flush ();
            try {
                writer.close ();
            } catch (Exception e1) {
            }
        }
        Clear ();
        DeleteJavaFiles ();
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            rs.close ();
        } catch (Exception e1) {
        }
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=208=-----==

public static void zipFolder (File source, File destination, FileFilter filter) throws IOException {
    String ssource = source.getAbsolutePath ();
    String sdest = destination.getAbsolutePath ();
    if (sdest.contains (ssource)) {
        throw new AppRuntimeException ("The destination file cannot be a child of the source folder");
    }
    ZipOutputStream zo = new ZipOutputStream (new FileOutputStream (destination));
    if (source.isFile ()) {
        zip (zo, source, source);
    }
    else {
        File [] files;
        if (filter == null) {
            files = source.listFiles ();
        }
        else {
            files = source.listFiles (filter);
        }
        for (File f : files) {
            zip (zo, source, f);
        }
    }
    zo.close ();
}


public void select (ImagePlus imp, int index) {
    int n = list.getItemCount ();
    if (index < 0) {
        for (int i = 0; i < n; i ++) if (list.isSelected (i)) list.deselect (i);
        if (record ()) Recorder.record ("roiManager", "Deselect");
        return;
    }
    if (index >= n) return;
    boolean mm = list.isMultipleMode ();
    if (mm) list.setMultipleMode (false);
    int delay = 1;
    long start = System.currentTimeMillis ();
    while (true) {
        list.select (index);
        if (delay > 1) IJ.wait (delay);
        if (list.isIndexSelected (index)) break;
        for (int i = 0; i < n; i ++) if (list.isSelected (i)) list.deselect (i);
        IJ.wait (delay);
        delay *= 2;
        if (delay > 32) delay = 32;
        if ((System.currentTimeMillis () - start) > 1000L) error ("Failed to select ROI " + index);
    }
    if (imp == null) imp = getImage ();
    restore (imp, index, true);
    if (mm) list.setMultipleMode (true);
}


-----Function Pair=209=-----==

private JobStatisticsBean getWorkflowStatistics (String userID, String workflowID) {
    JobStatisticsBean statBean = new JobStatisticsBean ();
    int finishedjobs = 0;
    int errorjobs = 0;
    String runtimeID = getRuntimeID (userID, workflowID);
    if (runtimeID != null) {
        ConcurrentHashMap < String, WorkflowData > workflows = PortalCacheService.getInstance ().getUser (userID).getWorkflows ();
        WorkflowData wrk_data = workflows.get (workflowID);
        long finishedJobNumber = wrk_data.getFinishedStatus ();
        long submittedJobNumber = wrk_data.getSubmittedStatus ();
        long errorJobNumber = wrk_data.getErrorStatus ();
        long runningJobNumber = wrk_data.getRunningStatus ();
        statBean.setErrorJobs (errorJobNumber);
        statBean.setSubmittedJobs (submittedJobNumber);
        statBean.setRunningJobs (runningJobNumber);
        statBean.setFinishedJobs (finishedJobNumber);
    }
    return statBean;
}


private void mergePropertiesFile (ZipInputStream zipIn, String filename) throws IOException {
    Properties incoming = new Properties ();
    incoming.load (zipIn);
    File destFile = new File (dir, filename);
    Properties original = new Properties ();
    if (destFile.exists ()) original.load (new FileInputStream (destFile));
    Properties merged = new SortedProperties ();
    merged.putAll (original);
    for (Iterator i = incoming.entrySet ().iterator (); i.hasNext ();) {
        Map.Entry e = (Map.Entry) i.next ();
        String key = (String) e.getKey ();
        String value = (String) e.getValue ();
        if (key.endsWith (BROKEN_SUFFIX)) {
            String intendedKey = key.substring (0, key.length () - BROKEN_SUFFIX.length ());
            if (original.containsKey (intendedKey)) continue;
        }
        merged.put (key, value);
    }
    if (original.equals (merged)) {
        if (verbose) System.out.println ("    No new properties in '" + filename + "'");
        return;
    }
    if (verbose) System.out.print ("    ");
    System.out.println ("Updating '" + filename + "'");
    FileOutputStream out = new FileOutputStream (destFile);
    merged.store (out, PROP_FILE_HEADER);
    out.close ();
}


-----Function Pair=210=-----==

public static String convertHexadecimal2RGB (String hexColor, String divider) {
    String hex = hexColor.replaceFirst ("#", "");
    if (hex.length () != 6) return null;
    StringBuilder sb = new StringBuilder ();
    String toCon = hex.substring (0, 2);
    int color = Integer.parseInt (toCon, 16);
    sb.append (color);
    for (int i = 2; i < 6; i += 2) {
        toCon = hex.substring (i, i + 2);
        color = Integer.parseInt (toCon, 16);
        sb.append (divider);
        sb.append (color);
    }
    return sb.toString ();
}


protected void addFile (File newEntry, String name) {
    if (newEntry.isDirectory ()) {
        return;
    }
    try {
        ZipEntry ze = new ZipEntry (name);
        mZos.putNextEntry (ze);
        FileInputStream fis = new FileInputStream (newEntry);
        byte fdata [] = new byte [512];
        int readCount = 0;
        while ((readCount = fis.read (fdata)) != - 1) {
            mZos.write (fdata, 0, readCount);
        }
        fis.close ();
        mZos.closeEntry ();
        mObserverCont.setNext (ze);
        mObserverCont.setCount (++ miCurrentCount);
    } catch (Exception ex) {
        mObserverCont.setError (ex.getMessage ());
    }
}


-----Function Pair=211=-----==

public void addPackage (String packageName, boolean recursive, final UserClassLoader loader) throws IOException {
    String [] paths = loader.getPaths ();
    final String packagePath = packageName == null ? null : (packageName.replace ('.', '/') + "/");
    int prevSize = size ();
    for (String p : paths) {
        File file = new File (p);
        if (file.isDirectory ()) {
            addMatchingDir (null, file, packagePath, recursive, loader);
        }
        else {
            JarInputStream jis = new JarInputStream (new FileInputStream (file));
            ZipEntry e = jis.getNextEntry ();
            while (e != null) {
                addMatchingFile (e.getName (), packagePath, recursive, loader);
                jis.closeEntry ();
                e = jis.getNextEntry ();
            }
            jis.close ();
        }
    }
    if (prevSize == size ()) {
        if (packageName == null) {
            System.err.println ("Warning: No classes found in the unnamed package");
            printHelp ();
        }
        else {
            System.err.println ("Warning: No classes found in package " + packageName);
        }
    }
}


private void setOptionsFromTransactionParams (NodeTransaction transaction) throws ParseException {
    orgId = getOrgIdFromTransaction (transaction);
    debug ("orgId = " + orgId);
    int argCount = transaction.getRequest ().getParameters ().size ();
    if (argCount >= 2) {
        String addHeader = getOptionalValueFromTransactionArgs (transaction, PARAM_INDEX_ADD_HEADER);
        if (StringUtils.isNotBlank (addHeader)) {
            makeHeader = Boolean.parseBoolean (addHeader);
            debug ("makeHeader = " + makeHeader);
        }
    }
    if (argCount >= 3) {
        String useHistory = getOptionalValueFromTransactionArgs (transaction, PARAM_INDEX_USE_HISTORY);
        if (StringUtils.isNotBlank (useHistory)) {
            useSubmissionHistory = Boolean.parseBoolean (useHistory);
            debug ("useSubmissionHistory = " + useSubmissionHistory);
        }
    }
    if (argCount >= 4) {
        String startString = getOptionalValueFromTransactionArgs (transaction, PARAM_INDEX_START_DATE);
        debug ("startString = " + startString);
        String endString = null;
        if (argCount >= 5) {
            endString = getOptionalValueFromTransactionArgs (transaction, PARAM_INDEX_END_DATE);
            debug ("endString = " + endString);
        }
        if (StringUtils.isNotBlank (startString)) {
            startDate = makeTimestamp (startString);
            debug ("startDate = " + startDate);
            if (StringUtils.isNotBlank (endString)) {
                endDate = makeTimestamp (endString);
            }
            else {
                endDate = new Timestamp (System.currentTimeMillis ());
            }
            debug ("endDate = " + endDate);
        }
    }
}


-----Function Pair=212=-----==

void expand (File dir, String [] files, boolean isUpdate) {
    if (files == null) {
        return;
    }
    for (int i = 0; i < files.length; i ++) {
        File f;
        if (dir == null) {
            f = new File (files [i]);
        }
        else {
            f = new File (dir, files [i]);
        }
        if (f.isFile ()) {
            if (entries.add (f)) {
                if (isUpdate) entryMap.put (entryName (f.getPath ()), f);
            }
        }
        else if (f.isDirectory ()) {
            if (entries.add (f)) {
                if (isUpdate) {
                    String dirPath = f.getPath ();
                    dirPath = (dirPath.endsWith (File.separator)) ? dirPath : (dirPath + File.separator);
                    entryMap.put (entryName (dirPath), f);
                }
                expand (f, f.list (), isUpdate);
            }
        }
        else {
            error (formatMsg ("error.nosuch.fileordir", String.valueOf (f)));
            ok = false;
        }
    }
}


private byte [] showAutoDelItems (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "AutoDelItems.html");
    HashMap < String, KeepForDetails > items = store.getAutoDelList ();
    String [] key = (String []) items.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        KeepForDetails item = (KeepForDetails) items.get (key [x]);
        out.append ("<tr>\n");
        out.append ("<td>" + item.getCreated ().toString () + "</td>");
        out.append ("<td>" + item.getFileName () + "</td>");
        out.append ("<td>" + item.getKeepFor () + "</td>");
        out.append ("<td><a href='/servlet/" + urlData.getServletClass () + "?action=07&id=" + key [x] + "'>remove</a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$itemList", out.toString ());
    template.replaceAll ("$autoDelLog", store.getAutoDelLog ());
    return template.getPageBytes ();
}


-----Function Pair=213=-----==

public boolean copyItems (SparseBooleanArray cis, CommanderAdapter to, boolean move) {
    try {
        if (zip == null) throw new RuntimeException ("Invalid ZIP");
        ZipEntry [] subItems = bitsToItems (cis);
        if (subItems == null) throw new RuntimeException ("Nothing to extract");
        if (! checkReadyness ()) return false;
        File dest = null;
        int rec_h = 0;
        if (to instanceof FSAdapter) {
            dest = new File (to.toString ());
            if (! dest.exists ()) dest.mkdirs ();
            if (! dest.isDirectory ()) throw new RuntimeException (ctx.getString (R.string.dest_exist));
        }
        else {
            dest = new File (createTempDir ());
            rec_h = setRecipient (to);
        }
        notify (Commander.OPERATION_STARTED);
        worker = new CopyFromEngine (workerHandler, subItems, dest, rec_h);
        worker.start ();
        return true;
    } catch (Exception e) {
        commander.showError ("Exception: " + e.getMessage ());
    }
    return false;
}


public < T > T readObject (ByteBuffer data, Class < T > c) throws IOException {
    try {
        ZIPCompressedMessage result = new ZIPCompressedMessage ();
        byte [] byteArray = new byte [data.remaining ()];
        data.get (byteArray);
        ZipInputStream in = new ZipInputStream (new ByteArrayInputStream (byteArray));
        in.getNextEntry ();
        ByteArrayOutputStream out = new ByteArrayOutputStream ();
        byte [] tmp = new byte [9012];
        int read;
        while (in.available () > 0 && ((read = in.read (tmp)) > 0)) {
            out.write (tmp, 0, read);
        }
        in.closeEntry ();
        out.flush ();
        in.close ();
        result.setMessage ((Message) Serializer.readClassAndObject (ByteBuffer.wrap (out.toByteArray ())));
        return (T) result;
    } catch (Exception e) {
        e.printStackTrace ();
        throw new IOException (e.toString ());
    }
}


-----Function Pair=214=-----==

public void Delete (NpsContext ctxt) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        List topics = null;
        if (Config.CACHE) {
            topics = GetTopics (ctxt);
        }
        String sql = "delete from topic_pts where templateid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update topic set art_template=null where art_template=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from template where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        for (int i = 0; topics != null && i < topics.size (); i ++) {
            TopicProfile profile = (TopicProfile) topics.get (i);
            Site site = ctxt.GetSite (profile.GetSiteId ());
            if (site == null) continue;
            TopicTree topic_tree = site.GetTopicTree ();
            if (topic_tree == null) continue;
            Topic topic = topic_tree.GetTopic (profile.GetId ());
            if (topic == null) continue;
            if (this instanceof ArticleTemplate) topic.SetArticleTemplate (null);
            else topic.RemovePageTemplate (id);
        }
        DeleteJavaFiles ();
        TemplatePool.GetPool ().remove (this);
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


public static PositionScoreTextData merge (ArrayList < PositionScoreTextData > pdAL) {
    PositionScoreTextData [] pdArray = new PositionScoreTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionScoreTexts.length;
    PositionScoreText [] concatinate = new PositionScoreText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionScoreText [] slice = pdArray [i].sortedPositionScoreTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionScoreTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionScoreTextData (concatinate, sliceInfo);
}


-----Function Pair=215=-----==

private void publishPage (URL url, String path, File outputFile) throws IOException {
    if (debug) {
        System.out.println ("      publishing page: " + path);
        System.out.println ("        url == " + url);
        System.out.println ("        file == " + outputFile);
    }
    StringBuffer sb = new StringBuffer ();
    try {
        InputStream is = url.openStream ();
        InputStreamReader isr = new InputStreamReader (is);
        BufferedReader br = new BufferedReader (isr);
        boolean firstLine = true;
        String line;
        do {
            line = br.readLine ();
            if (line != null) {
                if (! firstLine) sb.append ("\n");
                else firstLine = false;
                sb.append (line);
            }
        }
        while (line != null);
        br.close ();
    } catch (IOException e) {
        String mess = outputFile.toString () + ": " + e.getMessage ();
        errors.add (mess);
    }
    FileOutputStream fos = new FileOutputStream (outputFile);
    OutputStreamWriter sw = new OutputStreamWriter (fos);
    sw.write (sb.toString ());
    sw.close ();
    if (prepareArchive) archiveFiles.add (new ArchiveFile (path, outputFile));
}


public String [] queryACCByNameDescriptionAndBusinessTerms (String name, String [] desc, String objectClassTerm, String [] businessTerms) {
    try {
        init (null, null, false);
        String entryType = "ACC";
        name = "%" + name + "%";
        desc = appendLike (desc);
        objectClassTerm = "%" + objectClassTerm + "%";
        businessTerms = appendLike (businessTerms);
        boolean businessTermsFlag = false;
        boolean descriptionFlag = false;
        if (businessTerms.length > 0) {
            businessTermsFlag = true;
        }
        if (desc.length > 0) {
            descriptionFlag = true;
        }
        String qString = "SELECT eo.* FROM Extrinsicobject eo WHERE ";
        qString += "id IN (SELECT nm.parent FROM NAME_ nm WHERE upper(nm.value) LIKE upper('" + name + "')) AND ";
        qString += "id IN (SELECT sl1.parent FROM SLOT sl1 WHERE sl1.value='" + entryType + "' AND sl1.name='" + SLOT_ENTRY_TYPE + "' ) AND ";
        if (! objectClassTerm.contentEquals ("%null%")) {
            qString += "id IN (SELECT sl1.parent FROM SLOT sl1 WHERE upper(sl1.value) LIKE upper('" + objectClassTerm + "') AND sl1.name='" + SLOT_OBJECT_CLASS_TERM + "' ) AND ";
        }
        if (qString.endsWith ("AND ")) {
            qString = qString.substring (0, qString.length () - 4);
            qString += " ";
        }
        if (descriptionFlag) {
            qString += "AND (";
            for (int i = 0; i != desc.length; i ++) {
                qString += " id IN (SELECT descr.parent FROM DESCRIPTION descr WHERE upper(descr.value) LIKE upper('" + desc [i] + "')) OR";
            }
            qString = qString.substring (0, qString.length () - 2);
            qString += ")";
        }
        if (businessTermsFlag) {
            qString += " AND (";
            for (int i = 0; i != businessTerms.length; i ++) {
                qString += " id IN (SELECT slot1.parent FROM SLOT slot1 WHERE slot1.name_='Business Terms' AND upper(slot1.value) LIKE upper('" + businessTerms [i] + "')) OR";
            }
            qString = qString.substring (0, qString.length () - 2);
            qString += ")";
        }
        System.out.println (qString);
        Query qry = dqm.createQuery (Query.QUERY_TYPE_SQL, qString);
        Object [] EOlist = dqm.executeQuery (qry).getCollection ().toArray ();
        System.out.println (EOlist.length);
        results = new String [EOlist.length];
        for (int i = 0; i != EOlist.length; i ++) {
            results [i] = parseToXML ((ExtrinsicObject) EOlist [i]);
        }
    } catch (InvalidRequestException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (JAXRException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return results;
}


-----Function Pair=216=-----==

public static File getClasspathDir (Class clazz) throws GorillaException {
    String className = clazz.getName ();
    String resourceName = "/" + className.replaceAll ("\\.", "/") + ".class";
    URL url = clazz.getResource (resourceName);
    if (url == null) {
        throw new GorillaException ("could not bootstrap root of classpath" + " for class" + className);
    }
    String urlString = url.toString ();
    urlString = urlString.substring (0, urlString.lastIndexOf (resourceName) + 1);
    try {
        url = new URL (urlString);
    } catch (java.net.MalformedURLException e) {
        throw new GorillaException (e.getMessage ());
    }
    URLConnection conn;
    try {
        conn = url.openConnection ();
    } catch (IOException e) {
        throw new GorillaException ("IOException attempting to open classpath" + " \"" + url.toString () + "\":" + e.getMessage ());
    }
    String urlFileName = null;
    if (conn instanceof JarURLConnection) {
        url = ((JarURLConnection) conn).getJarFileURL ();
        urlFileName = url.getFile ();
        urlFileName = urlFileName.substring (0, urlFileName.lastIndexOf ("/"));
    }
    else {
        urlFileName = url.getFile ();
    }
    String bootFullPath = "could not parse url for file: " + urlFileName;
    try {
        bootFullPath = URLDecoder.decode (urlFileName, "UTF-8");
    } catch (UnsupportedEncodingException e) {
        throw new GorillaException (bootFullPath + ": " + e.getMessage ());
    }
    File file = new File (bootFullPath);
    return file;
}


public static void MakeZip (final OutputStream outs, final String [] filenames) {
    final byte [] buf = new byte [2048];
    try {
        final ZipOutputStream out = new ZipOutputStream (outs);
        out.setLevel (ZipOutputStream.STORED);
        for (int i = 0; i < filenames.length; i ++) {
            File file = new File (filenames [i]);
            if (file.canRead ()) {
                final FileInputStream in = new FileInputStream (file);
                try {
                    out.putNextEntry (new ZipEntry (file.getName ()));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                } catch (ZipException z) {
                    System.err.println ("EXPORT ERROR (Continuing):" + z.toString ());
                }
                in.close ();
            }
            else {
                System.out.println ("Skipping file during zip:" + filenames [i]);
            }
        }
        out.close ();
    } catch (IOException e) {
        System.err.println ("EXPORT FATAL ERROR:" + e.toString ());
        System.err.println (e);
    }
}


-----Function Pair=217=-----==

public void openItem (int position) {
    if (position == 0) {
        if (uri != null) {
            String cur = null;
            try {
                cur = uri.getFragment ();
            } catch (Exception e) {
            }
            if (cur == null || cur.length () == 0 || (cur.length () == 1 && cur.charAt (0) == SLC)) {
                File zip_file = new File (uri.getPath ());
                String parent_dir = zip_file.getParent ();
                commander.Navigate (Uri.parse (parent_dir != null ? parent_dir : Panels.DEFAULT_LOC), null, zip_file.getName ());
            }
            else {
                File cur_f = new File (cur);
                String parent_dir = cur_f.getParent ();
                commander.Navigate (uri.buildUpon ().fragment (parent_dir != null ? parent_dir : "").build (), null, cur_f.getName ());
            }
        }
        return;
    }
    if (items == null || position < 0 || position > items.length) return;
    ZipEntry item = items [position - 1];
    if (item.isDirectory ()) {
        commander.Navigate (uri.buildUpon ().fragment (fixName (item)).build (), null, null);
    }
    else {
        commander.Open (uri.buildUpon ().fragment (fixName (item)).build (), null);
    }
}


private byte [] stopRunningTask (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (4096);
    String id = urlData.getParameter ("id");
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    ScheduleItem si = null;
    ThreadLock.getInstance ().getLock ();
    try {
        si = store.getScheduleItem (id);
        if (si != null && si.getState () == ScheduleItem.RUNNING) {
            si.abort ();
            si.setStatus ("Aborting");
            si.setState (ScheduleItem.ABORTED);
            si.log ("Item marked for abortion");
        }
    } finally {
        ThreadLock.getInstance ().releaseLock ();
    }
    int counts = 10;
    while (si.getState () == ScheduleItem.ABORTED && counts > 0) {
        counts --;
        Thread.sleep (1000);
    }
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=218=-----==

public static void zip (File srcDir, File destFile, FileFilter filter) throws IOException {
    ZipOutputStream out = null;
    try {
        out = new ZipOutputStream (new FileOutputStream (destFile));
        Collection < File > files = FileUtils.listFiles (srcDir, TrueFileFilter.TRUE, TrueFileFilter.TRUE);
        for (File f : files) {
            if (filter == null || filter.accept (f)) {
                FileInputStream in = FileUtils.openInputStream (f);
                out.putNextEntry (new ZipEntry (Util.relativePath (srcDir, f).replace ('\\', '/')));
                IOUtils.copyLarge (in, out);
                out.closeEntry ();
                IOUtils.closeQuietly (in);
            }
        }
        IOUtils.closeQuietly (out);
    } catch (Throwable t) {
        throw new IOException ("Failed to create zip file", t);
    } finally {
        if (out != null) {
            out.flush ();
            IOUtils.closeQuietly (out);
        }
    }
}


private void handleException (File inFile, Node child, Exception e) {
    hasCaughtException = true;
    String name = inFile.getAbsolutePath ();
    Date date = new Date ();
    SimpleDateFormat sdf = new SimpleDateFormat ();
    sdf.applyPattern ("yy-MM-dd-ss");
    name = name.substring (0, name.lastIndexOf ('.')) + "-failed-" + sdf.format (date) + ".zip";
    File save = new File (name);
    if (save.exists ()) {
        if (! save.delete ()) {
            StatusHandler.log ("Unable to delete old backup tasklist file", this);
            return;
        }
    }
    if (! copy (inFile, save)) {
        inFile.renameTo (new File (name));
    }
    if (child == null) {
        StatusHandler.log (e, ITasksUiConstants.MESSAGE_RESTORE);
    }
    else {
        e.printStackTrace ();
        StatusHandler.log (e, "Tasks may have been lost from " + child.getNodeName ());
    }
}


-----Function Pair=219=-----==

public static String GC2HHMM (GregorianCalendar hora) {
    int h, m;
    String resp, hs = "", ms = "";
    try {
        h = hora.get (Calendar.HOUR_OF_DAY);
        m = hora.get (Calendar.MINUTE);
        if (h < 10) {
            hs = "0";
        }
        if (m < 10) {
            ms = "0";
        }
        resp = hs + h + ":" + ms + m;
        return resp;
    } catch (Exception e) {
        return "Erro na convers�o para String: " + e.toString ();
    }
}


public void read (DataInputStream dis) {
    try {
        header = dis.readUTF ();
        int numberPositions = sliceInfo.getNumberRecords ();
        sortedPositions = new Position [numberPositions];
        sortedPositions [0] = new Position (dis.readInt ());
        String fileType = sliceInfo.getBinaryType ();
        if (USeqUtilities.POSITION_INT.matcher (fileType).matches ()) {
            for (int i = 1; i < numberPositions; i ++) {
                sortedPositions [i] = new Position (sortedPositions [i - 1].getPosition () + dis.readInt ());
            }
        }
        else if (USeqUtilities.POSITION_SHORT.matcher (fileType).matches ()) {
            for (int i = 1; i < numberPositions; i ++) {
                sortedPositions [i] = new Position (sortedPositions [i - 1].getPosition () + dis.readShort () + 32768);
            }
        }
        else {
            throw new IOException ("Incorrect file type for creating a Position[] -> '" + fileType + "' in " + binaryFile + "\n");
        }
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (dis);
    }
}


-----Function Pair=220=-----==

private List < RE > preparePatterns (ArrayList < String > list, RECompiler recompiler) {
    ArrayList < RE > result = new ArrayList < RE > ();
    for (String element : list) {
        if ((element != null) && (element.length () > 0)) {
            element = this.vs.substitute (element, "plain");
            File f = new File (element);
            if (! f.isAbsolute ()) {
                element = new File (this.absolute_installpath, element).toString ();
            }
            StringBuffer element_re = new StringBuffer ();
            int lookahead = - 1;
            int pos = 0;
            while (pos < element.length ()) {
                char c;
                if (lookahead != - 1) {
                    c = (char) lookahead;
                    lookahead = - 1;
                }
                else {
                    c = element.charAt (pos ++);
                }
                switch (c) {
                    case '/' :
                        {
                            element_re.append (File.separator);
                            break;
                        }
                    case '\\' :
                    case '.' :
                        {
                            element_re.append ("\\");
                            element_re.append (c);
                            break;
                        }
                    case '*' :
                        {
                            if (pos == element.length ()) {
                                element_re.append ("[^").append (File.separator).append ("]*");
                                break;
                            }
                            lookahead = element.charAt (pos ++);
                            if (lookahead == '*') {
                                element_re.append (".*");
                                lookahead = - 1;
                            }
                            else {
                                element_re.append ("[^").append (File.separator).append ("]*");
                            }
                            break;
                        }
                    default :
                        {
                            element_re.append (c);
                            break;
                        }
                }
            }
            element_re.append ('$');
            try {
                result.add (new RE (recompiler.compile (element_re.toString ())));
            } catch (RESyntaxException e) {
                this.handler.emitNotification ("internal error: pattern \"" + element + "\" produced invalid RE \"" + f.getPath () + "\"");
            }
        }
    }
    return result;
}


private void addToJar (JarOutputStream out, InputStream in, String entryName, long length) throws IOException {
    byte [] buf = new byte [2048];
    ZipEntry entry = new ZipEntry (entryName);
    CRC32 crc = new CRC32 ();
    entry.setSize (length);
    entry.setCrc (crc.getValue ());
    out.putNextEntry (entry);
    int read = in.read (buf);
    while (read > 0) {
        crc.update (buf, 0, read);
        out.write (buf, 0, read);
        read = in.read (buf);
    }
    entry.setCrc (crc.getValue ());
    in.close ();
    out.closeEntry ();
}


-----Function Pair=221=-----==

public static boolean delAllFile (String path) throws Exception {
    boolean flag = false;
    File file = new File (path);
    if (! file.exists ()) {
        return flag;
    }
    if (! file.isDirectory ()) {
        return flag;
    }
    String [] tempList = file.list ();
    File temp = null;
    for (int i = 0; i < tempList.length; i ++) {
        if (path.endsWith (File.separator)) {
            temp = new File (path + tempList [i]);
        }
        else {
            temp = new File (path + File.separator + tempList [i]);
        }
        if (temp.isFile ()) {
            temp.delete ();
        }
        if (temp.isDirectory ()) {
            delAllFile (path + "/" + tempList [i]);
            delFolder (path + "/" + tempList [i]);
            flag = true;
        }
    }
    return flag;
}


private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Run\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=44&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/RunTaskSmall.png' border='0' alt='Delete' title='Run' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("tasks.deftask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("tasks.pretask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("tasks.starterrortask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("tasks.nodataerrortask"));
    return template.getPageBytes ();
}


-----Function Pair=222=-----==

public boolean save (final File f) {
    if (this.zipWorkflow) {
        this.zipEntries.clear ();
        final int bufsize = 1024;
        final File zipFile = f;
        ZipOutputStream zos;
        try {
            final FileOutputStream fos = new FileOutputStream (zipFile);
            zos = new ZipOutputStream (new BufferedOutputStream (fos));
            this.log.info ("Created zip output stream");
            final byte [] input_buffer = new byte [bufsize];
            final Iterator < IWorkflowResult > iter = this.iw.getResults ();
            File basedir = FileTools.prependDefaultDirsWithPrefix ("", null, this.iw.getStartupDate ());
            this.log.info ("marked basedir for deletion on exit: {}", basedir);
            if (this.deleteOnExit) {
                basedir.deleteOnExit ();
            }
            this.log.info ("setting basedir to parent file: {}", basedir.getParentFile ());
            basedir = basedir.getParentFile ();
            while (iter.hasNext ()) {
                final IWorkflowResult iwr = iter.next ();
                if (iwr instanceof IWorkflowFileResult) {
                    final IWorkflowFileResult iwfr = (IWorkflowFileResult) iwr;
                    final File file = iwfr.getFile ();
                    this.log.info ("Retrieving file result {}", file);
                    final File parent = file.getParentFile ();
                    this.log.info ("Retrieving parent of file result {}", parent);
                    if (parent.getAbsolutePath ().startsWith (basedir.getAbsolutePath ()) && ! parent.getAbsolutePath ().equals (basedir.getAbsolutePath ())) {
                        this.log.info ("Marking file and parent for deletion");
                        if (this.deleteOnExit) {
                            parent.deleteOnExit ();
                            file.deleteOnExit ();
                        }
                    }
                    if (file.getAbsolutePath ().startsWith (basedir.getAbsolutePath ())) {
                        this.log.info ("Marking file for deletion");
                        if (this.deleteOnExit) {
                            file.deleteOnExit ();
                        }
                    }
                    if ((this.ff != null) && ! this.ff.accept (file)) {
                        continue;
                    }
                    else {
                        this.log.info ("Adding zip entry!");
                        addZipEntry (bufsize, zos, input_buffer, file);
                    }
                }
            }
            final File runtimeProps = FileTools.prependDefaultDirsWithPrefix ("", null, this.iw.getStartupDate ());
            this.log.info ("Saving config to {}", runtimeProps);
            Factory.saveConfiguration (Factory.getInstance ().getConfiguration (), runtimeProps);
            if (runtimeProps.exists () && runtimeProps.canRead ()) {
                this.log.info ("Marking file for deletion");
                if (this.deleteOnExit) {
                    runtimeProps.deleteOnExit ();
                }
                addZipEntry (bufsize, zos, input_buffer, runtimeProps);
            }
            try {
                zos.flush ();
                zos.close ();
            } catch (final IOException e) {
                throw new RuntimeException (e);
            }
        } catch (final IOException e) {
            throw new RuntimeException (e);
        }
        return true;
    }
    else {
        this.log.debug ("Configured to not zip Workflow results!");
        return false;
    }
}


public static boolean zipDirectoryRecursiveOld (File path, File zipFileName, String excludeRegEx, boolean relative, boolean compress) {
    ArrayList < File > filesToZip = new ArrayList < File > ();
    if (path.exists ()) {
        File [] files = path.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            if (files [i].isDirectory ()) {
                FileTools.listFilesRecursive (files [i], filesToZip);
            }
            else {
                filesToZip.add (files [i]);
            }
        }
    }
    try {
        byte [] buffer = new byte [18024];
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));
        if (! compress) {
            out.setLevel (Deflater.NO_COMPRESSION);
        }
        else {
            out.setLevel (Deflater.DEFAULT_COMPRESSION);
        }
        for (int i = 0; i < filesToZip.size (); i ++) {
            if (excludeRegEx == null || ! filesToZip.get (i).getName ().contains (excludeRegEx)) {
                FileInputStream in = new FileInputStream (filesToZip.get (i));
                String filePath = filesToZip.get (i).getPath ();
                if (relative) {
                    filePath = filePath.replaceFirst (path.getAbsolutePath () + File.separator, "");
                }
                System.out.println ("Deflating: " + filePath);
                out.putNextEntry (new ZipEntry (filePath));
                int len;
                while ((len = in.read (buffer)) > 0) {
                    out.write (buffer, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
        }
        out.close ();
    } catch (IllegalArgumentException iae) {
        iae.printStackTrace ();
        return (false);
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
        return (false);
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        return (false);
    }
    return (true);
}


-----Function Pair=223=-----==

public static void packeAlleDrinkObjekte (String zipfile) {
    File f = new File (".");
    try {
        String entries [] = f.list (new DrnFilenameFilter ());
        byte [] buf = new byte [BLOCKSIZE];
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipfile));
        for (int i = 0; i < entries.length; ++ i) {
            File ff = new File (entries [i]);
            System.out.println ("adding " + ff);
            FileReader in = new FileReader (ff);
            out.putNextEntry (new ZipEntry (entries [i]));
            int len;
            while ((len = in.read ()) > 0) {
                out.write (len);
            }
            in.close ();
            in = null;
            FileUtil.deleteFile (ff);
        }
        out.close ();
        out = null;
    } catch (IOException e) {
        System.err.println (e.toString ());
    }
}


public void write (ZipOutputStream out, DataOutputStream dos, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegionScoreTexts [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
            int currentStart = sortedRegionScoreTexts [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegionScoreTexts.length; i ++) {
            int diff = sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    fileType = fileType + USeqUtilities.FLOAT + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = null;
    try {
        out.putNextEntry (new ZipEntry (sliceInfo.getSliceName ()));
        dos.writeUTF (header);
        dos.writeInt (sortedRegionScoreTexts [0].start);
        int bp = sortedRegionScoreTexts [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                dos.writeFloat (sortedRegionScoreTexts [0].score);
                dos.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    dos.writeFloat (sortedRegionScoreTexts [i].score);
                    dos.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                dos.writeFloat (sortedRegionScoreTexts [0].score);
                dos.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    dos.writeFloat (sortedRegionScoreTexts [i].score);
                    dos.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start);
                dos.writeFloat (sortedRegionScoreTexts [0].score);
                dos.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeInt (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start);
                    dos.writeFloat (sortedRegionScoreTexts [i].score);
                    dos.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionScoreTexts [0].stop - sortedRegionScoreTexts [0].start - 32768));
                dos.writeFloat (sortedRegionScoreTexts [0].score);
                dos.writeUTF (sortedRegionScoreTexts [0].text);
                for (int i = 1; i < sortedRegionScoreTexts.length; i ++) {
                    int currentStart = sortedRegionScoreTexts [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeShort ((short) (sortedRegionScoreTexts [i].stop - sortedRegionScoreTexts [i].start - 32768));
                    dos.writeFloat (sortedRegionScoreTexts [i].score);
                    dos.writeUTF (sortedRegionScoreTexts [i].text);
                    bp = currentStart;
                }
            }
        }
        out.closeEntry ();
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (out);
        USeqUtilities.safeClose (dos);
    }
}


-----Function Pair=224=-----==

private static void compress (ZipOutputStream zos, String rootpath, File source) throws IOException {
    if (source.isFile ()) {
        ZipEntry zipEntry = new ZipEntry (source.getName ());
        zos.putNextEntry (zipEntry);
        FileInputStream fis = new FileInputStream (source);
        byte [] buffer = new byte [1024];
        for (int length; (length = fis.read (buffer)) > 0;) {
            zos.write (buffer, 0, length);
        }
        fis.close ();
        zos.closeEntry ();
    }
    else if (source.isDirectory ()) {
        File [] files = source.listFiles ();
        for (File file : files) {
            compress (zos, rootpath, file);
        }
    }
}


public static File extractZipEntry (File zipFile, String entryName, File outFile) throws IOException {
    ZipInputStream zIn;
    ZipEntry zipEntry;
    int bytesRead;
    final int bufSize = 8192;
    byte buf [] = new byte [bufSize];
    if (! outFile.getParentFile ().exists ()) {
        outFile.getParentFile ().mkdirs ();
    }
    BufferedInputStream in = new BufferedInputStream (new FileInputStream (zipFile), bufSize);
    zIn = new ZipInputStream (in);
    while ((zipEntry = zIn.getNextEntry ()) != null) {
        String zipEntryName = zipEntry.getName ();
        if (zipEntryName.equalsIgnoreCase (entryName)) {
            break;
        }
        zIn.closeEntry ();
    }
    if (zipEntry == null) {
        return null;
    }
    BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (outFile), bufSize);
    while ((bytesRead = zIn.read (buf)) != - 1) {
        out.write (buf, 0, bytesRead);
    }
    out.flush ();
    out.close ();
    zIn.close ();
    outFile.setLastModified (zipEntry.getTime ());
    return outFile;
}


-----Function Pair=225=-----==

public void process () {
    try {
        update ("Shutdown knowledge base ...", 0);
        DBHelper.shutdownDB ();
        update ("Shutdown knowledge base ...", 9);
        String zipDir = P.DIR.getPKBDataPath ();
        update ("Backup in progress ...", 10);
        List < String > fileList = getFilesToZip (zipDir);
        File file = new File (fileName);
        ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (file));
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < fileList.size (); i ++) {
            String filePath = fileList.get (i);
            File f = new File (filePath);
            FileInputStream fis = new FileInputStream (f);
            String zipEntryName = f.getPath ().substring (zipDir.length () + 1);
            ZipEntry anEntry = new ZipEntry (zipEntryName);
            zout.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zout.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
            int percentage = (int) Math.round ((i + 1) * 80.0 / fileList.size ());
            update ("Backup in progress ...", 10 + percentage);
        }
        zout.close ();
        update ("Restart knowledge base ...", 91);
        DBHelper.startDB ();
        update ("Backup is done!", 100);
    } catch (Exception ex) {
        ex.printStackTrace ();
        update ("Error occurs during backup!", 100);
    }
}


protected void overlayPlugin (IPluginEntry oldPlugin, IPluginEntry newPlugin, IFeatureContentConsumer consumer) throws CoreException, IOException {
    if (newPlugin instanceof PluginEntry && ((PluginEntry) newPlugin).isUnpack ()) {
        super.overlayPlugin (oldPlugin, newPlugin, consumer);
    }
    URL oldURI = null;
    try {
        oldURI = new URL (consumer.getFeature ().getSite ().getURL ().getPath () + Site.DEFAULT_PLUGIN_PATH + oldPlugin.getVersionedIdentifier ().toString ());
    } catch (MalformedURLException e) {
        throw new IOException (e.getMessage ());
    }
    File oldJarFile = new File (oldURI.toExternalForm ());
    JarFile oldJar = new JarFile (oldJarFile);
    URL newURI = null;
    try {
        newURI = new URL (consumer.getFeature ().getSite ().getURL ().getPath () + Site.DEFAULT_PLUGIN_PATH + newPlugin.getVersionedIdentifier ().toString ());
    } catch (MalformedURLException e) {
        throw new IOException (e.getMessage ());
    }
    File newJarFile = new File (newURI.toExternalForm ());
    JarFile newJar = new JarFile (newJarFile);
    String tempFileName = oldURI + "-" + (new Date ()).getTime ();
    File tempFile = new File (tempFileName);
    FileOutputStream fos = new FileOutputStream (tempFile);
    JarOutputStream jos = new JarOutputStream (fos);
    addToJar (jos, newJar);
    addToJar (jos, oldJar);
    jos.closeEntry ();
    jos.finish ();
    fos.close ();
    newJar.close ();
    oldJar.close ();
    newJarFile = new File (newURI.toExternalForm ());
    newJarFile.delete ();
    newJarFile.createNewFile ();
    copyFile (tempFile, newJarFile);
}


-----Function Pair=226=-----==

private static void compress (File root, File in, ZipOutputStream out, MessageDigest md, Set < String > fileNamesToSkipInCheckSumCalculation) throws IOException {
    if (in.isDirectory ()) {
        List < File > files = Arrays.asList (in.listFiles ());
        if (md != null) {
            Collections.sort (files, new Comparator < File > () {
                public int compare (File o1, File o2) {
                    return o1.getName ().compareTo (o2.getName ());
                }
            }
            );
        }
        for (File f : files) {
            compress (root, f, out, md, fileNamesToSkipInCheckSumCalculation);
        }
    }
    else {
        String path = root.toURI ().relativize (in.toURI ()).toString ();
        out.putNextEntry (new ZipEntry (path));
        FileInputStream fin = new FileInputStream (in);
        byte [] buffer = new byte [1024];
        int br;
        if (md == null || (fileNamesToSkipInCheckSumCalculation != null && fileNamesToSkipInCheckSumCalculation.contains (in.getName ()))) {
            while ((br = fin.read (buffer)) > 0) {
                out.write (buffer, 0, br);
            }
        }
        else {
            while ((br = fin.read (buffer)) > 0) {
                out.write (buffer, 0, br);
                md.update (buffer, 0, br);
            }
        }
        fin.close ();
        out.closeEntry ();
    }
}


private void addPaddingInternal (HTTPurl urlData, HashMap < String, String > headers, OutputStream out) throws Exception {
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    String errorString = null;
    if (item != null) {
        Calendar cal = Calendar.getInstance ();
        cal.setTime (item.getStart ());
        int startBuff = 0;
        int endBuff = 0;
        try {
            startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
            endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
        } catch (Exception e) {
            e.printStackTrace ();
        }
        if (item.getState () != ScheduleItem.RUNNING) {
            System.out.println ("Not RUNNING");
            cal.add (Calendar.MINUTE, (startBuff * - 1));
            item.setDuration (item.getDuration () + startBuff + endBuff);
            item.setStart (cal);
        }
        else {
            System.out.println ("RUNNING");
            item.setDuration (item.getDuration () + endBuff);
        }
        store.saveSchedule (null);
    }
    else {
        errorString = "Schedule not found";
    }
    XmlDoc xmlDoc = new XmlDoc ("schedule_action");
    if (errorString != null) {
        Element error = xmlDoc.createTextElement ("error", errorString);
        xmlDoc.getRoot ().appendChild (error);
    }
    else {
        Element message = xmlDoc.createTextElement ("message", "Schedule Padding Added");
        xmlDoc.getRoot ().appendChild (message);
    }
    out.write (xmlDoc.getDocBytes ());
}


-----Function Pair=227=-----==

public static void replaceTemplateVariables (Writer writer, Reader reader, Map < String, String > variables) throws IOException {
    StreamTokenizer stk = new StreamTokenizer (reader);
    stk.resetSyntax ();
    stk.wordChars (0, Integer.MAX_VALUE);
    stk.ordinaryChar ('$');
    stk.ordinaryChar ('{');
    stk.ordinaryChar ('}');
    stk.ordinaryChar ('\n');
    String variableName = null;
    StringBuffer tmpBuf = new StringBuffer ();
    ParserExpects parserExpects = ParserExpects.NORMAL;
    while (stk.nextToken () != StreamTokenizer.TT_EOF) {
        String stringToWrite = null;
        if (stk.ttype == StreamTokenizer.TT_WORD) {
            switch (parserExpects) {
                case VARIABLE :
                    parserExpects = ParserExpects.BRACKET_CLOSE;
                    variableName = stk.sval;
                    tmpBuf.append (variableName);
                    break;
                case NORMAL :
                    stringToWrite = stk.sval;
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + stk.sval;
                    tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '\n') {
            stringToWrite = new String (new char [] {(char) stk.ttype});
            if (parserExpects != ParserExpects.NORMAL) {
                parserExpects = ParserExpects.NORMAL;
                stringToWrite = tmpBuf.toString () + stringToWrite;
                tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '$') {
            if (parserExpects != ParserExpects.NORMAL) {
                stringToWrite = tmpBuf.toString ();
                tmpBuf.setLength (0);
            }
            tmpBuf.append ((char) stk.ttype);
            parserExpects = ParserExpects.BRACKET_OPEN;
        }
        else if (stk.ttype == '{') {
            switch (parserExpects) {
                case NORMAL :
                    stringToWrite = new String (new char [] {(char) stk.ttype});
                    break;
                case BRACKET_OPEN :
                    tmpBuf.append ((char) stk.ttype);
                    parserExpects = ParserExpects.VARIABLE;
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + (char) stk.ttype;
                    tmpBuf.setLength (0);
            }
        }
        else if (stk.ttype == '}') {
            switch (parserExpects) {
                case NORMAL :
                    stringToWrite = new String (new char [] {(char) stk.ttype});
                    break;
                case BRACKET_CLOSE :
                    parserExpects = ParserExpects.NORMAL;
                    tmpBuf.append ((char) stk.ttype);
                    if (variableName == null) throw new IllegalStateException ("variableName is null!!!");
                    stringToWrite = variables.get (variableName);
                    if (stringToWrite == null) {
                        logger.warn ("Variable " + tmpBuf.toString () + " occuring in template is unknown!");
                        stringToWrite = tmpBuf.toString ();
                    }
                    tmpBuf.setLength (0);
                    break;
                default :
                    parserExpects = ParserExpects.NORMAL;
                    stringToWrite = tmpBuf.toString () + (char) stk.ttype;
                    tmpBuf.setLength (0);
            }
        }
        if (stringToWrite != null) writer.write (stringToWrite);
    }
}


private byte [] enableTask (HTTPurl urlData, HashMap headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap tasks = store.getTaskList ();
    String enabled = urlData.getParameter ("enabled");
    String name = urlData.getParameter ("name");
    TaskCommand taskCommand = (TaskCommand) tasks.get (name);
    if (taskCommand != null) {
        if ("true".equals (enabled)) taskCommand.setEnabled (true);
        else taskCommand.setEnabled (false);
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


-----Function Pair=228=-----==

private void collectClassNames () {
    logger.info ("collecting class names for extended instrumentation determination");
    Project project = getProject ();
    Iterator filesets = filesets ();
    while (filesets.hasNext ()) {
        FileSet fs = (FileSet) filesets.next ();
        DirectoryScanner ds = fs.getDirectoryScanner (project);
        String [] includedFiles = ds.getIncludedFiles ();
        File d = fs.getDir (project);
        for (int i = 0; i < includedFiles.length; ++ i) {
            File file = new File (d, includedFiles [i]);
            try {
                collectClassNames (file);
            } catch (Exception e) {
                throw new BuildException (e);
            }
        }
    }
    logger.info (classNames.size () + " class(es) being checked");
}


private void MoveTo (NpsContext ctxt, Node node_src, TopicTree tree_dest, Node node_dest) throws NpsException {
    Topic topic = (Topic) node_src.GetValue ();
    if (node_dest != null) {
        Topic topic_parent = (Topic) node_dest.GetValue ();
        topic.SetSite (tree_dest.GetSite ());
        topic.SetParentId (topic_parent.GetId ());
        topic.SetCode (topic_parent.GetCode () + "." + topic.GetAlias ());
    }
    else {
        topic.SetSite (tree_dest.GetSite ());
        topic.SetParentId ("-1");
        topic.SetCode (topic.GetAlias ());
    }
    tree_dest.AddTopic (topic);
    tree_dest.Save (ctxt, topic, false);
    if (node_src.HasChilds ()) {
        Node copyNode = tree_dest.GetNodeByTopic (topic);
        Iterator childs = node_src.GetChilds ();
        while (childs.hasNext ()) {
            Node node_src_child = (Node) childs.next ();
            MoveTo (ctxt, node_src_child, tree_dest, copyNode);
        }
    }
}


-----Function Pair=229=-----==

private static void compressAllDirectory (ZipOutputStream out, List < File > files) {
    byte [] data = new byte [COMPRESS_OUTPUTSTREAM_BUFFER_SIZE];
    BufferedInputStream origin = null;
    File file = null;
    int counterFiles = 0, counterDirectories = 0;
    if (files.size () > 0) {
        for (int i = 0; i < files.size (); i ++) {
            try {
                file = files.get (i);
                if (file.isFile ()) {
                    addFileToJar (origin, out, data, file.getPath ());
                    counterFiles ++;
                }
                else if (file.isDirectory ()) {
                    List < File > newFiles = (List < File >) CollectionHelper.convertTo (file.listFiles ());
                    compressAllDirectory (out, newFiles);
                    counterDirectories ++;
                }
            } catch (FileNotFoundException e) {
                logger.error ("File '" + file.getPath () + "' couldn't be added to jar file because it doesn't exist.", e);
            } catch (IOException e) {
                logger.error ("File '" + file.getPath () + "' couldn't be added to jar file cause of an input/ouput error.", e);
            }
        }
        logger.debug ("File '" + file.getPath () + "' couldn't be added to jar file cause of an input/ouput error.");
    }
}


public static final boolean zipExtract (String zipfile, String name, String dest) {
    boolean f = false;
    try {
        InputStream in = new BufferedInputStream (new FileInputStream (zipfile));
        ZipInputStream zin = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zin.getNextEntry ()) != null) {
            if (e.getName ().equals (name)) {
                FileOutputStream out = new FileOutputStream (dest);
                byte b [] = new byte [TEMP_FILE_BUFFER_SIZE];
                int len = 0;
                while ((len = zin.read (b)) != - 1) out.write (b, 0, len);
                out.close ();
                f = true;
                break;
            }
        }
        zin.close ();
    } catch (FileNotFoundException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    }
    return (f);
}


-----Function Pair=230=-----==

static String byteArrayToHexString (byte in []) {
    byte ch = 0x00;
    int i = 0;
    if (in == null || in.length <= 0) {
        return null;
    }
    String pseudo [] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"};
    StringBuffer out = new StringBuffer (in.length * 2);
    while (i < in.length) {
        ch = (byte) (in [i] & 0xF0);
        ch = (byte) (ch>>> 4);
        ch = (byte) (ch & 0x0F);
        out.append (pseudo [(int) ch]);
        ch = (byte) (in [i] & 0x0F);
        out.append (pseudo [(int) ch]);
        i ++;
    }
    String rslt = new String (out);
    return rslt;
}


public Object getValueAt (int row, int col) {
    Vector < ZipEntry > entries = new Vector < ZipEntry > ();
    Enumeration e = resFile.entries ();
    while (e.hasMoreElements ()) {
        entries.add ((ZipEntry) e.nextElement ());
    }
    if (col == 0) {
        return entries.get (row);
    }
    else if (col == 3) {
        return entries.get (row).getComment ();
    }
    else if (col == 1) {
        NumberFormat nf = NumberFormat.getNumberInstance (getLocale ());
        return nf.format (entries.get (row).getSize ()) + " B";
    }
    else if (col == 2) {
        NumberFormat nf = NumberFormat.getNumberInstance (getLocale ());
        return nf.format (entries.get (row).getCompressedSize ()) + " B";
    }
    else if (col == 4) {
        DateFormat df = DateFormat.getDateInstance (DateFormat.MEDIUM, getLocale ());
        return df.format (entries.get (row).getTime ());
    }
    else return null;
}


-----Function Pair=231=-----==

public static void zip (File destFile, File [] files) throws IOException {
    BufferedInputStream origin = null;
    FileOutputStream dest = new FileOutputStream (destFile);
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    out.setMethod (ZipOutputStream.DEFLATED);
    byte [] data = new byte [BUFFER_SIZE];
    for (int i = 0; i < files.length; i ++) {
        if (log.isDebugEnabled ()) {
            log.debug ("Adding: " + files [i].getName ());
        }
        if (files [i].isDirectory ()) {
            if (log.isDebugEnabled ()) {
                log.debug ("Skipping directory: " + files [i]);
            }
            continue;
        }
        FileInputStream fi = new FileInputStream (files [i]);
        origin = new BufferedInputStream (fi, BUFFER_SIZE);
        ZipEntry entry = new ZipEntry (files [i].getName ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER_SIZE)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    out.flush ();
    out.close ();
}


public void marshal (final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {
    final Message message = exchange.getIn ();
    final File file = message.getBody (File.class);
    final String fileName = file.getName ();
    final InputStream is = exchange.getContext ().getTypeConverter ().convertTo (InputStream.class, graph);
    final ZipOutputStream zipOutput = new ZipOutputStream (stream);
    zipOutput.setLevel (compressionLevel);
    try {
        zipOutput.putNextEntry (new ZipEntry (fileName));
    } catch (IOException e) {
        throw new IllegalStateException ("Error while adding a new Zip File Entry (File name: '" + fileName + "').", e);
    }
    IOHelper.copy (is, zipOutput);
    zipOutput.close ();
}


-----Function Pair=232=-----==

private void addAtomicFilesToBackup (ZipOutputStream zipOut, String [] filenames) throws IOException {
    List matchedFiles = new ArrayList ();
    List unmatchedFiles = new ArrayList ();
    for (int i = 0; i < filenames.length; i ++) {
        String filename = filenames [i];
        if (containsIgnoreCase (atomicFilesInOldBackup, filename)) matchedFiles.add (filename);
        else unmatchedFiles.add (filename);
    }
    if (! matchedFiles.isEmpty () && ! unmatchedFiles.isEmpty ()) {
        for (Iterator i = unmatchedFiles.iterator (); i.hasNext ();) {
            String filename = (String) i.next ();
            File file = new File (srcDirectory, filename);
            backupFile (null, null, null, zipOut, file, filename);
        }
    }
}


private void implantSelf () throws IOException {
    InputStream manifest = getClass ().getClassLoader ().getResourceAsStream ("META-INF/manifest.mf");
    log ("my classloader is " + getClass ().getClassLoader ().getClass ().getName ());
    ClassLoader loader = getClass ().getClassLoader ();
    if (manifest == null || loader == null || (loader.getClass ().getName ().indexOf ("Applet") == - 1 && loader.getClass ().getName ().indexOf ("Plugin") == - 1)) return;
    BufferedReader br = new BufferedReader (new InputStreamReader (manifest));
    Vector entries = new Vector ();
    String s = null;
    while ((s = br.readLine ()) != null) if (s.startsWith ("Name: ")) entries.addElement (s.substring (6));
    String ext_dirs = System.getProperty ("java.ext.dirs");
    log ("java.ext.dirs = " + ext_dirs);
    ext_dirs = ext_dirs + File.pathSeparatorChar + System.getProperty ("user.home") + File.separatorChar + ".vexi";
    StringTokenizer st = new StringTokenizer (ext_dirs, File.pathSeparatorChar + "");
    while (st.hasMoreTokens ()) {
        String dir = st.nextToken ();
        new File (dir).mkdirs ();
        try {
            if (! st.hasMoreTokens ()) modifyPolicyFile ();
            implantInDirectory (dir, entries);
            return;
        } catch (IOException e) {
            log ("Failed to implant in " + dir + " due to " + e);
        }
    }
    log ("Failed to implant self!");
}


-----Function Pair=233=-----=1=

private void zipDir (File dir, String jarEntry, JarOutputStream jos) throws IOException {
    String [] dirList = dir.list ();
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (dir, dirList [i]);
        if (f.isDirectory ()) {
            zipDir (f, jarEntry + dirList [i] + File.separatorChar, jos);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        ZipEntry anEntry = new ZipEntry (jarEntry + dirList [i]);
        jos.putNextEntry (anEntry);
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            jos.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


-----Function Pair=234=-----==

public void jar (File z, File root, FileFilter filter) {
    if (root.exists ()) {
        try {
            if (! z.exists ()) z.createNewFile ();
            if (root.isDirectory ()) {
                JarOutputStream jar = new JarOutputStream (new FileOutputStream (z));
                File [] jarFiles = listFiles (root, false, filter);
                for (int i = 0; i < jarFiles.length; i ++) {
                    addJarEntry (jar, jarFiles [i], filter, null);
                }
                File [] dirs = listDirectories (root, false);
                for (int i = 0; i < dirs.length; i ++) {
                    addJarEntry (jar, dirs [i], filter, null);
                }
                jar.close ();
            }
        } catch (IOException ex) {
        }
    }
}


private void addFileToZip (File file, EntryConfigurationListener callback) throws IOException {
    String abs = file.getAbsolutePath ();
    abs = abs.substring (startFromLen + 1);
    ZipEntry entry = new ZipEntry (abs);
    if (callback != null) callback.configure (entry);
    output.putNextEntry (entry);
    try {
        FileInputStream fis = new FileInputStream (file);
        BufferedInputStream bis = new BufferedInputStream (fis, 2048);
        try {
            int readIn;
            while ((readIn = bis.read (buff)) > 0) output.write (buff, 0, readIn);
        } finally {
            bis.close ();
        }
    } finally {
        output.closeEntry ();
    }
}


-----Function Pair=235=-----==

private static void getWatcherOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT watcherOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("watcherOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


public static RegionScoreTextData merge (ArrayList < RegionScoreTextData > pdAL) {
    RegionScoreTextData [] pdArray = new RegionScoreTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionScoreTexts.length;
    RegionScoreText [] concatinate = new RegionScoreText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionScoreText [] slice = pdArray [i].sortedRegionScoreTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionScoreTextData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionScoreTextData (concatinate, sliceInfo);
}


-----Function Pair=236=-----==

public boolean renameSnapshot (IPath source, String separator) {
    File sourceFile = source.toFile ();
    if (sourceFile.exists ()) {
        IPath destFilePath = null;
        File destFile = null;
        Date date = new Date (sourceFile.lastModified ());
        SimpleDateFormat debugDateFormat = new SimpleDateFormat ("yyMMddHHmmss");
        String extension = source.getFileExtension ();
        if (extension != null) {
            destFilePath = source.removeFileExtension ();
            destFile = new File (destFilePath.toOSString () + separator + debugDateFormat.format (date) + "." + extension);
        }
        else {
            destFile = new File (source.toOSString () + separator + debugDateFormat.format (date));
        }
        if (XPLog.isDebugEnabled ()) {
            XPLog.printDebug (LogConstants.LOG_PREFIX_LOCALSNAPSHOT + "renaming old snapshot: source=" + source.toOSString () + ", dest=" + destFile.getAbsolutePath ());
        }
        return sourceFile.renameTo (destFile);
    }
    else {
        return false;
    }
}


public void marshal (final Exchange exchange, final Object graph, final OutputStream stream) throws Exception {
    final Message message = exchange.getIn ();
    final File file = message.getBody (File.class);
    final String fileName = file.getName ();
    final InputStream is = exchange.getContext ().getTypeConverter ().convertTo (InputStream.class, graph);
    final ZipOutputStream zipOutput = new ZipOutputStream (stream);
    zipOutput.setLevel (compressionLevel);
    try {
        zipOutput.putNextEntry (new ZipEntry (fileName));
    } catch (IOException e) {
        throw new IllegalStateException ("Error while adding a new Zip File Entry (File name: '" + fileName + "').", e);
    }
    IOHelper.copy (is, zipOutput);
    zipOutput.close ();
}


-----Function Pair=237=-----==

public static void saveProject (TProject project, File zipFile) throws ParserConfigurationException, IOException, TransformerException {
    DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance ();
    DocumentBuilder domBuilder = domFactory.newDocumentBuilder ();
    Document doc = domBuilder.newDocument ();
    doc.appendChild (project.XMLEncode (doc));
    TProjectHandler.cleanTempDirectory ();
    TProjectHandler.copyCurrentToTemp (TAttributeEncoder.getFilePaths (doc));
    File file = new File (TProjectHandler.getTempDirectory (), "project.xml");
    BufferedWriter bufferWriter = new BufferedWriter (new OutputStreamWriter (new FileOutputStream (file), "UTF-8"));
    TransformerFactory transformerFactory = TransformerFactory.newInstance ();
    Transformer transformer = transformerFactory.newTransformer ();
    DOMSource source = new DOMSource (doc);
    StreamResult result = new StreamResult (bufferWriter);
    transformer.transform (source, result);
    bufferWriter.close ();
    TProjectHandler.saveZip (zipFile);
    TProjectHandler.cleanTempDirectory ();
}


private static void zip (File directory, File base, ZipOutputStream zos) throws IOException {
    File [] files = directory.listFiles ();
    byte [] buffer = new byte [8192];
    int read = 0;
    for (int i = 0, n = files.length; i < n; i ++) {
        if (files [i].isDirectory ()) {
            zip (files [i], base, zos);
        }
        else {
            FileInputStream in = new FileInputStream (files [i]);
            String entryStr = files [i].getPath ().substring (base.getPath ().length () + 1);
            entryStr = entryStr.replaceAll ("\\\\", "/");
            ZipEntry entry = new ZipEntry (entryStr);
            zos.putNextEntry (entry);
            while (- 1 != (read = in.read (buffer))) {
                zos.write (buffer, 0, read);
            }
            in.close ();
        }
    }
}


-----Function Pair=238=-----==

private void zipFiles (List < File > files, HttpServletResponse response) {
    try {
        BufferedInputStream origin = null;
        ZipOutputStream out = new ZipOutputStream (response.getOutputStream ());
        byte data [] = new byte [BUFFER];
        for (int i = 0; i < files.size (); i ++) {
            FileInputStream fi = new FileInputStream (files.get (i));
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (files.get (i).getName ());
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (Exception e) {
        log.error (e);
    }
}


public static String scheduleToString (Schedule sch) {
    String [] names = new DateFormatSymbols ().getWeekdays ();
    DecimalFormat format = new DecimalFormat ("00");
    StringBuilder result = new StringBuilder ();
    int [] limits = sch.getScheduleLimits ();
    for (int i = 0; i < limits.length; ++ i) {
        int from = limits [i];
        Collection < ScheduleItem > scheduleItems = sch.getScheduleItemsFrom (from);
        result.append ("From ").append (from);
        if (i + 1 < limits.length) result.append (" to ").append (limits [i + 1] - 1).append (" turns:\n");
        else result.append (" turn to the end of game:\n");
        for (ScheduleItem item : scheduleItems) {
            String weekDay = names [item.getDay ()];
            weekDay = weekDay.substring (0, 1).toUpperCase () + weekDay.substring (1);
            result.append (weekDay).append (' ').append (format.format ((long) item.getHour ())).append (':').append (format.format ((long) item.getMinute ())).append ('\n');
        }
        result.append ('\n');
    }
    return result.toString ();
}


-----Function Pair=239=-----==

public void copyFiles (File inputDir, String outputDir, java.io.FileFilter filter, boolean recursive) throws IOException {
    if (inputDir.exists ()) {
        if (inputDir.isDirectory ()) {
            File [] files = getFiles (inputDir, new ArrayList (), filter, false);
            File dir = new File (outputDir);
            if (! dir.exists ()) dir.mkdir ();
            outputDir += System.getProperty ("file.separator") + inputDir.getName ();
            dir = new File (outputDir);
            if (! dir.exists ()) dir.mkdir ();
            for (int i = 0; i < files.length; i ++) copyFile (files [i], new File (dir, files [i].getName ()));
            if (recursive) {
                File [] dirs = listDirectories (inputDir, false);
                for (int i = 0; i < dirs.length; i ++) {
                    copyFiles (dirs [i], outputDir, filter, recursive);
                }
            }
        }
        else throw new IOException (inputDir + " is not a directory.");
    }
    else throw new IOException (inputDir + " does not exist.");
}


public void setLoadOnDemand () {
    if (loadOnDemand) return;
    loadOnDemand = true;
    if ((Main.stripping & Main.STRIP_UNREACH) == 0) {
        String fullNamePrefix = (fullName.length () > 0) ? fullName + "." : "";
        Enumeration enumeration = bundle.getClassPath ().listClassesAndPackages (getFullName ());
        while (enumeration.hasMoreElements ()) {
            String subclazz = ((String) enumeration.nextElement ()).intern ();
            if (loadedClasses.containsKey (subclazz)) continue;
            String subFull = (fullNamePrefix + subclazz).intern ();
            if (bundle.getClassPath ().isPackage (subFull)) {
                PackageIdentifier ident = new PackageIdentifier (bundle, this, subFull, subclazz);
                loadedClasses.put (subclazz, ident);
                swappedClasses = null;
                ident.setLoadOnDemand ();
            }
            else {
                ClassIdentifier ident = new ClassIdentifier (this, subFull, subclazz, bundle.getClassPath ().getClassInfo (subFull));
                if (GlobalOptions.verboseLevel > 1) GlobalOptions.err.println ("preloading Class " + subFull);
                loadedClasses.put (subclazz, ident);
                swappedClasses = null;
                bundle.addClassIdentifier (ident);
            }
        }
        loadOnDemand = false;
    }
}


-----Function Pair=240=-----==

public void write (ZipOutputStream out, DataOutputStream dos, boolean attemptToSaveAsShort) {
    boolean useShort = false;
    if (attemptToSaveAsShort) {
        int bp = sortedPositionScoreTexts [0].position;
        useShort = true;
        for (int i = 1; i < sortedPositionScoreTexts.length; i ++) {
            int currentStart = sortedPositionScoreTexts [i].position;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShort = false;
                break;
            }
            bp = currentStart;
        }
    }
    String fileType;
    if (useShort) fileType = USeqUtilities.SHORT + USeqUtilities.FLOAT;
    else fileType = USeqUtilities.INT + USeqUtilities.FLOAT;
    fileType = fileType + USeqUtilities.TEXT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = null;
    try {
        out.putNextEntry (new ZipEntry (sliceInfo.getSliceName ()));
        dos.writeUTF (header);
        dos.writeInt (sortedPositionScoreTexts [0].position);
        dos.writeFloat (sortedPositionScoreTexts [0].score);
        dos.writeUTF (sortedPositionScoreTexts [0].text);
        if (useShort) {
            int bp = sortedPositionScoreTexts [0].position;
            for (int i = 1; i < sortedPositionScoreTexts.length; i ++) {
                int currentStart = sortedPositionScoreTexts [i].position;
                int diff = currentStart - bp - 32768;
                dos.writeShort ((short) (diff));
                dos.writeFloat (sortedPositionScoreTexts [i].score);
                dos.writeUTF (sortedPositionScoreTexts [i].text);
                bp = currentStart;
            }
        }
        else {
            int bp = sortedPositionScoreTexts [0].position;
            for (int i = 1; i < sortedPositionScoreTexts.length; i ++) {
                int currentStart = sortedPositionScoreTexts [i].position;
                int diff = currentStart - bp;
                dos.writeInt (diff);
                dos.writeFloat (sortedPositionScoreTexts [i].score);
                dos.writeUTF (sortedPositionScoreTexts [i].text);
                bp = currentStart;
            }
        }
        out.closeEntry ();
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (out);
        USeqUtilities.safeClose (dos);
    }
}


public ErrorSet checkContents () {
    ErrorSet err = super.checkContents ();
    if (usite == null) {
        err.add (new UError (id, "No Usite selected."));
    }
    else {
        boolean foundUsite = false;
        Vector knownUsites = ResourceManager.getUsites ();
        for (int i = 0; i < knownUsites.size (); i ++) {
            if (knownUsites.elementAt (i).equals (usite)) {
                foundUsite = true;
                usite = (Usite) knownUsites.elementAt (i);
                break;
            }
        }
        if (! foundUsite) {
            usite = null;
            err.add (new UError (id, res.getString ("NO_USITE")));
        }
        else {
            boolean foundVsite = false;
            Vector knownVsites = ResourceManager.getVsites (usite);
            for (int i = 0; i < knownVsites.size (); i ++) {
                Vsite knownVsite = (Vsite) knownVsites.elementAt (i);
                if ((vsite != null) && vsite.equals (knownVsite)) {
                    foundVsite = true;
                    vsite = knownVsite;
                    break;
                }
            }
            if (! foundVsite) {
                vsite = null;
            }
            else if (! ResourceManager.isVsiteAvailable (vsite)) {
                err.add (new UError (id, ResourceManager.getVsiteErrorMessage (vsite)));
            }
            if (vsite == null || vsite.getAddress () == null || vsite.getName () == null) {
                err.add (new UError (id, res.getString ("NO_VSITE_ENTRY")));
            }
        }
    }
    if (getTasks ().isEmpty ()) {
        err.add (new UError (id, res.getString ("EMPTY_GROUP")));
    }
    if (err.containsError ()) {
        updateIcon (Color.red);
    }
    else {
        updateIcon (Color.green);
    }
    setErrors (err);
    selectJPAIcon ();
    return err;
}


-----Function Pair=241=-----==

public static void extractZip (File jarFile, File destDir) throws IOException {
    java.util.zip.ZipFile jar = new java.util.zip.ZipFile (jarFile);
    java.util.Enumeration en = jar.entries ();
    while (en.hasMoreElements ()) {
        java.util.zip.ZipEntry file = (java.util.zip.ZipEntry) en.nextElement ();
        java.io.File f = new java.io.File (destDir + java.io.File.separator + file.getName ());
        if (file.isDirectory ()) {
            f.mkdir ();
            continue;
        }
        f.getParentFile ().mkdirs ();
        java.io.InputStream is = jar.getInputStream (file);
        java.io.FileOutputStream fos = new java.io.FileOutputStream (f);
        while (is.available () > 0) {
            fos.write (is.read ());
        }
        fos.close ();
        is.close ();
    }
}


public void wirteCatalog (QuestionCatalog catalog, OutputStream out) throws IOException {
    ZipOutputStream zOut = new ZipOutputStream (out);
    try {
        ZipEntry entry = new ZipEntry ("info.xml");
        JAXBContext context = JAXBContext.newInstance (QuestionCatalog.class);
        Marshaller m = context.createMarshaller ();
        m.setProperty (m.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
        zOut.putNextEntry (entry);
        m.marshal (catalog, zOut);
        for (int i = 0; i < catalog.getQuestions ().size (); i ++) {
            this.putQuestion (catalog.getQuestions ().get (i), zOut);
        }
    } catch (JAXBException ex) {
        Logger.getLogger (CatalogWriter.class.getName ()).log (Level.SEVERE, null, ex);
        throw new IOException (ex);
    }
    zOut.close ();
}


-----Function Pair=242=-----==

public static void main (String [] args) throws Exception {
    if (args.length < 4 || args.length > 5) {
        displayUsageAndExit ();
    }
    File fromEAR = new File (args [FROMEAR]);
    if (! fromEAR.exists () || ! fromEAR.canRead () || ! fromEAR.isFile ()) {
        System.out.println ("Error reading EAR, make sure the file " + args [FROMEAR] + " is a file and readable for the user.");
        System.exit (- 1);
    }
    File toEAR = new File (args [TOEAR]);
    String moduleType = args [MODULETYPE].toLowerCase ();
    if (! moduleType.equals (MODULETYPE_WEB) && ! moduleType.equals (MODULETYPE_EJB)) {
        System.out.println ("Error, unsupported module type " + args [MODULETYPE] + ".");
        System.exit (- 1);
    }
    String moduleName = args [MODULENAME];
    String contextRoot = "";
    if (moduleType.equals (MODULETYPE_WEB)) {
        if (args.length != 5) {
            System.out.println ("Error, context root must be specified if web module is inserted .");
            System.exit (- 1);
        }
        else {
            contextRoot = args [CONTEXTROOT];
        }
    }
    insertModuleInEar (fromEAR, toEAR, moduleType, moduleName, contextRoot);
}


public static void removeEmptyHeadings (Node root) {
    NodeList hNodes = ((Element) root).getElementsByTagName ("text:h");
    for (int i = 0; i < hNodes.getLength (); i ++) {
        Node node = hNodes.item (i);
        if (node.getChildNodes ().getLength () > 0) {
            boolean empty = true;
            for (int j = 0; j < node.getChildNodes ().getLength (); j ++) {
                if (! node.getChildNodes ().item (j).getTextContent ().trim ().equals ("")) {
                    empty = false;
                }
            }
            if (empty) {
                node.getParentNode ().removeChild (node);
                i --;
            }
        }
        else {
            if (node.getTextContent ().trim ().equals ("")) {
                node.getParentNode ().removeChild (node);
                i --;
            }
        }
    }
}


-----Function Pair=243=-----==

private void saveTo (File xmlFile, Object obj) {
    XStream xs = new XStream ();
    OutputStream os;
    try {
        os = new FileOutputStream (xmlFile);
        if (xmlFile.getName ().endsWith (".zip")) {
            ZipOutputStream zip = new ZipOutputStream (os);
            zip.putNextEntry (new ZipEntry (zipEntryName));
            os = zip;
        }
        else if (xmlFile.getName ().endsWith (".gz")) {
            GZIPOutputStream zip = new GZIPOutputStream (os);
            os = zip;
        }
        xs.toXML (obj, os);
        os.close ();
    } catch (StreamException e) {
        GLog.warn (L.tr ("XML_Write_Exception:"), e);
    } catch (MalformedURLException e) {
        GLog.warn (L.tr ("Malformed_URL:"), e);
    } catch (FileNotFoundException ex) {
        GLog.warn (L.tr ("Can't_find_file!"), ex);
    } catch (IOException e) {
        GLog.warn (L.tr ("Can't_gzip_the_file:_IOException:"), e);
    }
    GLog.log (L.tr ("Save_properties_to:_") + xmlFile.getAbsolutePath ());
    changed = false;
}


protected static List < File > getFiles (File dir, FilenameFilter filter, Date date) {
    List < File > newerFiles = new ArrayList < File > ();
    if (! dir.isDirectory ()) {
        throw new RuntimeException (dir + " is not a directory.  Bad, program!  BAD!!");
    }
    File [] children = dir.listFiles (filter);
    for (int i = 0; i < children.length; i ++) {
        if (children [i].isDirectory ()) {
            newerFiles.addAll (getFiles (children [i], filter, date));
        }
        else if (date.before (new Date (children [i].lastModified ())) && ! children [i].getName ().endsWith (".lck")) {
            newerFiles.add (children [i]);
        }
    }
    return newerFiles;
}


-----Function Pair=244=-----==

public static void main (String [] args) {
    System.out.println (MimeType.getMimeType ("data.xls"));
    System.out.println (MimeType.getMimeType ("data.cvs"));
    System.out.println (MimeType.getMimeType ("data.txt"));
    System.out.println (MimeType.getMimeType ("data.log"));
    System.out.println (MimeType.getMimeType ("data.html"));
    System.out.println (MimeType.getMimeType ("data.htm"));
    System.out.println (MimeType.getMimeType ("data.png"));
    System.out.println (MimeType.getMimeType ("data.gif"));
    System.out.println (MimeType.getMimeType ("data.jpg"));
    System.out.println (MimeType.getMimeType ("data.xml"));
    System.out.println (MimeType.getMimeType ("data.rtf"));
    System.exit (0);
    org.compiere.Adempiere.startupEnvironment (true);
    MAttachment att = new MAttachment (Env.getCtx (), 100, 0, null);
    att.addEntry (new File ("C:\\Adempiere\\Dev.properties"));
    att.addEntry (new File ("C:\\Adempiere\\index.html"));
    att.save ();
    System.out.println (att);
    att.dumpEntryNames ();
    int AD_Attachment_ID = att.getAD_Attachment_ID ();
    System.out.println ("===========================================");
    att = new MAttachment (Env.getCtx (), AD_Attachment_ID, null);
    System.out.println (att);
    att.dumpEntryNames ();
    System.out.println ("===========================================");
    MAttachmentEntry [] entries = att.getEntries ();
    for (int i = 0; i < entries.length; i ++) {
        MAttachmentEntry entry = entries [i];
        entry.dump ();
    }
    System.out.println ("===========================================");
    att.delete (true);
}


private Message createEmail (final File file) {
    try {
        final Properties props = new Properties ();
        props.put ("mail.smtp.host", config.getSmtpHost ());
        props.put ("mail.smtp.port", Integer.toString (config.getSmtpPort ()));
        final Session session = Session.getDefaultInstance (props, new Authenticator () {
            protected PasswordAuthentication getPasswordAuthentication () {
                return new PasswordAuthentication (config.getSmtpUserName (), config.getSmtpPassword ());
            }
        }
        );
        final Message message = new MimeMessage (session);
        message.setFrom (new InternetAddress (config.getFromAddress (), config.getFromName ()));
        message.setRecipient (Message.RecipientType.TO, new InternetAddress (config.getToAddress (), config.getToName ()));
        message.setSubject (config.getSubject ());
        message.setSentDate (new Date ());
        final MimeMultipart multipart = new MimeMultipart ();
        message.setContent (multipart);
        final BodyPart attachment = new MimeBodyPart ();
        attachment.setFileName ("unknown-devices.zip");
        final DataSource ds = new URLDataSource (file.toURL ());
        attachment.setDataHandler (new DataHandler (ds));
        attachment.setHeader ("Content-ID", "");
        multipart.addBodyPart (attachment);
        return message;
    } catch (Exception e) {
        LOGGER.warn ("unable-to-create-email", e);
        return null;
    }
}


-----Function Pair=245=-----==

private XmlData addDescriptiveMDInternal (String type, String md, Namespace ns) throws MetsException {
    XmlData xmlData = new XmlData ();
    if (ns != null) xmlData.setSchema (ns.getPrefix (), ns.getURI ());
    addToXmlData (xmlData, md, ns);
    DmdSec dmdSec = new DmdSec ();
    String dmdID = gensym ("dmd");
    dmdSec.setID (dmdID);
    dmdIDs.add (dmdID);
    dmdSec.setGROUPID (dmdGroupID);
    MdWrap mdWrap = new MdWrap ();
    setMdType (mdWrap, type);
    mdWrap.getContent ().add (xmlData);
    dmdSec.getContent ().add (mdWrap);
    manifest.getContent ().add (dmdSec);
    return xmlData;
}


private void CreateDsTable (NpsContext ctxt, Topic t) throws NpsException {
    if (t == null) return;
    String tablename = t.GetTable ();
    if (tablename == null || tablename.length () == 0) return;
    String dstable_name = tablename + "_prop";
    dstable_name = dstable_name.toUpperCase ();
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        String sql = "select count(*) table_count from all_tables Where table_name=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, dstable_name);
        rs = pstmt.executeQuery ();
        rs.next ();
        if (rs.getInt ("table_count") > 0) {
            try {
                rs.close ();
            } catch (Exception e) {
            }
            try {
                pstmt.close ();
            } catch (Exception e) {
            }
            sql = "select id,title,siteid,topic,state,createdate,publishdate from " + dstable_name + " where rownum<2";
            try {
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                rs = pstmt.executeQuery ();
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                stmt = ctxt.GetConnection ().createStatement ();
                sql = "Alter Table " + dstable_name + " Modify siteid default('" + t.GetSiteId () + "')";
                stmt.executeUpdate (sql);
                sql = "Alter Table " + dstable_name + " Modify topic default('" + t.GetId () + "')";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,default:" + treename + "'";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,default:" + t.GetName () + "'";
                stmt.executeUpdate (sql);
                try {
                    stmt.close ();
                } catch (Exception e1) {
                }
                return;
            } catch (Exception e) {
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                sql = "drop table " + dstable_name;
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                pstmt.executeUpdate (sql);
            }
        }
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        stmt = ctxt.GetConnection ().createStatement ();
        sql = "CREATE TABLE " + dstable_name + " (ID VARCHAR2(50) NOT NULL," + "TITLE VARCHAR2(1000) NOT NULL," + "SITEID VARCHAR2(10) DEFAULT '" + t.GetSiteId () + "' NOT NULL," + "TOPIC VARCHAR2(10) DEFAULT '" + t.GetId () + "' NOT NULL," + "STATE NUMBER," + "CREATEDATE DATE DEFAULT SYSDATE NOT NULL," + "PUBLISHDATE DATE," + "CONSTRAINT PK_" + dstable_name + " PRIMARY KEY (ID,TOPIC)" + ")";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".ID IS 'id'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TITLE IS 'title'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,site name is:" + treename + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,topic name is:" + t.GetName () + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".STATE IS 'status'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".CREATEDATE IS 'create date'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".PUBLISHDATE IS 'publish date'";
        stmt.executeUpdate (sql);
        sql = "create index idx_" + dstable_name + "_topstate on " + dstable_name + "(siteid,topic,state)";
        stmt.executeUpdate (sql);
        try {
            stmt.close ();
        } catch (Exception e) {
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        if (stmt != null) try {
            stmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=246=-----==

public void chargeConfigurations () {
    jcbConfig.removeActionListener (this);
    jcbConfig.removeAllItems ();
    File repertoireSysteme = new File (ConfigNat.getSystemConfigFilterFolder ());
    File repertoireUser = new File (ConfigNat.getUserConfigFilterFolder ());
    ArrayList < File > both = new ArrayList < File > ();
    try {
        Collections.addAll (both, repertoireSysteme.listFiles ());
    } catch (NullPointerException npe) {
        npe.printStackTrace ();
    }
    try {
        Collections.addAll (both, repertoireUser.listFiles ());
    } catch (NullPointerException npe) {
        npe.printStackTrace ();
    }
    File [] listConfs = both.toArray (new File [] {});
    ArrayList < ConfigurationsListItem > lesConfs = new ArrayList < ConfigurationsListItem > ();
    ConfigurationsListItem selectedConfig = null;
    for (int i = 0; i < listConfs.length; i ++) {
        try {
            ConfigurationsListItem cli = new ConfigurationsListItem (listConfs [i].getCanonicalPath (), gestErreur);
            if (cli.getIsValid ()) {
                lesConfs.add (cli);
                if (cli.getFilename ().equals (ConfigNat.getCurrentConfig ().getFichierConf ())) {
                    selectedConfig = cli;
                }
            }
        } catch (IOException ieo) {
            ieo.printStackTrace ();
        }
    }
    Collections.sort (lesConfs);
    for (ConfigurationsListItem c : lesConfs) {
        jcbConfig.addItem (c);
    }
    jcbConfig.addActionListener (this);
    if (selectedConfig != null) {
        jcbConfig.setSelectedItem (selectedConfig);
    }
}


private void lazyLoad (byte [] bytes) {
    if (passphrase == null) {
        throw new RuntimeException ("Passphrase required.");
    }
    byte [] decryptedBytes = null;
    try {
        decryptedBytes = SecurityUtil.decryptInMemory (passphrase, bytes);
    } catch (Exception ex) {
        throw new RuntimeException ("Incorrect passphrase for user zip file.", ex);
    }
    ByteArrayInputStream fis = null;
    BufferedInputStream bis = null;
    ZipInputStream zis = null;
    try {
        fis = new ByteArrayInputStream (decryptedBytes);
        bis = new BufferedInputStream (fis);
        zis = new ZipInputStream (bis);
        for (ZipEntry ze = zis.getNextEntry (); ze != null; ze = zis.getNextEntry ()) {
            if (ze.getName ().equals (UserZipFile.PUBLIC_CERTIFICATE_NAME)) {
                byte [] certBytes = IOUtil.getBytes (zis);
                X509Certificate cert = SecurityUtil.getCertificate (certBytes);
                setCertificate (cert);
                continue;
            }
            if (ze.getName ().equals (UserZipFile.PRIVATE_KEY_NAME)) {
                byte [] keyBytes = IOUtil.getBytes (zis);
                PrivateKey key = SecurityUtil.getPrivateKey (keyBytes);
                setPrivateKey (key);
                continue;
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    } finally {
        IOUtil.safeClose (zis);
        IOUtil.safeClose (bis);
        IOUtil.safeClose (fis);
    }
}


-----Function Pair=247=-----==

public static boolean string2FileAppend (String src, String fn) {
    BufferedWriter out = null;
    if ((src == null) || (fn == null)) return false;
    try {
        out = new BufferedWriter (new FileWriter (fn, true));
        out.write (src);
        out.flush ();
        out.close ();
    } catch (IOException e) {
        log.error ("error in string2FileAppend  " + fn + ":" + e.toString ());
        if (out != null) {
            try {
                out.close ();
            } catch (IOException ie) {
            }
            out = null;
            return false;
        }
    }
    out = null;
    return true;
}


static void buildLauncher () {
    try {
        ZipOutputStream zout = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream ("open-ig-launcher.jar"), 1024 * 1024));
        try {
            zout.setLevel (9);
            processDirectory (".\\bin\\", ".\\bin", zout, new FilenameFilter () {
                @Override
                public boolean accept (File dir, String name) {
                    String d = dir.toString ().replace ('\\', '/');
                    return d.endsWith ("hu/openig/launcher") || d.endsWith ("hu/openig/utils");
                }
            }
            );
            addFile ("META-INF/MANIFEST.MF", "META-INF/MANIFEST.MF.launcher", zout);
        } finally {
            zout.close ();
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}


-----Function Pair=248=-----==

public static void savePresetPackage (PresetPackage pkg, File pkgFile, ProgressCallback prog) throws PackageGenerationException {
    try {
        if (! (pkg instanceof Impl_PresetPackage)) throw new PackageGenerationException ("invalid preset package object");
        ZipOutputStream os = null;
        ObjectOutputStream oos = null;
        try {
            os = new ZipOutputStream (new FileOutputStream (pkgFile));
            os.setMethod (ZipOutputStream.DEFLATED);
            os.setLevel (Deflater.BEST_SPEED);
            os.putNextEntry (new ZipEntry (PresetPackage.PRESET_PKG_CONTENT_ENTRY));
            oos = new ObjectOutputStream (os);
            oos.writeObject (pkg.getHeader ());
            try {
                makeIsolatedPresetsSerializable ((Impl_PresetPackage) pkg);
            } catch (PresetException e) {
                throw new PackageGenerationException ("General packaging error");
            }
            oos.writeObject (pkg);
            if (pkg.getSamplePackage () != null) {
                File smplDir = ZUtilities.replaceExtension (pkgFile, SamplePackage.SAMPLE_DIR_EXT);
                try {
                    os.putNextEntry (new ZipEntry (SamplePackage.SAMPLE_PKG_CONTENT_ENTRY));
                } catch (IOException e) {
                    throw new PackageGenerationException (e.getMessage ());
                }
                writeSamplePackage (pkg.getSamplePackage (), oos, smplDir, prog);
            }
            oos.close ();
        } catch (IOException e) {
            pkgFile.delete ();
            throw new PackageGenerationException (e.getMessage ());
        }
    } finally {
        prog.updateProgress (1);
    }
}


private void initialize () {
    this.setSize (560, 346);
    this.setResizable (false);
    this.setTitle ("Generate Quiz");
    this.setModal (true);
    this.setContentPane (getJContentPane ());
    this.setDefaultCloseOperation (WindowConstants.DISPOSE_ON_CLOSE);
    Toolkit toolkit = Toolkit.getDefaultToolkit ();
    Dimension screenSize = toolkit.getScreenSize ();
    int x = (screenSize.width - this.getWidth ()) / 2;
    int y = (screenSize.height - this.getHeight ()) / 2;
    this.setLocation (x, y);
    if (owner.getClass ().getSuperclass ().getSimpleName ().equals ("JFrame")) {
        String userDir = System.getProperty ("user.dir");
        System.out.println (userDir);
    }
}


-----Function Pair=249=-----==

public void configureSave (ActionFormEvent event) throws PortletException {
    String selectedLanguage = event.getActionRequest ().getParameter ("language");
    Compiler c = compilers.get (selectedLanguage);
    if (c == null) {
        c = new Compiler ();
    }
    log.debug ("save compiler:" + selectedLanguage);
    c.setName (event.getActionRequest ().getParameter ("langName"));
    c.setCompiler (event.getActionRequest ().getParameter ("runable"));
    c.setExtensions (event.getActionRequest ().getParameter ("extensions"));
    c.setOutputFilename (event.getActionRequest ().getParameter ("output_filename"));
    ArrayList < CompilerOption > cos = c.getOptions ();
    for (int i = 0; i < cos.size (); i ++) {
        CompilerOption co = cos.get (i);
        if ("checked".equals ((String) event.getActionRequest ().getParameter ("optionEnableByDefault_" + String.valueOf (i)))) {
            co.setEnable_by_default (true);
        }
        else {
            co.setEnable_by_default (false);
        }
        if ("checked".equals (event.getActionRequest ().getParameter ("optionEnableMultiply_" + String.valueOf (i)))) {
            co.setMultiple (true);
        }
        else {
            co.setMultiple (false);
        }
        co.setName (event.getActionRequest ().getParameter ("optionName_" + String.valueOf (i)));
        co.setParam (event.getActionRequest ().getParameter ("optionParameter_" + String.valueOf (i)));
        co.setType (event.getActionRequest ().getParameter ("optionType_" + String.valueOf (i)));
        co.setTypeParam (event.getActionRequest ().getParameter ("optionTypeParameter_" + String.valueOf (i)));
    }
    c.setOptions (cos);
    if (! c.getName ().equals (selectedLanguage)) {
        compilers.remove (selectedLanguage);
        compilers.put (c.getName (), c);
    }
    event.getActionResponse ().setRenderParameter ("language", c.getName ());
    compilerService.saveCompiler (c);
    MyFile.populateMimeTypes ();
    for (Compiler cc : compilers.values ()) {
        String [] exts = cc.getExtensions ().split (";");
        String mime = "text/" + cc.getName () + " ";
        for (int i = 0; i < exts.length; i ++) {
            if (exts [i].length () > 1) {
                mime += " " + exts [i].substring (1);
            }
        }
        MyFile.mt.addMimeTypes (mime);
        log.debug ("add mime:" + mime);
    }
}


public static List < String > getWSDLTypes (Document document) {
    List < String > elements = new ArrayList < String > ();
    NodeList childNodes = document.getDocumentElement ().getChildNodes ();
    for (int i = 0; i < childNodes.getLength (); i ++) {
        Node node = childNodes.item (i);
        if (node.getLocalName () != null && node.getLocalName ().equals ("types")) {
            Node schema = node.getFirstChild ().getNextSibling ();
            if (schema != null && schema.hasChildNodes ()) {
                NodeList elementList = schema.getChildNodes ();
                for (int j = 0; j < elementList.getLength (); j ++) {
                    Node element = elementList.item (j);
                    if (element.getLocalName () != null && element.getLocalName ().equals ("element")) {
                        elements.add (((Element) element).getAttribute ("name"));
                    }
                }
            }
            break;
        }
    }
    return elements;
}


-----Function Pair=250=-----==

private void unZip (File fDes, String nameEntry) throws Exception {
    BufferedOutputStream dest = null;
    BufferedInputStream is = null;
    try {
        ZipEntry entry;
        ZipFile zipfile = new ZipFile (fzipIn);
        Enumeration e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            if (entry.getName ().equals (nameEntry)) {
                is = new BufferedInputStream (zipfile.getInputStream (entry));
                int count;
                byte data [] = new byte [BUFFER];
                FileOutputStream fos = new FileOutputStream (fDes);
                dest = new BufferedOutputStream (fos, BUFFER);
                while ((count = is.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
                is.close ();
                return;
            }
        }
    } catch (Exception e) {
        throw e;
    } finally {
        if (dest != null) {
            dest.close ();
        }
        if (is != null) {
            is.close ();
        }
    }
}


public static List < File > unzip (File zippedFile, File destinationDir) throws IOException {
    int buffer = 2048;
    List < File > unzippedFiles = new ArrayList < File > ();
    BufferedOutputStream dest;
    BufferedInputStream is;
    ZipEntry entry;
    ZipFile zipfile = new ZipFile (zippedFile);
    Enumeration e = zipfile.entries ();
    while (e.hasMoreElements ()) {
        entry = (ZipEntry) e.nextElement ();
        is = new BufferedInputStream (zipfile.getInputStream (entry));
        int count;
        byte data [] = new byte [buffer];
        File destFile;
        if (destinationDir != null) {
            destFile = new File (destinationDir, entry.getName ());
        }
        else {
            destFile = new File (entry.getName ());
        }
        FileOutputStream fos = new FileOutputStream (destFile);
        dest = new BufferedOutputStream (fos, buffer);
        while ((count = is.read (data, 0, buffer)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
        is.close ();
        unzippedFiles.add (destFile);
    }
    return unzippedFiles;
}


-----Function Pair=251=-----==

private static void zipFolder (File folder, ZipOutputStream zipOutputStream, String relativePath) throws IOException {
    File [] children = folder.listFiles ();
    for (int i = 0; i < children.length; i ++) {
        File child = children [i];
        if (child.isFile ()) {
            String zipEntryName = children [i].getCanonicalPath ().replace (relativePath + File.separator, "");
            ZipEntry entry = new ZipEntry (zipEntryName);
            zipOutputStream.putNextEntry (entry);
            InputStream inputStream = new FileInputStream (child);
            IOUtils.copy (inputStream, zipOutputStream);
            inputStream.close ();
        }
        else {
            ZipUtil.zipFolder (child, zipOutputStream, relativePath);
        }
    }
}


public static void zipDir (String dirToZip, String zipName) throws Exception {
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (zipName));
    List < String > l = new ArrayList < String > ();
    listOfFiles (new File (dirToZip), l);
    byte [] readBuffer = null;
    RandomAccessFile raf = null;
    for (Iterator iterator = l.iterator (); iterator.hasNext ();) {
        String filename = (String) iterator.next ();
        raf = new RandomAccessFile (filename, "r");
        readBuffer = new byte [(int) raf.length ()];
        raf.read (readBuffer);
        ZipEntry anEntry = new ZipEntry (filename.substring (dirToZip.length ()));
        zos.putNextEntry (anEntry);
        zos.write (readBuffer, 0, (int) raf.length ());
        raf.close ();
    }
    zos.close ();
}


-----Function Pair=252=-----==

public static final Collection < File > unZip (final ZipInputStream in, final File outDir) {
    final Collection < File > result = new ArrayList < File > (4);
    try {
        ZipEntry entry;
        BufferedOutputStream out = null;
        final byte data [] = new byte [10240];
        while (true) {
            out = null;
            try {
                entry = in.getNextEntry ();
                if (null == entry) break;
                int count;
                final File outFile = new File (outDir, entry.getName ());
                outFile.getParentFile ().mkdirs ();
                out = new BufferedOutputStream (new FileOutputStream (outFile));
                while ((count = in.read (data)) != - 1) out.write (data, 0, count);
                out.flush ();
                result.add (outFile);
            } catch (final Exception ioex) {
                ioex.printStackTrace ();
            } finally {
                closeIO (out);
            }
        }
    } catch (final Exception e) {
        e.printStackTrace ();
    } finally {
        closeIO (in);
    }
    return result;
}


public static ArrayList < File > fetchAllFilesRecursively (File directory) {
    ArrayList < File > files = new ArrayList < File > ();
    File [] list = directory.listFiles ();
    if (list != null) {
        for (int i = 0; i < list.length; i ++) {
            if (list [i].isDirectory ()) {
                ArrayList < File > al = fetchAllFilesRecursively (list [i]);
                int size = al.size ();
                for (int x = 0; x < size; x ++) {
                    File test = al.get (x);
                    if (test.getName ().startsWith (".") == false) files.add (test);
                }
            }
            else if (list [i].getName ().startsWith (".") == false) files.add (list [i]);
        }
    }
    return files;
}


-----Function Pair=253=-----==

public List < StatusMessage > sendToEmail (List < FileSystemItem > files, String to, String cc, String bcc, String subject, String body) throws IOException {
    List < StatusMessage > sms = new ArrayList < StatusMessage > ();
    String [] tos = splitAddress ("emailTo", sms, to);
    if (cc != null) {
        splitAddress ("emailCc", sms, cc);
    }
    if (bcc != null) {
        splitAddress ("emailBcc", sms, bcc);
    }
    if (! sms.isEmpty ()) {
        return sms;
    }
    List < ? extends Attachment > attachments;
    if (files.size () > 1) {
        attachments = createZipAttachment (files, containsFolder (files));
    }
    else {
        attachments = createFileAttachments (files);
    }
    try {
        mailServices.sendFiles (currentUser, tos, cc, bcc, subject, body, attachments.toArray (new Attachment [0]));
    } finally {
        for (Attachment a : attachments) {
            try {
                a.close ();
            } catch (IOException e) {
                log.warn ("Failed to close attachment " + a, e);
            }
        }
    }
    return Collections.emptyList ();
}


private void explodeGeometryCollection (FeatureSchema fs, ArrayList pointFeatures, ArrayList lineFeatures, ArrayList polyFeatures, GeometryCollection geometryCollection, Feature feature) {
    for (int i = 0; i < geometryCollection.getNumGeometries (); i ++) {
        Geometry geometry = geometryCollection.getGeometryN (i);
        if (geometry instanceof GeometryCollection) {
            explodeGeometryCollection (fs, pointFeatures, lineFeatures, polyFeatures, (GeometryCollection) geometry, feature);
        }
        else {
            Feature newFeature = feature.clone (true);
            newFeature.setGeometry (geometry);
            BitSet featureBit = new BitSet ();
            featureBit = GeoUtils.setBit (featureBit, geometry);
            if (featureBit.get (GeoUtils.pointBit)) pointFeatures.add (newFeature);
            if (featureBit.get (GeoUtils.lineBit)) lineFeatures.add (newFeature);
            if (featureBit.get (GeoUtils.polyBit)) polyFeatures.add (newFeature);
        }
    }
}


-----Function Pair=254=-----==

protected void writeManifest (OutputStream out) throws IOException {
    XmlSerializer xml = XMLUtils.getXmlSerializer (true);
    xml.setOutput (out, "UTF-8");
    xml.startDocument ("UTF-8", null);
    xml.startTag (null, "pdashReportArchive");
    xml.attribute (null, "version", "1.0");
    for (Map.Entry < String, String > e : contentTypeMap.entrySet ()) {
        xml.startTag (null, "file");
        xml.attribute (null, "name", e.getKey ());
        xml.attribute (null, "contentType", e.getValue ());
        if (defaultFile.equals (e.getKey ())) xml.attribute (null, "isDefault", "true");
        xml.endTag (null, "file");
    }
    xml.endTag (null, "pdashReportArchive");
    xml.endDocument ();
}


public void SetTable (String t) {
    if (t.length () == 0) t = null;
    if (table == null && t != null) {
        String key = t.toUpperCase ();
        EventSubscriber.GetSubscriber ().AddListener ((Ready2PublishEventListener) this, key);
        EventSubscriber.GetSubscriber ().AddListener ((InsertEventListener) this, key);
        EventSubscriber.GetSubscriber ().AddListener ((UpdateEventListener) this, key);
        EventSubscriber.GetSubscriber ().AddListener ((DeleteEventListener) this, key);
        EventSubscriber.GetSubscriber ().AddListener ((PublishEventListener) this, key);
        EventSubscriber.GetSubscriber ().AddListener ((CancelEventListener) this, key);
    }
    else if (table != null && t == null) {
        EventSubscriber.GetSubscriber ().RemoveListener (Ready2PublishEventListener.class, this);
        EventSubscriber.GetSubscriber ().RemoveListener (InsertEventListener.class, this);
        EventSubscriber.GetSubscriber ().RemoveListener (UpdateEventListener.class, this);
        EventSubscriber.GetSubscriber ().RemoveListener (DeleteEventListener.class, this);
        EventSubscriber.GetSubscriber ().RemoveListener (PublishEventListener.class, this);
        EventSubscriber.GetSubscriber ().RemoveListener (CancelEventListener.class, this);
    }
    table = t;
}


-----Function Pair=255=-----==

public void upZipFile (String zipFile, boolean decrypt, String specifiedDir) throws Exception {
    ZipFile zfile = new ZipFile (zipFile);
    Enumeration zList = zfile.entries ();
    ZipEntry ze = null;
    byte [] buf = new byte [BUFFER];
    byte [] encrypByte = new byte [encrypLength];
    int readLen = 0;
    logger.error ("解压文件：" + zipFile);
    long [] sDCardRealease = LoadResources.readSDCard ();
    long [] extSDCardRealease = LoadResources.readExtSDCard ();
    while (zList.hasMoreElements ()) {
        ze = (ZipEntry) zList.nextElement ();
        if (stopZipFile) {
            break;
        }
        if (specifiedDir != null && ! "..".equals (specifiedDir) && ze.getName ().indexOf (specifiedDir) < 0) continue;
        if (ze.isDirectory ()) {
            File f = new File (sdPath + ze.getName ());
            f.mkdir ();
            continue;
        }
        File tempFile = null;
        RandomAccessFile os = null;
        try {
            if (sDCardRealease [1] >= ze.getSize ()) {
                tempFile = getRealFileName (sdPath, ze.getName (), specifiedDir);
                os = new RandomAccessFile (tempFile.getAbsoluteFile (), "rw");
                sDCardRealease [1] = sDCardRealease [1] - ze.getSize ();
            }
            else if (extSDCardRealease [1] >= ze.getSize ()) {
                tempFile = getRealFileName (extSdPath, ze.getName (), specifiedDir);
                os = new RandomAccessFile (tempFile.getAbsoluteFile (), "rw");
                extSDCardRealease [1] = extSDCardRealease [1] - ze.getSize ();
            }
            else {
                throw new IOException ("空间不足");
            }
            logger.error ("解压文件：" + ze.getName ());
            InputStream is = new BufferedInputStream (zfile.getInputStream (ze));
            readLen = is.read (buf, 0, BUFFER);
            if (decrypt) {
                System.arraycopy (buf, 0, encrypByte, 0, encrypLength);
                byte [] temp = CryptionControl.getInstance ().decryptECB (encrypByte, rootKey);
                System.arraycopy (temp, 0, buf, 0, encrypLength);
            }
            while (readLen != - 1) {
                os.write (buf, 0, readLen);
                readLen = is.read (buf, 0, BUFFER);
            }
            is.close ();
            os.close ();
        } catch (IOException e) {
            throw new IOException ("解压失败");
        }
    }
    zfile.close ();
}


public void zipDir (String dir2zip, ZipOutputStream zos, String rootPath) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        zos.putNextEntry (new ZipEntry (rootPath + "/"));
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                String temp = rootPath + "\\" + f.getName ();
                zipDir (filePath, zos, temp);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            ZipEntry anEntry = new ZipEntry (rootPath + "\\" + f.getName ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
    }
}


-----Function Pair=256=-----==

protected ModelAndView handleRequestInternal (HttpServletRequest request, HttpServletResponse response) throws Exception {
    NodeVisit visit = VisitUtils.getVisit (request);
    if (visit == null) {
        logger.debug (AdminConstants.UNAUTHED + " transaction " + AdminConstants.ACCESS_REQUEST);
        return VisitUtils.getUnauthedView (request);
    }
    String transactionId = ServletRequestUtils.getRequiredStringParameter (request, "transactionId");
    NodeTransaction trans = getTransactionService ().get (transactionId, visit);
    NodeTransaction downloadTrans = null;
    File zipFile = null;
    if (trans != null) {
        PartnerIdentity oldPartner = new PartnerIdentity ();
        oldPartner.setUrl (trans.getNetworkEndpointUrl ());
        oldPartner.setVersion (trans.getNetworkEndpointVersion ());
        NodeClientService ncl = getNodeClientFactory ().makeAndConfigure (oldPartner);
        trans.setDocuments (new ArrayList < Document > ());
        downloadTrans = ncl.download (trans);
        if (downloadTrans.getDocuments () != null) {
            zipFile = File.createTempFile ("transdownload", ".zip");
            if (zipFile.exists ()) {
                zipFile.delete ();
            }
            ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipFile));
            for (int i = 0; i < downloadTrans.getDocuments ().size (); i ++) {
                Document currentDoc = downloadTrans.getDocuments ().get (i);
                writeFileToZip (zipOut, currentDoc.getContent (), currentDoc.getDocumentName ());
            }
            zipOut.flush ();
            zipOut.close ();
        }
    }
    if (zipFile != null) {
        response.setHeader ("Cache-Control", "must-revalidate");
        response.setContentType ("application/zip");
        response.setHeader ("Content-Disposition", "attachment; filename=\"" + trans.getNetworkId () + ".zip\"");
        FileCopyUtils.copy (new FileInputStream (zipFile), response.getOutputStream ());
        return null;
    }
    return new ModelAndView ("redirect:tran.htm?id=" + transactionId);
}


public void paintMapLegend (Graphics g) {
    if (getMap () == null) {
        return;
    }
    FontMetrics font_metrics = Toolkit.getDefaultToolkit ().getFontMetrics (configuration.getMapLegendFont ());
    l_height = 0;
    l_max_w = 0;
    for (int j = 0; j < map.size (); j ++) {
        Layer slayer = map.getLayer (map.getLayerOrder ().at (j));
        calculateLegendHeight (map, slayer, font_metrics, j, 0);
    }
    Dimension layers_legend_size = new Dimension (l_max_w + 10, l_height);
    Dimension ruler_size = getPreferredRulerSize (font_metrics);
    Graphics2D g2d = (Graphics2D) g;
    g2d.setFont (configuration.getMapLegendFont ());
    g2d.setColor (Color.white);
    g2d.fillRect (0, 0, whole_map_legend_size.width, whole_map_legend_size.height);
    g2d.setColor (Color.black);
    l_height = 0;
    if (configuration.getLayerOrder () == 0) {
        for (int j = 0; j < map.size (); j ++) {
            Layer layer = map.getLayer (map.getLayerOrder ().at (j));
            paintLayerLegend (map, layer, j, g2d, 0);
        }
    }
    else if (configuration.getLayerOrder () == 1) {
        for (int j = map.size () - 1; j >= 0; j --) {
            Layer layer = map.getLayer (map.getLayerOrder ().at (j));
            paintLayerLegend (map, layer, j, g2d, 0);
        }
    }
    if (isLegendDisplayDistanceRuler ()) {
        java.awt.geom.AffineTransform at = g2d.getTransform ();
        at.translate (0, layers_legend_size.height + 6);
        g2d.setTransform (at);
        paintDistanceRuler (g2d, font_metrics, configuration.getMapLegendFont ());
        at.translate (0, 0 - (layers_legend_size.height + 6));
        g2d.setTransform (at);
    }
}


-----Function Pair=257=-----==

public static MArchive [] get (Properties ctx, String whereClause) {
    ArrayList list = new ArrayList ();
    PreparedStatement pstmt = null;
    String sql = "SELECT * FROM AD_Archive WHERE AD_Client_ID=?";
    if ((whereClause != null) && (whereClause.length () > 0)) {
        sql += whereClause;
    }
    sql += " ORDER BY Created";
    try {
        pstmt = DB.prepareStatement (sql);
        pstmt.setInt (1, Env.getAD_Client_ID (ctx));
        ResultSet rs = pstmt.executeQuery ();
        while (rs.next ()) {
            list.add (new MArchive (ctx, rs, null));
        }
        rs.close ();
        pstmt.close ();
        pstmt = null;
    } catch (Exception e) {
        s_log.log (Level.SEVERE, sql, e);
    }
    try {
        if (pstmt != null) {
            pstmt.close ();
        }
        pstmt = null;
    } catch (Exception e) {
        pstmt = null;
    }
    if (list.size () == 0) {
        s_log.fine (sql);
    }
    else {
        s_log.finer (sql);
    }
    MArchive [] retValue = new MArchive [list.size ()];
    list.toArray (retValue);
    return retValue;
}


private String buildProcessListText (ProcessList processlist) {
    StringBuilder sb = new StringBuilder ();
    sb.append ("ProcessList generated on ").append (processlist.getDate ()).append (LINE_SEPARATOR);
    sb.append ("Server: ").append (processlist.getMysqlServer ().getName ()).append (LINE_SEPARATOR).append (LINE_SEPARATOR);
    sb.append ("PID\t\tUser\t\tHost\t\tDb\t\tCommand\t\tTime\t\tState\t\tInfo").append (LINE_SEPARATOR);
    List < ProcessListItem > items = processlist.getItems ();
    if (items != null) {
        int sleeping = 0;
        for (ProcessListItem item : items) {
            String itemCommand = item.getCommand ();
            if (itemCommand == null || ! itemCommand.equals ("Sleep")) {
                sb.append (item.getPid ()).append ("\t\t").append (item.getUser ()).append ("\t\t").append (item.getHost ()).append ("\t\t").append (item.getDb ()).append ("\t\t").append (item.getCommand ()).append ("\t\t").append (item.getTime ()).append ("\t\t").append (item.getState ()).append ("\t\t").append (item.getInfo ()).append (LINE_SEPARATOR);
            }
            else sleeping ++;
        }
        if (sleeping > 0) sb.append ("Plus ").append (sleeping).append (" sleeping connections.");
    }
    return sb.toString ();
}


-----Function Pair=258=-----==

public static Project loadProject (URL url) throws IOException, Exception {
    Project p = null;
    String urlString = url.toString ();
    int lastDot = urlString.lastIndexOf (".");
    String suffix = "";
    if (lastDot >= 0) {
        suffix = urlString.substring (lastDot).toLowerCase ();
    }
    if (suffix.equals (".xmi")) {
        p = new Project ();
        XMIParser.SINGLETON.readModels (p, url);
        MModel model = XMIParser.SINGLETON.getCurModel ();
        UmlHelper.getHelper ().addListenersToModel (model);
        p._UUIDRefs = XMIParser.SINGLETON.getUUIDRefs ();
        try {
            p.addMember (model);
            p.setNeedsSave (false);
        } catch (PropertyVetoException pve) {
        }
        org.argouml.application.Main.addPostLoadAction (new ResetStatsLater ());
    }
    else if ((suffix.equals (COMPRESSED_FILE_EXT)) || (suffix.equals (BOTL_FILE_EXT))) {
        try {
            ZipInputStream zis = new ZipInputStream (url.openStream ());
            String name = zis.getNextEntry ().getName ();
            while (! name.endsWith (PROJECT_FILE_EXT)) {
                name = zis.getNextEntry ().getName ();
            }
            System.out.println ("ARGO NAME: " + name);
            ArgoParser.SINGLETON.setURL (url);
            ArgoParser.SINGLETON.readProject (zis, false);
            p = ArgoParser.SINGLETON.getProject ();
            zis.close ();
            if (suffix.equals (BOTL_FILE_EXT)) {
                p.setBOTLProject (true);
            }
            else {
                p.setBOTLProject (false);
            }
        } catch (Exception e) {
            cat.error ("Oops, something went wrong in Project.loadProject ");
            cat.error (e);
            throw e;
        }
        try {
            p.loadZippedProjectMembers (url);
        } catch (IOException e) {
            cat.error ("Project file corrupted");
            cat.error (e);
            throw e;
        }
        p.postLoad ();
    }
    else {
        ArgoParser.SINGLETON.readProject (url);
        p = ArgoParser.SINGLETON.getProject ();
        p.loadAllMembers ();
        p.postLoad ();
    }
    return p;
}


private byte [] addTunerToList (HTTPurl urlData) throws Exception {
    String tunerID = "";
    String name = "";
    try {
        tunerID = urlData.getParameter ("tunerID");
        name = urlData.getParameter ("tunerName");
        boolean alreadyAdded = false;
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        if (tunerID.length () > 0) {
            for (int x = 0; x < devList.getDeviceCount (); x ++) {
                CaptureDevice cap = (CaptureDevice) devList.getDevice (x);
                if (cap.getID () == tunerID) {
                    alreadyAdded = true;
                }
            }
        }
        if (alreadyAdded == false && tunerID.length () > 0 && devList.getActiveDeviceCount () == 0) {
            CaptureDevice cap = new CaptureDevice (name, tunerID);
            devList.addDevice (cap);
            devList.saveDeviceList (null);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=259=-----==

private byte [] showCalendar (HTTPurl urlData) throws Exception {
    String id = urlData.getParameter ("id");
    int index = - 1;
    try {
        index = Integer.parseInt (urlData.getParameter ("index"));
    } catch (Exception e) {
    }
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    int month = - 1;
    int year = - 1;
    try {
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "calendar.html");
    template.replaceAll ("$calendar", getCalendarTable (month, year, id, index, urlData));
    return template.getPageBytes ();
}


private void archiveOldItem (ScheduleItem removedItem) {
    try {
        SimpleDateFormat df = new SimpleDateFormat ("yyyyMMdd@HHmmssS");
        String archiveName = new DllWrapper ().getAllUserPath () + "archive\\Schedule-" + df.format (removedItem.getStart ()) + " (" + removedItem.getChannel () + ") (" + removedItem.getName () + ").sof";
        File outFile = new File (archiveName);
        outFile = outFile.getCanonicalFile ();
        File parent = outFile.getParentFile ();
        if (parent.exists () == false) parent.mkdirs ();
        FileOutputStream fos = new FileOutputStream (outFile);
        ObjectOutputStream oos = new ObjectOutputStream (fos);
        oos.writeObject (removedItem);
        oos.close ();
    } catch (Exception e) {
        System.out.println ("Error trying to archive old Schedule Item:");
        e.printStackTrace ();
    }
}


-----Function Pair=260=-----==

private byte [] showAddForm (HTTPurl urlData) throws Exception {
    int day = - 1;
    int month = - 1;
    int year = - 1;
    try {
        day = Integer.parseInt (urlData.getParameter ("day"));
        month = Integer.parseInt (urlData.getParameter ("month"));
        year = Integer.parseInt (urlData.getParameter ("year"));
    } catch (Exception e) {
    }
    ScheduleItem item = null;
    String id = urlData.getParameter ("id");
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
    }
    if (item != null && (item.getState () != ScheduleItem.FINISHED && item.getState () != ScheduleItem.WAITING && item.getState () != ScheduleItem.SKIPPED && item.getState () != ScheduleItem.ERROR)) {
        StringBuffer out = new StringBuffer ();
        out.append ("HTTP/1.0 302 Moved Temporarily\n");
        out.append ("Location: /servlet/ScheduleDataRes\n\n");
        return out.toString ().getBytes ();
    }
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "itemdetails.html");
    if (item != null) template.replaceAll ("$duration", new Integer (item.getDuration ()).toString ());
    else template.replaceAll ("$duration", "1");
    if (item != null) template.replaceAll ("$name", item.getName ());
    else template.replaceAll ("$name", "");
    Calendar cal = Calendar.getInstance ();
    if (item != null) cal.setTime (item.getStart ());
    template.replaceAll ("$hour", store.intToStr (cal.get (Calendar.HOUR_OF_DAY)));
    template.replaceAll ("$min", store.intToStr (cal.get (Calendar.MINUTE)));
    template.replaceAll ("$channels", getChannelList (item));
    template.replaceAll ("$item_type", getTypeList (item));
    template.replaceAll ("$item_captype", getCapTypeList (item));
    String fields = "";
    fields += "<input type='hidden' name='day' value='" + day + "'>\n";
    fields += "<input type='hidden' name='month' value='" + month + "'>\n";
    fields += "<input type='hidden' name='year' value='" + year + "'>\n";
    if (item != null) {
        fields += "<input name='id' type='hidden' id='id' value='" + id + "'>\n";
    }
    template.replaceAll ("$fields", fields);
    if (item != null && item.isAutoDeletable ()) template.replaceAll ("$adtrue", "checked");
    else template.replaceAll ("$adtrue", "");
    template.replaceAll ("$pattern", getNamePatternList (item));
    if (item == null) {
        String defKeepFor = store.getProperty ("AutoDel.KeepFor");
        if (defKeepFor == null) defKeepFor = "30";
        template.replaceAll ("$keepfor", defKeepFor);
    }
    else {
        template.replaceAll ("$keepfor", new Integer (item.getKeepFor ()).toString ());
    }
    template.replaceAll ("$tasks", getTaskList (item));
    template.replaceAll ("$CapturePaths", getCapturePathList (item));
    return template.getPageBytes ();
}


public void write (ZipOutputStream out, DataOutputStream dos, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegionScores [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegionScores.length; i ++) {
            int currentStart = sortedRegionScores [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegionScores.length; i ++) {
            int diff = sortedRegionScores [i].stop - sortedRegionScores [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    fileType = fileType + USeqUtilities.FLOAT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = null;
    try {
        out.putNextEntry (new ZipEntry (sliceInfo.getSliceName ()));
        dos.writeUTF (header);
        dos.writeInt (sortedRegionScores [0].start);
        int bp = sortedRegionScores [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionScores [0].stop - sortedRegionScores [0].start);
                dos.writeFloat (sortedRegionScores [0].score);
                for (int i = 1; i < sortedRegionScores.length; i ++) {
                    int currentStart = sortedRegionScores [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeInt (sortedRegionScores [i].stop - sortedRegionScores [i].start);
                    dos.writeFloat (sortedRegionScores [i].score);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionScores [0].stop - sortedRegionScores [0].start - 32768));
                dos.writeFloat (sortedRegionScores [0].score);
                for (int i = 1; i < sortedRegionScores.length; i ++) {
                    int currentStart = sortedRegionScores [i].start;
                    int diff = currentStart - bp - 32768;
                    dos.writeShort ((short) (diff));
                    dos.writeShort ((short) (sortedRegionScores [i].stop - sortedRegionScores [i].start - 32768));
                    dos.writeFloat (sortedRegionScores [i].score);
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                dos.writeInt (sortedRegionScores [0].stop - sortedRegionScores [0].start);
                dos.writeFloat (sortedRegionScores [0].score);
                for (int i = 1; i < sortedRegionScores.length; i ++) {
                    int currentStart = sortedRegionScores [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeInt (sortedRegionScores [i].stop - sortedRegionScores [i].start);
                    dos.writeFloat (sortedRegionScores [i].score);
                    bp = currentStart;
                }
            }
            else {
                dos.writeShort ((short) (sortedRegionScores [0].stop - sortedRegionScores [0].start - 32768));
                dos.writeFloat (sortedRegionScores [0].score);
                for (int i = 1; i < sortedRegionScores.length; i ++) {
                    int currentStart = sortedRegionScores [i].start;
                    int diff = currentStart - bp;
                    dos.writeInt (diff);
                    dos.writeShort ((short) (sortedRegionScores [i].stop - sortedRegionScores [i].start - 32768));
                    dos.writeFloat (sortedRegionScores [i].score);
                    bp = currentStart;
                }
            }
        }
        out.closeEntry ();
    } catch (IOException e) {
        e.printStackTrace ();
        USeqUtilities.safeClose (out);
        USeqUtilities.safeClose (dos);
    }
}


-----Function Pair=261=-----==

public static File copyFile (File file) {
    File src = file;
    File dest = new File (src.getName ());
    try {
        if (! dest.exists ()) {
            dest.createNewFile ();
        }
        FileChannel source = new FileInputStream (src).getChannel ();
        FileChannel destination = new FileOutputStream (dest).getChannel ();
        destination.transferFrom (source, 0, source.size ());
        source.close ();
        destination.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return dest;
}


public static Map < String, String > parseManifestFile (File jarfile) {
    try {
        JarFile jar = new JarFile (jarfile);
        Manifest mf = jar.getManifest ();
        if (mf == null) return null;
        Attributes attrs = mf.getMainAttributes ();
        if (attrs == null) return null;
        Map < String, String > map = new HashMap < String, String > (mf.getMainAttributes ().size ());
        for (Map.Entry < Object, Object > entry : mf.getMainAttributes ().entrySet ()) map.put (entry.getKey ().toString (), entry.getValue ().toString ());
        return map;
    } catch (IOException e) {
        e.printStackTrace ();
        return null;
    } finally {
    }
}


-----Function Pair=262=-----==

public void run () throws Exception {
    File absJar = createJar (new File ("abs.jar").getAbsoluteFile (), "j.A");
    File relJar = createJar (new File ("rel.jar"), "j.R");
    File absDir = createDir (new File ("abs.dir").getAbsoluteFile (), "d.A");
    File relDir = createDir (new File ("rel.dir"), "d.R");
    File absTestFile = writeFile (new File ("AbsTest.java").getAbsoluteFile (), "class AbsTest { class Inner { } }");
    File relTestFile = writeFile (new File ("RelTest.java"), "class RelTest { class Inner { } }");
    File relTest2File = writeFile (new File ("p/RelTest2.java"), "package p; class RelTest2 { class Inner { } }");
    File mainFile = writeFile (new File ("Main.java"), "class Main { j.A ja; j.R jr; d.A da; d.R dr; }" + "");
    String sourcePath = createPath (absJar, relJar, absDir, relDir);
    File outDir = new File ("classes");
    outDir.mkdirs ();
    String [] args = {"-sourcepath", sourcePath, "-d", outDir.getPath (), absTestFile.getPath (), relTestFile.getPath (), relTest2File.getPath (), mainFile.getPath ()};
    System.err.println ("compile: " + Arrays.asList (args));
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javac.Main.compile (args, pw);
    pw.close ();
    if (rc != 0) {
        System.err.println (sw.toString ());
        throw new Exception ("unexpected exit from javac: " + rc);
    }
    Set < File > expect = getFiles (outDir, "d/A.class", "d/A$Inner.class", "d/R.class", "d/R$Inner.class", "j/A.class", "j/A$Inner.class", "j/R.class", "j/R$Inner.class", "AbsTest.class", "AbsTest$Inner.class", "RelTest.class", "RelTest$Inner.class", "p/RelTest2.class", "p/RelTest2$Inner.class", "Main.class");
    Set < File > found = findFiles (outDir);
    if (! found.equals (expect)) {
        if (found.containsAll (expect)) throw new Exception ("unexpected files found: " + diff (found, expect));
        else if (expect.containsAll (found)) throw new Exception ("expected files not found: " + diff (expect, found));
    }
    for (File f : found) verifySourceFileAttribute (f);
    if (errors > 0) throw new Exception (errors + " errors occurred");
}


public List < ExtZipEntry > getEntryList () throws IOException, ZipException {
    List < ExtZipEntry > out = new ArrayList < ExtZipEntry > ();
    short totalNumberOfEntries = this.getNumberOfEntries ();
    int dirOffset = raFile.readInt (this.dirOffsetPos);
    long fileOffset = dirOffset;
    for (int i = 0; i < totalNumberOfEntries; i ++) {
        int censig = raFile.readInt (fileOffset);
        if (censig != CENSIG) {
            throw new ZipException ("expected CENSIC not found at entry no " + (i + 1) + " in central directory at end of zip file at " + fileOffset);
        }
        short fileNameLength = raFile.readShort (fileOffset + 28);
        short extraFieldLength = raFile.readShort (fileOffset + 30);
        long fileOffsetPos = fileOffset + 28 + 14;
        long fileDataOffset = raFile.readInt (fileOffsetPos);
        int locsig = raFile.readInt (fileDataOffset);
        if (locsig != LOCSIG) {
            System.out.println (fileOffsetPos + " - " + fileNameLength);
        }
        byte [] fileNameBytes = raFile.readByteArray (fileOffsetPos + 4, fileNameLength);
        long nextFileOffset = raFile.getFilePointer ();
        String fileName = new String (fileNameBytes, charset);
        ExtZipEntry zipEntry = new ExtZipEntry (fileName);
        CentralDirectoryEntry cde = new CentralDirectoryEntry (raFile, fileOffset);
        zipEntry.setCentralDirectoryEntry (cde);
        zipEntry.setCompressedSize (cde.getCompressedSize ());
        zipEntry.setSize (cde.getUncompressedSize ());
        long dosTime = raFile.readInt (fileOffset + 12);
        zipEntry.setTime (ExtZipEntry.dosToJavaTime (dosTime));
        if (cde.isEncrypted ()) {
            zipEntry.setMethod (cde.getActualCompressionMethod ());
            zipEntry.setOffset ((int) (cde.getLocalHeaderOffset () + cde.getLocalHeaderSize ()) + cde.getCryptoHeaderLength ());
            zipEntry.initEncryptedEntry ();
        }
        else {
            zipEntry.setMethod (ZipEntry.DEFLATED);
            zipEntry.setPrimaryCompressionMethod (ZipEntry.DEFLATED);
        }
        nextFileOffset += extraFieldLength;
        out.add (zipEntry);
        fileOffset = nextFileOffset;
    }
    return out;
}


-----Function Pair=263=-----==

public void exportToENARGASTxt (List tecnicos, List revisiones, String postFix) {
    try {
        String fileName = System.getProperty ("java.io.tmpdir") + File.separator + "REVTMP.TXT";
        BufferedWriter out = new BufferedWriter (new FileWriter (fileName));
        for (Iterator ir = revisiones.iterator (); ir.hasNext ();) {
            Revision rev = (Revision) ir.next ();
            out.write (this.getENARGASString (rev));
            out.write ("\r\n");
        }
        out.close ();
        byte [] buf = new byte [1024];
        FileInputStream in = new FileInputStream (fileName);
        ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (path + File.separator + "REV" + postFix + ".zip"));
        zip.putNextEntry (new ZipEntry ("REV.TXT"));
        int len;
        while ((len = in.read (buf)) > 0) {
            zip.write (buf, 0, len);
        }
        zip.closeEntry ();
        in.close ();
        zip.close ();
    } catch (IOException e) {
        System.out.println ("Error al crear el archivo, exportacion.");
    }
}


private void archiveDirectories (ZipOutputStream out) throws IOException {
    int numThreads = Settings.getInt ("slowNetwork.numParallelReads", 10);
    ExecutorService service = Executors.newFixedThreadPool (Math.max (numThreads, 1));
    DrainableExecutor executor = new DrainableExecutor (service);
    exceptionEncountered = null;
    NumberFormat fmt = NumberFormat.getIntegerInstance ();
    fmt.setMinimumIntegerDigits (3);
    Set < String > extDirNames = new HashSet < String > ();
    extDirNames.add (null);
    extDirNames.add ("");
    for (int i = 0; i < importInstructions.size (); i ++) {
        ImportDirectoryInstruction instr = importInstructions.get (i);
        String newPath = getExtDirName (instr);
        if (extDirNames.contains (newPath)) newPath = "extdir" + fmt.format (i + 1);
        extDirNames.add (newPath);
        executor.execute (new ArchiveDirectoryTask (executor, out, instr, newPath));
    }
    executor.drain ();
    if (exceptionEncountered != null) throw exceptionEncountered;
}


-----Function Pair=264=-----==

public static void ensureFileContentsEqual (String fileOne, String fileTwo) throws IOException {
    File file1 = checkFileExists (fileOne);
    File file2 = checkFileExists (fileTwo);
    if (file1.length () != file2.length ()) {
        throw new IOException ("Comparison failed " + fileOne + " size=" + file1.length () + " " + fileTwo + " size=" + file2.length ());
    }
    BufferedInputStream file1Stream = new BufferedInputStream (new FileInputStream (file1));
    BufferedInputStream file2Stream = new BufferedInputStream (new FileInputStream (file2));
    int byteRead;
    int byteToCompare;
    long position = 0;
    while ((byteRead = file1Stream.read ()) != - 1) {
        byteToCompare = file2Stream.read ();
        if (byteRead != byteToCompare) {
            throw new IOException ("Comparison failed. Byte at position " + position + " in " + fileOne + " different from that in " + fileTwo);
        }
        position ++;
    }
}


public static String calculateMD5 (String formula) throws FileNotFoundException, IOException, NoSuchAlgorithmException {
    MessageDigest digest = MessageDigest.getInstance ("MD5");
    byte [] buffer = formula.getBytes ();
    digest.update (buffer);
    byte [] md5sum = digest.digest ();
    StringBuffer buf = new StringBuffer ();
    for (int i = 0; i < md5sum.length; i ++) {
        int halfbyte = (md5sum [i]>>> 4) & 0x0F;
        int two_halfs = 0;
        do {
            if ((0 <= halfbyte) && (halfbyte <= 9)) {
                buf.append ((char) ('0' + halfbyte));
            }
            else {
                buf.append ((char) ('a' + (halfbyte - 10)));
            }
            halfbyte = md5sum [i] & 0x0F;
        }
        while (two_halfs ++ < 1);
    }
    String res = buf.toString ();
    return buf.toString ();
}


-----Function Pair=265=-----=1=

private void backupDir (ZipOutputStream zos, String root, File dir) throws IOException {
    if (! root.equals (dir.toString ())) {
        String relDir = dir.toString ().substring (root.length () + 1) + '/';
        zos.putNextEntry (new ZipEntry (relDir));
    }
    File [] children = dir.listFiles ();
    if (children == null) return;
    for (int ii = 0; ii < children.length; ++ ii) {
        File child = children [ii];
        log (child.toString ());
        if (child.isDirectory ()) backupDir (zos, root, child);
        else {
            String relFile = child.toString ().substring (root.length () + 1);
            ZipEntry ze = new ZipEntry (relFile);
            ze.setSize (child.length ());
            ze.setTime (child.lastModified ());
            zos.putNextEntry (ze);
            FileInputStream fis = new FileInputStream (child);
            int len;
            while ((len = fis.read (fileBuffer)) != - 1) {
                crc32.update (fileBuffer, 0, len);
                zos.write (fileBuffer, 0, len);
            }
            fis.close ();
            ze.setCrc (crc32.getValue ());
        }
    }
}


static void copyZipEntries (ZipOutputStream zout, File src, Filter filter) throws Throwable {
    ZipFile zipSrc = null;
    try {
        zipSrc = new ZipFile (src);
    } catch (Throwable t) {
        System.out.println ("Unexpected error:");
        t.printStackTrace ();
        System.out.println ();
        System.out.println ("Your JDK_DIR cannot handle long JAR entries");
        System.out.println ("Please upgrade to JDK 1.4.1 or later.");
        System.out.println ("JDK version '1.4.1' is known to work.");
        System.exit (- 1);
    }
    for (Enumeration e = zipSrc.entries (); e.hasMoreElements ();) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        String name = entry.getName ();
        if (name.startsWith ("META-INF")) {
            continue;
        }
        if (filter != null && ! filter.includeEntry (entry.getName ())) {
            continue;
        }
        int size = (int) entry.getSize ();
        byte data [] = new byte [size];
        InputStream in = zipSrc.getInputStream (entry);
        DataInputStream din = new DataInputStream (in);
        din.readFully (data);
        zout.putNextEntry (entry);
        zout.write (data, 0, data.length);
        zout.closeEntry ();
        din.close ();
    }
}


-----Function Pair=266=-----==

boolean delete (boolean replacing) {
    int count = list.getItemCount ();
    if (count == 0) return error ("The list is empty.");
    int index [] = list.getSelectedIndexes ();
    if (index.length == 0 || (replacing && count > 1)) {
        String msg = "Delete all items on the list?";
        if (replacing) msg = "Replace items on the list?";
        canceled = false;
        if (! IJ.isMacro () && ! macro) {
            YesNoCancelDialog d = new YesNoCancelDialog (this, "ROI Manager", msg);
            if (d.cancelPressed ()) {
                canceled = true;
                return false;
            }
            if (! d.yesPressed ()) return false;
        }
        index = getAllIndexes ();
    }
    for (int i = count - 1; i >= 0; i --) {
        boolean delete = false;
        for (int j = 0; j < index.length; j ++) {
            if (index [j] == i) delete = true;
        }
        if (delete) {
            rois.remove (list.getItem (i));
            list.remove (i);
        }
    }
    ImagePlus imp = WindowManager.getCurrentImage ();
    if (count > 1 && index.length == 1 && imp != null) imp.killRoi ();
    updateShowAll ();
    if (record ()) Recorder.record ("roiManager", "Delete");
    return true;
}


public Vector < File > generate (final File path, File source []) {
    final ConcurrentLinkedQueue < File > queue = new ConcurrentLinkedQueue < File > ();
    for (File f : source) queue.add (f);
    final ImageGenerator imageGenerator = new ImageGenerator (o);
    try {
        final Vector < File > outFiles = new Vector < File > ();
        class Producer implements Runnable {
            private File outputdir;
            Producer (File theOutputDir) {
                this.outputdir = theOutputDir;
            } public void run () {
                try {
                    File file;
                    while ((file = queue.poll ()) != null) {
                        if (progressMonitor.isCanceled ()) break;
                        final String currentFile = file.getName ();
                        SwingUtilities.invokeLater (new Runnable () {
                            public void run () {
                                progressMonitor.setNote (mes.getString ("Generator.currentImage") + ": " + currentFile);
                            }
                        }
                        );
                        BufferedImage image = ImageIO.read (file);
                        boolean error = false;
                        File out;
                        try {
                            out = imageGenerator.generateImage (outputdir, file, image);
                            outFiles.addElement (out);
                        } catch (Exception e) {
                            error = true;
                            e.printStackTrace ();
                        }
                        StringBuilder message = new StringBuilder ();
                        message.append (mes.getString ("Generator.10"));
                        message.append (file.getName ());
                        message.append ("\t . . . ");
                        if (error == false) message.append (mes.getString ("Generator.40"));
                        else message.append (mes.getString ("Generator.42"));
                        log.insertLine (message.toString ());
                        incrementIndex ();
                    }
                } catch (Exception e) {
                    e.printStackTrace ();
                }
            } int index = 0;
            public synchronized void incrementIndex () {
                progressMonitor.setProgress (++ index);
            }
        }
        if (source.length == 0) return new Vector < File > ();
        m.status.setStatusOn ();
        String quality = Integer.toString ((int) (o.getQuality () * 100));
        String info = mes.getString ("Generator.28", source.length, source [0].getParentFile ().getName (), quality);
        progressMonitor = new ProgressMonitor (m, info, mes.getString ("Generator.10"), 0, source.length);
        progressMonitor.setMillisToPopup (0);
        progressMonitor.setMillisToDecideToPopup (0);
        log.insertLine ("");
        Producer producer = new Producer (path);
        Thread producerThread1 = new Thread (producer);
        Thread producerThread2 = new Thread (producer);
        log.insert (ls + ls + info + ls);
        long start = System.currentTimeMillis ();
        producerThread1.start ();
        producerThread2.start ();
        try {
            producerThread1.join ();
            producerThread2.join ();
        } catch (InterruptedException ignore) {
        }
        System.out.println ("duration: " + (System.currentTimeMillis () - start) + " millis");
        return outFiles;
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return new Vector < File > ();
}


-----Function Pair=267=-----==

private static void writeEntry (ZipOutputStream zip, String name, InputStream in) throws IOException {
    zip.putNextEntry (new ZipEntry (name));
    try {
        byte [] buffer = new byte [4096];
        for (int n = in.read (buffer); n != - 1; n = in.read (buffer)) {
            zip.write (buffer, 0, n);
        }
    } finally {
        try {
            in.close ();
        } catch (Exception e) {
        }
    }
    zip.closeEntry ();
}


public void execute (DBBroker broker) throws EXistException {
    if (! (broker instanceof NativeBroker)) throw new EXistException ("DataBackup system task can only be used " + "with the native storage backend");
    LOG.debug ("Backing up data files ...");
    String creationDate = creationDateFormat.format (Calendar.getInstance ().getTime ());
    String outFilename = dest + File.separatorChar + creationDate + ".zip";
    LOG.debug ("Archiving data files into: " + outFilename);
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        Callback cb = new Callback (out);
        broker.backupToArchive (cb);
        out.close ();
    } catch (IOException e) {
        LOG.warn ("An IO error occurred while backing up data files: " + e.getMessage (), e);
    }
}


-----Function Pair=268=-----==

public int obtenerCantidad () {
    try {
        BufferedOutputStream dest = null;
        BufferedInputStream is = null;
        ZipEntry entry;
        ZipFile zipfile = new ZipFile ("cantidadArchivos.zip");
        Enumeration e = zipfile.entries ();
        while (e.hasMoreElements ()) {
            entry = (ZipEntry) e.nextElement ();
            is = new BufferedInputStream (zipfile.getInputStream (entry));
            int count;
            byte data [] = new byte [buffer];
            FileOutputStream fos = new FileOutputStream (entry.getName ());
            dest = new BufferedOutputStream (fos, buffer);
            while ((count = is.read (data, 0, buffer)) != - 1) dest.write (data, 0, count);
            dest.flush ();
            dest.close ();
            is.close ();
        }
        DataInputStream input = new DataInputStream (new FileInputStream ("cantidadArchivos.txt"));
        int a = Integer.parseInt (input.readLine ());
        input.close ();
        return (a);
    } catch (Exception e) {
        return (0);
    }
}


public static File [] extractFiles (File directory) {
    File [] files = null;
    String [] fileNames;
    if (directory.isDirectory ()) {
        fileNames = directory.list ();
        int num = fileNames.length;
        ArrayList < File > al = new ArrayList < File > ();
        try {
            String path = directory.getCanonicalPath ();
            Pattern pat = Pattern.compile ("^\\w+.*");
            Matcher mat;
            for (int i = 0; i < num; i ++) {
                mat = pat.matcher (fileNames [i]);
                if (mat.matches ()) al.add (new File (path, fileNames [i]));
            }
            if (al.size () != 0) {
                files = new File [al.size ()];
                al.toArray (files);
            }
        } catch (IOException e) {
            System.out.println ("Problem extractFiles() " + directory);
            e.printStackTrace ();
            return null;
        }
    }
    if (files == null) {
        files = new File [1];
        files [0] = directory;
    }
    Arrays.sort (files);
    return files;
}


-----Function Pair=269=-----==

public MapObject loadMap (String path) {
    try {
        InputStream inStream = getClass ().getResourceAsStream (path);
        StringBuffer contents = new StringBuffer ();
        String line = null;
        BufferedReader reader = new BufferedReader (new InputStreamReader (inStream));
        while ((line = reader.readLine ()) != null) {
            contents.append (line);
            contents.append (MapMaker.NL);
        }
        MapObject map = new com.fj.torkel.author.MapMaker ().create (contents.toString (), false);
        return map;
    } catch (Throwable x) {
        x.printStackTrace ();
        return null;
    }
}


private void addObjectProperties () throws ObjectIntegrityException {
    String state = DOTranslationUtility.getStateAttribute (m_obj);
    String ownerId = m_obj.getOwnerId ();
    String label = m_obj.getLabel ();
    Date cdate = m_obj.getCreateDate ();
    Date mdate = m_obj.getLastModDate ();
    m_feed.setId (m_pid.toURI ());
    m_feed.setTitle (label == null ? "" : label);
    m_feed.setUpdated (mdate);
    m_feed.addAuthor (ownerId == null ? "" : StreamUtility.enc (ownerId));
    m_feed.addCategory (MODEL.STATE.uri, state, null);
    if (cdate != null) {
        m_feed.addCategory (MODEL.CREATED_DATE.uri, DateUtility.convertDateToString (cdate), null);
    }
    for (String extProp : m_obj.getExtProperties ().keySet ()) {
        m_feed.addCategory (MODEL.EXT_PROPERTY.uri, extProp, m_obj.getExtProperty (extProp));
    }
}


-----Function Pair=270=-----==

private static final void zip (File directory, File base, ZipOutputStream zos) throws IOException {
    File [] files = directory.listFiles ();
    byte [] buffer = new byte [8192];
    int read = 0;
    for (int i = 0, n = files.length; i < n; i ++) {
        if (files [i].isDirectory ()) {
            zip (files [i], base, zos);
        }
        else {
            FileInputStream in = new FileInputStream (files [i]);
            ZipEntry entry = new ZipEntry (files [i].getPath ().substring (base.getPath ().length () + 1));
            zos.putNextEntry (entry);
            while (- 1 != (read = in.read (buffer))) {
                zos.write (buffer, 0, read);
            }
            in.close ();
        }
    }
}


public void deleteEntry (int id, int dbid) throws StatementNotExecutedException, EntriesException, NoRightException {
    Key recordID = new Key (id, dbid);
    Key projID = query.getInputUnitManager ().getProjectID (recordID);
    Project proj = query.getProjectManager ().getProject (projID.getID (), projID.getDBNumber ());
    Right right = query.getUserManager ().getRight (project.getProjectKey ());
    if (right != Right.WRITE) {
        throw new NoRightException (NoRightException.Rights.NOWRITE);
    }
    Key massid = query.getInputUnitManager ().getMassKey (recordID);
    query.getMeasurementManager ().deleteValue (massid);
    Key wearstage2Key = query.getInputUnitManager ().getWearstage2Key (recordID);
    Key artefactID = query.getInputUnitManager ().getArtefactId (recordID);
    query.getArtefactManager ().deleteValue (artefactID);
    query.getInputUnitManager ().deleteValue (recordID);
    query.getWearstage2Manager ().deleteValue (wearstage2Key);
    query.getAnimalManager ().deleteValue (recordID);
    query.getBoneElementManager ().deleteValue (recordID);
    query.getGeneLibaryManager ().deleteValue (recordID);
}


-----Function Pair=271=-----==

protected void dispatchDone (HttpServletRequest request, HttpServletResponse response) {
    if (exception != null) {
        error (request, response, new ServletException (exception.getMessage (), exception));
        return;
    }
    try {
        response.setContentType ("application/zip");
        response.setHeader ("Expires", "0");
        response.setHeader ("Pragma", "no-cache");
        response.setHeader ("Keep-Alive", "timeout=15, max=100");
        response.setHeader ("Connection", "Keep-Alive");
        response.setHeader ("Content-Disposition", "attachment" + ";filename=HTMLExportOf" + virtualWiki + ".zip;");
        FileInputStream in = new FileInputStream (tempFile);
        response.setContentLength ((int) tempFile.length ());
        OutputStream out = response.getOutputStream ();
        int bytesRead = 0;
        byte byteArray [] = new byte [4096];
        while (in.available () > 0) {
            bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
            out.write (byteArray, 0, bytesRead);
        }
        out.flush ();
        out.close ();
        tempFile.delete ();
    } catch (Exception e) {
        logger.fatal ("Exception", e);
        error (request, response, new ServletException (e.getMessage (), e));
    }
}


public static int recursiveApply (String filename, FileRecursiveApply apply) {
    int count = 0;
    File file = new File (filename);
    if (file.exists ()) {
        if (file.isDirectory ()) {
            String [] list = file.list ();
            for (int i = 0; i < list.length; i ++) {
                if (list [i] != null) {
                    count += recursiveApply (filename + File.separatorChar + list [i], apply);
                }
            }
        }
        else {
            if (apply.apply (filename, file)) {
                count = 1;
            }
        }
    }
    return count;
}


-----Function Pair=272=-----==

public void editSolverBinary (File [] binary, SolverBinaries solverBin) throws IOException, NoSuchAlgorithmException {
    if (binary.length == 0) {
        return;
    }
    Arrays.sort (binary);
    solverBin.setBinaryArchive (binary);
    FileInputStreamList is = new FileInputStreamList (binary);
    SequenceInputStream seq = new SequenceInputStream (is);
    String md5 = Util.calculateMD5 (seq);
    if (hasDuplicates (md5)) {
        if (JOptionPane.showConfirmDialog (gui, "There already exists a solver binary with the same " + "checksum. Do you want to add this binary anyway?", "Duplicate solver binary", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.NO_OPTION) {
            return;
        }
    }
    solverBin.setMd5 (md5);
    Util.removeCommonPrefix (solverBin);
    new EDACCSolverBinaryDlg (EDACCApp.getApplication ().getMainFrame (), solverBin, this, EDACCSolverBinaryDlg.DialogMode.EDIT_MODE).setVisible (true);
    gui.showSolverBinariesDetails (currentSolver.getSolverBinaries ());
}


private ZipEntry processEntry (ZipFile zip, ZipEntry inputEntry) {
    String name = inputEntry.getName ();
    if (! (inputEntry.isDirectory () || name.endsWith (".class"))) {
        try {
            InputStream input = zip.getInputStream (zip.getEntry (name));
            String className = ClassNameReader.getClassName (input);
            input.close ();
            if (className != null) {
                name = className.replace ('.', '/') + ".class";
            }
        } catch (IOException ioe) {
        }
    }
    ZipEntry outputEntry = new ZipEntry (name);
    outputEntry.setTime (inputEntry.getTime ());
    outputEntry.setExtra (inputEntry.getExtra ());
    outputEntry.setComment (inputEntry.getComment ());
    outputEntry.setTime (inputEntry.getTime ());
    if (compression) {
        outputEntry.setMethod (ZipEntry.DEFLATED);
    }
    else {
        outputEntry.setMethod (ZipEntry.STORED);
        outputEntry.setCrc (inputEntry.getCrc ());
        outputEntry.setSize (inputEntry.getSize ());
    }
    return outputEntry;
}


-----Function Pair=273=-----==

private void CreateDsTable (NpsContext ctxt, Topic t) throws NpsException {
    if (t == null) return;
    String tablename = t.GetTable ();
    if (tablename == null || tablename.length () == 0) return;
    String dstable_name = tablename + "_prop";
    dstable_name = dstable_name.toUpperCase ();
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        String sql = "select count(*) table_count from all_tables Where table_name=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, dstable_name);
        rs = pstmt.executeQuery ();
        rs.next ();
        if (rs.getInt ("table_count") > 0) {
            try {
                rs.close ();
            } catch (Exception e) {
            }
            try {
                pstmt.close ();
            } catch (Exception e) {
            }
            sql = "select id,title,siteid,topic,state,createdate,publishdate from " + dstable_name + " where rownum<2";
            try {
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                rs = pstmt.executeQuery ();
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                stmt = ctxt.GetConnection ().createStatement ();
                sql = "Alter Table " + dstable_name + " Modify siteid default('" + t.GetSiteId () + "')";
                stmt.executeUpdate (sql);
                sql = "Alter Table " + dstable_name + " Modify topic default('" + t.GetId () + "')";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,default:" + treename + "'";
                stmt.executeUpdate (sql);
                sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,default:" + t.GetName () + "'";
                stmt.executeUpdate (sql);
                try {
                    stmt.close ();
                } catch (Exception e1) {
                }
                return;
            } catch (Exception e) {
                try {
                    rs.close ();
                } catch (Exception e1) {
                }
                try {
                    pstmt.close ();
                } catch (Exception e1) {
                }
                sql = "drop table " + dstable_name;
                pstmt = ctxt.GetConnection ().prepareStatement (sql);
                pstmt.executeUpdate (sql);
            }
        }
        try {
            rs.close ();
        } catch (Exception e) {
        }
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        stmt = ctxt.GetConnection ().createStatement ();
        sql = "CREATE TABLE " + dstable_name + " (ID VARCHAR2(50) NOT NULL," + "TITLE VARCHAR2(1000) NOT NULL," + "SITEID VARCHAR2(10) DEFAULT '" + t.GetSiteId () + "' NOT NULL," + "TOPIC VARCHAR2(10) DEFAULT '" + t.GetId () + "' NOT NULL," + "STATE NUMBER," + "CREATEDATE DATE DEFAULT SYSDATE NOT NULL," + "PUBLISHDATE DATE," + "CONSTRAINT PK_" + dstable_name + " PRIMARY KEY (ID,TOPIC)" + ")";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".ID IS 'id'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TITLE IS 'title'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".SITEID IS 'site id,site name is:" + treename + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".TOPIC IS 'topic id,topic name is:" + t.GetName () + "'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".STATE IS 'status'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".CREATEDATE IS 'create date'";
        stmt.executeUpdate (sql);
        sql = "COMMENT ON COLUMN " + dstable_name + ".PUBLISHDATE IS 'publish date'";
        stmt.executeUpdate (sql);
        sql = "create index idx_" + dstable_name + "_topstate on " + dstable_name + "(siteid,topic,state)";
        stmt.executeUpdate (sql);
        try {
            stmt.close ();
        } catch (Exception e) {
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (rs != null) try {
            rs.close ();
        } catch (Exception e) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        if (stmt != null) try {
            stmt.close ();
        } catch (Exception e) {
        }
    }
}


public boolean save (String content) throws IOException {
    FileUtility toFile = this;
    if (this.isDirectory ()) abort ("FileUtility: destination is a directory: " + pathName);
    if (toFile.exists ()) {
        if (! toFile.canWrite ()) {
            abort ("FileUtility: destination file is unwriteable: " + pathName);
            return false;
        }
    }
    else {
        String parent = toFile.getParent ();
        File dir = new File (parent);
        if (! dir.exists ()) {
            abort ("FileUtility: destination directory doesn't exist: " + parent);
            return false;
        }
        if (dir.isFile ()) {
            abort ("FileUtility: destination is not a directory: " + parent);
            return false;
        }
        if (! dir.canWrite ()) {
            abort ("FileUtility: destination directory is unwriteable: " + parent);
            return false;
        }
    }
    FileOutputStream to = null;
    try {
        to = new FileOutputStream (toFile);
        byte [] buffer = content.getBytes ();
        int bytes_read = buffer.length;
        to.write (buffer);
    } finally {
        if (to != null) try {
            to.close ();
        } catch (IOException e) {
        }
    }
    return true;
}


-----Function Pair=274=-----==

private static void substitute (File zipfile, File tmpfile, String entry, OutputStream out) throws IOException {
    ZipFile zip = new ZipFile (zipfile);
    ZipOutputStream zos = new ZipOutputStream (out);
    @SuppressWarnings ("unchecked")
    Enumeration < ZipEntry > en = (Enumeration < ZipEntry >) zip.entries ();
    while (en.hasMoreElements ()) {
        ZipEntry ze = en.nextElement ();
        if (! ze.getName ().equals (entry)) {
            zos.putNextEntry (new ZipEntry (ze.getName ()));
            InputStream is = zip.getInputStream (ze);
            copyStream (is, zos);
            is.close ();
        }
    }
    zos.putNextEntry (new ZipEntry (entry));
    InputStream is = new FileInputStream (tmpfile);
    copyStream (is, zos);
    is.close ();
    zos.close ();
}


protected final void addParentDirs (File baseDir, String entry, ZipOutputStream zOut, String prefix, int dirMode) throws IOException {
    if (! doFilesonly) {
        Stack directories = new Stack ();
        int slashPos = entry.length ();
        while ((slashPos = entry.lastIndexOf ('/', slashPos - 1)) != - 1) {
            String dir = entry.substring (0, slashPos + 1);
            if (addedDirs.get (prefix + dir) != null) {
                break;
            }
            directories.push (dir);
        }
        while (! directories.isEmpty ()) {
            String dir = (String) directories.pop ();
            File f = null;
            if (baseDir != null) {
                f = new File (baseDir, dir);
            }
            else {
                f = new File (dir);
            }
            zipDir (f, zOut, prefix + dir, dirMode);
        }
    }
}


-----Function Pair=275=-----==

public static String readImportData (java.io.InputStream is) throws java.io.IOException {
    java.util.zip.ZipInputStream zis;
    zis = new java.util.zip.ZipInputStream (ObfuscatingStream.unobfuscate (is));
    java.io.Reader reader = new java.io.InputStreamReader (zis);
    zis.getNextEntry ();
    StringBuilder ret = new StringBuilder ();
    char [] read = new char [1024];
    int count = reader.read (read);
    while (count > 0) {
        ret.append (read, 0, count);
        count = reader.read (read);
    }
    reader.close ();
    zis.close ();
    return ret.toString ();
}


public String getBudgetHeads (String xmlStr) {
    Element root = newGenXMLGenerator.getRootElementFromXMLDocument (xmlStr);
    Integer libID = new Integer (root.getChildText ("LibraryID"));
    root = new Element ("Response");
    Object [] objLocal = new Object [1];
    try {
        objLocal = ((LocalACC_BUDGET_HEADHome) HomeFactory.getInstance ().getHome ("ACC_BUDGET_HEAD")).findAll (libID).toArray ();
    } catch (FinderException ex) {
    }
    Object [] bheads = new Object [objLocal.length];
    for (int i = 0; i < objLocal.length; i ++) {
        bheads [i] = ((LocalACC_BUDGET_HEAD) objLocal [i]).getBudget_Head ();
    }
    java.util.Arrays.sort (bheads, java.text.Collator.getInstance ());
    for (int i = 0; i < bheads.length; i ++) {
        Element element = new Element ("BudgetHead");
        element.setText (String.valueOf (bheads [i]));
        root.addContent (element);
    }
    return newGenXMLGenerator.buildXMLDocument (root);
}


-----Function Pair=276=-----==

public static void zipFilesTo (Vector < File > fileVector, String baseDir, File destFile) {
    FileOutputStream ops = null;
    ZipOutputStream zos = null;
    int basedirlen = baseDir.length ();
    if (! baseDir.endsWith (File.separator)) basedirlen ++;
    try {
        ops = new FileOutputStream (destFile);
        zos = new ZipOutputStream (ops);
        Iterator < File > iter = fileVector.iterator ();
        while (iter.hasNext ()) {
            File file = iter.next ();
            FileInputStream fis = null;
            try {
                fis = new FileInputStream (file);
                String name = file.getPath ().substring (basedirlen);
                name = name.replace ('\\', '/');
                ZipEntry zi = new ZipEntry (name);
                zos.putNextEntry (zi);
                copystream (fis, zos);
                zos.closeEntry ();
            } catch (FileNotFoundException e) {
                e.printStackTrace ();
            } catch (IOException e) {
                e.printStackTrace ();
            } finally {
                try {
                    if (fis != null) fis.close ();
                } catch (Exception e) {
                }
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (zos != null) zos.close ();
            else if (ops != null) ops.close ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


private void writeReadmeFile () {
    OutputStreamWriter fos = null;
    try {
        fos = new OutputStreamWriter (new FileOutputStream (readmeFile), "UTF-8");
        fos.write ("<html>");
        String head = ITMMProperties.getInstance ().getProperty ("ITMM_README_HEADER");
        fos.write (head);
        fos.write ("<body>");
        fos.write ("<div class = 'normal'>");
        fos.write ("<p class='header1'>Taxonomy Readme</p>");
        fos.write ("<p>This Readme provides information about file structure and files included in the Taxonomy entry point file</p>");
        fos.write ("<p class='header2'>Taxonomy</p>");
        fos.write ("<p>Taxonomy name: " + taxonomy.getName () + "</p>");
        fos.write ("<p>Taxonomy ID: " + taxonomy.getId () + "</p>");
        fos.write ("<p>Taxonomy issue date: " + taxonomy.getIssueDate () + "</p>");
        fos.write ("<p class='header2'>Configuration</p>");
        String entry = "";
        if (clientSession.getTaxonomyOutputTyp ().equals ("instance")) {
            entry = "Entry Point: " + instanceFile.getName ();
        }
        else if (clientSession.getTaxonomyOutputTyp ().equals ("schema")) {
            entry = "Entry Point: " + entrypointFile.getName ();
        }
        fos.write ("<p>" + entry + "</p>");
        fos.write ("<p>Entry Point type: " + clientSession.getTaxonomyOutputTyp () + "</p>");
        fos.write ("<p>File path: " + clientSession.getTaxonomyRefTyp () + "</p>");
        fos.write ("<p class='header2'>Module Selection</p>");
        Iterator keys = clientSession.getClientSelection ().getSelectedModules ().keySet ().iterator ();
        while (keys.hasNext ()) {
            String moduleKey = (String) keys.next ();
            IModule m = (IModule) taxonomy.getModuleByID (moduleKey);
            String modulePath = m.getID ();
            fos.write ("<p>" + modulePath + " (" + m.getDescription () + ")</p>");
            writeReadmeModuleLocation (m.getModuleLocations (), modulePath + "/", fos);
            List ssm = clientSession.getClientSelection ().getSelectedSubModules (moduleKey);
            ISubModule sm;
            for (int i = 0; i < ssm.size (); i ++) {
                sm = (ISubModule) taxonomy.getSubModuleByID (moduleKey, ssm.get (i).toString ());
                String subModulePath = sm.getPath ();
                fos.write ("<p>" + modulePath + subModulePath + " (" + sm.getDescription () + ")</p>");
                writeReadmeModuleLocation (sm.getModuleLocations (), modulePath + subModulePath + "/", fos);
            }
            fos.write ("<p><br/></p>");
        }
        fos.write ("</div></body></html>");
    } catch (IOException e) {
        log.error ("Readme could not be written.\n\r" + e.getMessage ());
        throw new RuntimeException ("Readme could not be written.\n\r" + e.getMessage ());
    } finally {
        if (fos != null) {
            try {
                fos.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
}


-----Function Pair=277=-----==

public static final String decompressFromBase64Str (String base64Str) {
    byte [] compressed = null;
    try {
        compressed = new BASE64Decoder ().decodeBuffer (base64Str);
    } catch (IOException e1) {
        e1.printStackTrace ();
    }
    if (compressed == null) return null;
    ByteArrayOutputStream out = null;
    ByteArrayInputStream in = null;
    ZipInputStream zin = null;
    String decompressed;
    try {
        out = new ByteArrayOutputStream ();
        in = new ByteArrayInputStream (compressed);
        zin = new ZipInputStream (in);
        ZipEntry entry = zin.getNextEntry ();
        byte [] buffer = new byte [1024];
        int offset = - 1;
        while ((offset = zin.read (buffer)) != - 1) {
            out.write (buffer, 0, offset);
        }
        decompressed = out.toString ();
    } catch (IOException e) {
        decompressed = null;
    } finally {
        if (zin != null) {
            try {
                zin.close ();
            } catch (IOException e) {
            }
        }
        if (in != null) {
            try {
                in.close ();
            } catch (IOException e) {
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
    return decompressed;
}


public static int findItemIndex (List < ? extends IItem > listItems, IItem item, int nIdx) {
    if (listItems.get (nIdx) == item) return nIdx;
    String strTitle = item.getTitle ();
    char chTitle = strTitle == null || strTitle.length () == 0 ? '\0' : strTitle.charAt (0);
    for (int i = nIdx + 1; i < listItems.size (); i ++) {
        IItem itemTest = listItems.get (i);
        String strTitleTest = itemTest.getTitle ();
        char chTitleTest = strTitleTest == null || strTitleTest.length () == 0 ? '\0' : strTitleTest.charAt (0);
        if (chTitle != chTitleTest) break;
        if (itemTest == item) return i;
    }
    for (int i = nIdx - 1; i >= 0; i --) {
        IItem itemTest = listItems.get (i);
        String strTitleTest = itemTest.getTitle ();
        char chTitleTest = strTitleTest == null || strTitleTest.length () == 0 ? '\0' : strTitleTest.charAt (0);
        if (chTitle != chTitleTest) break;
        if (itemTest == item) return i;
    }
    for (int i = nIdx + 1; i < listItems.size (); i ++) if (! strTitle.equals (listItems.get (i).getTitle ())) return i;
    return nIdx;
}


-----Function Pair=278=-----==

private byte [] runTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String taskName = urlData.getParameter ("name");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    TaskCommand taskCommand = tasks.get (taskName);
    if (taskCommand != null) {
        System.out.println ("Runnig Task : " + taskName);
        TaskItemThread taskItem = new TaskItemThread (taskCommand, new CommandWaitThread (taskCommand.getCommand ()), null);
        Thread taskThread = new Thread (Thread.currentThread ().getThreadGroup (), taskItem, taskItem.getClass ().getName ());
        taskThread.start ();
    }
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/TaskManagementDataRes\n\n");
    return buff.toString ().getBytes ();
}


public static String get_ssl_page (String s) throws Exception {
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault ();
    SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket ("www.google.com", 443);
    PrintStream outStream = new PrintStream (sslsocket.getOutputStream ());
    outStream.println (s);
    outStream.flush ();
    DataInputStream inStream = new DataInputStream (sslsocket.getInputStream ());
    StringBuffer stb = new StringBuffer ();
    int ch = ' ';
    for (ch = inStream.read (); ch > 0; ch = inStream.read ()) {
        stb.append ((char) ch);
        if (stb.indexOf ("</html>") > - 1 || stb.indexOf ("</HTML>") > - 1) break;
    }
    inStream.close ();
    outStream.close ();
    sslsocket.close ();
    return stb.toString ();
}


-----Function Pair=279=-----==

private byte [] remTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("name");
    tasks.remove (name);
    store.saveTaskList (null);
    return out.getBytes ();
}


private Properties filterProperties (Properties p, String prefix) {
    prefix = prefix + TranslatorConstants.KEY_SEPARATOR;
    Properties result = new PropertiesFile ();
    Iterator i = p.entrySet ().iterator ();
    while (i.hasNext ()) {
        Map.Entry prop = (Map.Entry) i.next ();
        String name = (String) prop.getKey ();
        if (! name.startsWith (prefix)) continue;
        name = name.substring (prefix.length ());
        if (name.indexOf (TranslatorConstants.KEY_SEPARATOR) != - 1) continue;
        String value = (String) prop.getValue ();
        if (value == null || value.trim ().length () == 0) continue;
        result.setProperty (name, value);
    }
    return result;
}


-----Function Pair=280=-----==

public void remove (String fs, FilenameFilter ff, boolean tf) throws Exception {
    File f = new File (fs);
    if (f.getName ().length () < 1) return;
    String [] flist = f.list (ff);
    if (flist == null || flist.length < 1) {
        if (! (f.isDirectory () && ! tf)) f.delete ();
        return;
    }
    for (int i = 0; i < flist.length; i ++) {
        String p = f.getAbsolutePath ();
        if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
        FileUtil.deleteAll (p + flist [i], ff, tf);
    }
    if (f != null) if (! (f.isDirectory () && ! tf)) f.delete ();
}


public void loadBackup (File inFile) {
    Enumeration < ? extends ZipEntry > entries;
    ZipFile zipFile;
    File dbFolder = new File (DB_FOLDER);
    Installer.deleteDirectory (dbFolder);
    dbFolder.mkdir ();
    try {
        zipFile = new ZipFile (inFile);
        entries = zipFile.entries ();
        File output;
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            if (entry.isDirectory ()) {
                continue;
            }
            output = new File (entry.getName ());
            output.getParentFile ().mkdirs ();
            if (! output.exists ()) {
                if (! output.createNewFile ()) {
                    throw new PackerRuntimeException ("Problem with creating file");
                }
            }
            copyInputStream (zipFile.getInputStream (entry), new BufferedOutputStream (new FileOutputStream (output)));
        }
        zipFile.close ();
    } catch (IOException ioe) {
        throw new PackerRuntimeException ("Problem with data import.", ioe);
    }
}


-----Function Pair=281=-----==

protected final void includeClass (String className) throws BuildException {
    String osPath = className.replace ('.', File.separatorChar) + ".class";
    String urlPath = className.replace ('.', '/') + ".class";
    for (int i = 0; i < classpathFileList.length; ++ i) {
        File cpBase = classpathFileList [i];
        if (! cpBase.exists ()) continue;
        if (cpBase.isDirectory ()) {
            File testFile = fileUtils.resolveFile (cpBase, osPath);
            if (testFile.exists ()) {
                FileSet fileSet = new FileSet ();
                fileSet.setDir (cpBase);
                fileSet.setIncludes (osPath);
                super.addFileset (fileSet);
                return;
            }
            continue;
        }
        if (cpBase.isFile ()) {
            if (classpathZipList [i] == null) {
                try {
                    classpathZipList [i] = new ZipFile (cpBase);
                } catch (IOException ioe) {
                    classpathZipList [i] = null;
                    continue;
                }
            }
            if (classpathZipList [i].getEntry (urlPath) != null) {
                ZipFileSet zipFileSet = new ZipFileSet ();
                zipFileSet.setSrc (classpathFileList [i]);
                zipFileSet.setIncludes (urlPath);
                super.addZipfileset (zipFileSet);
                return;
            }
            continue;
        }
    }
    throw new BuildException ("Cannot locate class in classpath: " + className);
}


public void closeEntry () throws IOException {
    def.finish ();
    while (! def.finished ()) deflate ();
    long uncompressed_size = def.getTotalIn ();
    long compressed_size = def.getTotalOut ();
    long ecrc = (crc.getValue ());
    bytes_written += compressed_size;
    if (outSeekable || current.getCrc () == - 1 || current.getCompressedSize () == - 1 || current.getSize () == - 1) {
        current.setCrc (ecrc);
        current.compressedSize = compressed_size;
        current.setSize (uncompressed_size);
    }
    else {
        if (current.getCrc () != ecrc || current.getCompressedSize () != compressed_size || current.getSize () != uncompressed_size) throw new ZipException ("zip entry field incorrect");
    }
    if (outSeekable) {
        long here = bytes_written;
        ((SeekableOutputStream) out).seek (currentStart + 14);
        put4 (ecrc);
        put4 (compressed_size);
        put4 (uncompressed_size);
        ((SeekableOutputStream) out).seek (here);
    }
    else bytes_written += current.writeExtHeader (out);
    crc.reset ();
    def.reset ();
    current.next = chain;
    chain = current;
    current = null;
}


-----Function Pair=282=-----==

private void writeXMLFile (OpProjectSession session, OpBroker broker, XDocumentWriter writer, List < Triple < String, OpBackupMember, String > > toExport) throws IOException {
    writer.writeHeader1_0 ();
    Map < String, String > attributes = new HashMap < String, String > ();
    attributes.put (VERSION, String.valueOf (CURRENT_VERSION_NUMBER));
    int dataVersion = session.getSite ().getDataVersion ();
    attributes.put (SCHEMA_VERSION, String.valueOf (dataVersion));
    logger.info ("Schema Version is: " + dataVersion);
    writer.writeStartElement (OPP_BACKUP, attributes, false);
    attributes.clear ();
    Map < String, OpBackupMember [] > allMembers = exportPrototypes (writer);
    Map systemIdMap = querySystemObjectIdMap (broker);
    if (systemIdMap != null) {
        for (Map.Entry < String, OpPrototype > pe : prototypes.entrySet ()) {
            exportObjects (session, broker, writer, pe.getValue (), allMembers.get (pe.getKey ()), systemIdMap, toExport);
        }
    }
    writer.writeEndElement (OPP_BACKUP);
}


public static void extractFile (File zipFile, String entryName, File destination) throws IOException {
    ZipFile zip = new ZipFile (zipFile);
    try {
        ZipEntry entry = zip.getEntry (entryName);
        if (entry != null) {
            InputStream entryStream = zip.getInputStream (entry);
            try {
                File parent = destination.getParentFile ();
                if (parent != null) {
                    parent.mkdirs ();
                }
                FileOutputStream file = new FileOutputStream (destination);
                try {
                    byte [] data = new byte [BUFFER];
                    int bytesRead;
                    while ((bytesRead = entryStream.read (data)) != - 1) {
                        file.write (data, 0, bytesRead);
                    }
                } finally {
                    file.close ();
                }
            } finally {
                entryStream.close ();
            }
        }
        else {
            throw new IOException (zipFile.getName () + " does not contain: " + entryName);
        }
    } finally {
        zip.close ();
    }
}


-----Function Pair=283=-----==

public static File getFileByExtension (ZipFile zipFile, String extension) throws IOException {
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.getName ().indexOf ("." + extension) != - 1) {
            InputStream in = zipFile.getInputStream (entry);
            File rtn = new File (entry.getName ());
            FileOutputStream out = new FileOutputStream (rtn);
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                out.write (buffer, 0, nNumber);
            }
            in.close ();
            out.close ();
            return rtn;
        }
    }
    return null;
}


public void unzip (File zipFile, File dir) throws IOException {
    ZipFile zip = null;
    File arquivo = null;
    InputStream is = null;
    OutputStream os = null;
    byte [] buffer = new byte [1024];
    try {
        if (! dir.exists ()) {
            dir.mkdirs ();
        }
        if (! dir.exists () || ! dir.isDirectory ()) {
            throw new IOException ("O diretório " + dir.getName () + " não é um diretório válido");
        }
        zip = new ZipFile (zipFile);
        Enumeration e = zip.entries ();
        while (e.hasMoreElements ()) {
            ZipEntry entrada = (ZipEntry) e.nextElement ();
            arquivo = new File (dir, entrada.getName ());
            if (entrada.isDirectory () && ! arquivo.exists ()) {
                arquivo.mkdirs ();
                continue;
            }
            if (! arquivo.getParentFile ().exists ()) {
                arquivo.getParentFile ().mkdirs ();
            }
            try {
                is = zip.getInputStream (entrada);
                os = new FileOutputStream (arquivo);
                int bytesLidos = 0;
                if (is == null) {
                    throw new ZipException ("Erro ao ler a entrada do zip: " + entrada.getName ());
                }
                while ((bytesLidos = is.read (buffer)) > 0) {
                    os.write (buffer, 0, bytesLidos);
                }
            } finally {
                if (is != null) {
                    try {
                        is.close ();
                    } catch (Exception ex) {
                    }
                }
                if (os != null) {
                    try {
                        os.close ();
                    } catch (Exception ex) {
                    }
                }
            }
        }
    } finally {
        if (zip != null) {
            try {
                zip.close ();
            } catch (Exception e) {
            }
        }
    }
}


-----Function Pair=284=-----==

public ZippingRequestImpl (IFileSystemManager source, CMSessionData session, String path, OutputStream toStream, boolean metadata) {
    zip = new ZipOutputStream (toStream);
    this.source = source;
    this.path = path;
    this.metadata = metadata;
    this.session = session;
    name = path;
    if (name.endsWith (SEPARATOR)) {
        name = name.substring (0, name.length () - 1);
    }
    name = name.substring (name.lastIndexOf (SEPARATOR) + 1);
    if (name.trim ().length () == 0) {
        name = session.global.getProject ().getKey ();
        int lastslash = name.lastIndexOf (SEPARATOR);
        if (lastslash > 0) {
            name = name.substring (lastslash + 1);
        }
        int dot = name.lastIndexOf (".");
        if (dot > 0) {
            name = name.substring (0, dot);
        }
    }
    name = name + ".zip";
    generateID ();
}


public static boolean copyFileCover (String srcFileName, String descFileName, boolean coverlay) {
    File srcFile = new File (srcFileName);
    if (! srcFile.exists ()) {
        System.out.println ("复制文件失败，源文件" + srcFileName + "不存在!");
        return false;
    }
    else if (! srcFile.isFile ()) {
        System.out.println ("复制文件失败，" + srcFileName + "不是一个文件!");
        return false;
    }
    File descFile = new File (descFileName);
    if (descFile.exists ()) {
        if (coverlay) {
            System.out.println ("目标文件已存在，准备删除!");
            if (! FileOperateUtils.delFile (descFileName)) {
                System.out.println ("删除目标文件" + descFileName + "失败!");
                return false;
            }
        }
        else {
            System.out.println ("复制文件失败，目标文件" + descFileName + "已存在!");
            return false;
        }
    }
    else {
        if (! descFile.getParentFile ().exists ()) {
            System.out.println ("目标文件所在的目录不存在，创建目录!");
            if (! descFile.getParentFile ().mkdirs ()) {
                System.out.println ("创建目标文件所在的目录失败!");
                return false;
            }
        }
    }
    int readByte = 0;
    InputStream ins = null;
    OutputStream outs = null;
    try {
        ins = new FileInputStream (srcFile);
        outs = new FileOutputStream (descFile);
        byte [] buf = new byte [1024];
        while ((readByte = ins.read (buf)) != - 1) {
            outs.write (buf, 0, readByte);
        }
        System.out.println ("复制单个文件" + srcFileName + "到" + descFileName + "成功!");
        return true;
    } catch (Exception e) {
        System.out.println ("复制文件失败：" + e.getMessage ());
        return false;
    } finally {
        if (outs != null) {
            try {
                outs.close ();
            } catch (IOException oute) {
                oute.printStackTrace ();
            }
        }
        if (ins != null) {
            try {
                ins.close ();
            } catch (IOException ine) {
                ine.printStackTrace ();
            }
        }
    }
}


-----Function Pair=285=-----==

protected void dispatchDone (HttpServletRequest request, HttpServletResponse response, LongLastingOperationServlet servlet) {
    if (exception != null) {
        servlet.error (request, response, new ServletException (exception.getMessage (), exception));
        return;
    }
    try {
        response.setContentType ("application/zip");
        response.setHeader ("Expires", "0");
        response.setHeader ("Pragma", "no-cache");
        response.setHeader ("Keep-Alive", "timeout=15, max=100");
        response.setHeader ("Connection", "Keep-Alive");
        response.setHeader ("Content-Disposition", "attachment" + ";filename=HTMLExportOf" + virtualWiki + ".zip;");
        FileInputStream in = new FileInputStream (tempFile);
        response.setContentLength ((int) tempFile.length ());
        OutputStream out = response.getOutputStream ();
        int bytesRead = 0;
        byte byteArray [] = new byte [4096];
        while (in.available () > 0) {
            bytesRead = in.read (byteArray, 0, Math.min (4096, in.available ()));
            out.write (byteArray, 0, bytesRead);
        }
        out.flush ();
        out.close ();
        tempFile.delete ();
    } catch (Exception e) {
        logger.fatal ("Exception", e);
        servlet.error (request, response, new ServletException (e.getMessage (), e));
    }
}


private String getCapTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = - 1;
    if (item != null) type = item.getCapType ();
    if (type == - 1) {
        typeList.append ("<label><input name='captype' type='radio' value='-1' checked>AutoSelect</label><br>\n");
    }
    else {
        typeList.append ("<label><input name='captype' type='radio' value='-1'>AutoSelect</label><br>\n");
    }
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int x = 0; x < capabilities.size (); x ++) {
        CaptureCapability capability = capabilities.get (x);
        typeList.append ("<label><input name='captype' type='radio' value='" + capability.getTypeID () + "' ");
        if (type == capability.getTypeID ()) typeList.append ("checked");
        typeList.append (">" + capability.getName () + "</label><br>\n");
    }
    return typeList.toString ();
}


-----Function Pair=286=-----==

public static float [] [] [] fetchFloatFloatArrays (File [] files) {
    int i = 0;
    try {
        int num = files.length;
        float [] [] [] f = new float [num] [] [];
        for (; i < num; i ++) {
            f [i] = (float [] []) IO.fetchObject (files [i]);
        }
        return f;
    } catch (Exception e) {
        System.out.println ("\nError: One of your 'xxx.cela' files does not appear" + " to be a serialized java float[][] array?! -> " + files [i] + "\n");
        System.exit (0);
    }
    return null;
}


private String makeUTF8Filename (String filename) {
    try {
        byte [] bytes = filename.getBytes (DEFAULT_ENCODING);
        StringBuffer result = new StringBuffer ();
        for (byte aByte : bytes) {
            if (aByte >= WHITESPACE_ASCII_CODE) {
                result.append ((char) aByte);
            }
            else {
                result.append ("%").append (Long.toHexString (aByte < 0 ? (long) Math.pow (2, Byte.SIZE) + aByte : aByte));
            }
        }
        return result.toString ();
    } catch (Exception e) {
        logger.error ("Error during converting file name to UTF-8 -> using source file name", e);
        return filename;
    }
}


-----Function Pair=287=-----==

protected void exportProjects (Element parent) throws CmsImportExportException, SAXException {
    try {
        I_CmsReport report = getReport ();
        List allProjects = OpenCms.getOrgUnitManager ().getAllManageableProjects (getCms (), "", true);
        for (int i = 0; i < allProjects.size (); i ++) {
            CmsProject project = (CmsProject) allProjects.get (i);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_SUCCESSION_2, String.valueOf (i + 1), String.valueOf (allProjects.size ())), I_CmsReport.FORMAT_NOTE);
            report.print (Messages.get ().container (Messages.RPT_EXPORT_PROJECT_0), I_CmsReport.FORMAT_NOTE);
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_ARGUMENT_1, project.getName ()));
            report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
            exportProject (parent, project);
            report.println (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_OK_0), I_CmsReport.FORMAT_OK);
        }
    } catch (CmsImportExportException e) {
        throw e;
    } catch (CmsException e) {
        if (LOG.isDebugEnabled ()) {
            LOG.debug (e.getLocalizedMessage (), e);
        }
        throw new CmsImportExportException (e.getMessageContainer (), e);
    }
}


public void execute () throws BuildException {
    try {
        Integer.parseInt (version);
    } catch (NumberFormatException e) {
        throw new BuildException ("Error: 'version' property must only contain digits");
    }
    if (destfile == null) {
        throw new BuildException ("Error: 'destfile' property must be set.");
    }
    if (modulename == null) {
        modulename = new File (destfile).getName ().toUpperCase ();
        if (modulename.endsWith (".MAR")) {
            modulename = modulename.substring (0, modulename.length () - 4);
        }
    }
    else {
        modulename = modulename.toUpperCase ();
    }
    if (parts.size () == 0) {
        throw new BuildException ("Error: at least on 'part' task must exists in a mar configuration.");
    }
    String partsString = parts.get (0).getName ();
    for (int i = 1; i < parts.size (); i ++) {
        partsString += "," + parts.get (i).getName ();
    }
    if (verbose) {
        System.out.println ("Generating Module Archive : " + modulename);
        System.out.println ("  Version                 : " + version);
        System.out.println ("  Default Description     : " + (description == null ? "" : description));
        System.out.println ("  Destination             : " + destfile);
        System.out.println ("  Parts                   : " + partsString);
        System.out.println ("");
    }
    Properties desc = new Properties ();
    desc.setProperty (MARFileParser.MARDESCRIPTOR_VERSION, version);
    if (description != null) {
        desc.setProperty (MARFileParser.MARDESCRIPTOR_DEFAULTDESCRIPTION, description);
    }
    desc.setProperty (MARFileParser.MARDESCRIPTOR_MODULENAME, modulename);
    desc.setProperty (MARFileParser.MARDESCRIPTOR_PARTS, partsString);
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (destfile));
        out.putNextEntry (new ZipEntry (MARFileParser.MARDESCRIPTOR_PATH));
        desc.store (out, "MAR Descriptor generated by ANT task.");
        out.closeEntry ();
        for (PartAntTask part : parts) {
            zipFilesInPart (out, part);
        }
        out.close ();
    } catch (IOException e) {
        throw new BuildException ("Error: IO Exception when generated MAR file : " + e.getMessage ());
    }
    super.execute ();
}


-----Function Pair=288=-----==

public void setDataSheet (int sheetNumber, DataModel dataModel) {
    if (sheetNumber < 1) {
        throw new IllegalArgumentException ("sheetNumber must be >= 1, is " + sheetNumber);
    }
    Document worksheet;
    try {
        SAXReader reader = new SAXReader ();
        worksheet = reader.read (this.getClass ().getResourceAsStream (TEMPLATE_RESOURCE));
    } catch (DocumentException e) {
        throw new RuntimeException ("Unexpected DocumentExcpetion while reading template " + TEMPLATE_RESOURCE, e);
    }
    Element root = worksheet.getRootElement ();
    Element sheetData = root.element ("sheetData");
    Element rowElement = sheetData.addElement ("row");
    for (String columnName : dataModel.getColumnNames ()) {
        addCell (rowElement, columnName);
    }
    for (Iterator < DataModel.RowObject > iter = dataModel.iterator (); iter.hasNext ();) {
        DataModel.RowObject rowObject = iter.next ();
        rowElement = sheetData.addElement ("row");
        for (int i = 0; i < rowObject.getColumnCount (); i ++) {
            addCell (rowElement, rowObject.getValueAt (i));
        }
    }
    String sheetName = "xl/worksheets/sheet" + sheetNumber + ".xml";
    worksheetMap.put (sheetName, worksheet);
}


public static String getFormattedTimeString (long milliSec, String separator, String dateSeparator, String timeSeparator) {
    Calendar cal = Calendar.getInstance ();
    cal.setTimeInMillis (milliSec);
    int year = cal.get (Calendar.YEAR);
    int month = cal.get (Calendar.MONTH) + 1;
    int date = cal.get (Calendar.DATE);
    int hour = cal.get (Calendar.HOUR_OF_DAY);
    int min = cal.get (Calendar.MINUTE);
    int sec = cal.get (Calendar.SECOND);
    Formatter fmt = new Formatter ();
    if ((separator == null) || (separator.length () == 0)) {
        separator = "_";
    }
    if ((dateSeparator == null) || (dateSeparator.length () == 0)) {
        dateSeparator = ".";
    }
    if ((timeSeparator == null) || (timeSeparator.length () == 0)) {
        timeSeparator = ".";
    }
    final String formatStr = "%4d" + dateSeparator + "%02d" + dateSeparator + "%02d" + separator + "%02d" + timeSeparator + "%02d" + timeSeparator + "%02d";
    fmt.format (formatStr, year, month, date, hour, min, sec);
    return fmt.toString ();
}


-----Function Pair=289=-----==

public boolean copy (String fromFileName, String toFileName, int type) throws IOException {
    File fromFile = new File (fromFileName);
    File toFile = new File (toFileName);
    if (! fromFile.exists ()) {
        return false;
    }
    if (! fromFile.isFile ()) {
        File newFolder = new File (toFile, fromFile.getName ());
        int temp = 0;
        if (newFolder.getPath ().equals (fromFile.getPath ())) {
            while (newFolder.exists ()) {
                newFolder = new File (toFile, "Copy " + temp + " of " + fromFile.getName ());
                temp ++;
            }
        }
        else {
            if (newFolder.exists ()) {
                if (type == AConf.ACTIVE) {
                    int response;
                    response = JOptionPane.showConfirmDialog (null, "Overwrite existing folder " + newFolder.getName ());
                    if (response != JOptionPane.YES_OPTION) {
                        return false;
                    }
                    else {
                        deleteFile (newFolder.getPath (), AConf.BACKGROUND);
                    }
                }
                else {
                    deleteFile (newFolder.getPath (), AConf.BACKGROUND);
                }
            }
        }
        newFolder.mkdirs ();
        for (int i = 0; i < fromFile.listFiles ().length; i ++) {
            copy (fromFile.listFiles () [i].getPath (), newFolder.getPath (), type);
        }
        return true;
    }
    if (! fromFile.canRead ()) {
        return false;
    }
    if (toFile.isDirectory ()) {
        toFile = new File (toFile, fromFile.getName ());
    }
    if (toFile.exists ()) {
        if (! toFile.getPath ().equals (fromFile.getPath ())) {
            if (! toFile.canWrite ()) {
                return false;
            }
            if (type == AConf.ACTIVE) {
                int response;
                response = JOptionPane.showConfirmDialog (null, "Overwrite existing file " + toFile.getName ());
                if (response != JOptionPane.YES_OPTION) {
                    return false;
                }
            }
        }
        else {
            int n = 0;
            while (toFile.exists ()) {
                toFile = new File (toFile.getParent (), "Copy " + n + " of " + fromFile.getName ());
                n ++;
            }
        }
    }
    else {
        String parent = toFile.getParent ();
        if (parent == null) {
            parent = System.getProperty ("user.dir");
        }
        File dir = new File (parent);
        if (! dir.exists ()) {
            return false;
        }
        if (dir.isFile ()) {
            return false;
        }
        if (! dir.canWrite ()) {
            return false;
        }
    }
    FileInputStream from = null;
    FileOutputStream to = null;
    try {
        from = new FileInputStream (fromFile);
        to = new FileOutputStream (toFile);
        byte [] buffer = new byte [4096];
        int bytesRead;
        while ((bytesRead = from.read (buffer)) != - 1) {
            to.write (buffer, 0, bytesRead);
        }
        if (type == AConf.ACTIVE) {
            _form.processForm._nFiles ++;
        }
        _form.processForm.repaint ();
        return true;
    } finally {
        if (from != null) {
            try {
                from.close ();
            } catch (IOException e) {
            }
        }
        if (to != null) {
            try {
                to.close ();
            } catch (IOException e) {
            }
        }
    }
}


private String getSystemInfo (HTTPurl urlData) {
    StringBuffer content = new StringBuffer ();
    content.append ("<table class='systemtable'>");
    content.append ("<tr><td colspan='2' class='systemheading'>System Info</td></tr>");
    content.append ("<tr><td class='systemkey'>Current Time</td><td class='systemdata'>" + dtf.format (new Date ()) + "</td></tr>\n");
    Runtime r = Runtime.getRuntime ();
    long total = r.totalMemory ();
    long free = r.freeMemory ();
    long freePercentage = (long) (((double) free / (double) total) * 100);
    content.append ("<tr><td class='systemkey'>Memory</td><td class='systemdata'>" + freePercentage + "% Free</td></tr>\n");
    DllWrapper capEng = new DllWrapper ();
    NumberFormat nf = NumberFormat.getNumberInstance ();
    content.append ("<tr><td class='systemkey'>Capture Paths</td><td class='systemdata' nowrap>");
    String [] paths = store.getCapturePaths ();
    for (int x = 0; x < paths.length; x ++) {
        String fullPath = new File (paths [x]).getAbsolutePath ();
        long freeSpace = capEng.getFreeSpace (fullPath);
        content.append (fullPath);
        if (freeSpace == 0) {
            content.append (" (N/A)");
        }
        else {
            content.append (" (" + nf.format ((freeSpace / (1024 * 1024))) + " MB Free)");
        }
        if (x != paths.length - 1) content.append ("<br>");
    }
    content.append ("</td></tr>\n");
    content.append ("<tr><td class='systemkey'>Channels Loaded</td><td class='systemdata'>" + store.numberOfChannels ());
    content.append ("</td></tr>\n");
    File cap = new File (store.getProperty ("path.httproot"));
    String fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Httpd Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    cap = new File (store.getProperty ("path.data"));
    fullPath = cap.getAbsolutePath ();
    content.append ("<tr><td class='systemkey'>Data Path</td><td class='systemdata'>" + fullPath + "</td></tr>\n");
    content.append ("<tr><td class='systemkey'>HTTP Server Version</td><td class='systemdata'>" + store.getVersion () + "</td></tr>\n");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    content.append ("<tr><td class='systemkey'>Number of Devices Selected</td><td class='systemdata'>" + devList.getDeviceCount () + "</td></tr>\n");
    content.append ("</table>");
    return content.toString ();
}


-----Function Pair=290=-----==

protected void createTable (String name, String [] entries) {
    if (! tableExists (name)) {
        Statement stmt = null;
        try {
            Connection conn = getConnectionWrapper ().getConnection ();
            stmt = conn.createStatement ();
            String sql = "CREATE TABLE " + name + " (";
            for (int i = 0; i < entries.length; i ++) {
                sql += entries [i];
                if (i < entries.length - 1) sql += ", ";
                else sql += ")";
            }
            stmt.executeUpdate (sql);
            conn.commit ();
        } catch (SQLException e) {
            if (logger.isLoggable (Logger.SEVERE)) logger.log (Logger.SEVERE, "Error creating table '" + name + "'", e);
        } finally {
            if (stmt != null) {
                try {
                    stmt.close ();
                } catch (SQLException see) {
                    see.printStackTrace ();
                }
            }
        }
    }
}


static boolean logIn (String user, String pass) throws XmlRpcException, XmlRpcFault, TimeoutException, InterruptedException {
    try {
        if (client == null) {
            client = new XmlRpcClient ("http://www.opensubtitles.org/xml-rpc", false);
        }
    } catch (MalformedURLException e) {
        e.printStackTrace ();
    }
    Logging.logger.fine (Bundles.subgetBundle.getString ("Logging_in_to_opensubtitles.org..."));
    XmlRpcStruct struct = (XmlRpcStruct) client.invoke ("LogIn", new String [] {user, pass, "", Global.USER_AGENT});
    if (struct.getString ("status").indexOf ("401") == 0) {
        Logging.logger.severe (Bundles.subgetBundle.getString ("Login_failed,_wrong_user/password."));
        return false;
    }
    else {
        Logging.logger.fine (Bundles.subgetBundle.getString ("Login_OK"));
        token = struct.getString ("token");
        return true;
    }
}


-----Function Pair=291=-----==

String [] getNamesStartingWith (String starting) {
    Vector < String > starts = new Vector < String > ();
    for (int x = 0; x < channelMap.size (); x ++) {
        String [] map = (String []) channelMap.get (x);
        HashMap < String, GuideItem > progs = (HashMap < String, GuideItem >) progList.get (map [1]);
        if (progs != null) {
            GuideItem [] items = (GuideItem []) progs.values ().toArray (new GuideItem [0]);
            for (int y = 0; y < items.length; y ++) {
                if (items [y].getName () != null && items [y].getName ().length () > 1) {
                    if (items [y].getName ().toUpperCase ().startsWith (starting.toUpperCase ())) {
                        if (! starts.contains (items [y].getName ())) {
                            starts.add (items [y].getName ());
                        }
                    }
                }
            }
        }
    }
    String [] result = (String []) starts.toArray (new String [0]);
    Arrays.sort (result);
    return result;
}


private static void write (Document document, PrintWriter writer) {
    try {
        TransformerFactory transFactory = TransformerFactory.newInstance ();
        Transformer transformer = transFactory.newTransformer ();
        Properties props = new Properties ();
        props.put ("indent", "yes");
        transformer.setOutputProperties (props);
        DOMSource source = new DOMSource (document);
        StreamResult result = new StreamResult (writer);
        transformer.transform (source, result);
    } catch (TransformerConfigurationException e) {
        System.err.println ("Error:" + e);
    } catch (TransformerException e) {
        System.err.println ("Error:" + e);
    }
}


-----Function Pair=292=-----==

public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


-----Function Pair=293=-----==

private Class < ? > findClassNonDalvik (String name) throws ClassNotFoundException {
    String pathName = CLASS_PATH + name + ".class";
    File path = new File (pathName);
    RandomAccessFile raf;
    try {
        raf = new RandomAccessFile (path, "r");
    } catch (FileNotFoundException fnfe) {
        throw new ClassNotFoundException ("Not found: " + pathName);
    }
    byte [] fileData;
    try {
        fileData = new byte [(int) raf.length ()];
        raf.readFully (fileData);
    } catch (IOException ioe) {
        throw new ClassNotFoundException ("Read error: " + pathName);
    } finally {
        try {
            raf.close ();
        } catch (IOException ioe) {
        }
    }
    try {
        return defineClass (name, fileData, 0, fileData.length);
    } catch (Throwable th) {
        throw new ClassNotFoundException ("defineClass failed", th);
    }
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=294=-----==

public static String downloadWebpage2 (String address) throws MalformedURLException, IOException {
    URL url = new URL (address);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
    HttpURLConnection.setFollowRedirects (true);
    String encoding = conn.getContentEncoding ();
    InputStream is = null;
    if (encoding != null && encoding.equalsIgnoreCase ("gzip")) {
        is = new GZIPInputStream (conn.getInputStream ());
    }
    else if (encoding != null && encoding.equalsIgnoreCase ("deflate")) {
        is = new InflaterInputStream (conn.getInputStream ());
    }
    else {
        is = conn.getInputStream ();
    }
    BufferedReader br = new BufferedReader (new InputStreamReader (is));
    String line;
    String page = "";
    while ((line = br.readLine ()) != null) {
        page += line + "\n";
    }
    br.close ();
    return page;
}


void run (String className, String [] args, boolean background) {
    if (! background) {
        try {
            Class cls = Class.forName (className);
            Class [] argClses = {String [].class};
            Method mainMethod = cls.getMethod ("main", argClses);
            Object [] argObjs = {args};
            mainMethod.invoke (null, argObjs);
        } catch (InvocationTargetException ite) {
            ite.getTargetException ().printStackTrace ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    else {
        try {
            BackgroundThread t = new BackgroundThread (this, className, args);
            t.start ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=295=-----==

public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test137 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    reader.setSkipEmptyRecords (false);
    Assert.assertFalse (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=296=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=297=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=298=-----==

public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=299=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


-----Function Pair=300=-----==

public void download (FileShareFile [] files) {
    for (FileShareFile download : files) {
        Load load = new Load ();
        Load loadRemove = null;
        for (Load cload : lbDownloads.getLoads ()) {
            if (cload.getFilename ().equals (download.getFilename ())) {
                loadRemove = cload;
                break;
            }
        }
        load.setFilename (download.getFilename ());
        load.setDownload (true);
        File targetFile = new File (fileDownloads.getAbsolutePath () + "/" + getFileTitle (load));
        if (targetFile.exists ()) targetFile.delete ();
        if (loadRemove != null) {
            loadRemove.setFinished (true);
            lbDownloads.removeLoad (loadRemove);
        }
        downloads.add (load);
        lbDownloads.addLoad (load);
        requestDownload (download.getFilename (), 0);
    }
    saveLoads ();
    tabbedPane.setSelectedIndex (1);
    tbpTransfers.setSelectedIndex (0);
}


public void mousePressed (MouseEvent e) {
    isSeekPressed = true;
    SliderUI sliderUI = seekSlider.getUI ();
    if (seekSlider.isEnabled () && sliderUI instanceof BasicSliderUI) {
        BasicSliderUI basicSliderUI = (BasicSliderUI) sliderUI;
        if (seekSlider.getOrientation () == JSlider.HORIZONTAL) {
            seekSlider.setValue (basicSliderUI.valueForXPosition (e.getX ()));
        }
        else {
            seekSlider.setValue (basicSliderUI.valueForYPosition (e.getY ()));
        }
        PlaylistItem pli = playlist.getCursor ();
        if (pli != null) {
            oldSeekValue = seekSlider.getValue ();
            updateTime (pli, oldSeekValue);
        }
    }
}


-----Function Pair=301=-----==

private void drawTree (Node node, PGraphics canvas) {
    if (root == null) return;
    if (node.isHidden ()) return;
    boolean isInternal = ! node.isLeaf ();
    if (node.getParent () == null) {
        node.setSliderCollapsed (false);
    }
    else if (collapseMode.equals ("Root")) {
        if (node.depth () / rootdepth <= collapsedLevel) {
            node.setSliderCollapsed (true);
        }
        else node.setSliderCollapsed (false);
    }
    else if (collapseMode.equals ("Parent")) {
        if (node.depth () / node.getParent ().depth () <= collapsedLevel) {
            node.setSliderCollapsed (true);
        }
        else node.setSliderCollapsed (false);
    }
    if (isInternal) {
        if (node.isCollapsed () && ! treeLayout.equals ("Polar")) {
            drawWedge (node, canvas);
        }
        else {
            drawBranches (node, canvas);
        }
    }
    if ((isInternal && ! node.isCollapsed ()) || (node.isCollapsed () && isInternal && treeLayout.equals ("Polar"))) {
        for (int i = 0; i < node.nodes.size (); i ++) {
            Node child = node.nodes.get (i);
            drawTree (child, canvas);
        }
    }
    drawNode (node, canvas);
    if (node.getDrawPie ()) {
        double x = node.getXOffset ();
        double y = node.getYOffset ();
        if (treeLayout.equals ("Radial")) {
            x = node.getRXOffset ();
            y = node.getRYOffset ();
        }
        else if (treeLayout.equals ("Polar")) {
            x = node.getROffset () * Math.cos (node.getTOffset ());
            y = node.getROffset () * Math.sin (node.getTOffset ());
        }
        PieChart pie = new PieChart ((int) Math.round (toScreenX (x)), (int) Math.round (toScreenY (y)), pieChartRadius, node.getGroupBranchFraction (), node.getGroupBranchColor ());
        drawPieChart (pie, canvas);
    }
}


private void performSkeletonAnalysis () {
    ProjectManipulation projectFrame = getSelectedProjectFrame ();
    if (projectFrame == null) {
        showNoProjectSelectedMessage ();
        return;
    }
    Project project = projectFrame.getProjectWindow ().getProject ();
    JFileChooser fileChooser = new JFileChooser ();
    fileChooser.setFileFilter (new FileNameExtensionFilter (Messages.getString ("GuiController.37"), "txt"));
    if (JFileChooser.APPROVE_OPTION != fileChooser.showSaveDialog (ossobookFrame)) {
        return;
    }
    String path = fileChooser.getSelectedFile ().getAbsolutePath ();
    if (! path.endsWith (".txt")) {
        path += ".txt";
    }
    File f = new File (path);
    String result = JOptionPane.showInputDialog (ossobookFrame.getDesktop (), Messages.getString ("MainMenuBar.88"), "26");
    if (result == null) {
        return;
    }
    else if (result.length () == 0) {
        showErrorDialog (Messages.getString ("GuiController.40"));
        return;
    }
    int tiercode;
    try {
        tiercode = Integer.parseInt (result);
    } catch (NumberFormatException e) {
        showErrorDialog (Messages.getString ("GuiController.41"));
        return;
    }
    result = JOptionPane.showInputDialog (ossobookFrame.getDesktop (), Messages.getString ("MainMenuBar.90"), "fK,phase1,phase2,phase3,phase4");
    if (result == null) {
        return;
    }
    try {
        CSVExport export = new CSVExport (projectFrame.getProjectWindow ().getManager ().getConnection ());
        export.exportSkelettListe (f, project, tiercode, result);
    } catch (Exception e) {
        showErrorDialog (Messages.getString ("GuiController.42"));
    }
}


-----Function Pair=302=-----==

private void createPopupMenu () {
    popup = new JPopupMenu ();
    JMenuItem close = new JMenuItem ("Close Screenshot");
    close.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            dispose ();
        }
    }
    );
    popup.add (close);
    JMenuItem view = new JMenuItem ("View in External Program");
    view.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            launchLocalFile ();
            dispose ();
        }
    }
    );
    popup.add (view);
    JMenuItem delete = new JMenuItem ("Delete Screenshot");
    delete.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            deleteImage ();
            dispose ();
        }
    }
    );
    popup.add (delete);
    JMenuItem useAsIcon = new JMenuItem ("Use Screenshot as Application Icon");
    useAsIcon.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            ApplicationBean di = MainWindow.bl.removeGame ((String) Main.n.applicationList.getSelectedValue ());
            di.setIcon (getCurrentFile ().getAbsolutePath ());
            MainWindow.bl.addGame (di);
            dispose ();
        }
    }
    );
    popup.add (useAsIcon);
}


private static void loadSavedIPs () {
    try {
        FileReader fr = new FileReader (new File (FileModule.SAVED_IP_LOCATION));
        BufferedReader br = new BufferedReader (fr);
        String line;
        while ((line = br.readLine ()) != null) {
            try {
                SavedIPInfo sip = new SavedIPInfo ();
                String [] data = line.split (",");
                sip.setIp (data [0]);
                sip.setName (data [1]);
                sip.setPort (Integer.parseInt (data [2]));
                savedIPs.put (sip.getIp (), sip);
            } catch (Exception e) {
            }
        }
        br.close ();
        fr.close ();
    } catch (IOException e) {
    }
}


-----Function Pair=303=-----==

public JButton buttonLink (String url, String embeddingtext, String linktext, String followtext, Font smallerfont) throws URISyntaxException {
    final URI uri = new URI (url);
    JButton button = new JButton ();
    button.setName (url);
    button.setText ("<HTML>" + embeddingtext + " <FONT color=\"#000099\"><U>" + linktext + "</U></FONT>" + followtext + "</HTML>");
    button.setHorizontalAlignment (SwingConstants.LEFT);
    button.setFont (smallerfont);
    button.setForeground (Color.red);
    button.setToolTipText (uri.toString ());
    button.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            open (uri);
        }
    }
    );
    return button;
}


private void downloadBoards (final Folder targetFolder) {
    logger.info ("adding boards");
    int [] selectedRows = boardsTable.getSelectedRows ();
    if (selectedRows.length == 0) {
        boardsTable.selectAll ();
        selectedRows = boardsTable.getSelectedRows ();
        if (selectedRows.length == 0) {
            return;
        }
    }
    final AttachmentList < BoardAttachment > boardAttachmentList = selectedMessage.getAttachmentsOfTypeBoard ();
    for (final int element : selectedRows) {
        final Board fbo = boardAttachmentList.get (element).getBoardObj ();
        final String boardName = fbo.getName ();
        final Board board = mainFrame.getFrostMessageTab ().getTofTreeModel ().getBoardByName (boardName);
        if (board != null) {
            if (JOptionPane.showConfirmDialog (this, "You already have a board named " + boardName + ".\n" + "Are you sure you want to add this one over it?", "Board already exists", JOptionPane.YES_NO_OPTION) != 0) {
                continue;
            }
            else {
                board.setPublicKey (fbo.getPublicKey ());
                board.setPrivateKey (fbo.getPrivateKey ());
                mainFrame.updateTofTree (board);
            }
        }
        else {
            if (targetFolder == null) {
                mainFrame.getFrostMessageTab ().getTofTreeModel ().addNodeToTree (fbo);
            }
            else {
                mainFrame.getFrostMessageTab ().getTofTreeModel ().addNodeToTree (fbo, targetFolder);
            }
        }
    }
}


-----Function Pair=304=-----==

public String getToolTipText (MouseEvent event) {
    Figure f = getFigureAt (event.getX (), event.getY ());
    if (f == null) return null;
    int i = (int) (((header.length - 1) / (double) drawingArea.getWidth ()) * event.getX ());
    if (i >= header.length) return f.page.getLocalName ();
    StringBuilder b = new StringBuilder ("<html><body>");
    b.append ("<b>").append (XMLUtilities.escape (f.page.getLocalName ())).append ("</b>");
    b.append ("<ul>");
    b.append ("<li>").append (XMLUtilities.escape (header [i])).append ("</li>");
    b.append ("<li>Revisions: ").append (f.revisions [i]).append ("</li>");
    b.append ("<li>Sizes: ").append (f.sizes [i]).append ("</li>");
    b.append ("</ul>");
    b.append ("</body></html>");
    return b.toString ();
}


public static void launchWebBrowser (javax.swing.event.HyperlinkEvent evt) {
    if (HyperlinkEvent.EventType.ACTIVATED.equals (evt.getEventType ())) {
        URL url = evt.getURL ();
        if (Desktop.isDesktopSupported ()) {
            final Desktop desktop = Desktop.getDesktop ();
            if (desktop.isSupported (Desktop.Action.BROWSE)) {
                if (url == null) {
                    String string = "http://" + evt.getDescription ();
                    try {
                        url = new URL (string);
                    } catch (MalformedURLException ex) {
                        return;
                    }
                }
                try {
                    desktop.browse (url.toURI ());
                } catch (URISyntaxException ex) {
                } catch (IOException ex) {
                }
            }
        }
    }
}


-----Function Pair=305=-----==

public String guiEditGroupComments (ApplicationType app, GroupType group) {
    String id = group.getId ();
    CommentEditDialog dialog = null;
    try {
        ApplicationType tmpApp = ApplicationType.Factory.newInstance ();
        tmpApp.set (app);
        GroupType tmpGroup = super.getItem (tmpApp.getGroups ().getGroupList (), group.getId ());
        CommentRefs refs = (tmpGroup.isSetCommentRefs () == true) ? tmpGroup.getCommentRefs () : tmpGroup.addNewCommentRefs ();
        dialog = new CommentEditDialog (MetaManager.getMainWindow (), tmpApp, tmpGroup, refs);
        dialog.setVisible (true);
        if (dialog.getDataChangedFlag () == true) {
            logger.debug ("Saving changes to comments and recommendation");
            super.markModified (tmpGroup);
            app.set (tmpApp);
            MetaManager.getMainWindow ().updateApplication (app);
        }
    } catch (Exception ex) {
        logger.warn ("guiEditGroupComments exception", ex);
    }
    return id;
}


protected JButton makeNavigationButton (String imageName, String actionCommand, String toolTipText, String altText) {
    String imgLocation = "/icons/" + imageName;
    URL imageURL = FaksimileViewer.class.getResource (imgLocation);
    JButton button = new JButton ();
    button.setActionCommand (actionCommand);
    button.setToolTipText (toolTipText);
    button.addActionListener (this);
    if (imageURL != null) {
        button.setIcon (new ImageIcon (imageURL, altText));
    }
    else {
        button.setText (altText);
        System.err.println ("Resource not found: " + imgLocation);
    }
    return button;
}


-----Function Pair=306=-----==

public static String toString (int [] array, int offset, int length, boolean hex) {
    if (array == null) return "<null>";
    else {
        int limit = offset + length;
        StringBuffer buf = new StringBuffer ("[");
        for (int i = offset; i < limit; i ++) {
            if (i != 0) buf.append (" ");
            if (hex) {
                buf.append (Integer.toHexString (array [i]));
            }
            else {
                buf.append (array [i]);
            }
        }
        buf.append ("]");
        return buf.toString ();
    }
}


public void add (long value) {
    if ((values instanceof byte [] || values instanceof short [] || values instanceof int []) && value > Integer.MAX_VALUE) {
        long [] la = new long [Array.getLength (values)];
        for (int i = 0; i < size; i ++) {
            la [i] = Array.getLong (values, i);
        }
        values = la;
    }
    else if ((values instanceof byte [] || values instanceof short []) && value > Short.MAX_VALUE) {
        int [] ia = new int [Array.getLength (values)];
        for (int i = 0; i < size; i ++) {
            ia [i] = Array.getInt (values, i);
        }
        values = ia;
    }
    else if (values instanceof byte [] && value > Byte.MAX_VALUE) {
        short [] sa = new short [Array.getLength (values)];
        for (int i = 0; i < size; i ++) {
            sa [i] = Array.getShort (values, i);
        }
        values = sa;
    }
    if (Array.getLength (values) == size) {
        values = extendArray (values);
    }
    if (values instanceof long []) {
        ((long []) values) [size] = value;
    }
    else if (values instanceof int []) {
        ((int []) values) [size] = (int) value;
    }
    else if (values instanceof short []) {
        ((short []) values) [size] = (short) value;
    }
    else {
        ((byte []) values) [size] = (byte) value;
    }
    size ++;
}


-----Function Pair=307=-----==

public static final long [] trunc (long [] ary, int idx) {
    if (null == ary || 0 > idx) return ary;
    else {
        int len = ary.length;
        if (idx >= len) return ary;
        else if (0 == idx) {
            int nlen = (len - 1);
            long [] copy = new long [nlen];
            System.arraycopy (ary, 1, copy, 0, nlen);
            return copy;
        }
        else {
            int nlen = (len - 1);
            long [] copy = new long [nlen];
            System.arraycopy (ary, 0, copy, 0, (idx));
            System.arraycopy (ary, (idx + 1), copy, (idx), (nlen - idx));
            return copy;
        }
    }
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=308=-----==

public static < T, T2 extends T > T [] commonElements (T [] array1, T2 [] array2) {
    int count = 0;
    if (array1 == null && array2 == null) return null;
    else if (array2 == null) return (T []) Array.newInstance (array1.getClass ().getComponentType (), 0);
    else if (array1 == null) return (T []) Array.newInstance (array2.getClass ().getComponentType (), 0);
    int i, j;
    for (i = 0; i < array1.length; i ++) for (j = 0; j < array2.length; j ++) if (equals (array1 [i], array2 [j])) {
        count ++;
        break;
    }
    T [] ret = (T []) Array.newInstance (array1.getClass ().getComponentType (), count);
    count = 0;
    for (i = 0; i < array1.length; i ++) for (j = 0; j < array2.length; j ++) if (equals (array1 [i], array2 [j])) {
        ret [count] = array1 [i];
        count ++;
        break;
    }
    return ret;
}


public E set (int index, E e) {
    lock.lock ();
    try {
        int size = size ();
        checkIndexExlusive (index, size);
        E [] data;
        data = newElementArray (size);
        E [] oldArr = getData ();
        System.arraycopy (oldArr, 0, data, 0, size);
        E old = data [index];
        data [index] = e;
        setData (data);
        return old;
    } finally {
        lock.unlock ();
    }
}


-----Function Pair=309=-----==

public boolean removeAll (RectListManager rlm) {
    int x, xChange = 0;
    boolean ret = false;
    for (int j = 0, i = 0; j < rlm.size; j ++) {
        i = xChange;
        while ((rects [i] == null) || (rects [i].x < rlm.rects [j].x)) {
            i ++;
            if (i == size) break;
        }
        if (i == size) break;
        xChange = i;
        x = rects [i].x;
        while (true) {
            if (rects [i] == null) {
                i ++;
                if (i == size) break;
                continue;
            }
            if (rlm.rects [j].equals (rects [i])) {
                rects [i] = null;
                ret = true;
            }
            i ++;
            if (i == size) break;
            if (x != rects [i].x) break;
        }
    }
    if (ret) {
        int j = 0, i = 0;
        while (i < size) {
            if (rects [i] != null) rects [j ++] = rects [i];
            i ++;
        }
        size = j;
    }
    return ret;
}


public static String [] compactStrings (String [] as) {
    String as1 [] = new String [as.length];
    int i = 0;
    for (int j = 0; j < as.length; j ++) {
        i += as [j].length ();
    }
    char ac [] = new char [i];
    i = 0;
    for (int k = 0; k < as.length; k ++) {
        as [k].getChars (0, as [k].length (), ac, i);
        i += as [k].length ();
    }
    String s = new String (ac);
    i = 0;
    for (int l = 0; l < as.length; l ++) {
        as1 [l] = s.substring (i, i += as [l].length ());
    }
    return as1;
}


-----Function Pair=310=-----==

public static void printSaveMethod (PrintStream ps, Class theclass) {
    String className = theclass.getSimpleName ();
    ps.println ("    protected void save" + className + "(DataOutputStream out," + className + " object) throws IOException {");
    ArrayList < Method > simpleMethods = getMethods (theclass, false);
    ps.println ("        out.writeInt(" + simpleMethods.size () + ");");
    for (Method m : simpleMethods) {
        Class param = m.getReturnType ();
        if (param == int.class) {
            ps.println ("        out.writeInt( TYPE_INTEGER);");
            ps.println ("        out.writeInt( object." + m.getName () + "() );");
        }
        else if (param == double.class) {
            ps.println ("        out.writeInt( TYPE_DOUBLE);");
            ps.println ("        out.writeDouble( object." + m.getName () + "() );");
        }
        else if (param == float.class) {
            ps.println ("        out.writeInt( TYPE_FLOAT);");
            ps.println ("        out.writeFloat( object." + m.getName () + "() );");
        }
        else if (param == boolean.class) {
            ps.println ("        out.writeInt( TYPE_BOOLEAN);");
            ps.println ("        out.writeBoolean( object." + m.getName () + "() );");
        }
        else if (param == short.class) {
            ps.println ("        out.writeInt( TYPE_SHORT);");
            ps.println ("        out.writeShort( object." + m.getName () + "() );");
        }
        else if (param == long.class) {
            ps.println ("        out.writeInt( TYPE_LONG);");
            ps.println ("        out.writeLong( object." + m.getName () + "() );");
        }
        else if (param == char.class) {
            ps.println ("        out.writeInt( TYPE_CHAR);");
            ps.println ("        out.writeChar( object." + m.getName () + "() );");
        }
        else if (param == byte.class) {
            ps.println ("        out.writeInt( TYPE_BYTE);");
            ps.println ("        out.writeByte( object." + m.getName () + "() );");
        }
        else {
            ps.println ("        writeObject(out, object." + m.getName () + "() );");
        }
    }
    ps.println ("    }");
}


public Object [] remove (Object object) {
    int indexOfObject = - 1;
    for (int i = 0; (i < this.length) && (indexOfObject == - 1); i ++) {
        if (this.array [i] == object) {
            indexOfObject = i;
        }
    }
    if (indexOfObject == - 1) {
        return this.array;
    }
    int numElementsToMove = this.length - indexOfObject - 1;
    System.arraycopy (this.array, indexOfObject + 1, this.array, indexOfObject, numElementsToMove);
    this.length --;
    if (this.length % this.capacityIncrement == 0) {
        this.array = allocateNewArray (this.length);
    }
    return this.array;
}


-----Function Pair=311=-----==

private void encrypt (InputStream is, OutputStream os, Key wrappingKey) throws EncryptException {
    try {
        SecretKey simmetricKey = this.pkiContext.generateSimmetricKey ();
        logger.debug ("Using ecryption algorithm: " + this.pkiContext.getSymmetricAlgorithm ());
        Cipher cipher = Cipher.getInstance (this.pkiContext.getSymmetricAlgorithm (), "BC");
        cipher.init (Cipher.ENCRYPT_MODE, simmetricKey);
        byte [] buffer = new byte [1024];
        int numBytes = 0;
        byte [] abEncryptedData = null;
        while ((numBytes = is.read (buffer)) > - 1) {
            byte [] abTmp = new byte [numBytes];
            System.arraycopy (buffer, 0, abTmp, 0, numBytes);
            abEncryptedData = cipher.update (abTmp);
            if (abEncryptedData != null) {
                os.write (abEncryptedData);
            }
        }
        abEncryptedData = cipher.doFinal ();
        if (abEncryptedData != null) {
            os.write (abEncryptedData);
        }
        logger.debug ("Data encryption done.");
        this.setRandomData (cipher.getIV ());
        this.setSimetricKeyCiphered (this.wrapKey (simmetricKey, wrappingKey));
    } catch (Exception e) {
        EncryptException ex = new EncryptException (e);
        throw ex;
    }
}


public static byte [] expandPasswordToKey (String password, int keyLen, byte [] salt) {
    try {
        MessageDigest md5 = MessageDigest.getInstance ("MD5");
        int digLen = md5.getDigestLength ();
        byte [] mdBuf = new byte [digLen];
        byte [] key = new byte [keyLen];
        int cnt = 0;
        while (cnt < keyLen) {
            if (cnt > 0) {
                md5.update (mdBuf);
            }
            md5.update (password.getBytes ());
            md5.update (salt);
            md5.digest (mdBuf, 0, digLen);
            int n = ((digLen > (keyLen - cnt)) ? keyLen - cnt : digLen);
            System.arraycopy (mdBuf, 0, key, cnt, n);
            cnt += n;
        }
        return key;
    } catch (Exception e) {
        throw new Error ("Error in SSH2KeyPairFile.expandPasswordToKey: " + e);
    }
}


-----Function Pair=312=-----==

public int repairLog (String logRoot, String logFilename, byte [] secureRandomB, logReadingException e) {
    File logFile = new File (logRoot, logFilename);
    if (e.getErrorCode () != SAWSConstant.LogFileIncompleteErrCode) {
        this.showMessage ("This broken log file " + logFilename + " cannot be recovered. ", SAWSTextOutputCallback.WARNING);
        return - 1;
    }
    try {
        rafCurrentLogFile = new RandomAccessFile (logFile, "rw");
        rafCurrentLogFile.seek (rafCurrentLogFile.length ());
    } catch (Exception e2) {
        if (debugLevel > SAWSConstant.NoInfo) sawsDebugLog.write (e2.toString ());
        return - 1;
    }
    accMD = e.getAccMD ();
    if (this.accumulatedHash == null) {
        accumulatedHash = new byte [this.accMD.getDigestLength ()];
    }
    accumulatedHash = e.getAccumulatedHash ();
    currentRecordWriteCount = e.getSequence ();
    secureRandomBytes = secureRandomB;
    String s1 = new String ("" + SAWSConstant.LogFileIncompleteErrCode + "; log file is recovered here.");
    try {
        createSAWSRecord (s1.getBytes (), SAWSConstant.SysAuditorNotificationType, (byte) SAWSConstant.USERSAWS, SAWSConstant.NoEncryptionFlag, null);
        finalizeLogFile ();
    } catch (Exception e3) {
        if (debugLevel > SAWSConstant.NoInfo) sawsDebugLog.write (e3.toString ());
        return - 1;
    }
    return 0;
}


public void storeDataBlock (byte [] allData, int offs, int len, String password, RandomAccessFile raf) throws IOException {
    byte [] iv, data, salt = new byte [16];
    rnd.nextBytes (salt);
    try {
        Cipher cip = getCipher (password, Cipher.ENCRYPT_MODE, salt, null);
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        OutputStream out = new GZIPOutputStream (baos);
        out.write (allData, offs, len);
        out.close ();
        data = baos.toByteArray ();
        baos.reset ();
        out = new CipherOutputStream (baos, cip);
        if (data.length >= RAW_SIZE - IV_LENGTH - 17) throw new IOException ("Data too large");
        out.write (makePadding (RAW_SIZE - data.length - IV_LENGTH - 17));
        out.write (42);
        out.write (data);
        out.close ();
        data = baos.toByteArray ();
        iv = cip.getIV ();
    } catch (GeneralSecurityException ex) {
        ex.printStackTrace ();
        throw new IOException (ex.toString ());
    }
    raf.write (salt);
    raf.write (iv);
    raf.write (data);
    if (salt.length + iv.length + data.length != RAW_SIZE) {
        throw new RuntimeException ("Assertion failed!");
    }
}


-----Function Pair=313=-----==

public void save (boolean overwrite, File file) throws IOException, Exception {
    if (expander == null) {
        java.util.Hashtable templates = TemplateReader.readFile (ARGO_TEE);
        expander = new OCLExpander (templates);
    }
    preSave ();
    ZipOutputStream stream = new ZipOutputStream (new FileOutputStream (file));
    BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (stream, "UTF-8"));
    ZipEntry zipEntry = new ZipEntry (getBaseName () + UNCOMPRESSED_FILE_EXT);
    stream.putNextEntry (zipEntry);
    expander.expand (writer, this, "", "");
    writer.flush ();
    stream.closeEntry ();
    String path = file.getParent ();
    Argo.log.info ("Dir ==" + path);
    int size = _members.size ();
    try {
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (! (p.getType ().equalsIgnoreCase ("xmi"))) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
                writer.flush ();
                stream.closeEntry ();
            }
        }
        for (int i = 0; i < size; i ++) {
            ProjectMember p = (ProjectMember) _members.elementAt (i);
            if (p.getType ().equalsIgnoreCase ("xmi")) {
                Argo.log.info ("Saving member of type: " + ((ProjectMember) _members.elementAt (i)).getType ());
                stream.putNextEntry (new ZipEntry (p.getName ()));
                p.save (path, overwrite, writer);
            }
        }
    } catch (IOException e) {
        System.out.println ("hat nicht geklappt: " + e);
        e.printStackTrace ();
    }
    writer.close ();
    postSave ();
    try {
        setFile (file);
    } catch (PropertyVetoException ex) {
    }
}


public boolean writeToFile (Document doc, String fileName, boolean saveAsLocalFile) {
    OutputStreamWriter outputStreamWriter = null;
    FileOutputStream fileStream = null;
    URL url = null;
    BufferedOutputStream outputStream = null;
    boolean saveRemoteFile = ! saveAsLocalFile;
    try {
        if (saveRemoteFile) {
            url = new URL (DefaultServerSettings.getFTPURL ());
            revision = Long.parseLong (DefaultServerSettings.getResponce ());
            URLConnection urlc = url.openConnection ();
            outputStream = new BufferedOutputStream (urlc.getOutputStream ());
        }
        else {
            fileStream = new FileOutputStream (fileName);
            outputStream = new BufferedOutputStream (fileStream);
        }
        XMLOutputter XMLOut = new XMLOutputter ();
        XMLOut.setFormat (XMLOut.getFormat ().setExpandEmptyElements (true));
        if (fileName.substring (fileName.lastIndexOf ("."), fileName.length ()).equalsIgnoreCase (".aopz")) {
            ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);
            ZipEntry entry = new ZipEntry ("pathways.aop");
            zipOutputStream.putNextEntry (entry);
            XMLOut.output (doc, zipOutputStream);
            zipOutputStream.close ();
            outputStream.close ();
            System.out.println ("entry.size:" + entry.getSize ());
            if (! saveRemoteFile) fileStream.close ();
        }
        else {
            if (saveRemoteFile) outputStreamWriter = new OutputStreamWriter (outputStream, "UTF-8");
            else outputStreamWriter = new OutputStreamWriter (fileStream, "UTF-8");
            XMLOut.output (doc, outputStreamWriter);
            outputStreamWriter.close ();
        }
        return true;
    } catch (UnsupportedEncodingException e1) {
        e1.printStackTrace ();
    } catch (FileNotFoundException e1) {
        e1.printStackTrace ();
    } catch (MalformedURLException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=314=-----==

public Document readDocumentFromFile (String fileName) {
    try {
        SAXBuilder builder = new SAXBuilder ();
        URL url = getURL (fileName);
        if (fileName.substring (fileName.lastIndexOf ("."), fileName.length ()).equalsIgnoreCase (".aopz")) {
            FileInputStream fileInputStream = null;
            BufferedInputStream inputStream;
            if (url == null) {
                fileInputStream = new FileInputStream (fileName);
                inputStream = new BufferedInputStream (fileInputStream);
            }
            else {
                inputStream = new BufferedInputStream (url.openStream ());
                remoteFile = true;
            }
            ZipInputStream zipInputEntry = new ZipInputStream (inputStream);
            ZipEntry entry = zipInputEntry.getNextEntry ();
            if (entry != null) {
                String temp = readZIPEntry (zipInputEntry, (int) entry.getSize ());
                Document doc = builder.build (new StringReader (temp));
                zipInputEntry.close ();
                if (url == null) fileInputStream.close ();
                return doc;
            }
            return null;
        }
        else {
            if (url != null) return builder.build (url.openStream ());
            else return builder.build (new File (fileName));
        }
    } catch (JDOMException e) {
        e.printStackTrace ();
        return null;
    } catch (NullPointerException e) {
        e.printStackTrace ();
        return null;
    } catch (IOException e) {
        e.printStackTrace ();
        return null;
    }
}


private static void setMembers () {
    try {
        URL url = new URL (getTracUrl () + "newticket");
        BufferedReader reader = new BufferedReader (new InputStreamReader (url.openStream ()));
        String buffer = reader.readLine ();
        while (buffer != null) {
            if (buffer.contains ("<select id=\"component\" name=\"component\">")) {
                Pattern pattern = Pattern.compile (">[^<]+?<");
                Matcher matcher = pattern.matcher (buffer);
                Vector < String > erg = new Vector < String > ();
                int start = 0;
                while (matcher.find (start)) {
                    int von = matcher.start () + 1;
                    int bis = matcher.end () - 1;
                    erg.add (Recoder.recode (buffer.substring (von, bis), "UTF-8", Recoder.getDefaultEncoding ()));
                    start = bis;
                }
                m_strComponents = new String [erg.size ()];
                erg.toArray (m_strComponents);
            }
            if (buffer.contains ("<select id=\"priority\" name=\"priority\">")) {
                Pattern pattern = Pattern.compile (">[^<]+?<");
                Matcher matcher = pattern.matcher (buffer);
                Vector < String > erg = new Vector < String > ();
                int start = 0;
                while (matcher.find (start)) {
                    int von = matcher.start () + 1;
                    int bis = matcher.end () - 1;
                    erg.add (Recoder.recode (buffer.substring (von, bis), "UTF-8", Recoder.getDefaultEncoding ()));
                    start = bis;
                }
                m_strPriorities = new String [erg.size ()];
                erg.toArray (m_strPriorities);
            }
            buffer = reader.readLine ();
        }
    } catch (MalformedURLException e) {
        System.out.println ("e1");
    } catch (IOException e) {
        System.out.println (e);
    }
}


-----Function Pair=315=-----==

public static String download (String address) throws Exception {
    if (Main.gui != null) Main.gui.setStatusBar ("downloading " + address);
    URLConnection conn = null;
    InputStream in = null;
    String R = "";
    try {
        URL url = new URL (address);
        conn = url.openConnection ();
        in = conn.getInputStream ();
        byte [] buffer = new byte [1024];
        int numRead;
        long numWritten = 0;
        while ((numRead = in.read (buffer)) != - 1) {
            R += new String (buffer, 0, numRead);
        }
    } catch (MalformedURLException ex) {
        Utils.showException (ex);
        throw ex;
    } catch (IOException ex) {
        Utils.showException (ex);
        throw ex;
    }
    return R;
}


public XExternalEditor (String [] args) {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (Exception e) {
    }
    Timer tt = new Timer ("sfnet-updater", true);
    tt.schedule (new TimerTask () {
        @Override
        public void run () {
            try {
                LatestFilesMain l = new LatestFilesMain ();
                if (l.update ()) {
                    URL url = l.getLatest ();
                    if (JOptionPane.showConfirmDialog (null, LC.tr ("A new version of XExternalEditor is available!\nDo you wan't to get it now?"), LC.tr ("New Version"), JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE) == JOptionPane.YES_OPTION) {
                        Desktop.getDesktop ().browse (url.toURI ());
                    }
                }
            } catch (Throwable e) {
                XExternalEditor._logger.error ("", e);
            }
        }
    }
    , 100, 1000 * 60 * 60 * 24);
    if (args.length == 0) {
        JFileChooser fc = new JFileChooser (new File (System.getProperty ("user.home")));
        fc.setFileFilter (new FileFilter () {
            @Override
            public boolean accept (File f) {
                return f.getName ().endsWith (".ini") || f.isDirectory ();
            }@Override
            public String getDescription () {
                return LC.tr ("ini files");
            }
        }
        );
        if (fc.showOpenDialog (null) == JFileChooser.APPROVE_OPTION) {
            args = new String [] {fc.getSelectedFile ().getAbsolutePath ()};
        }
        else {
            System.exit (0);
        }
    }
    if (new File (args [0]).exists ()) {
        this.iniFileFromServer = new File (args [0]);
        try {
            this.loadIniFile ();
            this.loadSettings ();
            this.showGui ();
            if (! this.processFile ()) {
                this.close ();
            }
        } catch (IOException e) {
            XExternalEditor._logger.error ("", e);
            JOptionPane.showMessageDialog (this.frame, e.getClass ().getSimpleName () + ": " + e.getMessage (), LC.tr ("Error"), JOptionPane.ERROR_MESSAGE);
        } catch (NotSupportedException e) {
            XExternalEditor._logger.error ("", e);
            JOptionPane.showMessageDialog (this.frame, LC.tr ("XExternalEditor >>\nA feature you wan't is currently not supported!").concat ("\n\nInfo: <" + e.getMessage () + ">"), LC.tr ("Error"), JOptionPane.ERROR_MESSAGE);
        }
    }
    else {
        JOptionPane.showMessageDialog (new JFrame (), LC.tr ("The given parameter is no ini file!\nXExternalEditor will be closed."), LC.tr ("Error"), JOptionPane.ERROR_MESSAGE);
    }
}


-----Function Pair=316=-----==

public int print (Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {
    if (pageIndex > 0) return Printable.NO_SUCH_PAGE;
    Graphics2D g2d = (Graphics2D) graphics;
    g2d.translate (pageFormat.getImageableX (), pageFormat.getImageableY ());
    AffineTransform at = new AffineTransform ();
    at.translate (0, 0);
    Dimension drawku = kit.getScreenSize ();
    double xScale = pageFormat.getImageableWidth () / drawku.getWidth ();
    double yScale = pageFormat.getImageableHeight () / drawku.getHeight ();
    double aspectScale = Math.min (xScale, yScale);
    try {
        g2d.drawRenderedImage (panel.ambilDrawing (panel), at);
    } catch (Exception ex) {
    }
    return Printable.PAGE_EXISTS;
}


public void createScreenCapture (String outputFileName) {
    try {
        Point pt = new Point ();
        int width = 0;
        int height = 0;
        if (movieMode == 0) {
            pt = threeDpanel.getWwdLocationOnScreen ();
            width = threeDpanel.getWwdWidth ();
            height = threeDpanel.getWwdHeight ();
        }
        else if (movieMode == 1) {
            int [] twoDinfo = calculate2DMapSizeAndScreenLoc (twoDpanel);
            pt.setLocation (twoDinfo [2], twoDinfo [3]);
            width = twoDinfo [0];
            height = twoDinfo [1];
        }
        else {
            pt = otherPanel.getLocationOnScreen ();
            width = otherPanel.getWidth ();
            height = otherPanel.getHeight ();
        }
        if (height <= 0 || width <= 0) {
            JOptionPane.showInternalMessageDialog (this, "A Screenshot was not possible - too small of size", "ERROR", JOptionPane.ERROR_MESSAGE);
            return;
        }
        BufferedImage screencapture = new Robot ().createScreenCapture (new Rectangle (pt.x, pt.y, width, height));
        String fileExtension = "jpg";
        File file = new File (outputFileName);
        Exception e = SaveImageFile.saveImage (fileExtension, file, screencapture, 0.9f);
        if (e != null) {
            System.out.println ("ERROR SCREEN CAPTURE:" + e.toString ());
            return;
        }
    } catch (Exception e4) {
        System.out.println ("ERROR SCREEN CAPTURE:" + e4.toString ());
    }
}


-----Function Pair=317=-----==

public int print (Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {
    if (pageIndex > 0) return Printable.NO_SUCH_PAGE;
    Graphics2D g2d = (Graphics2D) graphics;
    g2d.translate (pageFormat.getImageableX (), pageFormat.getImageableY ());
    AffineTransform at = new AffineTransform ();
    at.translate (0, 0);
    Dimension drawku = kit.getScreenSize ();
    double xScale = pageFormat.getImageableWidth () / drawku.getWidth ();
    double yScale = pageFormat.getImageableHeight () / drawku.getHeight ();
    double aspectScale = Math.min (xScale, yScale);
    try {
        g2d.drawRenderedImage (panel.ambilDrawing (panel), at);
    } catch (Exception ex) {
    }
    return Printable.PAGE_EXISTS;
}


private void loadFromFile () {
    JFileChooser fileChooser = new JFileChooser (".");
    int returnVal = fileChooser.showOpenDialog (null);
    if (returnVal != JFileChooser.APPROVE_OPTION) return;
    File file = fileChooser.getSelectedFile ();
    System.out.println ("loadFromFile: " + file);
    int count = 0;
    try {
        FileInputStream fis = new FileInputStream (file);
        BufferedReader br = new BufferedReader (new InputStreamReader (fis));
        String sr = br.readLine ();
        while (sr != null && sr.length () > 2 && count < iDispProps.length - 2) {
            String [] sa = sr.split (",");
            sa [0] = sa [0].trim ();
            sa [1] = sa [1].trim ();
            System.out.println ("loadFromFile: " + sa [0] + CS + sa [1]);
            iDispProps [count].iName = sa [0];
            iDispProps [count].iLineageNum = getColorNumber (sa [1]);
            count ++;
            sr = br.readLine ();
        }
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        return;
    }
    for (int i = count; i < iDispProps.length - 2; i ++) {
        iDispProps [i].iName = "";
        iDispProps [i].iLineageNum = 0;
    }
    update ();
}


-----Function Pair=318=-----==

public static void logInit () throws IOException {
    String logdir = getWorkingDir () + File.separator + "logs";
    String yyyymmdd = getLogDate ();
    String hhmmss = getLogTime ();
    int yyyy = Integer.parseInt (yyyymmdd.substring (0, 4), 10);
    int mo = Integer.parseInt (yyyymmdd.substring (4, 6), 10);
    int dy = Integer.parseInt (yyyymmdd.substring (6), 10);
    int hr = Integer.parseInt (hhmmss.substring (0, 2), 10);
    int min = Integer.parseInt (hhmmss.substring (2, 4), 10);
    int sec = Integer.parseInt (hhmmss.substring (4), 10);
    ++ lognumber;
    logname = logdir + File.separator + logprefix + ".jaglog" + yyyymmdd + hhmmss + "_" + lognumber + ".rtf";
    File logfile = new File (logname);
    new File (logdir).mkdir ();
    logwriter = new BufferedWriter (new FileWriter (logfile));
    logwriter.write ("{\\rtf1\\ansi\\ansicpg1252\\uc1\\deff0");
    logwriter.newLine ();
    if (Jaguar.getOsName ().toLowerCase ().indexOf ("linux") >= 0) {
        logwriter.write ("{\\fonttbl{\\f0\\fnil\\fprq2{\\*\\panose 02020603050405020304}Times New Roman;}");
        logwriter.newLine ();
        logwriter.write ("{\\f1\\fnil\\fprq1{\\*\\panose 02070409020205020404}Courier{\\*\\falt Courier New};}");
    }
    else {
        logwriter.write ("{\\fonttbl{\\f0\\fnil\\fprq2 DejaVu Sans;}");
        logwriter.newLine ();
        logwriter.write ("{\\f1\\fnil\\fprq1 Courier;}");
    }
    logwriter.newLine ();
    logwriter.write ("}{\\colortbl;" + "\\red0\\green0\\blue0;" + "\\red0\\green0\\blue255;" + "\\red0\\green255\\blue255;" + "\\red0\\green255\\blue0;" + "\\red255\\green0\\blue255;" + "\\red255\\green0\\blue0;" + "\\red255\\green255\\blue0;" + "\\red255\\green255\\blue255;" + "\\red0\\green0\\blue128;" + "\\red0\\green128\\blue128;" + "\\red0\\green128\\blue0;" + "\\red128\\green0\\blue128;" + "\\red128\\green0\\blue0;" + "\\red128\\green128\\blue0;" + "\\red128\\green128\\blue128;" + "\\red255\\green255\\blue220;" + "\\red192\\green192\\blue192;" + "}" + "{\\stylesheet");
    logwriter.newLine ();
    logwriter.write ("{\\ql\\fi0\\f0\\fs20\\i0\\b0\\cf1\\ul0\\strike0\\snext0 Standard;}");
    logwriter.newLine ();
    logwriter.write ("}{\\info {\\comment Generated by Jaguar v" + Jaguar.version + " RTF Logger }" + "{\\creatim\\yr" + yyyy + "\\mo" + mo + "\\dy" + dy + "\\hr" + hr + "\\min" + min + "\\sec" + sec + "}" + "{\\revtim\\yr1970\\mo1\\dy1\\hr1\\min0\\sec0}" + "{\\printim\\yr1970\\mo1\\dy1\\hr1\\min0\\sec0}}" + "\\paperw12240\\paperh15840\\margl800\\margr800\\margt720\\margb720" + "\\widowctrl\\ftnbj\\aenddoc\\formshade \\fet0\\sectd");
    logwriter.newLine ();
    logwriter.write ("\\pgnstart1\\pard\\plain\\pard\\plain\\s0\\ql\\fi0\\f0\\fs20\\i0\\b1\\cf1\\ul1\\strike0 {" + logname.replaceAll ("\\\\", "\\\\\\\\") + "}");
    logwriter.newLine ();
    loglines = 0;
}


public SplashScreen (ImageIcon ghost, SplashCallable callback) {
    this.callback = callback;
    this.ghost = ghost;
    this.addMouseListener (this);
    w = ghost.getIconWidth ();
    h = ghost.getIconHeight ();
    GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment ();
    GraphicsDevice gd = ge.getDefaultScreenDevice ();
    GraphicsConfiguration gc = gd.getDefaultConfiguration ();
    Rectangle rect = gc.getBounds ();
    scrW = rect.width;
    scrH = rect.height;
    Robot robot = null;
    try {
        robot = new Robot ();
    } catch (AWTException e1) {
    }
    int x = (scrW - w) / 2;
    int y = (scrH - h) / 2;
    this.setVisible (true);
    composite = AlphaComposite.getInstance (AlphaComposite.SRC_OVER, 0.8f);
    screen = robot.createScreenCapture (new Rectangle (x, y, w, h));
    setLocation (x, y);
    pack ();
    try {
        Thread.sleep (3000);
        callback.runApplication ();
        this.dispose ();
    } catch (InterruptedException e) {
    }
}


-----Function Pair=319=-----==

private void loadFromFile () {
    JFileChooser fileChooser = new JFileChooser (iCurrentRotDir);
    int returnVal = fileChooser.showOpenDialog (null);
    if (returnVal != JFileChooser.APPROVE_OPTION) return;
    File file = fileChooser.getSelectedFile ();
    iCurrentRotDir = file.getParent ();
    iLineageCount = 0;
    try {
        FileReader fr = new FileReader (file);
        QDParser.parse (iParent, fr);
    } catch (FileNotFoundException fnfe) {
        fnfe.printStackTrace ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    for (int i = iLineageCount; i < iDispProps2.length - 2; i ++) {
        iDispProps2 [i].iName = "";
        iDispProps2 [i].iLineageNum = 0;
    }
    update ();
}


public static void main (String [] args) throws IOException, AWTException, InterruptedException {
    JRfbServer server = new JRfbServer (10, 400, 400, "Robot");
    server.start ();
    Graphics g = server.getGraphics ();
    Robot robot = new Robot ();
    while (true) {
        BufferedImage img = robot.createScreenCapture (new Rectangle (400, 400));
        g.drawImage (img, 0, 0, null);
        PointerInfo a = MouseInfo.getPointerInfo ();
        Point b = a.getLocation ();
        int x = (int) b.getX ();
        int y = (int) b.getY ();
        g.fillRect (x, y, 10, 10);
        server.imageUpdated ();
        Thread.sleep (1000);
    }
}


-----Function Pair=320=-----==

public static void getPublicKey (String publicKeyPath) throws FileNotFoundException, IOException, ClassNotFoundException {
    String s = ReadFile (publicKeyPath);
    String mod = GetValue ("m=", s);
    String pubExp = GetValue ("e=", s);
    BigInteger m = new BigInteger (mod, 16);
    BigInteger e = new BigInteger (pubExp, 16);
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec (m, e);
    KeyFactory keyFactory;
    try {
        keyFactory = KeyFactory.getInstance ("RSA");
        publicKey = keyFactory.generatePublic (keySpec);
    } catch (NoSuchAlgorithmException e1) {
        e1.printStackTrace ();
    } catch (InvalidKeySpecException e2) {
        e2.printStackTrace ();
    }
}


public static void createKeyPars (String dir) {
    try {
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance ("RSA");
        keyPairGen.initialize (1024);
        KeyPair keyPair = keyPairGen.generateKeyPair ();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate ();
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic ();
        String prvKeyFile = dir + "privateKey.scrpt";
        String pubKeyFile = dir + "publicKey.scrpt";
        FileOutputStream prvfos = new FileOutputStream (prvKeyFile);
        ObjectOutputStream prvoos = new ObjectOutputStream (prvfos);
        prvoos.writeObject (privateKey);
        prvoos.close ();
        prvfos.close ();
        FileOutputStream pubfos = new FileOutputStream (pubKeyFile);
        ObjectOutputStream puboos = new ObjectOutputStream (pubfos);
        puboos.writeObject (publicKey);
        puboos.close ();
        pubfos.close ();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=321=-----==

public void touchSomeFiles (int percentage, int mode) {
    try {
        File [] files = dir.listFiles (mff);
        Random rnd = new Random ();
        for (int i = files.length - 1; i >= 0; i --) {
            int j = rnd.nextInt (i + 1);
            File swap = files [i];
            files [i] = files [j];
            files [j] = swap;
        }
        int howfar = files.length * percentage / 100;
        if (mode == TOUCH_MODE_RECREATE || mode == TOUCH_MODE_COPY_TWICE) {
            for (int i = 0; i < howfar; i ++) {
                File f = files [i];
                if (mode == TOUCH_MODE_COPY_TWICE) {
                    File bf = new File (f.getParent (), "recreate--" + f.getName ());
                    recreateFile (f, bf);
                }
                else {
                    recreateFile (f, f);
                }
            }
            if (mode == TOUCH_MODE_COPY_TWICE) {
                try {
                    Thread.sleep (15000);
                } catch (InterruptedException ex) {
                    ex.printStackTrace ();
                }
                for (int i = 0; i < howfar; i ++) {
                    File f = files [i];
                    File bf = new File (f.getParent (), "recreate--" + f.getName ());
                    recreateFile (bf, f);
                }
            }
        }
        else if (mode == TOUCH_MODE_ACCESS || mode == TOUCH_MODE_MODIFY) {
            for (int i = 0; i < howfar; i ++) {
                RandomAccessFile raf = new RandomAccessFile (files [i], mode == TOUCH_MODE_MODIFY ? "rw" : "r");
                if (raf.length () > 0) {
                    int pos = rnd.nextInt (Math.max (0, (int) raf.length ()));
                    raf.seek (pos);
                    byte byte1 = raf.readByte ();
                    if (mode == TOUCH_MODE_MODIFY) {
                        raf.seek (pos);
                        raf.write (byte1);
                    }
                }
                raf.close ();
                files [i].setLastModified (LAST_MODIFIED_DATE);
            }
        }
        else {
            throw new IllegalArgumentException ();
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}


public void computeError (Neuron [] n, int inumber) {
    int vTest = (int) (group * (c.getVectorsInTestingSet () / 100.0));
    int rVector;
    double error;
    job = ERROR_COMPUTING;
    myRandom.resetRandom ();
    int count = 0;
    for (int act = 0; act < inumber; act ++) {
        n [act].setSquareError (0);
    }
    for (int i = c.isTestOnBothTrainingAndTestingData () ? 0 : (group - vTest); i < group; i ++) {
        rVector = 0;
        if (i < group - vTest) {
            rVector = myRandom.getRandomLearningVector ();
        }
        if (i == group - vTest) {
            myRandom.resetRandom ();
        }
        if (i >= group - vTest) {
            rVector = myRandom.getRandomTestingVector ();
        }
        iLayer.setActualVector (rVector);
        mode = PASSIVE;
        prevLayer.computeOutputs ();
        for (int act = 0; act < inumber; act ++) {
            error = n [act].getError (rVector);
            if (myGraph != null) if (GraphCanvas.getInstance ().isVisualInspectionEnabled ()) {
                if (cw != null) {
                    cw.setErr (act, rVector, error);
                }
            }
            n [act].setSquareError (n [act].getSquareError () + error * error);
            layerProgress = (int) (100.0 * (i + (double) act / (double) (inumber - 1)) / (double) (group));
        }
        if (i % 1000 == 1) {
        }
        mode = ACTIVE;
        count ++;
    }
    for (int act = 0; act < inumber; act ++) {
        double error_data = n [act].getSquareError () / (double) count;
        n [act].setSquareError (error_data);
        double penalty;
        switch (c.getRegularization ()) {
            case NetworkGAMEConfiguration.RMS :
                break;
            case NetworkGAMEConfiguration.RMS_PENALTY :
                n [act].penalizeComplexity ();
                break;
            case NetworkGAMEConfiguration.RMS_PENALTY_NOISE :
                n [act].penalizeComplexity ();
                penalty = n [act].getSquareError () - error_data;
                n [act].setSquareError (error_data * (1 + penalty * data_noise * 100));
                break;
        }
        if (myGraph != null) if (GraphCanvas.getInstance ().isVisualInspectionEnabled ()) {
            if (cw != null) {
                cw.setSerr (act, n [act].getSquareError ());
            }
            for (int i = 0; i < inumber; i ++) {
                if (cw != null) {
                    cw.setCorDist (i, act, getCorrelationDistance (n [i], n [act], 50));
                    cw.setGenDist (i, act, g [i].getNormalizedDistance (g [act]));
                }
            }
        }
    }
}


-----Function Pair=322=-----==

public boolean findSmiliesbytypeid (short typeid, String url) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Smilies as s where s.type='smiley' and s.typeid=? and url = ?");
        query.setParameter (0, typeid);
        query.setParameter (1, url);
        List list = query.list ();
        tr.commit ();
        if (list != null && list.size () > 0) {
            return true;
        }
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
        }
        he.printStackTrace ();
    }
    return false;
}


public Boolean isAtividadeAtiva (Atividade atividade) throws SQLException {
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Atividade_has_recurso_humano rh " + "where " + "rh.ativo = 'TRUE' and " + "rh.atividade_idatividade=" + atividade.getIdAtividade ();
        ResultSet rs = stmt.executeQuery (sqlSelect);
        while (rs.next ()) {
            return true;
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return false;
}


-----Function Pair=323=-----==

public List < Smilies > findSmiliesBytypeid (short typeid, int start, int max) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Smilies as s where s.typeid=?");
        query.setParameter (0, typeid);
        query.setFirstResult (start);
        query.setMaxResults (max);
        List < Smilies > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
        }
        he.printStackTrace ();
    }
    return null;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nExercise1Id, Long nUserId) {
    List < CoScoreExercises1 > listCoScoreExercises1 = null;
    Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_SCORE_EXERCISES1, CoScoreExercises1.class);
    query.setParameter (1, nExercise1Id);
    query.setParameter (2, nUserId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listCoScoreExercises1 = query.getResultList ();
    if (listCoScoreExercises1 == null || listCoScoreExercises1.size () == 0) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("coScoreExercises1.search.notFound"));
    }
    else {
        Object [] arrayParam = {listCoScoreExercises1.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises1.search.success"), arrayParam));
        serviceResult.setObjResult (listCoScoreExercises1);
        serviceResult.setNumResult (listCoScoreExercises1.size ());
    }
    return serviceResult;
}


-----Function Pair=324=-----==

public int getIdJugadorxRonda (int idJugxDiv, int idRonda) {
    int id = 0;
    try {
        String sql = "SELECT idJugxDivxRnd FROM jugadorxdivxronda " + " WHERE  jugadorxDivision_idJugadorxDivision = " + idJugxDiv + " AND ronda_numeroRonda = " + idRonda;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            id = populateId (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return id;
}


private Hashtable getCourseSelected () throws Exception {
    String applicant_id = getParam ("applicant_id");
    if ("".equals (applicant_id)) throw new Exception ("Missing applicant_id..");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("choice1");
        r.add ("choice2");
        r.add ("choice3");
        r.add ("applicant_id", applicant_id);
        sql = r.getSQLSelect ("adm_applicant_choice");
        ResultSet rs = stmt.executeQuery (sql);
        Hashtable h = new Hashtable ();
        if (rs.next ()) {
            h.put ("choice1", rs.getString ("choice1"));
            h.put ("choice2", rs.getString ("choice2"));
            h.put ("choice3", rs.getString ("choice3"));
        }
        return h;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=325=-----==

public int getEstadoRonda (int idRonda) {
    int dato = 0;
    try {
        String sql = "SELECT estado FROM ronda" + " WHERE numeroRonda = " + idRonda;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            dato = populateEstado (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return dato;
}


public boolean classifyByNamespaceId (int namespaceId, DTSPermission permission) throws SQLException {
    ExtNamespaceEntry extNamespace = fetchExtNamespaceEntry (namespaceId);
    if (extNamespace == null) {
        throw new SQLException ("Namespace [ ID=" + namespaceId + " ] is not found.");
    }
    if (extNamespace.baseName == null) {
        throw new SQLException ("Namespace [ " + extNamespace.name + " ] is not an Ontylog Extension Namespace");
    }
    if (! canClassifyNamespace (extNamespace, permission)) {
        return false;
    }
    String url = getMCServerUrl (extNamespace);
    gidMap.clear ();
    List requests = buildMCRequest (extNamespace);
    if (requests.size () == 0) {
        return true;
    }
    List resultConcepts = sendMCRequest (requests, extNamespace, url);
    processMCResult (resultConcepts, namespaceId);
    return true;
}


-----Function Pair=326=-----==

public int add (String name, int objectId) throws FidoDatabaseException, ObjectNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            ObjectTable ot = new ObjectTable ();
            if (ot.contains (objectId) == false) throw new ObjectNotFoundException (objectId);
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            int row = findMaxRank (stmt, name);
            String sql = "insert into ProperNouns (Noun, SenseNumber, ObjectId) " + "values ('" + name + "', " + (row + 1) + ", " + objectId + ")";
            stmt.executeUpdate (sql);
            return row;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public static PXAlbumFace updateFaceForAlbum (PXAlbumContent album) {
    PXAlbumFace updateFace = null;
    if (album != null) {
        String anAlbumId = album.getId ();
        if (anAlbumId != null) {
            Transaction aTransaction = null;
            try {
                Session aSession = PXObjectStore.getInstance ().getThreadSession ();
                updateFace = (PXAlbumFace) PXSessionUtility.tryLoad (aSession, PXAlbumFace.class, anAlbumId);
                aTransaction = aSession.beginTransaction ();
                if (updateFace == null) {
                    File aPath = album.getAlbumPath ();
                    if (aPath != null) {
                        PXAlbumFace anInvalidFace = PXAlbumFace.getFaceForPath (aPath.getAbsolutePath ());
                        if (anInvalidFace != null) {
                            PXAlbumFace.removeFaceFromStore (anInvalidFace);
                        }
                    }
                    updateFace = new PXAlbumFace (anAlbumId);
                    updateFace.takeValuesFromAlbum (album);
                    aSession.save (updateFace);
                }
                else {
                    updateFace.takeValuesFromAlbum (album);
                    updateFace.setLastUpdateDate (new Date ());
                }
                aTransaction.commit ();
            } catch (Exception anException) {
                if (aTransaction != null) {
                    try {
                        aTransaction.rollback ();
                    } catch (Exception eS) {
                    }
                }
                LOG.warn (null, anException);
            }
        }
    }
    return updateFace;
}


-----Function Pair=327=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public AcUser findUser (String email, String pwd) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + AcUser.class.getName () + " where email = '" + email + "' and userPwd = '" + pwd + "'";
        Query queryObject = getSession ().createQuery (queryString);
        List < AcUser > rtn = queryObject.list ();
        tx.commit ();
        return rtn.size () <= 0 ? null : rtn.get (0);
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=328=-----==

public static Funcionario selectByID (String id_funcionario) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Funcionario objFuncionario = null;
    if (c == null) {
        return null;
    }
    try {
        String sql = "Select * from funcionario where id_funcionario = ?";
        pst = c.prepareStatement (sql);
        pst.setString (1, id_funcionario);
        rs = pst.executeQuery ();
        if (rs.next ()) {
            objFuncionario = new Funcionario ();
            objFuncionario.setCodigo (rs.getInt ("id_funcionario"));
            objFuncionario.setNome (rs.getString ("nome"));
            objFuncionario.setCpf (rs.getString ("cpf"));
            objFuncionario.setEmail (rs.getString ("email"));
            objFuncionario.setLogin (rs.getString ("login"));
            objFuncionario.setSenha (rs.getString ("senha"));
            objFuncionario.setTelefone (rs.getString ("telefone"));
            objFuncionario.setCargo (CargoDAO.selectByID (rs.getString ("id_cargo")));
            objFuncionario.setDepartamento (DepartamentoDAO.selectByFuncionario (rs.getInt ("id_funcionario")));
        }
    } catch (SQLException e) {
        System.out.println ("[FuncionarioDAO.selectByID] Erro ao atualizar -> " + e.getMessage ());
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return objFuncionario;
}


private String findNamespaceID (String column, String value) throws SQLException {
    String statement = getDAO ().getStatement (TABLE_KEY, "GET_NAMESPACE");
    statement += (" " + getDAO ().getStatement (TABLE_KEY, "FIND_NAMESPACE_BY_" + column.toUpperCase ()));
    statement += ("'" + value + "'");
    ResultSet res = findNamespaceSt.executeQuery (statement);
    int id = - 1;
    while (res.next ()) {
        id = res.getInt (1);
    }
    String idString = "";
    if (id != - 1) {
        idString = Integer.toString (id);
    }
    return idString;
}


-----Function Pair=329=-----==

public boolean hasTaskRole (Techconeng eng) {
    DbConn conn = new DbConn ();
    boolean isRole = false;
    DbRs rs = null;
    try {
        String sql = "select * from techconeng where conid=? and engid=? and taskid=0 ";
        conn.prepare (sql);
        conn.setInt (1, eng.getConid ());
        conn.setString (2, eng.getEngid ());
        rs = conn.executeQuery ();
        if (rs.size () > 0) {
            isRole = true;
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
        setErr (ex.getMessage ());
    } finally {
        conn.close ();
    }
    return isRole;
}


public static void setAuditRecord (String messageid, String message) throws Exception {
    log.debug ("Adding audit  message");
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Audit auditTable = new Audit ();
    auditTable.setMessageid (messageid);
    auditTable.setAction (message);
    try {
        session.saveOrUpdate (auditTable);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception (e);
    }
    return;
}


-----Function Pair=330=-----==

public boolean addRoleType (RoleTypeEntry entry, DTSPermission permit) throws DTSValidationException, SQLException, PermissionException {
    checkPermission (permit, String.valueOf (entry.getNamespaceId ()));
    int linkedNamespaceId = getLinkedNamespaceId (entry.namespaceId);
    if (linkedNamespaceId == - 1) {
        throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0027", new String [] {String.valueOf (entry.namespaceId)}));
    }
    if (entry.domainKindNamespaceId != entry.namespaceId && entry.domainKindNamespaceId != linkedNamespaceId) {
        throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0028"));
    }
    long domainGid = getGID (entry.domainKindNamespaceId, entry.domainKindId);
    if (entry.rangeKindNamespaceId != entry.namespaceId && entry.rangeKindNamespaceId != linkedNamespaceId) {
        throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0029"));
    }
    long rangeGid = getGID (entry.rangeKindNamespaceId, entry.rangeKindId);
    long rightIdentityGid = 0;
    if (entry.rightIdentityId != 0) {
        if (entry.rightIdentityNamespaceId != entry.namespaceId && entry.rightIdentityNamespaceId != linkedNamespaceId) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0030"));
        }
        if (entry.id != - 1) {
            if (entry.rightIdentityNamespaceId == entry.namespaceId && entry.rightIdentityId == entry.id) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0035"));
            }
        }
        rightIdentityGid = getGID (entry.rightIdentityNamespaceId, entry.rightIdentityId);
        DBRoleTypeEntry riEntry = fetchDBRoleTypeEntry (rightIdentityGid);
        if (riEntry == null) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0039", new String [] {"Right Identity Role Type", String.valueOf (entry.rightIdentityNamespaceId), String.valueOf (entry.rightIdentityId)}));
        }
        if (riEntry.domainGid != riEntry.rangeGid) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0036"));
        }
        if (riEntry.domainGid != rangeGid) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0037"));
        }
    }
    long parentGid = 0;
    if (entry.parentId != 0) {
        if (entry.parentNamespaceId != entry.namespaceId && entry.parentNamespaceId != linkedNamespaceId) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0031"));
        }
        if (entry.id != - 1) {
            if (entry.parentNamespaceId == entry.namespaceId && entry.parentId == entry.id) {
                throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0032"));
            }
        }
        parentGid = getGID (entry.parentNamespaceId, entry.parentId);
        DBRoleTypeEntry pEntry = fetchDBRoleTypeEntry (parentGid);
        if (pEntry == null) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0039", new String [] {"Parent Role Type", String.valueOf (entry.parentNamespaceId), String.valueOf (entry.parentId)}));
        }
        if ((pEntry.domainGid != domainGid) || pEntry.rangeGid != rangeGid) {
            throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0038"));
        }
    }
    if (entry.id == - 1) {
        entry.id = getNextFormId (ROLE_TYPE_TABLE_KEY, String.valueOf (entry.namespaceId));
    }
    if ((entry.code == null) || entry.code.equals ("")) {
        entry.code = generateRoleTypeCode (entry.id);
    }
    entry.name = DTSUtil.checkValue ("Role Type Name", entry.name, DTSDataLimits.LEN_NAME);
    entry.code = DTSUtil.checkValue ("Role Type Code", entry.code, DTSDataLimits.LEN_CODE);
    if (isRoleTypeExist (entry.name, linkedNamespaceId)) {
        throw new DTSValidationException (ApelMsgHandler.getInstance ().getMsg ("DTS-0033", new String [] {entry.name}));
    }
    String sql = getDAO ().getStatement (ROLE_TYPE_TABLE_KEY, "INSERT");
    PreparedStatement pstmt = null;
    int result;
    try {
        pstmt = conn.prepareStatement (sql);
        pstmt.setLong (1, getGID (entry.namespaceId, entry.id));
        pstmt.setInt (2, entry.id);
        pstmt.setString (3, entry.code);
        pstmt.setString (4, entry.name);
        pstmt.setInt (5, entry.namespaceId);
        pstmt.setLong (6, domainGid);
        pstmt.setLong (7, rangeGid);
        if (rightIdentityGid == 0) {
            pstmt.setNull (8, Types.INTEGER);
        }
        else {
            pstmt.setLong (8, rightIdentityGid);
        }
        pstmt.setNull (9, Types.INTEGER);
        if (parentGid == 0) {
            pstmt.setNull (10, Types.INTEGER);
        }
        else {
            pstmt.setLong (10, parentGid);
        }
        result = pstmt.executeUpdate ();
    } finally {
        closeStatement (pstmt);
    }
    return (result == 1);
}


private void Reserve () throws SQLException {
    Statement stbookings, stchartwl;
    String sp = "";
    if (useragent) sp = "agent";
    else sp = "user";
    String userbooksql = "";
    String agentbooksql = "";
    String bookingid = String.valueOf (System.currentTimeMillis ());
    String currentcoach;
    String currentseat;
    try {
        if (useragent) {
            agentbooksql = "update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert ";
            agentbooksql += " <detail booking_id=\"" + booking_details.getTicketno () + "\" status=\"open\" train_no=\"" + booking_details.getTrain_no () + "\" source=\"" + booking_details.getSource () + "\" dest=\"" + booking_details.getDestination () + "\" dep_date=\"" + booking_details.getDate () + "\" > ";
        }
        else if (! useragent) {
            userbooksql = "update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert ";
            userbooksql += " <detail booking_id=\"" + booking_details.getTicketno () + "\" status=\"open\" train_no=\"" + booking_details.getTrain_no () + "\" source=\"" + booking_details.getSource () + "\" dest=\"" + booking_details.getDestination () + "\" dep_date=\"" + booking_details.getDate () + "\" > ";
        }
        for (int tickpos = 0; tickpos < booking_details.getNoOfPersons (); tickpos ++) {
            currentcoach = coach.get (tickpos);
            currentseat = seatno.get (tickpos);
            if (! currentcoach.equals ("WL")) {
                String chartavailupdsql = "update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert ";
                chartavailupdsql += "<seat number=\"" + currentseat + "\"><details user_id=\"" + booking_details.getUserId () + "\" usertype=\"" + sp + "\" ticket_no=\"" + booking_details.getTicketno () + "\" name=\"" + booking_details.getNameAt (tickpos) + "\" age=\"" + booking_details.getAgeAt (tickpos) + "\" sex=\"" + booking_details.getSexAt (tickpos) + "\" type=\"primary\"  /></seat>";
                chartavailupdsql += " into $new/status/class[@name=\"" + booking_details.getTclass () + "\"]/coach[@number=\"" + currentcoach + "\"] ";
                chartavailupdsql += " return  $new' ) where train_no like '" + booking_details.getTrain_no () + "' and date = '" + booking_details.getDate () + "' ";
                System.out.println (chartavailupdsql);
                stchartwl = conn.createStatement ();
                int updstat = stchartwl.executeUpdate (chartavailupdsql);
                if (updstat > 0) System.out.println ("chart_wl  availability  updated");
            }
            else if (currentcoach.equals ("WL")) {
                String chartwlupdsql = "update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert ";
                chartwlupdsql += "<details user_id=\"" + booking_details.getUserId () + "\" usertype=\"" + sp + "\" ticket_no=\"" + booking_details.getTicketno () + "\" name=\"" + booking_details.getNameAt (tickpos) + "\" age=\"" + booking_details.getAgeAt (tickpos) + "\" sex=\"" + booking_details.getSexAt (tickpos) + "\" type=\"primary\" /></seat>";
                chartwlupdsql += " into $new/status/class[@name=\"" + booking_details.getTclass () + "\"] ";
                chartwlupdsql += " return  $new' ) where train_no like '" + booking_details.getTrain_no () + "' and date = '" + booking_details.getDate () + "' ";
                System.out.println (chartwlupdsql);
                stchartwl = conn.createStatement ();
                int updstat = stchartwl.executeUpdate (chartwlupdsql);
                if (updstat > 0) System.out.println ("chart_wl  waitlisting  updated");
            }
            if (useragent) agentbooksql += "<person><coach>" + currentcoach + "</coach><seat>" + currentseat + "</seat></person>";
            else userbooksql += "<person><coach>" + currentcoach + "</coach><seat>" + currentseat + "</seat></person>";
        }
        if (useragent) {
            agentbooksql += "</detail>   as first into $new/book return  $new' ) where agent_id like '" + booking_details.getUserId () + "'";
            System.out.println (agentbooksql);
            stbookings = conn.createStatement ();
            int updstat = stbookings.executeUpdate (agentbooksql);
            if (updstat > 0) System.out.println ("agent bookings updated");
        }
        else {
            userbooksql += "</detail>   as first into $new/book return  $new' ) where user_id like '" + booking_details.getUserId () + "'";
            System.out.println (userbooksql);
            stbookings = conn.createStatement ();
            int updstat = stbookings.executeUpdate (userbooksql);
            if (updstat > 0) System.out.println ("user bookings  updated");
        }
    } catch (SQLException e) {
        conn.rollback ();
        e.printStackTrace ();
    }
}


-----Function Pair=331=-----==

private List < AuthInfo > getAuthInfoDefault (DatabaseAdapter db_, Long userId, Long siteId) {
    List < AuthInfo > list = new ArrayList < AuthInfo > ();
    if (userId == null || siteId == null) {
        return list;
    }
    PreparedStatement ps = null;
    ResultSet rs = null;
    try {
        String sql = "select a.* " + "from  WM_AUTH_USER a, V$_READ_LIST_FIRM z1, WM_PORTAL_LIST_SITE x1 " + "where x1.ID_SITE=? and z1.ID_FIRM = x1.ID_FIRM and " + "      a.ID_AUTH_USER=z1.ID_AUTH_USER and a.ID_USER=?";
        ps = db_.prepareStatement (sql);
        ps.setLong (1, siteId);
        ps.setLong (1, userId);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            list.add (setAuthInfo (rs));
        }
        return list;
    } catch (Throwable e) {
        String es = "AuthInfo.getInstance() exception";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (rs, ps);
        rs = null;
        ps = null;
    }
}


public int update (String strUpdate, Map < String, Object > mapVal) throws RuntimeException {
    int rtnVal = 0;
    EntityManager em = getEntityManager ();
    if (em != null) {
        EntityTransaction et = em.getTransaction ();
        try {
            Query query = em.createQuery (strUpdate);
            if (mapVal != null) {
                for (String mKey : mapVal.keySet ()) {
                    Object mObj = mapVal.get (mKey);
                    query.setParameter (mKey, mObj);
                }
            }
            if (query != null) {
                if (et.isActive () == false) {
                    et.begin ();
                }
                rtnVal = query.executeUpdate ();
                if (et.isActive ()) {
                    et.commit ();
                }
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            em.close ();
            throw new RuntimeException (exception);
        }
        em.close ();
    }
    return rtnVal;
}


-----Function Pair=332=-----==

public Long addUserInfo (AuthSession authSession, AuthInfo authInfo, List < RoleEditableBean > roles) {
    DatabaseAdapter db = null;
    try {
        db = DatabaseAdapter.getInstance ();
        Long companyId = authSession.checkCompanyId (authInfo.getCompanyId ());
        Long holdingId = authSession.checkHoldingId (authInfo.getHoldingId ());
        Long id = addUserInfo (db, authInfo, roles, companyId, holdingId);
        db.commit ();
        return id;
    } catch (Throwable e) {
        try {
            if (db != null) db.rollback ();
        } catch (Exception e001) {
        }
        final String es = "Error add user auth";
        log.error (es, e);
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db);
        db = null;
    }
}


public void testManyParametersStatement () throws Exception {
    final int PARAMS = 2110;
    Statement stmt = con.createStatement ();
    makeTestTables (stmt);
    makeObjects (stmt, 10);
    stmt.close ();
    StringBuffer sb = new StringBuffer (PARAMS * 3 + 100);
    sb.append ("SELECT * FROM #test WHERE f_int in (?");
    for (int i = 1; i < PARAMS; i ++) {
        sb.append (", ?");
    }
    sb.append (")");
    try {
        PreparedStatement pstmt = con.prepareStatement (sb.toString ());
        for (int i = 1; i <= PARAMS; i ++) {
            pstmt.setInt (i, i);
        }
        ResultSet rs = pstmt.executeQuery ();
        int cnt = 0;
        while (rs.next ()) {
            ++ cnt;
        }
        assertEquals (9, cnt);
    } catch (SQLException ex) {
        assertEquals ("22025", ex.getSQLState ());
    }
}


-----Function Pair=333=-----==

private void processDeletedRoles (DatabaseAdapter db_, AuthUserExtendedInfo infoAuth) throws Exception {
    if (infoAuth == null || infoAuth.getAuthInfo () == null || infoAuth.getAuthInfo ().getAuthUserId () == null) {
        return;
    }
    log.info ("Start delete roles for authUserId: " + infoAuth.getAuthInfo ().getAuthUserId () + ", roles list: " + infoAuth.getRoles ());
    PreparedStatement ps = null;
    try {
        if (infoAuth.getRoles () == null) {
            log.info ("Role list is null, return.");
            return;
        }
        for (RoleEditableBean roleBeanImpl : infoAuth.getRoles ()) {
            log.info ("role: " + roleBeanImpl);
            if (! roleBeanImpl.isDelete ()) {
                continue;
            }
            ps = db_.prepareStatement ("delete from WM_AUTH_RELATE_ACCGROUP " + "where  ID_AUTH_USER=? and ID_ACCESS_GROUP=? ");
            ps.setLong (1, infoAuth.getAuthInfo ().getAuthUserId ());
            ps.setLong (2, roleBeanImpl.getRoleId ());
            ps.executeUpdate ();
            ps.close ();
            ps = null;
        }
    } finally {
        DatabaseManager.close (ps);
        ps = null;
        log.info ("End delete roles");
    }
}


protected String getInsertSql (ArchiveEntry entry) {
    Date snapDate = entry.getDate (getTimeZone ());
    String dateString = getDateAsSql (snapDate);
    String sql = "insert into " + props.getProperty (Constants.TABLE_NAME) + " ( ";
    sql = sql + " snapdate, ";
    sql = sql + " location, ";
    sql = sql + " avgInTemp, ";
    sql = sql + " avgOutTemp, ";
    sql = sql + " hiOutTemp, ";
    sql = sql + " lowOutTemp, ";
    sql = sql + " rain, ";
    sql = sql + " avgWindSpeed, ";
    sql = sql + " windDirection, ";
    sql = sql + " windGust, ";
    sql = sql + " barometer, ";
    sql = sql + " inHumidity, ";
    sql = sql + " dewpoint, ";
    sql = sql + " windchill, ";
    sql = sql + " outHumidity ) values ( '";
    sql = sql + dateString + "', ";
    sql = sql + "'" + props.getProperty (Constants.LOCATION) + "'" + ", ";
    sql = sql + (float) (entry.getAvgInTemp ()) + ", ";
    sql = sql + (float) (entry.getAvgOutTemp ()) + ", ";
    sql = sql + (float) (entry.getHiOutTemp ()) + ", ";
    sql = sql + (float) (entry.getLowOutTemp ()) + ", ";
    sql = sql + (float) (entry.getRain ()) + ", ";
    sql = sql + entry.getAvgWindSpeed () + ", ";
    sql = sql + entry.getNativeWindDirection () + ", ";
    sql = sql + entry.getWindGust () + ", ";
    sql = sql + (float) (entry.getBarometer ()) + ", ";
    sql = sql + entry.getInHumidity () + ", ";
    sql = sql + Converter.getDewpoint ((float) entry.getOutHumidity (), (float) entry.getAvgOutTemp ()) + ", ";
    sql = sql + Converter.getWindChill (entry.getWindGust (), (float) entry.getAvgOutTemp ()) + ", ";
    sql = sql + entry.getOutHumidity () + ") ";
    return sql;
}


-----Function Pair=334=-----==

protected synchronized void auditTrail (String opMode, AbstractBaseObject obj) throws ApplicationException {
    Vector oldValues = new Vector ();
    Vector newValues = new Vector ();
    DmsRelationalWord tmpDmsRelationalWord = (DmsRelationalWord) this.oldValue;
    if (tmpDmsRelationalWord != null) {
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getID ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getRecordStatus ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdateCount ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getCreatorID ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getCreateDate ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdaterID ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdateDate ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getWord ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getParentID ()));
        oldValues.add (toAuditTrailValue (tmpDmsRelationalWord.getType ()));
    }
    tmpDmsRelationalWord = (DmsRelationalWord) obj;
    if (tmpDmsRelationalWord != null) {
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getID ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getRecordStatus ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdateCount ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getCreatorID ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getCreateDate ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdaterID ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getUpdateDate ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getWord ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getParentID ()));
        newValues.add (toAuditTrailValue (tmpDmsRelationalWord.getType ()));
    }
    auditTrailBase (opMode, oldValues, newValues);
}


public int addCliente (Cliente cli) throws errorConexionBD, errorSQL {
    System.out.println ("GestorCliente.addCliente()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        sql = "SELECT nif FROM persona WHERE nif='" + cli.getNif () + "'";
        System.out.println ("Ejecuando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            throw new errorSQL ("NIF duplicado en INSERT");
        }
        gd.begin ();
        sql = "INSERT INTO persona(nif, nombre, apellido1, apellido2, " + "direccion, poblacion,telefono, movil, email, fecha_baja)" + "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setString (1, cli.getNif ());
        pstmt.setString (2, cli.getNombre ());
        pstmt.setString (3, cli.getApellido1 ());
        pstmt.setString (4, cli.getApellido2 ());
        pstmt.setString (5, cli.getDireccion ());
        pstmt.setString (6, cli.getPoblacion ());
        pstmt.setString (7, cli.getTelefono ());
        pstmt.setString (8, cli.getMovil ());
        pstmt.setString (9, cli.getEmail ());
        pstmt.setDate (10, (java.sql.Date) cli.getFechaBaja ());
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        pstmt.close ();
        rs.close ();
        sql = "INSERT INTO cliente (cod_cliente, tarjeta_credito, puntos)" + "VALUES (?,?,?) RETURNING cod_cliente";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, nuevoId);
        pstmt.setString (2, cli.getTarjetaCredito ());
        pstmt.setInt (3, 0);
        gd.commit ();
        System.out.println ("commit");
        rs = pstmt.executeQuery ();
        rs.close ();
        pstmt.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorCliente.addCliente()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


-----Function Pair=335=-----==

public int insert (String sql) {
    int id = 0;
    Connection conn = null;
    Statement stmt = null;
    Transaction tran = null;
    try {
        Session session = SessionFactory.getSession ();
        tran = session.beginTransaction ();
        conn = session.connection ();
        stmt = conn.createStatement ();
        stmt.setEscapeProcessing (false);
        int rows = stmt.executeUpdate (sql);
        if (rows > 0) {
            ResultSet rs = stmt.executeQuery ("SELECT last_insert_id()");
            if (rs.next ()) {
                id = rs.getInt (1);
            }
            rs.close ();
            rs = null;
        }
        tran.commit ();
    } catch (SQLException e) {
        tran.rollback ();
        e.printStackTrace ();
    } finally {
        try {
            if (tran != null) {
                tran = null;
            }
            if (stmt != null) {
                stmt.close ();
                stmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return id;
}


public void removeRecipe (Recipe recipe) throws Exception {
    PreparedStatement pst1 = null;
    PreparedStatement pst2 = null;
    PreparedStatement pst3 = null;
    ResultSet rs = null;
    try {
        int id = - 1;
        conn = getConnection ();
        pst1 = conn.prepareStatement ("SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? ");
        pst1.setString (1, recipe.getName ());
        pst1.setString (2, recipe.getInstructions ());
        rs = pst1.executeQuery ();
        if (rs.next ()) {
            id = rs.getInt (1);
        }
        pst2 = conn.prepareStatement ("DELETE FROM ingredients WHERE recipe_id = ? ");
        pst3 = conn.prepareStatement ("DELETE FROM recipes WHERE recipe_id = ? ");
        pst2.setInt (1, id);
        pst3.setInt (1, id);
        pst2.executeUpdate ();
        if (pst3.executeUpdate () > 0) {
            MainFrame.appendStatusText ("Resepti poistettu kannasta");
        }
        else {
            MainFrame.appendStatusText ("Resepti� poistettaessa tietokannasta tapahtui virhe");
        }
        conn.commit ();
        MainFrame.recipePanel.update ();
        MainFrame.recipePanel.update ();
    } catch (Exception e) {
        conn.rollback ();
        MainFrame.appendStatusText ("Can't remove recipe, the exception was " + e.getMessage ());
    } finally {
        try {
            if (rs != null) rs.close ();
            rs = null;
            if (pst1 != null) pst1.close ();
            pst1 = null;
            if (pst2 != null) pst2.close ();
            pst2 = null;
            if (pst3 != null) pst3.close ();
            pst3 = null;
        } catch (SQLException sqle) {
            MainFrame.appendStatusText ("Can't close database connection.");
        }
    }
}


-----Function Pair=336=-----==

private static String mysqlEscapeString (String text) {
    StringBuffer sb = new StringBuffer (text.length () * 2);
    StringCharacterIterator iterator = new StringCharacterIterator (text);
    char character = iterator.current ();
    while (character != StringCharacterIterator.DONE) {
        switch (character) {
            case '"' :
                sb.append ("\\\"");
                break;
            case '\'' :
                sb.append ("\\\'");
                break;
            case '\\' :
                sb.append ("\\\\");
                break;
            case '\r' :
                sb.append ("\\r");
                break;
            case '\n' :
                sb.append ("\\n");
                break;
            default :
                sb.append (character);
                break;
        }
        character = iterator.next ();
    }
    return sb.toString ();
}


public RestServiceResult update (RestServiceResult serviceResult, CoActivity coActivity) {
    CoActivityDAO coActivityDAO = new CoActivityDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        coActivityDAO.update (coActivity);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coActivity);
        Object [] args = {coActivity.getActivityName ()};
        if (bundle != null) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("activity.update.success"), args));
        }
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("activity.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=337=-----==

public TimmonId doGetParentId (TimmonId timmon_id) throws SecurityException, RemoteException, IllegalArgumentException, TimmonBackEndException {
    try {
        if (isTypeOf (doGetType (timmon_id), TimmonConstants.TYPE_ACTIVITY)) {
            sql_get_parent_of_activity_stmt_.setInt (1, (int) ((SQLTimmonId) timmon_id).getTimmonId ());
            ResultSet rs = sql_get_parent_of_activity_stmt_.executeQuery ();
            if ((rs != null) && (rs.next ())) {
                long id = (long) rs.getInt (1);
                rs.close ();
                return (new SQLTimmonId (id, TimmonConstants.TYPE_TASK));
            }
        }
        else {
            sql_get_parent_of_task_stmt_.setInt (1, (int) ((SQLTimmonId) timmon_id).getTimmonId ());
            ResultSet rs = sql_get_parent_of_task_stmt_.executeQuery ();
            if ((rs != null) && (rs.next ())) {
                long id = (long) rs.getInt (1);
                rs.close ();
                return (new SQLTimmonId (id, TimmonConstants.TYPE_TASK));
            }
        }
    } catch (SQLException e) {
        throw (new TimmonBackEndException (e));
    }
    return null;
}


public boolean updateAttachments (Attachments attachments) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (attachments);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=338=-----==

public static void main (String [] argv) throws Exception {
    CmdlineUtils.initializeLogging ();
    CmdlineOptions options = new CmdlineOptions ("CSVImport", argv);
    OptionsListener ohandler = new OptionsListener ();
    options.addLong (ohandler, "separator", 's', true);
    options.addLong (ohandler, "stripquotes", 'q');
    options.addLong (ohandler, "ignorelines", 'i', true);
    CmdlineUtils.registerLoggingOptions (options);
    try {
        options.parse ();
    } catch (CmdlineOptions.OptionsException e) {
        System.err.println ("Error: " + e.getMessage ());
        System.exit (1);
    }
    String [] args = options.getArguments ();
    if (args.length < 4) {
        System.err.println ("Error: wrong number of arguments.");
        usage ();
        System.exit (1);
    }
    String schema = args [0];
    String dbprops = args [1];
    String csvfile = args [2];
    String table = args [3];
    String [] columns = StringUtils.split (args [4], ",");
    Properties props = new Properties ();
    props.load (new FileInputStream (dbprops));
    DefaultConnectionFactory cfactory = new DefaultConnectionFactory (props, false);
    Connection conn = cfactory.requestConnection ();
    CSVImport ci = new CSVImport (DatabaseProjectReader.loadProject (schema), conn);
    ci.setTable (table);
    ci.setColumns (columns);
    ci.setSeparator (ohandler.separator);
    ci.setClearTable (true);
    ci.setStripQuotes (ohandler.stripquotes);
    ci.setIgnoreColumns (true);
    ci.setIgnoreLines (ohandler.ignorelines);
    ci.importCSV (new FileInputStream (csvfile));
}


public RestServiceResult check (RestServiceResult serviceResult, Long nLanguageId, String sWord) {
    List < MaSpell > listMaSpell = null;
    log.info ("nLanguageId: " + nLanguageId);
    Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.SELECT_MA_SPELL, MaSpell.class);
    query.setParameter (1, nLanguageId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listMaSpell = query.getResultList ();
    int error = 0;
    boolean revisar = true;
    String cleanWord = delDot (sWord.toLowerCase ());
    for (int i = 0; i < listMaSpell.size (); i ++) {
        error = computeLevenshteinDistance (cleanWord, listMaSpell.get (i).getWord ().toLowerCase ());
        if (error == 0) {
            serviceResult.setError (true);
            serviceResult.setMessage (bundle.getString ("spell.check.notErrorFound"));
            revisar = false;
            break;
        }
    }
    if (revisar) {
        List < MaSpell > listSpellChoises = new ArrayList < MaSpell > ();
        for (int i = 0; i < listMaSpell.size (); i ++) {
            error = computeLevenshteinDistance (cleanWord, listMaSpell.get (i).getWord ().toLowerCase ());
            if (error < 3) {
                listSpellChoises.add (listMaSpell.get (i));
            }
        }
        Object [] arrayParam = {listSpellChoises.size ()};
        if (listSpellChoises.size () == 0) {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.check.noChoises"), arrayParam));
        }
        else {
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("spell.check.success"), arrayParam));
        }
        serviceResult.setObjResult (listSpellChoises);
        serviceResult.setNumResult (listSpellChoises.size ());
    }
    return serviceResult;
}


-----Function Pair=339=-----==

public void restore (Component component, String componentName, int currentPilot) {
    try {
        PreparedStatement psta = jdbc.prepareStatement ("SELECT size_height, size_width, pos_x, pos_y " + "FROM component_prop " + "WHERE pilot_id = ? " + "AND component_name = ?");
        psta.setInt (1, currentPilot);
        psta.setString (2, componentName);
        ResultSet resl = psta.executeQuery ();
        if (resl.next ()) {
            component.setSize (resl.getInt (2), resl.getInt (1));
            Point point = new Point (resl.getInt (3), resl.getInt (4));
            component.setLocation (point);
        }
    } catch (SQLException e) {
        log.debug (e);
    }
}


public boolean updateAllocateByUID (int updateUid, int updateTid, int originalUid) {
    boolean ok = false;
    try {
        PreparedStatement stmt = getCon ().prepareStatement ("update allocate set tid=?,uid=? where tid=?");
        stmt.setInt (1, updateUid);
        stmt.setInt (2, updateTid);
        stmt.setInt (3, originalUid);
        int num = stmt.executeUpdate ();
        if (num == 1) {
            ok = true;
        }
        stmt.close ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return ok;
}


-----Function Pair=340=-----=1=

public int addDecisionInstruction (int condition, String frameSlot, String linkName, int objectId, String attribute, int positive, int negative) throws FidoDatabaseException, ObjectNotFoundException, InstructionNotFoundException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            if ((condition == ConditionalOperatorTable.CONTAINS_LINK) || (condition == ConditionalOperatorTable.NOT_CONTAINS_LINK)) {
                ObjectTable ot = new ObjectTable ();
                if (ot.contains (objectId) == false) throw new ObjectNotFoundException (objectId);
            }
            conn = fido.util.FidoDataSource.getConnection ();
            conn.setAutoCommit (false);
            stmt = conn.createStatement ();
            if (contains (stmt, positive) == false) throw new InstructionNotFoundException (positive);
            if (contains (stmt, negative) == false) throw new InstructionNotFoundException (negative);
            String sql = "insert into Instructions (Type, Operator, FrameSlot, LinkName, ObjectId, AttributeName) " + "values (2, " + condition + ", '" + frameSlot + "', '" + linkName + "', " + objectId + ", '" + attribute + "')";
            stmt.executeUpdate (sql);
            int id = getCurrentId (stmt);
            InstructionGroupTable groupTable = new InstructionGroupTable ();
            groupTable.deleteInstruction (stmt, id);
            if (positive != - 1) groupTable.addInstructionAt (stmt, id, 1, positive);
            if (negative != - 1) groupTable.addInstructionAt (stmt, id, 2, negative);
            conn.commit ();
            return id;
        } catch (SQLException e) {
            if (conn != null) conn.rollback ();
            throw e;
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public MsgRecvInfo [] recvMsg (MsgRecvReq msgRecvReq) throws SQLException {
    String updateSQL = " update dyhikemomessages set receive_id = ?, receive_Time = ?  where mo_to =? and receive_id =0  limit 20";
    String selectSQL = " select MOMSG_ID,mo_from,mo_to,create_time,mo_content from dyhikemomessages where receive_id =?  ";
    String insertSQL = " insert into t_receive_history select * from dyhikemomessages  where receive_id =?  ";
    String deleteSQL = " delete from dyhikemomessages where receive_id =? ";
    Logger logger = Logger.getLogger (this.getClass ());
    ArrayList msgInfoList = new ArrayList ();
    String mo_to = msgRecvReq.getAuthInfo ().getUserName ();
    MsgRecvInfo [] msgInfoArray = new ototype.MsgRecvInfo [0];
    String receiveTime = Const.DF.format (new Date ());
    logger.debug ("recvMsgNew1");
    Connection conn = null;
    try {
        int receiveID = this.getSegquence ("receiveID");
        conn = this.getJdbcTemplate ().getDataSource ().getConnection ();
        conn.setAutoCommit (false);
        PreparedStatement pstmt = conn.prepareStatement (updateSQL);
        pstmt.setInt (1, receiveID);
        pstmt.setString (2, receiveTime);
        pstmt.setString (3, mo_to);
        int recordCount = pstmt.executeUpdate ();
        logger.info (recordCount + " record(s) got");
        if (recordCount > 0) {
            pstmt = conn.prepareStatement (selectSQL);
            pstmt.setInt (1, receiveID);
            ResultSet rs = pstmt.executeQuery ();
            while (rs.next ()) {
                MsgRecvInfo msg = new MsgRecvInfo ();
                msg.setDestMobile (rs.getString ("mo_to"));
                msg.setRecvAddi (rs.getString ("mo_to"));
                msg.setSendAddi (rs.getString ("MO_FROM"));
                msg.setContent (rs.getString ("mo_content"));
                msg.setRecvDate (rs.getString ("create_time"));
                msgInfoList.add (msg);
            }
            msgInfoArray = (MsgRecvInfo []) msgInfoList.toArray (new MsgRecvInfo [msgInfoList.size ()]);
            pstmt = conn.prepareStatement (insertSQL);
            pstmt.setInt (1, receiveID);
            pstmt.execute ();
            pstmt = conn.prepareStatement (deleteSQL);
            pstmt.setInt (1, receiveID);
            pstmt.execute ();
            conn.commit ();
        }
        logger.debug ("recvMsgNew2");
        return msgInfoArray;
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } finally {
        if (conn != null) {
            conn.setAutoCommit (true);
            conn.close ();
        }
    }
}


-----Function Pair=341=-----==

public Boolean executeUpdateTransaction (BufferedQuery oBufferedQuery) {
    Connection oConnection = this.getConnection ();
    Boolean bAutoCommit = true;
    String sQuery;
    Statement oStatement = null;
    if (oConnection == null) {
        return false;
    }
    try {
        bAutoCommit = oConnection.getAutoCommit ();
        oConnection.setAutoCommit (false);
        oStatement = oConnection.createStatement ();
        while ((sQuery = oBufferedQuery.readQuery ()) != null) {
            oStatement.execute (sQuery);
        }
        if (bAutoCommit) {
            oConnection.commit ();
            oConnection.setAutoCommit (true);
        }
    } catch (SQLException oException) {
        if (this.reloadConnection ()) return this.executeUpdateTransaction (oBufferedQuery);
        else {
            try {
                oConnection.rollback ();
            } catch (SQLException oRollbackException) {
                throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, Strings.ROLLBACK, oRollbackException);
            }
            throw new DatabaseException (ErrorCode.DATABASE_UPDATE_QUERY, "bufferedquery", oException);
        }
    } finally {
        try {
            if (oStatement != null) oStatement.close ();
            oConnection.setAutoCommit (bAutoCommit);
        } catch (SQLException oException) {
            throw new SystemException (ErrorCode.CLOSE_QUERY, null, oException);
        }
    }
    return true;
}


public IllnessListDocument getIllnessList () {
    IllnessListDocument doc = null;
    ResultSet rsList = null;
    try {
        helper = new DBHelper ();
        doc = IllnessListDocument.Factory.newInstance ();
        PreparedStatement psList = helper.prepareStatement (SQL.getIllnessList ());
        rsList = psList.executeQuery ();
        doc.addNewIllnessList ();
        while (rsList.next ()) {
            Illness i = doc.getIllnessList ().addNewIllness ();
            i.setIllnessno (rsList.getString ("ILLNESSNO"));
            i.setIllness (rsList.getString ("ILLNESS"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsList != null) {
                rsList.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


-----Function Pair=342=-----==

public User getUser (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from User R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        User u = (User) q.uniqueResult ();
        s.getTransaction ().commit ();
        return u;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public String hasPermission (Element root, DTSPermission permit) throws SQLException, XMLException {
    if (permit == null) {
        return getTrueResult ();
    }
    String accessType = permit.getAccessType ();
    if (accessType.equals (DTSUsers.WRITE_ACCESS_TYPE)) {
        String namespaceId = root.getAttribute (ID);
        Vector stored_namespace_ids = permit.getNamespaceIds ();
        boolean isPermitted = stored_namespace_ids.contains (namespaceId);
        if (isPermitted) {
            return getTrueResult ();
        }
    }
    return getFalseResult ();
}


-----Function Pair=343=-----==

protected PostgresModelIterator getModelsUnordered (String table, String type, TupleBinding binding) {
    try {
        PreparedStatement ps = null;
        if (persistenceMethod == PostgreSQLStore.BYTEA) {
            ps = conn.prepareStatement ("select bdata, " + table + "_id from " + table + " where type = '" + type + "'");
        }
        else if (persistenceMethod == PostgreSQLStore.OID || persistenceMethod == PostgreSQLStore.FIELDS) {
            ps = conn.prepareStatement ("select oiddata, " + table + "_id from " + table + " where type = '" + type + "'");
        }
        ResultSet rs = ps.executeQuery ();
        return (new PostgresModelIterator (rs, binding, persistenceMethod, lobj));
    } catch (SQLException e) {
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    } catch (Exception e) {
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    }
    return (null);
}


public RestServiceResult search (RestServiceResult serviceResult, Long nGlossId) {
    ToGloss maGloss = new ToGlossDAO ().findById (nGlossId);
    if (maGloss == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("gloss.search.notFound"));
    }
    else {
        List < ToGloss > list = new ArrayList < ToGloss > ();
        EntityManagerHelper.refresh (maGloss);
        list.add (maGloss);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("gloss.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=344=-----==

public List getAccountNames (User u, int accountType) throws Exception {
    Session s = null;
    try {
        String query = "select A.accountName from Account A where A.ownerId=? and A.accountType=?";
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        Query q = s.createQuery (query);
        q.setLong (0, u.getUid ());
        q.setInteger (1, accountType);
        List ret = q.list ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public static synchronized void init (boolean externalDB) throws SQLException {
    DB.externalDB = externalDB;
    String configRessource = "/hibernate.cfg.xml";
    if (externalDB) {
        configRessource = "/hibernate_extern.cfg.xml";
    }
    try {
        AnnotationConfiguration configuration = new AnnotationConfiguration ();
        sessionFactory = configuration.configure (configRessource).buildSessionFactory ();
        commonSession = createSession ();
    } catch (HibernateException ex) {
        throw new SQLException ("Exception building SessionFactory: " + ex.getMessage (), ex);
    }
    try {
        synchronized (commonSession) {
            Transaction tx = commonSession.beginTransaction ();
            tx.commit ();
        }
    } catch (Exception e) {
        throw new SQLException ("Unable to access database.", e);
    }
}


-----Function Pair=345=-----==

public IllnessListDocument getIllnessList () {
    IllnessListDocument doc = null;
    ResultSet rsList = null;
    try {
        helper = new DBHelper ();
        doc = IllnessListDocument.Factory.newInstance ();
        PreparedStatement psList = helper.prepareStatement (SQL.getIllnessList ());
        rsList = psList.executeQuery ();
        doc.addNewIllnessList ();
        while (rsList.next ()) {
            Illness i = doc.getIllnessList ().addNewIllness ();
            i.setIllnessno (rsList.getString ("ILLNESSNO"));
            i.setIllness (rsList.getString ("ILLNESS"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsList != null) {
                rsList.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


public static String getSql1 (final Connection con, final String querySql) {
    final StringBuffer finalSql = new StringBuffer ();
    DatabaseMetaData dmd = null;
    String dbName = null;
    try {
        dmd = con.getMetaData ();
        dbName = dmd.getDatabaseProductName ().toLowerCase ();
        if (dbName.equals ("oracle")) {
            finalSql.append (" SELECT * FROM (");
            finalSql.append (querySql);
            finalSql.append (" ) WHERE ROWNUM =1 ");
            return finalSql.toString ();
        }
    } catch (final SQLException e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=346=-----==

public void saveStructure (long userId, TreeStructureInfo info, List < TreeStructureNode > structure) throws DatabaseException {
    if (info == null) throw new NullPointerException ("info");
    if (structure == null) throw new NullPointerException ("structure");
    try {
        getConnection ().setAutoCommit (false);
    } catch (SQLException e) {
        LOGGER.warn ("Unable to set autocommit off", e);
    }
    PreparedStatement insertInfoSt = null, insSt = null;
    try {
        insertInfoSt = getConnection ().prepareStatement (INSERT_INFO);
        insertInfoSt.setLong (1, userId);
        insertInfoSt.setString (2, info.getDescription () != null ? info.getDescription () : "");
        insertInfoSt.setString (3, info.getBarcode ());
        insertInfoSt.setString (4, info.getName ());
        insertInfoSt.setString (5, info.getInputPath ());
        insertInfoSt.setString (6, info.getModel ());
        insertInfoSt.executeUpdate ();
        PreparedStatement seqSt = getConnection ().prepareStatement (INFO_VALUE);
        ResultSet rs = seqSt.executeQuery ();
        int key = - 1;
        while (rs.next ()) {
            key = rs.getInt (1);
        }
        if (key == - 1) {
            getConnection ().rollback ();
            throw new DatabaseException ("Unable to obtain new id from DB when executing query: " + insertInfoSt);
        }
        int total = 0;
        for (TreeStructureNode node : structure) {
            insSt = getConnection ().prepareStatement (INSERT_NODE);
            insSt.setLong (1, key);
            insSt.setString (2, node.getPropId ());
            insSt.setString (3, node.getPropParent ());
            insSt.setString (4, node.getPropName ());
            insSt.setString (5, node.getPropPicture ());
            insSt.setString (6, node.getPropType ());
            insSt.setString (7, node.getPropTypeId ());
            insSt.setString (8, node.getPropPageType ());
            insSt.setString (9, node.getPropDateIssued ());
            insSt.setString (10, node.getPropAltoPath ());
            insSt.setString (11, node.getPropOcrPath ());
            insSt.setBoolean (12, node.getPropExist ());
            total += insSt.executeUpdate ();
        }
        if (total != structure.size ()) {
            getConnection ().rollback ();
            throw new DatabaseException ("Unable to insert _ALL_ nodes: " + total + " nodes were inserted of " + structure.size ());
        }
        getConnection ().commit ();
    } catch (SQLException e) {
        LOGGER.error ("Queries: \"" + insertInfoSt + "\" and \"" + insSt + "\"", e);
    } finally {
        closeConnection ();
    }
}


public boolean validateRangeExerciseS1Scored (Long nRoleUserId, CoExercises1 coExercises1, Long nUserId) {
    List < CoScoreExercises1 > listCoScoreExercises1 = new ArrayList < CoScoreExercises1 > ();
    CoScoreExercises1 coScoreExercises1 = null;
    String sFlagExerciseScore = "";
    Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_SCORE_EXERCISES1, CoScoreExercises1.class);
    query.setParameter (1, coExercises1.getExerciseId ());
    query.setParameter (2, nUserId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listCoScoreExercises1 = query.getResultList ();
    for (int i = 0; i < listCoScoreExercises1.size (); i ++) {
        coScoreExercises1 = (CoScoreExercises1) listCoScoreExercises1.get (i);
        sFlagExerciseScore = coExercises1.getFlagExerciseScore ();
    }
    if (coScoreExercises1 == null) {
        return false;
    }
    else if (sFlagExerciseScore.equalsIgnoreCase ("0")) {
        Float nScore = new Float (coScoreExercises1.getScore ());
        if (nScore < Common.CRITIC_VALUE_QUANTITATIVE || nScore >= Common.EXELLENT_VALUE_QUANTITATIVE) {
            return true;
        }
        else {
            return false;
        }
    }
    else {
        Long nScore = new Long (coScoreExercises1.getScore ());
        if (nScore < Common.CRITIC_VALUE_QUALITATIVE || nScore >= Common.EXELLENT_VALUE_QUALITATIVE) {
            return true;
        }
        else {
            return false;
        }
    }
}


-----Function Pair=347=-----==

public PTask [] match (PTaskTemplate template, SyrupConnection con) throws Exception {
    PTask p [] = new PTask [0];
    String qq = null;
    List qParts = new LinkedList ();
    qParts.add (new QueryOperation (template, "description", "description"));
    qParts.add (new QueryOperation (template, "name", "name"));
    qParts.add (new QueryOperation (template, "function_class", "functionClass"));
    qParts.add (new QueryOperation (template, "environment", "environment"));
    qParts.add (new QueryOperation (template, "parameter", "parameter"));
    qParts.add (new QueryOperation (template, "or_type", "orType"));
    qParts.add (new QueryOperation (template, "parent_key", "parentKey"));
    qParts.add (new QueryOperation (template, "key_", "key"));
    qParts.add (new QueryOperation (template, "modifications", "modifications"));
    qParts.add (new QueryOperation (template, "modification_time", "modificationTime"));
    qParts.add (new QueryOperation (template, "creation_time", "creationTime"));
    qParts.add (new QueryOperation (template, "executable", "executable"));
    qParts.add (new QueryOperation (template, "done", "done"));
    qParts.add (new QueryOperation (template, "worker", "worker"));
    qParts.add (new QueryOperation (template, "is_parent", "isParent"));
    Iterator qIterator = qParts.iterator ();
    while (qIterator.hasNext ()) {
        QueryOperation op = (QueryOperation) qIterator.next ();
        if (op.sqlOp != null) {
            if (qq != null) {
                qq = qq + " and ";
            }
            else {
                qq = " ";
            }
            qq = qq + op.sqlAtt + " " + op.sqlOp + " ?";
        }
    }
    if (qq == null) {
        qq = sqlImpl ().sqlStatements ().selectTasksStatement ();
    }
    else {
        qq = sqlImpl ().sqlStatements ().selectTasksStatement () + "where" + qq;
    }
    PreparedStatement ps = null;
    ps = con.prepareStatement (qq);
    qIterator = qParts.iterator ();
    int ii = 1;
    while (qIterator.hasNext ()) {
        QueryOperation op = (QueryOperation) qIterator.next ();
        if (op.sqlOp != null) {
            ps.setObject (ii ++, op.value);
        }
    }
    ResultSet result = null;
    try {
        result = ps.executeQuery ();
        ArrayList ptasks = new ArrayList ();
        while (result.next ()) {
            PTask t = sqlImpl ().queryFunctions ().readPTask (result);
            ptasks.add (t);
        }
        p = new PTask [ptasks.size ()];
        Object [] o = ptasks.toArray ();
        for (int i = 0; i < o.length; i ++) {
            p [i] = (PTask) o [i];
        }
    } finally {
        close (result);
    }
    return p;
}


public Comp [] loadComponents (Connection conn, int id, int noOfComponents) throws SQLException {
    Statement statement = null;
    ResultSet rs = null;
    try {
        statement = conn.createStatement ();
        String sql = getSelectComponentSQL (id);
        rs = statement.executeQuery (sql);
        Comp [] components = (Comp []) Array.newInstance (m_compClass, noOfComponents);
        initialiseComponents (components);
        int compNdx = 0;
        while (rs.next ()) {
            Comp component = null;
            try {
                component = m_compClass.newInstance ();
            } catch (InstantiationException e) {
                e.printStackTrace ();
            } catch (IllegalAccessException e) {
                e.printStackTrace ();
            }
            int colNdx = 1;
            DbColumnExt parentIdCol = m_componentTable.getParentId ();
            for (Iterator < DbColumnExt > iter = m_componentTable.getIter (0); iter.hasNext (); colNdx ++) {
                DbColumnExt column = iter.next ();
                if (column != parentIdCol) {
                    column.setVal (component, rs.getObject (colNdx));
                }
            }
            components [getCompNdx (compNdx, component)] = component;
            compNdx ++;
        }
        return components;
    } finally {
        if (statement != null) {
            statement.close ();
        }
    }
}


-----Function Pair=348=-----==

public PortfolioEntry getPortfolioEntry (long id) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from PortfolioEntry R where R.id=?";
        Query q = s.createQuery (query);
        q.setLong (0, id);
        return (PortfolioEntry) q.uniqueResult ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public void add (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            if (contains (name) == false) {
                String sql = "insert into AttributeCategories (CategoryName) " + "values ('" + name + "')";
                conn = FidoDataSource.getConnection ();
                stmt = conn.createStatement ();
                stmt.executeUpdate (sql);
            }
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=349=-----==

public Vector getChild (Connection con) throws Exception {
    Vector allChildOrg = new Vector ();
    PreparedStatement ps = null;
    ResultSet result = null;
    String strQuery = "SELECT ot.organize_id,ot.organize_type_id,organize_name,organize_manager," + "organize_describe,work_type,show_order,position_x,position_y " + "FROM " + Common.ORGANIZE_TABLE + " ot, " + Common.ORGANIZE_RELATION_TABLE + " ort " + "WHERE ot.organize_id = ort.child_id " + "AND ot.organize_type_id=ort.child_type_id " + "AND ort.organize_id = '" + this.organizeID + "' " + "AND ort.organize_type_id = '" + this.organizeTypeID + "' ";
    try {
        ps = con.prepareStatement (strQuery);
        result = ps.executeQuery ();
        int i = 1;
        ValueAsc va = new ValueAsc (i);
        while (result.next ()) {
            i = 1;
            va.setStart (i);
            Organize oTemp = Organize.generateOrganize (result, va);
            allChildOrg.addElement (oTemp);
        }
        va = null;
    } catch (SQLException se) {
        throw new CesSystemException ("Organize.getParent(): SQLException while getting inferior organize " + "where child organize_id = " + this.organizeID + " :\n\t" + se);
    } finally {
        closeResultSet (result);
        closePreparedStatement (ps);
    }
    return allChildOrg;
}


public Migration (Element p_node) {
    name = p_node.getAttribute ("name");
    contactInfo = p_node.getAttribute ("contactInfo");
    dataSource = p_node.getAttribute ("dataSource");
    NodeList nodes = p_node.getChildNodes ();
    for (int i = 0; i < nodes.getLength (); i ++) {
        if (! (nodes.item (i) instanceof Element)) continue;
        Element element = (Element) nodes.item (i);
        if ("runSQL".equals (element.getTagName ())) {
            actions.add (new RunSQLAction (element));
        }
        else if ("action".equals (element.getTagName ())) {
            String className = element.getAttribute ("class");
            actions.add ((IMigrationAction) ReflectionUtils.construct (className));
        }
    }
}


-----Function Pair=350=-----==

private Vector getItem (Hashtable examDetail) throws Exception {
    String exam_id = getParam ("exam_id");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        {
            r.add ("adm_exam_name");
            r.add ("adm_exam_id", exam_id);
            sql = r.getSQLSelect ("adm_exam");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                examDetail.put ("id", exam_id);
                examDetail.put ("name", rs.getString ("adm_exam_name"));
            }
        }
        Vector v = new Vector ();
        {
            r.clear ();
            r.add ("adm_subject_id");
            r.add ("adm_subject_name");
            r.add ("adm_grade_display_id");
            r.add ("adm_exam_id", exam_id);
            sql = r.getSQLSelect ("adm_exam_subject", "adm_exam_id");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("exam_id", exam_id);
                h.put ("subject_id", rs.getString ("adm_subject_id"));
                h.put ("subject_name", rs.getString ("adm_subject_name"));
                h.put ("grade_display_id", rs.getString ("adm_grade_display_id"));
                v.addElement (h);
            }
        }
        return v;
    } finally {
        if (db != null) db.close ();
    }
}


public static void assignRoles (String module_id, String [] roles) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        sql = "DELETE FROM role_module WHERE module_id = '" + module_id + "'";
        stmt.executeUpdate (sql);
        for (int i = 0; i < roles.length; i ++) {
            sql = "INSERT INTO role_module (module_id, user_role) VALUES ('" + module_id + "', '" + roles [i] + "')";
            stmt.executeUpdate (sql);
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=351=-----=1=

public boolean run () {
    Connection conn = null;
    Statement stmt = null;
    try {
        conn = getDataSource ().getConnection ();
        conn.setAutoCommit (false);
        conn.rollback ();
        stmt = conn.createStatement ();
        for (String task : tasks) {
            if (task.length () == 0) continue;
            LOGGER.info ("Executing SQL migration: " + task);
            stmt.executeUpdate (task);
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (Throwable th) {
        }
        throw new SystemException ("Cannot execute SQL migration", ex);
    } finally {
        try {
            if (stmt != null) stmt.close ();
        } catch (Throwable th) {
            LOGGER.error (th);
        }
        try {
            if (stmt != null) conn.close ();
        } catch (Throwable th) {
            LOGGER.error (th);
        }
    }
    return true;
}


public void testSavepoint9 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #savepoint9 (data int)");
    stmt.close ();
    con.setAutoCommit (false);
    Savepoint sp = con.setSavepoint ();
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #savepoint9 (data) VALUES (?)");
    pstmt.setInt (1, 1);
    assertTrue (pstmt.executeUpdate () == 1);
    pstmt.close ();
    stmt = con.createStatement ();
    ResultSet rs = stmt.executeQuery ("SELECT SUM(data) FROM #savepoint9");
    assertTrue (rs.next ());
    assertTrue (rs.getInt (1) == 1);
    assertTrue (! rs.next ());
    stmt.close ();
    rs.close ();
    con.commit ();
    con.rollback ();
    stmt = con.createStatement ();
    rs = stmt.executeQuery ("SELECT SUM(data) FROM #savepoint9");
    assertTrue (rs.next ());
    assertTrue ("bug [2021839]", rs.getInt (1) == 1);
    assertTrue (! rs.next ());
    stmt.close ();
    rs.close ();
    con.setAutoCommit (true);
}


-----Function Pair=352=-----==

public int executeUpdate (final IBBDBeanAPI storedProcedure, final Object...params) throws SQLException {
    int rowsUpdated = 0;
    Statement stmt = null;
    PreparedStatement pstmt = null;
    BBDAPIPrincipal principal = (BBDAPIPrincipal) ((BBDBeanAPI) storedProcedure).getBbdPrincipal ();
    try {
        if (params.length == 0) {
            stmt = getConnection (principal).createStatement ();
            rowsUpdated = stmt.executeUpdate (getSQL (storedProcedure));
            logWarnings (stmt.getWarnings ());
        }
        else {
            pstmt = getConnection (principal).prepareStatement (getSQL (storedProcedure));
            insertArguments (storedProcedure, params, pstmt);
            rowsUpdated = pstmt.executeUpdate ();
            logWarnings (pstmt.getWarnings ());
        }
        if (! getConnection (principal).getAutoCommit ()) {
            getConnection (principal).commit ();
        }
    } catch (SQLException sqle) {
        logExceptions (sqle);
        if (! getConnection (principal).getAutoCommit ()) {
            getConnection (principal).rollback ();
        }
        throw sqle;
    } finally {
        if (stmt != null) {
            stmt.close ();
        }
        if (pstmt != null) {
            pstmt.close ();
        }
    }
    return rowsUpdated;
}


public void write (String virtualWiki, String contents, boolean convertTabs, String topicName) throws Exception {
    if (virtualWiki == null || virtualWiki.length () == 0) {
        virtualWiki = Constants.DEFAULT_VWIKI;
    }
    if (convertTabs) {
        contents = Utilities.convertTabs (contents);
    }
    Connection conn = null;
    try {
        conn = DatabaseConnection.getConnection ();
        if (! exists (virtualWiki, topicName)) {
            logger.fine ("Inserting into topic " + topicName + ", " + contents);
            writeInsert (virtualWiki, contents, topicName, conn);
        }
        else {
            logger.fine ("Updating topic " + topicName + " to " + contents);
            writeUpdate (virtualWiki, contents, topicName, conn);
        }
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    if (Environment.getInstance ().isVersioningOn ()) {
        VersionManager versionManager = WikiBase.getInstance ().getVersionManager ();
        versionManager.addVersion (virtualWiki, topicName, contents, SystemTime.asDate ());
    }
}


-----Function Pair=353=-----==

public Object execute (ExecutionEvent event) throws ExecutionException {
    ISelection selection = HandlerUtil.getActiveWorkbenchWindow (event).getActivePage ().getSelection ();
    if (selection != null & selection instanceof IStructuredSelection) {
        IStructuredSelection strucSelection = (IStructuredSelection) selection;
        for (Iterator < Object > iterator = strucSelection.iterator (); iterator.hasNext ();) {
            Object element = (Object) iterator.next ();
            if (element instanceof Entity) {
                Entity entity = (Entity) element;
                if (entity instanceof Research) {
                    processResarchReport ((Research) entity, event);
                }
                else {
                    JasperPrint print = getEntityReport (entity, entity.getType ().getReport ());
                    if (print != null) {
                        ViewerApp app = new ViewerApp ();
                        app.getReportViewer ().setDocument (print);
                        app.open ();
                    }
                }
            }
        }
    }
    return null;
}


boolean checkPassword (String username, String password) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("applicant_id");
        r.add ("applicant_id", username);
        r.add ("password", password);
        sql = r.getSQLSelect ("adm_applicant");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) return true;
        else return false;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=354=-----==

private void deleteFieldContent (Object primaryKey, Connection conn) throws SQLException {
    PreparedStatement ps = null;
    String [] types = {"VARCHAR", "DATE", "INT", "FLOAT", "TEXT"};
    try {
        for (int i = 0; i < types.length; i ++) {
            ps = conn.prepareStatement (sqlConstants.get ("DELETE_" + types [i] + "_CONTENT"));
            ps.setObject (1, primaryKey);
            ps.executeUpdate ();
            ps.close ();
            ps = null;
        }
    } finally {
        if (ps != null) ps.close ();
    }
}


public HistoricalCommand getHistoricalCommand (long historyId) throws SQLException {
    PreparedStatement preparedStatement = null;
    ResultSet cursor = null;
    try {
        preparedStatement = embeddedConnection.prepareStatement (HISTORY_SELECT_SINGLE);
        preparedStatement.setLong (1, historyId);
        boolean hasResults = preparedStatement.execute ();
        if (hasResults) {
            cursor = preparedStatement.getResultSet ();
            if (cursor.next ()) {
                HistoricalCommand command = new HistoricalCommand ();
                command.setId (cursor.getLong (1));
                command.setService (cursor.getString (2));
                command.setQueryTime (cursor.getTimestamp (3));
                command.setTransactionId (cursor.getLong (4));
                CommandType type = CommandType.valueOf (cursor.getString (5));
                command.setType (type);
                command.setCommandText (cursor.getString (6));
                return command;
            }
        }
        return null;
    } finally {
        if (cursor != null) {
            try {
                cursor.close ();
            } catch (SQLException ignored) {
            }
        }
        if (preparedStatement != null) {
            try {
                preparedStatement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


-----Function Pair=355=-----==

public String getDOBOUid (String boName) {
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        String sql = "select objUID from DO_BO where type = '" + getType () + "' and sqlStr = ? ";
        PreparedStatement pstmt = con.prepareStatement (sql);
        pstmt.setString (1, boName);
        ResultSet rs = pstmt.executeQuery ();
        String boUid = null;
        if (rs.next ()) {
            boUid = rs.getString (1);
        }
        return boUid;
    } catch (SQLException ex1) {
        ex1.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
    return null;
}


public Map < Integer, ProjectDeploymentConfiguration > readProjectDeploymentConfigurations () throws AdaptationException {
    Map < Integer, ProjectDeploymentConfiguration > projDepConfigs = new HashMap < Integer, ProjectDeploymentConfiguration > ();
    Connection connection = null;
    Statement statement = null;
    ResultSet resultSet = null;
    try {
        String query = "SELECT * FROM ProjectDeploymentConfigurations";
        connection = DriverManager.getConnection (CONN_STR);
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (query);
        while (resultSet.next ()) {
            ProjectDeploymentConfiguration pdConfiguration = getProjectDeploymentConfiguration (resultSet);
            projDepConfigs.put (pdConfiguration.getID (), pdConfiguration);
        }
    } catch (SQLException ex) {
        String msg = "SQLException in readProjectDeploymentConfigurations";
        log.error (msg, ex);
        throw new AdaptationException (msg, ex);
    } finally {
        try {
            resultSet.close ();
        } catch (Exception ex) {
        }
        try {
            statement.close ();
        } catch (Exception ex) {
        }
        try {
            connection.close ();
        } catch (Exception ex) {
        }
    }
    return projDepConfigs;
}


-----Function Pair=356=-----==

public void createPartners (int C_BP_Group_ID, int C_Country_ID, int C_Region_ID, String City) {
    MBPartner bpCU = new MBPartner (m_ctx, 0, m_trx.getTrxName ());
    bpCU.setValue (AD_User_U_Name);
    bpCU.setName (AD_User_U_Name);
    bpCU.setC_BP_Group_ID (C_BP_Group_ID);
    bpCU.setIsEmployee (true);
    bpCU.setIsSalesRep (true);
    if (bpCU.save ()) {
        m_info.append (Msg.translate (m_lang, "SalesRep_ID")).append ("=").append (AD_User_U_Name).append ("\n");
    }
    else {
        log.log (Level.SEVERE, "SalesRep (User) NOT inserted");
    }
    MLocation bpLocCU = new MLocation (m_ctx, C_Country_ID, C_Region_ID, City, m_trx.getTrxName ());
    bpLocCU.save ();
    MBPartnerLocation bplCU = new MBPartnerLocation (bpCU);
    bplCU.setC_Location_ID (bpLocCU.getC_Location_ID ());
    if (! bplCU.save ()) {
        log.log (Level.SEVERE, "BP_Location (User) NOT inserted");
    }
    StringBuffer sqlCmd = new StringBuffer ("UPDATE AD_User SET C_BPartner_ID=");
    sqlCmd.append (bpCU.getC_BPartner_ID ()).append (" WHERE AD_User_ID=").append (AD_User_U_ID);
    int no = DB.executeUpdate (sqlCmd.toString (), m_trx.getTrxName ());
    if (no != 1) {
        log.log (Level.SEVERE, "User of SalesRep (User) NOT updated");
    }
    MBPartner bpCA = new MBPartner (m_ctx, 0, m_trx.getTrxName ());
    bpCA.setValue (AD_User_Name);
    bpCA.setName (AD_User_Name);
    bpCA.setC_BP_Group_ID (C_BP_Group_ID);
    bpCA.setIsEmployee (true);
    bpCA.setIsSalesRep (true);
    if (bpCA.save ()) {
        m_info.append (Msg.translate (m_lang, "SalesRep_ID")).append ("=").append (AD_User_Name).append ("\n");
    }
    else {
        log.log (Level.SEVERE, "SalesRep (Admin) NOT inserted");
    }
    MLocation bpLocCA = new MLocation (m_ctx, C_Country_ID, C_Region_ID, City, m_trx.getTrxName ());
    bpLocCA.save ();
    MBPartnerLocation bplCA = new MBPartnerLocation (bpCA);
    bplCA.setC_Location_ID (bpLocCA.getC_Location_ID ());
    if (! bplCA.save ()) {
        log.log (Level.SEVERE, "BP_Location (Admin) NOT inserted");
    }
    sqlCmd = new StringBuffer ("UPDATE AD_User SET C_BPartner_ID=");
    sqlCmd.append (bpCA.getC_BPartner_ID ()).append (" WHERE AD_User_ID=").append (AD_User_ID);
    no = DB.executeUpdate (sqlCmd.toString (), m_trx.getTrxName ());
    if (no != 1) {
        log.log (Level.SEVERE, "User of SalesRep (Admin) NOT updated");
    }
}


private ItemSelecionavel [] obterOpcoesDeFiltro (String pNomeDaProcedure, String pNomeDaColunaChave, String pNomeDaColunaDaSigla, String pNomeDaColunaDescritiva) throws SQLException {
    String sql = "{ call ? := PC_CONSULTAS." + pNomeDaProcedure + "() }";
    CallableStatement stmtDestino = this.conDestino.prepareCall (sql);
    stmtDestino.registerOutParameter (1, OracleTypes.CURSOR);
    stmtDestino.execute ();
    ResultSet rs = (ResultSet) stmtDestino.getObject (1);
    ArrayList < ItemSelecionavel > opcoes = new ArrayList < ItemSelecionavel > ();
    int chave;
    String sigla, descricao;
    while (rs.next ()) {
        chave = rs.getInt (pNomeDaColunaChave);
        if (pNomeDaColunaDaSigla == null) {
            sigla = null;
        }
        else {
            sigla = rs.getString (pNomeDaColunaDaSigla);
        }
        descricao = rs.getString (pNomeDaColunaDescritiva);
        opcoes.add (new ItemSelecionavelImpl (chave, sigla, descricao));
    }
    return opcoes.toArray (new ItemSelecionavel [] {});
}


-----Function Pair=357=-----==

public static SessionProperty setAttributeBatch (String type, HttpSession session, User user) throws CesSystemException {
    SessionProperty sp = null;
    if (type.equals (UserSession.STORE_SESSION)) {
        sp = new SessionProperty (session);
    }
    else {
        sp = new SessionProperty ();
    }
    Vector authorities = null;
    try {
        authorities = AuthContext.getInstance ().getUserAuthAssign (user.getUserID ());
        Hashtable extrAuths = AuthContext.getInstance ().getUserExtrAuthAssign (user.getUserID ());
        if (authorities == null) {
            authorities = user.getAuthoritiesFromContext ();
            extrAuths = new Hashtable ();
            if (authorities != null && authorities.size () > 0) {
                Authority au = null;
                for (int i = 0; i < authorities.size ();) {
                    au = (Authority) authorities.get (i);
                    if (au.getAuthorityType ().trim ().equals (Authority.TYPE_EXTERNAL)) {
                        extrAuths.put (au.getAuthorityID () + "", au);
                        authorities.remove (i);
                    }
                    else {
                        i ++;
                    }
                }
            }
            AuthContext.getInstance ().setUserAuthAssign (user.getUserID (), authorities);
            AuthContext.getInstance ().setUserExtrAuthAssign (user.getUserID (), extrAuths);
        }
        sp.setAttribute ("extrauthority", extrAuths);
        sp.setAttribute ("authority", authorities);
        sp.setAttribute ("user", user);
        sp.setAttribute ("sa", user.getFlagSA ());
        Organize org = user.getOrgOfUser ();
        Vector rs = new Vector ();
        if (org != null) {
            rs = Organize.getAllParents (org);
            rs.add (0, org);
        }
        sp.setAttribute ("organizes", rs);
    } catch (CesSystemException e) {
        throw e;
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    return sp;
}


public String [] getSiteChannelPaths (String docTypPath, boolean isFindParentNode) throws Exception {
    if (docTypPath == null) {
        return new String [0];
    }
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    List list = new ArrayList ();
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        resultSet = dbo.select ("select chan_path from t_ip_doctype_channel where doctype_path='" + docTypPath + "'");
        while (resultSet.next ()) {
            list.add (resultSet.getString (1));
        }
    } catch (Exception ex) {
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
    String [] result = new String [list.size ()];
    for (int i = 0; i < result.length; i ++) {
        result [i] = (String) list.get (i);
    }
    return result;
}


-----Function Pair=358=-----==

public void executeSelect (String tableName, Vector vField, Field fieldID) throws Throwable {
    log.info ("<<<<<< ApplicDBManager.executeSelect >>>>>> Begin ");
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        conn = getConnection ();
        String listColDB = "";
        for (int i = 0; i < vField.size (); i ++) {
            if (i != 0) listColDB += ", ";
            listColDB += ((Field) vField.elementAt (i)).getID ();
        }
        String query = " SELECT " + listColDB + "   FROM " + tableName + "  WHERE " + fieldID.getID () + " = " + fieldID.getValue ();
        log.info ("<<<<<< ApplicDBManager.executeSelect query = '" + query + "'");
        stmt = conn.createStatement ();
        rs = stmt.executeQuery (query);
        if (rs.next ()) {
            for (int i = 0; i < vField.size (); i ++) setFieldValueFromResultSet (rs, i + 1, (Field) vField.elementAt (i));
        }
        log.info ("<<<<<< ApplicDBManager.executeSelect >>>>>>  End ");
    } catch (Exception e) {
        manageException (e, "executeSelect");
    } finally {
        closeQueryObjects (rs, stmt);
        closeConnection (conn);
    }
}


public void testOutputParams () throws Exception {
    Statement stmt = con.createStatement ();
    dropProcedure ("#jtds_outputTest");
    Object [] [] datatypes = getDatatypes ();
    for (int i = 0; i < datatypes.length; i ++) {
        String valueToAssign;
        boolean bImage = datatypes [i] [0].equals ("image");
        if (bImage) {
            valueToAssign = "";
        }
        else {
            valueToAssign = " = " + datatypes [i] [1];
        }
        String sql = "create procedure #jtds_outputTest " + "@a1 " + datatypes [i] [0] + " = null out " + "as select @a1" + valueToAssign;
        stmt.executeUpdate (sql);
        for (int pass = 0; (pass < 2 && ! bImage) || pass < 1; pass ++) {
            CallableStatement cstmt = con.prepareCall ("{call #jtds_outputTest(?)}");
            int jtype = getType (datatypes [i] [2]);
            if (pass == 1) cstmt.setObject (1, null, jtype, 10);
            if (jtype == java.sql.Types.NUMERIC || jtype == java.sql.Types.DECIMAL) {
                cstmt.registerOutParameter (1, jtype, 10);
                if (pass == 0) {
                    cstmt.setObject (1, datatypes [i] [2], jtype, 10);
                }
            }
            else if (jtype == java.sql.Types.VARCHAR) {
                cstmt.registerOutParameter (1, jtype);
                if (pass == 0) {
                    cstmt.setObject (1, datatypes [i] [2]);
                }
            }
            else {
                cstmt.registerOutParameter (1, jtype);
                if (pass == 0) {
                    cstmt.setObject (1, datatypes [i] [2]);
                }
            }
            assertEquals (bImage, cstmt.execute ());
            while (cstmt.getMoreResults () || cstmt.getUpdateCount () != - 1);
            if (jtype == java.sql.Types.VARBINARY) {
                assertTrue (compareBytes (cstmt.getBytes (1), (byte []) datatypes [i] [2]) == 0);
            }
            else if (datatypes [i] [2] instanceof Number) {
                Number n = (Number) cstmt.getObject (1);
                if (n != null) {
                    assertEquals ("Failed on " + datatypes [i] [0], n.doubleValue (), ((Number) datatypes [i] [2]).doubleValue (), 0.001);
                }
                else {
                    assertEquals ("Failed on " + datatypes [i] [0], n, datatypes [i] [2]);
                }
            }
            else {
                assertEquals ("Failed on " + datatypes [i] [0], cstmt.getObject (1), datatypes [i] [2]);
            }
            cstmt.close ();
        }
        stmt.executeUpdate (" drop procedure #jtds_outputTest");
    }
    stmt.close ();
}


-----Function Pair=359=-----==

public void testWriteDate () throws SQLException {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("CREATE TABLE #testWriteDate (d DATETIME)");
    stmt.close ();
    long time = System.currentTimeMillis ();
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #testWriteDate VALUES (?)");
    pstmt.setDate (1, new Date (time));
    pstmt.executeUpdate ();
    pstmt.close ();
    pstmt = con.prepareStatement ("SELECT * FROM #testWriteDate WHERE d=?");
    pstmt.setDate (1, new Date (time + 10));
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertTrue (time - rs.getDate (1).getTime () < 24 * 60 * 60 * 1000);
    Calendar c1 = new GregorianCalendar (), c2 = new GregorianCalendar ();
    c1.setTime (rs.getTimestamp (1));
    c2.setTime (new Timestamp (time));
    assertEquals (c2.get (Calendar.YEAR), c1.get (Calendar.YEAR));
    assertEquals (c2.get (Calendar.MONTH), c1.get (Calendar.MONTH));
    assertEquals (c2.get (Calendar.DAY_OF_MONTH), c1.get (Calendar.DAY_OF_MONTH));
    assertEquals (0, c1.get (Calendar.HOUR));
    assertEquals (0, c1.get (Calendar.MINUTE));
    assertEquals (0, c1.get (Calendar.SECOND));
    assertEquals (0, c1.get (Calendar.MILLISECOND));
    rs.close ();
    pstmt.close ();
    stmt = con.createStatement ();
    rs = stmt.executeQuery ("select datepart(hour, d), datepart(minute, d)," + " datepart(second, d), datepart(millisecond, d)" + " from #testWriteDate");
    assertTrue (rs.next ());
    assertEquals (0, rs.getInt (1));
    assertEquals (0, rs.getInt (2));
    assertEquals (0, rs.getInt (3));
    assertEquals (0, rs.getInt (4));
    assertFalse (rs.next ());
    rs.close ();
    stmt.close ();
}


public Department findByName (String name) throws DBConnectionException, SelectException {
    Department dpt = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("DEPARTMENT_NAME", name);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (DepartmentDAO.TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                dpt = new Department (result.getString ("DEPARTMENT_NAME"), result.getString ("DEPARTMENT_DESCRIPTION"), result.getString ("DEPARTMENT_ACRONYM"), null);
                dpt.setId (result.getInt ("DEPARTMENT_ID"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return dpt;
}


-----Function Pair=360=-----==

private void academic_save (HttpSession session) throws Exception {
    Hashtable info = new Hashtable ();
    info.put ("applicant_id", getParam ("applicant_id"));
    Vector examInfo = (Vector) session.getAttribute ("examInfo");
    for (int i = 0; i < examInfo.size (); i ++) {
        Hashtable exam = (Hashtable) examInfo.elementAt (i);
        String exam_id = (String) exam.get ("id");
        Vector subjects = (Vector) exam.get ("subjects");
        for (int k = 0; k < subjects.size (); k ++) {
            Hashtable subject = (Hashtable) subjects.elementAt (k);
            String subject_id = (String) subject.get ("id");
            info.put (subject_id, getParam (subject_id));
        }
    }
    ExamResultData.save (examInfo, info);
}


public void saveDocumentPreviewData (String documentId, int page, InputStream data, String contentType, int type, int width, int height, float aspectRatio) {
    logger.debug ("saveDocumentPreviewData(%s, %s, %s, %s, %s, %s, %s, %s)", documentId, String.valueOf (page), data, contentType, type, width, height, aspectRatio);
    Connection connection = null;
    NamedParameterStatement statement = null;
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA));
        statement.setString (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_ID_DOCUMENT, documentId);
        statement.setInt (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_PAGE, page);
        statement.setBinaryStream (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_DATA, data);
        statement.setString (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_CONTENTTYPE, contentType);
        statement.setInt (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_TYPE, type);
        statement.setInt (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_WIDTH, width);
        statement.setInt (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_HEIGHT, height);
        statement.setFloat (QueryStore.INSERT_DOCUMENT_PREVIEW_DATA_PARAM_ASPECT_RATIO, aspectRatio);
        statement.executeUpdate ();
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (statement);
        close (connection);
    }
}


-----Function Pair=361=-----==

public MetaDatabase (OrmHandler ormHandler, OrmUjo database, MetaDatabase param) {
    this.ormHandler = ormHandler;
    ROOT.setValue (this, database);
    if (param != null) {
        changeDefault (this, SCHEMA, SCHEMA.of (param));
        changeDefault (this, DIALECT, DIALECT.of (param));
        changeDefault (this, JDBC_URL, JDBC_URL.of (param));
        changeDefault (this, JDBC_DRIVER, JDBC_DRIVER.of (param));
        changeDefault (this, USER, USER.of (param));
        changeDefault (this, PASSWORD, PASSWORD.of (param));
        changeDefault (this, JNDI, JNDI.of (param));
        changeDefault (this, SEQUENCER, SEQUENCER.of (param));
    }
    Db annotDB = database.getClass ().getAnnotation (Db.class);
    if (annotDB != null) {
        changeDefault (this, SCHEMA, annotDB.schema ());
        changeDefault (this, DIALECT, annotDB.dialect ());
        changeDefault (this, JDBC_URL, annotDB.jdbcUrl ());
        changeDefault (this, JDBC_DRIVER, annotDB.jdbcDriver ());
        changeDefault (this, USER, annotDB.user ());
        changeDefault (this, PASSWORD, annotDB.password ());
        changeDefault (this, JNDI, Arrays.asList (annotDB.jndi ()));
        changeDefault (this, SEQUENCER, annotDB.sequencer ());
    }
    changeDefault (this, ID, database.getClass ().getSimpleName ());
    changeDefault (this, JDBC_URL, getDialect ().getJdbcUrl ());
    changeDefault (this, JDBC_DRIVER, getDialect ().getJdbcDriver ());
    for (UjoProperty tableProperty : database.readProperties ()) {
        if (tableProperty instanceof RelationToMany) {
            RelationToMany tProperty = (RelationToMany) tableProperty;
            MetaTable par = param != null ? param.findTable (tProperty.getName ()) : null;
            MetaTable table = new MetaTable (this, tProperty, par);
            TABLES.addItem (this, table);
            ormHandler.addTableModel (table);
        }
        else if (tableProperty.isTypeOf (DbProcedure.class)) {
            UjoProperty tProcedure = tableProperty;
            MetaProcedure par = param != null ? param.findProcedure (tProcedure.getName ()) : null;
            MetaProcedure procedure = new MetaProcedure (this, tProcedure, par);
            PROCEDURES.addItem (this, procedure);
            ormHandler.addProcedureModel (procedure);
        }
    }
    if (ADD_DB_MODEL) {
        @SuppressWarnings ("unchecked")
        RelationToMany relation = new RelationToMany (SCHEMA.of (this), database.getClass ());
        MetaTable table = new MetaTable (this, relation, null);
        table.setNotPersistent ();
        TABLES.addItem (this, table);
        ormHandler.addTableModel (table);
    }
}


public static final List < Map < String, String > > getTableStruct (final String tableName, final Connection conn) {
    final List < Map < String, String > > result = new ArrayList < Map < String, String > > ();
    Statement stmt = null;
    ResultSet rs = null;
    try {
        final String sql = StringsUtils.u ("SELECT * FROM ", tableName, " WHERE 1>1");
        stmt = conn.createStatement ();
        rs = stmt.executeQuery (sql);
        final ResultSetMetaData metaData = rs.getMetaData ();
        Map < String, String > rowMap;
        final int colsLen = metaData.getColumnCount () + 1;
        for (int i = 1; i < colsLen; i ++) {
            rowMap = new HashMap < String, String > ();
            rowMap.put ("FIELD", metaData.getColumnName (i));
            rowMap.put ("ZHCN", metaData.getColumnLabel (i));
            rowMap.put ("DATATYPE", metaData.getColumnTypeName (i));
            rowMap.put ("DATACLASS", metaData.getColumnClassName (i));
            rowMap.put ("DATASIZE", String.valueOf (metaData.getColumnDisplaySize (i)));
            result.add (rowMap);
        }
    } catch (final Exception e) {
    } finally {
        closeAll (rs, stmt, null);
    }
    return result;
}


-----Function Pair=362=-----==

private void formatResultSet (ResultSet r) {
    if (r == null) {
        String [] g = new String [1];
        g [0] = "Result";
        gResult.setHead (g);
        g [0] = "(empty)";
        gResult.addRow (g);
        return;
    }
    try {
        ResultSetMetaData m = r.getMetaData ();
        int col = m.getColumnCount ();
        Object [] h = new Object [col];
        boolean [] isVarChar = new boolean [col];
        for (int i = 1; i <= col; i ++) {
            h [i - 1] = m.getColumnLabel (i);
            isVarChar [i - 1] = (m.getColumnType (i) == java.sql.Types.VARCHAR);
        }
        gResult.setHead (h);
        while (r.next ()) {
            for (int i = 1; i <= col; i ++) {
                try {
                    h [i - 1] = r.getObject (i);
                    if (r.wasNull ()) {
                        h [i - 1] = (isVarChar [i - 1] ? NULL_STR : null);
                    }
                } catch (SQLException e) {
                }
            }
            gResult.addRow (h);
        }
        r.close ();
    } catch (SQLException e) {
        CommonSwing.errorMessage (e);
    }
}


public List Delete (String [] uids) throws NpsException {
    if (uids == null || uids.length == 0) return null;
    if (! IsSysAdmin () && ! IsLocalAdmin ()) throw new NpsException (ErrorHelper.ACCESS_NOPRIVILEGE);
    ArrayList list = new ArrayList (uids.length);
    Connection conn = null;
    try {
        conn = Database.GetDatabase ("nps").GetConnection ();
        conn.setAutoCommit (false);
        for (Object obj : uids) {
            String uid = (String) obj;
            if (uid == null || uid.length () == 0) continue;
            User aUser = null;
            String owner = null;
            try {
                aUser = GetUser (conn, uid);
                if (aUser == null) continue;
                owner = GetDefaultOwner (conn, aUser.GetUnit (), uids);
            } catch (Exception e) {
                nps.util.DefaultLog.error_noexception (e);
                continue;
            }
            Delete (conn, aUser, owner);
            list.add (uid);
        }
        conn.commit ();
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (Exception e1) {
        }
        list.clear ();
        nps.util.DefaultLog.error (e);
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (Exception e1) {
        }
    }
    return list;
}


-----Function Pair=363=-----==

public void testNonUniqueResultExceptionThrown () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        Person p2 = new Person (102, "Barney", "Rubble", "barney.rubble@jpox.com");
        em.persist (p2);
        em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T where T.firstName <> 'Wilma' ").getSingleResult ();
        fail ("expected NonUniqueResultException");
    } catch (NonUniqueResultException ex) {
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


public synchronized boolean setup (String datasetIdentifier) throws PXObjectStoreException {
    if (! _isSetup) {
        try {
            String aUrl;
            if (datasetIdentifier != null) {
                aUrl = URL_PREFIX + datasetIdentifier;
            }
            else {
                aUrl = DEFAULT_URL;
            }
            _storeProperties.put (Environment.URL, aUrl);
            _configuration = new Configuration ();
            _configuration.addProperties (_storeProperties);
            _isSetup = true;
            _version.ensureCurrent (this);
        } catch (Exception e) {
            LOG.warn (null, e);
            try {
                doTeardown ();
            } catch (Exception ignore) {
            }
            _isSetup = false;
            throw new PXObjectStoreException (e);
        }
    }
    else {
        throw new PXObjectStoreException ("attempt to setup() PXObjectStore that is already setup()");
    }
    return _isSetup;
}


-----Function Pair=364=-----==

public int addPedido (Pedido pe) throws errorConexionBD, errorSQL {
    System.out.println ("GestorPedido.addPedido()");
    String sql;
    PreparedStatement pstmt = null;
    Statement stmt = null;
    ResultSet rs = null;
    int nuevoId = 0;
    try {
        gd.begin ();
        sql = "INSERT INTO pedido(id_cliente, id_promocion, id_producto, " + "importe, fecha) VALUES (?, ?, ?, ?, ?) RETURNING id";
        System.out.println ("Ejecuando: " + sql);
        pstmt = gd.getConexion ().prepareStatement (sql);
        pstmt.setInt (1, pe.getIdCliente ());
        pstmt.setInt (2, pe.getIdPromocion ());
        pstmt.setInt (3, pe.getIdProducto ());
        pstmt.setFloat (4, pe.getImporte ());
        if (pe.getFecha () != null) {
            pstmt.setDate (5, new java.sql.Date (pe.getFecha ().getTime ()));
        }
        else {
            pstmt.setNull (5, Types.DATE);
        }
        rs = pstmt.executeQuery ();
        System.out.println ("Devolviendo el nuevo ID");
        if (rs.next ()) {
            nuevoId = rs.getInt (1);
            System.out.println ("Nuevo id: " + nuevoId);
        }
        gd.commit ();
        System.out.println ("commit");
        pstmt.close ();
        rs.close ();
        return nuevoId;
    } catch (SQLException e) {
        System.err.println ("Error en GestorPedido.addPedido()");
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
}


public int getRondaActual (int idDivision) {
    int dato = 0;
    try {
        String sql = "SELECT rondaActual FROM divisionxTorneo " + " WHERE idDivisionxTorneo = " + idDivision;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            dato = populateRondaActual (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return dato;
}


-----Function Pair=365=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("from Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=366=-----==

public void testSavepoint4 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #savepoint4 (data int)");
    stmt.close ();
    con.setAutoCommit (false);
    for (int i = 0; i < 3; i ++) {
        System.out.println ("iteration: " + i);
        PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #savepoint4 (data) VALUES (?)");
        pstmt.setInt (1, 1);
        assertTrue (pstmt.executeUpdate () == 1);
        Savepoint savepoint = con.setSavepoint ();
        assertNotNull (savepoint);
        assertTrue (savepoint.getSavepointId () == 1);
        try {
            savepoint.getSavepointName ();
            assertTrue (false);
        } catch (SQLException e) {
        }
        pstmt.setInt (1, 2);
        assertTrue (pstmt.executeUpdate () == 1);
        pstmt.close ();
        pstmt = con.prepareStatement ("SELECT SUM(data) FROM #savepoint4");
        ResultSet rs = pstmt.executeQuery ();
        assertTrue (rs.next ());
        assertTrue (rs.getInt (1) == 3);
        assertTrue (! rs.next ());
        pstmt.close ();
        rs.close ();
        con.rollback (savepoint);
        pstmt = con.prepareStatement ("SELECT SUM(data) FROM #savepoint4");
        rs = pstmt.executeQuery ();
        assertTrue (rs.next ());
        assertTrue (rs.getInt (1) == 1);
        assertTrue (! rs.next ());
        pstmt.close ();
        rs.close ();
        con.rollback ();
    }
    con.setAutoCommit (true);
}


public RestServiceResult search (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    if (maUser == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("user.search.notFound"));
    }
    else {
        List < MaUser > list = new ArrayList < MaUser > ();
        list.add (maUser);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=367=-----==

private ArrayList runStoreProc (String spName, String query1, String query2, PreviewOptions options) throws SQLException {
    CallableStatement cs = null;
    Categories.dataDb ().debug ("Running " + spName + " with following 2 statements \n " + " [ " + query1 + "] \n" + " [ " + query2 + "] ");
    try {
        cs = conn.prepareCall ("{? = call " + spName + " (?,?)}");
        cs.setString (2, query1);
        cs.setString (3, query2);
        cs.registerOutParameter (1, Types.ARRAY);
        cs.setMaxRows (options.getLimit ());
        ArrayList cons = new ArrayList (10);
        ResultSet rs = cs.executeQuery ();
        while (rs.next ()) {
            long conGid = rs.getLong (1);
            cons.add (new Long (conGid));
        }
        return cons;
    } finally {
        if (cs != null) {
            cs.close ();
        }
    }
}


public static void save (ConfigurationScenario cs) throws SQLException {
    boolean autocommit = DatabaseConnector.getInstance ().getConn ().getAutoCommit ();
    try {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (false);
        if (cs.isNew ()) {
            PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement ("INSERT INTO ConfigurationScenario (SolverBinaries_idSolverBinary, Experiment_idExperiment) VALUES (?, ?)", Statement.RETURN_GENERATED_KEYS);
            st.setInt (1, cs.getIdSolverBinary ());
            st.setInt (2, cs.getIdExperiment ());
            st.executeUpdate ();
            ResultSet generatedKeys = st.getGeneratedKeys ();
            if (generatedKeys.next ()) {
                cs.setId (generatedKeys.getInt (1));
            }
            generatedKeys.close ();
            st.close ();
        }
        else if (cs.isModified ()) {
            PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement ("UPDATE ConfigurationScenario SET SolverBinaries_idSolverBinary = ? WHERE Experiment_idExperiment = ?");
            st.setInt (1, cs.getIdSolverBinary ());
            st.setInt (2, cs.getIdExperiment ());
            st.executeUpdate ();
            st.close ();
        }
        cs.setSaved ();
        Statement st = DatabaseConnector.getInstance ().getConn ().createStatement ();
        st.executeUpdate ("DELETE FROM ConfigurationScenario_has_Parameters WHERE ConfigurationScenario_idConfigurationScenario = " + cs.getId ());
        st.close ();
        PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("INSERT INTO ConfigurationScenario_has_Parameters (ConfigurationScenario_idConfigurationScenario, Parameters_idParameter, configurable, fixedValue) VALUES (?, ?, ?, ?)");
        for (ConfigurationScenarioParameter param : cs.getParameters ()) {
            ps.setInt (1, cs.getId ());
            param.setIdConfigurationScenario (cs.getId ());
            ps.setInt (2, param.getIdParameter ());
            ps.setBoolean (3, param.isConfigurable ());
            ps.setString (4, param.getFixedValue ());
            ps.addBatch ();
            param.setSaved ();
        }
        ps.executeBatch ();
        ps.close ();
        if (cs.getCourse () != null && ! cs.getCourse ().isSaved ()) {
            PreparedStatement st2 = DatabaseConnector.getInstance ().getConn ().prepareStatement ("INSERT INTO Course (ConfigurationScenario_idConfigurationScenario, Instances_idInstance, seed, `order`) VALUES (?, ?, ?, ?)");
            for (int i = cs.getCourse ().getModifiedIndex (); i < cs.getCourse ().getLength (); i ++) {
                st2.setInt (1, cs.getId ());
                InstanceSeed is = cs.getCourse ().get (i);
                st2.setInt (2, is.instance.getId ());
                st2.setInt (3, is.seed);
                st2.setInt (4, i);
                st2.addBatch ();
            }
            st2.executeBatch ();
            st2.close ();
            Statement stmnt = DatabaseConnector.getInstance ().getConn ().createStatement ();
            stmnt.executeUpdate ("UPDATE ConfigurationScenario SET initial_course_length = " + cs.getCourse ().getLength () + " WHERE idConfigurationScenario = " + cs.getId ());
            stmnt.close ();
            cs.getCourse ().setInitialLength (cs.getCourse ().getLength ());
            cs.getCourse ().setSaved ();
        }
        else if (cs.getCourse () == null) {
            cs.setCourse (new Course ());
        }
    } catch (Exception ex) {
        DatabaseConnector.getInstance ().getConn ().rollback ();
        if (ex instanceof SQLException) {
            throw (SQLException) ex;
        }
    } finally {
        DatabaseConnector.getInstance ().getConn ().setAutoCommit (autocommit);
    }
}


-----Function Pair=368=-----==

public static void setAuditRecord (String messageid, String message) throws Exception {
    log.debug ("Adding audit  message");
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tx = session.beginTransaction ();
    Audit auditTable = new Audit ();
    auditTable.setMessageid (messageid);
    auditTable.setAction (message);
    try {
        session.saveOrUpdate (auditTable);
        tx.commit ();
    } catch (Exception e) {
        log.debug ("Rolled Back Transaction: " + e);
        tx.rollback ();
        throw new Exception (e);
    }
    return;
}


public void lock (String oid, String key) throws PersisterException {
    String lock = getLock (oid);
    if (lock == null) {
        throw new PersisterException ("Object does not exist: OID = " + oid);
    }
    else if (! NULL.equals (lock) && (! lock.equals (key))) {
        throw new PersisterException ("The object is currently locked with another key: OID = " + oid + ", LOCK = " + lock + ", KEY = " + key);
    }
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("update " + _table_name + " set " + _key_col + " = ?, " + _ts_col + " = ? where " + _oid_col + " = ?");
        ps.setString (1, key);
        ps.setLong (2, System.currentTimeMillis ());
        ps.setString (3, oid);
        ps.executeUpdate ();
    } catch (Throwable th) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (Throwable th2) {
            }
        }
        throw new PersisterException ("Failed to lock object: OID = " + oid + ", KEY = " + key, th);
    } finally {
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=369=-----==

private void addAssociations (HashMap assocMap, long associationGid, String assocSeqName, QuerySession qs) throws SQLException {
    Categories.dataDb ().debug ("Adding associations ...");
    if (addAssociationStmt == null) {
        String addAssocStmt = this.subsetDAO.getStatement (SubsetDb.TABLE_KEY, ADD_ASSOCIATIONS);
        addAssociationStmt = this.conn.prepareStatement (addAssocStmt);
        int smallBatchSize = 1000;
        if (SQL.getConnType (conn).equals (SQL.ORACLE)) {
            ((oracle.jdbc.driver.OraclePreparedStatement) addAssociationStmt).setExecuteBatch (smallBatchSize);
        }
    }
    qs.startExecute (addAssociationStmt);
    int count = 0;
    Iterator keys = assocMap.keySet ().iterator ();
    while (keys.hasNext ()) {
        Long fromCon = (Long) keys.next ();
        Vector toCons = (Vector) assocMap.get (fromCon);
        for (int i = 0; i < toCons.size (); i ++) {
            Long toCon = (Long) toCons.elementAt (i);
            addAssociationStmt.setLong (1, fromCon.longValue ());
            addAssociationStmt.setLong (2, associationGid);
            addAssociationStmt.setLong (3, toCon.longValue ());
            if (assocSeqName != null && assocSeqName.length () > 0) {
                long iid = this.getInstanceId (assocSeqName, IIDGenerator.getNamespaceIdFromGid (associationGid));
                addAssociationStmt.setLong (4, iid);
            }
            addAssociationStmt.executeUpdate ();
            if ((++ count % 1000) == 0) {
                Categories.dataDb ().debug ("Added [" + count + "] associations...");
            }
        }
    }
    qs.endExecute ();
    Categories.dataDb ().debug ("Added [" + count + "] associations...");
}


public static Any addDocType (Connection con, Any values, Any retValue) throws SQLException {
    HashMap mapPar = (HashMap) values.extract_Value ();
    String sName = (String) mapPar.get ("NAME");
    String sAutoNum = (String) mapPar.get ("AUTONUM");
    String sID = (String) mapPar.get ("ID");
    int iTempType = (Integer) mapPar.get ("TEMPTYPE");
    String sDocForm = (String) mapPar.get ("DOCFORM");
    HashMap [] attrs = (HashMap []) mapPar.get ("ATTR");
    byte [] tempData = (byte []) mapPar.get ("TEMPDATA");
    OracleCallableStatement ps = null;
    String sSql = ResourceBundle.getBundle (Documents.class.getName ()).getString ("addDocType");
    try {
        ArrayList < ObjAttr > arObjAttr = new ArrayList < ObjAttr > ();
        for (HashMap attr : attrs) {
            arObjAttr.add (new ObjAttr ((String) attr.get ("NAME"), (String) attr.get ("TYPE"), (String) attr.get ("DESC")));
        }
        ObjAttrs arAttrs = new ObjAttrs (arObjAttr.toArray (new ObjAttr [arObjAttr.size ()]));
        ps = (OracleCallableStatement) con.prepareCall (sSql);
        BLOB blb = null;
        ps.setString (1, sName);
        ps.setString (2, sAutoNum);
        ps.setString (3, sDocForm);
        switch (iTempType) {
            case 1 :
            case 2 :
                blb = BLOB.createTemporary (con, true, BLOB.DURATION_SESSION);
                blb.setBytes (1, tempData);
                ps.setBlob (4, blb);
                break;
            default :
                ps.setNull (4, Types.BLOB);
                break;
        }
        ps.setORAData (5, arAttrs);
        if (sID != null) ps.setString (6, sID);
        else ps.setNull (6, Types.INTEGER);
        ps.setInt (7, iTempType);
        ps.executeUpdate ();
        con.commit ();
        ps.close ();
        if (blb != null) BLOB.freeTemporary (blb);
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


-----Function Pair=370=-----==

public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        sql = "DELETE FROM usuario WHERE cod_usuario =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


public void testUpdateSetNullUnionSubclass () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("update Vehicle set owner = 'Steve'").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    count = s.createQuery ("update Vehicle set owner = null where owner = 'Steve'").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    count = s.createQuery ("delete Vehicle where owner is null").executeUpdate ();
    assertEquals ("incorrect restricted update count", 4, count);
    t.commit ();
    s.close ();
    data.cleanup ();
}


-----Function Pair=371=-----==

private void Delete (Connection conn, User user, String owner) throws NpsException {
    PreparedStatement pstmt = null;
    String sql = null;
    try {
        sql = "update article set creator=? where creator=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, owner);
        pstmt.setString (2, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update template set creator=? where creator=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, owner);
        pstmt.setString (2, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from userrole where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from topic_owner where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from site_owner where userid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from users where id=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, user.GetId ());
        pstmt.executeUpdate ();
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


public int [] getImageDimension (String documentId) {
    logger.debug ("getImageDimension(%s)", documentId);
    Connection connection = null;
    NamedParameterStatement statement = null;
    ResultSet resultSet = null;
    int [] dimension = new int [2];
    try {
        connection = this.dataSource.getConnection ();
        statement = new NamedParameterStatement (connection, this.queryStore.get (QueryStore.SELECT_IMAGE_DIMENSION));
        statement.setString (QueryStore.SELECT_IMAGE_DIMENSION_PARAM_ID, documentId);
        resultSet = statement.executeQuery ();
        if (resultSet.next ()) {
            dimension [0] = resultSet.getInt (QueryStore.SELECT_IMAGE_DIMENSION_PARAM_WIDTH);
            dimension [1] = resultSet.getInt (QueryStore.SELECT_IMAGE_DIMENSION_PARAM_HEIGHT);
        }
        else {
            throw new ApplicationException (String.format ("Image %s not found", documentId));
        }
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ApplicationException (e.getMessage ());
    } finally {
        close (resultSet);
        close (statement);
        close (connection);
    }
    return dimension;
}


-----Function Pair=372=-----==

public void testBetweenQuery () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 BETWEEN 1 AND 3").getResultList ();
        assertEquals (1, result.size ());
        result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 BETWEEN 3 AND 4").getResultList ();
        assertEquals (0, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


public void add (CoGObject cogTask) {
    Session session = sessionFactory.openSession ();
    Transaction tx = session.beginTransaction ();
    try {
        session.beginTransaction ();
        Task task = new Task ();
        task.setTypename (cogTask.get ("typename"));
        task.setJobid (cogTask.get ("jobid"));
        task.setInputfile (cogTask.get ("inputfile"));
        task.setOutputfile (cogTask.get ("outputfile"));
        task.setErrorfile (cogTask.get ("errorfile"));
        task.setSuspended (cogTask.get ("suspended"));
        task.setJobtype (cogTask.get ("job.type"));
        task.setResource (cogTask.get ("resource"));
        task.setExecutable (cogTask.get ("executable"));
        task.setDirectory (cogTask.get ("directory"));
        task.setMpi (cogTask.get ("mpi"));
        task.setWalltime (cogTask.get ("walltime"));
        task.setTimestamp (new Date ());
        session.save (task);
        session.flush ();
        session.clear ();
        tx.commit ();
    } catch (RuntimeException e) {
        tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
}


-----Function Pair=373=-----==

public void removeAllRecordsInTable (final String tableName) {
    long numberOfEntitiesRemoved = 0;
    final EntityManager entityManager = getEntityManager ();
    EntityTransaction tx = null;
    try {
        tx = entityManager.getTransaction ();
        if (! tx.isActive ()) {
            tx.begin ();
        }
        Query query = entityManager.createNativeQuery ("delete from " + tableName);
        numberOfEntitiesRemoved = query.executeUpdate ();
        tx.commit ();
    } catch (Exception e) {
        log.error ("Removal of entities failed", e);
        if (tx != null && tx.isActive ()) {
            tx.rollback ();
        }
    }
    log.info (numberOfEntitiesRemoved + " records explicitely deleted in table " + tableName.toUpperCase ());
}


public HolidaysType findByName (String name) throws SelectException, DBConnectionException {
    HolidaysType holiType = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to get statement", e1);
    }
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("HOLIDAYS_TYPE_NAME", name);
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (TABLE_NAME, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                holiType = new HolidaysType ();
                holiType.setId (result.getInt ("HOLIDAYS_TYPE_ID"));
                holiType.setName (result.getString ("HOLIDAYS_TYPE_NAME"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return holiType;
}


-----Function Pair=374=-----==

public Department store (Department obj) throws InsertException, DBConnectionException, XmlIOException {
    Department toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getName ());
    values.add (obj.getDescription ());
    values.add (obj.getAcronym ());
    try {
        stmt.executeUpdate (new InsertQuery (DepartmentDAO.TABLE_NAME, values).toString ());
        toReturn = findByAcronym (obj.getAcronym ());
        if (toReturn != null) toReturn.setYear_of_study (obj.getYearOfStudyList ());
        else {
            throw new SelectException (TABLE_NAME + " Can't retieve record");
        }
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException ("Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


public void add (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            if (contains (name) == false) {
                String sql = "insert into AttributeCategories (CategoryName) " + "values ('" + name + "')";
                conn = FidoDataSource.getConnection ();
                stmt = conn.createStatement ();
                stmt.executeUpdate (sql);
            }
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=375=-----==

public static Connection createConnection (final Properties properties) {
    if (null == properties) return null;
    final String driver = properties.getProperty ("driver");
    final String url = properties.getProperty ("url");
    String user = properties.getProperty ("user");
    if (null == user) user = properties.getProperty ("username");
    String pass = properties.getProperty ("pass");
    if (null == pass) pass = properties.getProperty ("password");
    try {
        Class.forName (driver);
    } catch (final ClassNotFoundException e) {
        throw new RuntimeException ("���ܼ���ָ������:" + driver);
    }
    try {
        return DriverManager.getConnection (url, user, pass);
    } catch (final SQLException e) {
        e.printStackTrace ();
    }
    return null;
}


public void testUpdateCount1 () throws Exception {
    int count = 50;
    Statement stmt = con.createStatement ();
    stmt.execute ("CREATE TABLE #updateCount1 (data INT)");
    PreparedStatement pstmt = con.prepareStatement ("INSERT INTO #updateCount1 (data) VALUES (?)");
    for (int i = 1; i <= count; i ++) {
        pstmt.setInt (1, i);
        assertEquals (1, pstmt.executeUpdate ());
    }
    pstmt.close ();
    ResultSet rs = stmt.executeQuery ("SELECT COUNT(*) FROM #updateCount1");
    assertTrue (rs.next ());
    assertEquals (count, rs.getInt (1));
    assertFalse (rs.next ());
    stmt.close ();
    rs.close ();
    pstmt = con.prepareStatement ("DELETE FROM #updateCount1");
    assertEquals (count, pstmt.executeUpdate ());
    pstmt.close ();
}


-----Function Pair=376=-----==

public boolean setupDatabaseSchema () {
    Configuration cfg = Configuration.getInstance ();
    Connection con = getConnection ();
    if (null == con) return false;
    try {
        String sql = FileTool.readFile (cfg.getProperty ("database.sql.rootdir") + System.getProperty ("file.separator") + cfg.getProperty ("database.sql.mysql.setupschema"));
        sql = sql.replaceAll (MYSQL_SQL_SCHEMA_REPLACEMENT, StateSaver.getInstance ().getDatabaseSettings ().getSchema ());
        con.setAutoCommit (false);
        Statement stmt = con.createStatement ();
        String [] sqlParts = sql.split (";");
        for (String sqlPart : sqlParts) {
            if (sqlPart.trim ().length () > 0) stmt.executeUpdate (sqlPart);
        }
        con.commit ();
        JOptionPane.showMessageDialog (null, language.getProperty ("database.messages.executionsuccess"), language.getProperty ("dialog.information.title"), JOptionPane.INFORMATION_MESSAGE);
        return true;
    } catch (SQLException e) {
        Logger.logException (e);
    }
    try {
        if (con != null) con.rollback ();
    } catch (SQLException e) {
        Logger.logException (e);
    }
    JOptionPane.showMessageDialog (null, language.getProperty ("database.messages.executionerror"), language.getProperty ("dialog.error.title"), JOptionPane.ERROR_MESSAGE);
    return false;
}


private StringBuffer getInsertSql (List allProps, String table) {
    StringBuffer insertSql = new StringBuffer ();
    insertSql.append ("insert into ").append (table).append ("(");
    log.info ("正在生成服务和参数关联SQL:");
    for (Iterator itCol = allProps.iterator (); itCol.hasNext ();) {
        DOBOProperty property = (DOBOProperty) itCol.next ();
        insertSql.append (property.getColName ());
        if (itCol.hasNext ()) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    insertSql.append (" values(");
    for (int i = 0; i < allProps.size (); i ++) {
        insertSql.append ("?");
        if (i < allProps.size () - 1) {
            insertSql.append (",");
        }
        else {
            insertSql.append (")");
        }
    }
    return insertSql;
}


-----Function Pair=377=-----==

public List executeHQL (String hql, List conditionsList) throws HibernateException {
    if (log.isDebugEnabled ()) log.debug ("Hibernate query: " + hql);
    if (log.isDebugEnabled ()) log.debug ("with conditions: " + conditionsList);
    Session session = HibernateUtil.currentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query query = session.createQuery (hql);
        if (conditionsList != null) {
            for (Iterator it = conditionsList.iterator (); it.hasNext ();) {
                HQLCondition cond = (HQLCondition) it.next ();
                if (cond.getOperation ().equals (HQLCondition.LIKE)) {
                    query.setParameter (cond.getField (), "%" + cond.getValue () + "%");
                }
                else {
                    query.setParameter (cond.getField (), cond.getValue ());
                }
            }
        }
        query.setMaxResults (LIST_LIMIT_TO_PREVENT_OUT_OF_MEMORY);
        List result = query.list ();
        tx.commit ();
        return result;
    } catch (RuntimeException e) {
        tx.rollback ();
        log.error ("Error Executing HQL Sentence in Hibernate", e);
        throw new HibernateException (e);
    }
}


public void testMultipleResults0015 () throws Exception {
    Connection cx = getConnection ();
    dropTable ("#t0015");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("create table #t0015 " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    PreparedStatement pStmt = cx.prepareStatement ("insert into #t0015 values (?, ?)");
    int rowsToAdd = 8;
    final String theString = "abcdefghijklmnopqrstuvwxyz";
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pStmt.setInt (1, i);
        pStmt.setString (2, theString.substring (0, i));
        count += pStmt.executeUpdate ();
    }
    assertTrue (count == rowsToAdd);
    stmt = cx.createStatement ();
    ResultSet rs = stmt.executeQuery ("select s from #t0015 select i from #t0015");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    assertTrue (stmt.getMoreResults ());
    rs = stmt.getResultSet ();
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    rs = stmt.executeQuery ("select i, s from #t0015");
    count = 0;
    while (rs.next ()) {
        count ++;
    }
    assertTrue (count == rowsToAdd);
    cx.close ();
}


-----Function Pair=378=-----==

private static void debug (String sqlhql, int size, long ms, List < ISParameter > params, ServiceCall call) {
    if (call.isDebug () || ms > 1000) {
        String debug = "" + sqlhql + "\n returned " + size + " results in " + ms + "ms ";
        if (call.getMaxNbrQueryResults () > 0) {
            debug += " (max " + call.getMaxNbrQueryResults () + ") ";
        }
        if (! call.isDebug ()) {
            debug += sqlhql;
        }
        for (ISParameter param : params) {
            String value = param.isList () ? Converter.convertQuotedList (param.getValues ()) : Converter.convertDisplayString (param.getValue ());
            debug.replace (param.getName (), value);
        }
        Log.warn (debug);
    }
}


public NameMap getReference (String pTableName) {
    NameMap tOut = new NameMap ();
    ResultSet tRS = null;
    try {
        tRS = getConnection ().getMetaData ().getImportedKeys (loginInfo.getSchema (), SCHEMA_PATTERN, pTableName);
        while (tRS.next ()) {
            String tFkName = tRS.getString ("FK_NAME").intern ();
            String tFkColumnName = tRS.getString ("FKCOLUMN_NAME").intern ();
            String tRefTableName = tRS.getString ("PKTABLE_NAME").intern ();
            String tRefColumnName = tRS.getString ("PKCOLUMN_NAME").intern ();
            tOut.addColumn (tFkName, new NameMapCell (tFkColumnName, tRefTableName, tRefColumnName));
        }
    } catch (Exception e) {
        LOG.error ("", e);
    } finally {
        close (tRS);
    }
    return tOut;
}


-----Function Pair=379=-----==

public int updateHQL (String hql, List conditionsList) throws HibernateException {
    if (log.isDebugEnabled ()) log.debug ("Hibernate update query: " + hql);
    if (log.isDebugEnabled ()) log.debug ("with conditions: " + conditionsList);
    Session session = HibernateUtil.currentSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query updateQuery = session.createQuery (hql);
        if (conditionsList != null) {
            for (Iterator it = conditionsList.iterator (); it.hasNext ();) {
                HQLCondition cond = (HQLCondition) it.next ();
                if (cond.getOperation ().equals (HQLCondition.LIKE)) {
                    updateQuery.setParameter (cond.getField (), "%" + cond.getValue () + "%");
                }
                else {
                    updateQuery.setParameter (cond.getField (), cond.getValue ());
                }
            }
        }
        int num = updateQuery.executeUpdate ();
        tx.commit ();
        return num;
    } catch (RuntimeException e) {
        tx.rollback ();
        throw new HibernateException (e);
    }
}


public jugador getUnJugador (int id) {
    jugador unjugador = null;
    try {
        String sql = " SELECT * " + " FROM jugador " + " WHERE idJugador = " + id;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            this.elJugador = new jugador ();
            populateJugadores (resultSet);
            unjugador = this.elJugador;
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return unjugador;
}


-----Function Pair=380=-----==

public void test33_listLogFiles () throws Exception {
    FileInformation [] infos = listLogFiles (null);
    assertNotNull (infos);
    Date previousDate = null;
    boolean dir = true;
    for (int i = 0; i < infos.length; i ++) {
        if (previousDate == null && ! dir) previousDate = infos [i].getLastModified ();
        dir = infos [i].isDirectory ();
        if (previousDate != null) assertSame (previousDate + " before " + infos [i].getLastModified (), ! previousDate.before (infos [i].getLastModified ()), true);
        if (infos [i].isDirectory ()) {
            Date previousDate2 = null;
            FileInformation [] subdir = listLogFiles (infos [i].getName ());
            assertNotNull (subdir);
            for (int j = 0; j < subdir.length; j ++) {
                if (previousDate2 == null) previousDate2 = subdir [j].getLastModified ();
                assertTrue (previousDate2 + " before " + subdir [j].getLastModified (), ! previousDate2.before (subdir [j].getLastModified ()));
            }
        }
    }
}


public final void setChildren (Class < ? extends Record > record, Integer...ids) throws RecordException, RecordValidationException, RecordValidationSyntax, FieldOrMethodNotFoundException {
    try {
        List < Record > l = new ArrayList < Record > ();
        for (int id : ids) {
            Record r = record.newInstance ();
            if (r instanceof RecordBase) {
                r = ((RecordBase) r).find (id).get (0);
                l.add (r);
            }
            else if (r instanceof StaticRecordBase) {
                Method m;
                try {
                    m = r.getClass ().getSuperclass ().getDeclaredMethod ("find", Class.class, Integer [].class);
                    Object tmp = m.invoke (null, r.getClass (), new Object [] {id});
                    r = (Record) tmp;
                    l.add (r);
                } catch (SecurityException e) {
                    throw new RecordException (e);
                } catch (NoSuchMethodException e) {
                    throw new RecordException (e);
                } catch (IllegalArgumentException e) {
                    throw new RecordException (e);
                } catch (InvocationTargetException e) {
                    throw new RecordException (e);
                }
            }
        }
        setChildren (record, l);
    } catch (InstantiationException e) {
        throw new RecordException (e);
    } catch (IllegalAccessException e) {
        throw new RecordException (e);
    }
}


-----Function Pair=381=-----==

public boolean checkUserExistance (String userDocument) {
    DBHelper helper = null;
    boolean ret = false;
    ResultSet rsCheck = null;
    UserDocument doc = null;
    try {
        helper = new DBHelper ();
        doc = UserDocument.Factory.parse (userDocument);
        PreparedStatement psCheck = helper.prepareStatement (SQL.checkUserExistance ());
        psCheck.setString (1, doc.getUser ().getUsername ());
        rsCheck = psCheck.executeQuery ();
        rsCheck.next ();
        if (rsCheck.getInt (1) != 0) {
            ret = true;
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsCheck != null) {
                rsCheck.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return ret;
}


public Boolean execHapusPembayaran (Integer NoBukti, Date Dibayar) {
    Double Nilai;
    String Jenis;
    Boolean r = false;
    Jenis = String.valueOf (pembayaranTable.getValueAt (pembayaranTable.getSelectedRow (), 2));
    Nilai = Double.valueOf (String.valueOf (pembayaranTable.getValueAt (pembayaranTable.getSelectedRow (), 3)));
    if (JOptionPane.showConfirmDialog (this, "Hapus pembayaran " + Jenis + " sejumlah " + floatDisplay.format (Nilai) + "?", "Konfirmasi", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
        try {
            pembayaranEntity.getTransaction ().begin ();
            pembayaranQuery = pembayaranEntity.createNativeQuery ("DELETE FROM pembayaran WHERE nobukti = #nobukti AND dibayar = #dibayar").setParameter ("nobukti", NoBukti).setParameter ("dibayar", Dibayar);
            pembayaranQuery.executeUpdate ();
            pembayaranEntity.getTransaction ().commit ();
            r = true;
        } catch (Exception ex) {
            pembayaranEntity.getTransaction ().rollback ();
            ex.printStackTrace ();
            Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
    return r;
}


-----Function Pair=382=-----==

public void doPost (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    HttpSession userSession = request.getSession (false);
    Map < String, String > servicesCheckedMap = getServicesChecked (userSession);
    String checkedServices [] = request.getParameterValues ("serviceCheck");
    if (checkedServices != null) {
        for (String checkedService : checkedServices) {
            servicesCheckedMap.put (checkedService, "Y");
        }
    }
    Iterator < String > iterator = servicesCheckedMap.keySet ().iterator ();
    while (iterator.hasNext ()) {
        String key = iterator.next ();
        StringTokenizer tokenizer = new StringTokenizer (key, ",");
        int nodeID = WebSecurityUtils.safeParseInt (tokenizer.nextToken ());
        String ipAddress = tokenizer.nextToken ();
        int serviceID = WebSecurityUtils.safeParseInt (tokenizer.nextToken ());
        updateService (nodeID, ipAddress, serviceID, servicesCheckedMap.get (key));
    }
    response.sendRedirect ("index.jsp");
}


public void genDropSchema (DiagramModel diagramModel, boolean foreignKeys) {
    try {
        con.setAutoCommit (false);
        stmt = con.createStatement ();
        Collection boxes = diagramModel.getBoxes ();
        BoxModel box;
        String sqlQuery;
        if (foreignKeys) {
            for (Iterator x = boxes.iterator (); x.hasNext ();) {
                box = (BoxModel) x.next ();
                if (! box.isAbstractDef ()) {
                    dropForeignKeys (box);
                }
            }
        }
        int counter = 0;
        for (Iterator x = boxes.iterator (); x.hasNext ();) {
            box = (BoxModel) x.next ();
            if (! box.isAbstractDef ()) {
                sqlQuery = sqlDropTable (box);
                System.out.println (sqlQuery);
                try {
                    stmt.executeUpdate (sqlQuery);
                    counter ++;
                } catch (SQLException e) {
                    String tableName = box.getName ();
                    System.out.println ("// Problem while dropping table " + tableName + " : " + e.getMessage ());
                    String msg = Para.getPara ().getText ("tableNotDropped") + " -- " + tableName;
                    this.informUser (msg);
                }
            }
        }
        con.commit ();
        if (counter > 0) {
            String msg = Para.getPara ().getText ("schemaDropped") + " -- " + counter + " " + Para.getPara ().getText ("tables");
            this.informUser (msg);
        }
        else {
            this.informUser (Para.getPara ().getText ("schemaNotDropped"));
        }
    } catch (SQLException e) {
        System.out.println (e.getMessage () + " // Problem with the JDBC schema generation! ");
        try {
            con.rollback ();
            this.informUser (Para.getPara ().getText ("schemaNotDropped"));
        } catch (SQLException e1) {
            System.out.println (e1.getMessage () + " // Problem with the connection rollback! ");
        }
    } finally {
        try {
            con.setAutoCommit (true);
            stmt.close ();
        } catch (SQLException e1) {
            System.out.println (e1.getMessage () + " // Problem with the connection disconnect! ");
        }
    }
}


-----Function Pair=383=-----==

public static Hashtable getEnrollmentInfo2 (Statement stmt, String student_id) throws Exception {
    Hashtable info = new Hashtable ();
    info.put ("isEnrolled", new Boolean (false));
    String sql = "";
    SQLRenderer r = new SQLRenderer ();
    boolean enrolled = true;
    {
        r.add ("stu.name as student_name");
        r.add ("stu.icno");
        r.add ("c.course_id");
        r.add ("c.course_code");
        r.add ("c.course_name");
        r.add ("sc.program_code");
        r.add ("p.program_name");
        r.add ("sc.period_root_id");
        r.add ("sc.track_id");
        r.add ("sc.intake_month");
        r.add ("sc.intake_year");
        r.add ("sc.intake_code");
        r.add ("sc.intake_session");
        r.add ("s.session_name");
        r.add ("f.faculty_code");
        r.add ("f.faculty_name");
        r.add ("i.institution_id");
        r.add ("i.institution_name");
        r.add ("i.institution_abbr");
        r.add ("sc.student_id", student_id);
        r.add ("sc.student_id", r.unquote ("stu.id"));
        r.add ("c.course_id", r.unquote ("sc.course_id"));
        r.add ("sc.program_code", r.unquote ("p.program_code"));
        r.add ("c.faculty_id", r.unquote ("f.faculty_id"));
        r.add ("f.institution_id", r.unquote ("i.institution_id"));
        r.add ("sc.intake_session", r.unquote ("s.session_id"));
        sql = r.getSQLSelect ("student stu, student_course sc, study_course c, session s, program p, faculty f, institution i");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            info.put ("id", student_id);
            info.put ("student_id", student_id);
            info.put ("student_name", rs.getString ("student_name"));
            info.put ("icno", Db.getString (rs, "icno"));
            info.put ("course_id", mecca.db.Db.getString (rs, "course_id"));
            info.put ("course_code", mecca.db.Db.getString (rs, "course_code"));
            info.put ("program_code", mecca.db.Db.getString (rs, "program_code"));
            info.put ("program_name", mecca.db.Db.getString (rs, "program_name"));
            info.put ("course_name", mecca.db.Db.getString (rs, "course_name"));
            info.put ("period_scheme", mecca.db.Db.getString (rs, "period_root_id"));
            info.put ("track_id", mecca.db.Db.getString (rs, "track_id"));
            info.put ("intake_month", new Integer (rs.getInt ("intake_month")));
            info.put ("intake_year", new Integer (rs.getInt ("intake_year")));
            info.put ("intake_code", mecca.db.Db.getString (rs, "intake_code"));
            info.put ("intake_session", mecca.db.Db.getString (rs, "intake_session"));
            info.put ("intake_session_name", mecca.db.Db.getString (rs, "session_name"));
            info.put ("faculty_code", mecca.db.Db.getString (rs, "faculty_code"));
            info.put ("faculty_name", mecca.db.Db.getString (rs, "faculty_name"));
            info.put ("institution_id", mecca.db.Db.getString (rs, "institution_id"));
            info.put ("institution_name", mecca.db.Db.getString (rs, "institution_name"));
            info.put ("institution_abbr", mecca.db.Db.getString (rs, "institution_abbr"));
            info.put ("batch_session", "");
            info.put ("batch_session_name", "");
        }
        else {
            enrolled = false;
        }
    }
    if (! enrolled) return info;
    String track_id = (String) info.get ("track_id");
    if ("".equals (track_id)) track_id = "0";
    if (! "0".equals (track_id)) {
        r.clear ();
        r.add ("t.program_code", (String) info.get ("program_code"));
        r.add ("t.track_id", (String) info.get ("track_id"));
        r.add ("t.track_name");
        r.add ("t.period_root_id");
        r.add ("p.program_name");
        r.add ("t.program_code", r.unquote ("p.program_code"));
        sql = r.getSQLSelect ("program_track t, program p");
        ResultSet rs = stmt.executeQuery (sql);
        Hashtable h = new Hashtable ();
        while (rs.next ()) {
            info.put ("track_name", rs.getString ("track_name"));
        }
    }
    else {
        info.put ("track_name", "Default");
    }
    {
        info.put ("isEnrolled", new Boolean (true));
        int period_level = 0;
        String parent_id = "";
        info.put ("period_name", "none");
        String period_name = (String) info.get ("period_name");
        while (period_level != 0) {
            r.clear ();
            r.add ("period_name");
            r.add ("parent_id");
            r.add ("period_level");
            r.add ("period_id", parent_id);
            sql = r.getSQLSelect ("period");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                period_name = rs.getString ("period_name") + ", " + period_name;
                parent_id = rs.getString ("parent_id");
                period_level = rs.getInt ("period_level");
            }
        }
        info.put ("period_name", period_name);
    }
    String period_id = SessionData.getCurrentPeriodId ((String) info.get ("period_scheme"), (String) info.get ("intake_session"));
    info.put ("period_id", period_id);
    if (period_id != null && ! "".equals (period_id)) {
        if ("FINISHED".equals (period_id)) {
            info.put ("period_name", "FINISHED STUDY");
        }
        else {
            createPeriodName (info);
        }
    }
    else {
        info.put ("period_name", "UNDEFINED");
    }
    {
        String session_id = (String) info.get ("intake_session");
        sql = "select c.centre_id, centre_code, centre_name from student s, learning_centre c " + "where s.centre_id = c.centre_id and id = '" + student_id + "'";
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            info.put ("centre_id", rs.getString ("centre_id"));
            info.put ("centre_code", rs.getString ("centre_code"));
            info.put ("centre_name", rs.getString ("centre_name"));
        }
        else {
            info.put ("centre_id", "");
            info.put ("centre_code", "");
            info.put ("centre_name", "");
        }
    }
    return info;
}


public static boolean update (String fullname, String username, String password, String role, String login_alt) throws Exception {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        boolean isExist = false;
        if (! login_alt.equals (username)) {
            {
                r.clear ();
                r.add ("user_login");
                r.add ("user_login", login_alt);
                sql = r.getSQLSelect ("users");
                ResultSet rs = stmt.executeQuery (sql);
                if (rs.next ()) isExist = true;
            }
        }
        if (! isExist) {
            r.clear ();
            r.add ("user_name", fullname);
            r.add ("user_password", lebah.util.PasswordService.encrypt (password));
            r.add ("user_role", role);
            r.add ("user_login_alt", login_alt);
            r.update ("user_login", username);
            sql = r.getSQLUpdate ("users");
            int num = stmt.executeUpdate (sql);
            if (num > 0) return true;
            else return false;
        }
    } catch (SQLException ex) {
        Log.print (ex.getMessage () + "\n" + sql);
    } finally {
        if (db != null) db.close ();
    }
    return false;
}


-----Function Pair=384=-----==

public byte [] getBlob (String dbName, Query select) throws ServiceException {
    log.info ("[DAOService::getBlob] BEGIN");
    Connection con = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    byte [] bytes = null;
    try {
        con = getDbConnection ().getConnection (dbName);
        pstmt = con.prepareStatement (select.getSql ());
        addParametersToQuery (select, pstmt);
        rs = pstmt.executeQuery ();
        Blob blob = null;
        if (rs.next ()) {
            blob = rs.getBlob (1);
            bytes = IOUtils.toByteArray (blob.getBinaryStream ());
        }
        log.info ("[DAOService::getBlob] return " + blob);
        return bytes;
    } catch (DbException e) {
        log.error ("[DAOService::getBlob] " + e.getMessage (), e);
        throw new ServiceException (e.getMessage ());
    } catch (SQLException e) {
        log.error ("[DAOService::getBlob] " + e.getMessage (), e);
        throw new ServiceException (e.getMessage ());
    } catch (IOException e) {
        log.error ("[DAOService::getBlob] " + e.getMessage (), e);
        throw new ServiceException (e.getMessage ());
    } finally {
        log.info ("[DAOService::getBlob] Chiudo le connessioni al db");
        log.info ("[DAOService::getBlob] END");
        closeConnection (con, pstmt, rs);
    }
}


public void delete (Channel channel) throws Exception {
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        dbo = createDBOperation ();
        connection = dbo.getConnection ();
        connection.setAutoCommit (false);
        String [] selfDefinePath = getSelfDefinePath (channel.getPath (), "1", connection, preparedStatement, resultSet);
        selfDefineDelete (selfDefinePath, connection, preparedStatement);
        String sqlStr = "delete from t_ip_channel where channel_path=?";
        preparedStatement = connection.prepareStatement (sqlStr);
        preparedStatement.setString (1, channel.getPath ());
        preparedStatement.executeUpdate ();
        sqlStr = "delete from t_ip_channel_order where channel_order_site = ?";
        preparedStatement.setString (1, channel.getPath ());
        preparedStatement.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        connection.rollback ();
        log.error ("ɾ��Ƶ��ʧ�ܣ�channelPath=" + channel.getPath (), ex);
        throw ex;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
}


-----Function Pair=385=-----==

public boolean deleteCategories (int leaveId) {
    boolean flag = false;
    try {
        transaction = session.beginTransaction ();
        LeaveType leaveType = (LeaveType) session.get (LeaveType.class, leaveId);
        session.delete (leaveType);
        transaction.commit ();
        session.close ();
        flag = true;
    } catch (HibernateException e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
    return flag;
}


public List < Members > getAllMembers () {
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        String hql = "FROM Members";
        Query query = session.createQuery (hql);
        List < Members > resultList = query.list ();
        transaction.commit ();
        return resultList;
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
        return null;
    }
}


-----Function Pair=386=-----==

public HistoricalCommand getHistoricalCommand (long historyId) throws SQLException {
    PreparedStatement preparedStatement = null;
    ResultSet cursor = null;
    try {
        preparedStatement = embeddedConnection.prepareStatement (HISTORY_SELECT_SINGLE);
        preparedStatement.setLong (1, historyId);
        boolean hasResults = preparedStatement.execute ();
        if (hasResults) {
            cursor = preparedStatement.getResultSet ();
            if (cursor.next ()) {
                HistoricalCommand command = new HistoricalCommand ();
                command.setId (cursor.getLong (1));
                command.setService (cursor.getString (2));
                command.setQueryTime (cursor.getTimestamp (3));
                command.setTransactionId (cursor.getLong (4));
                CommandType type = CommandType.valueOf (cursor.getString (5));
                command.setType (type);
                command.setCommandText (cursor.getString (6));
                return command;
            }
        }
        return null;
    } finally {
        if (cursor != null) {
            try {
                cursor.close ();
            } catch (SQLException ignored) {
            }
        }
        if (preparedStatement != null) {
            try {
                preparedStatement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


public < T > T merge (EntityManager em, T obj) throws RuntimeException {
    T rtnVal = null;
    boolean doCloseEntityManager = false;
    EntityManager emTemp = em;
    if (emTemp == null) {
        emTemp = getEntityManager ();
        doCloseEntityManager = true;
    }
    if (emTemp != null) {
        EntityTransaction et = emTemp.getTransaction ();
        try {
            if (et.isActive () == false) {
                et.begin ();
            }
            rtnVal = emTemp.merge (obj);
            if (et.isActive ()) {
                et.commit ();
            }
        } catch (Exception exception) {
            if (et.isActive ()) {
                et.rollback ();
            }
            if (doCloseEntityManager) {
                emTemp.close ();
            }
            throw new RuntimeException (exception);
        }
        if (doCloseEntityManager) {
            emTemp.close ();
        }
    }
    return rtnVal;
}


-----Function Pair=387=-----==

private static void createPeriodName (Statement stmt, Hashtable info) throws Exception {
    String sql = "";
    info.put ("period_name", "");
    if (info.get ("period_id") == null || "".equals ((String) info.get ("period_id"))) return;
    if (info.get ("period_scheme") == null || "".equals ((String) info.get ("period_scheme"))) return;
    SQLRenderer r = new SQLRenderer ();
    {
        r.clear ();
        r.add ("period_name");
        r.add ("period_level");
        r.add ("parent_id");
        r.add ("period_id", (String) info.get ("period_id"));
        r.add ("period_root_id", (String) info.get ("period_scheme"));
        sql = r.getSQLSelect ("period");
        int period_level = 0;
        String parent_id = "";
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            info.put ("period_name", rs.getString ("period_name"));
            period_level = rs.getInt ("period_level");
            parent_id = rs.getString ("parent_id");
        }
        String period_name = (String) info.get ("period_name");
        while (period_level != 0) {
            r.clear ();
            r.add ("period_name");
            r.add ("parent_id");
            r.add ("period_level");
            r.add ("period_id", parent_id);
            sql = r.getSQLSelect ("period");
            rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                period_name = rs.getString ("period_name") + ", " + period_name;
                parent_id = rs.getString ("parent_id");
                period_level = rs.getInt ("period_level");
            }
        }
        info.put ("period_name", period_name);
    }
}


public static ArrayList < Departamento > selectByOrgao (int codigo) {
    Connection c = DBConnection.getConnection ();
    PreparedStatement pst = null;
    ResultSet rs = null;
    Departamento objDepartamento = null;
    ArrayList < Departamento > al = new ArrayList < Departamento > ();
    if (c == null) {
        return null;
    }
    try {
        String sql = "SELECT distinct d.id_departamento, d.id_orgao, d.telefone " + ", d.sala, d.nome, d.cod_depto " + "FROM departamento d " + "where d.id_orgao = ? " + "order by d.nome";
        pst = c.prepareStatement (sql);
        pst.setInt (1, codigo);
        rs = pst.executeQuery ();
        while (rs.next ()) {
            objDepartamento = new Departamento ();
            objDepartamento.setCodigo (rs.getInt ("id_departamento"));
            objDepartamento.setNome (rs.getString ("nome"));
            objDepartamento.setSala (rs.getString ("sala"));
            objDepartamento.setTelefone (rs.getString ("telefone"));
            objDepartamento.setOrgao (OrgaoDAO.selectByID (rs.getString ("id_orgao")));
            al.add (objDepartamento);
            objDepartamento = null;
        }
    } catch (SQLException e) {
        System.out.println ("[DepartamentoDAO.selectByID] Erro ao atualizar -> " + e.getMessage ());
        al = null;
    } finally {
        DBConnection.closeResultSet (rs);
        DBConnection.closePreparedStatement (pst);
        DBConnection.closeConnection (c);
    }
    return al;
}


-----Function Pair=388=-----==

private static void createPeriodName (Statement stmt, Hashtable info) throws Exception {
    String sql = "";
    info.put ("period_name", "");
    if (info.get ("period_id") == null || "".equals ((String) info.get ("period_id"))) return;
    if (info.get ("period_scheme") == null || "".equals ((String) info.get ("period_scheme"))) return;
    SQLRenderer r = new SQLRenderer ();
    {
        r.clear ();
        r.add ("period_name");
        r.add ("period_level");
        r.add ("parent_id");
        r.add ("period_id", (String) info.get ("period_id"));
        r.add ("period_root_id", (String) info.get ("period_scheme"));
        sql = r.getSQLSelect ("period");
        int period_level = 0;
        String parent_id = "";
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            info.put ("period_name", rs.getString ("period_name"));
            period_level = rs.getInt ("period_level");
            parent_id = rs.getString ("parent_id");
        }
        String period_name = (String) info.get ("period_name");
        while (period_level != 0) {
            r.clear ();
            r.add ("period_name");
            r.add ("parent_id");
            r.add ("period_level");
            r.add ("period_id", parent_id);
            sql = r.getSQLSelect ("period");
            rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                period_name = rs.getString ("period_name") + ", " + period_name;
                parent_id = rs.getString ("parent_id");
                period_level = rs.getInt ("period_level");
            }
        }
        info.put ("period_name", period_name);
    }
}


public static void main (String [] args) {
    org.compiere.Adempiere.startup (true);
    CLogMgt.setLevel (Level.SEVERE);
    CLogMgt.setLoggerLevel (Level.SEVERE, null);
    s_list = new Vector < Integer > (1000);
    long time = System.currentTimeMillis ();
    Thread [] threads = new Thread [10];
    for (int i = 0; i < 10; i ++) {
        Runnable r = new GetIDs (i);
        threads [i] = new Thread (r);
        threads [i].start ();
    }
    for (int i = 0; i < 10; i ++) {
        try {
            threads [i].join ();
        } catch (InterruptedException e) {
        }
    }
    time = System.currentTimeMillis () - time;
    System.out.println ("-------------------------------------------");
    System.out.println ("Size=" + s_list.size () + " (should be 1000)");
    Integer [] ia = new Integer [s_list.size ()];
    s_list.toArray (ia);
    Arrays.sort (ia);
    Integer last = null;
    int duplicates = 0;
    for (int i = 0; i < ia.length; i ++) {
        if (last != null) {
            if (last.compareTo (ia [i]) == 0) {
                duplicates ++;
            }
        }
        last = ia [i];
    }
    System.out.println ("-------------------------------------------");
    System.out.println ("Size=" + s_list.size () + " (should be 1000)");
    System.out.println ("Duplicates=" + duplicates);
    System.out.println ("Time (ms)=" + time + " - " + ((float) time / s_list.size ()) + " each");
    System.out.println ("-------------------------------------------");
}


-----Function Pair=389=-----==

public boolean renameBookmarkFolder (String existingPath, String newPath) throws SQLException {
    Object [] bindVariables = new Object [3];
    int [] types = new int [3];
    types [0] = Types.VARCHAR;
    types [1] = Types.VARCHAR;
    types [2] = Types.VARCHAR;
    bindVariables [0] = MessageFormat.format ("({0})(.*)", new Object [] {existingPath});
    bindVariables [1] = MessageFormat.format ("{0}$2", new Object [] {newPath});
    bindVariables [2] = MessageFormat.format ("{0}%", new Object [] {existingPath});
    PreparedStatement preparedStatement = null;
    try {
        preparedStatement = embeddedConnection.prepareStatement (BOOKMARK_FOLDER_RENAME);
        for (int i = 0; i < bindVariables.length; i ++) {
            if (bindVariables [i] == null) {
                preparedStatement.setNull (i + 1, types [i]);
            }
            else {
                preparedStatement.setObject (i + 1, bindVariables [i]);
            }
        }
        int affected = preparedStatement.executeUpdate ();
        return affected >= 1;
    } finally {
        if (preparedStatement != null) {
            try {
                preparedStatement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


static final synchronized DataStore getConnection (boolean exclusive) {
    String threadName = Thread.currentThread ().getName ();
    long start = System.currentTimeMillis ();
    if (exclusive) {
        LOG.info ("Thread '" + threadName + "' is seeking an exclusive DataStore connection!");
        while (DB_CONNS.size () != actualPoolSize) {
            try {
                LOG.info ("Thread '" + threadName + "' is waiting for an exclusive DataStore connection! [AVAIL=" + DB_CONNS.size () + "; MAX=" + actualPoolSize + "; WAIT=" + (System.currentTimeMillis () - start) + "ms]");
                DataStore.class.wait ();
            } catch (InterruptedException e) {
            }
        }
        exclusiveRequestActive = true;
        exclusiveHolder = Thread.currentThread ();
        LOG.info ("Thread '" + threadName + "' has received an exclusive DataStore connection! [WAIT=" + (System.currentTimeMillis () - start) + "ms]");
    }
    else {
        while (exclusiveRequestActive && ! Thread.currentThread ().equals (exclusiveHolder)) {
            try {
                LOG.debug ("Thread '" + threadName + "' is waiting for a non-exclusive DataStore connection! [WAIT=" + (System.currentTimeMillis () - start) + "ms]");
                DataStore.class.wait ();
            } catch (InterruptedException e) {
            }
        }
        LOG.debug ("Thread '" + threadName + "' has received a non-exclusive DataStore connection! [WAIT=" + (System.currentTimeMillis () - start) + "ms]");
    }
    if (DB_CONNS.isEmpty ()) {
        LOG.debug ("DataStore connection pool is empty; added a new connection to the pool.");
        DB_CONNS.add (new DataStore ());
        ++ actualPoolSize;
    }
    return DB_CONNS.remove ().startTimer ();
}


-----Function Pair=390=-----==

public void saveClob (String fieldName, Clob data) throws DataException {
    try {
        if (myConnection == null) {
            myConnection = DBConnectionPool.getInstance (getCriteria ().getMappedDataContext ()).getConnection ("LOB Field Connection");
        }
    } catch (DBException ex) {
        throw new DataException ("Error getting Database" + " Connection for BLOB Retrieval", ex);
    }
    PreparedStatement preparedStatement = prepUpdate (getCriteria (), fieldName, myConnection);
    try {
        if (data == null) {
            DataFieldMetaData metaData = getCriteria ().getFieldMetaData (fieldName);
            int typeCode = TypeMapper.getInstance (getCriteria ().getMappedDataContext ()).getJavaSQLType (metaData.getTypeString ());
            preparedStatement.setNull (1, typeCode);
        }
        else {
            preparedStatement.setClob (1, data);
        }
    } catch (SQLException ex) {
        throw new DataException ("Unable to set CharacterStream to CLOB object.", ex);
    } catch (DBException ex) {
        throw new DataException ("Unable to get type mapping information for CLOB field", ex);
    }
    finalizeUpdate (myConnection);
}


public int findMemberCountByHql (String hql) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery (hql);
        List list = query.list ();
        tr.commit ();
        if (list != null && list.size () > 0) {
            return (Integer) list.get (0);
        }
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return 0;
}


-----Function Pair=391=-----==

public static void delete (Order entry) {
    Session session = sessionFactory.openSession ();
    session.getTransaction ().begin ();
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        session.delete (entry);
        tx.commit ();
    } catch (RuntimeException e) {
        if (tx != null && tx.isActive ()) {
            try {
                tx.rollback ();
            } catch (HibernateException e1) {
                System.out.println ("Error rolling back transaction");
            }
            throw e;
        }
    }
}


public boolean updateAttachments (Attachments attachments) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        session.update (attachments);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=392=-----==

public void testConcurrentCachedDirtyQueries () throws Exception {
    if (getDialect ().doesReadCommittedCauseWritersToBlockReaders ()) {
        reportSkip ("write locks block readers", "concurrent queries");
        return;
    }
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    Session s = openSession ();
    Map foo = new HashMap ();
    foo.put ("name", "Foo");
    foo.put ("description", "a big foo");
    s.persist ("Item", foo);
    Map bar = new HashMap ();
    bar.put ("name", "Bar");
    bar.put ("description", "a small bar");
    s.persist ("Item", bar);
    SimpleJtaTransactionManagerImpl.getInstance ().commit ();
    synchronized (this) {
        wait (1000);
    }
    getSessions ().getStatistics ().clear ();
    getSessions ().evictEntity ("Item");
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    Session s4 = openSession ();
    Transaction tx4 = SimpleJtaTransactionManagerImpl.getInstance ().suspend ();
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    Session s1 = openSession ();
    List r1 = s1.createCriteria ("Item").addOrder (Order.asc ("description")).setCacheable (true).list ();
    assertEquals (r1.size (), 2);
    foo = (Map) r1.get (0);
    foo.put ("description", "a big red foo");
    s1.flush ();
    Transaction tx1 = SimpleJtaTransactionManagerImpl.getInstance ().suspend ();
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    Session s2 = openSession ();
    List r2 = s2.createCriteria ("Item").addOrder (Order.asc ("description")).setCacheable (true).list ();
    assertEquals (r2.size (), 2);
    SimpleJtaTransactionManagerImpl.getInstance ().commit ();
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheHitCount (), 0);
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheMissCount (), 0);
    assertEquals (getSessions ().getStatistics ().getEntityLoadCount (), 4);
    assertEquals (getSessions ().getStatistics ().getEntityFetchCount (), 0);
    assertEquals (getSessions ().getStatistics ().getQueryExecutionCount (), 2);
    assertEquals (getSessions ().getStatistics ().getQueryCachePutCount (), 2);
    assertEquals (getSessions ().getStatistics ().getQueryCacheHitCount (), 0);
    assertEquals (getSessions ().getStatistics ().getQueryCacheMissCount (), 2);
    SimpleJtaTransactionManagerImpl.getInstance ().resume (tx1);
    tx1.commit ();
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    Session s3 = openSession ();
    s3.createCriteria ("Item").addOrder (Order.asc ("description")).setCacheable (true).list ();
    SimpleJtaTransactionManagerImpl.getInstance ().commit ();
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheHitCount (), 0);
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheMissCount (), 0);
    assertEquals (getSessions ().getStatistics ().getEntityLoadCount (), 6);
    assertEquals (getSessions ().getStatistics ().getEntityFetchCount (), 0);
    assertEquals (getSessions ().getStatistics ().getQueryExecutionCount (), 3);
    assertEquals (getSessions ().getStatistics ().getQueryCachePutCount (), 3);
    assertEquals (getSessions ().getStatistics ().getQueryCacheHitCount (), 0);
    assertEquals (getSessions ().getStatistics ().getQueryCacheMissCount (), 3);
    SimpleJtaTransactionManagerImpl.getInstance ().resume (tx4);
    List r4 = s4.createCriteria ("Item").addOrder (Order.asc ("description")).setCacheable (true).list ();
    assertEquals (r4.size (), 2);
    tx4.commit ();
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheHitCount (), 2);
    assertEquals (getSessions ().getStatistics ().getSecondLevelCacheMissCount (), 0);
    assertEquals (getSessions ().getStatistics ().getEntityLoadCount (), 6);
    assertEquals (getSessions ().getStatistics ().getEntityFetchCount (), 0);
    assertEquals (getSessions ().getStatistics ().getQueryExecutionCount (), 3);
    assertEquals (getSessions ().getStatistics ().getQueryCachePutCount (), 3);
    assertEquals (getSessions ().getStatistics ().getQueryCacheHitCount (), 1);
    assertEquals (getSessions ().getStatistics ().getQueryCacheMissCount (), 3);
    SimpleJtaTransactionManagerImpl.getInstance ().begin ();
    s = openSession ();
    s.createQuery ("delete from Item").executeUpdate ();
    SimpleJtaTransactionManagerImpl.getInstance ().commit ();
}


public static Map getDocumentDataFilesParameters (Connection conn, String documentID) throws Exception {
    String documentReportDefDir = "";
    String documentReportDefFileName = "";
    String companyLogoImage = "";
    String documentReportDataDir = "";
    String defaultLocale = "pt_PT";
    int numberOfCopies = 1;
    String documentReportPropFileName = "";
    ResourceBundle resourceBundle = null;
    Properties documentReportProps = new Properties ();
    try {
        Statement stmt = conn.createStatement ();
        ResultSet rs = stmt.executeQuery ("select distinct a.ParameterValue, b.ParameterValue, c.ParameterValue, d.ParameterValue, e.ParameterValue, f.ParameterValue " + " from tbl_Parameter a, tbl_Parameter b, tbl_Parameter c, tbl_Parameter d, tbl_Parameter e, tbl_Parameter f  where " + " a.ParameterID='DocumentReportDefDir' and b.ParameterID='DocumentReportDefFileName' and c.ParameterID='CompanyLogoImage' and " + " d.ParameterID='DocumentReportDataDir' and e.ParameterID='DefaultLocale' and f.ParameterID='DocumentReportPropFileName'");
        if (rs.next ()) {
            documentReportDefDir = rs.getString (1);
            documentReportDefFileName = rs.getString (2);
            companyLogoImage = rs.getString (3);
            documentReportDataDir = rs.getString (4);
            defaultLocale = rs.getString (5);
            documentReportPropFileName = rs.getString (6);
        }
        rs.close ();
        rs = stmt.executeQuery ("select dt.NumberOfCopies from tbl_DocumentType dt, tbl_Document d where dt.DocumentTypeID=d.DocumentTypeID and d.DocumentID=" + documentID);
        if (rs.next ()) {
            numberOfCopies = rs.getInt (1);
        }
        rs.close ();
        stmt.close ();
        resourceBundle = I18NMessages.getResourceBundle (defaultLocale);
        documentReportProps.load (new FileInputStream (documentReportDefDir + "/" + documentReportPropFileName));
    } catch (Exception ex) {
        logger.error ("ViewDocumentReport.java: Error getting parameters from DB: " + ex);
        ex.printStackTrace ();
        throw ex;
    }
    HashMap result = new HashMap ();
    result.putAll (getDocumentDataFilesPath (documentReportDataDir, documentID));
    result.put ("documentReportDefDir", documentReportDefDir);
    result.put ("documentReportDefFileName", documentReportDefFileName);
    result.put ("companyLogoImage", companyLogoImage);
    result.put ("documentReportDataDir", documentReportDataDir);
    result.put ("defaultLocale", defaultLocale);
    result.put ("documentReportPropFileName", documentReportPropFileName);
    result.put ("resourceBundle", resourceBundle);
    result.put ("documentReportProps", documentReportProps);
    result.put ("numberOfCopies", new Integer (numberOfCopies));
    return result;
}


-----Function Pair=393=-----==

public List < Double > getsumsm () {
    List < Double > ls = new ArrayList < Double > ();
    Connection conn = null;
    PreparedStatement pm1 = null;
    PreparedStatement pm2 = null;
    ResultSet rs1 = null;
    ResultSet rs2 = null;
    try {
        conn = Pool.getConnection ();
        pm1 = conn.prepareStatement ("select sum(outprice) from delwuliao");
        pm2 = conn.prepareStatement ("select sum(maori) from delwuliao");
        rs1 = pm1.executeQuery ();
        rs2 = pm2.executeQuery ();
        if (rs1 != null && rs2 != null) {
            while (rs1.next () && rs2.next ()) {
                ls.add (rs1.getDouble (1));
                ls.add (rs2.getDouble (1));
            }
        }
        Pool.close (rs1);
        Pool.close (rs2);
        Pool.close (pm1);
        Pool.close (pm2);
        Pool.close (conn);
    } catch (Exception e) {
        e.printStackTrace ();
        Pool.close (rs1);
        Pool.close (rs2);
        Pool.close (pm1);
        Pool.close (pm2);
        Pool.close (conn);
    } finally {
        Pool.close (rs1);
        Pool.close (rs2);
        Pool.close (pm1);
        Pool.close (pm2);
        Pool.close (conn);
    }
    return ls;
}


public static MSequence get (Properties ctx, String tableName, String trxName) {
    String sql = "SELECT * FROM AD_Sequence " + "WHERE UPPER(Name)=?" + " AND IsTableID='Y'";
    MSequence retValue = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    try {
        pstmt = DB.prepareStatement (sql, trxName);
        pstmt.setString (1, tableName.toUpperCase ());
        rs = pstmt.executeQuery ();
        if (rs.next ()) retValue = new MSequence (ctx, rs, trxName);
        if (rs.next ()) s_log.log (Level.SEVERE, "More then one sequence for " + tableName);
    } catch (Exception e) {
        s_log.log (Level.SEVERE, "get", e);
    } finally {
        DB.close (rs, pstmt);
        rs = null;
        pstmt = null;
    }
    return retValue;
}


-----Function Pair=394=-----==

public void update (StudentsGroup obj) throws UpdateException, DBConnectionException, XmlIOException {
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    Criteria newCrit = new Criteria ();
    newCrit.addCriterion ("GROUP_TYPE_ID", obj.getGroupType ().getId ());
    newCrit.addCriterion ("YEAR_STUDY_ID", obj.getYearOfStudy ().getId ());
    newCrit.addCriterion ("STUDENT_GROUP_NAME", obj.getName ());
    newCrit.addCriterion ("STUDENT_GROUP_NB_STUDENT", obj.getNbStudents ());
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("STUDENT_GROUP_ID", obj.getId ());
    try {
        stmt.executeUpdate (new UpdateQuery (StudentsGroupDAO.TABLE_NAME, newCrit, critWhere).toString ());
        stmt.getConnection ().commit ();
    } catch (SQLException e) {
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new UpdateException (TABLE_NAME + " Update exception", e);
    }
}


private String deleteConceptTermAssociation (Entry entry) throws SQLException {
    conn.setAutoCommit (false);
    int defaultLevel = conn.getTransactionIsolation ();
    conn.setTransactionIsolation (Connection.TRANSACTION_READ_COMMITTED);
    WFPlugin wf = entry.getWF (this);
    int result = - 1;
    try {
        boolean success = deleteCTAssociation (entry);
        if (! success) {
            conn.rollback ();
            return getFalseResult ();
        }
        wf.update (entry.fromId, entry.fromNamespaceId, entry.permit, WFPlugin.ATTR_ASSOCIATION, WFPlugin.EDIT_DELETE);
        wf.update (entry.toId, entry.toNamespaceId, entry.permit, WFPlugin.ATTR_ASSOCIATION, WFPlugin.EDIT_DELETE);
        conn.commit ();
        return getTrueResult ();
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } finally {
        conn.setTransactionIsolation (defaultLevel);
        conn.setAutoCommit (true);
    }
}


-----Function Pair=395=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nExercise2Id, Long nUserId) {
    List < CoScoreExercises2 > listCoScoreExercises2 = null;
    Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_SCORE_EXERCISES2, CoScoreExercises2.class);
    query.setParameter (1, nExercise2Id);
    query.setParameter (2, nUserId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listCoScoreExercises2 = query.getResultList ();
    if (listCoScoreExercises2 == null || listCoScoreExercises2.size () == 0) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("coScoreExercises2.search.notFound"));
    }
    else {
        Object [] arrayParam = {listCoScoreExercises2.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreExercises2.search.success"), arrayParam));
        serviceResult.setObjResult (listCoScoreExercises2);
        serviceResult.setNumResult (listCoScoreExercises2.size ());
    }
    return serviceResult;
}


protected void removeMessage (ReplicationMessage message) {
    logger.info (String.format ("remove replication message: %d", message.getId ()));
    ConnectionProvider cp = null;
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        SessionFactoryImplementor impl = (SessionFactoryImplementor) portalDao.getSessionFactory ();
        cp = impl.getConnectionProvider ();
        conn = cp.getConnection ();
        conn.setAutoCommit (false);
        ps = conn.prepareStatement ("delete from light_replication_message where id=?");
        ps.setLong (1, message.getId ());
        ps.executeUpdate ();
        conn.commit ();
        ps.close ();
        conn.close ();
    } catch (Exception e) {
        try {
            conn.rollback ();
            ps.close ();
            conn.close ();
        } catch (Exception se) {
        }
    }
}


-----Function Pair=396=-----==

public int getRecipeId (String recipeName) {
    System.out.println ("getRecipeId");
    PreparedStatement statement = null;
    ResultSet rs = null;
    int returnValue = - 1;
    StringBuffer query = new StringBuffer ("select recipe_id from recipes where name = ?");
    try {
        conn = getConnection ();
        statement = conn.prepareStatement (query.toString ());
        statement.setString (1, recipeName);
        rs = statement.executeQuery ();
        if (rs.next ()) returnValue = rs.getInt (1);
    } catch (Exception e) {
        MainFrame.appendStatusText ("Error when trying to execute sql: " + e.getMessage ());
    } finally {
        try {
            if (rs != null) rs.close ();
            rs = null;
            if (statement != null) statement.close ();
            statement = null;
        } catch (Exception ex) {
            MainFrame.appendStatusText ("Can't close database connection.");
        }
    }
    return returnValue;
}


public static boolean existsSchema (EboContext p_eboctx, String schemaName) throws boRuntimeException {
    Connection cn = null;
    boolean ret = false;
    PreparedStatement pstm = null;
    ResultSet rslt = null;
    try {
        cn = p_eboctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("SELECT 1 from ALL_USERS WHERE USERNAME=?");
        pstm.setString (1, schemaName.toUpperCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            return true;
        }
        rslt.close ();
        pstm.close ();
    } catch (Exception e) {
        throw new boRuntimeException ("boBuildDB.existsSchema", "BO-1304", e);
    } finally {
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
    return ret;
}


-----Function Pair=397=-----==

public PatientDocument getSymptomForPatient (String patientDocument) {
    PatientDocument in = null;
    PatientDocument out = null;
    ResultSet rsSymptom = null;
    try {
        helper = new DBHelper ();
        in = PatientDocument.Factory.parse (patientDocument);
        long dateFrom = in.getPatient ().getAdmitanceRecord ().getAdmitanceArray (0).getDateAdmited ();
        long dateTo = in.getPatient ().getAdmitanceRecord ().getAdmitanceArray (0).getDateDischarged ();
        String patientNo = in.getPatient ().getPatientno ();
        PreparedStatement psSymptom = helper.prepareStatement (SQL.getSymptomsForPatient ());
        psSymptom.setLong (1, dateFrom);
        psSymptom.setLong (2, (dateTo == 0 ? System.currentTimeMillis () : dateTo));
        psSymptom.setString (3, patientNo);
        rsSymptom = psSymptom.executeQuery ();
        out = PatientDocument.Factory.newInstance ();
        out.addNewPatient ().addNewVectors ().addNewVector ().addNewSymptomRatingList ();
        while (rsSymptom.next ()) {
            SymptomRatingType s = out.getPatient ().getVectors ().getVectorArray (0).getSymptomRatingList ().addNewRating ();
            s.setSymptom (rsSymptom.getString ("SYMPTOM"));
            s.setSymptomNo (rsSymptom.getString ("SYMPTOMNO"));
            s.setDsm (rsSymptom.getString ("GROUPDESCRIPTION"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsSymptom != null) {
                rsSymptom.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return out;
}


public List < AcDataProject > getAllAcDataProjectPagination (Integer projectId, int offset, int limit, String sort, String dir, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("from ");
        hqlSB.append (AcDataProject.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" data.id = '" + projectId + "' order by " + sort + " " + dir);
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        queryObject.setFirstResult (offset);
        queryObject.setMaxResults (limit);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=398=-----==

public RestServiceResult create (RestServiceResult result, CoTechnical coTechnical) {
    CoTechnicalDAO coTechnicalDAO = new CoTechnicalDAO ();
    try {
        coTechnical.setTechnicalId (getSequence ("sq_co_technical"));
        EntityManagerHelper.beginTransaction ();
        coTechnicalDAO.save (coTechnical);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coTechnical);
        Object [] args = {coTechnical.getTechnicalName (), coTechnical.getTechnicalId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("technical.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar la t�cnica: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


public static void BubbleSortInt1 (int [] num) {
    boolean flag = true;
    int temp;
    while (flag) {
        flag = false;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=399=-----==

public final int delete (List < DeletableBean > deletableList, Session session) throws HibernateException {
    Transaction tx = null;
    int i, result = 0, size = deletableList.size ();
    DeletableBean deletable = null;
    try {
        tx = session.beginTransaction ();
        for (i = 0; i < size; i ++) {
            deletable = deletableList.get (i);
            result += session.createQuery ("delete from " + deletable.getBeanClass () + " o where o.id =" + deletable.getId ()).executeUpdate ();
        }
        tx.commit ();
        session.flush ();
        session.close ();
    } catch (HibernateException e) {
        if (tx != null) tx.rollback ();
        session.close ();
        throw e;
    }
    return result;
}


public Disciplina consultar (String t) throws Exception {
    PreparedStatement stmt = null;
    String sql = "SELECT d.nm_disciplina, d.id_disciplina, d.cod_disciplina, t.nm_topico " + "FROM disciplina d, topico t  " + "WHERE d.nm_disciplina = ? " + "AND d.id_disciplina = t.id_disciplina";
    try {
        stmt = conexao.prepareStatement (sql);
        stmt.setString (1, t);
        ResultSet rs = stmt.executeQuery ();
        conexao.commit ();
        Disciplina disciplina = new Disciplina ();
        int count = 0;
        while (rs.next ()) {
            count ++;
            disciplina.setNomeDisciplina (rs.getString (1));
            disciplina.setIdDisciplina (rs.getInt (2));
            disciplina.setCodDisciplina (rs.getString (3));
            disciplina.setTopicos (listarTopicos (disciplina));
        }
        if (count > 0) {
            return disciplina;
        }
        else {
            return null;
        }
    } catch (SQLException e) {
        conexao.rollback ();
        throw e;
    }
}


-----Function Pair=400=-----==

public void executeUpdateForcedApplications () {
    String userId = "";
    Object idObject = parameters.get (DataConnector.RECORD_KEY_PARAMETER);
    if (idObject != null) {
        if (StringUtils.isString (idObject)) {
            String originalId = (String) idObject;
            userId = originalId.toLowerCase ();
        }
    }
    Session session = null;
    Transaction tx = null;
    try {
        session = sessionFactory.openSession ();
        tx = session.beginTransaction ();
        List newValues = (List) parameters.get (DataConnector.RECORD_PARAMETER);
        BasicUser user = (BasicUser) session.load (BasicUser.class, userId);
        user.setForcedApplications (newValues);
        user.setLastUpdate (new Date ());
        user.setLastUpdateBy (UserProfileManager.getUserId ());
        tx.commit ();
        responseCode = 0;
        responseString = "Execution complete";
    } catch (Throwable t) {
        responseCode = 10;
        responseString = t.toString ();
        t.printStackTrace ();
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    } finally {
        if (session != null) {
            try {
                session.close ();
            } catch (Throwable t2) {
                t2.printStackTrace ();
            }
        }
    }
}


public static void main (String [] Args) {
    String DriverName = "";
    String DBUrl = "";
    String DBUser = "";
    String DBPassword = "";
    boolean initialize_dataset = true;
    for (int i = 0; i < Args.length; i ++) {
        if (Args [i].equals ("-clients")) {
            if (i + 1 < Args.length) {
                i ++;
                n_clients = Integer.parseInt (Args [i]);
            }
        }
        else if (Args [i].equals ("-driver")) {
            if (i + 1 < Args.length) {
                i ++;
                DriverName = Args [i];
                if (DriverName.equals ("org.hsqldb.jdbc.JDBCDriver") || DriverName.equals ("org.hsqldb.jdbcDriver")) {
                }
            }
        }
        else if (Args [i].equals ("-url")) {
            if (i + 1 < Args.length) {
                i ++;
                DBUrl = Args [i];
            }
        }
        else if (Args [i].equals ("-user")) {
            if (i + 1 < Args.length) {
                i ++;
                DBUser = Args [i];
            }
        }
        else if (Args [i].equals ("-password")) {
            if (i + 1 < Args.length) {
                i ++;
                DBPassword = Args [i];
            }
        }
        else if (Args [i].equals ("-tpc")) {
            if (i + 1 < Args.length) {
                i ++;
                n_txn_per_client = Integer.parseInt (Args [i]);
            }
        }
        else if (Args [i].equals ("-init")) {
            initialize_dataset = true;
        }
        else if (Args [i].equals ("-tps")) {
            if (i + 1 < Args.length) {
                i ++;
                tps = Integer.parseInt (Args [i]);
            }
        }
        else if (Args [i].equals ("-rounds")) {
            if (i + 1 < Args.length) {
                i ++;
                rounds = Integer.parseInt (Args [i]);
            }
        }
        else if (Args [i].equals ("-sp")) {
            useStoredProcedure = true;
        }
        else if (Args [i].equals ("-v")) {
            verbose = true;
        }
    }
    if (DriverName.length () == 0 || DBUrl.length () == 0) {
        System.out.println ("usage: java TestBench -driver [driver_class_name] -url [url_to_db] -user [username] -password [password] [-v] [-init] [-tpc n] [-clients n]");
        System.out.println ();
        System.out.println ("-v          verbose error messages");
        System.out.println ("-init       initialize the tables");
        System.out.println ("-tpc        transactions per client");
        System.out.println ("-clients    number of simultaneous clients");
        System.exit (- 1);
    }
    System.out.println ("*********************************************************");
    System.out.println ("* TestBench v1.1                                        *");
    System.out.println ("*********************************************************");
    System.out.println ();
    System.out.println ("Driver: " + DriverName);
    System.out.println ("URL:" + DBUrl);
    System.out.println ();
    System.out.println ("Scale factor value: " + tps);
    System.out.println ("Number of clients: " + n_clients);
    System.out.println ("Number of transactions per client: " + n_txn_per_client);
    System.out.println ();
    try {
        Class.forName (DriverName);
        TestBench Me = new TestBench (DBUrl, DBUser, DBPassword, initialize_dataset);
    } catch (Exception E) {
        System.out.println (E.getMessage ());
        E.printStackTrace ();
    }
}


