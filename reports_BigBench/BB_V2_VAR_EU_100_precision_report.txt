Found 28/400 pairs as clones in the BCB
-----Function Pair=1=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=2=-----==

public static View findView (org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=3=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.SaveccmDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.SaveccmDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            Composite model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, CompositeEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (se.mdh.mrtc.saveccm.composite.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.PlwebDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.PlwebDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            DiagramRoot model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, DiagramRootEditPart.MODEL_ID, PlwebDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (org.spbu.plweb.diagram.part.PlwebDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (org.spbu.plweb.diagram.part.PlwebDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                PlwebDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        PlwebDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=4=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (org.eclipse.gmf.runtime.diagram.ui.editparts.DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=5=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=6=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=7=-----==

static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


-----Function Pair=8=-----==

public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


-----Function Pair=9=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=10=-----==

public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=11=-----==

static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


-----Function Pair=12=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=13=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.MxgraphclipseDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.MxgraphclipseDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            org.mxeclipse.mxgraphclipse.Map model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, MapEditPart.MODEL_ID, MxgraphclipseDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (org.mxeclipse.mxgraphclipse.diagram.part.MxgraphclipseDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (org.mxeclipse.mxgraphclipse.diagram.part.MxgraphclipseDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                MxgraphclipseDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        MxgraphclipseDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.SaveccmDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.SaveccmDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            System model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, SystemEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (se.mdh.mrtc.saveccm.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (se.mdh.mrtc.saveccm.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=14=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=15=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=16=-----==

private static boolean buildElement2ViewMap (View parentView, Map < EObject, View > element2ViewMap, Set < ? extends EObject > elements) {
    if (elements.size () == element2ViewMap.size ()) {
        return true;
    }
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) {
            return true;
        }
    }
    boolean complete = false;
    for (Iterator < ? > it = parentView.getChildren ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    for (Iterator < ? > it = parentView.getSourceEdges ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    for (Iterator < ? > it = parentView.getTargetEdges ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    return complete;
}


private static boolean buildElement2ViewMap (View parentView, Map < EObject, View > element2ViewMap, Set < ? extends EObject > elements) {
    if (elements.size () == element2ViewMap.size ()) {
        return true;
    }
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) {
            return true;
        }
    }
    boolean complete = false;
    for (Iterator < ? > it = parentView.getChildren ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    for (Iterator < ? > it = parentView.getSourceEdges ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    for (Iterator < ? > it = parentView.getTargetEdges ().iterator (); it.hasNext () && ! complete;) {
        complete = buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
    }
    return complete;
}


-----Function Pair=17=-----==

public final Map < EObject, View > getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap < EObject, View > ();
        for (EObject element : elementSet) {
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, view);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map < EObject, View > getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap < EObject, View > ();
        for (EObject element : elementSet) {
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, view);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=18=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=19=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof SaveccmAbstractNavigatorItem) {
        return;
    }
    SaveccmAbstractNavigatorItem abstractNavigatorItem = (SaveccmAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof SaveccmNavigatorItem) {
        navigatorView = ((SaveccmNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof SaveccmNavigatorGroup) {
        SaveccmNavigatorGroup navigatorGroup = (SaveccmNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof SaveccmNavigatorItem) {
            navigatorView = ((SaveccmNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof BmmAbstractNavigatorItem) {
        return;
    }
    BmmAbstractNavigatorItem abstractNavigatorItem = (BmmAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof BmmNavigatorItem) {
        navigatorView = ((BmmNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof BmmNavigatorGroup) {
        BmmNavigatorGroup navigatorGroup = (BmmNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof BmmNavigatorItem) {
            navigatorView = ((BmmNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=20=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=21=-----==

static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


-----Function Pair=22=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=23=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof CtbAbstractNavigatorItem) {
        return;
    }
    CtbAbstractNavigatorItem abstractNavigatorItem = (CtbAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof CtbNavigatorItem) {
        navigatorView = ((CtbNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof CtbNavigatorGroup) {
        CtbNavigatorGroup navigatorGroup = (CtbNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof CtbNavigatorItem) {
            navigatorView = ((CtbNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof SiseorAbstractNavigatorItem) {
        return;
    }
    SiseorAbstractNavigatorItem abstractNavigatorItem = (SiseorAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof SiseorNavigatorItem) {
        navigatorView = ((SiseorNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof SiseorNavigatorGroup) {
        SiseorNavigatorGroup navigatorGroup = (SiseorNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof SiseorNavigatorItem) {
            navigatorView = ((SiseorNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=24=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof DrlModelAbstractNavigatorItem) {
        return;
    }
    DrlModelAbstractNavigatorItem abstractNavigatorItem = (DrlModelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof DrlModelNavigatorItem) {
        navigatorView = ((DrlModelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof DrlModelNavigatorGroup) {
        DrlModelNavigatorGroup navigatorGroup = (DrlModelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof DrlModelNavigatorItem) {
            navigatorView = ((DrlModelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof MindmapAbstractNavigatorItem) {
        return;
    }
    MindmapAbstractNavigatorItem abstractNavigatorItem = (MindmapAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof MindmapNavigatorItem) {
        navigatorView = ((MindmapNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof MindmapNavigatorGroup) {
        MindmapNavigatorGroup navigatorGroup = (MindmapNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof MindmapNavigatorItem) {
            navigatorView = ((MindmapNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=25=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=26=-----==

public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


public static String getUniqueFileName (IPath containerFullPath, String fileName, String extension) {
    if (containerFullPath == null) {
        containerFullPath = new Path ("");
    }
    if (fileName == null || fileName.trim ().length () == 0) {
        fileName = "default";
    }
    IPath filePath = containerFullPath.append (fileName);
    if (extension != null && ! extension.equals (filePath.getFileExtension ())) {
        filePath = filePath.addFileExtension (extension);
    }
    extension = filePath.getFileExtension ();
    fileName = filePath.removeFileExtension ().lastSegment ();
    int i = 1;
    while (ResourcesPlugin.getWorkspace ().getRoot ().exists (filePath)) {
        i ++;
        filePath = containerFullPath.append (fileName + i);
        if (extension != null) {
            filePath = filePath.addFileExtension (extension);
        }
    }
    return filePath.lastSegment ();
}


-----Function Pair=27=-----==

void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=28=-----==

private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=29=-----==

public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].startsWith ("0x") || args [0].startsWith ("0X") || args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


-----Function Pair=30=-----==

protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getBlue ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


protected int findClosest (Color c) {
    if (colorTab == null) return - 1;
    int r = c.getRed ();
    int g = c.getGreen ();
    int b = c.getBlue ();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
        int dr = r - (colorTab [i ++] & 0xff);
        int dg = g - (colorTab [i ++] & 0xff);
        int db = b - (colorTab [i] & 0xff);
        int d = dr * dr + dg * dg + db * db;
        int index = i / 3;
        if (usedEntry [index] && (d < dmin)) {
            dmin = d;
            minpos = index;
        }
        i ++;
    }
    return minpos;
}


-----Function Pair=31=-----==

public void onChange (Widget arg0) {
    switch (scope.getSelectedIndex ()) {
        case FilterData.LEVEL :
            setLevel ();
            break;
        case FilterData.URI :
            setNormal ();
            break;
        case FilterData.LOGGER :
            setNormal ();
            break;
        case FilterData.CLASS :
            setNormal ();
            break;
        case FilterData.METHOD :
            setNormal ();
            break;
        case FilterData.MESSAGE :
            setNormal ();
            break;
        case FilterData.ACK :
            setAck ();
            break;
    }
}


public static boolean isLetter (char character) {
    switch (character) {
        case 'a' :
            return true;
        case 'b' :
            return true;
        case 'c' :
            return true;
        case 'd' :
            return true;
        case 'e' :
            return true;
        case 'f' :
            return true;
        case 'g' :
            return true;
        case 'h' :
            return true;
        case 'i' :
            return true;
        case 'j' :
            return true;
        case 'k' :
            return true;
        case 'l' :
            return true;
        case 'm' :
            return true;
        case 'n' :
            return true;
        case 'o' :
            return true;
        case 'p' :
            return true;
        case 'q' :
            return true;
        case 'r' :
            return true;
        case 's' :
            return true;
        case 't' :
            return true;
        case 'u' :
            return true;
        case 'v' :
            return true;
        case 'w' :
            return true;
        case 'x' :
            return true;
        case 'y' :
            return true;
        case 'z' :
            return true;
        case 'A' :
            return true;
        case 'B' :
            return true;
        case 'C' :
            return true;
        case 'D' :
            return true;
        case 'E' :
            return true;
        case 'F' :
            return true;
        case 'G' :
            return true;
        case 'H' :
            return true;
        case 'I' :
            return true;
        case 'J' :
            return true;
        case 'K' :
            return true;
        case 'L' :
            return true;
        case 'M' :
            return true;
        case 'N' :
            return true;
        case 'O' :
            return true;
        case 'P' :
            return true;
        case 'Q' :
            return true;
        case 'R' :
            return true;
        case 'S' :
            return true;
        case 'T' :
            return true;
        case 'U' :
            return true;
        case 'V' :
            return true;
        case 'W' :
            return true;
        case 'X' :
            return true;
        case 'Y' :
            return true;
        case 'Z' :
            return true;
        default :
            return false;
    }
}


-----Function Pair=32=-----==

public void doClearBreakpoint (String command, String [] args) {
    if (args.length == 0) {
        user.bpset.clearBreakpoint ();
        jdp_console.writeOutput ("breakpoint cleared");
    }
    else if (args [0].equals ("all")) {
        user.bpset.clearAllBreakpoint ();
        jdp_console.writeOutput ("all breakpoints cleared");
    }
    else {
        try {
            int addr = parseHex32 (args [0]);
            breakpoint bp = user.bpset.lookup (addr);
            if (bp != null) {
                user.bpset.clearBreakpoint (bp);
                jdp_console.writeOutput ("breakpoint cleared");
            }
            else jdp_console.writeOutput ("no breakpoint at " + args [0]);
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("Clear breakpoint: please specify hex address");
        }
    }
}


public void doClearBreakpoint (String command, String [] args) {
    if (args.length == 0) {
        user.bpset.clearBreakpoint ();
        jdp_console.writeOutput ("breakpoint cleared");
    }
    else if (args [0].equals ("all")) {
        user.bpset.clearAllBreakpoint ();
        jdp_console.writeOutput ("all breakpoints cleared");
    }
    else {
        try {
            int addr = parseHex32 (args [0]);
            breakpoint bp = user.bpset.lookup (addr);
            if (bp != null) {
                user.bpset.clearBreakpoint (bp);
                jdp_console.writeOutput ("breakpoint cleared");
            }
            else jdp_console.writeOutput ("no breakpoint at " + args [0]);
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("Clear breakpoint: please specify hex address");
        }
    }
}


-----Function Pair=33=-----==

public void doGetInstanceCommand (String command, String [] args) {
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            JDP_Class jdpClass = new JDP_Class ();
            jdpClass.address = parseHex32 (args [1]);
            jdpClass.name = args [0].substring (1, rparen);
            jdpClass.instance = true;
            try {
                user.bmap.classToJDPClass (jdpClass.name, jdpClass.address, false, jdpClass);
                jdpClass.fields.trimToSize ();
                jdp_console.writeOutput (jdpClass);
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            } catch (NoSuchClassException e2) {
                jdp_console.writeOutput (jdpClass.name + " is an invalid class name");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
    }
    else {
        jdp_console.writeOutput ("invalid args for getinstance");
    }
    return;
}


public void doGetInstanceCommand (String command, String [] args) {
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            JDP_Class jdpClass = new JDP_Class ();
            jdpClass.address = parseHex32 (args [1]);
            jdpClass.name = args [0].substring (1, rparen);
            jdpClass.instance = true;
            try {
                user.bmap.classToJDPClass (jdpClass.name, jdpClass.address, false, jdpClass);
                jdpClass.fields.trimToSize ();
                jdp_console.writeOutput (jdpClass);
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            } catch (NoSuchClassException e2) {
                jdp_console.writeOutput (jdpClass.name + " is an invalid class name");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
    }
    else {
        jdp_console.writeOutput ("invalid args for getinstance");
    }
    return;
}


-----Function Pair=34=-----==

void generateOutputFromTemplate () throws IOException {
    try {
        String inLine;
        for (inLine = readLine (); inLine != null; inLine = readLine ()) {
            if (DEBUG) System.out.println ("from input:" + inLine);
            if (! isTemplateLine (inLine)) {
                if (DEBUG) System.out.println ("not template line, continuing...");
                out.print (inLine + "\n");
                continue;
            }
            Vector region = buildTemplateRegion (inLine);
            processTemplateRegion (region);
        }
    } finally {
        out.flush ();
    }
}


void generateOutputFromTemplate () throws IOException {
    try {
        String inLine;
        for (inLine = readLine (); inLine != null; inLine = readLine ()) {
            if (DEBUG) System.out.println ("from input:" + inLine);
            if (! isTemplateLine (inLine)) {
                if (DEBUG) System.out.println ("not template line, continuing...");
                out.print (inLine + "\n");
                continue;
            }
            Vector region = buildTemplateRegion (inLine);
            processTemplateRegion (region);
        }
    } finally {
        out.flush ();
    }
}


-----Function Pair=35=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=36=-----==

void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=37=-----==

public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


-----Function Pair=38=-----==

void generateOutputFromTemplate () throws IOException {
    try {
        String inLine;
        for (inLine = readLine (); inLine != null; inLine = readLine ()) {
            if (DEBUG) System.out.println ("from input:" + inLine);
            if (! isTemplateLine (inLine)) {
                if (DEBUG) System.out.println ("not template line, continuing...");
                out.print (inLine + "\n");
                continue;
            }
            Vector region = buildTemplateRegion (inLine);
            processTemplateRegion (region);
        }
    } finally {
        out.flush ();
    }
}


void generateOutputFromTemplate () throws IOException {
    try {
        String inLine;
        for (inLine = readLine (); inLine != null; inLine = readLine ()) {
            if (DEBUG) System.out.println ("from input:" + inLine);
            if (! isTemplateLine (inLine)) {
                if (DEBUG) System.out.println ("not template line, continuing...");
                out.print (inLine + "\n");
                continue;
            }
            Vector region = buildTemplateRegion (inLine);
            processTemplateRegion (region);
        }
    } finally {
        out.flush ();
    }
}


-----Function Pair=39=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=40=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=41=-----==

Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


Vector buildTemplateRegion (String inLine) throws IOException {
    Vector region = new Vector ();
    region.addElement (inLine);
    int command = getTemplateCommand (inLine);
    if (DEBUG) System.out.println ("template command #" + command);
    switch (command) {
        case FOREACH :
        case LOOP :
        case SPLIT :
        case JOIN :
        case EVAL :
        case LET :
        case COUNT :
            buildLoopRegion (region);
            break;
        case IF :
            buildCondRegion (region);
            break;
        case INCLUDE :
            buildIncludeRegion (region);
            break;
        default :
            throw new IOException ("Invalid command");
    }
    return region;
}


-----Function Pair=42=-----==

public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=43=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=44=-----==

void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processLetRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    StringReader sr = new StringReader (params);
    StreamTokenizer pst = new StreamTokenizer (sr);
    pst.ordinaryChar ('-');
    pst.ordinaryChar ('/');
    pst.ordinaryChar ('*');
    pst.wordChars ('@', '@');
    pst.wordChars ('_', '_');
    int tok = pst.nextToken ();
    if (tok != pst.TT_WORD) throw new IOException ("Missing var name in LET");
    String var_name = pst.sval;
    if (pst.nextToken () == pst.TT_EOF) throw new IOException ("Missing value in LET");
    pst.pushBack ();
    String value = evalLet (pst);
    if (DEBUG) System.out.println ("doing let with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=45=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=46=-----==

void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=47=-----==

void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=48=-----==

private String acceptKeystroke () {
    historyCursor = history.size ();
    load ("");
    byte keystroke = readKeystroke ();
    for (;;) {
        switch (keystroke) {
            case K_NOP :
            case K_TAB :
                break;
            case K_BSP :
                if (bufferCursor > 0) {
                    -- bufferCursor;
                    delete ();
                }
                else beep ();
                break;
            case K_ESC :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        log.println ("completion not found for: " + toComplete);
                        beep ();
                    }
                    else load (completed);
                    break;
                }
            case K_SPACE :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        if (CommandCompletion.moreSpaceKeyExpected (toComplete)) {
                            insert (keystroke);
                            ++ bufferCursor;
                        }
                        else {
                            beep ();
                        }
                    }
                    else load (completed);
                    break;
                }
            case K_ENTER :
                {
                    String string = new String (buffer);
                    if (string.length () != 0) {
                        history.removeElement (string);
                        history.addElement (string);
                    }
                    historyCursor = history.size ();
                    load ("");
                    return string;
                }
            case K_UP :
                up ();
                break;
            case K_DN :
                down ();
                break;
            case K_RT :
                right ();
                break;
            case K_LT :
                left ();
                break;
            case K_HOME :
                home ();
                break;
            case K_END :
                end ();
                break;
            case K_DEL :
                delete ();
                break;
            default :
                insert (keystroke);
                ++ bufferCursor;
        }
        keystroke = readKeystroke ();
    }
}


private String acceptKeystroke () {
    historyCursor = history.size ();
    load ("");
    byte keystroke = readKeystroke ();
    for (;;) {
        switch (keystroke) {
            case K_NOP :
            case K_TAB :
                break;
            case K_BSP :
                if (bufferCursor > 0) {
                    -- bufferCursor;
                    delete ();
                }
                else beep ();
                break;
            case K_ESC :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        log.println ("completion not found for: " + toComplete);
                        beep ();
                    }
                    else load (completed);
                    break;
                }
            case K_SPACE :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        if (CommandCompletion.moreSpaceKeyExpected (toComplete)) {
                            insert (keystroke);
                            ++ bufferCursor;
                        }
                        else {
                            beep ();
                        }
                    }
                    else load (completed);
                    break;
                }
            case K_ENTER :
                {
                    String string = new String (buffer);
                    if (string.length () != 0) {
                        history.removeElement (string);
                        history.addElement (string);
                    }
                    historyCursor = history.size ();
                    load ("");
                    return string;
                }
            case K_UP :
                up ();
                break;
            case K_DN :
                down ();
                break;
            case K_RT :
                right ();
                break;
            case K_LT :
                left ();
                break;
            case K_HOME :
                home ();
                break;
            case K_END :
                end ();
                break;
            case K_DEL :
                delete ();
                break;
            default :
                insert (keystroke);
                ++ bufferCursor;
        }
        keystroke = readKeystroke ();
    }
}


-----Function Pair=49=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=50=-----==

void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=51=-----==

void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=52=-----==

void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=53=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=54=-----==

public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


public String nextToken () {
    skipDelimiters ();
    if (curPos >= maxPos) throw new NoSuchElementException ();
    int start = curPos;
    if (str.charAt (curPos) == '\"') {
        start ++;
        curPos ++;
        boolean quoted = false;
        while (quoted || str.charAt (curPos) != '\"') {
            quoted = ! quoted && str.charAt (curPos) == '\\';
            curPos ++;
            if (curPos >= maxPos) throw new UnterminatedStringException ();
        }
        StringBuffer sb = new StringBuffer ();
        String s = str.substring (start, curPos ++);
        int st = 0;
        for (;;) {
            int bs = s.indexOf ('\\', st);
            if (bs == - 1) break;
            sb.append (s.substring (st, bs));
            sb.append (s.substring (bs + 1, bs + 2));
            st = bs + 2;
        }
        sb.append (s.substring (st));
        return sb.toString ();
    }
    while (curPos < maxPos && delim.indexOf (str.charAt (curPos)) < 0) curPos ++;
    return str.substring (start, curPos);
}


-----Function Pair=55=-----==

void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=56=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=57=-----==

private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


private String evalSubst (StreamTokenizer st) throws IOException {
    if (st.nextToken () != '(') throw new IOException ("Missing '('");
    StringBuffer val = new StringBuffer (evalStrExpr (st));
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String oldc = st.sval;
    if (st.nextToken () != ',') throw new IOException ("Missing ','");
    if (st.nextToken () != '"') throw new IOException ("Invalid string");
    String newc = st.sval;
    if (st.nextToken () != ')') throw new IOException ("Missing ')'");
    for (int i = 0; i < val.length (); i ++) {
        int l = oldc.indexOf (val.charAt (i));
        if (l != - 1) val.setCharAt (i, newc.charAt (l));
    }
    return val.toString ();
}


-----Function Pair=58=-----==

void mousePressed (A_3D_editing.CustomCanvas ic, MouseEvent e) {
    try {
        ic.dragged = findBallInBallField (ic.x_p, ic.y_p);
    } catch (Exception ebp) {
        IJ.write ("error at mousePressed at Ball at findpointinballfield: " + ebp);
    }
    if (ic.dragged != - 1 && e.isControlDown ()) {
        removeBall (ic.dragged);
        ic.post_action = "deleted";
        ic.repaint ();
        return;
    }
    else if (ic.dragged == - 1 && ! e.isControlDown ()) {
        ic.dragged = addBall (ic.x_p, ic.y_p, Double.parseDouble (ic.a3de.csw.pipepointwidth.getText ()));
        ic.post_action = "added";
        ic.repaint ();
        return;
    }
}


void mousePressed (A_3D_editing.CustomCanvas ic, MouseEvent e) {
    try {
        ic.dragged = findBallInBallField (ic.x_p, ic.y_p);
    } catch (Exception ebp) {
        IJ.write ("error at mousePressed at Ball at findpointinballfield: " + ebp);
    }
    if (ic.dragged != - 1 && e.isControlDown ()) {
        removeBall (ic.dragged);
        ic.post_action = "deleted";
        ic.repaint ();
        return;
    }
    else if (ic.dragged == - 1 && ! e.isControlDown ()) {
        ic.dragged = addBall (ic.x_p, ic.y_p, Double.parseDouble (ic.a3de.csw.pipepointwidth.getText ()));
        ic.post_action = "added";
        ic.repaint ();
        return;
    }
}


-----Function Pair=59=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=60=-----==

public void visitNewArray (JCNewArray tree) {
    if (tree.elems != null) {
        Type elemtype = types.elemtype (tree.type);
        loadIntConst (tree.elems.length ());
        Item arr = makeNewArray (tree.pos (), tree.type, 1);
        int i = 0;
        for (List < JCExpression > l = tree.elems; l.nonEmpty (); l = l.tail) {
            arr.duplicate ();
            loadIntConst (i);
            i ++;
            genExpr (l.head, elemtype).load ();
            items.makeIndexedItem (elemtype).store ();
        }
        result = arr;
    }
    else {
        for (List < JCExpression > l = tree.dims; l.nonEmpty (); l = l.tail) {
            genExpr (l.head, syms.intType).load ();
        }
        result = makeNewArray (tree.pos (), tree.type, tree.dims.length ());
    }
}


public void visitNewArray (JCNewArray tree) {
    if (tree.elems != null) {
        Type elemtype = types.elemtype (tree.type);
        loadIntConst (tree.elems.length ());
        Item arr = makeNewArray (tree.pos (), tree.type, 1);
        int i = 0;
        for (List < JCExpression > l = tree.elems; l.nonEmpty (); l = l.tail) {
            arr.duplicate ();
            loadIntConst (i);
            i ++;
            genExpr (l.head, elemtype).load ();
            items.makeIndexedItem (elemtype).store ();
        }
        result = arr;
    }
    else {
        for (List < JCExpression > l = tree.dims; l.nonEmpty (); l = l.tail) {
            genExpr (l.head, syms.intType).load ();
        }
        result = makeNewArray (tree.pos (), tree.type, tree.dims.length ());
    }
}


-----Function Pair=61=-----==

protected void writeGraphicCtrlExt () throws IOException {
    out.write (0x21);
    out.write (0xf9);
    out.write (4);
    int transp, disp;
    if (transparent == null) {
        transp = 0;
        disp = 0;
    }
    else {
        transp = 1;
        disp = 2;
    }
    if (dispose >= 0) {
        disp = dispose & 7;
    }
    disp <<= 2;
    out.write (0 | disp | 0 | transp);
    writeShort (delay);
    out.write (transIndex);
    out.write (0);
}


protected void writeGraphicCtrlExt () throws IOException {
    out.write (0x21);
    out.write (0xf9);
    out.write (4);
    int transp, disp;
    if (transparent == null) {
        transp = 0;
        disp = 0;
    }
    else {
        transp = 1;
        disp = 2;
    }
    if (dispose >= 0) {
        disp = dispose & 7;
    }
    disp <<= 2;
    out.write (disp | transp);
    writeShort (delay);
    out.write (transIndex);
    out.write (0);
}


-----Function Pair=62=-----==

private int decodeWhiteCodeWord () throws IIOException {
    int current, entry, bits, isT, twoBits, code = - 1;
    int runLength = 0;
    boolean isWhite = true;
    while (isWhite) {
        current = nextNBits (10);
        entry = white [current];
        isT = entry & 0x0001;
        bits = (entry>>> 1) & 0x0f;
        if (bits == 12) {
            twoBits = nextLesserThan8Bits (2);
            current = ((current << 2) & 0x000c) | twoBits;
            entry = additionalMakeup [current];
            bits = (entry>>> 1) & 0x07;
            code = (entry>>> 4) & 0x0fff;
            runLength += code;
            updatePointer (4 - bits);
        }
        else if (bits == 0) {
            throw new IIOException ("Error 0");
        }
        else if (bits == 15) {
            throw new IIOException ("Error 1");
        }
        else {
            code = (entry>>> 5) & 0x07ff;
            runLength += code;
            updatePointer (10 - bits);
            if (isT == 0) {
                isWhite = false;
            }
        }
    }
    return runLength;
}


private int decodeWhiteCodeWord () {
    int current, entry, bits, isT, twoBits, code = - 1;
    int runLength = 0;
    boolean isWhite = true;
    while (isWhite) {
        current = nextNBits (10);
        entry = white [current];
        isT = entry & 0x0001;
        bits = (entry>>> 1) & 0x0f;
        if (bits == 12) {
            twoBits = nextLesserThan8Bits (2);
            current = ((current << 2) & 0x000c) | twoBits;
            entry = additionalMakeup [current];
            bits = (entry>>> 1) & 0x07;
            code = (entry>>> 4) & 0x0fff;
            runLength += code;
            updatePointer (4 - bits);
        }
        else if (bits == 0) {
            throw new RuntimeException ("Invalid code encountered.");
        }
        else if (bits == 15) {
            throw new RuntimeException ("EOL code word encountered in White run.");
        }
        else {
            code = (entry>>> 5) & 0x07ff;
            runLength += code;
            updatePointer (10 - bits);
            if (isT == 0) {
                isWhite = false;
            }
        }
    }
    return runLength;
}


-----Function Pair=63=-----==

public void doRegisterRead (String command, String [] args) {
    try {
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.reg.getValue ("0", 0));
                break;
            case 1 :
                jdp_console.writeOutput (user.reg.getValue (args [0], 1));
                break;
            case 2 :
                try {
                    int count = Integer.parseInt (args [1]);
                    jdp_console.writeOutput (user.reg.getValue (args [0], count));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput ("bad count: " + args [1]);
                }
                break;
            default :
                printHelp (command);
        }
    } catch (Exception e) {
        jdp_console.writeOutput (e.getMessage ());
    }
}


public void doRegisterRead (String command, String [] args) {
    try {
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.reg.getValue ("0", 0));
                break;
            case 1 :
                jdp_console.writeOutput (user.reg.getValue (args [0], 1));
                break;
            case 2 :
                try {
                    int count = Integer.parseInt (args [1]);
                    jdp_console.writeOutput (user.reg.getValue (args [0], count));
                } catch (NumberFormatException e) {
                    jdp_console.writeOutput ("bad count: " + args [1]);
                }
                break;
            default :
                printHelp (command);
        }
    } catch (Exception e) {
        jdp_console.writeOutput (e.getMessage ());
    }
}


-----Function Pair=64=-----==

void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


-----Function Pair=65=-----==

public void actionPerformed (ActionEvent ae) {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            thisInstance.setEnabled (false);
            try {
                searcher.next (((Number) numberOfResultsSpinner.getValue ()).intValue ());
            } catch (Exception e) {
                e.printStackTrace ();
                thisInstance.setEnabled (true);
            }
            processFinished ();
            pageOfResults ++;
            titleResults.setText ("Results - Page " + pageOfResults);
            thisInstance.setEnabled (true);
        }
    }
    );
}


void initGame () {
    moveControl.setUpSequence ();
    notifyAll (moveControl.getSequenceMessage ());
    cardsTalon.clear ();
    cardsTalon.addAll (deck.getAllCards ());
    riffleTalon ();
    LOGGER.info ("talon has " + cardsTalon.size () + " cards, these are " + cardsTalon);
    LOGGER.info ("dealing out " + MAU_MAU_HAND_CARDS_COUNT + " cards to " + moveControl.getSeatsOccupied () + " subscribers");
    moveControl.sendCardsFromTalonToAllPlayers (MAU_MAU_HAND_CARDS_COUNT);
    cardsStack.clear ();
    cardsStack.push (cardsTalon.pop ());
    notifyAll (new CardPutDown (getName (), cardsStack.peek ()));
    move = new MauMauTableMove (cardsStack.peek (), getNextToken ());
    move.dismissPenalty ();
    move.dismissRequirement ();
    move.dismissSkipping ();
    move.setSealed ();
}


-----Function Pair=66=-----==

private void findNextPair () {
    for (int i = 0; i < numClusters; i ++) {
        r [i] = 0;
        for (int j = 0; j < numClusters; j ++) {
            r [i] += getDist (i, j);
        }
    }
    besti = 0;
    bestj = 1;
    double smax = - 1.0;
    scale = 1.0 / (numClusters - 2);
    for (int i = 0; i < numClusters - 1; i ++) {
        for (int j = i + 1; j < numClusters; j ++) {
            double sij = (r [i] + r [j]) * scale - getDist (i, j);
            if (sij > smax) {
                smax = sij;
                besti = i;
                bestj = j;
            }
        }
    }
    abi = alias [besti];
    abj = alias [bestj];
}


private void findNextPair () {
    for (int i = 0; i < numClusters; i ++) {
        r [i] = 0;
        for (int j = 0; j < numClusters; j ++) {
            r [i] += getDist (i, j);
        }
    }
    besti = 0;
    bestj = 1;
    double smax = - 1.0;
    scale = 1.0 / (numClusters - 2);
    for (int i = 0; i < numClusters - 1; i ++) {
        for (int j = i + 1; j < numClusters; j ++) {
            double sij = (r [i] + r [j]) * scale - getDist (i, j);
            if (sij > smax) {
                smax = sij;
                besti = i;
                bestj = j;
            }
        }
    }
    abi = alias [besti];
    abj = alias [bestj];
}


-----Function Pair=67=-----==

private int [] AStar (Graph g, int v1, int v2) {
    int [] resultArray;
    if (! g.freshlyReset) {
        g.reset ();
        reset ();
    }
    if (msgLevel >= 2) System.out.println ("\nFinding path with \"A*\", from node " + v1 + " to node " + v2);
    g.freshlyReset = false;
    goal = v2;
    if ((resultArray = ascheckNode (g, v1, 0)) != null) {
        if (msgLevel >= 2) printResult (resultArray, accumDist);
        return resultArray;
    }
    else {
        if (msgLevel >= 1) System.out.println ("No connection between start node and end node");
        return null;
    }
}


private int [] DepthFirst (Graph g, int v1, int v2) {
    int [] resultArray;
    if (! g.freshlyReset) {
        g.reset ();
        reset ();
    }
    if (msgLevel >= 2) System.out.println ("\nFinding path with \"Depth First\", from node " + v1 + " to node " + v2);
    g.freshlyReset = false;
    goal = v2;
    if ((resultArray = dfcheckNode (g, v1, 0)) != null) {
        if (msgLevel >= 2) printResult (resultArray, accumDist);
        return resultArray;
    }
    else {
        if (msgLevel >= 1) System.out.println ("No connection between start node and end node");
        return null;
    }
}


-----Function Pair=68=-----==

private void disconnect () {
    if (client != null) {
        try {
            try {
                try {
                    client.logout ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            } finally {
                try {
                    client.disconnect ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            }
        } finally {
            client = null;
        }
    }
}


public void disconnect () {
    if (client != null) {
        try {
            try {
                try {
                    client.logout ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            } finally {
                try {
                    client.disconnect ();
                } catch (Exception ex) {
                    _logger.debug ("Hiding exception", ex);
                }
            }
        } finally {
            client = null;
        }
    }
}


-----Function Pair=69=-----=1=

public static void main (String [] args) {
    System.out.println ("Chapter 2: example HelloWorldLandscape");
    System.out.println ("-> Creates a PDF file with the text 'Hello World';");
    System.out.println ("   PageSize.LETTER was used for the page size,");
    System.out.println ("   the orientation was set to landscape.");
    System.out.println ("-> jars needed: iText.jar");
    System.out.println ("-> files generated in /results subdirectory:");
    System.out.println ("   HelloWorldLandscape.pdf");
    Document document = new Document (PageSize.LETTER.rotate ());
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("results/in_action/chapter02/HelloWorldLandscape.pdf"));
        document.open ();
        document.add (new Paragraph ("Hello World"));
    } catch (DocumentException de) {
        System.err.println (de.getMessage ());
    } catch (IOException ioe) {
        System.err.println (ioe.getMessage ());
    }
    document.close ();
}


public static void main (String [] args) {
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("HelloWorld.pdf"));
        document.open ();
        document.add (new Paragraph ("A Hello World PDF document."));
        document.close ();
    } catch (DocumentException e) {
        e.printStackTrace ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=70=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=71=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=72=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=73=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=74=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=75=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=76=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=77=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=78=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=79=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=80=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=81=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=82=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=83=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=84=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=85=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=86=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=87=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=88=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=89=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=90=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=91=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=92=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=93=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=94=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=95=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=96=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=97=-----==

private Control addLabel (Control controlTop, String text) {
    Label label = new Label (dialog, SWT.LEFT);
    FormData formDatalabel = new FormData ();
    if (controlTop == null) {
        formDatalabel.top = new FormAttachment (0, padding);
        formDatalabel.bottom = new FormAttachment (0, padding + 16);
    }
    else {
        formDatalabel.top = new FormAttachment (controlTop, padding, SWT.BOTTOM);
        formDatalabel.bottom = new FormAttachment (controlTop, padding + 16, SWT.BOTTOM);
    }
    formDatalabel.left = new FormAttachment (0, padding);
    formDatalabel.right = new FormAttachment (100, - padding);
    label.setLayoutData (formDatalabel);
    label.setText (text);
    return label;
}


private Control addLabel (Control controlTop, String text) {
    Label label = new Label (dialog, SWT.LEFT);
    FormData formDatalabel = new FormData ();
    if (controlTop == null) {
        formDatalabel.top = new FormAttachment (0, padding);
        formDatalabel.bottom = new FormAttachment (0, padding + 16);
    }
    else {
        formDatalabel.top = new FormAttachment (controlTop, padding, SWT.BOTTOM);
        formDatalabel.bottom = new FormAttachment (controlTop, padding + 16, SWT.BOTTOM);
    }
    formDatalabel.left = new FormAttachment (0, padding);
    formDatalabel.right = new FormAttachment (100, - padding);
    label.setLayoutData (formDatalabel);
    label.setText (text);
    return label;
}


-----Function Pair=98=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


-----Function Pair=99=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


-----Function Pair=100=-----==

public static Matrix read (BufferedReader input) throws java.io.IOException {
    StreamTokenizer tokenizer = new StreamTokenizer (input);
    tokenizer.resetSyntax ();
    tokenizer.wordChars (0, 255);
    tokenizer.whitespaceChars (0, ' ');
    tokenizer.eolIsSignificant (true);
    java.util.Vector v = new java.util.Vector ();
    while (tokenizer.nextToken () == StreamTokenizer.TT_EOL);
    if (tokenizer.ttype == StreamTokenizer.TT_EOF) throw new java.io.IOException ("Unexpected EOF on matrix read.");
    do {
        v.addElement (Double.valueOf (tokenizer.sval));
    }
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
    int n = v.size ();
    double row [] = new double [n];
    for (int j = 0; j < n; j ++) row [j] = ((Double) v.elementAt (j)).doubleValue ();
    v.removeAllElements ();
    v.addElement (row);
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD) {
        v.addElement (row = new double [n]);
        int j = 0;
        do {
            if (j >= n) throw new java.io.IOException ("Row " + v.size () + " is too long.");
            row [j ++] = Double.valueOf (tokenizer.sval).doubleValue ();
        }
        while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
        if (j < n) throw new java.io.IOException ("Row " + v.size () + " is too short.");
    }
    int m = v.size ();
    double [] [] A = new double [m] [];
    v.copyInto (A);
    return new Matrix (A);
}


public static Matrix read (BufferedReader input) throws java.io.IOException {
    StreamTokenizer tokenizer = new StreamTokenizer (input);
    tokenizer.resetSyntax ();
    tokenizer.wordChars (0, 255);
    tokenizer.whitespaceChars (0, ' ');
    tokenizer.eolIsSignificant (true);
    java.util.Vector v = new java.util.Vector ();
    while (tokenizer.nextToken () == StreamTokenizer.TT_EOL);
    if (tokenizer.ttype == StreamTokenizer.TT_EOF) throw new java.io.IOException ("Unexpected EOF on matrix read.");
    do {
        v.addElement (Double.valueOf (tokenizer.sval));
    }
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
    int n = v.size ();
    double row [] = new double [n];
    for (int j = 0; j < n; j ++) row [j] = ((Double) v.elementAt (j)).doubleValue ();
    v.removeAllElements ();
    v.addElement (row);
    while (tokenizer.nextToken () == StreamTokenizer.TT_WORD) {
        v.addElement (row = new double [n]);
        int j = 0;
        do {
            if (j >= n) throw new java.io.IOException ("Row " + v.size () + " is too long.");
            row [j ++] = Double.valueOf (tokenizer.sval).doubleValue ();
        }
        while (tokenizer.nextToken () == StreamTokenizer.TT_WORD);
        if (j < n) throw new java.io.IOException ("Row " + v.size () + " is too short.");
    }
    int m = v.size ();
    double [] [] A = new double [m] [];
    v.copyInto (A);
    return new Matrix (A);
}


-----Function Pair=101=-----==

public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


public static Matrix constructWithCopy (double [] [] A) {
    int m = A.length;
    int n = A [0].length;
    Matrix X = new Matrix (m, n);
    double [] [] C = X.getArray ();
    for (int i = 0; i < m; i ++) {
        if (A [i].length != n) {
            throw new IllegalArgumentException ("All rows must have the same length.");
        }
        for (int j = 0; j < n; j ++) {
            C [i] [j] = A [i] [j];
        }
    }
    return X;
}


-----Function Pair=102=-----==

private static void QuickSortMinToMax (int a [], int lo0, int hi0) {
    int lo = lo0;
    int hi = hi0;
    int mid;
    if (hi0 > lo0) {
        mid = a [(int) Math.round ((lo0 + hi0) / 2.0)];
        while (lo <= hi) {
            while ((lo < hi0) && (a [lo] < mid)) ++ lo;
            while ((hi > lo0) && (a [hi] > mid)) -- hi;
            if (lo <= hi) {
                swap (a, lo, hi);
                ++ lo;
                -- hi;
            }
        }
        if (lo0 < hi) QuickSortMinToMax (a, lo0, hi);
        if (lo < hi0) QuickSortMinToMax (a, lo, hi0);
    }
}


private static void QuickSortMaxToMin (int a [], int lo0, int hi0) {
    int lo = lo0;
    int hi = hi0;
    int mid;
    if (hi0 > lo0) {
        mid = a [(int) Math.round ((lo0 + hi0) / 2.0)];
        while (lo <= hi) {
            while ((lo < hi0) && (a [lo] > mid)) ++ lo;
            while ((hi > lo0) && (a [hi] < mid)) -- hi;
            if (lo <= hi) {
                swap (a, lo, hi);
                ++ lo;
                -- hi;
            }
        }
        if (lo0 < hi) QuickSortMaxToMin (a, lo0, hi);
        if (lo < hi0) QuickSortMaxToMin (a, lo, hi0);
    }
}


-----Function Pair=103=-----==

public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP(" + addrport (addr, port) + "): " + e);
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP(" + addrport (addr, port) + "): " + e);
    }
}


-----Function Pair=104=-----==

Message doAXFR (Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s) {
    Zone zone = (Zone) znames.get (name);
    boolean first = true;
    if (zone == null) return errorMessage (query, Rcode.REFUSED);
    Iterator it = zone.AXFR ();
    try {
        DataOutputStream dataOut;
        dataOut = new DataOutputStream (s.getOutputStream ());
        int id = query.getHeader ().getID ();
        while (it.hasNext ()) {
            RRset rrset = (RRset) it.next ();
            Message response = new Message (id);
            Header header = response.getHeader ();
            header.setFlag (Flags.QR);
            header.setFlag (Flags.AA);
            addRRset (rrset.getName (), response, rrset, Section.ANSWER, FLAG_DNSSECOK);
            if (tsig != null) {
                tsig.applyAXFR (response, qtsig, first);
                qtsig = response.getTSIG ();
            }
            first = false;
            byte [] out = response.toWire ();
            dataOut.writeShort (out.length);
            dataOut.write (out);
        }
    } catch (IOException ex) {
        System.out.println ("AXFR failed");
    }
    try {
        s.close ();
    } catch (IOException ex) {
    }
    return null;
}


byte [] doAXFR (Name name, Message query, TSIG tsig, TSIGRecord qtsig, Socket s) {
    Zone zone = (Zone) znames.get (name);
    boolean first = true;
    if (zone == null) return errorMessage (query, Rcode.REFUSED);
    Iterator it = zone.AXFR ();
    try {
        DataOutputStream dataOut;
        dataOut = new DataOutputStream (s.getOutputStream ());
        int id = query.getHeader ().getID ();
        while (it.hasNext ()) {
            RRset rrset = (RRset) it.next ();
            Message response = new Message (id);
            Header header = response.getHeader ();
            header.setFlag (Flags.QR);
            header.setFlag (Flags.AA);
            addRRset (rrset.getName (), response, rrset, Section.ANSWER, FLAG_DNSSECOK);
            if (tsig != null) {
                tsig.applyStream (response, qtsig, first);
                qtsig = response.getTSIG ();
            }
            first = false;
            byte [] out = response.toWire ();
            dataOut.writeShort (out.length);
            dataOut.write (out);
        }
    } catch (IOException ex) {
        System.out.println ("AXFR failed");
    }
    try {
        s.close ();
    } catch (IOException ex) {
    }
    return null;
}


-----Function Pair=105=-----=1=

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new HashMap ();
    znames = new HashMap ();
    TSIGs = new HashMap ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) ports.add (Short.valueOf (st.nextToken ()));
        else if (keyword.equals ("address")) {
            String addr = st.nextToken ();
            addresses.add (InetAddress.getByName (addr));
        }
        else {
            System.out.println ("ignoring invalid keyword: " + keyword);
        }
    }
    if (ports.size () == 0) ports.add (new Short ((short) 53));
    if (addresses.size () == 0) addresses.add (null);
    Iterator iaddr = addresses.iterator ();
    while (iaddr.hasNext ()) {
        InetAddress addr = (InetAddress) iaddr.next ();
        Iterator iport = ports.iterator ();
        while (iport.hasNext ()) {
            short port = ((Short) iport.next ()).shortValue ();
            String addrString;
            addUDP (addr, port);
            addTCP (addr, port);
            if (addr == null) addrString = "0.0.0.0";
            else addrString = addr.getHostAddress ();
            System.out.println ("jnamed: listening on " + addrString + "#" + port);
        }
    }
    System.out.println ("jnamed: running");
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new HashMap ();
    znames = new HashMap ();
    TSIGs = new HashMap ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) ports.add (Short.valueOf (st.nextToken ()));
        else if (keyword.equals ("address")) {
            String addr = st.nextToken ();
            addresses.add (InetAddress.getByName (addr));
        }
        else {
            System.out.println ("ignoring invalid keyword: " + keyword);
        }
    }
    if (ports.size () == 0) ports.add (new Short ((short) 53));
    if (addresses.size () == 0) addresses.add (null);
    Iterator iaddr = addresses.iterator ();
    while (iaddr.hasNext ()) {
        InetAddress addr = (InetAddress) iaddr.next ();
        Iterator iport = ports.iterator ();
        while (iport.hasNext ()) {
            short port = ((Short) iport.next ()).shortValue ();
            String addrString;
            addUDP (addr, port);
            addTCP (addr, port);
            if (addr == null) addrString = "0.0.0.0";
            else addrString = addr.getHostAddress ();
            System.out.println ("jnamed: listening on " + addrString + "#" + port);
        }
    }
    System.out.println ("jnamed: running");
}


-----Function Pair=106=-----==

public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


-----Function Pair=107=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=108=-----==

void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=109=-----==

void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


void processSplitRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing value in SPLIT");
    String value = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in SPLIT");
    String sep = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variables in SPLIT");
    int numVars = pst.countTokens ();
    String [] var_names = new String [numVars];
    for (int i = 0; i < numVars; i ++) var_names [i] = pst.nextToken ();
    StringTokenizer vst = new StringTokenizer (value, sep);
    String [] values = new String [numVars];
    for (int i = 0; i < numVars; i ++) if (vst.hasMoreTokens ()) values [i] = vst.nextToken ();
    else values [i] = "";
    if (DEBUG) System.out.println ("doing split with value \"" + value + "\" to vars :" + params.substring (value.length () + 3));
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = currentLine;
            for (int curVar = 0; curVar < var_names.length; curVar ++) result = substitute (result, var_names [curVar], values [curVar]);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = oldRegion;
            for (int curVar = 0; curVar < var_names.length; curVar ++) newRegion = substituteInRegion (newRegion, var_names [curVar], values [curVar]);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=110=-----==

public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


-----Function Pair=111=-----==

public void TCPclient (Socket s) {
    try {
        int inLength;
        DataInputStream dataIn;
        DataOutputStream dataOut;
        byte [] in;
        InputStream is = s.getInputStream ();
        dataIn = new DataInputStream (is);
        inLength = dataIn.readUnsignedShort ();
        in = new byte [inLength];
        dataIn.readFully (in);
        Message query;
        byte [] response = null;
        try {
            query = new Message (in);
            response = generateReply (query, in, in.length, s);
            if (response == null) return;
        } catch (IOException e) {
            response = formerrMessage (in);
        }
        dataOut = new DataOutputStream (s.getOutputStream ());
        dataOut.writeShort (response.length);
        dataOut.write (response);
    } catch (IOException e) {
        String addrString;
        System.out.println ("TCPclient(" + s.getLocalAddress ().getHostAddress () + "#" + s.getLocalPort () + "): " + e);
    } finally {
        try {
            s.close ();
        } catch (IOException e) {
        }
    }
}


public void TCPclient (Socket s) {
    try {
        int inLength;
        DataInputStream dataIn;
        DataOutputStream dataOut;
        byte [] in;
        InputStream is = s.getInputStream ();
        dataIn = new DataInputStream (is);
        inLength = dataIn.readUnsignedShort ();
        in = new byte [inLength];
        dataIn.readFully (in);
        Message query;
        byte [] response = null;
        try {
            query = new Message (in);
            response = generateReply (query, in, in.length, s);
            if (response == null) return;
        } catch (IOException e) {
            response = formerrMessage (in);
        }
        dataOut = new DataOutputStream (s.getOutputStream ());
        dataOut.writeShort (response.length);
        dataOut.write (response);
    } catch (IOException e) {
        String addrString;
        System.out.println ("TCPclient(" + s.getLocalAddress ().getHostAddress () + "#" + s.getLocalPort () + "): " + e);
    } finally {
        try {
            s.close ();
        } catch (IOException e) {
        }
    }
}


-----Function Pair=112=-----==

public void serveUDP (InetAddress addr, short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


-----Function Pair=113=-----==

void writeHeader () throws Exception {
    bw.write (titleLine1);
    bw.newLine ();
    bw.write (titleLine2);
    bw.newLine ();
    bw.write (atomCountAndOriginLine);
    bw.newLine ();
    for (int i = 0; i < 3; ++ i) {
        bw.write (volumetricVectorLines [i]);
        bw.newLine ();
    }
    for (int i = 0; i < atomCount; ++ i) {
        bw.write (atomLines [i]);
        bw.newLine ();
    }
    if (negativeAtomCount) {
        bw.write (optionalMolecularOrbitalLine);
        bw.newLine ();
    }
}


void writeHeader () throws Exception {
    bw.write (titleLine1);
    bw.newLine ();
    bw.write (titleLine2);
    bw.newLine ();
    bw.write (atomCountAndOriginLine);
    bw.newLine ();
    for (int i = 0; i < 3; ++ i) {
        bw.write (volumetricVectorLines [i]);
        bw.newLine ();
    }
    for (int i = 0; i < atomCount; ++ i) {
        bw.write (atomLines [i]);
        bw.newLine ();
    }
    if (negativeAtomCount) {
        bw.write (optionalMolecularOrbitalLine);
        bw.newLine ();
    }
}


-----Function Pair=114=-----==

void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=115=-----==

public static void parseMimeTypes2 (String file, Map mimeTypes) {
    BufferedReader mimefile = null;
    try {
        if (new File (file).exists () == true) {
            mimefile = new BufferedReader (new FileReader (file));
            String aLine, Mime, value;
            while (mimefile.ready ()) {
                aLine = mimefile.readLine ();
                if (aLine != null && aLine.length () > 0) {
                    aLine = aLine.trim ().replace ('\t', ' ');
                    if (aLine.length () > 0 && aLine.charAt (0) != '#') {
                        int positionOfSpace = aLine.indexOf (' ');
                        if (positionOfSpace != - 1) {
                            Mime = aLine.substring (0, positionOfSpace).trim ();
                            value = aLine.substring (positionOfSpace + 1).trim ();
                            mimeTypes.put (Mime, value);
                        }
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
    } finally {
        try {
            if (mimefile != null) mimefile.close ();
        } catch (IOException e) {
        }
    }
}


public static void parseMimeTypes2 (String file, Map mimeTypes) {
    BufferedReader mimefile = null;
    try {
        if (new File (file).exists () == true) {
            mimefile = new BufferedReader (new FileReader (file));
            String aLine, Mime, value;
            while (mimefile.ready ()) {
                aLine = mimefile.readLine ();
                if (aLine != null && aLine.length () > 0) {
                    aLine = aLine.trim ().replace ('\t', ' ');
                    if (aLine.length () > 0 && aLine.charAt (0) != '#') {
                        int positionOfSpace = aLine.indexOf (' ');
                        if (positionOfSpace != - 1) {
                            Mime = aLine.substring (0, positionOfSpace).trim ();
                            value = aLine.substring (positionOfSpace + 1).trim ();
                            mimeTypes.put (Mime, value);
                        }
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
    } finally {
        try {
            if (mimefile != null) mimefile.close ();
        } catch (IOException e) {
        }
    }
}


-----Function Pair=116=-----==

Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String value) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, value);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, value);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=117=-----==

public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


-----Function Pair=118=-----==

public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP(" + addrport (addr, port) + "): " + e);
    }
}


public void serveUDP (InetAddress addr, int port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query;
            byte [] response = null;
            try {
                query = new Message (in);
                response = generateReply (query, in, indp.getLength (), null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            if (outdp == null) outdp = new DatagramPacket (response, response.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (response);
                outdp.setLength (response.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP(" + addrport (addr, port) + "): " + e);
    }
}


-----Function Pair=119=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=120=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=121=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=122=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=123=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=124=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=125=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=126=-----==

private void archiveOldItem (ScheduleItem removedItem) {
    try {
        SimpleDateFormat df = new SimpleDateFormat ("yyyyMMdd@HHmmssS");
        String archiveName = new DllWrapper ().getAllUserPath () + "archive\\Schedule-" + df.format (removedItem.getStart ()) + " (" + removedItem.getChannel () + ") (" + removedItem.getName () + ").sof";
        File outFile = new File (archiveName);
        outFile = outFile.getCanonicalFile ();
        File parent = outFile.getParentFile ();
        if (parent.exists () == false) parent.mkdirs ();
        FileOutputStream fos = new FileOutputStream (outFile);
        ObjectOutputStream oos = new ObjectOutputStream (fos);
        oos.writeObject (removedItem);
        oos.close ();
    } catch (Exception e) {
        System.out.println ("Error trying to archive old Schedule Item:");
        e.printStackTrace ();
    }
}


private void archiveOldItem (ScheduleItem removedItem) {
    try {
        SimpleDateFormat df = new SimpleDateFormat ("yyyyMMdd@HHmmssS");
        String archiveName = new DllWrapper ().getAllUserPath () + "archive\\Schedule-" + df.format (removedItem.getStart ()) + " (" + removedItem.getChannel () + ") (" + removedItem.getName () + ").sof";
        File outFile = new File (archiveName);
        outFile = outFile.getCanonicalFile ();
        File parent = outFile.getParentFile ();
        if (parent.exists () == false) parent.mkdirs ();
        FileOutputStream fos = new FileOutputStream (outFile);
        ObjectOutputStream oos = new ObjectOutputStream (fos);
        oos.writeObject (removedItem);
        oos.close ();
    } catch (Exception e) {
        System.out.println ("Error trying to archive old Schedule Item:");
        e.printStackTrace ();
    }
}


-----Function Pair=127=-----==

public void doListInstruction (String command, String [] args) {
    int count;
    int addr = - 1;
    try {
        switch (args.length) {
            case 0 :
                addr = user.reg.currentIP ();
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            case 1 :
                addr = parseHex32 (args [0]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            default :
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, count));
                break;
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad address: " + args [0]);
    }
}


public void doListInstruction (String command, String [] args) {
    int count;
    int addr = - 1;
    try {
        switch (args.length) {
            case 0 :
                addr = user.reg.currentIP ();
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            case 1 :
                addr = parseHex32 (args [0]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            default :
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, count));
                break;
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad address: " + args [0]);
    }
}


-----Function Pair=128=-----==

private void printHelp (String command) {
    StringBuffer ret = new StringBuffer ();
    if (command.equals ("step") || command.equals ("s")) {
        ret.append ("Format:  < s | step > \n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping into all method invocations\n");
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        ret.append ("Format:  < sbr | stepbr >\n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping over method invocations\n");
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        ret.append ("Format:  < sl | stepline > \n");
        ret.append ("Single step only the current thread by one java source line, stepping into method invocations\n");
        ret.append ("(may need to hit enter twice to step one line because currently jdp may not be able to set precise breakpoints)\n");
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        ret.append ("Format:  < slo | steplineover >\n");
        ret.append ("Single step only the current thread by one java source line, stepping over method invocations\n");
    }
    else if (command.equals ("run")) {
        ret.append ("Format:  < run > <name ... >\n");
        ret.append ("Start a new program\n");
        ret.append ("If no program name is specified, rerun the last program\n");
        ret.append ("All current breakpoints will be set\n");
        ret.append ("The current program must be killed before restarting\n");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        ret.append ("Format:  < k | kill >\n");
        ret.append ("Terminate the current program without exiting the debugger\n");
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        ret.append ("Format:  < ct | cthread > \n");
        ret.append ("Continue only current thread, passing to the program any pending signal\n");
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        ret.append ("Format:  < c | cont > \n");
        ret.append ("Continue all threads, passing to the program any pending signal\n");
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        ret.append ("Format:  < cr | creturn >\n");
        ret.append ("continue only current thread to the end of this method \n");
        ret.append ("(i.e. go up one stack frame)\n");
    }
    else if (command.equals ("where") || command.equals ("w")) {
        ret.append ("Format:  < w | where > < from | to > <hexval>\n");
        ret.append ("Display stack trace\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
        ret.append ("If we are in the prolog code, the stack frame is being constructed\n");
        ret.append ("so a place holder will be shown for the frame\n");
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        ret.append ("Format:  < wf | whereframe > < from | to > <hexval>\n");
        ret.append ("Display stack trace with arguments, local variables, temporary variables for each stack frame\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
    }
    else if (command.equals ("reg") || command.equals ("r") || command.equals ("wreg") || command.equals ("wr")) {
        ret.append ("Format 1:  < r | reg > <num|name> <count>\n");
        ret.append ("Format 2:  < wr | wreg > <num|name> <hexval>\n");
        ret.append ("Display/update hardware registers (not thread context registers)\n");
        ret.append ("Specify register by number:  0-31, 128-136, 138, 148, 256-287\n");
        ret.append ("or by names: \n");
        String regname = "";
        for (int i = 0; i < VM_BaselineConstants.GPR_NAMES.length; i ++) regname += VM_BaselineConstants.GPR_NAMES [i] + " ";
        ret.append (regname);
        regname = "";
        for (int i = 0; i < VM_BaselineConstants.FPR_NAMES.length; i ++) regname += VM_BaselineConstants.FPR_NAMES [i] + " ";
        ret.append (regname);
        ret.append ("IP LR\n");
    }
    else if (command.equals ("mem") || command.equals ("m") || command.equals ("wmem") || command.equals ("wm") || command.equals ("memraw") || command.equals ("mraw")) {
        ret.append ("Format 1:  < m | mem > <hexaddr> <count>\n");
        ret.append ("Format 2:  < wm | wmem > <hexaddr> <hexvalue>\n");
        ret.append ("Format 3:  < mraw | memraw > <hexaddr> <hexvalue>\n");
        ret.append ("Display/update memory at this address\n");
        ret.append ("If count is not specified, 5 words will be displayed\n");
        ret.append ("For mem and wmem, the breakpoints are transparent\n");
        ret.append ("For memraw, the actual memory contents are shown with the breakpoints as is (intended for debugging jdp)\n");
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        ret.append ("Format 1:   < pc | printclass> <class><.field><[n]>\n");
        ret.append ("Print the static fields for this class\n");
        ret.append ("(including super classes up to but not including java.lang.Object)\n");
        ret.append ("For array, specify an individual element or omit the rightmost dimension \nto display the full dimension\n");
        ret.append ("The variable name can be nested arbitrarily\n");
        ret.append ("Example:\n");
        ret.append ("   pc class                         print the static variables\n");
        ret.append ("   pc class.field                   print this field\n");
        ret.append ("   pc class.array[2]                print this array element\n");
        ret.append ("   pc class.field1.array[4].field2  nested expression\n\n");
        ret.append ("Format 2:   < pc | printclass> <hexaddr>\n");
        ret.append ("   pc 01234567                      print the type for this address\n\n");
    }
    else if (command.equals ("print") || command.equals ("p")) {
        ret.append ("Format 1:   < p | print> frame<:localvar><.field><[n]>\n");
        ret.append ("Print the content of a local variable in this stack frame;\n");
        ret.append ("If no name is specified, all locals in the current scope are printed\n");
        ret.append ("The name can be the string this to print the current object\n");
        ret.append ("Example:\n");
        ret.append ("   p 0                             print all locals in frame 0\n");
        ret.append ("   p this                          print the current object in frame 0\n");
        ret.append ("   p 1:mylocal.field1              print this local variable in frame 1\n\n");
        ret.append ("Format 2:   < p | print> (classname) hexaddress\n");
        ret.append ("Cast the address as an instance of this class\n");
        ret.append ("and print the contents \n\n");
        ret.append ("Format 3:   < p | print><@class.staticvar>\n");
        ret.append ("Print the address of a static variable for this class\n");
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        ret.append ("Format:  < lb | listb > <hexaddr>\n");
        ret.append ("Dissassemble the bytecodes of the method containing this address\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("(this command has been removed because the Optimizing compiler does not generate the bytecode information)\n");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        ret.append ("Format:  < li | listi > <hexaddr><count>\n");
        ret.append ("Dissassemble the machine instruction in this range of addresses\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("Default count is 10\n");
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        ret.append ("Format:  < lt | listt > <all|byname|run|ready|wakeup|system|gc>\n");
        ret.append ("List the threads, select the type of thread by:\n");
        ret.append ("  all      all threads listed by top stack frame\n");
        ret.append ("  byname   all threads listed by thread class name\n");
        ret.append ("  run      threads currently loaded in the system threads\n");
        ret.append ("  ready    threads in the VM_Scheduler ready queue\n");
        ret.append ("  wakeup   threads in the VM_Scheduler wakeup queue\n");
        ret.append ("  system   dump the state of the system threads\n");
        ret.append ("  gc       garbage collector threads\n");
        ret.append ("Annotation: \n");
        ret.append ("  threads loaded in system thread are indicated by >\n");
        ret.append ("  the current thread in which the debugger stops is indicated by ->\n");
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        ret.append ("Format:  < th | thread > <threadID|off>\n");
        ret.append ("Select a thread context by its ID \n");
        ret.append ("(this is a small integer, get all current thread ID by the listt command)\n");
        ret.append ("The new thread context will be shown in the jdp prompt\n");
        ret.append ("and all future stack and local display will be for this thread\n");
        ret.append ("If no ID is specified, the context is returned to the current thread in which the debugger has stopped\n");
        ret.append ("To force jdp to use the context in the hardware register, specify an ID of 0 or OFF; jdp will stay there until the context is set manually to a valid thread ID\n");
        ret.append ("jdp will start in the OFF thread (i.e. no thread context)\n");
    }
    else if (command.equals ("break") || command.equals ("b")) {
        ret.append ("Format:  < b ><hexaddr><class.method:line sig>\n");
        ret.append ("Set breakpoint by hex address or symbolic name \n");
        ret.append ("With no argument, the list of current breakpoints is shown\n");
        ret.append ("For symbolic name, jdp will attempt to match partial names\n");
        ret.append ("The method prolog is skipped;  to break at the start of the prolog, \nspecify 0 for the line number\n");
        ret.append ("example:\n");
        ret.append ("   b                        list current breakpoints\n");
        ret.append ("   b 0123abcd               at this hex address\n");
        ret.append ("   b class:line             at java source line in class\n");
        ret.append ("   b method                 at start of method, skipping prolog\n");
        ret.append ("   b class.method           at start of method, skipping prolog\n");
        ret.append ("   b class.method sig       for overloaded method\n");
        ret.append ("   b class.method:0         at start of method prolog\n");
        ret.append ("the class file must be generated with -g to get the line number\n");
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        ret.append ("Format:  < cb ><hexaddr|all> \n");
        ret.append ("Clear breakpoint at the hex address or all breakpoint\n");
        ret.append ("(type b to get the list of current breakpoints)\n");
        ret.append ("If no address is specified, clear breakpoint at the current instruction\n");
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        ret.append ("Format:  < f | stack > <hexval> <n>\n");
        ret.append ("Display current JVM stack \n");
        ret.append ("showing n words at the top and bottom, the default is 4 words\n");
        ret.append ("The value for Frame Pointer may be specified in <hexval>\n");
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        ret.append ("Format:  < preference | pref> <string>\n");
        ret.append ("Set user preferences\n");
        ret.append ("To display integer in hex or decimal, specify:  int  < hex | x | dec | d > \n");
        ret.append ("To display stack with/without a decimal column, specify: stack < hex | x | dec | d > \n");
        ret.append ("To display floating point register in hex or float, specify:  fpr  < hex | x | float | f > ");
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        ret.append ("Format:  < v | verbose >\n");
        ret.append ("Toggle verbose mode on and off\n");
        ret.append ("In verbose, the current stack frame is automatically displayed\n");
    }
    else if (command.equals ("macro")) {
        ret.append ("Format:  <your macro name>\n");
        ret.append ("jdp will search for the named file with the .jdp suffix in the current class path\n");
        ret.append ("Each line is read and executed it as if it is entered from the command line\n");
        ret.append ("The file should contain normal jdp commands\n");
        ret.append ("On start up, jdp will look for the file startup.jdp in the current directory\n");
        ret.append ("If it exists, it will be loaded and executed automatically\n");
    }
    else if (command.equals ("q") || command.equals ("quit")) {
        ret.append ("Format:  <q | quit>\n");
        ret.append ("Exit debugger\n");
    }
    else if (command.equals ("enter")) {
        ret.append ("Format:  (enter)\n");
        ret.append ("Repeat last command\n");
    }
    else {
        ret.append ("step          step current thread by instruction, into method\n");
        ret.append ("stepbr        step current thread by instruction, over method\n");
        ret.append ("stepline      step current thread by java source line, into method \n");
        ret.append ("steplineover  step current thread by java source line, over method \n");
        ret.append ("creturn       continue to last caller \n");
        ret.append ("cthread       continue current thread only\n");
        ret.append ("cont          continue all threads\n");
        ret.append ("kill          terminate program \n");
        ret.append ("run           start new program \n");
        ret.append ("break         list/set breakpoint \n");
        ret.append ("clearbreak    clear breakpoints \n\n");
        ret.append ("thread        set or turn off thread context\n");
        ret.append ("where         print short stack trace \n");
        ret.append ("whereframe    print full stack trace \n");
        ret.append ("stack         display formatted stack \n");
        ret.append ("mem           display memory\n");
        ret.append ("memraw        display actual memory, jdp breakpoints visible\n");
        ret.append ("wmem          write memory \n");
        ret.append ("reg           display registers \n");
        ret.append ("wreg          write register \n");
        ret.append ("printclass    print the class statics or the type of an object address\n");
        ret.append ("print         print local variables or cast an address as an object\n");
        ret.append ("listi         list machine instruction\n");
        ret.append ("listt         list threads\n\n");
        ret.append ("quit          exit debugger\n");
        ret.append ("preference    set user preference\n");
        ret.append ("verbose       toggle verbose mode\n");
        ret.append ("(macro name)  load and execute this macro (a text file with suffix .jdp)\n");
        ret.append ("x2d, d2x      convert number between hex and decimal\n");
        ret.append ("(enter)       repeat last command\n\n");
        ret.append ("To get more information on a specific command, type: \n \thelp thiscommand\n");
    }
    jdp_console.writeOutput (ret.toString ());
}


private void printHelp (String command) {
    StringBuffer ret = new StringBuffer ();
    if (command.equals ("step") || command.equals ("s")) {
        ret.append ("Format:  < s | step > \n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping into all method invocations\n");
    }
    else if (command.equals ("stepbr") || command.equals ("sbr")) {
        ret.append ("Format:  < sbr | stepbr >\n");
        ret.append ("Single step only the current thread by one machine instruction, \nstepping over method invocations\n");
    }
    else if (command.equals ("stepline") || command.equals ("sl")) {
        ret.append ("Format:  < sl | stepline > \n");
        ret.append ("Single step only the current thread by one java source line, stepping into method invocations\n");
        ret.append ("(may need to hit enter twice to step one line because currently jdp may not be able to set precise breakpoints)\n");
    }
    else if (command.equals ("steplineover") || command.equals ("slo")) {
        ret.append ("Format:  < slo | steplineover >\n");
        ret.append ("Single step only the current thread by one java source line, stepping over method invocations\n");
    }
    else if (command.equals ("run")) {
        ret.append ("Format:  < run > <name ... >\n");
        ret.append ("Start a new program\n");
        ret.append ("If no program name is specified, rerun the last program\n");
        ret.append ("All current breakpoints will be set\n");
        ret.append ("The current program must be killed before restarting\n");
    }
    else if (command.equals ("kill") || command.equals ("k")) {
        ret.append ("Format:  < k | kill >\n");
        ret.append ("Terminate the current program without exiting the debugger\n");
    }
    else if (command.equals ("cthread") || command.equals ("ct")) {
        ret.append ("Format:  < ct | cthread > \n");
        ret.append ("Continue only current thread, passing to the program any pending signal\n");
    }
    else if (command.equals ("cont") || command.equals ("c")) {
        ret.append ("Format:  < c | cont > \n");
        ret.append ("Continue all threads, passing to the program any pending signal\n");
    }
    else if (command.equals ("creturn") || command.equals ("cr")) {
        ret.append ("Format:  < cr | creturn >\n");
        ret.append ("continue only current thread to the end of this method \n");
        ret.append ("(i.e. go up one stack frame)\n");
    }
    else if (command.equals ("where") || command.equals ("w")) {
        ret.append ("Format:  < w | where > < from | to > <hexval>\n");
        ret.append ("Display stack trace\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
        ret.append ("If we are in the prolog code, the stack frame is being constructed\n");
        ret.append ("so a place holder will be shown for the frame\n");
    }
    else if (command.equals ("whereframe") || command.equals ("wf")) {
        ret.append ("Format:  < wf | whereframe > < from | to > <hexval>\n");
        ret.append ("Display stack trace with arguments, local variables, temporary variables for each stack frame\n");
        ret.append ("Up to 20 frames are displayed and the number of remaining frames are indicated\n");
        ret.append ("Any frame, range of frames, or a specific frame pointer can be specified\n");
    }
    else if (command.equals ("reg") || command.equals ("r") || command.equals ("wreg") || command.equals ("wr")) {
        ret.append ("Format 1:  < r | reg > <num|name> <count>\n");
        ret.append ("Format 2:  < wr | wreg > <num|name> <hexval>\n");
        ret.append ("Display/update hardware registers (not thread context registers)\n");
        ret.append ("Specify Intel register by names: \n");
        String regname = "";
        for (int i = 0; i < VM_BaselineConstants.GPR_NAMES.length; i ++) regname += VM_BaselineConstants.GPR_NAMES [i] + " ";
        ret.append (regname);
        regname = "";
        for (int i = 0; i < VM_BaselineConstants.FPR_NAMES.length; i ++) regname += VM_BaselineConstants.FPR_NAMES [i] + " ";
        ret.append (regname);
        for (int i = 0; i < VM_BaselineConstants.RVM_GPR_NAMES.length; i ++) regname += VM_BaselineConstants.RVM_GPR_NAMES [i] + " ";
        ret.append (regname);
    }
    else if (command.equals ("mem") || command.equals ("m") || command.equals ("wmem") || command.equals ("wm") || command.equals ("memraw") || command.equals ("mraw")) {
        ret.append ("Format 1:  < m | mem > <hexaddr> <count>\n");
        ret.append ("Format 2:  < wm | wmem > <hexaddr> <hexvalue>\n");
        ret.append ("Format 3:  < mraw | memraw > <hexaddr> <hexvalue>\n");
        ret.append ("Display/update memory at this address\n");
        ret.append ("If count is not specified, 5 words will be displayed\n");
        ret.append ("For mem and wmem, the breakpoints are transparent\n");
        ret.append ("For memraw, the actual memory contents are shown with the breakpoints as is (intended for debugging jdp)\n");
    }
    else if (command.equals ("printclass") || command.equals ("pc")) {
        ret.append ("Format 1:   < pc | printclass> <class><.field><[n]>\n");
        ret.append ("Print the static fields for this class\n");
        ret.append ("(including super classes up to but not including java.lang.Object)\n");
        ret.append ("For array, specify an individual element or omit the rightmost dimension \nto display the full dimension\n");
        ret.append ("The variable name can be nested arbitrarily\n");
        ret.append ("Example:\n");
        ret.append ("   pc class                         print the static variables\n");
        ret.append ("   pc class.field                   print this field\n");
        ret.append ("   pc class.array[2]                print this array element\n");
        ret.append ("   pc class.field1.array[4].field2  nested expression\n\n");
        ret.append ("Format 2:   < pc | printclass> <hexaddr>\n");
        ret.append ("   pc 01234567                      print the type for this address\n\n");
    }
    else if (command.equals ("print") || command.equals ("p")) {
        ret.append ("Format 1:   < p | print> frame<:localvar><.field><[n]>\n");
        ret.append ("Print the content of a local variable in this stack frame;\n");
        ret.append ("If no name is specified, all locals in the current scope are printed\n");
        ret.append ("The name can be the string this to print the current object\n");
        ret.append ("Example:\n");
        ret.append ("   p 0                             print all locals in frame 0\n");
        ret.append ("   p this                          print the current object in frame 0\n");
        ret.append ("   p 1:mylocal.field1              print this local variable in frame 1\n\n");
        ret.append ("Format 2:   < p | print> (classname) hexaddress\n");
        ret.append ("Cast the address as an instance of this class\n");
        ret.append ("and print the contents \n\n");
        ret.append ("Format 3:   < p | print><@class.staticvar>\n");
        ret.append ("Print the address of a static variable for this class\n");
    }
    else if (command.equals ("listb") || command.equals ("lb")) {
        ret.append ("Format:  < lb | listb > <hexaddr>\n");
        ret.append ("Dissassemble the bytecodes of the method containing this address\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("(this command has been removed because the Optimizing compiler does not generate the bytecode information)\n");
    }
    else if (command.equals ("listi") || command.equals ("li")) {
        ret.append ("Format:  < li | listi > <hexaddr><count>\n");
        ret.append ("Dissassemble the machine instruction in this range of addresses\n");
        ret.append ("If address is not specified, use the current PC\n");
        ret.append ("Default count is 10\n");
    }
    else if (command.equals ("listt") || command.equals ("lt")) {
        ret.append ("Format:  < lt | listt > <all|byname|ready|wakeup|gc>\n");
        ret.append ("List the threads, select the type of thread by:\n");
        ret.append ("  all      all threads listed by top stack frame\n");
        ret.append ("  byname   all threads listed by thread class name\n");
        ret.append ("  ready    threads in the VM_Scheduler ready queue\n");
        ret.append ("  wakeup   threads in the VM_Scheduler wakeup queue\n");
        ret.append ("  gc       garbage collector threads\n");
        ret.append ("Annotation: \n");
        ret.append ("  threads loaded in system thread are indicated by >\n");
        ret.append ("  the current thread in which the debugger stops is indicated by ->\n");
    }
    else if (command.equals ("thread") || command.equals ("th")) {
        ret.append ("Format:  < th | thread > <threadID|off>\n");
        ret.append ("Select a thread context by its ID \n");
        ret.append ("(this is a small integer, get all current thread ID by the listt command)\n");
        ret.append ("The new thread context will be shown in the jdp prompt\n");
        ret.append ("and all future stack and local display will be for this thread\n");
        ret.append ("If no ID is specified, the context is returned to the current thread in which the debugger has stopped\n");
        ret.append ("To force jdp to use the context in the hardware register, specify an ID of 0 or OFF; jdp will stay there until the context is set manually to a valid thread ID\n");
        ret.append ("jdp will start in the OFF thread (i.e. no thread context)\n");
    }
    else if (command.equals ("break") || command.equals ("b")) {
        ret.append ("Format:  < b ><hexaddr><class.method:line sig>\n");
        ret.append ("Set breakpoint by hex address or symbolic name \n");
        ret.append ("With no argument, the list of current breakpoints is shown\n");
        ret.append ("For symbolic name, jdp will attempt to match partial names\n");
        ret.append ("The method prolog is skipped;  to break at the start of the prolog, \nspecify 0 for the line number\n");
        ret.append ("example:\n");
        ret.append ("   b                        list current breakpoints\n");
        ret.append ("   b 0123abcd               at this hex address\n");
        ret.append ("   b class:line             at java source line in class\n");
        ret.append ("   b method                 at start of method, skipping prolog\n");
        ret.append ("   b class.method           at start of method, skipping prolog\n");
        ret.append ("   b class.method sig       for overloaded method\n");
        ret.append ("   b class.method:0         at start of method prolog\n");
        ret.append ("the class file must be generated with -g to get the line number\n");
    }
    else if (command.equals ("clearbreak") || command.equals ("cb")) {
        ret.append ("Format:  < cb ><hexaddr|all> \n");
        ret.append ("Clear breakpoint at the hex address or all breakpoint\n");
        ret.append ("(type b to get the list of current breakpoints)\n");
        ret.append ("If no address is specified, clear breakpoint at the current instruction\n");
    }
    else if (command.equals ("stack") || command.equals ("f")) {
        ret.append ("Format:  < f | stack > <hexval> <n>\n");
        ret.append ("Display current JVM stack \n");
        ret.append ("showing n words at the top and bottom, the default is 4 words\n");
        ret.append ("The value for Frame Pointer may be specified in <hexval>\n");
    }
    else if (command.equals ("preference") || command.equals ("pref")) {
        ret.append ("Format:  < preference | pref> <string>\n");
        ret.append ("Set user preferences\n");
        ret.append ("To display integer in hex or decimal, specify:  int  < hex | x | dec | d > \n");
        ret.append ("To display stack with/without a decimal column, specify: stack < hex | x | dec | d > \n");
        ret.append ("To display floating point register in hex or float, specify:  fpr  < hex | x | float | f > ");
    }
    else if (command.equals ("verbose") || command.equals ("v")) {
        ret.append ("Format:  < v | verbose >\n");
        ret.append ("Toggle verbose mode on and off\n");
        ret.append ("In verbose, the current stack frame is automatically displayed\n");
    }
    else if (command.equals ("macro")) {
        ret.append ("Format:  <your macro name>\n");
        ret.append ("jdp will search for the named file with the .jdp suffix in the current class path\n");
        ret.append ("Each line is read and executed it as if it is entered from the command line\n");
        ret.append ("The file should contain normal jdp commands\n");
        ret.append ("On start up, jdp will look for the file startup.jdp in the current directory\n");
        ret.append ("If it exists, it will be loaded and executed automatically\n");
    }
    else if (command.equals ("q") || command.equals ("quit")) {
        ret.append ("Format:  <q | quit>\n");
        ret.append ("Exit debugger\n");
    }
    else if (command.equals ("enter")) {
        ret.append ("Format:  (enter)\n");
        ret.append ("Repeat last command\n");
    }
    else if (command.equals ("x2d") || command.equals ("d2x")) {
        ret.append ("Format:  x2d hexnum\n");
        ret.append ("         d2x decimalnum\n");
        ret.append ("Convert number between hex and decimal\n");
    }
    else {
        ret.append ("step          step current thread by instruction, into method\n");
        ret.append ("stepbr        step current thread by instruction, over method\n");
        ret.append ("stepline      step current thread by java source line, into method \n");
        ret.append ("steplineover  step current thread by java source line, over method \n");
        ret.append ("creturn       continue to last caller \n");
        ret.append ("cthread       continue current thread only\n");
        ret.append ("cont          continue all threads\n");
        ret.append ("kill          terminate program \n");
        ret.append ("run           start new program \n");
        ret.append ("break         list/set breakpoint \n");
        ret.append ("clearbreak    clear breakpoints \n\n");
        ret.append ("thread        set or turn off thread context\n");
        ret.append ("where         print short stack trace \n");
        ret.append ("whereframe    print full stack trace \n");
        ret.append ("stack         display formatted stack \n");
        ret.append ("mem           display memory\n");
        ret.append ("memraw        display actual memory, jdp breakpoints visible\n");
        ret.append ("wmem          write memory \n");
        ret.append ("reg           display registers \n");
        ret.append ("wreg          write register \n");
        ret.append ("printclass    print the class statics or the type of an object address\n");
        ret.append ("print         print local variables or cast an address as an object\n");
        ret.append ("listi         list machine instruction\n");
        ret.append ("listt         list threads\n\n");
        ret.append ("quit          exit debugger\n");
        ret.append ("preference    set user preference\n");
        ret.append ("verbose       toggle verbose mode\n");
        ret.append ("(macro name)  load and execute this macro (a text file with suffix .jdp)\n");
        ret.append ("x2d, d2x      convert number between hex and decimal\n");
        ret.append ("(enter)       repeat last command\n\n");
        ret.append ("To get more information on a specific command, type: \n \thelp thiscommand\n");
    }
    jdp_console.writeOutput (ret.toString ());
}


-----Function Pair=129=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=130=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=131=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=132=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=133=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=134=-----==

private void displayHeaders (MailUserData mud, HttpServletRequest req, ServletOutputStream out) throws IOException {
    SimpleDateFormat df = new SimpleDateFormat ("EE M/d/yy");
    out.println ("<html>");
    out.println ("<HEAD><TITLE>JavaMail Servlet</TITLE></HEAD>");
    out.println ("<BODY bgcolor=\"#ccccff\"><hr>");
    out.print ("<center><font face=\"Arial,Helvetica\" font size=\"+3\">");
    out.println ("<b>Folder " + mud.getStore ().getURLName () + "/INBOX</b></font></center><p>");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+3\"><b>");
    out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?logout=true\">Logout</a>");
    out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?compose=true\" target=\"compose\">Compose</a>");
    out.println ("</b></font>");
    out.println ("<hr>");
    out.print ("<table cellpadding=1 cellspacing=1 ");
    out.println ("width=\"100%\" border=1>");
    out.println ("<tr><td width=\"25%\" bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Sender</b></font></td>");
    out.println ("<td width=\"15%\" bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Date</b></font></td>");
    out.println ("<td bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Subject</b></font></td></tr>");
    try {
        Folder f = mud.getFolder ();
        int msgCount = f.getMessageCount ();
        Message m = null;
        for (int i = 1; i <= msgCount; i ++) {
            m = f.getMessage (i);
            if (m.isSet (Flags.Flag.DELETED)) continue;
            out.println ("<tr valigh=middle>");
            out.print ("<td width=\"25%\" bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + ((m.getFrom () != null) ? m.getFrom () [0].toString () : "") + "</font></td>");
            out.print ("<td nowrap width=\"15%\" bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + df.format ((m.getSentDate () != null) ? m.getSentDate () : m.getReceivedDate ()) + "</font></td>");
            out.print ("<td bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + "<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + i + "\">" + ((m.getSubject () != null) ? m.getSubject () : "<i>No Subject</i>") + "</a>" + "</font></td>");
            out.println ("</tr>");
        }
    } catch (MessagingException mex) {
        out.println ("<tr><td>" + mex.toString () + "</td></tr>");
        mex.printStackTrace ();
    }
    out.println ("</table>");
    out.println ("</BODY></html>");
    out.flush ();
    out.close ();
}


private void displayHeaders (MailUserData mud, HttpServletRequest req, ServletOutputStream out) throws IOException {
    SimpleDateFormat df = new SimpleDateFormat ("EE M/d/yy");
    out.println ("<html>");
    out.println ("<HEAD><TITLE>JavaMail Servlet</TITLE></HEAD>");
    out.println ("<BODY bgcolor=\"#ccccff\"><hr>");
    out.print ("<center><font face=\"Arial,Helvetica\" font size=\"+3\">");
    out.println ("<b>Folder " + mud.getStore ().getURLName () + "/INBOX</b></font></center><p>");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+3\"><b>");
    out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?logout=true\">Logout</a>");
    out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?compose=true\" target=\"compose\">Compose</a>");
    out.println ("</b></font>");
    out.println ("<hr>");
    out.print ("<table cellpadding=1 cellspacing=1 ");
    out.println ("width=\"100%\" border=1>");
    out.println ("<tr><td width=\"25%\" bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Sender</b></font></td>");
    out.println ("<td width=\"15%\" bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Date</b></font></td>");
    out.println ("<td bgcolor=\"ffffcc\">");
    out.println ("<font face=\"Arial,Helvetica\" font size=\"+1\">");
    out.println ("<b>Subject</b></font></td></tr>");
    try {
        Folder f = mud.getFolder ();
        int msgCount = f.getMessageCount ();
        Message m = null;
        for (int i = 1; i <= msgCount; i ++) {
            m = f.getMessage (i);
            if (m.isSet (Flags.Flag.DELETED)) continue;
            out.println ("<tr valigh=middle>");
            out.print ("<td width=\"25%\" bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + ((m.getFrom () != null) ? m.getFrom () [0].toString () : "") + "</font></td>");
            out.print ("<td nowrap width=\"15%\" bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + df.format ((m.getSentDate () != null) ? m.getSentDate () : m.getReceivedDate ()) + "</font></td>");
            out.print ("<td bgcolor=\"ffffff\">");
            out.println ("<font face=\"Arial,Helvetica\">" + "<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + i + "\">" + ((m.getSubject () != null) ? m.getSubject () : "<i>No Subject</i>") + "</a>" + "</font></td>");
            out.println ("</tr>");
        }
    } catch (MessagingException mex) {
        out.println ("<tr><td>" + mex.toString () + "</td></tr>");
        mex.printStackTrace ();
    }
    out.println ("</table>");
    out.println ("</BODY></html>");
    out.flush ();
    out.close ();
}


-----Function Pair=135=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=136=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=137=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=138=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=139=-----=1=

private void send (HttpServletRequest req, HttpServletResponse res, ServletOutputStream out, HttpSession ssn) throws IOException {
    String to = req.getParameter ("to");
    String cc = req.getParameter ("cc");
    String subj = req.getParameter ("subject");
    String text = req.getParameter ("text");
    try {
        MailUserData mud = getMUD (ssn);
        if (mud == null) throw new Exception ("trying to send, but not logged in");
        Message msg = new MimeMessage (mud.getSession ());
        InternetAddress [] toAddrs = null, ccAddrs = null;
        if (to != null) {
            toAddrs = InternetAddress.parse (to, false);
            msg.setRecipients (Message.RecipientType.TO, toAddrs);
        }
        else throw new MessagingException ("No \"To\" address specified");
        if (cc != null) {
            ccAddrs = InternetAddress.parse (cc, false);
            msg.setRecipients (Message.RecipientType.CC, ccAddrs);
        }
        if (subj != null) msg.setSubject (subj);
        URLName u = mud.getURLName ();
        msg.setFrom (new InternetAddress (u.getUsername () + "@" + u.getHost ()));
        if (text != null) msg.setText (text);
        Transport.send (msg);
        out.println ("<h1>Message sent successfully</h1></body></html>");
        out.close ();
    } catch (Exception mex) {
        out.println ("<h1>Error sending message.</h1>");
        out.println (mex.toString ());
        out.println ("<br></body></html>");
    }
}


private void send (HttpServletRequest req, HttpServletResponse res, ServletOutputStream out, HttpSession ssn) throws IOException {
    String to = req.getParameter ("to");
    String cc = req.getParameter ("cc");
    String subj = req.getParameter ("subject");
    String text = req.getParameter ("text");
    try {
        MailUserData mud = getMUD (ssn);
        if (mud == null) throw new Exception ("trying to send, but not logged in");
        Message msg = new MimeMessage (mud.getSession ());
        InternetAddress [] toAddrs = null, ccAddrs = null;
        if (to != null) {
            toAddrs = InternetAddress.parse (to, false);
            msg.setRecipients (Message.RecipientType.TO, toAddrs);
        }
        else throw new MessagingException ("No \"To\" address specified");
        if (cc != null) {
            ccAddrs = InternetAddress.parse (cc, false);
            msg.setRecipients (Message.RecipientType.CC, ccAddrs);
        }
        if (subj != null) msg.setSubject (subj);
        URLName u = mud.getURLName ();
        msg.setFrom (new InternetAddress (u.getUsername () + "@" + u.getHost ()));
        if (text != null) msg.setText (text);
        Transport.send (msg);
        out.println ("<h1>Message sent successfully</h1></body></html>");
        out.close ();
    } catch (Exception mex) {
        out.println ("<h1>Error sending message.</h1>");
        out.println (mex.toString ());
        out.println ("<br></body></html>");
    }
}


-----Function Pair=140=-----==

private void displayPart (MailUserData mud, int msgNum, Part part, int partNum, HttpServletRequest req, ServletOutputStream out) throws IOException {
    if (partNum != 0) out.println ("<p><hr>");
    try {
        String sct = part.getContentType ();
        if (sct == null) {
            out.println ("invalid part");
            return;
        }
        ContentType ct = new ContentType (sct);
        if (partNum != 0) out.println ("<b>Attachment Type:</b> " + ct.getBaseType () + "<br>");
        if (ct.match ("text/plain")) {
            out.println ("<pre>");
            out.println ((String) part.getContent ());
            out.println ("</pre>");
        }
        else {
            String s;
            if ((s = part.getFileName ()) != null) out.println ("<b>Filename:</b> " + s + "<br>");
            s = null;
            if ((s = part.getDescription ()) != null) out.println ("<b>Description:</b> " + s + "<br>");
            out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + msgNum + "&part=" + partNum + "\">Display Attachment</a>");
        }
    } catch (MessagingException mex) {
        out.println (mex.toString ());
    }
}


private void displayPart (MailUserData mud, int msgNum, Part part, int partNum, HttpServletRequest req, ServletOutputStream out) throws IOException {
    if (partNum != 0) out.println ("<p><hr>");
    try {
        String sct = part.getContentType ();
        if (sct == null) {
            out.println ("invalid part");
            return;
        }
        ContentType ct = new ContentType (sct);
        if (partNum != 0) out.println ("<b>Attachment Type:</b> " + ct.getBaseType () + "<br>");
        if (ct.match ("text/plain")) {
            out.println ("<pre>");
            out.println ((String) part.getContent ());
            out.println ("</pre>");
        }
        else {
            String s;
            if ((s = part.getFileName ()) != null) out.println ("<b>Filename:</b> " + s + "<br>");
            s = null;
            if ((s = part.getDescription ()) != null) out.println ("<b>Description:</b> " + s + "<br>");
            out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + msgNum + "&part=" + partNum + "\">Display Attachment</a>");
        }
    } catch (MessagingException mex) {
        out.println (mex.toString ());
    }
}


-----Function Pair=141=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=142=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=143=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=144=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=145=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=146=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=147=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=148=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=149=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=150=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=151=-----==

public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


public void doCurrentFrame (String command, String [] args) {
    try {
        int width, fp;
        switch (args.length) {
            case 0 :
                jdp_console.writeOutput (user.mem.printJVMstack (0, 4));
                break;
            case 1 :
                if (args [0].startsWith ("0x") || args [0].startsWith ("0X") || args [0].length () == 8) {
                    fp = parseHex32 (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (fp, 4));
                }
                else {
                    width = Integer.parseInt (args [0]);
                    jdp_console.writeOutput (user.mem.printJVMstack (0, width));
                }
                break;
            case 2 :
                fp = parseHex32 (args [0]);
                width = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.printJVMstack (fp, width));
                break;
        }
    } catch (NumberFormatException e) {
        printHelp (command);
    }
}


-----Function Pair=152=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=153=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=154=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=155=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=156=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=157=-----==

static void preRegister (Context c, final Set < String > keys) {
    if (keys != null) {
        c.put (JavacMessages.messagesKey, new Context.Factory < JavacMessages > () {
            public JavacMessages make (Context c) {
                return new MessageTracker (c) {
                    @Override
                    public String getLocalizedString (Locale l, String key, Object...args) {
                        keys.add (key);
                        return super.getLocalizedString (l, key, args);
                    }
                }
                ;
            }
        }
        );
    }
}


static void preRegister (Context c, final Set < String > keys) {
    if (keys != null) {
        c.put (JavacMessages.messagesKey, new Context.Factory < JavacMessages > () {
            public JavacMessages make (Context c) {
                return new MessageTracker (c) {
                    @Override
                    public String getLocalizedString (Locale l, String key, Object...args) {
                        keys.add (key);
                        return super.getLocalizedString (l, key, args);
                    }
                }
                ;
            }
        }
        );
    }
}


-----Function Pair=158=-----==

int new_javah (List < String > options, File outDir, File bootclasspath, String className) {
    List < String > args = new ArrayList < String > ();
    args.addAll (options);
    args.add ("-d");
    args.add (outDir.getPath ());
    args.add ("-bootclasspath");
    args.add (bootclasspath.getPath ());
    args.add (className);
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javah.Main.run (args.toArray (new String [args.size ()]), pw);
    pw.close ();
    System.err.println ("new javah out: " + sw.toString ());
    return rc;
}


int new_javah (List < String > options, File outDir, File bootclasspath, String className) {
    List < String > args = new ArrayList < String > ();
    args.addAll (options);
    args.add ("-d");
    args.add (outDir.getPath ());
    args.add ("-bootclasspath");
    args.add (bootclasspath.getPath ());
    args.add (className);
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javah.Main.run (args.toArray (new String [args.size ()]), pw);
    pw.close ();
    System.err.println ("new javah out: " + sw.toString ());
    return rc;
}


-----Function Pair=159=-----==

public void traversePath (String strPath, XMLReader xmlReader, FileWriter fw) throws SAXException, IOException {
    File path = new File (strPath);
    File [] files = path.listFiles ();
    if (files == null) {
        System.out.println ("The path " + strPath + " has no files");
        System.exit (1);
    }
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            traversePath (files [i].getAbsolutePath (), xmlReader, fw);
        }
        else {
            String strFileName = files [i].getAbsolutePath ();
            try {
                if (strFileName.contains ("zip")) {
                    traverseZipFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.contains ("tar.gz")) {
                    traverseTarGzFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.endsWith ("xml")) {
                    xmlReader.parse (strFileName);
                }
            } catch (SAXParseException e) {
                System.out.println ("Wrong Xml format file" + strFileName);
            }
        }
    }
    System.out.println ("Start Writing File");
    it = this.tagMap.entrySet ().iterator ();
    while (it.hasNext ()) {
        Map.Entry entry = (Map.Entry) it.next ();
        outputFile.write ((String) entry.getKey ());
        outputFile.write ('\t');
        count = (Integer) entry.getValue ();
        outputFile.write (Integer.toString (count));
        outputFile.write ('\t');
        rate = count / totalNum;
        outputFile.write (Double.toString (rate));
        outputFile.write ('\n');
        outputFile.flush ();
    }
    System.out.println ("Writing file finished");
}


public void traversePath (String strPath, XMLReader xmlReader, FileWriter fw) throws SAXException, IOException {
    File path = new File (strPath);
    File [] files = path.listFiles ();
    if (files == null) {
        System.out.println ("The path " + strPath + " has no files");
        System.exit (1);
    }
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            traversePath (files [i].getAbsolutePath (), xmlReader, fw);
        }
        else {
            String strFileName = files [i].getAbsolutePath ();
            try {
                if (strFileName.contains ("zip")) {
                    traverseZipFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.contains ("tar.gz")) {
                    traverseTarGzFile (strFileName, xmlReader, fw);
                }
                else if (strFileName.endsWith ("xml")) {
                    xmlReader.parse (strFileName);
                }
            } catch (SAXParseException e) {
                System.out.println ("Wrong Xml format file" + strFileName);
            }
        }
    }
    System.out.println ("Start Writing File");
    it = this.tagMap.entrySet ().iterator ();
    while (it.hasNext ()) {
        Map.Entry entry = (Map.Entry) it.next ();
        outputFile.write ((String) entry.getKey ());
        outputFile.write ('\t');
        count = (Integer) entry.getValue ();
        outputFile.write (Integer.toString (count));
        outputFile.write ('\t');
        rate = count / totalNum;
        outputFile.write (Double.toString (rate));
        outputFile.write ('\n');
        outputFile.flush ();
    }
    System.out.println ("Writing file finished");
}


-----Function Pair=160=-----==

private static byte [] readBytes (File file) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    try {
        InputStream fis = new FileInputStream (file);
        InputStream is = new BufferedInputStream (fis);
        int count = 0;
        byte [] buf = new byte [16384];
        while ((count = is.read (buf)) != - 1) {
            if (count > 0) baos.write (buf, 0, count);
        }
        is.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return baos.toByteArray ();
}


private static char [] readChars (File file) {
    CharArrayWriter caw = new CharArrayWriter ();
    try {
        Reader fr = new FileReader (file);
        Reader in = new BufferedReader (fr);
        int count = 0;
        char [] buf = new char [16384];
        while ((count = in.read (buf)) != - 1) {
            if (count > 0) caw.write (buf, 0, count);
        }
        in.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return caw.toCharArray ();
}


-----Function Pair=161=-----==

private byte [] showEmailOptions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "EmailOptions.html");
    template.replaceAll ("$emailTo$", store.getProperty ("email.to"));
    template.replaceAll ("$emailFrom$", store.getProperty ("email.from"));
    template.replaceAll ("$emailServer$", store.getProperty ("email.server.address"));
    template.replaceAll ("$emailPort$", store.getProperty ("email.server.port"));
    if ("1".equals (store.getProperty ("email.auth.enabled"))) template.replaceAll ("$emailAuthEnabled$", "CHECKED");
    else template.replaceAll ("$emailAuthEnabled$", "");
    template.replaceAll ("$emailAuthUser$", store.getProperty ("email.auth.user"));
    template.replaceAll ("$emailAuthPassword$", store.getProperty ("email.auth.password"));
    String security = store.getProperty ("email.security");
    if ("1".equals (security)) {
        template.replaceAll ("$emailSecurityNONE$", "");
        template.replaceAll ("$emailSecuritySTARTTLS$", "SELECTED");
    }
    else {
        template.replaceAll ("$emailSecurityNONE$", "SELECTED");
        template.replaceAll ("$emailSecuritySTARTTLS$", "");
    }
    String sendServerStarted = store.getProperty ("email.send.serverstarted");
    if ("1".equals (sendServerStarted)) template.replaceAll ("$sendServerStarted$", "CHECKED");
    else template.replaceAll ("$sendServerStarted$", "");
    String sendCapFinished = store.getProperty ("email.send.capfinished");
    if ("1".equals (sendCapFinished)) template.replaceAll ("$sendCapFinished$", "CHECKED");
    else template.replaceAll ("$sendCapFinished$", "");
    String sendEpgLoaded = store.getProperty ("email.send.epgloaded");
    if ("1".equals (sendEpgLoaded)) template.replaceAll ("$sendEpgLoaded$", "CHECKED");
    else template.replaceAll ("$sendEpgLoaded$", "");
    String sendOnWarning = store.getProperty ("email.send.onwarning");
    if ("1".equals (sendOnWarning)) template.replaceAll ("$sendOnWarning$", "CHECKED");
    else template.replaceAll ("$sendOnWarning$", "");
    String sendWeeklyReport = store.getProperty ("email.send.weeklyreport");
    if ("1".equals (sendWeeklyReport)) template.replaceAll ("$sendWeeklyReport$", "CHECKED");
    else template.replaceAll ("$sendWeeklyReport$", "");
    String sendFreeSpaceLow = store.getProperty ("email.send.freespacelow");
    if ("1".equals (sendFreeSpaceLow)) template.replaceAll ("$sendFreeSpaceLow$", "CHECKED");
    else template.replaceAll ("$sendFreeSpaceLow$", "");
    return template.getPageBytes ();
}


private byte [] showEmailOptions (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "EmailOptions.html");
    template.replaceAll ("$emailTo$", store.getProperty ("email.to"));
    template.replaceAll ("$emailFrom$", store.getProperty ("email.from"));
    template.replaceAll ("$emailServer$", store.getProperty ("email.server.address"));
    template.replaceAll ("$emailPort$", store.getProperty ("email.server.port"));
    if ("1".equals (store.getProperty ("email.auth.enabled"))) template.replaceAll ("$emailAuthEnabled$", "CHECKED");
    else template.replaceAll ("$emailAuthEnabled$", "");
    template.replaceAll ("$emailAuthUser$", store.getProperty ("email.auth.user"));
    template.replaceAll ("$emailAuthPassword$", store.getProperty ("email.auth.password"));
    String security = store.getProperty ("email.security");
    if ("1".equals (security)) {
        template.replaceAll ("$emailSecurityNONE$", "");
        template.replaceAll ("$emailSecuritySTARTTLS$", "SELECTED");
    }
    else {
        template.replaceAll ("$emailSecurityNONE$", "SELECTED");
        template.replaceAll ("$emailSecuritySTARTTLS$", "");
    }
    String sendServerStarted = store.getProperty ("email.send.serverstarted");
    if ("1".equals (sendServerStarted)) template.replaceAll ("$sendServerStarted$", "CHECKED");
    else template.replaceAll ("$sendServerStarted$", "");
    String sendCapFinished = store.getProperty ("email.send.capfinished");
    if ("1".equals (sendCapFinished)) template.replaceAll ("$sendCapFinished$", "CHECKED");
    else template.replaceAll ("$sendCapFinished$", "");
    String sendEpgLoaded = store.getProperty ("email.send.epgloaded");
    if ("1".equals (sendEpgLoaded)) template.replaceAll ("$sendEpgLoaded$", "CHECKED");
    else template.replaceAll ("$sendEpgLoaded$", "");
    String sendOnWarning = store.getProperty ("email.send.onwarning");
    if ("1".equals (sendOnWarning)) template.replaceAll ("$sendOnWarning$", "CHECKED");
    else template.replaceAll ("$sendOnWarning$", "");
    String sendWeeklyReport = store.getProperty ("email.send.weeklyreport");
    if ("1".equals (sendWeeklyReport)) template.replaceAll ("$sendWeeklyReport$", "CHECKED");
    else template.replaceAll ("$sendWeeklyReport$", "");
    String sendFreeSpaceLow = store.getProperty ("email.send.freespacelow");
    if ("1".equals (sendFreeSpaceLow)) template.replaceAll ("$sendFreeSpaceLow$", "CHECKED");
    else template.replaceAll ("$sendFreeSpaceLow$", "");
    return template.getPageBytes ();
}


-----Function Pair=162=-----=1=

private void traverseTarGzFile (String zipFileName, XMLReader xmlReader, FileWriter fw) throws IOException {
    index = 1;
    paraLength = 0;
    FileInputStream fileIn = null;
    BufferedInputStream bufIn = null;
    GZIPInputStream gzipIn = null;
    TarInputStream taris = null;
    try {
        fileIn = new FileInputStream (zipFileName);
        bufIn = new BufferedInputStream (fileIn);
        gzipIn = new GZIPInputStream (bufIn);
        taris = new TarInputStream (gzipIn);
        TarEntry entry = null;
        while ((entry = taris.getNextEntry ()) != null) {
            if (entry.isDirectory ()) continue;
            if (entry.getName ().endsWith (".DS_Store")) {
                System.out.println (entry.getName ());
                continue;
            }
            else if (entry.getName ().endsWith (".xml")) {
                ByteArrayOutputStream bos = new ByteArrayOutputStream ();
                byte buf [] = new byte [50000];
                int blen;
                while ((blen = taris.read (buf)) != - 1) {
                    bos.write (buf, 0, blen);
                }
                byte cbuf [] = bos.toByteArray ();
                ByteArrayInputStream bis = new ByteArrayInputStream (cbuf);
                InputSource inputSource = new InputSource (bis);
                xmlReader.parse (inputSource);
                ucid_flag = 0;
                msid_flag = 0;
                ucid.delete (0, ucid.length ());
                msid.delete (0, msid.length ());
                index = 1;
                paraLength = 0;
                ucidTag_flag = 0;
                msidTag_flag = 0;
            }
            else continue;
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        taris.close ();
        gzipIn.close ();
        bufIn.close ();
        fileIn.close ();
    }
}


private void traverseTarGzFile (String zipFileName, XMLReader xmlReader, FileWriter fw) throws IOException {
    index = 1;
    paraLength = 0;
    FileInputStream fileIn = null;
    BufferedInputStream bufIn = null;
    GZIPInputStream gzipIn = null;
    TarInputStream taris = null;
    try {
        fileIn = new FileInputStream (zipFileName);
        bufIn = new BufferedInputStream (fileIn);
        gzipIn = new GZIPInputStream (bufIn);
        taris = new TarInputStream (gzipIn);
        TarEntry entry = null;
        while ((entry = taris.getNextEntry ()) != null) {
            if (entry.isDirectory ()) continue;
            if (entry.getName ().endsWith (".DS_Store")) {
                System.out.println (entry.getName ());
                continue;
            }
            else if (entry.getName ().endsWith (".xml")) {
                ByteArrayOutputStream bos = new ByteArrayOutputStream ();
                byte buf [] = new byte [50000];
                int blen;
                while ((blen = taris.read (buf)) != - 1) {
                    bos.write (buf, 0, blen);
                }
                byte cbuf [] = bos.toByteArray ();
                ByteArrayInputStream bis = new ByteArrayInputStream (cbuf);
                InputSource inputSource = new InputSource (bis);
                xmlReader.parse (inputSource);
                ucid_flag = 0;
                msid_flag = 0;
                ucid.delete (0, ucid.length ());
                msid.delete (0, msid.length ());
                index = 1;
                paraLength = 0;
                ucidTag_flag = 0;
                msidTag_flag = 0;
            }
            else continue;
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        taris.close ();
        gzipIn.close ();
        bufIn.close ();
        fileIn.close ();
    }
}


-----Function Pair=163=-----==

private String addSchedule (HTTPurl urlData, ScheduleItem item) throws Exception {
    int startBuff = 0;
    int endBuff = 0;
    try {
        startBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.start"));
        endBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.end"));
    } catch (Exception e) {
    }
    String addBuff = urlData.getParameter ("buffer");
    String y = urlData.getParameter ("year");
    String m = urlData.getParameter ("month");
    String d = urlData.getParameter ("day");
    String h = urlData.getParameter ("hour");
    String mi = urlData.getParameter ("min");
    String dur = urlData.getParameter ("duration");
    String channel = urlData.getParameter ("channel");
    String name = urlData.getParameter ("name");
    String autoDel = urlData.getParameter ("autoDel");
    String namePattern = urlData.getParameter ("namePattern");
    String keepFor = urlData.getParameter ("keepfor");
    String task = urlData.getParameter ("task");
    HashMap channels = store.getChannels ();
    if (! channels.containsKey (channel)) {
        throw new Exception ("Channel Not Found!");
    }
    String [] namePatterns = store.getNamePatterns ();
    if (namePattern == null || namePattern.length () == 0) namePattern = namePatterns [0];
    GuideStore guide = GuideStore.getInstance ();
    boolean found = false;
    for (int x = 0; x < namePatterns.length; x ++) {
        if (namePatterns [x].equals (namePattern)) {
            found = true;
            break;
        }
    }
    if (! found) {
        throw new Exception ("Name Pattern Not Found!");
    }
    if (item != null) {
        store.removeScheduleItem (item.toString ());
    }
    int duration = Integer.parseInt (dur);
    int type = 0;
    try {
        type = Integer.parseInt (urlData.getParameter ("type"));
    } catch (Exception e01) {
    }
    int captype = 2;
    try {
        captype = Integer.parseInt (store.getProperty ("Capture.deftype"));
    } catch (Exception e01) {
    }
    try {
        captype = Integer.parseInt (urlData.getParameter ("captype"));
    } catch (Exception e01) {
    }
    Calendar newDate = Calendar.getInstance ();
    newDate.set (Calendar.MILLISECOND, 0);
    newDate.set (Integer.parseInt (y), Integer.parseInt (m), Integer.parseInt (d), Integer.parseInt (h), Integer.parseInt (mi), 0);
    if ("yes".equals (addBuff)) {
        newDate.add (Calendar.MINUTE, (startBuff * - 1));
        duration = duration + startBuff + endBuff;
    }
    if (item == null) item = new ScheduleItem (store.rand.nextLong ());
    item.setCreatedFrom (null);
    item.setCapType (captype);
    item.setType (type);
    item.setName (name);
    item.setState (ScheduleItem.WAITING);
    item.setStatus ("Waiting");
    item.resetAbort ();
    item.setStart (newDate);
    item.setDuration (duration);
    int pathIndex = - 1;
    try {
        pathIndex = Integer.parseInt (urlData.getParameter ("path"));
    } catch (Exception e01) {
    }
    item.setCapturePathIndex (pathIndex);
    item.setChannel (channel);
    if ("true".equalsIgnoreCase (autoDel)) item.setAutoDeletable (true);
    else item.setAutoDeletable (false);
    item.setFilePattern (namePattern);
    if (keepFor != null) {
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    else {
        keepFor = store.getProperty ("AutoDel.KeepFor");
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    if (task != null && ! task.equalsIgnoreCase ("none") && task.length () > 0) {
        HashMap tasks = store.getTaskList ();
        if (tasks.containsKey (task)) item.setPostTask (task);
    }
    else if (task != null && task.equalsIgnoreCase ("none")) {
        item.setPostTask ("");
    }
    item.log ("New Schedule added/edited");
    boolean isAlreadyInLIst = guide.isAlreadyInList (item, 1);
    if (isAlreadyInLIst) {
        return "Already In List";
    }
    else {
        store.addScheduleItem (item);
    }
    return null;
}


private String addSchedule (HTTPurl urlData, ScheduleItem item) throws Exception {
    int startBuff = 0;
    int endBuff = 0;
    try {
        startBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.start"));
        endBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.end"));
    } catch (Exception e) {
    }
    String addBuff = urlData.getParameter ("buffer");
    String y = urlData.getParameter ("year");
    String m = urlData.getParameter ("month");
    String d = urlData.getParameter ("day");
    String h = urlData.getParameter ("hour");
    String mi = urlData.getParameter ("min");
    String dur = urlData.getParameter ("duration");
    String channel = urlData.getParameter ("channel");
    String name = urlData.getParameter ("name");
    String autoDel = urlData.getParameter ("autoDel");
    String namePattern = urlData.getParameter ("namePattern");
    String keepFor = urlData.getParameter ("keepfor");
    String task = urlData.getParameter ("task");
    HashMap channels = store.getChannels ();
    if (! channels.containsKey (channel)) {
        throw new Exception ("Channel Not Found!");
    }
    String [] namePatterns = store.getNamePatterns ();
    if (namePattern == null || namePattern.length () == 0) namePattern = namePatterns [0];
    GuideStore guide = GuideStore.getInstance ();
    boolean found = false;
    for (int x = 0; x < namePatterns.length; x ++) {
        if (namePatterns [x].equals (namePattern)) {
            found = true;
            break;
        }
    }
    if (! found) {
        throw new Exception ("Name Pattern Not Found!");
    }
    if (item != null) {
        store.removeScheduleItem (item.toString ());
    }
    int duration = Integer.parseInt (dur);
    int type = 0;
    try {
        type = Integer.parseInt (urlData.getParameter ("type"));
    } catch (Exception e01) {
    }
    int captype = 2;
    try {
        captype = Integer.parseInt (store.getProperty ("Capture.deftype"));
    } catch (Exception e01) {
    }
    try {
        captype = Integer.parseInt (urlData.getParameter ("captype"));
    } catch (Exception e01) {
    }
    Calendar newDate = Calendar.getInstance ();
    newDate.set (Calendar.MILLISECOND, 0);
    newDate.set (Integer.parseInt (y), Integer.parseInt (m), Integer.parseInt (d), Integer.parseInt (h), Integer.parseInt (mi), 0);
    if ("yes".equals (addBuff)) {
        newDate.add (Calendar.MINUTE, (startBuff * - 1));
        duration = duration + startBuff + endBuff;
    }
    if (item == null) item = new ScheduleItem (store.rand.nextLong ());
    item.setCreatedFrom (null);
    item.setCapType (captype);
    item.setType (type);
    item.setName (name);
    item.setState (ScheduleItem.WAITING);
    item.setStatus ("Waiting");
    item.resetAbort ();
    item.setStart (newDate);
    item.setDuration (duration);
    int pathIndex = - 1;
    try {
        pathIndex = Integer.parseInt (urlData.getParameter ("path"));
    } catch (Exception e01) {
    }
    item.setCapturePathIndex (pathIndex);
    item.setChannel (channel);
    if ("true".equalsIgnoreCase (autoDel)) item.setAutoDeletable (true);
    else item.setAutoDeletable (false);
    item.setFilePattern (namePattern);
    if (keepFor != null) {
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    else {
        keepFor = store.getProperty ("AutoDel.KeepFor");
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    if (task != null && ! task.equalsIgnoreCase ("none") && task.length () > 0) {
        HashMap tasks = store.getTaskList ();
        if (tasks.containsKey (task)) item.setPostTask (task);
    }
    else if (task != null && task.equalsIgnoreCase ("none")) {
        item.setPostTask ("");
    }
    item.log ("New Schedule added/edited");
    boolean isAlreadyInLIst = guide.isAlreadyInList (item, 1);
    if (isAlreadyInLIst) {
        return "Already In List";
    }
    else {
        store.addScheduleItem (item);
    }
    return null;
}


-----Function Pair=164=-----=1=

public static void main (String [] args) {
    final String dbdriver = "org.postgresql.Driver";
    final String dbconnect = "jdbc:postgresql://prologdev1:5432/wdb";
    final String dbuser = "guest2";
    final String dbpasswd = "";
    Connection con = null;
    Statement statement = null;
    try {
        Class.forName (dbdriver);
        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);
        statement = con.createStatement ();
    } catch (Exception e) {
        System.out.println ("FATAL: cant load the database driver <" + dbdriver + ">!");
        System.exit (1);
    }
    String wdbInit = "SELECT wci.begin('" + dbuser + "')";
    String sql = " SELECT value, dataProviderName, placeName, placeGeometry," + "        referencetime, " + "        validFrom, validTo, " + "        valueParameterName, valueParameterUnit, " + "        levelParameterName, levelUnitName, levelFrom, levelTo, " + "        dataVersion, confidenceCode, storetime, valueid, valuetype " + " FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', " + "                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), " + "                NULL, " + "                array['instant pressure of air', " + "                      'instant temperature of air', " + "                      'instant velocity of air (u-component)', " + "                      'instant velocity of air (v-component)'], " + "                ( 2, 2, 'distance above ground', 'exact' ), " + "                array[-1], " + "                NULL::wci.returnFloat )";
    final String colNames [] = {"value", "dataProviderName", "placeName", "referencetime", "validFrom", "validTo", "valueParameterName", "valueParameterUnit", "levelParameterName", "levelUnitName", "levelFrom", "levelTo", "dataVersion"};
    ResultSet rs = null;
    try {
        statement.execute (wdbInit);
        rs = statement.executeQuery (sql);
        ResultSetMetaData rsMetaData = rs.getMetaData ();
        String data;
        boolean first;
        while (rs.next ()) {
            first = true;
            for (String name : colNames) {
                data = rs.getString (name);
                if (first) {
                    first = false;
                }
                else {
                    System.out.print (", ");
                }
                if (data != null) System.out.print (data);
                else System.out.print ("\\N");
            }
            System.out.println ();
        }
    } catch (Exception ex) {
        System.out.println ("SELECT error: " + ex);
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (SQLException ex) {
                System.out.println ("EXCEPTION: rs.close: " + ex);
            }
        }
    }
}


public static void main (String [] args) {
    final String dbdriver = "org.postgresql.Driver";
    final String dbconnect = "jdbc:postgresql://prologdev1:5432/wdb";
    final String dbuser = "guest2";
    final String dbpasswd = "";
    Connection con = null;
    Statement statement = null;
    try {
        Class.forName (dbdriver);
        con = DriverManager.getConnection (dbconnect, dbuser, dbpasswd);
        statement = con.createStatement ();
    } catch (Exception e) {
        System.out.println ("FATAL: cant load the database driver <" + dbdriver + ">!");
        System.exit (1);
    }
    String wdbInit = "SELECT wci.begin('" + dbuser + "')";
    String sql = " SELECT value, dataProviderName, placeName, placeGeometry," + "        referencetime, " + "        validFrom, validTo, " + "        valueParameterName, valueParameterUnit, " + "        levelParameterName, levelUnitName, levelFrom, levelTo, " + "        dataVersion, confidenceCode, storetime, valueid, valuetype " + " FROM wci.read( array['hirlam 10'], 'POINT( 10.0 59.0 )', " + "                ('2000-01-03 01:00:00', '2000-01-03 01:00:00', 'exact'), " + "                NULL, " + "                array['instant pressure of air', " + "                      'instant temperature of air', " + "                      'instant velocity of air (u-component)', " + "                      'instant velocity of air (v-component)'], " + "                ( 2, 2, 'distance above ground', 'exact' ), " + "                array[-1], " + "                NULL::wci.returnFloat )";
    final String colNames [] = {"value", "dataProviderName", "placeName", "referencetime", "validFrom", "validTo", "valueParameterName", "valueParameterUnit", "levelParameterName", "levelUnitName", "levelFrom", "levelTo", "dataVersion"};
    ResultSet rs = null;
    try {
        statement.execute (wdbInit);
        rs = statement.executeQuery (sql);
        ResultSetMetaData rsMetaData = rs.getMetaData ();
        String data;
        boolean first;
        while (rs.next ()) {
            first = true;
            for (String name : colNames) {
                data = rs.getString (name);
                if (first) {
                    first = false;
                }
                else {
                    System.out.print (", ");
                }
                if (data != null) System.out.print (data);
                else System.out.print ("\\N");
            }
            System.out.println ();
        }
    } catch (Exception ex) {
        System.out.println ("SELECT error: " + ex);
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (SQLException ex) {
                System.out.println ("EXCEPTION: rs.close: " + ex);
            }
        }
    }
}


-----Function Pair=165=-----=1=

private void initializeOMEncoder (Properties sosProps) throws OwsExceptionReport {
    String className = sosProps.getProperty (OMENCODER);
    try {
        if (className == null) {
            log.fatal ("No OMEncoder Implementation is set in the configFile!");
            OwsExceptionReport se = new OwsExceptionReport ();
            se.addCodedException (OwsExceptionReport.ExceptionCode.NoApplicableCode, "SosConfigurator.initializeOMEncoder()", "No OMEncoder Implementation is set in the configFile!");
            throw se;
        }
        Class omEncoderClass = Class.forName (className);
        Class [] constrArgs = {};
        Object [] args = {};
        Constructor < IOMEncoder > constructor = omEncoderClass.getConstructor ();
        this.omEncoder = constructor.newInstance ();
        log.info ("\n******\n" + className + " loaded successfully!\n******\n");
    } catch (ClassNotFoundException cnfe) {
        log.fatal ("Error while loading OMEncoder, required class could not be loaded: " + cnfe.toString ());
        throw new OwsExceptionReport (cnfe.getMessage (), cnfe.getCause ());
    } catch (SecurityException se) {
        log.fatal ("Error while loading OMEncoder: " + se.toString ());
        throw new OwsExceptionReport (se.getMessage (), se.getCause ());
    } catch (NoSuchMethodException nsme) {
        log.fatal ("Error while loading OMEncoder, no required constructor available: " + nsme.toString ());
        throw new OwsExceptionReport (nsme.getMessage (), nsme.getCause ());
    } catch (IllegalArgumentException iae) {
        log.fatal ("Error while loading OMEncoder, parameters for the constructor are illegal: " + iae.toString ());
        throw new OwsExceptionReport (iae.getMessage (), iae.getCause ());
    } catch (InstantiationException ie) {
        log.fatal ("The instatiation of a OMEncoder failed: " + ie.toString ());
        throw new OwsExceptionReport (ie.getMessage (), ie.getCause ());
    } catch (IllegalAccessException iace) {
        log.fatal ("The instatiation of an OMEncoder failed: " + iace.toString ());
        throw new OwsExceptionReport (iace.getMessage (), iace.getCause ());
    } catch (InvocationTargetException ite) {
        log.fatal ("the instatiation of an OMEncoder failed: " + ite.toString () + ite.getLocalizedMessage () + ite.getCause ());
        throw new OwsExceptionReport (ite.getMessage (), ite.getCause ());
    }
}


private void initializeGMLEncoder (Properties sosProps) throws OwsExceptionReport {
    String className = sosProps.getProperty (GMLENCODER);
    try {
        if (className == null) {
            log.fatal ("No GMLEncoder Implementation is set in the configFile!");
            OwsExceptionReport se = new OwsExceptionReport ();
            se.addCodedException (OwsExceptionReport.ExceptionCode.NoApplicableCode, "SosConfigurator.initializeGMLEncoder()", "No GMLEncoder Implementation is set in the configFile!");
            throw se;
        }
        Class gmlEncoderClass = Class.forName (className);
        Class [] constrArgs = {};
        Object [] args = {};
        Constructor < IGMLEncoder > constructor = gmlEncoderClass.getConstructor ();
        this.gmlEncoder = constructor.newInstance ();
        log.info ("\n******\n" + className + " loaded successfully!\n******\n");
    } catch (ClassNotFoundException cnfe) {
        log.fatal ("Error while loading GMLEncoder, required class could not be loaded: " + cnfe.toString ());
        throw new OwsExceptionReport (cnfe.getMessage (), cnfe.getCause ());
    } catch (SecurityException se) {
        log.fatal ("Error while loading GMLEncoder: " + se.toString ());
        throw new OwsExceptionReport (se.getMessage (), se.getCause ());
    } catch (NoSuchMethodException nsme) {
        log.fatal ("Error while loading GMLEncoder, no required constructor available: " + nsme.toString ());
        throw new OwsExceptionReport (nsme.getMessage (), nsme.getCause ());
    } catch (IllegalArgumentException iae) {
        log.fatal ("Error while loading GMLEncoder, parameters for the constructor are illegal: " + iae.toString ());
        throw new OwsExceptionReport (iae.getMessage (), iae.getCause ());
    } catch (InstantiationException ie) {
        log.fatal ("The instatiation of GMLEncoder failed: " + ie.toString ());
        throw new OwsExceptionReport (ie.getMessage (), ie.getCause ());
    } catch (IllegalAccessException iace) {
        log.fatal ("The instatiation of GMLEncoder failed: " + iace.toString ());
        throw new OwsExceptionReport (iace.getMessage (), iace.getCause ());
    } catch (InvocationTargetException ite) {
        log.fatal ("the instatiation of GMLEncoder failed: " + ite.toString () + ite.getLocalizedMessage () + ite.getCause ());
        throw new OwsExceptionReport (ite.getMessage (), ite.getCause ());
    }
}


-----Function Pair=166=-----=1=

public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


-----Function Pair=167=-----==

private static void hasfield () throws TestException {
    DummyPoint p = new DummyPoint ();
    System.out.println ("    java> DummyPoint p = new DummyPoint()");
    System.out.print ("    * hasField( p, 'x' ) ");
    if (! RJavaTools.hasField (p, "x")) {
        throw new TestException (" hasField( DummyPoint, 'x' ) == false");
    }
    System.out.println (" true : ok");
    System.out.print ("    * hasField( p, 'iiiiiiiiiiiii' ) ");
    if (RJavaTools.hasField (p, "iiiiiiiiiiiii")) {
        throw new TestException (" hasField( DummyPoint, 'iiiiiiiiiiiii' ) == true");
    }
    System.out.println ("  false : ok");
    RJavaTools_Test ob = new RJavaTools_Test ();
    System.out.print ("    * testing a private field ");
    if (RJavaTools.hasField (ob, "bogus")) {
        throw new TestException (" hasField returned true on private field");
    }
    System.out.println ("  false : ok");
}


private static void hasmethod () throws TestException {
    DummyPoint p = new DummyPoint ();
    System.out.println ("    java> DummyPoint p = new DummyPoint()");
    System.out.print ("    * hasMethod( p, 'move' ) ");
    if (! RJavaTools.hasMethod (p, "move")) {
        throw new TestException (" hasField( DummyPoint, 'move' ) == false");
    }
    System.out.println (" true : ok");
    System.out.print ("    * hasMethod( p, 'iiiiiiiiiiiii' ) ");
    if (RJavaTools.hasMethod (p, "iiiiiiiiiiiii")) {
        throw new TestException (" hasMethod( Point, 'iiiiiiiiiiiii' ) == true");
    }
    System.out.println ("  false : ok");
    RJavaTools_Test ob = new RJavaTools_Test ();
    System.out.print ("    * testing a private method ");
    if (RJavaTools.hasField (ob, "getBogus")) {
        throw new TestException (" hasMethod returned true on private method");
    }
    System.out.println ("  false : ok");
}


-----Function Pair=168=-----=1=

public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


public static void main (String args []) throws Exception {
    Class c = Class.forName ("tClass");
    System.out.println (c);
    try {
        Class c_not_found = Class.forName ("NotAClassSoThrowAnExceptionPlease");
    } catch (ClassNotFoundException e) {
        System.out.println ("caught ClassNotFoundException");
    }
    if (c.isArray ()) System.out.println (c + " is an array????");
    else System.out.println (c + " is not an array...good");
    Constructor ctors [] = c.getConstructors ();
    Arrays.sort (ctors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + ctors.length + " visible constructors");
    for (int i = 0; i < ctors.length; ++ i) System.out.println ("   " + i + ": " + ctors [i]);
    Constructor declaredCtors [] = c.getDeclaredConstructors ();
    Arrays.sort (declaredCtors, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has " + declaredCtors.length + " declared constructors");
    for (int i = 0; i < declaredCtors.length; ++ i) System.out.println ("   " + i + ": " + declaredCtors [i]);
    Method methods [] = c.getMethods ();
    Method hello = null;
    Method iello = null;
    Method lello = null;
    Method jello = null;
    Method vello = null;
    Method declaredMethods [] = c.getDeclaredMethods ();
    Arrays.sort (declaredMethods, new Comparator () {
        public int compare (Object x, Object y) {
            return x.toString ().compareTo (y.toString ());
        }
    }
    );
    System.out.println (c + " has a total number of methods: " + methods.length);
    for (int i = 0; i < methods.length; i ++) {
        if (methods [i].getName ().equals ("hello")) hello = methods [i];
        if (methods [i].getName ().equals ("iello")) iello = methods [i];
        if (methods [i].getName ().equals ("lello")) lello = methods [i];
        if (methods [i].getName ().equals ("jello")) jello = methods [i];
        if (methods [i].getName ().equals ("vello")) vello = methods [i];
    }
    System.out.println (" Number of declared methods: " + declaredMethods.length);
    for (int i = 0; i < declaredMethods.length; i ++) System.out.println (declaredMethods [i]);
    if (hello == null) {
        System.out.println ("tClass.hello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + hello);
    }
    int n_calls = 3;
    while (n_calls -- > 0) {
        String hello_args [] = {"I Say Hello to You!"};
        String result = (String) hello.invoke (null, hello_args);
        System.out.println (result);
    }
    if (iello == null) {
        System.out.println ("tClass.iello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + iello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object iello_args [] = {"I Say Iello to You!", new Integer (99)};
        Integer result = (Integer) iello.invoke (null, iello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (lello == null) {
        System.out.println ("tClass.lello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + lello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object lello_args [] = {"I Say Lello to You!", new Long (99)};
        Long result = (Long) lello.invoke (null, lello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    if (jello == null) {
        System.out.println ("tClass.jello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + jello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        Object jello_args [] = {new Integer (99), "I Say Jello to You!", new Integer (95), new Integer (94)};
        Integer result = (Integer) jello.invoke (null, jello_args);
        System.out.println ("Does this>" + result + "< look like 99?");
    }
    tClass tc = new tClass ("Hi!");
    String initargs [] = {"I'm dynamic!"};
    tClass tc_dyn = (tClass) ctors [0].newInstance (initargs);
    if (vello == null) {
        System.out.println ("tClass.vello not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vello);
    }
    n_calls = 3;
    while (n_calls -- > 0) {
        String vello_args [] = {"I Say Vello to You!"};
        String result = (String) vello.invoke (tc_dyn, vello_args);
        System.out.println (result);
    }
}


-----Function Pair=169=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=170=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=171=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=172=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=173=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=174=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=175=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=176=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=177=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=178=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=179=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=180=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=181=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=182=-----=1=

public static void start () {
    File workdir = new File (System.getProperty ("user.dir"));
    File outputdir = new File (workdir, "output");
    if (! outputdir.exists ()) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  Directory " + outputdir + " does not exist.");
        System.out.println ("");
        System.out.println ("  Make sure you've built the native executable first before running ");
        System.out.println ("  these tests.");
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
    String osname = System.getProperty ("os.name");
    File iodaemon = new File ("");
    if (osname.startsWith ("Linux")) {
        throw new Error ("TODO: IMPLEMENT LINUX IODAEMON PATH");
    }
    else if (osname.startsWith ("Windows")) {
        iodaemon = new File (outputdir, "cygwin");
        iodaemon = new File (iodaemon, "iodaemon-" + VERSION + ".exe");
    }
    else if (osname.startsWith ("Mac")) {
        throw new Error ("TODO: IMPLEMENT MACOS IODAEMON PATH");
    }
    if (! iodaemon.exists ()) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  " + iodaemon.getAbsolutePath () + " does not exist.");
        System.out.println ("");
        System.out.println ("  Make sure you've built the native executable first before running ");
        System.out.println ("  these tests.");
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
    ProcessBuilder builder = new ProcessBuilder (iodaemon.getAbsolutePath (), "--port=" + TEST_DAEMON_PORT);
    try {
        process = builder.start ();
        readInputStream (process.getInputStream ());
        readErrorStream (process.getErrorStream ());
        try {
            int exitValue = process.exitValue ();
            System.out.println ("***********************************************************************");
            System.out.println ("");
            System.out.println ("  I/O Daemon did not start normally (exit value: " + exitValue + ").");
            System.out.println ("");
            System.out.println ("***********************************************************************");
            System.exit (- 1);
        } catch (IllegalThreadStateException e) {
        }
    } catch (Exception e) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  Cannot start I/O daemon!");
        System.out.println ("");
        System.out.println ("  " + e.toString ());
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
}


public static void start () {
    File workdir = new File (System.getProperty ("user.dir"));
    File outputdir = new File (workdir, "output");
    if (! outputdir.exists ()) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  Directory " + outputdir + " does not exist.");
        System.out.println ("");
        System.out.println ("  Make sure you've built the native executable first before running ");
        System.out.println ("  these tests.");
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
    String osname = System.getProperty ("os.name");
    File iodaemon = new File ("");
    if (osname.startsWith ("Linux")) {
        throw new Error ("TODO: IMPLEMENT LINUX IODAEMON PATH");
    }
    else if (osname.startsWith ("Windows")) {
        iodaemon = new File (outputdir, "cygwin");
        iodaemon = new File (iodaemon, "iodaemon-" + VERSION + ".exe");
    }
    else if (osname.startsWith ("Mac")) {
        throw new Error ("TODO: IMPLEMENT MACOS IODAEMON PATH");
    }
    if (! iodaemon.exists ()) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  " + iodaemon.getAbsolutePath () + " does not exist.");
        System.out.println ("");
        System.out.println ("  Make sure you've built the native executable first before running ");
        System.out.println ("  these tests.");
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
    ProcessBuilder builder = new ProcessBuilder (iodaemon.getAbsolutePath (), "--port=" + TEST_DAEMON_PORT);
    try {
        process = builder.start ();
        readInputStream (process.getInputStream ());
        readErrorStream (process.getErrorStream ());
        try {
            int exitValue = process.exitValue ();
            System.out.println ("***********************************************************************");
            System.out.println ("");
            System.out.println ("  I/O Daemon did not start normally (exit value: " + exitValue + ").");
            System.out.println ("");
            System.out.println ("***********************************************************************");
            System.exit (- 1);
        } catch (IllegalThreadStateException e) {
        }
    } catch (Exception e) {
        System.out.println ("***********************************************************************");
        System.out.println ("");
        System.out.println ("  Cannot start I/O daemon!");
        System.out.println ("");
        System.out.println ("  " + e.toString ());
        System.out.println ("");
        System.out.println ("***********************************************************************");
        System.exit (- 1);
    }
}


-----Function Pair=183=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=184=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=185=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=186=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=187=-----==

public boolean validateMethodLeft () throws Exception {
    String testRoot = TEST_MethodLeft;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("a", "[a]");
    sReferencePS.set ("b", "[a  ]");
    sReferencePS.set ("c", "[aa ]");
    sReferencePS.set ("d", "[aaa]");
    sReferencePS.set ("e", "[aaaa]");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


public boolean validateMethodSpaces () throws Exception {
    String testRoot = TEST_MethodSpaces;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("-1s", "[ ]");
    sReferencePS.set ("0s", "[]");
    sReferencePS.set ("1s", "[ ]");
    sReferencePS.set ("2s", "[  ]");
    sReferencePS.set ("4s", "[    ]");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=188=-----==

public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


-----Function Pair=189=-----==

public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


-----Function Pair=190=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=191=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=192=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=193=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=194=-----==

int new_javah (List < String > options, File outDir, File bootclasspath, String className) {
    List < String > args = new ArrayList < String > ();
    args.addAll (options);
    args.add ("-d");
    args.add (outDir.getPath ());
    args.add ("-bootclasspath");
    args.add (bootclasspath.getPath ());
    args.add (className);
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javah.Main.run (args.toArray (new String [args.size ()]), pw);
    pw.close ();
    System.err.println ("new javah out: " + sw.toString ());
    return rc;
}


int new_javah (List < String > options, File outDir, File bootclasspath, String className) {
    List < String > args = new ArrayList < String > ();
    args.addAll (options);
    args.add ("-d");
    args.add (outDir.getPath ());
    args.add ("-bootclasspath");
    args.add (bootclasspath.getPath ());
    args.add (className);
    StringWriter sw = new StringWriter ();
    PrintWriter pw = new PrintWriter (sw);
    int rc = com.sun.tools.javah.Main.run (args.toArray (new String [args.size ()]), pw);
    pw.close ();
    System.err.println ("new javah out: " + sw.toString ());
    return rc;
}


-----Function Pair=195=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=196=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=197=-----=1=

public void start (Gedcom gedcom) {
    String cmd = getValueFromUser ("executables", translate ("WhichExecutable"), new String [0]);
    if (cmd == null) return;
    try {
        Process process = Runtime.getRuntime ().exec (cmd);
        BufferedReader in = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        while (true) {
            String line = in.readLine ();
            if (line == null) break;
            println (line);
        }
    } catch (IOException ioe) {
        println (translate ("Error") + ioe.getMessage ());
    }
}


public void start (Object context) {
    String cmd = getValueFromUser ("executables", i18n ("WhichExecutable"), new String [0]);
    if (cmd == null) return;
    try {
        Process process = Runtime.getRuntime ().exec (cmd);
        BufferedReader in = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        while (true) {
            String line = in.readLine ();
            if (line == null) break;
            println (line);
        }
    } catch (IOException ioe) {
        println (i18n ("Error") + ioe.getMessage ());
    }
}


-----Function Pair=198=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=199=-----==

public boolean validateMethodGetNumUserArgs () throws Exception {
    String testRoot = TEST_MethodGetNumUserArgs;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("arg0", "ua1");
    sReferencePS.set ("arg1", "u a 2");
    sReferencePS.set ("arg2", "ua3");
    sReferencePS.set ("numUserArgs", String.valueOf (NUM_USER_ARGS_testMethodGetNumUserArgs));
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


public boolean validateMethodGetUserArg () throws Exception {
    String testRoot = TEST_MethodGetUserArg;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("ua1", "ua1");
    sReferencePS.set ("ua2", "ua2");
    sReferencePS.set ("ua3", "ua3");
    sReferencePS.set ("ua4", "ua4");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=200=-----==

public void unsubscribe (List list) {
    try {
        Connection conn = Ozymandias.getDBConnection ();
        Statement stmt = conn.createStatement ();
        String dbQuery = "DELETE FROM UserLists WHERE (U_ID='" + getUID () + "' AND L_ID='" + list.getLID () + "')";
        stmt.executeQuery (dbQuery);
    } catch (SQLException e) {
        System.out.println (e);
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    } catch (InstantiationException e) {
        System.out.println (e);
    } catch (IllegalAccessException e) {
        System.out.println (e);
    }
}


public void unsubscribe (List list) {
    try {
        Connection conn = Ozymandias.getDBConnection ();
        Statement stmt = conn.createStatement ();
        String dbQuery = "DELETE FROM UserLists WHERE (U_ID='" + getUID () + "' AND L_ID='" + list.getLID () + "')";
        stmt.executeQuery (dbQuery);
    } catch (SQLException e) {
        System.out.println (e);
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    } catch (InstantiationException e) {
        System.out.println (e);
    } catch (IllegalAccessException e) {
        System.out.println (e);
    }
}


-----Function Pair=201=-----=1=

public sendhtml (String [] argv) {
    String to, subject = null, from = null, cc = null, bcc = null, url = null;
    String mailhost = null;
    String mailer = "sendhtml";
    String protocol = null, host = null, user = null, password = null;
    String record = null;
    boolean debug = false;
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    int optind;
    for (optind = 0; optind < argv.length; optind ++) {
        if (argv [optind].equals ("-T")) {
            protocol = argv [++ optind];
        }
        else if (argv [optind].equals ("-H")) {
            host = argv [++ optind];
        }
        else if (argv [optind].equals ("-U")) {
            user = argv [++ optind];
        }
        else if (argv [optind].equals ("-P")) {
            password = argv [++ optind];
        }
        else if (argv [optind].equals ("-M")) {
            mailhost = argv [++ optind];
        }
        else if (argv [optind].equals ("-f")) {
            record = argv [++ optind];
        }
        else if (argv [optind].equals ("-s")) {
            subject = argv [++ optind];
        }
        else if (argv [optind].equals ("-o")) {
            from = argv [++ optind];
        }
        else if (argv [optind].equals ("-c")) {
            cc = argv [++ optind];
        }
        else if (argv [optind].equals ("-b")) {
            bcc = argv [++ optind];
        }
        else if (argv [optind].equals ("-L")) {
            url = argv [++ optind];
        }
        else if (argv [optind].equals ("-d")) {
            debug = true;
        }
        else if (argv [optind].equals ("--")) {
            optind ++;
            break;
        }
        else if (argv [optind].startsWith ("-")) {
            System.out.println ("Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]");
            System.out.println ("\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]");
            System.out.println ("\t[-f record-mailbox] [-M transport-host] [-d] [address]");
            System.exit (1);
        }
        else {
            break;
        }
    }
    try {
        if (optind < argv.length) {
            to = argv [optind];
            System.out.println ("To: " + to);
        }
        else {
            System.out.print ("To: ");
            System.out.flush ();
            to = in.readLine ();
        }
        if (subject == null) {
            System.out.print ("Subject: ");
            System.out.flush ();
            subject = in.readLine ();
        }
        else {
            System.out.println ("Subject: " + subject);
        }
        Properties props = System.getProperties ();
        if (mailhost != null) props.put ("mail.smtp.host", mailhost);
        Session session = Session.getInstance (props, null);
        if (debug) session.setDebug (true);
        Message msg = new MimeMessage (session);
        if (from != null) msg.setFrom (new InternetAddress (from));
        else msg.setFrom ();
        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));
        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));
        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));
        msg.setSubject (subject);
        collect (in, msg);
        msg.setHeader ("X-Mailer", mailer);
        msg.setSentDate (new Date ());
        Transport.send (msg);
        System.out.println ("\nMail was sent successfully.");
        if (record != null) {
            Store store = null;
            if (url != null) {
                URLName urln = new URLName (url);
                store = session.getStore (urln);
                store.connect ();
            }
            else {
                if (protocol != null) store = session.getStore (protocol);
                else store = session.getStore ();
                if (host != null || user != null || password != null) store.connect (host, user, password);
                else store.connect ();
            }
            Folder folder = store.getFolder (record);
            if (folder == null) {
                System.err.println ("Can't get record folder.");
                System.exit (1);
            }
            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);
            Message [] msgs = new Message [1];
            msgs [0] = msg;
            folder.appendMessages (msgs);
            System.out.println ("Mail was recorded successfully.");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public sendhtml (String [] argv) {
    String to, subject = null, from = null, cc = null, bcc = null, url = null;
    String mailhost = null;
    String mailer = "sendhtml";
    String protocol = null, host = null, user = null, password = null;
    String record = null;
    boolean debug = false;
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    int optind;
    for (optind = 0; optind < argv.length; optind ++) {
        if (argv [optind].equals ("-T")) {
            protocol = argv [++ optind];
        }
        else if (argv [optind].equals ("-H")) {
            host = argv [++ optind];
        }
        else if (argv [optind].equals ("-U")) {
            user = argv [++ optind];
        }
        else if (argv [optind].equals ("-P")) {
            password = argv [++ optind];
        }
        else if (argv [optind].equals ("-M")) {
            mailhost = argv [++ optind];
        }
        else if (argv [optind].equals ("-f")) {
            record = argv [++ optind];
        }
        else if (argv [optind].equals ("-s")) {
            subject = argv [++ optind];
        }
        else if (argv [optind].equals ("-o")) {
            from = argv [++ optind];
        }
        else if (argv [optind].equals ("-c")) {
            cc = argv [++ optind];
        }
        else if (argv [optind].equals ("-b")) {
            bcc = argv [++ optind];
        }
        else if (argv [optind].equals ("-L")) {
            url = argv [++ optind];
        }
        else if (argv [optind].equals ("-d")) {
            debug = true;
        }
        else if (argv [optind].equals ("--")) {
            optind ++;
            break;
        }
        else if (argv [optind].startsWith ("-")) {
            System.out.println ("Usage: sendhtml [[-L store-url] | [-T prot] [-H host] [-U user] [-P passwd]]");
            System.out.println ("\t[-s subject] [-o from-address] [-c cc-addresses] [-b bcc-addresses]");
            System.out.println ("\t[-f record-mailbox] [-M transport-host] [-d] [address]");
            System.exit (1);
        }
        else {
            break;
        }
    }
    try {
        if (optind < argv.length) {
            to = argv [optind];
            System.out.println ("To: " + to);
        }
        else {
            System.out.print ("To: ");
            System.out.flush ();
            to = in.readLine ();
        }
        if (subject == null) {
            System.out.print ("Subject: ");
            System.out.flush ();
            subject = in.readLine ();
        }
        else {
            System.out.println ("Subject: " + subject);
        }
        Properties props = System.getProperties ();
        if (mailhost != null) props.put ("mail.smtp.host", mailhost);
        Session session = Session.getInstance (props, null);
        if (debug) session.setDebug (true);
        Message msg = new MimeMessage (session);
        if (from != null) msg.setFrom (new InternetAddress (from));
        else msg.setFrom ();
        msg.setRecipients (Message.RecipientType.TO, InternetAddress.parse (to, false));
        if (cc != null) msg.setRecipients (Message.RecipientType.CC, InternetAddress.parse (cc, false));
        if (bcc != null) msg.setRecipients (Message.RecipientType.BCC, InternetAddress.parse (bcc, false));
        msg.setSubject (subject);
        collect (in, msg);
        msg.setHeader ("X-Mailer", mailer);
        msg.setSentDate (new Date ());
        Transport.send (msg);
        System.out.println ("\nMail was sent successfully.");
        if (record != null) {
            Store store = null;
            if (url != null) {
                URLName urln = new URLName (url);
                store = session.getStore (urln);
                store.connect ();
            }
            else {
                if (protocol != null) store = session.getStore (protocol);
                else store = session.getStore ();
                if (host != null || user != null || password != null) store.connect (host, user, password);
                else store.connect ();
            }
            Folder folder = store.getFolder (record);
            if (folder == null) {
                System.err.println ("Can't get record folder.");
                System.exit (1);
            }
            if (! folder.exists ()) folder.create (Folder.HOLDS_MESSAGES);
            Message [] msgs = new Message [1];
            msgs [0] = msg;
            folder.appendMessages (msgs);
            System.out.println ("Mail was recorded successfully.");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=202=-----==

private void displayMessageHeaders (MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
    try {
        out.println ("<b>Date:</b> " + msg.getSentDate () + "<br>");
        Address [] fr = msg.getFrom ();
        if (fr != null) {
            boolean tf = true;
            out.print ("<b>From:</b> ");
            for (int i = 0; i < fr.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (fr [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] to = msg.getRecipients (Message.RecipientType.TO);
        if (to != null) {
            boolean tf = true;
            out.print ("<b>To:</b> ");
            for (int i = 0; i < to.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (to [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] cc = msg.getRecipients (Message.RecipientType.CC);
        if (cc != null) {
            boolean cf = true;
            out.print ("<b>CC:</b> ");
            for (int i = 0; i < cc.length; i ++) {
                out.print (((cf) ? " " : ", ") + getDisplayAddress (cc [i]));
                cf = false;
            }
            out.println ("<br>");
        }
        out.print ("<b>Subject:</b> " + ((msg.getSubject () != null) ? msg.getSubject () : "") + "<br>");
    } catch (MessagingException mex) {
        out.println (msg.toString ());
    }
}


private void displayMessageHeaders (MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
    try {
        out.println ("<b>Date:</b> " + msg.getSentDate () + "<br>");
        Address [] fr = msg.getFrom ();
        if (fr != null) {
            boolean tf = true;
            out.print ("<b>From:</b> ");
            for (int i = 0; i < fr.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (fr [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] to = msg.getRecipients (Message.RecipientType.TO);
        if (to != null) {
            boolean tf = true;
            out.print ("<b>To:</b> ");
            for (int i = 0; i < to.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (to [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] cc = msg.getRecipients (Message.RecipientType.CC);
        if (cc != null) {
            boolean cf = true;
            out.print ("<b>CC:</b> ");
            for (int i = 0; i < cc.length; i ++) {
                out.print (((cf) ? " " : ", ") + getDisplayAddress (cc [i]));
                cf = false;
            }
            out.println ("<br>");
        }
        out.print ("<b>Subject:</b> " + ((msg.getSubject () != null) ? msg.getSubject () : "") + "<br>");
    } catch (MessagingException mex) {
        out.println (msg.toString ());
    }
}


-----Function Pair=203=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=204=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=205=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=206=-----==

private String convertPathRelativeToFile (String filePathToConvert, String filePathFromConvert) {
    String dirFileTo = "";
    String dirFileFrom = "";
    String convertedRelativePath = "";
    int lastSlashTo = filePathToConvert.lastIndexOf ("/");
    int lastSlashFrom = filePathFromConvert.lastIndexOf ("/");
    String fileTo = (lastSlashTo == - 1) ? filePathToConvert : filePathToConvert.substring (lastSlashTo + 1, filePathToConvert.length ());
    if (lastSlashTo == - 1) lastSlashTo = 0;
    if (lastSlashFrom == - 1) lastSlashFrom = 0;
    String pathTo = filePathToConvert.substring (0, lastSlashTo);
    String pathFrom = filePathFromConvert.substring (0, lastSlashFrom);
    StringTokenizer stokTo = new StringTokenizer (pathTo, "/");
    StringTokenizer stokFrom = new StringTokenizer (pathFrom, "/");
    int totalFromTokens = stokFrom.countTokens ();
    for (int fromTokenCounter = 0; fromTokenCounter < totalFromTokens; fromTokenCounter ++) {
        dirFileFrom = stokFrom.nextToken ();
        if ((! convertedRelativePath.contains ("../")) && (stokTo.hasMoreTokens ())) dirFileTo = stokTo.nextToken ();
        else dirFileTo = "";
        if (! dirFileFrom.equals (dirFileTo) || (convertedRelativePath.contains ("../"))) {
            convertedRelativePath = convertedRelativePath.concat ("../");
        }
        else dirFileTo = "";
    }
    if (! dirFileTo.equals ("")) convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    while (stokTo.hasMoreTokens ()) {
        dirFileTo = stokTo.nextToken ();
        convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    }
    convertedRelativePath = convertedRelativePath.concat (fileTo);
    return convertedRelativePath;
}


private String convertPathRelativeToFile (String filePathToConvert, String filePathFromConvert) {
    String dirFileTo = "";
    String dirFileFrom = "";
    String convertedRelativePath = "";
    int lastSlashTo = filePathToConvert.lastIndexOf ("/");
    int lastSlashFrom = filePathFromConvert.lastIndexOf ("/");
    String fileTo = (lastSlashTo == - 1) ? filePathToConvert : filePathToConvert.substring (lastSlashTo + 1, filePathToConvert.length ());
    if (lastSlashTo == - 1) lastSlashTo = 0;
    if (lastSlashFrom == - 1) lastSlashFrom = 0;
    String pathTo = filePathToConvert.substring (0, lastSlashTo);
    String pathFrom = filePathFromConvert.substring (0, lastSlashFrom);
    StringTokenizer stokTo = new StringTokenizer (pathTo, "/");
    StringTokenizer stokFrom = new StringTokenizer (pathFrom, "/");
    int totalFromTokens = stokFrom.countTokens ();
    for (int fromTokenCounter = 0; fromTokenCounter < totalFromTokens; fromTokenCounter ++) {
        dirFileFrom = stokFrom.nextToken ();
        if ((! convertedRelativePath.contains ("../")) && (stokTo.hasMoreTokens ())) dirFileTo = stokTo.nextToken ();
        else dirFileTo = "";
        if (! dirFileFrom.equals (dirFileTo) || (convertedRelativePath.contains ("../"))) {
            convertedRelativePath = convertedRelativePath.concat ("../");
        }
        else dirFileTo = "";
    }
    if (! dirFileTo.equals ("")) convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    while (stokTo.hasMoreTokens ()) {
        dirFileTo = stokTo.nextToken ();
        convertedRelativePath = convertedRelativePath.concat (new StringBuffer (dirFileTo).append ("/").toString ());
    }
    convertedRelativePath = convertedRelativePath.concat (fileTo);
    return convertedRelativePath;
}


-----Function Pair=207=-----==

public static PositionScoreTextData merge (ArrayList < PositionScoreTextData > pdAL) {
    PositionScoreTextData [] pdArray = new PositionScoreTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedPositionScoreTexts.length;
    PositionScoreText [] concatinate = new PositionScoreText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        PositionScoreText [] slice = pdArray [i].sortedPositionScoreTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    PositionScoreTextData.updateSliceInfo (concatinate, sliceInfo);
    return new PositionScoreTextData (concatinate, sliceInfo);
}


public static RegionTextData merge (ArrayList < RegionTextData > pdAL) {
    RegionTextData [] pdArray = new RegionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionTexts.length;
    RegionText [] concatinate = new RegionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionText [] slice = pdArray [i].sortedRegionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionTextData (concatinate, sliceInfo);
}


-----Function Pair=208=-----=1=

public static void zipDirectory (File file, ZipOutputStream out) throws Exception {
    String [] dirList = file.list ();
    byte [] readBuffer = new byte [1024];
    int bytesIn = 0;
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (file, dirList [i]);
        if (f.isDirectory ()) {
            zipDirectory (f, out);
            continue;
        }
        FileInputStream fis = new FileInputStream (f);
        ZipEntry zipEntry = new ZipEntry (f.getPath ());
        out.putNextEntry (zipEntry);
        while ((bytesIn = fis.read (readBuffer)) != - 1) {
            out.write (readBuffer, 0, bytesIn);
        }
        fis.close ();
    }
}


public static void zipDirectory (File inputFile, ZipOutputStream zipOutputStream) throws IOException {
    String [] dirList = inputFile.list ();
    byte [] readBuffer = new byte [1024];
    int bytesIn = 0;
    for (int i = 0; i < dirList.length; i ++) {
        File file = new File (inputFile, dirList [i]);
        if (file.isDirectory ()) {
            zipDirectory (file, zipOutputStream);
            continue;
        }
        FileInputStream fileInputStream = new FileInputStream (file);
        ZipEntry zipEntry = new ZipEntry (file.getPath ());
        zipOutputStream.putNextEntry (zipEntry);
        while ((bytesIn = fileInputStream.read (readBuffer)) != - 1) {
            zipOutputStream.write (readBuffer, 0, bytesIn);
        }
        fileInputStream.close ();
    }
}


-----Function Pair=209=-----==

public void zipContent () {
    if (getText ().equals ("")) return;
    String zipFile = chooseFile (this, SAVE);
    if (zipFile != null) {
        if (! zipFile.endsWith (".zip")) zipFile += ".zip";
        if (! (new File (zipFile)).exists ()) zip (zipFile);
        else {
            int response = JOptionPane.showConfirmDialog (null, "File already exists, overwrite it ?", "Save", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
            switch (response) {
                case 0 :
                    zip (zipFile);
                    break;
                case 1 :
                    break;
                default :
                    return;
            }
        }
    }
}


public void saveContent () {
    String fileToSave = chooseFile (this, SAVE);
    if (fileToSave != null) {
        if (! (new File (fileToSave)).exists ()) save (fileToSave);
        else {
            int response = JOptionPane.showConfirmDialog (null, "File already exists, overwrite it ?", "Save", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
            switch (response) {
                case 0 :
                    save (fileToSave);
                    break;
                case 1 :
                    break;
                default :
                    return;
            }
        }
    }
}


-----Function Pair=210=-----=1=

static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


-----Function Pair=211=-----==

public void zipTo (TFile file) throws TIoException {
    file.write (new OutputProcessor () {
        public void process (OutputManager outputManager) throws IOException {
            ZipOutputStream zipStream = new ZipOutputStream (outputManager.outputStream ());
            outputManager.registerResource (zipStream);
            addDirEntry (zipStream, "", TDirectory.this);
        } private void addDirEntry (ZipOutputStream zipStream, String path, TDirectory directory) throws IOException {
            TFile [] files = directory.listFiles ();
            for (int i = 0; i < files.length; i ++) {
                addFileEntry (zipStream, path, files [i]);
            }
            TDirectory [] directories = directory.listDirs ();
            for (int i = 0; i < directories.length; i ++) {
                TDirectory subDirectory = directories [i];
                addDirEntry (zipStream, path + "/" + subDirectory.name (), subDirectory);
            }
            zipStream.putNextEntry (new ZipEntry (path + "/"));
            zipStream.closeEntry ();
        } private void addFileEntry (ZipOutputStream zipStream, String path, TFile file) throws IOException {
            ZipEntry entry = new ZipEntry (path + file.name ());
            zipStream.putNextEntry (entry);
            file.copyTo (zipStream);
            zipStream.closeEntry ();
        }
    }
    );
}


public void UnListen () {
    if (! running) return;
    switch (event) {
        case EVENT_INSERT :
            EventSubscriber.GetSubscriber ().RemoveListener (InsertEventListener.class, this);
            break;
        case EVENT_UPDATE :
            EventSubscriber.GetSubscriber ().RemoveListener (UpdateEventListener.class, this);
            break;
        case EVENT_DELETE :
            EventSubscriber.GetSubscriber ().RemoveListener (DeleteEventListener.class, this);
            break;
        case EVENT_READY :
            EventSubscriber.GetSubscriber ().RemoveListener (Ready2PublishEventListener.class, this);
            break;
        case EVENT_PUBLISH :
            EventSubscriber.GetSubscriber ().RemoveListener (PublishEventListener.class, this);
            break;
        case EVENT_CANCEL :
            EventSubscriber.GetSubscriber ().RemoveListener (CancelEventListener.class, this);
            break;
    }
    running = false;
}


-----Function Pair=212=-----==

private static void untar (InputStream in, File untarDir) throws IOException {
    log.log (Level.INFO, "Reading TarInputStream... ");
    TarInputStream tin = new TarInputStream (in);
    TarEntry tarEntry = tin.getNextEntry ();
    log.log (Level.INFO, "UNTARDIR " + untarDir);
    if (! untarDir.exists ()) {
        untarDir.mkdir ();
    }
    while (tarEntry != null) {
        File destPath = new File (untarDir.getAbsolutePath () + File.separatorChar + tarEntry.getName ());
        log.log (Level.INFO, "Processing " + destPath.getAbsoluteFile ());
        if (! tarEntry.isDirectory ()) {
            FileOutputStream fout = new FileOutputStream (destPath);
            tin.copyEntryContents (fout);
            fout.close ();
        }
        else {
            destPath.mkdir ();
        }
        tarEntry = tin.getNextEntry ();
    }
    tin.close ();
}


private static void untar (InputStream in, File untarDir) throws IOException {
    log.log (Level.INFO, "Reading TarInputStream... ");
    TarInputStream tin = new TarInputStream (in);
    TarEntry tarEntry = tin.getNextEntry ();
    log.log (Level.INFO, "UNTARDIR " + untarDir);
    if (! untarDir.exists ()) {
        untarDir.mkdir ();
    }
    while (tarEntry != null) {
        File destPath = new File (untarDir.getAbsolutePath () + File.separatorChar + tarEntry.getName ());
        log.log (Level.INFO, "Processing " + destPath.getAbsoluteFile ());
        if (! tarEntry.isDirectory ()) {
            FileOutputStream fout = new FileOutputStream (destPath);
            tin.copyEntryContents (fout);
            fout.close ();
        }
        else {
            destPath.mkdir ();
        }
        tarEntry = tin.getNextEntry ();
    }
    tin.close ();
}


-----Function Pair=213=-----==

public synchronized void disconnectFromServer () {
    if (! isConnected) return;
    try {
        Debug.netMsg ("Writing disconnect message to the server");
        SealedObject sealed_object = new SealedObject ("JFRITZ CLOSE", outCipher);
        objectOut.writeObject (sealed_object);
        objectOut.flush ();
        objectOut.close ();
        objectIn.close ();
        connect = false;
    } catch (IOException e) {
        Debug.error ("Error writing disconnect message to server");
        Debug.error (e.toString ());
        e.printStackTrace ();
    } catch (IllegalBlockSizeException e) {
        Debug.error ("Problems with the block size");
        Debug.error (e.toString ());
        e.printStackTrace ();
    }
}


public synchronized void requestDeleteList () {
    Debug.info ("Requesting server to delete the list from the box");
    actionRequest.action = ClientActionRequest.ActionType.deleteListFromBox;
    try {
        SealedObject sealedActionRequest = new SealedObject (actionRequest, outCipher);
        objectOut.writeObject (sealedActionRequest);
        objectOut.flush ();
        objectOut.reset ();
    } catch (IOException e) {
        Debug.error ("Error writing writing delete list from box request");
        Debug.error (e.toString ());
        e.printStackTrace ();
    } catch (IllegalBlockSizeException e) {
        Debug.error ("Illegal block size exception!");
        Debug.error (e.toString ());
        e.printStackTrace ();
    }
}


-----Function Pair=214=-----==

void convertPropsSequenceToString (SkinProperty newProp) {
    String newPropValue = null;
    String seqPropNamePrefix = newProp.name;
    int index = 0;
    String seqPropName = seqPropNamePrefix + index;
    String seqPropValue = (String) romizedProps.get (seqPropName);
    while (seqPropValue != null) {
        if (newPropValue == null) {
            newPropValue = seqPropValue;
        }
        else {
            newPropValue += "," + seqPropValue;
        }
        index += 1;
        seqPropName = seqPropNamePrefix + index;
        seqPropValue = (String) romizedProps.get (seqPropName);
    }
    newProp.value = newPropValue;
}


void convertPropsSequenceToString (SkinProperty newProp) {
    String newPropValue = null;
    String seqPropNamePrefix = newProp.name;
    int index = 0;
    String seqPropName = seqPropNamePrefix + index;
    String seqPropValue = (String) romizedProps.get (seqPropName);
    while (seqPropValue != null) {
        if (newPropValue == null) {
            newPropValue = seqPropValue;
        }
        else {
            newPropValue += "," + seqPropValue;
        }
        index += 1;
        seqPropName = seqPropNamePrefix + index;
        seqPropValue = (String) romizedProps.get (seqPropName);
    }
    newProp.value = newPropValue;
}


-----Function Pair=215=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=216=-----==

public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=217=-----==

public void doMemoryReadRaw (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    ret.append ("Actual memory (breakpoints shown as is):\n");
    int addr, count;
    switch (args.length) {
        case 0 :
            jdp_console.writeOutput (ret.toString ());
            printHelp (command);
            break;
        case 1 :
            try {
                addr = parseHex32 (args [0]);
                ret.append (user.mem.printRaw (addr, 5));
            } catch (NumberFormatException e) {
                ret.append ("bad address: " + args [0] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
        default :
            try {
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                ret.append (user.mem.printRaw (addr, count));
            } catch (NumberFormatException e) {
                ret.append ("bad address or count: " + args [0] + ", " + args [1] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
    }
}


public void doMemoryReadRaw (String command, String [] args) {
    StringBuffer ret = new StringBuffer ();
    ret.append ("Actual memory (breakpoints shown as is):\n");
    int addr, count;
    switch (args.length) {
        case 0 :
            jdp_console.writeOutput (ret.toString ());
            printHelp (command);
            break;
        case 1 :
            try {
                addr = parseHex32 (args [0]);
                ret.append (user.mem.printRaw (addr, 5));
            } catch (NumberFormatException e) {
                ret.append ("bad address: " + args [0] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
        default :
            try {
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                ret.append (user.mem.printRaw (addr, count));
            } catch (NumberFormatException e) {
                ret.append ("bad address or count: " + args [0] + ", " + args [1] + "\n");
            }
            jdp_console.writeOutput (ret.toString ());
            break;
    }
}


-----Function Pair=218=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=219=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=220=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=221=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=222=-----==

private static Set getOpcodes (Method [] emitters) {
    Set s = new HashSet ();
    for (int i = 0; i < emitters.length; i ++) {
        String name = emitters [i].getName ();
        if (DEBUG) System.out.println (name);
        if (name.startsWith ("emit")) {
            int posOf_ = name.indexOf ('_');
            if (posOf_ != - 1) {
                String opcode = name.substring (4, posOf_);
                if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
            else {
                String opcode = name.substring (4);
                if (opcode.equals (opcode.toUpperCase (Locale.getDefault ()))) if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
        }
    }
    return s;
}


private static Set getOpcodes (Method [] emitters) {
    Set s = new HashSet ();
    for (int i = 0; i < emitters.length; i ++) {
        String name = emitters [i].getName ();
        if (DEBUG) System.out.println (name);
        if (name.startsWith ("emit")) {
            int posOf_ = name.indexOf ('_');
            if (posOf_ != - 1) {
                String opcode = name.substring (4, posOf_);
                if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
            else {
                String opcode = name.substring (4);
                if (opcode.equals (opcode.toUpperCase (Locale.getDefault ()))) if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
        }
    }
    return s;
}


-----Function Pair=223=-----==

public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=224=-----=1=

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=225=-----==

public static void main (String args []) throws Exception {
    Class c = Class.forName ("tInstance");
    tInstance myInstance = (tInstance) c.newInstance ();
    myInstance.ifield = 4;
    myInstance.dfield = 8.8;
    myInstance.bfield = true;
    myInstance.ofield = null;
    System.out.println (c);
    Method methods [] = c.getMethods ();
    Method imethod = null;
    Method dmethod = null;
    Method bmethod = null;
    Method omethod = null;
    Method vmethod = null;
    for (int i = 0; i < methods.length; i ++) {
        String methodName = methods [i].getName ();
        if (methodName.equals ("iuserFunction")) imethod = methods [i];
        else if (methodName.equals ("duserFunction")) dmethod = methods [i];
        else if (methodName.equals ("buserFunction")) bmethod = methods [i];
        else if (methodName.equals ("ouserFunction")) omethod = methods [i];
        else if (methodName.equals ("vuserFunction")) vmethod = methods [i];
    }
    Object [] methodargs = new Object [1];
    if (imethod == null) {
        System.out.println ("tInstance.iuserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + imethod);
        methodargs [0] = new Integer (3);
        int iresult = ((Integer) imethod.invoke (myInstance, methodargs)).intValue ();
        if (iresult != 7) {
            System.out.println ("Wrong answer from iuserFunction");
            System.out.println (iresult);
            System.exit (- 1);
        }
    }
    if (dmethod == null) {
        System.out.println ("tInstance.duserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + dmethod);
        methodargs [0] = new Double (3.4);
        double dresult = ((Double) dmethod.invoke (myInstance, methodargs)).doubleValue ();
        if (dresult < 12.2 || dresult >= 12.2000001) {
            System.out.println ("Wrong answer from duserFunction");
            System.out.println (dresult);
            System.exit (- 1);
        }
    }
    if (bmethod == null) {
        System.out.println ("tInstance.buserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + bmethod);
        methodargs [0] = new Boolean (true);
        boolean bresult = ((Boolean) bmethod.invoke (myInstance, methodargs)).booleanValue ();
        if (bresult != true) {
            System.out.println ("Wrong answer from buserFunction");
            System.exit (- 1);
        }
    }
    if (omethod == null) {
        System.out.println ("tInstance.ouserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + omethod);
        methodargs [0] = new String ("123");
        Object oresult = omethod.invoke (myInstance, methodargs);
        if (! (oresult instanceof java.lang.String) || ! ((java.lang.String) oresult).equals ("123abc")) {
            System.out.println ("Wrong answer from ouserFunction");
            System.exit (- 1);
        }
    }
    if (vmethod == null) {
        System.out.println ("tInstance.vuserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vmethod);
        Object twoargs [] = new Object [2];
        twoargs [0] = new Integer (4);
        twoargs [1] = new Integer (10);
        Object vresult = vmethod.invoke (myInstance, twoargs);
        if ((vresult != null) || (myInstance.ifield != 18)) {
            System.out.println ("Wrong results from vuserFunction");
            System.exit (- 1);
        }
    }
    System.out.println ("Test success");
}


public static void main (String args []) throws Exception {
    Class c = Class.forName ("tInstance");
    tInstance myInstance = (tInstance) c.newInstance ();
    myInstance.ifield = 4;
    myInstance.dfield = 8.8;
    myInstance.bfield = true;
    myInstance.ofield = null;
    System.out.println (c);
    Method methods [] = c.getMethods ();
    Method imethod = null;
    Method dmethod = null;
    Method bmethod = null;
    Method omethod = null;
    Method vmethod = null;
    for (int i = 0; i < methods.length; i ++) {
        String methodName = methods [i].getName ();
        if (methodName.equals ("iuserFunction")) imethod = methods [i];
        else if (methodName.equals ("duserFunction")) dmethod = methods [i];
        else if (methodName.equals ("buserFunction")) bmethod = methods [i];
        else if (methodName.equals ("ouserFunction")) omethod = methods [i];
        else if (methodName.equals ("vuserFunction")) vmethod = methods [i];
    }
    Object [] methodargs = new Object [1];
    if (imethod == null) {
        System.out.println ("tInstance.iuserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + imethod);
        methodargs [0] = new Integer (3);
        int iresult = ((Integer) imethod.invoke (myInstance, methodargs)).intValue ();
        if (iresult != 7) {
            System.out.println ("Wrong answer from iuserFunction");
            System.out.println (iresult);
            System.exit (- 1);
        }
    }
    if (dmethod == null) {
        System.out.println ("tInstance.duserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + dmethod);
        methodargs [0] = new Double (3.4);
        double dresult = ((Double) dmethod.invoke (myInstance, methodargs)).doubleValue ();
        if (dresult < 12.2 || dresult >= 12.2000001) {
            System.out.println ("Wrong answer from duserFunction");
            System.out.println (dresult);
            System.exit (- 1);
        }
    }
    if (bmethod == null) {
        System.out.println ("tInstance.buserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + bmethod);
        methodargs [0] = new Boolean (true);
        boolean bresult = ((Boolean) bmethod.invoke (myInstance, methodargs)).booleanValue ();
        if (bresult != true) {
            System.out.println ("Wrong answer from buserFunction");
            System.exit (- 1);
        }
    }
    if (omethod == null) {
        System.out.println ("tInstance.ouserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + omethod);
        methodargs [0] = new String ("123");
        Object oresult = omethod.invoke (myInstance, methodargs);
        if (! (oresult instanceof java.lang.String) || ! ((java.lang.String) oresult).equals ("123abc")) {
            System.out.println ("Wrong answer from ouserFunction");
            System.exit (- 1);
        }
    }
    if (vmethod == null) {
        System.out.println ("tInstance.vuserFunction not found!");
        System.exit (- 1);
    }
    else {
        System.out.println ("================= READY TO CALL: " + vmethod);
        Object twoargs [] = new Object [2];
        twoargs [0] = new Integer (4);
        twoargs [1] = new Integer (10);
        Object vresult = vmethod.invoke (myInstance, twoargs);
        if ((vresult != null) || (myInstance.ifield != 18)) {
            System.out.println ("Wrong results from vuserFunction");
            System.exit (- 1);
        }
    }
    System.out.println ("Test success");
}


-----Function Pair=226=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=227=-----==

public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                OPTRecord opt = query.getOPT ();
                if (opt != null) udpLength = opt.getPayloadSize ();
                response = generateReply (query, in, udpLength);
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                OPTRecord opt = query.getOPT ();
                if (opt != null) udpLength = opt.getPayloadSize ();
                response = generateReply (query, in, udpLength);
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


-----Function Pair=228=-----=1=

public static void main (String argv []) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


public static void main (String argv []) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


-----Function Pair=229=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=230=-----==

public void test31 () throws Exception {
    CsvWriter writer = new CsvWriter (new PrintWriter (new OutputStreamWriter (new FileOutputStream ("temp.csv"), Charset.forName ("UTF-8"))), ',');
    writer.write (" \t \t");
    writer.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new FileInputStream ("temp.csv"), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
    new File ("temp.csv").delete ();
}


public void test31 () throws Exception {
    CsvWriter writer = new CsvWriter (new PrintWriter (new OutputStreamWriter (new FileOutputStream ("temp.csv"), Charset.forName ("UTF-8"))), ',');
    writer.write (" \t \t");
    writer.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new FileInputStream ("temp.csv"), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
    new File ("temp.csv").delete ();
}


-----Function Pair=231=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=232=-----==

public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=233=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=234=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=235=-----==

public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=236=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=237=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=238=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=239=-----==

public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=240=-----==

public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=241=-----==

public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


-----Function Pair=242=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=243=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=244=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=245=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=246=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=247=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=248=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=249=-----==

public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=250=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=251=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=252=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=253=-----=1=

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=254=-----==

public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=255=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


-----Function Pair=256=-----==

public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test137 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    reader.setSkipEmptyRecords (false);
    Assert.assertFalse (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=257=-----==

public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


-----Function Pair=258=-----==

public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


-----Function Pair=259=-----==

public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


-----Function Pair=260=-----=1=

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setCstrvar ("Goodbye");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=261=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=262=-----==

public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=263=-----==

public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test47 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=264=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=265=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=266=-----==

private void emitSingleton (String opcode, boolean [] [] testsPerformed, int level) {
    EmitterDescriptor ed = (EmitterDescriptor) emitters.iterator ().next ();
    int [] args = ed.getArgs ();
    int count = ed.getCount ();
    for (int i = 0; i < count; i ++) if (! testsPerformed [i] [args [i]]) emitVerify (i, args [i], level);
    int size = ed.getSize ();
    if (size != 0) {
        boolean needed = true;
        for (int i = 0; i < count; i ++) if (testsPerformed [i] [size]) needed = false;
        if (needed) emitVerify (0, size, level);
        if (size == Byte) for (int i = 0; i < count; i ++) if (args [i] == Register) if (currentOpcode.indexOf ("MOVZX") == - 1 && currentOpcode.indexOf ("MOVSX") == - 1) {
            emitTab (level);
            emit ("if (VM.VerifyAssertions && !(");
            emitArgs (i, Register);
            emit (" < 4)) VM.assert(false, inst.toString());\n");
        }
    }
    emitEmitCall (opcode, args, count, level, ed.getSize ());
}


private void emitSingleton (String opcode, boolean [] [] testsPerformed, int level) {
    EmitterDescriptor ed = (EmitterDescriptor) emitters.iterator ().next ();
    int [] args = ed.getArgs ();
    int count = ed.getCount ();
    for (int i = 0; i < count; i ++) if (! testsPerformed [i] [args [i]]) emitVerify (i, args [i], level);
    int size = ed.getSize ();
    if (size != 0) {
        boolean needed = true;
        for (int i = 0; i < count; i ++) if (testsPerformed [i] [size]) needed = false;
        if (needed) emitVerify (0, size, level);
        if (size == Byte) for (int i = 0; i < count; i ++) if (args [i] == Register) if (currentOpcode.indexOf ("MOVZX") == - 1 && currentOpcode.indexOf ("MOVSX") == - 1) {
            emitTab (level);
            emit ("if (VM.VerifyAssertions && !(");
            emitArgs (i, Register);
            emit (" < 4)) VM._assert(false, inst.toString());\n");
        }
    }
    emitEmitCall (opcode, args, count, level, ed.getSize ());
}


-----Function Pair=267=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=268=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=269=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=270=-----==

public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=271=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=272=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=273=-----==

public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=274=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=275=-----==

public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


public void test54 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    Assert.assertFalse (writer.getForceQualifier ());
    writer.setForceQualifier (true);
    Assert.assertTrue (writer.getForceQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \"\"some stuff in quotes\"\"\"\r\n\"1,2\",\"3\",\"blah \"\"some stuff in quotes\"\"\"", data);
}


-----Function Pair=276=-----==

public static Object packageAndInvoke (Object obj, int methodID, int argAddress, VM_Type expectReturnType, boolean skip4Args, boolean isVarArg) throws Exception {
    VM_Magic.pragmaNoOptCompile ();
    VM_Magic.pragmaNoInline ();
    VM_Method targetMethod;
    int returnValue;
    targetMethod = VM_MethodDictionary.getValue (methodID);
    VM_Type returnType = targetMethod.getReturnType ();
    if (expectReturnType == null) {
        if (! returnType.isReferenceType ()) throw new Exception ("Wrong return type for method: expect reference type instead of " + returnType);
    }
    else {
        if (returnType != expectReturnType) throw new Exception ("Wrong return type for method: expect " + expectReturnType + " instead of " + returnType);
    }
    Object [] argObjectArray;
    if (isVarArg) {
        argObjectArray = packageParameterFromVarArg (targetMethod, argAddress);
    }
    else {
        argObjectArray = packageParameterFromJValue (targetMethod, argAddress);
    }
    Object returnObj = VM_Reflection.invoke (targetMethod, obj, argObjectArray, skip4Args);
    return returnObj;
}


public static Object packageAndInvoke (Object obj, int methodID, int argAddress, VM_Type expectReturnType, boolean skip4Args, boolean isVarArg) throws Exception {
    VM_Magic.pragmaNoOptCompile ();
    VM_Magic.pragmaNoInline ();
    VM_Method targetMethod;
    int returnValue;
    targetMethod = VM_MethodDictionary.getValue (methodID);
    VM_Type returnType = targetMethod.getReturnType ();
    if (expectReturnType == null) {
        if (! returnType.isReferenceType ()) throw new Exception ("Wrong return type for method: expect reference type instead of " + returnType);
    }
    else {
        if (returnType != expectReturnType) throw new Exception ("Wrong return type for method: expect " + expectReturnType + " instead of " + returnType);
    }
    Object [] argObjectArray;
    if (isVarArg) {
        argObjectArray = packageParameterFromVarArg (targetMethod, argAddress);
    }
    else {
        argObjectArray = packageParameterFromJValue (targetMethod, argAddress);
    }
    Object returnObj = VM_Reflection.invoke (targetMethod, obj, argObjectArray, skip4Args);
    return returnObj;
}


-----Function Pair=277=-----==

public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


-----Function Pair=278=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=279=-----=1=

public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


public static void main (String argv []) {
    example.setIvar (42);
    example.setSvar ((short) - 31000);
    example.setLvar (65537);
    example.setUivar (123456);
    example.setUsvar (61000);
    example.setUlvar (654321);
    example.setScvar ((byte) - 13);
    example.setUcvar ((short) 251);
    example.setCvar ('S');
    example.setFvar ((float) 3.14159);
    example.setDvar (2.1828);
    example.setStrvar ("Hello World");
    example.setCstrvar ("Goodbye");
    example.setIptrvar (example.new_int (37));
    example.setPtptr (example.new_Point (37, 42));
    example.setName ("Bill");
    System.out.println ("Variables (values printed from Java)");
    System.out.println ("ivar      =" + example.getIvar ());
    System.out.println ("svar      =" + example.getSvar ());
    System.out.println ("lvar      =" + example.getLvar ());
    System.out.println ("uivar     =" + example.getUivar ());
    System.out.println ("usvar     =" + example.getUsvar ());
    System.out.println ("ulvar     =" + example.getUlvar ());
    System.out.println ("scvar     =" + example.getScvar ());
    System.out.println ("ucvar     =" + example.getUcvar ());
    System.out.println ("fvar      =" + example.getFvar ());
    System.out.println ("dvar      =" + example.getDvar ());
    System.out.println ("cvar      =" + (char) example.getCvar ());
    System.out.println ("strvar    =" + example.getStrvar ());
    System.out.println ("cstrvar   =" + example.getCstrvar ());
    System.out.println ("iptrvar   =" + Long.toHexString (SWIGTYPE_p_int.getCPtr (example.getIptrvar ())));
    System.out.println ("name      =" + example.getName ());
    System.out.println ("ptptr     =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPtptr ())) + example.Point_print (example.getPtptr ()));
    System.out.println ("pt        =" + Long.toHexString (SWIGTYPE_p_Point.getCPtr (example.getPt ())) + example.Point_print (example.getPt ()));
    System.out.println ("\nVariables (values printed from C)");
    example.print_vars ();
    System.out.println ("\nNow I'm going to try and modify some read only variables");
    System.out.println ("     Trying to set 'path'");
    try {
        Method m = example.class.getDeclaredMethod ("setPath", new Class [] {String.class});
        m.invoke (example.class, new Object [] {"Whoa!"});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("     Trying to set 'status'");
    try {
        Method m = example.class.getDeclaredMethod ("setStatus", new Class [] {Integer.class});
        m.invoke (example.class, new Object [] {new Integer (0)});
        System.out.println ("Hey, what's going on?!?! This shouldn't work");
    } catch (NoSuchMethodException e) {
        System.out.println ("Good.");
    } catch (Throwable t) {
        System.out.println ("You shouldn't see this!");
    }
    System.out.println ("\nI'm going to try and update a structure variable.\n");
    example.setPt (example.getPtptr ());
    System.out.println ("The new value is");
    example.pt_print ();
    System.out.println ("You should see the value" + example.Point_print (example.getPtptr ()));
}


-----Function Pair=280=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=281=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=282=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=283=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=284=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=285=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=286=-----==

public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


public void test57 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertTrue (writer.getUseTextQualifier ());
    writer.setUseTextQualifier (false);
    Assert.assertFalse (writer.getUseTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=287=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=288=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=289=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=290=-----==

public static void main (String [] args) {
    try {
        out = new FileWriter (System.getProperty ("generateToDir") + "/OPT_Assembler.java");
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    try {
        lowLevelAsm = Class.forName ("com.ibm.JikesRVM.VM_Assembler");
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
    emit ("package com.ibm.JikesRVM.opt;\n\n");
    emit ("import com.ibm.JikesRVM.*;\n\n");
    emit ("import com.ibm.JikesRVM.opt.ir.*;\n\n");
    emit ("\n\n");
    emit ("/**\n");
    emit (" *  This class is the automatically-generated assembler for\n");
    emit (" * the optimizing compiler.  It consists of methods that\n");
    emit (" * understand the possible operand combinations of each\n");
    emit (" * instruction type, and how to translate those operands to\n");
    emit (" * calls to the VM_Assember low-level emit method\n");
    emit (" *\n");
    emit (" * It is generated by GenerateAssembler.java\n");
    emit (" *\n");
    emit (" * @author Julian Dolby\n");
    emit (" */\n");
    emit ("class OPT_Assembler extends OPT_AssemblerBase {\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  This class requires no special construction;\n");
    emitTab (1);
    emit (" * this constructor simply invokes the\n");
    emitTab (1);
    emit (" * constructor for VM_Assembler\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @see VM_Assembler\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("OPT_Assembler(int bcSize, boolean print) {\n");
    emitTab (2);
    emit ("super(bcSize, print);\n");
    emitTab (1);
    emit ("}");
    emit ("\n\n");
    Method [] emitters = lowLevelAsm.getDeclaredMethods ();
    Set opcodes = getOpcodes (emitters);
    Iterator i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        setCurrentOpcode (opcode);
        emitTab (1);
        emit ("/**\n");
        emitTab (1);
        emit (" *  Emit the given instruction, assuming that\n");
        emitTab (1);
        emit (" * it is a " + currentFormat + " instruction\n");
        emitTab (1);
        emit (" * and has a " + currentOpcode + " operator\n");
        emitTab (1);
        emit (" *\n");
        emitTab (1);
        emit (" * @param inst the instruction to assemble\n");
        emitTab (1);
        emit (" */\n");
        emitTab (1);
        emit ("private void do" + opcode + "(OPT_Instruction inst) {\n");
        EmitterSet emitter = buildSetForOpcode (emitters, opcode);
        boolean [] [] tp = new boolean [4] [encoding.length];
        emitter.emitSet (opcode, tp, 2);
        emitTab (1);
        emit ("}\n\n");
    }
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  The number of instructions emitted so far\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("private int instructionCount = 0;\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  Assemble the given instruction\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @param inst the instruction to assemble\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("void doInst(OPT_Instruction inst) {\n");
    emitTab (2);
    emit ("resolveForwardReferences(++instructionCount);\n");
    emitTab (2);
    emit ("switch (inst.getOpcode()) {\n");
    Set emittedOpcodes = new HashSet ();
    i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        Iterator operators = getMatchingOperators (opcode).iterator ();
        while (operators.hasNext ()) {
            Object operator = operators.next ();
            emitTab (3);
            emittedOpcodes.add (operator);
            emit ("case IA32_" + operator + "_opcode:\n");
        }
        emitTab (4);
        emit ("do" + opcode + "(inst);\n");
        emitTab (4);
        emit ("break;\n");
    }
    emittedOpcodes.add ("JCC");
    emitTab (3);
    emit ("case IA32_JCC_opcode:\n");
    emitTab (4);
    emit ("doJCC(inst);\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("JMP");
    emitTab (3);
    emit ("case IA32_JMP_opcode:\n");
    emitTab (4);
    emit ("doJMP(inst);\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IA32_LOCK_opcode:\n");
    emitTab (4);
    emit ("emitLockNextInstruction();\n");
    emitTab (4);
    emit ("break;\n");
    emitTab (3);
    emit ("case IG_PATCH_POINT_opcode:\n");
    emitTab (4);
    emit ("emitPatchPoint();\n");
    emitTab (4);
    emit ("break;\n");
    Set errorOpcodes = getErrorOpcodes (emittedOpcodes);
    if (! errorOpcodes.isEmpty ()) {
        i = errorOpcodes.iterator ();
        while (i.hasNext ()) {
            emitTab (3);
            emit ("case IA32_" + i.next () + "_opcode:\n");
        }
        emitTab (4);
        emit ("throw new OPT_OptimizingCompilerException(inst + \" has unimplemented IA32 opcode (check excludedOpcodes)\");\n");
    }
    emitTab (2);
    emit ("}\n");
    emitTab (2);
    emit ("inst.setmcOffset( mi );\n");
    emitTab (1);
    emit ("}\n\n");
    emit ("\n}\n");
    try {
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public static void main (String [] args) {
    try {
        out = new FileWriter (System.getProperty ("generateToDir") + "/OPT_Assembler.java");
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (1);
    }
    try {
        lowLevelAsm = Class.forName ("com.ibm.JikesRVM.VM_Assembler");
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        System.exit (1);
    }
    emit ("package com.ibm.JikesRVM.opt;\n\n");
    emit ("import com.ibm.JikesRVM.*;\n\n");
    emit ("import com.ibm.JikesRVM.opt.ir.*;\n\n");
    emit ("\n\n");
    emit ("/**\n");
    emit (" *  This class is the automatically-generated assembler for\n");
    emit (" * the optimizing compiler.  It consists of methods that\n");
    emit (" * understand the possible operand combinations of each\n");
    emit (" * instruction type, and how to translate those operands to\n");
    emit (" * calls to the VM_Assember low-level emit method\n");
    emit (" *\n");
    emit (" * It is generated by GenerateAssembler.java\n");
    emit (" *\n");
    emit (" * @author Julian Dolby\n");
    emit (" */\n");
    emit ("class OPT_Assembler extends OPT_AssemblerBase {\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  This class requires no special construction;\n");
    emitTab (1);
    emit (" * this constructor simply invokes the\n");
    emitTab (1);
    emit (" * constructor for VM_Assembler\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @see VM_Assembler\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("OPT_Assembler(int bcSize, boolean print) {\n");
    emitTab (2);
    emit ("super(bcSize, print);\n");
    emitTab (1);
    emit ("}");
    emit ("\n\n");
    Method [] emitters = lowLevelAsm.getDeclaredMethods ();
    Set opcodes = getOpcodes (emitters);
    Iterator i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        setCurrentOpcode (opcode);
        emitTab (1);
        emit ("/**\n");
        emitTab (1);
        emit (" *  Emit the given instruction, assuming that\n");
        emitTab (1);
        emit (" * it is a " + currentFormat + " instruction\n");
        emitTab (1);
        emit (" * and has a " + currentOpcode + " operator\n");
        emitTab (1);
        emit (" *\n");
        emitTab (1);
        emit (" * @param inst the instruction to assemble\n");
        emitTab (1);
        emit (" */\n");
        emitTab (1);
        emit ("private void do" + opcode + "(OPT_Instruction inst) {\n");
        EmitterSet emitter = buildSetForOpcode (emitters, opcode);
        boolean [] [] tp = new boolean [4] [encoding.length];
        emitter.emitSet (opcode, tp, 2);
        emitTab (1);
        emit ("}\n\n");
    }
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  The number of instructions emitted so far\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("private int instructionCount = 0;\n\n");
    emitTab (1);
    emit ("/**\n");
    emitTab (1);
    emit (" *  Assemble the given instruction\n");
    emitTab (1);
    emit (" *\n");
    emitTab (1);
    emit (" * @param inst the instruction to assemble\n");
    emitTab (1);
    emit (" */\n");
    emitTab (1);
    emit ("void doInst(OPT_Instruction inst) {\n");
    emitTab (2);
    emit ("resolveForwardReferences(++instructionCount);\n");
    emitTab (2);
    emit ("switch (inst.getOpcode()) {\n");
    Set emittedOpcodes = new HashSet ();
    i = opcodes.iterator ();
    while (i.hasNext ()) {
        String opcode = (String) i.next ();
        Iterator operators = getMatchingOperators (opcode).iterator ();
        while (operators.hasNext ()) {
            Object operator = operators.next ();
            emitTab (3);
            emittedOpcodes.add (operator);
            emit ("case IA32_" + operator + "_opcode:\n");
        }
        emitTab (4);
        emit ("do" + opcode + "(inst);\n");
        emitTab (4);
        emit ("break;\n");
    }
    emittedOpcodes.add ("JCC");
    emitTab (3);
    emit ("case IA32_JCC_opcode:\n");
    emitTab (4);
    emit ("doJCC(inst);\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("JMP");
    emitTab (3);
    emit ("case IA32_JMP_opcode:\n");
    emitTab (4);
    emit ("doJMP(inst);\n");
    emitTab (4);
    emit ("break;\n");
    emittedOpcodes.add ("LOCK");
    emitTab (3);
    emit ("case IA32_LOCK_opcode:\n");
    emitTab (4);
    emit ("emitLockNextInstruction();\n");
    emitTab (4);
    emit ("break;\n");
    emitTab (3);
    emit ("case IG_PATCH_POINT_opcode:\n");
    emitTab (4);
    emit ("emitPatchPoint();\n");
    emitTab (4);
    emit ("break;\n");
    Set errorOpcodes = getErrorOpcodes (emittedOpcodes);
    if (! errorOpcodes.isEmpty ()) {
        i = errorOpcodes.iterator ();
        while (i.hasNext ()) {
            emitTab (3);
            emit ("case IA32_" + i.next () + "_opcode:\n");
        }
        emitTab (4);
        emit ("throw new OPT_OptimizingCompilerException(inst + \" has unimplemented IA32 opcode (check excludedOpcodes)\");\n");
    }
    emitTab (2);
    emit ("}\n");
    emitTab (2);
    emit ("inst.setmcOffset( mi );\n");
    emitTab (1);
    emit ("}\n\n");
    emit ("\n}\n");
    try {
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=291=-----==

public void perform (OPT_IR ir) {
    OPT_DefUse.computeDU (ir);
    OPT_DefUse.recomputeSSA (ir);
    OPT_SimpleEscape analyzer = new OPT_SimpleEscape ();
    OPT_FI_EscapeSummary summary = analyzer.simpleEscapeAnalysis (ir);
    for (OPT_Register reg = ir.regpool.getFirstRegister (); reg != null; reg = reg.getNext ()) {
        if (! reg.isSSA ()) continue;
        if (reg.defList == null) continue;
        OPT_Instruction def = reg.defList.instruction;
        if (ir.options.SCALAR_REPLACE_AGGREGATES && summary.isMethodLocal (reg)) {
            OPT_AggregateReplacer s = null;
            if ((def.getOpcode () == NEW_opcode) || (def.getOpcode () == NEWARRAY_opcode)) {
                s = getAggregateReplacer (def, ir);
            }
            if (s != null) {
                s.transform ();
            }
        }
        if (ir.options.MONITOR_REMOVAL && summary.isThreadLocal (reg)) {
            OPT_UnsyncReplacer unsync = null;
            if ((def.getOpcode () == NEW_opcode) || (def.getOpcode () == NEWARRAY_opcode)) {
                unsync = getUnsyncReplacer (reg, def, ir);
            }
            if (unsync != null) {
                unsync.transform ();
            }
        }
    }
}


public void perform (OPT_IR ir) {
    OPT_DefUse.computeDU (ir);
    OPT_DefUse.recomputeSSA (ir);
    OPT_SimpleEscape analyzer = new OPT_SimpleEscape ();
    OPT_FI_EscapeSummary summary = analyzer.simpleEscapeAnalysis (ir);
    for (OPT_Register reg = ir.regpool.getFirstRegister (); reg != null; reg = reg.getNext ()) {
        if (! reg.isSSA ()) continue;
        if (reg.defList == null) continue;
        OPT_Instruction def = reg.defList.instruction;
        if (ir.options.SCALAR_REPLACE_AGGREGATES && summary.isMethodLocal (reg)) {
            OPT_AggregateReplacer s = null;
            if ((def.getOpcode () == NEW_opcode) || (def.getOpcode () == NEWARRAY_opcode)) {
                s = getAggregateReplacer (def, ir);
            }
            if (s != null) {
                s.transform ();
            }
        }
        if (ir.options.MONITOR_REMOVAL && summary.isThreadLocal (reg)) {
            OPT_UnsyncReplacer unsync = null;
            if ((def.getOpcode () == NEW_opcode) || (def.getOpcode () == NEWARRAY_opcode)) {
                unsync = getUnsyncReplacer (reg, def, ir);
            }
            if (unsync != null) {
                unsync.transform ();
            }
        }
    }
}


-----Function Pair=292=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=293=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=294=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=295=-----==

public void test82 () throws Exception {
    StringBuilder holder = new StringBuilder (200010);
    for (int i = 0; i < 100000; i ++) {
        holder.append ("a,");
    }
    holder.append ("a");
    CsvReader reader = CsvReader.parse (holder.toString ());
    try {
        reader.readRecord ();
    } catch (Exception ex) {
        assertException (new IOException ("Maximum column count of 100,000 exceeded in record 0. Set the SafetySwitch property to false if you're expecting more than 100,000 columns per record to avoid this error."), ex);
    }
    reader.close ();
}


public void test82 () throws Exception {
    StringBuilder holder = new StringBuilder (200010);
    for (int i = 0; i < 100000; i ++) {
        holder.append ("a,");
    }
    holder.append ("a");
    CsvReader reader = CsvReader.parse (holder.toString ());
    try {
        reader.readRecord ();
    } catch (Exception ex) {
        assertException (new IOException ("Maximum column count of 100,000 exceeded in record 0. Set the SafetySwitch property to false if you're expecting more than 100,000 columns per record to avoid this error."), ex);
    }
    reader.close ();
}


-----Function Pair=296=-----==

public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=297=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=298=-----==

public void test137 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    reader.setSkipEmptyRecords (false);
    Assert.assertFalse (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=299=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=300=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=301=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=302=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=303=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=304=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=305=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=306=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=307=-----==

public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=308=-----==

protected void setRootDir (final File rootFile) {
    if (rootFile.exists ()) {
        config.sidplay2 ().setHVMEC (PathUtils.getPath (rootFile));
        getUiEvents ().fireEvent (ICollectionChanged.class, new ICollectionChanged () {
            @Override
            public File getCollectionRoot () {
                return rootFile;
            }@Override
            public CollectionType getColectionType () {
                return CollectionType.HVMEC;
            }
        }
        );
    }
}


protected void setRootDir (final File rootFile) {
    if (rootFile.exists ()) {
        config.sidplay2 ().setMags (PathUtils.getPath (rootFile));
        getUiEvents ().fireEvent (ICollectionChanged.class, new ICollectionChanged () {
            @Override
            public File getCollectionRoot () {
                return rootFile;
            }@Override
            public CollectionType getColectionType () {
                return CollectionType.MAGS;
            }
        }
        );
    }
}


-----Function Pair=309=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=310=-----==

public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=311=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=312=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=313=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=314=-----==

public static int nullSafeHashCode (Object obj) {
    if (obj == null) {
        return 0;
    }
    if (obj instanceof Object []) {
        return nullSafeHashCode ((Object []) obj);
    }
    if (obj instanceof boolean []) {
        return nullSafeHashCode ((boolean []) obj);
    }
    if (obj instanceof byte []) {
        return nullSafeHashCode ((byte []) obj);
    }
    if (obj instanceof char []) {
        return nullSafeHashCode ((char []) obj);
    }
    if (obj instanceof double []) {
        return nullSafeHashCode ((double []) obj);
    }
    if (obj instanceof float []) {
        return nullSafeHashCode ((float []) obj);
    }
    if (obj instanceof int []) {
        return nullSafeHashCode ((int []) obj);
    }
    if (obj instanceof long []) {
        return nullSafeHashCode ((long []) obj);
    }
    if (obj instanceof short []) {
        return nullSafeHashCode ((short []) obj);
    }
    return obj.hashCode ();
}


public static int nullSafeHashCode (Object obj) {
    if (obj == null) {
        return 0;
    }
    if (obj instanceof Object []) {
        return nullSafeHashCode ((Object []) obj);
    }
    if (obj instanceof boolean []) {
        return nullSafeHashCode ((boolean []) obj);
    }
    if (obj instanceof byte []) {
        return nullSafeHashCode ((byte []) obj);
    }
    if (obj instanceof char []) {
        return nullSafeHashCode ((char []) obj);
    }
    if (obj instanceof double []) {
        return nullSafeHashCode ((double []) obj);
    }
    if (obj instanceof float []) {
        return nullSafeHashCode ((float []) obj);
    }
    if (obj instanceof int []) {
        return nullSafeHashCode ((int []) obj);
    }
    if (obj instanceof long []) {
        return nullSafeHashCode ((long []) obj);
    }
    if (obj instanceof short []) {
        return nullSafeHashCode ((short []) obj);
    }
    return obj.hashCode ();
}


-----Function Pair=315=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=316=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=317=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=318=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=319=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=320=-----==

public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=321=-----==

public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=322=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (String.valueOf (array [i]));
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=323=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (String.valueOf (array [i]));
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=324=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (String.valueOf (array [i]));
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=325=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (String.valueOf (array [i]));
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=326=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=327=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=328=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'" + array [i] + "'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=329=-----==

public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=330=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=331=-----==

public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=332=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=333=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=334=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=335=-----==

public int indexOf (Object o) {
    if (o == null) {
        return DeducedConstant.INDEX_NOT_FOUND;
    }
    int index = 0;
    Iterator it = _collection.iterator ();
    while (it.hasNext ()) {
        Object element = it.next ();
        if (o.equals (element)) {
            return index;
        }
        ++ index;
    }
    return DeducedConstant.INDEX_NOT_FOUND;
}


public int indexOf (Object o) {
    if (o == null) {
        return DeducedConstant.INDEX_NOT_FOUND;
    }
    int index = 0;
    Iterator it = _collection.iteratorByValue ();
    while (it.hasNext ()) {
        Object element = it.next ();
        if (o.equals (element)) {
            return index;
        }
        ++ index;
    }
    return DeducedConstant.INDEX_NOT_FOUND;
}


-----Function Pair=336=-----==

public static String nullSafeToString (short [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=337=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=338=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=339=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=340=-----==

public static Object [] toObjectArray (Object source) {
    if (source instanceof Object []) {
        return (Object []) source;
    }
    if (source == null) {
        return new Object [0];
    }
    if (! source.getClass ().isArray ()) {
        throw new IllegalArgumentException ("Source is not an array: " + source);
    }
    int length = Array.getLength (source);
    if (length == 0) {
        return new Object [0];
    }
    Class < ? > wrapperType = Array.get (source, 0).getClass ();
    Object [] newArray = (Object []) Array.newInstance (wrapperType, length);
    for (int i = 0; i < length; i ++) {
        newArray [i] = Array.get (source, i);
    }
    return newArray;
}


public static Object [] toObjectArray (Object source) {
    if (source instanceof Object []) {
        return (Object []) source;
    }
    if (source == null) {
        return new Object [0];
    }
    if (! source.getClass ().isArray ()) {
        throw new IllegalArgumentException ("Source is not an array: " + source);
    }
    int length = Array.getLength (source);
    if (length == 0) {
        return new Object [0];
    }
    Class wrapperType = Array.get (source, 0).getClass ();
    Object [] newArray = (Object []) Array.newInstance (wrapperType, length);
    for (int i = 0; i < length; i ++) {
        newArray [i] = Array.get (source, i);
    }
    return newArray;
}


-----Function Pair=341=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=342=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=343=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=344=-----=1=

public static void BubbleSortInt2 (int [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                int temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=345=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=346=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=347=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=348=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=349=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=350=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=351=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=352=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=353=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=354=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=355=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=356=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=357=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=358=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=359=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=360=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=361=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=362=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=363=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=364=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=365=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=366=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=367=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=368=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=369=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=370=-----==

public void actionPerformed (ActionEvent e) {
    connConnTxt.setForeground (UIManager.getColor ("Label.foreground"));
    connConnTxt.setVisible (true);
    connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestStart"));
    connConnProgress.setVisible (true);
    (new Thread () {
        private ServerSocket server;
        boolean noOutcome;
        public void run () {
            try {
                int port = Integer.parseInt (connConnPort.getText ());
                final ServerSocket s = Connection.getServer ();
                if (s == null || s.isClosed () || s.getLocalPort () != port) {
                    server = new ServerSocket (port);
                    port = server.getLocalPort ();
                    newConnection ();
                }
                else {
                    port = s.getLocalPort ();
                }
                if (Util.getDebugLevel () > 30) Util.debug ("Port: " + port);
                if (testPort != port) {
                    if (testPort == Util.getPropInt ("connPort")) {
                        Connection.newPortMappings (- 1, port, true);
                    }
                    else {
                        Connection.newPortMappings (testPort, port, true);
                    }
                }
                testPort = port;
                URL url = new URL (Connection.URL_STR + "?req=portcheck&port=" + port);
                URLConnection connection = url.openConnection (Connection.getProxy ());
                connection.setRequestProperty ("User-Agent", Connection.USER_AGENT);
                BufferedReader bufferedRdr = new BufferedReader (new InputStreamReader (connection.getInputStream ()));
                noOutcome = true;
                (new Thread () {
                    public void run () {
                        try {
                            Thread.sleep (12000);
                            if (noOutcome) {
                                connConnTxt.setForeground (ERROR_COLOR);
                                connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestCannotConnect"));
                                connConnProgress.setVisible (false);
                                server.close ();
                            }
                        } catch (Exception e) {
                        }
                    }
                }
                ).start ();
                final String line = bufferedRdr.readLine ();
                bufferedRdr.close ();
                if (line != null && line.equals ("ok")) {
                    connConnTxt.setForeground (SUCCESS_COLOR);
                    connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestOk"));
                }
                else if (line != null && line.equals ("later")) {
                    connConnTxt.setForeground (ERROR_COLOR);
                    connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestTryLater"));
                }
                else {
                    connConnTxt.setForeground (ERROR_COLOR);
                    connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestWrongResponse"));
                }
                connConnProgress.setVisible (false);
            } catch (java.nio.channels.ClosedChannelException e) {
                if (Util.getDebugLevel () > 90) e.printStackTrace ();
            } catch (FileNotFoundException e) {
                connConnTxt.setForeground (ERROR_COLOR);
                connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestCannotConnect") + "\n" + Util.getMsg ("Err_FileNotFound"));
                connConnProgress.setVisible (false);
            } catch (BindException e) {
                connConnTxt.setForeground (ERROR_COLOR);
                connConnTxt.setText (Util.getMsg ("Err_PortInUse") + "!");
                connConnProgress.setVisible (false);
            } catch (SocketException e) {
                connConnTxt.setForeground (ERROR_COLOR);
                connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestCannotConnect") + "\n" + e.getLocalizedMessage ());
                connConnProgress.setVisible (false);
            } catch (Exception e) {
                connConnTxt.setForeground (ERROR_COLOR);
                connConnTxt.setText (Util.getMsg ("Set_Conn_ConnTestCannotConnect") + "\n" + e.toString ());
                connConnProgress.setVisible (false);
                if (Util.getDebugLevel () > 90) e.printStackTrace ();
            } finally {
                noOutcome = false;
                try {
                    if (server != null && ! server.isClosed ()) server.close ();
                } catch (IOException e) {
                    if (Util.getDebugLevel () > 90) e.printStackTrace ();
                }
            }
        } void newConnection () {
            (new Thread () {
                public void run () {
                    try {
                        final Socket socket = server.accept ();
                        newConnection ();
                        socket.setKeepAlive (true);
                        BufferedReader in = new BufferedReader (new InputStreamReader (socket.getInputStream ()));
                        String ln;
                        while ((ln = in.readLine ()) != null) {
                            if (Util.getDebugLevel () > 30) Util.debug (ln);
                            if (ln.equals ("\0c\0h\0e\0c\0k\0u\0p\0")) {
                                socket.getOutputStream ().write (new byte [] {0, 'O', 0, 'k'});
                                socket.close ();
                            }
                            else {
                                final char c = (ln.length () > 0 ? ln.charAt (0) : 0);
                                socket.getOutputStream ().write (new byte [] {0, 'U', (byte) (c>> 8), (byte) c});
                            }
                        }
                    } catch (SocketException e) {
                        if (Util.getDebugLevel () > 68) {
                            if (! e.getMessage ().equals ("socket closed")) {
                                e.printStackTrace ();
                            }
                        }
                    } catch (IOException e) {
                        if (Util.getDebugLevel () > 90) e.printStackTrace ();
                    }
                }
            }
            ).start ();
        }
    }
    ).start ();
}


public void actionPerformed (java.awt.event.ActionEvent e) {
    new Thread () {
        public void run () {
            File file = TokenTool.getFrame ().showSaveDialog ();
            if (file != null) {
                if (! file.getName ().toUpperCase ().endsWith (".PNG")) {
                    file = new File (file.getAbsolutePath () + ".png");
                }
                if (file.exists ()) {
                    if (! TokenTool.confirm ("File exists.  Overwrite?")) {
                        return;
                    }
                }
                try {
                    BufferedImage img = TokenTool.getFrame ().getComposedToken ();
                    ImageWriter writer = getImageWriterBySuffix ("png");
                    writer.setOutput (ImageIO.createImageOutputStream (file));
                    ImageWriteParam param = writer.getDefaultWriteParam ();
                    PNGMetadata png = new PNGMetadata ();
                    int resX = (int) (img.getWidth () * 39.375f);
                    png.pHYs_pixelsPerUnitXAxis = resX;
                    png.pHYs_pixelsPerUnitYAxis = resX;
                    png.pHYs_unitSpecifier = 1;
                    png.pHYs_present = true;
                    writer.write (null, new IIOImage (img, null, png), param);
                } catch (IOException ioe) {
                    ioe.printStackTrace ();
                    TokenTool.showError ("Unable to write image: " + ioe);
                }
            }
        }
    }
    .start ();
}


-----Function Pair=371=-----==

void calcNewValueHeightSpin () {
    if (this.doUpdateBounds) {
        int newHeight = Integer.valueOf (ScreenShare.instance.jVScreenHeightSpin.getValue ().toString ()).intValue ();
        if (VirtualScreenBean.vScreenSpinnerY + newHeight > VirtualScreenBean.screenHeightMax) {
            newHeight = VirtualScreenBean.screenHeightMax - VirtualScreenBean.vScreenSpinnerY;
            ScreenShare.instance.jVScreenHeightSpin.setValue (newHeight);
            if (this.showWarning) ScreenShare.instance.showBandwidthWarning ("Reduce the y of the SharingScreen before you try to make it higher");
        }
        else {
            VirtualScreenBean.vScreenSpinnerHeight = newHeight;
            updateVScreenBounds ();
        }
    }
    else {
        VirtualScreenBean.vScreenSpinnerHeight = Integer.valueOf (ScreenShare.instance.jVScreenHeightSpin.getValue ().toString ()).intValue ();
    }
}


void calcNewValueHeightSpin () {
    if (this.doUpdateBounds) {
        int newHeight = Integer.valueOf (ScreenShareRTMPT.instance.jVScreenHeightSpin.getValue ().toString ()).intValue ();
        if (VirtualScreenBean.vScreenSpinnerY + newHeight > VirtualScreenBean.screenHeightMax) {
            newHeight = VirtualScreenBean.screenHeightMax - VirtualScreenBean.vScreenSpinnerY;
            ScreenShareRTMPT.instance.jVScreenHeightSpin.setValue (newHeight);
            if (this.showWarning) ScreenShareRTMPT.instance.showBandwidthWarning ("Reduce the y of the SharingScreen before you try to make it higher");
        }
        else {
            VirtualScreenBean.vScreenSpinnerHeight = newHeight;
            updateVScreenBounds ();
        }
    }
    else {
        VirtualScreenBean.vScreenSpinnerHeight = Integer.valueOf (ScreenShareRTMPT.instance.jVScreenHeightSpin.getValue ().toString ()).intValue ();
    }
}


-----Function Pair=372=-----==

private void sort (int l, int r) {
    int i, j;
    if ((r - l) > 4) {
        i = (r + l) / 2;
        switch (sort_criteria) {
            case SORT_BYNAME :
                String s1 = chans [i].getTag ();
                String s2 = chans [l].getTag ();
                String s3 = chans [r].getTag ();
                if (collator.compare (s2, s1) < 0) swap (l, i);
                if (collator.compare (s2, s3) < 0) swap (l, r);
                if (collator.compare (s1, s3) < 0) swap (i, r);
                break;
            case SORT_BYNUM :
                int comp1 = chans [i].getUsers ();
                int comp2 = chans [l].getUsers ();
                int comp3 = chans [r].getUsers ();
                if (comp2 < comp1) swap (l, i);
                if (comp2 < comp3) swap (l, r);
                if (comp1 < comp3) swap (i, r);
        }
        j = r - 1;
        swap (i, j);
        i = l;
        switch (sort_criteria) {
            case SORT_BYNAME :
                String v = chans [j].getTag ();
                for (;;) {
                    while (collator.compare (chans [++ i].getTag (), v) > 0);
                    while (collator.compare (chans [-- j].getTag (), v) < 0);
                    if (j < i) break;
                    swap (i, j);
                }
                break;
            case SORT_BYNUM :
                int w = chans [j].getUsers ();
                for (;;) {
                    while (chans [++ i].getUsers () > w);
                    while (chans [-- j].getUsers () < w);
                    if (j < i) break;
                    swap (i, j);
                }
        }
        swap (i, r - 1);
        sort (l, j);
        sort (i + 1, r);
    }
}


private void sort (int l, int r) {
    int i, j;
    if ((r - l) > 4) {
        i = (r + l) / 2;
        switch (sort_criteria) {
            case SORT_BYNAME :
                String s1 = chans [i].getTag ();
                String s2 = chans [l].getTag ();
                String s3 = chans [r].getTag ();
                if (collator.compare (s2, s1) < 0) swap (l, i);
                if (collator.compare (s2, s3) < 0) swap (l, r);
                if (collator.compare (s1, s3) < 0) swap (i, r);
                break;
            case SORT_BYNUM :
                int comp1 = chans [i].getUsers ();
                int comp2 = chans [l].getUsers ();
                int comp3 = chans [r].getUsers ();
                if (comp2 < comp1) swap (l, i);
                if (comp2 < comp3) swap (l, r);
                if (comp1 < comp3) swap (i, r);
        }
        j = r - 1;
        swap (i, j);
        i = l;
        switch (sort_criteria) {
            case SORT_BYNAME :
                String v = chans [j].getTag ();
                for (;;) {
                    while (collator.compare (chans [++ i].getTag (), v) > 0);
                    while (collator.compare (chans [-- j].getTag (), v) < 0);
                    if (j < i) break;
                    swap (i, j);
                }
                break;
            case SORT_BYNUM :
                int w = chans [j].getUsers ();
                for (;;) {
                    while (chans [++ i].getUsers () > w);
                    while (chans [-- j].getUsers () < w);
                    if (j < i) break;
                    swap (i, j);
                }
        }
        swap (i, r - 1);
        sort (l, j);
        sort (i + 1, r);
    }
}


-----Function Pair=373=-----==

private static void delete (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("DELETE FROM Address");
        query.executeUpdate ();
        query = session.createQuery ("DELETE FROM Person");
        query.executeUpdate ();
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=374=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            person.getAddresses ().add (address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


-----Function Pair=375=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=376=-----==

protected synchronized List getList () throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    List result = new ArrayList ();
    synchronized (dbConn) {
        try {
            sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD A ");
            sqlStat.append ("WHERE  A.RECORD_STATUS = ? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            this.setPrepareStatement (preStat, 1, GlobalConstant.RECORD_STATUS_ACTIVE);
            rs = preStat.executeQuery ();
            while (rs.next ()) {
                DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
                tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
                tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
                tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
                tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
                tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
                tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
                tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
                tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
                tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
                tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
                tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
                tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
                result.add (tmpDmsRelationalWord);
            }
            return (result);
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
        } finally {
            try {
                rs.close ();
            } catch (Exception ignore) {
            } finally {
                rs = null;
            }
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


protected synchronized List getList () throws ApplicationException {
    PreparedStatement preStat = null;
    ResultSet rs = null;
    StringBuffer sqlStat = new StringBuffer ();
    List result = new ArrayList ();
    synchronized (dbConn) {
        try {
            sqlStat.append ("SELECT A.ID, A.RECORD_STATUS, A.UPDATE_COUNT, A.CREATOR_ID, A.CREATE_DATE, A.UPDATER_ID, A.UPDATE_DATE, A.WORD, A.PARENT_ID, A.TYPE ");
            sqlStat.append ("FROM   DMS_RELATIONAL_WORD A ");
            sqlStat.append ("WHERE  A.RECORD_STATUS = ? ");
            preStat = dbConn.prepareStatement (sqlStat.toString (), ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
            this.setPrepareStatement (preStat, 1, GlobalConstant.RECORD_STATUS_ACTIVE);
            rs = preStat.executeQuery ();
            while (rs.next ()) {
                DmsRelationalWord tmpDmsRelationalWord = new DmsRelationalWord ();
                tmpDmsRelationalWord.setID (getResultSetInteger (rs, "ID"));
                tmpDmsRelationalWord.setRecordStatus (getResultSetString (rs, "RECORD_STATUS"));
                tmpDmsRelationalWord.setUpdateCount (getResultSetInteger (rs, "UPDATE_COUNT"));
                tmpDmsRelationalWord.setCreatorID (getResultSetInteger (rs, "CREATOR_ID"));
                tmpDmsRelationalWord.setCreateDate (getResultSetTimestamp (rs, "CREATE_DATE"));
                tmpDmsRelationalWord.setUpdaterID (getResultSetInteger (rs, "UPDATER_ID"));
                tmpDmsRelationalWord.setUpdateDate (getResultSetTimestamp (rs, "UPDATE_DATE"));
                tmpDmsRelationalWord.setWord (getResultSetString (rs, "WORD"));
                tmpDmsRelationalWord.setParentID (getResultSetInteger (rs, "PARENT_ID"));
                tmpDmsRelationalWord.setType (getResultSetString (rs, "TYPE"));
                tmpDmsRelationalWord.setCreatorName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getCreatorID ()));
                tmpDmsRelationalWord.setUpdaterName (UserInfoFactory.getUserFullName (tmpDmsRelationalWord.getUpdaterID ()));
                result.add (tmpDmsRelationalWord);
            }
            return (result);
        } catch (ApplicationException appEx) {
            throw appEx;
        } catch (SQLException sqle) {
            log.error (sqle, sqle);
            throw new ApplicationException (ErrorConstant.DB_GENERAL_ERROR, sqle, sqle.toString ());
        } catch (Exception e) {
            log.error (e, e);
            throw new ApplicationException (ErrorConstant.DB_SELECT_ERROR, e);
        } finally {
            try {
                rs.close ();
            } catch (Exception ignore) {
            } finally {
                rs = null;
            }
            try {
                preStat.close ();
            } catch (Exception ignore) {
            } finally {
                preStat = null;
            }
        }
    }
}


-----Function Pair=377=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query with fetchplan ***");
        querywithfetchplan (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update and query with jpa ***");
        updateandquerywithjpa (entityManagerFactory);
        System.out.println ("*** update and query with native criteria api ***");
        updateandquerywithcriteria (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=378=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=379=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=380=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        LOGGER.info ("*** insert ***");
        insert (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** update ***");
        update (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        LOGGER.info ("*** insert ***");
        insert (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** update ***");
        update (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


-----Function Pair=381=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        query = entityManager.createQuery ("DELETE FROM Address a");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=382=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setUniquePersonNumber ("1234-567");
        person.setUpnIssuer ("FRO-TX");
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        person.getAddresses ().add ("Main Road 12 - Oakwood");
        person.getAddresses ().add ("Sunshine Boulevard 211 - Austin");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=383=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nForumPostId) {
    ToForumPost toForumPost = new ToForumPostDAO ().findById (nForumPostId);
    if (toForumPost == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("forumPost.search.notFound"));
    }
    else {
        List < ToForumPost > list = new ArrayList < ToForumPost > ();
        EntityManagerHelper.refresh (toForumPost);
        list.add (toForumPost);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forumPost.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nForumId) {
    ToForum toForum = new ToForumDAO ().findById (nForumId);
    if (toForum == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("forum.search.notFound"));
    }
    else {
        List < ToForum > list = new ArrayList < ToForum > ();
        EntityManagerHelper.refresh (toForum);
        list.add (toForum);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=384=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=385=-----==

public void testDatetimeRounding10 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 999);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 2);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 0);
    receiveValue.set (Calendar.MINUTE, 0);
    receiveValue.set (Calendar.SECOND, 0);
    receiveValue.set (Calendar.MILLISECOND, 0);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr10 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr10 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr10");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public void testDatetimeRounding5 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 994);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 993);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr5 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr5 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr5");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


-----Function Pair=386=-----==

public void testDatetimeRounding8 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 997);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 997);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr8 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr8 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr8");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public void testDatetimeRounding9 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 998);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 997);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr9 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr9 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr9");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


-----Function Pair=387=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setName ("Jesse James");
        person.setWeight (1.3d);
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=388=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=389=-----==

public static void main (String [] args) {
    SessionFactory sessionFactory = new Configuration ().configure ().buildSessionFactory ();
    try {
        LOGGER.info ("*** insert ***");
        insert (sessionFactory);
        LOGGER.info ("*** query ***");
        query (sessionFactory);
        LOGGER.info ("*** update ***");
        update (sessionFactory);
        LOGGER.info ("*** query ***");
        query (sessionFactory);
        LOGGER.info ("*** delete ***");
        delete (sessionFactory);
    } finally {
        sessionFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=390=-----==

public Cliente getCliente (int id) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.getCliente()");
    Cliente cli = new Cliente ();
    cli.setId (id);
    String sql;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        sql = "SELECT id, nif, nombre, apellido1, apellido2, " + "direccion, poblacion, telefono, movil, email, fecha_baja, " + "pasword, desactivado, cod_cliente, tarjeta_credito, puntos " + "FROM persona, usuario, cliente " + "WHERE id=cod_cliente AND cod_usuario=id AND id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (sql);
        System.out.println ("executeQuery");
        if (rs.next ()) {
            cli.setId (id);
            cli.setNif (rs.getString ("nif"));
            cli.setNombre (rs.getString ("nombre"));
            cli.setApellido1 (rs.getString ("apellido1"));
            cli.setApellido2 (rs.getString ("apellido2"));
            cli.setDireccion (rs.getString ("direccion"));
            cli.setPoblacion (rs.getString ("poblacion"));
            cli.setTelefono (rs.getString ("telefono"));
            cli.setMovil (rs.getString ("movil"));
            cli.setEmail (rs.getString ("email"));
            cli.setFechaBaja (rs.getDate ("fecha_baja"));
            cli.setPassword (rs.getString ("pasword"));
            cli.setCodUsuario (Util.generarCodigo (rs.getInt ("cod_cliente")));
            cli.setTarjetaCredito (rs.getString ("tarjeta_credito"));
            cli.setPuntos (rs.getInt ("puntos"));
            System.out.println ("Cargados datos de persona y cliente");
        }
        else {
            System.out.println ("cliente " + id + " no encontrado.");
        }
        stmt.close ();
        rs.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    }
    return cli;
}


public Cliente getCliente (int id) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.getCliente()");
    Cliente cli = new Cliente ();
    cli.setId (id);
    String sql;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        sql = "SELECT id, nif, nombre, apellido1, apellido2, " + "direccion, poblacion, telefono, movil, email, fecha_baja, " + "pasword, desactivado, cod_cliente, tarjeta_credito, puntos " + "FROM persona, usuario, cliente " + "WHERE id=cod_cliente AND cod_usuario=id AND id=" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        rs = stmt.executeQuery (sql);
        System.out.println ("executeQuery");
        if (rs.next ()) {
            cli.setId (id);
            cli.setNif (rs.getString ("nif"));
            cli.setNombre (rs.getString ("nombre"));
            cli.setApellido1 (rs.getString ("apellido1"));
            cli.setApellido2 (rs.getString ("apellido2"));
            cli.setDireccion (rs.getString ("direccion"));
            cli.setPoblacion (rs.getString ("poblacion"));
            cli.setTelefono (rs.getString ("telefono"));
            cli.setMovil (rs.getString ("movil"));
            cli.setEmail (rs.getString ("email"));
            cli.setFechaBaja (rs.getDate ("fecha_baja"));
            cli.setPassword (rs.getString ("pasword"));
            cli.setCodUsuario (rs.getString ("cod_cliente"));
            cli.setTarjetaCredito (rs.getString ("tarjeta_credito"));
            cli.setPuntos (rs.getInt ("puntos"));
            System.out.println ("Cargados datos de persona y cliente");
        }
        else {
            System.out.println ("cliente " + id + " no encontrado.");
        }
        stmt.close ();
        rs.close ();
    } catch (SQLException e) {
        throw new errorSQL (e.toString ());
    }
    return cli;
}


-----Function Pair=391=-----==

public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("P�rez");
            c.setApellido2 ("G�mez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


public static void main (String [] args) {
    Cliente c = new Cliente ();
    try {
        GestorCliente gCli = new GestorCliente ();
        try {
            c.setId (2);
            c.setNif ("12345679");
            c.setNombre ("Pepe");
            c.setApellido1 ("P�rez");
            c.setApellido2 ("G�mez");
            c.setDireccion ("C/Saboya 12-3");
            c.setPoblacion ("Barcelona");
            c.setTelefono ("93666555");
            c.setMovil ("666 001122");
            c.setEmail ("un.correo@no.es");
            c.setCodUsuario ("2");
            c.setTarjetaCredito ("123456789");
            gCli.addCliente (c);
        } catch (errorSQL e) {
            System.out.println (e.getMessage ());
        }
    } catch (errorConexionBD e) {
        System.out.println (e.getMessage ());
    }
}


-----Function Pair=392=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nPublicationId) {
    ToPublication coNews = new ToPublicationDAO ().findById (nPublicationId);
    if (coNews == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("publication.search.notFound"));
    }
    else {
        List < ToPublication > list = new ArrayList < ToPublication > ();
        EntityManagerHelper.refresh (coNews);
        list.add (coNews);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("publication.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nThemesId) {
    ToThemes toThemes = new ToThemesDAO ().findById (nThemesId);
    if (toThemes == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("theme.search.notFound"));
    }
    else {
        List < ToThemes > list = new ArrayList < ToThemes > ();
        EntityManagerHelper.refresh (toThemes);
        list.add (toThemes);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("theme.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


-----Function Pair=393=-----==

public boolean deleteFavoritesByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Favorites as f where f.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException er) {
        if (tr != null) {
            tr.rollback ();
        }
        er.printStackTrace ();
    }
    return false;
}


public boolean deleteFavoritesByTid (int tid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Favorites as f where f.id.tid=?");
        query.setParameter (0, tid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=394=-----==

public boolean deleteFavoritesByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Favorites as f where f.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException er) {
        if (tr != null) {
            tr.rollback ();
        }
        er.printStackTrace ();
    }
    return false;
}


public boolean deleteSubscriptionByUid (int uid) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("delete from Subscriptions as s where s.id.uid=?");
        query.setParameter (0, uid);
        query.executeUpdate ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=395=-----==

public Integer getUserRoleCount (Integer userId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (AcUserRole.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" acUser.id = '" + userId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


public Integer getAllProjectAppointmentCount (int projectId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (DoAppointments.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" doProject.id = '" + projectId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=396=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=397=-----==

private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Person person = new Person ();
        person.setFirstName ("Jesse");
        person.setLastName ("James");
        entityManager.persist (person);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=398=-----==

public RestServiceResult delete (RestServiceResult serviceResult, ToNews toNews) {
    try {
        log.info ("Eliminando el anuncio: " + toNews.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_NEWS);
        query.setParameter (1, toNews.getNewsId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toNews);
        Object [] arrayParam = {toNews.getTitle ()};
        log.info ("Anuncio eliminado con �xito: " + toNews.getTitle ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el anuncio: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toNews.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, ToComment toComment) {
    try {
        log.info ("Eliminando la publicacion: " + toComment.getCommentId ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_COMMENT);
        query.setParameter (1, toComment.getCommentId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toComment);
        Object [] arrayParam = {toComment.getCommentId ()};
        log.info ("Publicacion eliminada con �xito: " + toComment.getCommentId ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la publicacion: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toComment.getCommentId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("comment.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=399=-----==

public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


public static void query (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            System.out.println ("found: " + person);
            for (Address address : person.getAddresses ()) {
                System.out.println ("  with address: " + address);
            }
        }
    } finally {
        entityManager.close ();
    }
}


-----Function Pair=400=-----==

public BaseClass (int clsId, boolean t) {
    this.clsId = clsId;
    dao = DAO.getInstance ();
    dao.query (Resources.SELECT_CLS_SQL);
    dao.setInt (1, clsId);
    ResultSet rs = dao.executeQuery ();
    try {
        if (rs.next ()) {
            clsName = rs.getString ("CLSNAME");
            basicSQL = rs.getString ("BASICSQL");
            defCL = rs.getInt ("DEFCL");
        }
        rs.close ();
    } catch (SQLException sqle) {
    }
    initialMainTableName ();
    initialColumns ();
    initialI18n ();
    initialSlayerMaster ();
    initialGroupnames ();
    initialPkColumns ();
    initialRowType ();
    initialRows ();
}


public BaseClass (int clsId) {
    this.clsId = clsId;
    dao = DAO.getInstance ();
    dao.query (Resources.SELECT_CLS_SQL);
    dao.setInt (1, clsId);
    ResultSet rs = dao.executeQuery ();
    try {
        if (rs.next ()) {
            clsName = rs.getString ("CLSNAME");
            basicSQL = rs.getString ("BASICSQL");
            defCL = rs.getInt ("DEFCL");
        }
        rs.close ();
    } catch (SQLException sqle) {
    }
    initialMainTableName ();
    initialColumns ();
    initialI18n ();
    initialSlayerMaster ();
    initialGroupnames ();
    initialPkColumns ();
    initialRowType ();
    initialRows ();
}


